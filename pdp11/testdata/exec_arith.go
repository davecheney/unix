// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
)

var ops = []string{
	"add",
	"ash",
	"ashc",
	"ashc1",
	"bic",
	"bicb",
	"bis",
	"bisb",
	"bit",
	"bitb",
	"cmp",
	"cmpb",
	"div",
	"mov",
	"movb",
	"mul",
	"mul1",
	"sub",
	"xor",
}

var vals = []uint16{
	0,
	1,
	2,
	0o177,
	0o200,
	0o377,
	0o400,
	0o077777,
	0o100000,
	0o177776,
	0o177777,
}

func main() {
	for _, op := range ops {
		var b bytes.Buffer
		fmt.Fprintf(&b, "// generated by go run exec_arith.go\n")
		for _, x := range vals {
			for _, y := range vals {
				x := x
				fmt.Fprintf(&b, "\nmov #%06o, r1\nmov #%06o, r0\n%s r1, r0\n", x, y, op)
				n, z, v, c := int16(y) < 0, y == 0, false, false
				switch op {
				case "mov":
					y = x
					n, z, v = int16(y) < 0, y == 0, false
				case "movb":
					y = uint16(int8(x)) // movb to register sign-extends
					n, z, v = int8(y) < 0, uint8(y) == 0, false
				case "add":
					oy := y
					u := uint32(y) + uint32(x)
					y = uint16(u)
					n, z, v, c = int16(y) < 0, y == 0, (int16(x) < 0) == (int16(oy) < 0) && (int16(x) < 0) != (int16(y) < 0), u>>16 != 0
				case "sub":
					oy := y
					u := uint32(y) - uint32(x)
					y = uint16(u)
					n, z, v, c = int16(y) < 0, y == 0, (int16(x) < 0) != (int16(oy) < 0) && (int16(x) < 0) == (int16(y) < 0), u>>16 != 0
				case "cmp":
					u := uint32(x) - uint32(y)
					t := uint16(u)
					n, z, v, c = int16(t) < 0, t == 0, (int16(x) < 0) != (int16(y) < 0) && (int16(y) < 0) == (int16(t) < 0), u>>16 != 0
				case "cmpb":
					t := (x & 0o377) - (y & 0o377)
					n, z, v, c = int8(t) < 0, uint8(t) == 0, (int8(x) < 0) != (int8(y) < 0) && (int8(y) < 0) == (int8(t) < 0), t>>8 != 0
				case "ash":
					oy := y
					sh := int16(x) << 10 >> 10
					if sh < 0 {
						y = uint16(int16(y) >> -sh)
						c = (oy>>(-sh-1))&1 != 0
					} else if sh > 0 {
						y <<= sh
						c = (oy<<(sh-1))>>15 != 0
					} else {
						c = false
					}
					n, z, v = int16(y) < 0, y == 0, (int16(y) < 0) != (int16(oy) < 0)
				case "bic":
					y &^= x
					n, z, v = int16(y) < 0, y == 0, false
				case "bicb":
					y &^= x & 0o377
					n, z, v = int8(y) < 0, uint8(y) == 0, false
				case "bis":
					y |= x
					n, z, v = int16(y) < 0, y == 0, false
				case "bisb":
					y |= x & 0o377
					n, z, v = int8(y) < 0, uint8(y) == 0, false
				case "bit":
					t := x & y
					n, z, v = int16(t) < 0, t == 0, false
				case "bitb":
					t := x & y & 0o377
					n, z, v = int8(t) < 0, uint8(t) == 0, false
				case "xor":
					y ^= x
					n, z, v = int16(y) < 0, y == 0, false
				}
				fmt.Fprintf(&b, "now")
				r0, r1 := y, x
				if op == "ashc1" || op == "mul1" {
					r0, r1 = x, y
				}
				if r0 != 0 {
					fmt.Fprintf(&b, " r0=%06o", r0)
				}
				if r1 != 0 {
					fmt.Fprintf(&b, " r1=%06o", r1)
				}
				if n || z || v || c {
					fmt.Fprintf(&b, " nzvc=%d%d%d%d", bit(n), bit(z), bit(v), bit(c))
				}
				if r0 == 0 && r1 == 0 && !n && !z && !v && !c {
					fmt.Fprintf(&b, " ~")
				}
				fmt.Fprint(&b, "\n")
			}
		}

		if err := os.WriteFile("exec_"+op+".txt", b.Bytes(), 0666); err != nil {
			log.Fatal(err)
		}
	}
}

func bit(b bool) uint16 {
	if b {
		return 1
	}
	return 0
}
