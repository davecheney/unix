// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
)

var ops = []string{
	"adc",
	"adcb",
	"asl",
	"aslb",
	"asr",
	"asrb",
	"clr",
	"clrb",
	"com",
	"comb",
	"dec",
	"decb",
	"inc",
	"incb",
	"neg",
	"negb",
	"rol",
	"rolb",
	"ror",
	"rorb",
	"sbc",
	"sbcb",
	"swab",
	"sxt",
	"tst",
	"tstb",
}

var vals = []uint16{
	0,
	1,
	2,
	0o123,
	0o177,
	0o200,
	0o377,
	0o400,
	0o077400,
	0o077777,
	0o100000,
	0o177777,
	0o107070,
	0o170707,
	0o177400,
	0o177776,
	0o177777,
}

func main() {
	for _, op := range ops {
		var b bytes.Buffer
		fmt.Fprintf(&b, "// generated by go run exec_unary.go\n")
		for _, c := range []bool{false, true} {
			for _, x := range vals {
				c := c
				fmt.Fprintf(&b, "\nccc\n")
				if c {
					fmt.Fprintf(&b, "sec\n")
				}
				fmt.Fprintf(&b, "mov #%06o, r1\n%s r1\n", x, op)
				n, z, v := int16(x) < 0, x == 0, false
				ox := x
				xb := uint8(x)
				oxb := xb
				switch op {
				default:
					panic("badname")
				case "clr":
					x = 0
					n, z, v, c = false, true, false, false
				case "clrb":
					xb = 0
					n, z, v, c = false, true, false, false
				case "swab":
					x = x<<8 | x>>8
					n, z, v, c = int8(uint8(x)) < 0, uint8(x) == 0, false, false
				case "com":
					x = ^x
					n, z, v, c = int16(x) < 0, x == 0, false, true
				case "comb":
					xb = ^xb
					n, z, v, c = int8(xb) < 0, xb == 0, false, true
				case "inc":
					x++
					n, z, v, c = int16(x) < 0, x == 0, x == 0o100000, c
				case "incb":
					xb++
					n, z, v, c = int8(xb) < 0, xb == 0, xb == 0o200, c
				case "dec":
					x--
					n, z, v, c = int16(x) < 0, x == 0, x == 0o077777, c
				case "decb":
					xb--
					n, z, v, c = int8(xb) < 0, xb == 0, xb == 0o177, c
				case "neg":
					x = -x
					n, z, v, c = int16(x) < 0, x == 0, x == 0o100000, x != 0
				case "negb":
					xb = -xb
					n, z, v, c = int8(xb) < 0, xb == 0, xb == 0o200, xb != 0
				case "adc":
					x += bit(c)
					n, z, v, c = int16(x) < 0, x == 0, c && x == 0o100000, c && x == 0
				case "adcb":
					xb += uint8(bit(c))
					n, z, v, c = int8(xb) < 0, xb == 0, c && xb == 0o200, c && xb == 0
				case "sbc":
					// TODO manual
					x -= bit(c)
					n, z, v, c = int16(x) < 0, x == 0, x+bit(c) == 0o100000, c && x == 0o177777
				case "sbcb":
					// TODO apout uses new xb == 0o200
					xb -= uint8(bit(c))
					n, z, v, c = int8(xb) < 0, xb == 0, xb+uint8(bit(c)) == 0o200, c && xb == 0o377
				case "tst":
					n, z, v, c = int16(x) < 0, x == 0, false, false
				case "tstb":
					n, z, v, c = int8(xb) < 0, xb == 0, false, false
				case "ror":
					x = x>>1 | bit(c)<<15
					n, z, c = int16(x) < 0, x == 0, ox&1 != 0
					v = n != c
				case "rorb":
					xb = xb>>1 | uint8(bit(c))<<7
					n, z, c = int8(xb) < 0, xb == 0, ox&1 != 0
					v = n != c
				case "rol":
					x = x<<1 | bit(c)
					n, z, c = int16(x) < 0, x == 0, ox>>15 != 0
					v = n != c
				case "rolb":
					xb = xb<<1 | uint8(bit(c))
					n, z, c = int8(xb) < 0, xb == 0, oxb>>7 != 0
					v = n != c
				case "asr":
					x = uint16(int16(x) >> 1)
					n, z, c = int16(x) < 0, x == 0, ox&1 != 0
					v = n != c
				case "asrb":
					xb = uint8(int8(xb) >> 1)
					n, z, c = int8(xb) < 0, xb == 0, ox&1 != 0
					v = n != c
				case "asl":
					x <<= 1
					n, z, c = int16(x) < 0, x == 0, ox>>15 != 0
					v = n != c
				case "aslb":
					xb <<= 1
					n, z, c = int8(xb) < 0, xb == 0, oxb>>7 != 0
					v = n != c
				case "sxt":
					if n {
						x = 0o177777
					} else {
						x = 0
					}
					n, z = int16(x) < 0, x == 0
				}
				fmt.Fprintf(&b, "now")
				if len(op) == 4 && op != "swab" {
					x = x>>8<<8 | uint16(xb)
				}
				if x != 0 {
					fmt.Fprintf(&b, " r1=%06o", x)
				} else {
					if !n && !z && !v && !c {
						fmt.Fprintf(&b, " ~")
					}
				}
				if n || z || v || c {
					fmt.Fprintf(&b, " nzvc=%d%d%d%d", bit(n), bit(z), bit(v), bit(c))
				}
				fmt.Fprint(&b, "\n")
			}
		}

		if err := os.WriteFile("exec_"+op+".txt", b.Bytes(), 0666); err != nil {
			log.Fatal(err)
		}
	}
}

func bit(b bool) uint16 {
	if b {
		return 1
	}
	return 0
}
